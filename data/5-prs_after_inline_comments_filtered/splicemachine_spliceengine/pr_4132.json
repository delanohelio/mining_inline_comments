{"pr_number": 4132, "pr_title": "DB-10049 user-defined statement separator in sqlshell.", "pr_createdAt": "2020-09-16T09:56:26Z", "pr_url": "https://github.com/splicemachine/spliceengine/pull/4132", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU5NTU3NA==", "url": "https://github.com/splicemachine/spliceengine/pull/4132#discussion_r492595574", "bodyText": "return missing", "author": "martinrupp", "createdAt": "2020-09-22T09:27:05Z", "path": "db-tools-ij/src/main/java/com/splicemachine/db/impl/tools/ij/utilMain.java", "diffHunk": "@@ -692,206 +667,185 @@ private void checkScrollableCursor(ResultSet rs, String operation)\n         }\n     }\n \n-\t/**\n-\t * Position on the specified row of the specified ResultSet.\n-\t *\n-\t * @param rs\tThe specified ResultSet.\n-\t * @param row\tThe row # to move to.\n-\t *\t\t\t\t(Negative means from the end of the result set.)\n-\t *\n-\t * @return\tNULL.\n-\t *\n-\t * @exception\tSQLException thrown on error.\n-\t *\t\t\t\t(absolute() not supported pre-JDBC2.0)\n-\t */\n-\tijResult absolute(ResultSet rs, int row)\n-\t\tthrows SQLException\n-\t{\n+    /**\n+     * Position on the specified row of the specified ResultSet.\n+     *\n+     * @param rs  The specified ResultSet.\n+     * @param row The row # to move to.\n+     *            (Negative means from the end of the result set.)\n+     * @return NULL.\n+     * @exception SQLException thrown on error.\n+     * (absolute() not supported pre-JDBC2.0)\n+     */\n+    ijResult absolute(ResultSet rs, int row)\n+            throws SQLException {\n         checkScrollableCursor(rs, \"ABSOLUTE\");\n-\t\t// 0 is an *VALID* value for row\n-\t\treturn new ijRowResult(rs, rs.absolute(row));\n-\t}\n-\n-\t/**\n-\t * Move the cursor position by the specified amount.\n-\t *\n-\t * @param rs\tThe specified ResultSet.\n-\t * @param row\tThe # of rows to move.\n-\t *\t\t\t\t(Negative means toward the beginning of the result set.)\n-\t *\n-\t * @return\tNULL.\n-\t *\n-\t * @exception\tSQLException thrown on error.\n-\t *\t\t\t\t(relative() not supported pre-JDBC2.0)\n-\t */\n-\tijResult relative(ResultSet rs, int row)\n-\t\tthrows SQLException\n-\t{\n+        // 0 is an *VALID* value for row\n+        return new ijRowResult(rs, rs.absolute(row));\n+    }\n+\n+    /**\n+     * Move the cursor position by the specified amount.\n+     *\n+     * @param rs  The specified ResultSet.\n+     * @param row The # of rows to move.\n+     *            (Negative means toward the beginning of the result set.)\n+     * @return NULL.\n+     * @exception SQLException thrown on error.\n+     * (relative() not supported pre-JDBC2.0)\n+     */\n+    ijResult relative(ResultSet rs, int row)\n+            throws SQLException {\n         checkScrollableCursor(rs, \"RELATIVE\");\n-\t\treturn new ijRowResult(rs, rs.relative(row));\n-\t}\n-\n-\t/**\n-\t * Position before the first row of the specified ResultSet\n-\t * and return NULL to the user.\n-\t *\n-\t * @param rs\tThe specified ResultSet.\n-\t *\n-\t * @return\tNULL.\n-\t *\n-\t * @exception\tSQLException thrown on error.\n-\t *\t\t\t\t(beforeFirst() not supported pre-JDBC2.0)\n-\t */\n-\tijResult beforeFirst(ResultSet rs)\n-\t\tthrows SQLException\n-\t{\n+        return new ijRowResult(rs, rs.relative(row));\n+    }\n+\n+    /**\n+     * Position before the first row of the specified ResultSet\n+     * and return NULL to the user.\n+     *\n+     * @param rs The specified ResultSet.\n+     * @return NULL.\n+     * @exception SQLException thrown on error.\n+     * (beforeFirst() not supported pre-JDBC2.0)\n+     */\n+    ijResult beforeFirst(ResultSet rs)\n+            throws SQLException {\n         checkScrollableCursor(rs, \"BEFORE FIRST\");\n-\t\trs.beforeFirst();\n-\t\treturn new ijRowResult(rs, false);\n-\t}\n-\n-\t/**\n-\t * Position on the first row of the specified ResultSet\n-\t * and return that row to the user.\n-\t *\n-\t * @param rs\tThe specified ResultSet.\n-\t *\n-\t * @return\tThe first row of the ResultSet.\n-\t *\n-\t * @exception\tSQLException thrown on error.\n-\t *\t\t\t\t(first() not supported pre-JDBC2.0)\n-\t */\n-\tijResult first(ResultSet rs)\n-\t\tthrows SQLException\n-\t{\n+        rs.beforeFirst();\n+        return new ijRowResult(rs, false);\n+    }\n+\n+    /**\n+     * Position on the first row of the specified ResultSet\n+     * and return that row to the user.\n+     *\n+     * @param rs The specified ResultSet.\n+     * @return The first row of the ResultSet.\n+     * @exception SQLException thrown on error.\n+     * (first() not supported pre-JDBC2.0)\n+     */\n+    ijResult first(ResultSet rs)\n+            throws SQLException {\n         checkScrollableCursor(rs, \"FIRST\");\n-\t\treturn new ijRowResult(rs, rs.first());\n-\t}\n-\n-\t/**\n-\t * Position after the last row of the specified ResultSet\n-\t * and return NULL to the user.\n-\t *\n-\t * @param rs\tThe specified ResultSet.\n-\t *\n-\t * @return\tNULL.\n-\t *\n-\t * @exception\tSQLException thrown on error.\n-\t *\t\t\t\t(afterLast() not supported pre-JDBC2.0)\n-\t */\n-\tijResult afterLast(ResultSet rs)\n-\t\tthrows SQLException\n-\t{\n+        return new ijRowResult(rs, rs.first());\n+    }\n+\n+    /**\n+     * Position after the last row of the specified ResultSet\n+     * and return NULL to the user.\n+     *\n+     * @param rs The specified ResultSet.\n+     * @return NULL.\n+     * @exception SQLException thrown on error.\n+     * (afterLast() not supported pre-JDBC2.0)\n+     */\n+    ijResult afterLast(ResultSet rs)\n+            throws SQLException {\n         checkScrollableCursor(rs, \"AFTER LAST\");\n-\t\trs.afterLast();\n-\t\treturn new ijRowResult(rs, false);\n-\t}\n-\n-\t/**\n-\t * Position on the last row of the specified ResultSet\n-\t * and return that row to the user.\n-\t *\n-\t * @param rs\tThe specified ResultSet.\n-\t *\n-\t * @return\tThe last row of the ResultSet.\n-\t *\n-\t * @exception\tSQLException thrown on error.\n-\t *\t\t\t\t(last() not supported pre-JDBC2.0)\n-\t */\n-\tijResult last(ResultSet rs)\n-\t\tthrows SQLException\n-\t{\n+        rs.afterLast();\n+        return new ijRowResult(rs, false);\n+    }\n+\n+    /**\n+     * Position on the last row of the specified ResultSet\n+     * and return that row to the user.\n+     *\n+     * @param rs The specified ResultSet.\n+     * @return The last row of the ResultSet.\n+     * @exception SQLException thrown on error.\n+     * (last() not supported pre-JDBC2.0)\n+     */\n+    ijResult last(ResultSet rs)\n+            throws SQLException {\n         checkScrollableCursor(rs, \"LAST\");\n-\t\treturn new ijRowResult(rs, rs.last());\n-\t}\n-\n-\t/**\n-\t * Position on the previous row of the specified ResultSet\n-\t * and return that row to the user.\n-\t *\n-\t * @param rs\tThe specified ResultSet.\n-\t *\n-\t * @return\tThe previous row of the ResultSet.\n-\t *\n-\t * @exception\tSQLException thrown on error.\n-\t *\t\t\t\t(previous() not supported pre-JDBC2.0)\n-\t */\n-\tijResult previous(ResultSet rs)\n-\t\tthrows SQLException\n-\t{\n+        return new ijRowResult(rs, rs.last());\n+    }\n+\n+    /**\n+     * Position on the previous row of the specified ResultSet\n+     * and return that row to the user.\n+     *\n+     * @param rs The specified ResultSet.\n+     * @return The previous row of the ResultSet.\n+     * @exception SQLException thrown on error.\n+     * (previous() not supported pre-JDBC2.0)\n+     */\n+    ijResult previous(ResultSet rs)\n+            throws SQLException {\n         checkScrollableCursor(rs, \"PREVIOUS\");\n-\t\treturn new ijRowResult(rs, rs.previous());\n-\t}\n-\n-\t/**\n-\t * Get the current row number\n-\t *\n-\t * @param rs\tThe specified ResultSet.\n-\t *\n-\t * @return\tThe current row number\n-\t *\n-\t * @exception\tSQLException thrown on error.\n-\t *\t\t\t\t(getRow() not supported pre-JDBC2.0)\n-\t */\n-\tint getCurrentRowNumber(ResultSet rs)\n-\t\tthrows SQLException\n-\t{\n+        return new ijRowResult(rs, rs.previous());\n+    }\n+\n+    /**\n+     * Get the current row number\n+     *\n+     * @param rs The specified ResultSet.\n+     * @return The current row number\n+     * @exception SQLException thrown on error.\n+     * (getRow() not supported pre-JDBC2.0)\n+     */\n+    int getCurrentRowNumber(ResultSet rs)\n+            throws SQLException {\n         checkScrollableCursor(rs, \"GETCURRENTROWNUMBER\");\n-\t\treturn rs.getRow();\n-\t}\n-\n-\tpublic final Object run() {\n-\t\treturn  getClass().getResourceAsStream(ProductGenusNames.TOOLS_INFO);\n-\t}\n-\n-\tpublic static void setPromptClock(boolean showPromptClock) {\n-\t\tutilMain.showPromptClock = showPromptClock;\n-\t}\n-\n-\t@SuppressFBWarnings(value = \"RV_RETURN_VALUE_IGNORED_BAD_PRACTICE\",justification = \"Intentional, we don't care if the file already exists\")\n-\tpublic void startSpooling(String path) throws IOException {\n-\t\ttry {\n-\t\t\tlogFileName = path;\n-\t\t\tFile f = new File(logFileName);\n-\t\t\tif(!f.exists()) {\n-\t\t\t\tf.createNewFile(); // create if not exists, no-op if file exists.\n-\t\t\t\tout.println(langUtil.getTextMessage(\"IJ_SpoolNewFile\", path));\n-\t\t\t} else if(f.exists() && f.canWrite() && !f.isDirectory()) {\n-\t\t\t\tout.println(langUtil.getTextMessage(\"IJ_SpoolFileAlreadyExistsWarning\", path));\n-\t\t\t} else {\n-\t\t\t\tout.println(langUtil.getTextMessage(\"IJ_SpoolError\", path));\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\tthis.out.close();\n-\t\t\tthis.out = new LocalizedOutput(new ForkOutputStream(new FileOutputStream(f)));\n-\t\t\tdoSpool = true;\n-\t\t} catch (IOException e) {\n-\t\t\tout.println(langUtil.getTextMessage(\"IJ_SpoolError\", path));\n-\t\t}\n-\t}\n-\n-\tpublic void stopSpooling() {\n-\t\tif(!doSpool) {\n-\t\t\tout.println(langUtil.getTextMessage(\"IJ_SpoolNotActive\"));\n-\t\t} else {\n-\t\t\tdoSpool = false;\n-\t\t\tthis.out.flush();\n-\t\t\tthis.out.close();\n-\t\t\tthis.out = new LocalizedOutput(System.out);\n-\t\t}\n-\t}\n-\n-\tpublic void clearSpooling() throws IOException {\n-\t\tif(doSpool)\n-\t\t{\n-\t\t\tPrintWriter pw = new PrintWriter(logFileName, \"UTF-8\");\n-\t\t\tpw.close();\n-\t\t} else {\n-\t\t\tout.println(langUtil.getTextMessage(\"IJ_SpoolNotActive\"));\n-\t\t}\n-\t}\n-\n-\tpublic void setOmitHeader(boolean omitHeader) {\n-\t\tthis.omitHeader = omitHeader;\n-\t}\n+        return rs.getRow();\n+    }\n+\n+    public final Object run() {\n+        return getClass().getResourceAsStream(ProductGenusNames.TOOLS_INFO);\n+    }\n+\n+    @SuppressFBWarnings(value = \"RV_RETURN_VALUE_IGNORED_BAD_PRACTICE\", justification = \"Intentional, we don't care if the file already exists\")\n+    public void startSpooling(String path) throws IOException {\n+        try {\n+            logFileName = path;\n+            File f = new File(logFileName);\n+            if (!f.exists()) {\n+                f.createNewFile(); // create if not exists, no-op if file exists.\n+                out.println(langUtil.getTextMessage(\"IJ_SpoolNewFile\", path));\n+            } else if (f.exists() && f.canWrite() && !f.isDirectory()) {\n+                out.println(langUtil.getTextMessage(\"IJ_SpoolFileAlreadyExistsWarning\", path));\n+            } else {\n+                out.println(langUtil.getTextMessage(\"IJ_SpoolError\", path));\n+                return;\n+            }\n+            this.out.close();\n+            this.out = new LocalizedOutput(new ForkOutputStream(new FileOutputStream(f)));\n+            doSpool = true;\n+        } catch (IOException e) {\n+            out.println(langUtil.getTextMessage(\"IJ_SpoolError\", path));\n+        }\n+    }\n+\n+    public void stopSpooling() {\n+        if (!doSpool) {\n+            out.println(langUtil.getTextMessage(\"IJ_SpoolNotActive\"));\n+        } else {\n+            doSpool = false;\n+            this.out.flush();\n+            this.out.close();\n+            this.out = new LocalizedOutput(System.out);\n+        }\n+    }\n+\n+    public void clearSpooling() throws IOException {\n+        if (doSpool) {\n+            PrintWriter pw = new PrintWriter(logFileName, \"UTF-8\");\n+            pw.close();\n+        } else {\n+            out.println(langUtil.getTextMessage(\"IJ_SpoolNotActive\"));\n+        }\n+    }\n+\n+    public void setOmitHeader(boolean omitHeader) {\n+        this.omitHeader = omitHeader;\n+    }\n+\n+    public void setTerminator(String terminator) {\n+        if (terminator.length() != 1 || !StatementFinder.isValidTerminator(terminator.charAt(0))) {\n+            out.println(langUtil.getTextMessage(\"IJ_TerminatorInvalid\", terminator));\n+        }", "originalCommit": "48a646d057393fffaf29e7c029e42f866c7cfb78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU5NTk2NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4132#discussion_r492595965", "bodyText": "e.g. this fails\nset terminator ',';\nshow tables;", "author": "martinrupp", "createdAt": "2020-09-22T09:27:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU5NTU3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU5Mzg4Mg==", "url": "https://github.com/splicemachine/spliceengine/pull/4132#discussion_r499593882", "bodyText": "Thanks Martin, fixed.", "author": "hatyo", "createdAt": "2020-10-05T13:22:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU5NTU3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA0NzE2Ng==", "url": "https://github.com/splicemachine/spliceengine/pull/4132#discussion_r500047166", "bodyText": "(minor comment) also ; is an ASCII character... i think you mean Character.isLetter(terminator)", "author": "martinrupp", "createdAt": "2020-10-06T07:00:46Z", "path": "db-tools-ij/src/main/java/com/splicemachine/db/impl/tools/ij/StatementFinder.java", "diffHunk": "@@ -31,549 +31,567 @@\n \n package com.splicemachine.db.impl.tools.ij;\n \n-import com.splicemachine.db.iapi.tools.i18n.LocalizedOutput;\n import com.splicemachine.db.iapi.tools.i18n.LocalizedInput;\n+import com.splicemachine.db.iapi.tools.i18n.LocalizedOutput;\n \n import java.io.IOException;\n import java.io.Reader;\n+import java.util.ArrayList;\n \n /**\n-\tStatementGrabber looks through an input stream for\n-\tthe next JSQL statement.  A statement is considered to\n-\tbe any tokens up to the next semicolon or EOF.\n-\t<p>\n-\tSemicolons inside comments, strings, and delimited identifiers\n-\tare not considered to be statement terminators but to be\n-\tpart of those tokens.\n-\t<p>\n-    Comments currently recognized include the SQL comment,\n-    which begins with \"--\" and ends at the next EOL, and nested\n-    bracketed comments.\n-\t<p>\n-\tStrings and delimited identifiers are permitted to contain\n-\tnewlines; the actual IJ or JSQL parsers will report errors when\n-\tthose cases occur.\n-\t<p>\n-\tThere are no escaped characters, i.e. \"\\n\" is considered to\n-\tbe two characters, '\\' and 'n'.\n-\n+ * StatementGrabber looks through an input stream for\n+ * the next JSQL statement.  A statement is considered to\n+ * be any tokens up to the next user-defined terminator or EOF.\n+ * <p>\n+ * Semicolons inside comments, strings, and delimited identifiers\n+ * are not considered to be statement terminators but to be\n+ * part of those tokens.\n+ * <p>\n+ * Comments currently recognized include the SQL comment,\n+ * which begins with \"--\" and ends at the next EOL, and nested\n+ * bracketed comments.\n+ * <p>\n+ * Strings and delimited identifiers are permitted to contain\n+ * newlines; the actual IJ or JSQL parsers will report errors when\n+ * those cases occur.\n+ * <p>\n+ * There are no escaped characters, i.e. \"\\n\" is considered to\n+ * be two characters, '\\' and 'n'.\n  */\n-\n public class StatementFinder {\n \n-\tprivate Reader source; \n-\tprivate StringBuffer statement = new StringBuffer();\n-\tprivate int state;\n-\tprivate boolean atEOF = false;\n-\tprivate boolean peekEOF = false;\n-\tprivate char peekChar;\n-\tprivate boolean peeked = false;\n-\tprivate LocalizedOutput promptwriter;\n-\tprivate boolean doPrompt;\n-\tprivate boolean continuedStatement;\n-\n-\t// state variables\n-\tprivate static final int IN_STATEMENT = 0;\n-\tprivate static final int IN_STRING = 1;\n-\tprivate static final int IN_SQLCOMMENT = 2;\n-\tprivate static final int END_OF_STATEMENT = 3;\n-\tprivate static final int END_OF_INPUT = 4;\n-\n-\t// special state-changing characters\n-\tprivate static final char MINUS = '-';\n-\tprivate static final char SINGLEQUOTE = '\\'';\n-\tprivate static final char DOUBLEQUOTE = '\\\"';\n-\tprivate static final char SEMICOLON = ';';\n-\tprivate static final char NEWLINE = '\\n';\n-\tprivate static final char RETURN = '\\r';\n-\tprivate static final char SPACE = ' ';\n-\tprivate static final char TAB = '\\t';\n-\tprivate static final char FORMFEED = '\\f';\n-\tprivate static final char SLASH = '/';\n-\tprivate static final char ASTERISK = '*';\n-\n-\n-\tprivate static final char LITTLE_A = 'a';\n-\tprivate static final char LITTLE_T = 't';\n-\tprivate static final char LITTLE_O = 'o';\n-\tprivate static final char LITTLE_M = 'm';\n-\tprivate static final char LITTLE_I = 'i';\n-\tprivate static final char LITTLE_C = 'c';\n-\n-\tprivate static final char LITTLE_E = 'e';\n-\tprivate static final char LITTLE_N = 'n';\n-\tprivate static final char LITTLE_D = 'd';\n-\n-\tprivate static final char BIG_A = 'A';\n-\tprivate static final char BIG_T = 'T';\n-\tprivate static final char BIG_O = 'O';\n-\tprivate static final char BIG_M = 'M';\n-\tprivate static final char BIG_I = 'I';\n-\tprivate static final char BIG_C = 'C';\n-\n-\tprivate static final char BIG_E = 'E';\n-\tprivate static final char BIG_N = 'N';\n-\tprivate static final char BIG_D = 'D';\n-\n-\n-\t// state variables\n-\tprivate static final int NOT_IN_BEGIN_BLOCK = 0;\n-\tprivate static final int IN_BEGIN_BLOCK = 1;\n-\tprivate static final int IN_BEGIN_BLOCK_SEMICOLON_SEEN = 2;\n-\n-\t// trigger parsing state\n-        private static final int WHITESPACE_SEEN = 0;\n-        private static final int E_SEEN = 1;\n-        private static final int EN_SEEN = 2;\n-\n-        private static final int A_SEEN = 3;\n-        private static final int AT_SEEN = 4;\n-\tprivate static final int ATO_SEEN = 5;\n-\tprivate static final int ATOM_SEEN = 6;\n-\tprivate static final int ATOMI_SEEN = 7;\n-        private static final int NOTHING_SEEN = 8;\n-\n-\n-\t/**\n-\t\tThe constructor does not assume the stream is data input\n-\t\tor buffered, so it will wrap it appropriately.\n-\n-\t\tIf the StatementFinder's input stream is connected to\n-\t\tSystem.in, a LocalizedOutput stream may be given to print\n-\t\tline continuation prompts when StatementFinder reads a newline.\n-\n-\t\t@param s the input stream for reading statements from.\n-\t\t@param promptDest LocalizedOutput stream to write line\n-\t\t\t\t\t\tcontinuation prompts (\"> \") to. If null,\n-\t\t\t\t\t\tno such prompts will be written.\n-\t */\n-\tpublic StatementFinder(LocalizedInput s, LocalizedOutput promptDest) {\n-\t\tsource = s;\n-\t\tif(promptDest != null && s.isStandardInput()) {\n-\t\t\tpromptwriter = promptDest;\n-\t\t\tdoPrompt = true;\n-\t\t} else {\n-\t\t\tdoPrompt = false;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t\tReinit is used to redirect the finder to another stream.\n-\t\tThe previous stream should not have been in a PEEK state.\n-\n-\t\tIf an output stream was given when constructing this \n-\t\tStatementFinder and the input is standard input, \n-\t\tcontinuation prompting will be enabled.\n-\n-\t\t@param s the input stream for reading statements from.\n-\t */\n-\tpublic void reInit(LocalizedInput s) {\n-\t    try {\n-\t\t\tsource.close();\n-\t\t} catch (IOException ioe) {\n-\t\t\t// just be quiet if it is already gone\n-\t\t}\n-\t\tsource = s;\n-\t\tstate = IN_STATEMENT;\n-\t\tatEOF = false;\n-\t\tpeekEOF = false;\n-\t\tpeeked = false;\n-\t\tdoPrompt = s.isStandardInput() && promptwriter != null;\n-\t}\n-\n-\tpublic void close() throws IOException {\n-\t\tsource.close();\n-\t}\n-\n-\t/**\n-\t\tget the next statement in the input stream. Returns it,\n-\t\tdropping its closing semicolon if it has one. If there is\n-\t\tno next statement, return a null.\n-\n-\t\t@return the next statement in the input stream.\n-\t */\n-\tpublic String nextStatement() {\n-\t\tboolean haveSemi = false;\n-\t\tchar nextChar;\n-\t\tint triggerState = NOT_IN_BEGIN_BLOCK;\n-\t\tint triggerParseState = WHITESPACE_SEEN;\n-\n-\t\t// initialize fields for getting the next statement\n-\t\tstatement.setLength(0);\n-\t\tif (state == END_OF_INPUT) return null;\n-\n-\t\tstate = IN_STATEMENT;\n-\n-\t\t// skip leading whitespace\n-\t\tnextChar = peekChar();\n-\t\tif (peekEOF()) {\n-\t\t\tstate = END_OF_INPUT;\n-\t\t\treturn null;\n-\t\t}\n-\t\tif (whiteSpace(nextChar)) {\n-\t\t\twhile (whiteSpace(peekChar()) && ! peekEOF());\n-\t\t\tif (peekEOF()) {\n-\t\t\t\tstate = END_OF_INPUT;\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t}\n-\n-\t\twhile (state != END_OF_STATEMENT && state != END_OF_INPUT) {\n-\n-\t\t\t// get the next character from the input\n-\t\t\tnextChar = readChar();\n-\t\t\tif (atEOF()) {\n-\t\t\t\tstate = END_OF_INPUT;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t\t\n-\t\t\tif (!(nextChar == MINUS))\n-\t\t\t\tcontinuedStatement=true;\n-\n-\t\t\tswitch(nextChar) {\n-\t\t\t\tcase SPACE:\n-\t\t\t\tcase TAB:\n-\t\t\t\tcase FORMFEED:\n-\t\t\t\t\ttriggerParseState = WHITESPACE_SEEN;\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase LITTLE_A:\n-\t\t\t\tcase BIG_A:\n-\t\t\t\t\tif (triggerParseState == WHITESPACE_SEEN)\n-\t\t\t\t\t\ttriggerParseState = A_SEEN;\n-\t\t\t\t\telse\n-\t\t\t\t\t\ttriggerParseState = NOTHING_SEEN;\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase LITTLE_T:\n-\t\t\t\tcase BIG_T:\n-\t\t\t\t\tif (triggerParseState == A_SEEN)\n-\t\t\t\t\t\ttriggerParseState = AT_SEEN;\n-\t\t\t\t\telse\n-\t\t\t\t\t\ttriggerParseState = NOTHING_SEEN;\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase LITTLE_O:\n-\t\t\t\tcase BIG_O:\n-\t\t\t\t\tif (triggerParseState == AT_SEEN)\n-\t\t\t\t\t\ttriggerParseState = ATO_SEEN;\n-\t\t\t\t\telse\n-\t\t\t\t\t\ttriggerParseState = NOTHING_SEEN;\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase LITTLE_M:\n-\t\t\t\tcase BIG_M:\n-\t\t\t\t\tif (triggerParseState == ATO_SEEN)\n-\t\t\t\t\t\ttriggerParseState = ATOM_SEEN;\n-\t\t\t\t\telse\n-\t\t\t\t\t\ttriggerParseState = NOTHING_SEEN;\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase LITTLE_I:\n-\t\t\t\tcase BIG_I:\n-\t\t\t\t\tif (triggerParseState == ATOM_SEEN)\n-\t\t\t\t\t\ttriggerParseState = ATOMI_SEEN;\n-\t\t\t\t\telse\n-\t\t\t\t\t\ttriggerParseState = NOTHING_SEEN;\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase LITTLE_C:\n-\t\t\t\tcase BIG_C:\n-\t\t\t\t\tif (triggerParseState == ATOMI_SEEN)\n-\t\t\t\t\t\ttriggerState = IN_BEGIN_BLOCK;\n-\t\t\t\t\ttriggerParseState = NOTHING_SEEN;\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase LITTLE_E:\n-\t\t\t\tcase BIG_E:\n-\t\t\t\t\tif (triggerState == IN_BEGIN_BLOCK_SEMICOLON_SEEN && triggerParseState == WHITESPACE_SEEN)\n-\t\t\t\t\t\ttriggerParseState = E_SEEN;\n-\t\t\t\t\telse\n-\t\t\t\t\t\ttriggerParseState = NOTHING_SEEN;\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase LITTLE_N:\n-\t\t\t\tcase BIG_N:\n-\t\t\t\t\tif (triggerState == IN_BEGIN_BLOCK_SEMICOLON_SEEN && triggerParseState == E_SEEN)\n-\t\t\t\t\t\ttriggerParseState = EN_SEEN;\n-\t\t\t\t\telse\n-\t\t\t\t\t\ttriggerParseState = NOTHING_SEEN;\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase LITTLE_D:\n-\t\t\t\tcase BIG_D:\n-\t\t\t\t\tif (triggerState == IN_BEGIN_BLOCK_SEMICOLON_SEEN && triggerParseState == EN_SEEN) {\n-\t\t\t\t\t\ttriggerState = NOT_IN_BEGIN_BLOCK;\n-\t\t\t\t\t}\n-\t\t\t\t\ttriggerParseState = NOTHING_SEEN;\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase MINUS:\n-\t\t\t\t\treadSingleLineComment(nextChar);\n-\t\t\t\t\ttriggerParseState = WHITESPACE_SEEN;\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase SLASH:\n-\t\t\t\t\treadBracketedComment();\n-\t\t\t\t\ttriggerParseState = WHITESPACE_SEEN;\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase SINGLEQUOTE:\n-\t\t\t\tcase DOUBLEQUOTE:\n-\t\t\t\t\treadString(nextChar);\n-\t\t\t\t\ttriggerParseState = NOTHING_SEEN;\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase SEMICOLON:\n-\t\t\t\t\tif (triggerState == NOT_IN_BEGIN_BLOCK || peekChar() == SEMICOLON) {\n-\t\t\t\t\t\thaveSemi = true;\n-\t\t\t\t\t\tstate = END_OF_STATEMENT;\n-\t\t\t\t\t\tcontinuedStatement = false;\n-\t\t\t\t\t}\n-\t\t\t\t\tif (triggerState == IN_BEGIN_BLOCK)\n-\t\t\t\t\t\ttriggerState = IN_BEGIN_BLOCK_SEMICOLON_SEEN;\n-\t\t\t\t\ttriggerParseState = WHITESPACE_SEEN;\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase NEWLINE:\n-\t\t\t\tcase RETURN:\n-\t\t\t\t\tif(doPrompt) {\n-\t\t\t\t\t\tutilMain.doPrompt(false, promptwriter, \"\");\n-\t\t\t\t\t\t/* If the next character is a newline as well,\n-\t\t\t\t\t\t   we swallow it to avoid double prompting on\n-\t\t\t\t\t\t   Windows. */\n-\t\t\t\t\t\tif(nextChar == RETURN && peekChar() == NEWLINE) {\n-\t\t\t\t\t\t\treadChar();\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\ttriggerParseState = WHITESPACE_SEEN;\n-\t\t\t\t\tbreak;\n-\t\t\t\tdefault:\n-\t\t\t\t\ttriggerParseState = NOTHING_SEEN;\n-\t\t\t\t\t// keep going, just a normal character\n-\t\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (haveSemi)\n-\t\t\tstatement.setLength(statement.length()-1);\n-\t\treturn statement.toString();\n-\t}\n-\n-\t/**\n-\t\tDetermine if the given character is considered whitespace\n-\n-\t\t@param c the character to consider\n-\t\t@return true if the character is whitespace\n-\t */\n-\tprivate boolean whiteSpace(char c) {\n-\t\treturn (c == SPACE ||\n-\t\t    \tc == TAB ||\n-\t\t    \tc == RETURN ||\n-\t\t    \tc == NEWLINE ||\n-\t\t    \tc == FORMFEED);\n-\t}\n-\n-\t/**\n-\t \t* Advance the source stream to the end of a comment\n-\t\t* if it is on one, assuming the first character of\n-\t\t* a potential bracketed comment has been found.\n-\t\t* If it is not a comment, do not advance the stream.\n-\t */\n-\tprivate void readBracketedComment() {\n-\t\tchar nextChar = peekChar();\n-\n-\t\t// if next char is EOF, we are done.\n-\t\tif (peekEOF()) return;\n-\n-\t\t// if nextChar is not an asterisk, then not a comment.\n-\t\tif (nextChar != ASTERISK)\n-\t\t{\n-\t\t\tcontinuedStatement = true;\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// we are really in a comment\n-\t\treadChar(); // grab the asterisk for real.\n-\n-\t\tint nestingLevel = 1;\n-\n-\t\twhile (true) {\n-\t\t\tnextChar = readChar();\n-\n-\t\t\tif (atEOF()) {\n-\t\t\t\t// let the caller process the EOF, don't read it\n-\t\t\t\tstate = IN_STATEMENT;\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\tchar peek = peekChar();\n-\n-\t\t\tif (nextChar == SLASH && peek == ASTERISK) {\n-\t\t\t\treadChar();\n-\t\t\t\tnestingLevel++;\n-\t\t\t} else if (nextChar == ASTERISK && peek == SLASH) {\n-\t\t\t\treadChar();\n-\t\t\t\tnestingLevel--;\n-\t\t\t\tif (nestingLevel == 0) {\n-\t\t\t\t\tstate = IN_STATEMENT;\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t} else if (nextChar == NEWLINE || nextChar == RETURN) {\n-\t\t\t\tif (doPrompt) {\n-\t\t\t\t\tutilMain.doPrompt(false, promptwriter, \"\");\n-\t\t\t\t\t// If the next character is a NEWLINE, we process\n-\t\t\t\t\t// it as well to account for Windows CRLFs.\n-\t\t\t\t\tif (nextChar == RETURN && peek == NEWLINE) {\n-\t\t\t\t\t\treadChar();\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t\tAdvance the source stream to the end of a comment if it\n-\t\tis on one, assuming the first character of\n-\t\ta potential single line comment has been found.\n-\t\tIf it is not a comment, do not advance the stream.\n-\t\t<p>\n-\t\tThe form of a single line comment is, in regexp, XX.*$,\n-\t\twhere XX is two instances of commentChar.\n-\n-\t\t@param commentChar the character whose duplication signifies\n-\t\t\tthe start of the comment.\n-\t */\n-\tprivate void readSingleLineComment(char commentChar) {\n-\t\tchar nextChar;\n-\n-\t\tnextChar = peekChar();\n-\t\t// if next char is EOF, we are done.\n-\t\tif (peekEOF()) return;\n-\n-\t\t// if nextChar is not a minus, it was just a normal minus,\n-\t\t// nothing special to do\n-\t\tif (nextChar != commentChar)\n-\t\t{\n-\t\t\tcontinuedStatement=true;\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// we are really in a comment\n-\t\treadChar(); // grab the minus for real.\n-\n-\t\tstate = IN_SQLCOMMENT;\n-\t\tdo {\n-\t\t\tnextChar = peekChar();\n-\t\t\tif (peekEOF()) {\n-\t\t\t\t// let the caller process the EOF, don't read it\n-\t\t\t\tstate = IN_STATEMENT;\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\tswitch (nextChar) {\n-\t\t\t\tcase NEWLINE:\n-\t\t\t\tcase RETURN:\n-\t\t\t\t\treadChar(); // okay to process the character\n-\t\t\t\t\tstate = IN_STATEMENT;\n-\t\t\t\t\tif (doPrompt){\n-\t\t\t\t\t\t// If we had previously already started a statement,\n-\t\t\t\t\t\t// add the prompt.\n-\t\t\t\t\t\t// Otherwise, consider this a single line comment,\n-\t\t\t\t\t\t// and the next line should not get a prompt\n-\t\t\t\t\t\tif (continuedStatement)\n-\t\t\t\t\t\t\tutilMain.doPrompt(false, promptwriter, \"\");\n+    // state variables\n+    private static final int IN_STATEMENT = 0;\n+    private static final int IN_STRING = 1;\n+    private static final int IN_SQLCOMMENT = 2;\n+    private static final int END_OF_STATEMENT = 3;\n+    private static final int END_OF_INPUT = 4;\n+    // special state-changing characters\n+    private static final char MINUS = '-';\n+    private static final char SINGLEQUOTE = '\\'';\n+    private static final char DOUBLEQUOTE = '\\\"';\n+    public static final char SEMICOLON = ';';\n+    private static final char NEWLINE = '\\n';\n+    private static final char RETURN = '\\r';\n+    private static final char SPACE = ' ';\n+    private static final char TAB = '\\t';\n+    private static final char FORMFEED = '\\f';\n+    private static final char SLASH = '/';\n+    private static final char ASTERISK = '*';\n+    private static final char LITTLE_A = 'a';\n+    private static final char LITTLE_T = 't';\n+    private static final char LITTLE_O = 'o';\n+    private static final char LITTLE_M = 'm';\n+    private static final char LITTLE_I = 'i';\n+    private static final char LITTLE_C = 'c';\n+    private static final char LITTLE_E = 'e';\n+    private static final char LITTLE_N = 'n';\n+    private static final char LITTLE_D = 'd';\n+    private static final char BIG_A = 'A';\n+    private static final char BIG_T = 'T';\n+    private static final char BIG_O = 'O';\n+    private static final char BIG_M = 'M';\n+    private static final char BIG_I = 'I';\n+    private static final char BIG_C = 'C';\n+    private static final char BIG_E = 'E';\n+    private static final char BIG_N = 'N';\n+    private static final char BIG_D = 'D';\n+    // state variables\n+    private static final int NOT_IN_BEGIN_BLOCK = 0;\n+    private static final int IN_BEGIN_BLOCK = 1;\n+    private static final int IN_BEGIN_BLOCK_SEMICOLON_SEEN = 2;\n+    // trigger parsing state\n+    private static final int WHITESPACE_SEEN = 0;\n+    private static final int E_SEEN = 1;\n+    private static final int EN_SEEN = 2;\n+    private static final int A_SEEN = 3;\n+    private static final int AT_SEEN = 4;\n+    private static final int ATO_SEEN = 5;\n+    private static final int ATOM_SEEN = 6;\n+    private static final int ATOMI_SEEN = 7;\n+    private static final int NOTHING_SEEN = 8;\n+    private static final ArrayList<Character> DISALLOWED_TERMINATORS = new ArrayList<Character>() {{\n+        add(',');\n+        add('\\'');\n+        add('\"');\n+        add('(');\n+        add(')');\n+        add(' ');\n+        add('_');\n+    }};\n+    private char terminator;\n+    private Reader source;\n+    private StringBuffer statement = new StringBuffer();\n+    private int state;\n+    private boolean atEOF = false;\n+    private boolean peekEOF = false;\n+    private char peekChar;\n+    private boolean peeked = false;\n+    private LocalizedOutput promptwriter;\n+    private boolean doPrompt;\n+    private boolean continuedStatement;\n+\n+    /**\n+     * The constructor does not assume the stream is data input\n+     * or buffered, so it will wrap it appropriately.\n+     * <p>\n+     * If the StatementFinder's input stream is connected to\n+     * System.in, a LocalizedOutput stream may be given to print\n+     * line continuation prompts when StatementFinder reads a newline.\n+     *\n+     * @param s          the input stream for reading statements from.\n+     * @param promptDest LocalizedOutput stream to write line\n+     *                   continuation prompts (\"> \") to. If null,\n+     *                   no such prompts will be written.\n+     */\n+    public StatementFinder(LocalizedInput s, LocalizedOutput promptDest, char terminator) {\n+        source = s;\n+        if (promptDest != null && s.isStandardInput()) {\n+            promptwriter = promptDest;\n+            doPrompt = true;\n+        } else {\n+            doPrompt = false;\n+        }\n+        setTerminator(terminator);\n+    }\n+\n+    /**\n+     * Reinit is used to redirect the finder to another stream.\n+     * The previous stream should not have been in a PEEK state.\n+     * <p>\n+     * If an output stream was given when constructing this\n+     * StatementFinder and the input is standard input,\n+     * continuation prompting will be enabled.\n+     *\n+     * @param s the input stream for reading statements from.\n+     */\n+    public void reInit(LocalizedInput s) {\n+        try {\n+            source.close();\n+        } catch (IOException ioe) {\n+            // just be quiet if it is already gone\n+        }\n+        source = s;\n+        state = IN_STATEMENT;\n+        atEOF = false;\n+        peekEOF = false;\n+        peeked = false;\n+        doPrompt = s.isStandardInput() && promptwriter != null;\n+    }\n+\n+    public void close() throws IOException {\n+        source.close();\n+    }\n+\n+    /**\n+     * get the next statement in the input stream. Returns it,\n+     * dropping its closing terminator if it has one. If there is\n+     * no next statement, return a null.\n+     *\n+     * @return the next statement in the input stream.\n+     */\n+    public String nextStatement() {\n+        boolean haveSemi = false;\n+        char nextChar;\n+        int triggerState = NOT_IN_BEGIN_BLOCK;\n+        int triggerParseState = WHITESPACE_SEEN;\n+\n+        // initialize fields for getting the next statement\n+        statement.setLength(0);\n+        if (state == END_OF_INPUT) return null;\n+\n+        state = IN_STATEMENT;\n+\n+        // skip leading whitespace\n+        nextChar = peekChar();\n+        if (peekEOF()) {\n+            state = END_OF_INPUT;\n+            return null;\n+        }\n+        if (whiteSpace(nextChar)) {\n+            while (whiteSpace(peekChar()) && !peekEOF()) ;\n+            if (peekEOF()) {\n+                state = END_OF_INPUT;\n+                return null;\n+            }\n+        }\n+\n+        while (state != END_OF_STATEMENT && state != END_OF_INPUT) {\n+\n+            // get the next character from the input\n+            nextChar = readChar();\n+            if (atEOF()) {\n+                state = END_OF_INPUT;\n+                break;\n+            }\n+\n+            if (!(nextChar == MINUS))\n+                continuedStatement = true;\n+\n+            switch (nextChar) {\n+                case SPACE:\n+                case TAB:\n+                case FORMFEED:\n+                    triggerParseState = WHITESPACE_SEEN;\n+                    break;\n+                case LITTLE_A:\n+                case BIG_A:\n+                    if (triggerParseState == WHITESPACE_SEEN)\n+                        triggerParseState = A_SEEN;\n+                    else\n+                        triggerParseState = NOTHING_SEEN;\n+                    break;\n+                case LITTLE_T:\n+                case BIG_T:\n+                    if (triggerParseState == A_SEEN)\n+                        triggerParseState = AT_SEEN;\n+                    else\n+                        triggerParseState = NOTHING_SEEN;\n+                    break;\n+                case LITTLE_O:\n+                case BIG_O:\n+                    if (triggerParseState == AT_SEEN)\n+                        triggerParseState = ATO_SEEN;\n+                    else\n+                        triggerParseState = NOTHING_SEEN;\n+                    break;\n+                case LITTLE_M:\n+                case BIG_M:\n+                    if (triggerParseState == ATO_SEEN)\n+                        triggerParseState = ATOM_SEEN;\n+                    else\n+                        triggerParseState = NOTHING_SEEN;\n+                    break;\n+                case LITTLE_I:\n+                case BIG_I:\n+                    if (triggerParseState == ATOM_SEEN)\n+                        triggerParseState = ATOMI_SEEN;\n+                    else\n+                        triggerParseState = NOTHING_SEEN;\n+                    break;\n+                case LITTLE_C:\n+                case BIG_C:\n+                    if (triggerParseState == ATOMI_SEEN)\n+                        triggerState = IN_BEGIN_BLOCK;\n+                    triggerParseState = NOTHING_SEEN;\n+                    break;\n+                case LITTLE_E:\n+                case BIG_E:\n+                    if (triggerState == IN_BEGIN_BLOCK_SEMICOLON_SEEN && triggerParseState == WHITESPACE_SEEN)\n+                        triggerParseState = E_SEEN;\n+                    else\n+                        triggerParseState = NOTHING_SEEN;\n+                    break;\n+                case LITTLE_N:\n+                case BIG_N:\n+                    if (triggerState == IN_BEGIN_BLOCK_SEMICOLON_SEEN && triggerParseState == E_SEEN)\n+                        triggerParseState = EN_SEEN;\n+                    else\n+                        triggerParseState = NOTHING_SEEN;\n+                    break;\n+                case LITTLE_D:\n+                case BIG_D:\n+                    if (triggerState == IN_BEGIN_BLOCK_SEMICOLON_SEEN && triggerParseState == EN_SEEN) {\n+                        triggerState = NOT_IN_BEGIN_BLOCK;\n+                    }\n+                    triggerParseState = NOTHING_SEEN;\n+                    break;\n+                case MINUS:\n+                    readSingleLineComment(nextChar);\n+                    triggerParseState = WHITESPACE_SEEN;\n+                    break;\n+                case SLASH:\n+                    readBracketedComment();\n+                    triggerParseState = WHITESPACE_SEEN;\n+                    break;\n+                case SINGLEQUOTE:\n+                case DOUBLEQUOTE:\n+                    readString(nextChar);\n+                    triggerParseState = NOTHING_SEEN;\n+                    break;\n+                case NEWLINE:\n+                case RETURN:\n+                    if (doPrompt) {\n+                        utilMain.doPrompt(false, promptwriter, \"\");\n+                        /* If the next character is a newline as well,\n+                           we swallow it to avoid double prompting on\n+                           Windows. */\n+                        if (nextChar == RETURN && peekChar() == NEWLINE) {\n+                            readChar();\n+                        }\n+                    }\n+                    triggerParseState = WHITESPACE_SEEN;\n+                    break;\n+                case SEMICOLON:\n+                    if (triggerState == IN_BEGIN_BLOCK) {\n+                        triggerState = IN_BEGIN_BLOCK_SEMICOLON_SEEN;\n+                        break;\n+                    } // intentional fallthrough, backward-compatible behavior of sqlshell, it is able to understand\n+                      // trigger with nested statements having semicolon separator.\n+                default:\n+                    if(terminator == nextChar) {\n+                        if (triggerState == NOT_IN_BEGIN_BLOCK || peekChar() == terminator) {\n+                            haveSemi = true;\n+                            state = END_OF_STATEMENT;\n+                            continuedStatement = false;\n+                        }\n+                        triggerParseState = WHITESPACE_SEEN;\n+                    } else {\n+                        // keep going, just a normal character\n+                        triggerParseState = NOTHING_SEEN;\n+                    }\n+                    break;\n+            }\n+        }\n+\n+        if (haveSemi)\n+            statement.setLength(statement.length() - 1);\n+        return statement.toString();\n+    }\n+\n+    /**\n+     * Determine if the given character is considered whitespace\n+     *\n+     * @param c the character to consider\n+     * @return true if the character is whitespace\n+     */\n+    private boolean whiteSpace(char c) {\n+        return (c == SPACE ||\n+                c == TAB ||\n+                c == RETURN ||\n+                c == NEWLINE ||\n+                c == FORMFEED);\n+    }\n+\n+    /**\n+     * Advance the source stream to the end of a comment\n+     * if it is on one, assuming the first character of\n+     * a potential bracketed comment has been found.\n+     * If it is not a comment, do not advance the stream.\n+     */\n+    private void readBracketedComment() {\n+        char nextChar = peekChar();\n+\n+        // if next char is EOF, we are done.\n+        if (peekEOF()) return;\n+\n+        // if nextChar is not an asterisk, then not a comment.\n+        if (nextChar != ASTERISK) {\n+            continuedStatement = true;\n+            return;\n+        }\n+\n+        // we are really in a comment\n+        readChar(); // grab the asterisk for real.\n+\n+        int nestingLevel = 1;\n+\n+        while (true) {\n+            nextChar = readChar();\n+\n+            if (atEOF()) {\n+                // let the caller process the EOF, don't read it\n+                state = IN_STATEMENT;\n+                return;\n+            }\n+\n+            char peek = peekChar();\n+\n+            if (nextChar == SLASH && peek == ASTERISK) {\n+                readChar();\n+                nestingLevel++;\n+            } else if (nextChar == ASTERISK && peek == SLASH) {\n+                readChar();\n+                nestingLevel--;\n+                if (nestingLevel == 0) {\n+                    state = IN_STATEMENT;\n+                    return;\n+                }\n+            } else if (nextChar == NEWLINE || nextChar == RETURN) {\n+                if (doPrompt) {\n+                    utilMain.doPrompt(false, promptwriter, \"\");\n+                    // If the next character is a NEWLINE, we process\n+                    // it as well to account for Windows CRLFs.\n+                    if (nextChar == RETURN && peek == NEWLINE) {\n+                        readChar();\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Advance the source stream to the end of a comment if it\n+     * is on one, assuming the first character of\n+     * a potential single line comment has been found.\n+     * If it is not a comment, do not advance the stream.\n+     * <p>\n+     * The form of a single line comment is, in regexp, XX.*$,\n+     * where XX is two instances of commentChar.\n+     *\n+     * @param commentChar the character whose duplication signifies\n+     *                    the start of the comment.\n+     */\n+    private void readSingleLineComment(char commentChar) {\n+        char nextChar;\n+\n+        nextChar = peekChar();\n+        // if next char is EOF, we are done.\n+        if (peekEOF()) return;\n+\n+        // if nextChar is not a minus, it was just a normal minus,\n+        // nothing special to do\n+        if (nextChar != commentChar) {\n+            continuedStatement = true;\n+            return;\n+        }\n+\n+        // we are really in a comment\n+        readChar(); // grab the minus for real.\n+\n+        state = IN_SQLCOMMENT;\n+        do {\n+            nextChar = peekChar();\n+            if (peekEOF()) {\n+                // let the caller process the EOF, don't read it\n+                state = IN_STATEMENT;\n+                return;\n+            }\n+            switch (nextChar) {\n+                case NEWLINE:\n+                case RETURN:\n+                    readChar(); // okay to process the character\n+                    state = IN_STATEMENT;\n+                    if (doPrompt) {\n+                        // If we had previously already started a statement,\n+                        // add the prompt.\n+                        // Otherwise, consider this a single line comment,\n+                        // and the next line should not get a prompt\n+                        if (continuedStatement)\n+                            utilMain.doPrompt(false, promptwriter, \"\");\n                         else\n                             utilMain.doPrompt(true, promptwriter, \"\");\n-\t\t\t\t\t    \n-\t\t\t\t\t\t/* If the next character is a NEWLINE, we process\n-\t\t\t\t\t\t *  it as well to account for Windows CRLFs. */\n-\t\t\t\t\t\tif(nextChar == RETURN && peekChar() == NEWLINE) {\n-\t\t\t\t\t\t\treadChar();\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\treturn;\n-\t\t\t\tdefault:\n-\t\t\t\t\treadChar(); // process the character, still in comment\n-\t\t\t\t\tbreak;\n-\t\t\t}\n-\t\t} while (state == IN_SQLCOMMENT); // could be while true...\n-\t}\n-\n-\t/**\n-\t\tAdvance the stream to the end of the string.\n-\t\tAssumes the opening delimiter of the string has been read.\n-\t\tThis handles the SQL ability to put the delimiter within\n-\t\tthe string by doubling it, by reading those as two strings\n-\t\tsitting next to one another.  I.e, 'Mary''s lamb' is read\n-\t\tby this class as two strings, 'Mary' and 's lamb'.\n-\t\t<p>\n-\t\tThe delimiter of the string is expected to be repeated at\n-\t\tits other end. If the other flavor of delimiter occurs within\n-\t\tthe string, it is just a normal character within it.\n-\t\t<p>\n-\t\tAll characters except the delimiter are permitted within the\n-\t\tstring. If EOF is hit before the closing delimiter is found,\n-\t\tthe end of the string is assumed. Parsers using this parser\n-\t\twill detect the error in that case and return appropriate messages.\n-\n-\t\t@param stringDelimiter the starting and ending character\n-\t\t\tfor the string being read.\n-\t */\n-\tprivate void readString(char stringDelimiter) {\n-\t\tstate = IN_STRING;\n-\t\tdo {\n-\t\t\tchar nextChar = readChar();\n-\n-\t\t\tif (atEOF()) {\n-\t\t\t\tstate = END_OF_INPUT;\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\tif (nextChar == stringDelimiter) {\n-\t\t\t\t// we've reached the end of the string\n-\t\t\t\tstate = IN_STATEMENT;\n-\t\t\t\treturn;\n-\t\t\t}\n-\n-\t\t\t// still in string\n-\t\t} while (state == IN_STRING); // could be while true...\n-\t}\n-\n-\tprivate boolean atEOF() {\n-\t\treturn atEOF;\n-\t}\n-\n-\tprivate boolean peekEOF() {\n-\t\treturn peekEOF;\n-\t}\n-\n-\t/**\n-\t\treturn the next character in the source stream and\n-\t\tappend it to the statement buffer.\n-\n-\t\t@return the next character in the source stream.\n-\t */\n-\tprivate char readChar() {\n-\t\tif (!peeked) peekChar();\n-\n-\t\tpeeked = false;\n-\t\tatEOF = peekEOF;\n-\n-\t\tif (!atEOF) statement.append(peekChar);\n-\n-\t\treturn peekChar;\n-\t}\n-\n-\t/**\n-\t\treturn the next character in the source stream, without\n-\t\tadvancing.\n-\n-\t\t@return the next character in the source stream.\n-\t */\n-\tprivate char peekChar() {\n-\t\tpeeked = true;\n-\t\tchar c = '\\00';\n-\n-\t\ttry {\n-\t\t    int cInt;\n-\n-\t\t\t// REMIND: this is assuming a flat ascii source file.\n-\t\t\t// will need to beef it up at some future point to\n-\t\t\t// understand whether the stream is ascii or something else.\n-\t\t\tcInt = source.read();\n-\t\t\tpeekEOF = (cInt == -1);\n-\t\t\tif (!peekEOF) c = (char)cInt;\n-\t\t} catch (IOException ie) {\n-\t\t\tthrow ijException.iOException(ie);\n-\t\t}\n-\n-\t\tpeekChar = c;\n-\t\treturn c;\n-\t}\n+\n+                        /* If the next character is a NEWLINE, we process\n+                         *  it as well to account for Windows CRLFs. */\n+                        if (nextChar == RETURN && peekChar() == NEWLINE) {\n+                            readChar();\n+                        }\n+                    }\n+                    return;\n+                default:\n+                    readChar(); // process the character, still in comment\n+                    break;\n+            }\n+        } while (state == IN_SQLCOMMENT); // could be while true...\n+    }\n+\n+    /**\n+     * Advance the stream to the end of the string.\n+     * Assumes the opening delimiter of the string has been read.\n+     * This handles the SQL ability to put the delimiter within\n+     * the string by doubling it, by reading those as two strings\n+     * sitting next to one another.  I.e, 'Mary''s lamb' is read\n+     * by this class as two strings, 'Mary' and 's lamb'.\n+     * <p>\n+     * The delimiter of the string is expected to be repeated at\n+     * its other end. If the other flavor of delimiter occurs within\n+     * the string, it is just a normal character within it.\n+     * <p>\n+     * All characters except the delimiter are permitted within the\n+     * string. If EOF is hit before the closing delimiter is found,\n+     * the end of the string is assumed. Parsers using this parser\n+     * will detect the error in that case and return appropriate messages.\n+     *\n+     * @param stringDelimiter the starting and ending character\n+     *                        for the string being read.\n+     */\n+    private void readString(char stringDelimiter) {\n+        state = IN_STRING;\n+        do {\n+            char nextChar = readChar();\n+\n+            if (atEOF()) {\n+                state = END_OF_INPUT;\n+                return;\n+            }\n+\n+            if (nextChar == stringDelimiter) {\n+                // we've reached the end of the string\n+                state = IN_STATEMENT;\n+                return;\n+            }\n+\n+            // still in string\n+        } while (state == IN_STRING); // could be while true...\n+    }\n+\n+    private boolean atEOF() {\n+        return atEOF;\n+    }\n+\n+    private boolean peekEOF() {\n+        return peekEOF;\n+    }\n+\n+    /**\n+     * return the next character in the source stream and\n+     * append it to the statement buffer.\n+     *\n+     * @return the next character in the source stream.\n+     */\n+    private char readChar() {\n+        if (!peeked) peekChar();\n+\n+        peeked = false;\n+        atEOF = peekEOF;\n+\n+        if (!atEOF) statement.append(peekChar);\n+\n+        return peekChar;\n+    }\n+\n+    /**\n+     * return the next character in the source stream, without\n+     * advancing.\n+     *\n+     * @return the next character in the source stream.\n+     */\n+    private char peekChar() {\n+        peeked = true;\n+        char c = '\\00';\n+\n+        try {\n+            int cInt;\n+\n+            // REMIND: this is assuming a flat ascii source file.\n+            // will need to beef it up at some future point to\n+            // understand whether the stream is ascii or something else.\n+            cInt = source.read();\n+            peekEOF = (cInt == -1);\n+            if (!peekEOF) c = (char) cInt;\n+        } catch (IOException ie) {\n+            throw ijException.iOException(ie);\n+        }\n+\n+        peekChar = c;\n+        return c;\n+    }\n+\n+    public void setTerminator(char terminator) {\n+        assert isValidTerminator(terminator);\n+        this.terminator = terminator;\n+    }\n+\n+    private static boolean isAsciiCharacter(char c) {\n+        return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\n+    }\n+\n+    public static boolean isValidTerminator(char terminator) {\n+        return !isAsciiCharacter(terminator) && !DISALLOWED_TERMINATORS.contains(terminator);", "originalCommit": "d8d2bcff393c1e7021e98b1aa2d73863ad612e24", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDEyMTcxMQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4132#discussion_r500121711", "bodyText": "+1", "author": "arnaud-splice", "createdAt": "2020-10-06T09:07:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA0NzE2Ng=="}], "type": "inlineReview"}, {"oid": "9eb6f812a9ad4c568c66261b8f9158b9d62993f0", "url": "https://github.com/splicemachine/spliceengine/commit/9eb6f812a9ad4c568c66261b8f9158b9d62993f0", "message": "DB-10049 fix indentation of ij.ij, StatementFinder and utilMain", "committedDate": "2020-10-08T07:35:15Z", "type": "commit"}, {"oid": "668de356fe895b59daace99c8101360d8081f119", "url": "https://github.com/splicemachine/spliceengine/commit/668de356fe895b59daace99c8101360d8081f119", "message": "DB-10049 user-defined statement separator in sqlshell.", "committedDate": "2020-10-08T07:44:37Z", "type": "commit"}, {"oid": "668de356fe895b59daace99c8101360d8081f119", "url": "https://github.com/splicemachine/spliceengine/commit/668de356fe895b59daace99c8101360d8081f119", "message": "DB-10049 user-defined statement separator in sqlshell.", "committedDate": "2020-10-08T07:44:37Z", "type": "forcePushed"}]}