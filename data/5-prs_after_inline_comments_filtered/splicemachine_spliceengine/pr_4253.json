{"pr_number": 4253, "pr_title": "DB-9009 DB-10435 implement Foreign Key ON DELETE SET NULL", "pr_createdAt": "2020-10-08T15:40:21Z", "pr_url": "https://github.com/splicemachine/spliceengine/pull/4253", "timeline": [{"oid": "488d4458222da9f21a067c9668a76014fd8393fb", "url": "https://github.com/splicemachine/spliceengine/commit/488d4458222da9f21a067c9668a76014fd8393fb", "message": "DB-9009 implement FK ON DELETE SET NULL.", "committedDate": "2020-10-08T15:36:24Z", "type": "commit"}, {"oid": "8f113738d59d877946937c0988bf2b6d11715dec", "url": "https://github.com/splicemachine/spliceengine/commit/8f113738d59d877946937c0988bf2b6d11715dec", "message": "DB-9009 refactoring and cleaning up.", "committedDate": "2020-10-08T15:37:02Z", "type": "commit"}, {"oid": "bed852b3949b015f6ddea7f6d489b7c407957c7d", "url": "https://github.com/splicemachine/spliceengine/commit/bed852b3949b015f6ddea7f6d489b7c407957c7d", "message": "DB-9009 address spotbugs issues.", "committedDate": "2020-10-08T17:04:42Z", "type": "commit"}, {"oid": "d9fa652767e34e1fe0a92ba8658619cb4819badd", "url": "https://github.com/splicemachine/spliceengine/commit/d9fa652767e34e1fe0a92ba8658619cb4819badd", "message": "DB-9009 make FK tests green.", "committedDate": "2020-10-08T18:02:47Z", "type": "commit"}, {"oid": "e868cbfa2c6bc8efd7a4b92901b22ab8185debcb", "url": "https://github.com/splicemachine/spliceengine/commit/e868cbfa2c6bc8efd7a4b92901b22ab8185debcb", "message": "DB-9009 add tests and fixes.\n\n- add tests for ON DELETE SET NULL.\n- fix self-referencing FK with ON DELETE SET NULL.\n- other smaller fixes.", "committedDate": "2020-10-08T19:55:26Z", "type": "commit"}, {"oid": "be8ecb2293a12ebfaec9b4bf49bb0cc0729e47ea", "url": "https://github.com/splicemachine/spliceengine/commit/be8ecb2293a12ebfaec9b4bf49bb0cc0729e47ea", "message": "Merge remote-tracking branch 'origin/master' into DB-9009", "committedDate": "2020-10-08T19:57:16Z", "type": "commit"}, {"oid": "bb96fc91fb918b8bef0c2a2a06073618ac3cd914", "url": "https://github.com/splicemachine/spliceengine/commit/bb96fc91fb918b8bef0c2a2a06073618ac3cd914", "message": "DB-10435 Add test.", "committedDate": "2020-10-08T20:15:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM4OTYwNA==", "url": "https://github.com/splicemachine/spliceengine/pull/4253#discussion_r502389604", "bodyText": "Shouldn't we flush the rows that were written before the failure?", "author": "dgomezferro", "createdAt": "2020-10-09T12:23:18Z", "path": "splice_machine/src/main/java/com/splicemachine/pipeline/foreignkey/ForeignKeyParentInterceptWriteHandler.java", "diffHunk": "@@ -80,135 +79,68 @@ private boolean isForeignKeyInterceptNecessary(KVPair.Type type) {\n         return type == KVPair.Type.DELETE;\n     }\n \n-\n-    @Override\n-    public void flush(WriteContext ctx) throws IOException {\n-        try {\n-            // TODO Buffer with skip scan\n-            for (int k = 0; k<mutations.size();k++) {\n-                KVPair mutation = mutations.get(k);\n-                for (int i = 0; i < referencingIndexConglomerateIds.size(); i++) {\n-                    long indexConglomerateId = referencingIndexConglomerateIds.get(i);\n-                    Partition table = null;\n-                    if (childPartitions.containsKey(indexConglomerateId))\n-                        table = childPartitions.get(indexConglomerateId);\n-                    else {\n-                        table = SIDriver.driver().getTableFactory().getTable(Long.toString((indexConglomerateId)));\n-                        childPartitions.put(indexConglomerateId, table);\n-                    }\n-                    if (hasReferences(indexConglomerateId, table, mutation, ctx))\n-                        failRow(mutation, ctx, constraintInfos.get(i));\n-                    else\n-                        ctx.success(mutation);\n+    private void ensureBuffers(WriteContext context) throws Exception {\n+        if (shouldRefreshActions) {\n+            assert childBaseTableConglomerateIds.size() == constraintInfos.size()\n+                    && childBaseTableConglomerateIds.size() == referencingIndexConglomerateIds.size();\n+            for (int i = 0; i < childBaseTableConglomerateIds.size(); i++) {\n+                Pair<Long, Long> needle = new Pair<>(childBaseTableConglomerateIds.get(i), referencingIndexConglomerateIds.get(i));\n+                if(!actions.containsKey(needle)) {\n+                    actions.put(needle, ActionFactory.createAction(childBaseTableConglomerateIds.get(i),\n+                            referencingIndexConglomerateIds.get(i), constraintInfos.get(i), context,\n+                            parentTableName, txnOperationFactory, violationProcessor));\n                 }\n             }\n-        } catch (Exception e) {\n-            violationProcessor.failWrite(e, ctx);\n-        }\n-\n-    }\n-\n-    @Override\n-    public void close(WriteContext ctx) throws IOException {\n-        mutations.clear();\n-        for (Partition table:childPartitions.values()) {\n-            if (table != null)\n-                table.close();\n+            shouldRefreshActions = false;\n         }\n     }\n \n     @Override\n-    public String toString() {\n-        return getClass().getSimpleName();\n-    }\n-\n-            /*\n-         * The way prefix keys work is that longer keys sort after shorter keys. We\n-         * are already starting exactly where we want to be, and we want to end as soon\n-         * as we hit a record which is not this key.\n-         *\n-         * Historically, we did this by using an HBase PrefixFilter. We can do that again,\n-         * but it's a bit of a pain to make that work in an architecture-independent\n-         * way (we would need to implement a version of that for other architectures,\n-         * for example. It's much easier for us to just make use of row key sorting\n-         * to do the job for us.\n-         *\n-         * We start where we want, and we need to end as soon as we run off that. The\n-         * first key which is higher than the start key is the start key as a prefix followed\n-         * by 0x00 (in unsigned sort order). Therefore, we make the end key\n-         * [startKey | 0x00].\n-         */\n-\n-\n-        private boolean hasReferences(Long indexConglomerateId, Partition table, KVPair kvPair, WriteContext ctx) throws IOException {\n-        byte[] startKey = kvPair.getRowKey();\n-        //make sure this is a transactional scan\n-        DataScan scan = txnOperationFactory.newDataScan(null); // Non-Transactional, will resolve on this side\n-        scan =scan.startKey(startKey);\n-        byte[] endKey = Bytes.unsignedCopyAndIncrement(startKey);//new byte[startKey.length+1];\n-        scan = scan.stopKey(endKey);\n-\n-            SimpleTxnFilter readUncommittedFilter;\n-            SimpleTxnFilter readCommittedFilter;\n-            if (ctx.getTxn() instanceof ActiveWriteTxn) {\n-                readCommittedFilter = new SimpleTxnFilter(Long.toString(indexConglomerateId), ((ActiveWriteTxn) ctx.getTxn()).getReadCommittedActiveTxn(), NoOpReadResolver.INSTANCE, SIDriver.driver().getTxnStore());\n-                readUncommittedFilter = new SimpleTxnFilter(Long.toString(indexConglomerateId), ((ActiveWriteTxn) ctx.getTxn()).getReadUncommittedActiveTxn(), NoOpReadResolver.INSTANCE, SIDriver.driver().getTxnStore());\n-\n+    public void next(KVPair mutation, WriteContext ctx) {\n+        if (isForeignKeyInterceptNecessary(mutation.getType())) {\n+            if(failed) {\n+                ctx.notRun(mutation);\n+                return;\n             }\n-            else if (ctx.getTxn() instanceof WritableTxn) {\n-                readCommittedFilter = new SimpleTxnFilter(Long.toString(indexConglomerateId), ((WritableTxn) ctx.getTxn()).getReadCommittedActiveTxn(), NoOpReadResolver.INSTANCE, SIDriver.driver().getTxnStore());\n-                readUncommittedFilter = new SimpleTxnFilter(Long.toString(indexConglomerateId), ((WritableTxn) ctx.getTxn()).getReadUncommittedActiveTxn(), NoOpReadResolver.INSTANCE, SIDriver.driver().getTxnStore());\n+            try {\n+                ensureBuffers(ctx);\n+            } catch (Exception e) {\n+                ctx.failed(mutation, WriteResult.failed(e.getMessage()));\n+                return;\n             }\n-            else\n-                throw new IOException(\"invalidTxn\");\n-        try(DataScanner scanner = table.openScanner(scan)) {\n-            List<DataCell> next;\n-            while ((next = scanner.next(-1)) != null && !next.isEmpty()) {\n-                readCommittedFilter.reset();\n-                readUncommittedFilter.reset();\n-                if (hasData(next, readCommittedFilter) || hasData(next, readUncommittedFilter))\n-                    return true;\n+            for(Action action : actions.values()) {\n+                action.next(mutation, ctx);\n+                if(action.hasFailed()) {\n+                    failed = true;\n+                    ctx.failed(mutation, action.getWriteResult());\n+                    break;\n+                }\n             }\n-            return false;\n-        }catch (Exception e) {\n-            throw new IOException(e);\n+        }\n+        if(!failed) {\n+            ctx.success(mutation);\n+            ctx.sendUpstream(mutation);\n         }\n     }\n \n-    private boolean hasData(List<DataCell> next, SimpleTxnFilter txnFilter) throws IOException {\n-        int cellCount = next.size();\n-        for(DataCell dc:next){\n-            DataFilter.ReturnCode rC = txnFilter.filterCell(dc);\n-            switch(rC){\n-                case NEXT_ROW:\n-                    return false; //the entire row is filtered\n-                case SKIP:\n-                case NEXT_COL:\n-                case SEEK:\n-                    cellCount--; //the cell is filtered\n-                    break;\n-                case INCLUDE:\n-                case INCLUDE_AND_NEXT_COL: //the cell is included\n-                default:\n-                    break;\n+    @Override\n+    public void flush(WriteContext ctx) throws IOException {\n+        if(failed) {", "originalCommit": "bb96fc91fb918b8bef0c2a2a06073618ac3cd914", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA4MDU0MA==", "url": "https://github.com/splicemachine/spliceengine/pull/4253#discussion_r503080540", "bodyText": "Wouldn't that interfere with transaction atomicity in case of failure? e.g.\nImagine the parent table p has FKs defined on three child tables (c1, c2, and c3), the DELETE on the parent key comprises three rows r1, r2, and r3:\n\nfor r1: accepted by all children => add mutations r1c1, r1c2, r1c3 to respective buffers.\nfor r2: accepted only by c1 => generate mutation r2c1 and add it to its buffer.\nNow if we flush previous results we will end up with semi-updated child tables (r1c1 for c1, r1c2 for c2, and r1c3 for c3).\n\nI am not sure about the internals of the write buffer so maybe in this situation the statement is rolled back properly at some other level. is that the case?", "author": "hatyo", "createdAt": "2020-10-12T07:08:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM4OTYwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc2MDIzMA==", "url": "https://github.com/splicemachine/spliceengine/pull/4253#discussion_r503760230", "bodyText": "I was thinking of \"permissive\" writes, where we would want to write some rows and fail others. For a non-permissive write we would rollback the transaction and those written records shouldn't matter. But this is fine for now until we handle permissive writes for FK.", "author": "dgomezferro", "createdAt": "2020-10-13T08:23:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM4OTYwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM5MDc2Mw==", "url": "https://github.com/splicemachine/spliceengine/pull/4253#discussion_r502390763", "bodyText": "Should it be getFailedWriteResult() ?", "author": "dgomezferro", "createdAt": "2020-10-09T12:25:27Z", "path": "splice_machine/src/main/java/com/splicemachine/pipeline/foreignkey/actions/Action.java", "diffHunk": "@@ -0,0 +1,44 @@\n+package com.splicemachine.pipeline.foreignkey.actions;\n+\n+import com.splicemachine.pipeline.client.WriteResult;\n+import com.splicemachine.pipeline.writehandler.WriteHandler;\n+\n+import java.util.Objects;\n+\n+public abstract class Action implements WriteHandler  {\n+\n+    protected final Long childBaseTableConglomId;\n+    protected final Long backingIndexConglomId;\n+    protected boolean failed;\n+    protected WriteResult writeResult;\n+\n+    protected Action(Long childBaseTableConglomId, Long backingIndexConglomId) {\n+        this.childBaseTableConglomId = childBaseTableConglomId;\n+        this.backingIndexConglomId = backingIndexConglomId;\n+        this.failed = false;\n+        this.writeResult = null;\n+    }\n+\n+    public boolean hasFailed() {\n+        return failed;\n+    }\n+\n+    public WriteResult getWriteResult() {", "originalCommit": "bb96fc91fb918b8bef0c2a2a06073618ac3cd914", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA4MDc5Nw==", "url": "https://github.com/splicemachine/spliceengine/pull/4253#discussion_r503080797", "bodyText": "Fixed, thanks!", "author": "hatyo", "createdAt": "2020-10-12T07:08:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM5MDc2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM5MTU4MA==", "url": "https://github.com/splicemachine/spliceengine/pull/4253#discussion_r502391580", "bodyText": "Please handle properly", "author": "dgomezferro", "createdAt": "2020-10-09T12:26:59Z", "path": "splice_machine/src/main/java/com/splicemachine/pipeline/foreignkey/actions/OnDeleteSetNull.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package com.splicemachine.pipeline.foreignkey.actions;\n+\n+import com.splicemachine.db.iapi.error.StandardException;\n+import com.splicemachine.db.iapi.services.io.FormatableBitSet;\n+import com.splicemachine.db.iapi.sql.execute.ExecRow;\n+import com.splicemachine.db.impl.sql.execute.ValueRow;\n+import com.splicemachine.ddl.DDLMessage;\n+import com.splicemachine.derby.stream.output.WriteReadUtils;\n+import com.splicemachine.derby.stream.output.update.NonPkRowHash;\n+import com.splicemachine.derby.utils.marshall.EntryDataHash;\n+import com.splicemachine.derby.utils.marshall.dvd.DescriptorSerializer;\n+import com.splicemachine.derby.utils.marshall.dvd.VersionedSerializers;\n+import com.splicemachine.kvpair.KVPair;\n+import com.splicemachine.pipeline.client.WriteResult;\n+import com.splicemachine.pipeline.context.WriteContext;\n+import com.splicemachine.pipeline.foreignkey.ForeignKeyViolationProcessor;\n+import com.splicemachine.si.api.data.TxnOperationFactory;\n+\n+import java.util.Arrays;\n+\n+public class OnDeleteSetNull extends OnDeleteAbstractAction {\n+\n+    private final boolean isSelfReferencing;\n+\n+    public OnDeleteSetNull(Long childBaseTableConglomId,\n+                           Long backingIndexConglomId,\n+                           DDLMessage.FKConstraintInfo constraintInfo,\n+                           WriteContext writeContext,\n+                           TxnOperationFactory txnOperationFactory,\n+                           ForeignKeyViolationProcessor violationProcessor) throws Exception {\n+        super(childBaseTableConglomId, backingIndexConglomId, constraintInfo, writeContext, txnOperationFactory, violationProcessor);\n+        isSelfReferencing = childBaseTableConglomId == constraintInfo.getParentTableConglomerate();\n+    }\n+\n+    private KVPair constructUpdateToNull(byte[] rowId ) throws StandardException {\n+        int colCount = constraintInfo.getTable().getFormatIdsCount();\n+        int[] keyColumns = constraintInfo.getColumnIndicesList().stream().mapToInt(i -> i).toArray();\n+        int[] oneBased = new int[colCount + 1];\n+        for (int i = 0; i < colCount; ++i) {\n+            oneBased[i + 1] = i;\n+        }\n+        FormatableBitSet heapSet = new FormatableBitSet(oneBased.length);\n+        ExecRow execRow = WriteReadUtils.getExecRowFromTypeFormatIds(constraintInfo.getTable().getFormatIdsList().stream().mapToInt(i -> i).toArray());\n+        for (int keyColumn : keyColumns) {\n+            execRow.setColumn(keyColumn, execRow.getColumn(keyColumn).getNewNull());\n+            heapSet.set(keyColumn);\n+        }\n+        DescriptorSerializer[] serializers = VersionedSerializers.forVersion(constraintInfo.getTable().getTableVersion(), true).getSerializers(execRow);\n+        EntryDataHash entryEncoder = new NonPkRowHash(oneBased, null, serializers, heapSet);\n+        ValueRow rowToEncode = new ValueRow(execRow.getRowArray().length);\n+        rowToEncode.setRowArray(execRow.getRowArray());\n+        entryEncoder.setRow(rowToEncode);\n+        byte[] value = entryEncoder.encode();\n+        return new KVPair(rowId, value, KVPair.Type.UPDATE);\n+    }\n+\n+    @Override\n+    protected WriteResult handleExistingRow(byte[] indexRowId, byte[] sourceRowKey) throws Exception {\n+        byte[] baseTableRowId = new byte[0];\n+        try {\n+            baseTableRowId = toChildBaseRowId(indexRowId, constraintInfo);\n+        } catch (StandardException e) {\n+            e.printStackTrace();", "originalCommit": "bb96fc91fb918b8bef0c2a2a06073618ac3cd914", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA4MTMxOA==", "url": "https://github.com/splicemachine/spliceengine/pull/4253#discussion_r503081318", "bodyText": "Fixed, thanks!", "author": "hatyo", "createdAt": "2020-10-12T07:09:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM5MTU4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM5NDA3OA==", "url": "https://github.com/splicemachine/spliceengine/pull/4253#discussion_r502394078", "bodyText": "Can you test it with \"permissive\" imports? If we allow up to N badRecords and some records violate the FK constraint, we should log them but import the rest, does that work?", "author": "dgomezferro", "createdAt": "2020-10-09T12:31:45Z", "path": "splice_machine/src/test/java/com/splicemachine/foreignkeys/ForeignKeyActionIT.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/*\n+ * Copyright (c) 2012 - 2020 Splice Machine, Inc.\n+ *\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.splicemachine.foreignkeys;\n+\n+import com.splicemachine.derby.test.framework.SpliceSchemaWatcher;\n+import com.splicemachine.derby.test.framework.SpliceWatcher;\n+import com.splicemachine.derby.test.framework.TestConnection;\n+import com.splicemachine.test_dao.TableDAO;\n+import com.splicemachine.util.StatementUtils;\n+import org.junit.*;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Statement;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * Foreign key tests for referential actions:\n+ *\n+ * ON DELETE NO ACTION\n+ * ON DELETE CASCADE\n+ * ON DELETE SET NULL\n+ * ON UPDATE NO ACTION\n+ */\n+public class ForeignKeyActionIT {", "originalCommit": "bb96fc91fb918b8bef0c2a2a06073618ac3cd914", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzIwMzk5NA==", "url": "https://github.com/splicemachine/spliceengine/pull/4253#discussion_r503203994", "bodyText": "I tried to run the following scenario via a unit test but it failed, I suspected it is not related to this PR so I ran it against master and ran into the same issue:\ncreate table PI(col1 int, col2 varchar(2), primary key (col1));\ncreate table C1I(col1 int, col2 int, constraint ci_fk_key foreign key(col1) references PI(col1) on delete no action);\ninsert into PI values (1, 'a');\ninsert into PI values (2, 'b');\n-- create a file: /tmp/bad.csv containing the following rows:\n-- 1,1\n-- 1000,1000\n-- 1,1\n-- 2000,2000\n-- 2,2\n-- create a directory /tmp/BAD\ncall SYSCS_UTIL.import_data('SPLICE', 'C1I', null, '/tmp/bad.csv', ',', null, null, null, null, 2, '/tmp/BAD', null, null);\nrowsImported        |failedRows          |files      |dataSize            |failedLog\n-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n3                   |2                   |1          |32                  |/tmp/BAD\nselect * from C1I;\nCOL1       |COL2\n-----------------------\n1          |1\n1000       |1000\n1          |1\n2000       |2000\n2          |2\n\nThe SYSCS_UTIL.IMPORT_DATA is not rejecting the rows that violate the FK constraint. I will open a JIRA for it so we can track it separately.", "author": "hatyo", "createdAt": "2020-10-12T10:39:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM5NDA3OA=="}], "type": "inlineReview"}, {"oid": "f557ff1d7eb3edf6a99bccc527abcde6e30f203a", "url": "https://github.com/splicemachine/spliceengine/commit/f557ff1d7eb3edf6a99bccc527abcde6e30f203a", "message": "Merge remote-tracking branch 'origin/master' into DB-9009", "committedDate": "2020-10-12T07:00:07Z", "type": "commit"}, {"oid": "a112b13605964b374f99a0f71b4bf8358d639a9b", "url": "https://github.com/splicemachine/spliceengine/commit/a112b13605964b374f99a0f71b4bf8358d639a9b", "message": "DB-9009 address comments.", "committedDate": "2020-10-12T11:28:41Z", "type": "commit"}, {"oid": "a67c4e7532a033098c2dbe79e1c9cd3a756eebac", "url": "https://github.com/splicemachine/spliceengine/commit/a67c4e7532a033098c2dbe79e1c9cd3a756eebac", "message": "Merge remote-tracking branch 'origin/master' into DB-9009", "committedDate": "2020-10-12T11:36:23Z", "type": "commit"}, {"oid": "30c5d9c6f571c6a4af826e0a9e395b86504ce392", "url": "https://github.com/splicemachine/spliceengine/commit/30c5d9c6f571c6a4af826e0a9e395b86504ce392", "message": "DB-9009 fix spotbugs issues.", "committedDate": "2020-10-12T14:28:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgyMjc2NA==", "url": "https://github.com/splicemachine/spliceengine/pull/4253#discussion_r503822764", "bodyText": "It seems the third argument can be built from the fourth. Is it possible to build it inside the function and make the signature cleaner?", "author": "ascend1", "createdAt": "2020-10-13T09:57:00Z", "path": "splice_machine/src/main/java/com/splicemachine/pipeline/foreignkey/FKWriteFactoryHolder.java", "diffHunk": "@@ -115,7 +117,8 @@ public void handleForeignKeyAdd(DDLChange ddlChange, long onConglomerateNumber)\n         TentativeFK tentativeFKAdd = ddlChange.getTentativeFK();\n         // We are configuring a write context on the PARENT base-table or unique-index.\n         if (onConglomerateNumber == tentativeFKAdd.getReferencedConglomerateNumber()) {\n-            addParentInterceptWriteFactory(tentativeFKAdd.getReferencedTableName(), ImmutableList.of(tentativeFKAdd.getReferencingConglomerateNumber()),ImmutableList.of(tentativeFKAdd.getFkConstraintInfo()));\n+            addParentInterceptWriteFactory(tentativeFKAdd.getReferencedTableName(), ImmutableList.of(tentativeFKAdd.getReferencingConglomerateNumber()),\n+                    ImmutableList.of(tentativeFKAdd.getFkConstraintInfo().getTable().getConglomerate()),ImmutableList.of(tentativeFKAdd.getFkConstraintInfo()));", "originalCommit": "488d4458222da9f21a067c9668a76014fd8393fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDE4MDMzMQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4253#discussion_r504180331", "bodyText": "Thanks! I kind of extended the API without paying too much attention to cleaning it up a little, I removed that extraneous parameter.", "author": "hatyo", "createdAt": "2020-10-13T18:45:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgyMjc2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgzMTc3Ng==", "url": "https://github.com/splicemachine/spliceengine/pull/4253#discussion_r503831776", "bodyText": "Maybe a bit more description about the special case?", "author": "ascend1", "createdAt": "2020-10-13T10:12:01Z", "path": "splice_machine/src/main/java/com/splicemachine/pipeline/foreignkey/ForeignKeyParentInterceptWriteHandler.java", "diffHunk": "@@ -42,35 +65,261 @@\n  */\n @NotThreadSafe\n public class ForeignKeyParentInterceptWriteHandler implements WriteHandler{\n+\n+    private boolean failed;\n+\n+    static class ChildBaseTableContext {\n+        public ChildBaseTableContext(Long conglomerateId,\n+                                     Long fkIndexConglomerateId,\n+                                     DDLMessage.FKConstraintInfo constraintInfo,\n+                                     WriteContext context) throws Exception {\n+            this.conglomerateId = conglomerateId;\n+            this.fkIndexConglomerateId = fkIndexConglomerateId;\n+            this.mutationBuffer = new ObjectObjectHashMap<>();\n+            this.pipelineBuffer = context.getSharedWriteBuffer(\n+                    DDLUtils.getIndexConglomBytes(conglomerateId),\n+                    this.mutationBuffer,\n+                    1000 * 2 + 10,\n+                    true,\n+                    context.getTxn(),\n+                    context.getToken());\n+            this.constraintInfo = constraintInfo;\n+        }\n+        public final Long conglomerateId;\n+        public final Long fkIndexConglomerateId;\n+        public final ObjectObjectHashMap<KVPair, KVPair> mutationBuffer;\n+        public final CallBuffer<KVPair> pipelineBuffer;\n+        public final DDLMessage.FKConstraintInfo constraintInfo;\n+    }\n+\n     private final List<Long> referencingIndexConglomerateIds;\n+    private List<Long> childBaseTableConglomerateIds;\n+    private boolean childContextsCreated = false;\n+    List<ChildBaseTableContext> childBaseTableContexts;\n     private final List<DDLMessage.FKConstraintInfo> constraintInfos;\n     private final ForeignKeyViolationProcessor violationProcessor;\n     private TxnOperationFactory txnOperationFactory;\n     private HashMap<Long,Partition> childPartitions = new HashMap<>();\n     private String parentTableName;\n+    private transient DataGet baseGet = null;\n     private ObjectArrayList<KVPair> mutations = new ObjectArrayList<>();\n \n \n     public ForeignKeyParentInterceptWriteHandler(String parentTableName,\n                                                  List<Long> referencingIndexConglomerateIds,\n-                                                 PipelineExceptionFactory exceptionFactory,\n-                                                 List<DDLMessage.FKConstraintInfo> constraintInfos\n+                                                 List<Long> childBaseTableConglomerateIds,\n+                                                 List<DDLMessage.FKConstraintInfo> constraintInfos,\n+                                                 PipelineExceptionFactory exceptionFactory\n                                                  ) {\n         this.referencingIndexConglomerateIds = referencingIndexConglomerateIds;\n+        this.childBaseTableConglomerateIds = childBaseTableConglomerateIds;\n+        this.childBaseTableContexts = new ArrayList<>();\n         this.violationProcessor = new ForeignKeyViolationProcessor(\n                 new ForeignKeyViolationProcessor.ParentFkConstraintContextProvider(parentTableName),exceptionFactory);\n         this.constraintInfos = constraintInfos;\n         this.txnOperationFactory = SIDriver.driver().getOperationFactory();\n         this.parentTableName = parentTableName;\n     }\n \n+    private boolean ensureBuffers(WriteContext context) {\n+        if (!childContextsCreated) {\n+            assert childBaseTableConglomerateIds.size() == constraintInfos.size();\n+            for (int i = 0; i < childBaseTableConglomerateIds.size(); i++) {\n+               if(constraintInfos.get(i).getDeleteRule() == StatementType.RA_SETNULL) {\n+                   try {\n+                       childBaseTableContexts.add(new ChildBaseTableContext(childBaseTableConglomerateIds.get(i),\n+                               referencingIndexConglomerateIds.get(i), constraintInfos.get(i), context));\n+                   } catch (Exception e) {\n+                       // todo improve this\n+                       return false;\n+                   }\n+               }\n+            }\n+            childContextsCreated = true;\n+        }\n+        return true;\n+    }\n+\n     @Override\n     public void next(KVPair mutation, WriteContext ctx) {\n+        if(failed) {\n+            ctx.notRun(mutation);\n+            return;\n+        }\n         if (isForeignKeyInterceptNecessary(mutation.getType())) {\n+            ensureBuffers(ctx); // todo handle failures properly\n             mutations.add(mutation);\n+            for(ChildBaseTableContext childBaseTableContext : childBaseTableContexts) {\n+                if(!checkReferencesAndUpdateChildBuffers(mutation, ctx, childBaseTableContext)) {\n+                    failed = true;\n+                    failRow(mutation, ctx, childBaseTableContext.constraintInfo);\n+                    break;\n+                }\n+            }\n+        }\n+        if(!failed) {\n+            ctx.success(mutation);\n+            ctx.sendUpstream(mutation);\n+        }\n+    }\n+\n+    /*\n+     * The way prefix keys work is that longer keys sort after shorter keys. We\n+     * are already starting exactly where we want to be, and we want to end as soon\n+     * as we hit a record which is not this key.\n+     *\n+     * Historically, we did this by using an HBase PrefixFilter. We can do that again,\n+     * but it's a bit of a pain to make that work in an architecture-independent\n+     * way (we would need to implement a version of that for other architectures,\n+     * for example. It's much easier for us to just make use of row key sorting\n+     * to do the job for us.\n+     *\n+     * We start where we want, and we need to end as soon as we run off that. The\n+     * first key which is higher than the start key is the start key as a prefix followed\n+     * by 0x00 (in unsigned sort order). Therefore, we make the end key\n+     * [startKey | 0x00].\n+     */\n+    private static DataScan prepareScan(TxnOperationFactory factory, TxnView txnView, KVPair needle) {\n+        byte[] startKey = needle.getRowKey();\n+        byte[] stopKey = Bytes.unsignedCopyAndIncrement(startKey); // +1 from startKey.\n+        DataScan scan = factory.newDataScan(txnView);\n+        return scan.startKey(startKey).stopKey(stopKey);\n+    }\n+\n+    private static Pair<SimpleTxnFilter, SimpleTxnFilter> prepareScanFilters(TxnView txnView, long indexConglomerateId) throws IOException {\n+        SimpleTxnFilter readUncommittedFilter, readCommittedFilter;\n+        if (txnView instanceof ActiveWriteTxn) {\n+            readCommittedFilter = new SimpleTxnFilter(Long.toString(indexConglomerateId), ((ActiveWriteTxn) txnView).getReadCommittedActiveTxn(), NoOpReadResolver.INSTANCE, SIDriver.driver().getTxnStore());\n+            readUncommittedFilter = new SimpleTxnFilter(Long.toString(indexConglomerateId), ((ActiveWriteTxn) txnView).getReadUncommittedActiveTxn(), NoOpReadResolver.INSTANCE, SIDriver.driver().getTxnStore());\n+\n+        } else if (txnView instanceof WritableTxn) {\n+            readCommittedFilter = new SimpleTxnFilter(Long.toString(indexConglomerateId), ((WritableTxn) txnView).getReadCommittedActiveTxn(), NoOpReadResolver.INSTANCE, SIDriver.driver().getTxnStore());\n+            readUncommittedFilter = new SimpleTxnFilter(Long.toString(indexConglomerateId), ((WritableTxn) txnView).getReadUncommittedActiveTxn(), NoOpReadResolver.INSTANCE, SIDriver.driver().getTxnStore());\n+        } else {\n+            throw new IOException(\"invalidTxn,\");\n         }\n-        ctx.sendUpstream(mutation);\n+        return Pair.newPair(readCommittedFilter, readUncommittedFilter);\n     }\n+\n+    private byte[] isVisible(List<DataCell> next, SimpleTxnFilter txnFilter) throws IOException {\n+        int cellCount = next.size();\n+        for(DataCell dc:next){\n+            DataFilter.ReturnCode rC = txnFilter.filterCell(dc);\n+            switch(rC){\n+                case NEXT_ROW:\n+                    return null; //the entire row is filtered\n+                case SKIP:\n+                case NEXT_COL:\n+                case SEEK:\n+                    cellCount--; //the cell is filtered\n+                    break;\n+                case INCLUDE:\n+                case INCLUDE_AND_NEXT_COL: //the cell is included\n+                default:\n+                    break;\n+            }\n+        }\n+        if(cellCount > 0) {\n+            return next.get(0).key();\n+        }\n+        return null;\n+    }\n+\n+    private static byte[] toChildBaseRowId(byte[] indexRowId, DDLMessage.FKConstraintInfo fkConstraintInfo) {\n+        // 1. determine the position\n+        MultiFieldDecoder multiFieldDecoder = MultiFieldDecoder.create();\n+        TypeProvider typeProvider = VersionedSerializers.typesForVersion(fkConstraintInfo.getParentTableVersion());\n+        int position = 0;\n+        multiFieldDecoder.set(indexRowId);\n+        for (int i = 0; i < fkConstraintInfo.getFormatIdsCount(); i++) {\n+            if (multiFieldDecoder.nextIsNull()) {\n+                return null;\n+            }\n+            if (fkConstraintInfo.getFormatIds(i) == StoredFormatIds.SQL_DOUBLE_ID) {\n+                position += multiFieldDecoder.skipDouble();\n+            } else if (fkConstraintInfo.getFormatIds(i) == StoredFormatIds.SQL_REAL_ID) {\n+                position += multiFieldDecoder.skipFloat();\n+            } else if (typeProvider.isScalar(fkConstraintInfo.getFormatIds(i))) {\n+                position += multiFieldDecoder.skipLong();\n+            } else {\n+                position += multiFieldDecoder.skip();\n+            }\n+        }\n+        int lastKeyIndex = position - 2;\n+\n+        if (lastKeyIndex == indexRowId.length - 1) {\n+            return null; // special case.", "originalCommit": "488d4458222da9f21a067c9668a76014fd8393fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDE3NjQxNg==", "url": "https://github.com/splicemachine/spliceengine/pull/4253#discussion_r504176416", "bodyText": "This is an outdated version of this method. Check out the new version of it in OnDeleteAbstractAction, we throw if we encounter this special code path.\nTo answer your question, I think in this case we make sure the index key comprises a prefix + base row id, i.e. that there is also a base row id encoded in there not just a prefix.", "author": "hatyo", "createdAt": "2020-10-13T18:38:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgzMTc3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgzOTQyMw==", "url": "https://github.com/splicemachine/spliceengine/pull/4253#discussion_r503839423", "bodyText": "What will happen if the foreign key column is not nullable? Do we have such a test case?\ncreate table SRT (a int primary key, b int not null, constraint fk foreign key (B) references SRT(a) on delete set null);\nProbably should throw already in binding phase since it's semantically conflicting.", "author": "ascend1", "createdAt": "2020-10-13T10:25:06Z", "path": "splice_machine/src/test/java/com/splicemachine/foreignkeys/ForeignKeyActionIT.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright (c) 2012 - 2020 Splice Machine, Inc.\n+ *\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.splicemachine.foreignkeys;\n+\n+import com.splicemachine.derby.test.framework.SpliceSchemaWatcher;\n+import com.splicemachine.derby.test.framework.SpliceWatcher;\n+import com.splicemachine.derby.test.framework.TestConnection;\n+import com.splicemachine.test_dao.TableDAO;\n+import com.splicemachine.util.StatementUtils;\n+import org.junit.*;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.SQLIntegrityConstraintViolationException;\n+import java.sql.Statement;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * Foreign key tests for referential actions:\n+ *\n+ * ON DELETE NO ACTION\n+ * ON DELETE CASCADE\n+ * ON DELETE SET NULL\n+ * ON UPDATE NO ACTION\n+ */\n+public class ForeignKeyActionIT {\n+\n+    private static final String SCHEMA = ForeignKeyActionIT.class.getSimpleName();\n+\n+    @ClassRule\n+    public static SpliceSchemaWatcher spliceSchemaWatcher = new SpliceSchemaWatcher(SCHEMA);\n+\n+    @Rule\n+    public SpliceWatcher methodWatcher = new SpliceWatcher(SCHEMA);\n+\n+    private TestConnection conn;\n+    @Before\n+    public void deleteTables() throws Exception {\n+        conn = methodWatcher.getOrCreateConnection();\n+        conn.setAutoCommit(false);\n+        new TableDAO(conn).drop(SCHEMA, \"SRT\", \"LC\", \"YAC\", \"AC\", \"AP\", \"C\", \"P\");\n+    }\n+\n+    @After\n+    public void tearDown() throws Exception{\n+        conn.rollback();\n+        conn.reset();\n+    }\n+\n+    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n+    //\n+    // fk references unique index\n+    //\n+    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n+\n+    private static void createDatabaseObjects1(Statement s) throws SQLException {\n+        s.executeUpdate(\"create table P (a int unique, b int)\");\n+        s.executeUpdate(\"create table C (a int, b int, CONSTRAINT FK_1 FOREIGN KEY (a) REFERENCES P(a) ON DELETE NO ACTION)\");\n+        s.executeUpdate(\"insert into P values(1,10),(2,20),(3,30)\");\n+        s.executeUpdate(\"insert into C values(1,10),(1,15),(2,20),(2,20),(3,30),(3,35)\");\n+    }\n+\n+    @Test\n+    public void onDeleteNoAction() throws Exception {\n+        try(Statement s = conn.createStatement()){\n+            createDatabaseObjects1(s);\n+            assertQueryFail(s,\"delete from P where a = 2\",\"Operation on table 'P' caused a violation of foreign key constraint 'FK_1' for key (A).  The statement has been rolled back.\");\n+            assertQueryFail(s,\"update P set a=-1 where a = 2\",\"Operation on table 'P' caused a violation of foreign key constraint 'FK_1' for key (A).  The statement has been rolled back.\");\n+        }\n+    }\n+\n+    @Test\n+    public void onDeleteNoActionImplicit() throws Exception {\n+        try(Statement s = conn.createStatement()){\n+            createDatabaseObjects1(s);\n+\n+            assertQueryFail(s,\"delete from P where a = 2\",\"Operation on table 'P' caused a violation of foreign key constraint 'FK_1' for key (A).  The statement has been rolled back.\");\n+            assertQueryFail(s,\"update P set a=-1 where a = 2\",\"Operation on table 'P' caused a violation of foreign key constraint 'FK_1' for key (A).  The statement has been rolled back.\");\n+        }\n+    }\n+\n+    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n+    //\n+    // fk references primary key\n+    //\n+    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n+\n+    @Test\n+    public void onDeleteNoActionPrimaryKey() throws Exception {\n+        try(Statement s = conn.createStatement()){\n+            createDatabaseObjects1(s);\n+\n+            assertQueryFail(s,\"delete from P where a = 2\",\"Operation on table 'P' caused a violation of foreign key constraint 'FK_1' for key (A).  The statement has been rolled back.\");\n+            assertQueryFail(s,\"update P set a=-1 where a = 2\",\"Operation on table 'P' caused a violation of foreign key constraint 'FK_1' for key (A).  The statement has been rolled back.\");\n+        }\n+    }\n+\n+    /* Make sure FKs still work when we create the parent, write to it first, then create the child that actually has the FK */\n+    @Test\n+    public void onDeleteNoActionPrimaryKeyInitializeWriteContextOfParentFirst() throws Exception {\n+        try(Statement s = conn.createStatement()){\n+            s.executeUpdate(\"create table P (a int primary key, b int unique)\");\n+            s.executeUpdate(\"insert into P values(1,10),(2,20),(3,30),(4,40)\");\n+\n+            s.executeUpdate(\"create table C1 (a int, b int, CONSTRAINT FK_1 FOREIGN KEY (a) REFERENCES P(a))\");\n+            s.executeUpdate(\"insert into C1 values(1,10),(1,15),(2,20),(2,20),(3,30),(3,35)\");\n+\n+            assertQueryFail(s,\"delete from P where a = 2\",\"Operation on table 'P' caused a violation of foreign key constraint 'FK_1' for key (A).  The statement has been rolled back.\");\n+            assertQueryFail(s,\"update P set a=-1 where a = 2\",\"Operation on table 'P' caused a violation of foreign key constraint 'FK_1' for key (A).  The statement has been rolled back.\");\n+\n+            s.executeUpdate(\"create table C2 (a int, b int, CONSTRAINT FK_2 FOREIGN KEY (b) REFERENCES P(b))\");\n+            s.executeUpdate(\"insert into C2 values(4,40)\");\n+\n+            // verify NEW FK constraint works\n+            assertQueryFail(s,\"delete from P where a = 4\",\"Operation on table 'P' caused a violation of foreign key constraint 'FK_2' for key (B).  The statement has been rolled back.\");\n+            assertQueryFail(s,\"update P set b=-1 where a = 4\",\"Operation on table 'P' caused a violation of foreign key constraint 'FK_2' for key (B).  The statement has been rolled back.\");\n+\n+            // verify FIRST FK constraint STILL works\n+            assertQueryFail(s,\"delete from P where a = 1\",\"Operation on table 'P' caused a violation of foreign key constraint 'FK_1' for key (A).  The statement has been rolled back.\");\n+            assertQueryFail(s,\"update P set a=-1 where a = 1\",\"Operation on table 'P' caused a violation of foreign key constraint 'FK_1' for key (A).  The statement has been rolled back.\");\n+        }\n+    }\n+\n+    @Test\n+    public void onDeleteNoActionPrimaryKeySuccessAfterDeleteReference() throws Exception {\n+        try(Statement s = conn.createStatement()){\n+            createDatabaseObjects1(s);\n+\n+            assertQueryFail(s,\"delete from P where a = 2\",\"Operation on table 'P' caused a violation of foreign key constraint 'FK_1' for key (A).  The statement has been rolled back.\");\n+            assertQueryFail(s,\"update P set a=-1 where a = 2\",\"Operation on table 'P' caused a violation of foreign key constraint 'FK_1' for key (A).  The statement has been rolled back.\");\n+\n+            // delete references\n+            s.executeUpdate(\"delete from C where a=2\");\n+\n+            // now delete from parent should succeed\n+            assertEquals(4L,StatementUtils.onlyLong(s,\"select count(*) from C\"));\n+            assertEquals(1L,s.executeUpdate(\"delete from P where a = 2\"));\n+        }\n+    }\n+\n+    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n+    //\n+    // FK - ON DELETE SET NULL\n+    //\n+    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n+", "originalCommit": "e868cbfa2c6bc8efd7a4b92901b22ab8185debcb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDE3OTYxNg==", "url": "https://github.com/splicemachine/spliceengine/pull/4253#discussion_r504179616", "bodyText": "You are correct, we get a semantic check error:\ncreate table SRT (a int primary key, b int not null, constraint fk foreign key (B) references SRT(a) on delete set null);\nERROR 42834: SET NULL cannot be specified because FOREIGN KEY 'FK'  cannot contain null values.", "author": "hatyo", "createdAt": "2020-10-13T18:44:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgzOTQyMw=="}], "type": "inlineReview"}, {"oid": "a0e78c7485a1d769a625c91f05f63814e9e7b4f6", "url": "https://github.com/splicemachine/spliceengine/commit/a0e78c7485a1d769a625c91f05f63814e9e7b4f6", "message": "DB-9009 address comments.", "committedDate": "2020-10-13T19:07:34Z", "type": "commit"}]}