{"pr_number": 3270, "pr_title": "DB-9179 support cast from char to char for bit data", "pr_createdAt": "2020-02-28T16:56:41Z", "pr_url": "https://github.com/splicemachine/spliceengine/pull/3270", "timeline": [{"oid": "df221fb220468d5d3529380b43abc6c044f66724", "url": "https://github.com/splicemachine/spliceengine/commit/df221fb220468d5d3529380b43abc6c044f66724", "message": "DB-9179 support cast from char to char for bit data\nDB-9179 allow char for bit data for locate\nDB-9179 allow implicit String to bytes conversion at client", "committedDate": "2020-02-28T16:49:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU5MjA3Ng==", "url": "https://github.com/splicemachine/spliceengine/pull/3270#discussion_r387592076", "bodyText": "Can you make sure we are raising the exception on the expected cases? You can assign the exception to a variable and make the check outside the catch clause, failing if we don't raise the exception when expected.", "author": "dgomezferro", "createdAt": "2020-03-04T10:57:21Z", "path": "splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/TernaryFunctionForBitDataIT.java", "diffHunk": "@@ -0,0 +1,375 @@\n+package com.splicemachine.derby.impl.sql.execute.operations;\n+\n+import com.splicemachine.db.iapi.reference.SQLState;\n+import com.splicemachine.derby.test.framework.SpliceSchemaWatcher;\n+import com.splicemachine.derby.test.framework.SpliceUnitTest;\n+import com.splicemachine.derby.test.framework.SpliceWatcher;\n+import com.splicemachine.homeless.TestUtils;\n+import com.splicemachine.test_tools.TableCreator;\n+import org.apache.log4j.Logger;\n+import org.junit.*;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.spark_project.guava.collect.Lists;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLSyntaxErrorException;\n+import java.util.Collection;\n+\n+import static com.splicemachine.test_tools.Rows.row;\n+import static com.splicemachine.test_tools.Rows.rows;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(Parameterized.class)\n+public class TernaryFunctionForBitDataIT extends SpliceUnitTest {\n+    private static Logger LOG = Logger.getLogger(TernaryFunctionForBitDataIT.class);\n+    public static final String CLASS_NAME = TernaryFunctionForBitDataIT.class.getSimpleName().toUpperCase();\n+    protected static SpliceWatcher spliceClassWatcher = new SpliceWatcher(CLASS_NAME);\n+    protected static SpliceSchemaWatcher spliceSchemaWatcher = new SpliceSchemaWatcher(CLASS_NAME);\n+\n+    @Parameterized.Parameters\n+    public static Collection<Object[]> data() {\n+        Collection<Object[]> params = Lists.newArrayListWithCapacity(2);\n+        params.add(new Object[]{\"true\"});\n+        params.add(new Object[]{\"false\"});\n+\n+        return params;\n+    }\n+\n+    private String useSpark;\n+\n+    public TernaryFunctionForBitDataIT(String useSpark) {\n+        this.useSpark = useSpark;\n+    }\n+\n+    @ClassRule\n+    public static TestRule chain = RuleChain.outerRule(spliceClassWatcher)\n+            .around(spliceSchemaWatcher);\n+    @Rule\n+    public SpliceWatcher methodWatcher = new SpliceWatcher(CLASS_NAME);\n+\n+    public static void createData(Connection conn, String schemaName) throws Exception {\n+\n+        new TableCreator(conn)\n+                .withCreate(\"create table t1(id int, a1 char(10), a2 varchar(10), a3 long varchar, a4 clob, \" +\n+                        \"a5 char(10) for bit data, a6 varchar(10) for bit data, a7 long varchar for bit data, a8 blob, \" +\n+                        \"b1 char(5), b2 varchar(5), b3 long varchar, b4 clob,\" +\n+                        \"b5 char(5) for bit data, b6 varchar(5) for bit data, b7 long varchar for bit data, b8 blob)\")\n+                .withInsert(\"insert into t1 values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) \")\n+                .withRows(rows(\n+                        row(1, \"abac bc\", \"abac bc\", \"abac bc\", \"abac bc\",\n+                                \"abac bc\".getBytes(), \"abac bc\".getBytes(), \"abac bc\".getBytes(), \"abac bc\".getBytes(),\n+                                \"aaa\", \"aaa\", \"aaa\", \"aaa\", \"aaa\".getBytes(), \"aaa\".getBytes(), \"aaa\".getBytes(), \"aaa\".getBytes()),\n+                        row(2, \"abac bc\", \"abac bc\", \"abac bc\", \"abac bc\", \"abac bc\".getBytes(), \"abac bc\".getBytes(), \"abac bc\".getBytes(), \"abac bc\".getBytes(),\n+                               \"ab\", \"ab\", \"ab\", \"ab\", \"ab\".getBytes(), \"ab\".getBytes(), \"ab\".getBytes(), \"ab\".getBytes()),\n+                        row(3, \"abac bc\", \"abac bc\", \"abac bc\", \"abac bc\",\n+                                \"abac bc\".getBytes(), \"abac bc\".getBytes(), \"abac bc\".getBytes(), \"abac bc\".getBytes(),\n+                                \"bc\", \"bc\", \"bc\", \"bc\", \"bc\".getBytes(), \"bc\".getBytes(), \"bc\".getBytes(), \"bc\".getBytes()),\n+                        row(4, \"ab\", \"ab\", \"ab\", \"ab\", \"ab\".getBytes(), \"ab\".getBytes(), \"ab\".getBytes(), \"ab\".getBytes(),\n+                                null, null, null, null, null, null, null, null),\n+                        row(5, \"\", \"\", \"\", \"\", \"\".getBytes(), \"\".getBytes(), \"\".getBytes(), \"\".getBytes(), null, null, null, null, null, null, null, null),\n+                        row(6, \"ab\", \"ab\", \"ab\", \"ab\", \"ab\".getBytes(), \"ab\".getBytes(), \"ab\".getBytes(), \"ab\".getBytes(),\n+                                \"\", \"\", \"\", \"\", \"\".getBytes(), \"\".getBytes(), \"\".getBytes(), \"\".getBytes()),\n+                        row(7, null, null, null, null, null, null, null, null,\n+                                \"aa\", \"aa\", \"aa\", \"aa\", \"aa\".getBytes(), \"aa\".getBytes(),\"aa\".getBytes(),\"aa\".getBytes())\n+                            ))\n+                .create();\n+        conn.commit();\n+    }\n+\n+    @BeforeClass\n+    public static void createDataSet() throws Exception {\n+        createData(spliceClassWatcher.getOrCreateConnection(), spliceSchemaWatcher.toString());\n+    }\n+\n+    @Test\n+    public void testLocateSearchFromSearchForOfDifferentTypeCombination1() throws Exception {\n+        /* fixed type - fixed type */\n+        String[] col1set = {\"a1\", \"a5\"};\n+        String[] col2set = {\"b1\", \"b5\"};\n+\n+        String expected = \"ID |      2      |   3    |  4  |\\n\" +\n+                \"---------------------------------\\n\" +\n+                \" 1 |-abac bc   - |-aaa  - |  0  |\\n\" +\n+                \" 2 |-abac bc   - |-ab   - |  0  |\\n\" +\n+                \" 3 |-abac bc   - |-bc   - |  6  |\\n\" +\n+                \" 4 |-ab        - | NULL   |NULL |\\n\" +\n+                \" 5 |-          - | NULL   |NULL |\\n\" +\n+                \" 6 |-ab        - |-     - |  3  |\\n\" +\n+                \" 7 |    NULL     |-aa   - |NULL |\";\n+\n+        String expected2 = \"ID |      2      |   3    | 4 |\\n\" +\n+                \"-------------------------------\\n\" +\n+                \" 3 |-abac bc   - |-bc   - | 6 |\\n\" +\n+                \" 6 |-ab        - |-     - | 3 |\";\n+\n+        for (String col1: col1set) {\n+            for (String col2 : col2set) {\n+                /* Q1 */\n+                String sqlText = format(\"select id, '-' || a1 || '-', '-' || b1 || '-', locate(%1$s,%2$s) from t1 --splice-properties useSpark=%3$s\\n order by id\", col2, col1, useSpark);\n+\n+                ResultSet rs = methodWatcher.executeQuery(sqlText);\n+                Assert.assertEquals(\"\\nlocate(\" + col2 + \",\" + col1 + \"):\" + sqlText + \"\\n\", expected, TestUtils.FormattedResult.ResultFactory.toString(rs));\n+                rs.close();\n+\n+                /* Q2 */\n+                sqlText = format(\"select id, '-' || a1 || '-', '-' || b1 || '-', locate(%1$s,%2$s) from t1 --splice-properties useSpark=%3$s\\n where locate(%1$s,%2$s)>1 order by id\", col2, col1, useSpark);\n+\n+                rs = methodWatcher.executeQuery(sqlText);\n+                Assert.assertEquals(\"\\nlocate(\" + col2 + \",\" + col1 + \"):\" + sqlText + \"\\n\", expected2, TestUtils.FormattedResult.ResultFactory.toString(rs));\n+                rs.close();\n+            }\n+        }\n+    }\n+\n+\n+    @Test\n+    public void testLocateSearchFromSearchForOfDifferentTypeCombination2() throws Exception {\n+        /* fixed type - var type(no long varchar */\n+        String[] col1set = {\"a1\", \"a5\"};\n+        String[] col2set = {\"b2\", \"b3\", \"b4\", \"b6\", \"b7\", \"b8\"};\n+\n+        String expected = \"ID |      2      |  3   |  4  |\\n\" +\n+        \"-------------------------------\\n\" +\n+                \" 1 |-abac bc   - |-aaa- |  0  |\\n\" +\n+                \" 2 |-abac bc   - |-ab-  |  1  |\\n\" +\n+                \" 3 |-abac bc   - |-bc-  |  6  |\\n\" +\n+                \" 4 |-ab        - |NULL  |NULL |\\n\" +\n+                \" 5 |-          - |NULL  |NULL |\\n\" +\n+                \" 6 |-ab        - | --   |  1  |\\n\" +\n+                \" 7 |    NULL     |-aa-  |NULL |\";\n+\n+        String expected2 = \"ID |      2      |  3  | 4 |\\n\" +\n+                \"----------------------------\\n\" +\n+                \" 3 |-abac bc   - |-bc- | 6 |\";\n+\n+        for (String col1: col1set) {\n+            for (String col2 : col2set) {\n+                try {\n+                    /* Q1 */\n+                    String sqlText = format(\"select id, '-' || a1 || '-', '-' || b2 || '-', locate(%1$s,%2$s) from t1 --splice-properties useSpark=%3$s\\n order by id\", col2, col1, useSpark);\n+\n+                    ResultSet rs = methodWatcher.executeQuery(sqlText);\n+                    Assert.assertEquals(\"\\nlocate(\" + col2 + \",\" + col1 + \"):\" + sqlText + \"\\n\", expected, TestUtils.FormattedResult.ResultFactory.toString(rs));\n+                    rs.close();\n+\n+                    /* Q2 */\n+                    sqlText = format(\"select id, '-' || a1 || '-', '-' || b2 || '-', locate(%1$s,%2$s) from t1 --splice-properties useSpark=%3$s\\n where locate(%1$s,%2$s)>1 order by id\", col2, col1, useSpark);\n+\n+                    rs = methodWatcher.executeQuery(sqlText);\n+                    Assert.assertEquals(\"\\nlocate(\" + col2 + \",\" + col1 + \"):\" + sqlText + \"\\n\", expected2, TestUtils.FormattedResult.ResultFactory.toString(rs));\n+                    rs.close();\n+                } catch (SQLSyntaxErrorException e) {\n+                    // it is expected that long varchar and clob are not compared with bit data type", "originalCommit": "df221fb220468d5d3529380b43abc6c044f66724", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg5MTAwOA==", "url": "https://github.com/splicemachine/spliceengine/pull/3270#discussion_r387891008", "bodyText": "Done!", "author": "yxia92", "createdAt": "2020-03-04T19:39:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU5MjA3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU5MzgzMw==", "url": "https://github.com/splicemachine/spliceengine/pull/3270#discussion_r387593833", "bodyText": "You can use a try-with-resources to simplify this:\ntry (ResultSet rs = ps.executeQuery()) {\n}\nIt will automatically close the resultset for you.", "author": "dgomezferro", "createdAt": "2020-03-04T11:00:45Z", "path": "splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/TernaryFunctionForBitDataIT.java", "diffHunk": "@@ -0,0 +1,375 @@\n+package com.splicemachine.derby.impl.sql.execute.operations;\n+\n+import com.splicemachine.db.iapi.reference.SQLState;\n+import com.splicemachine.derby.test.framework.SpliceSchemaWatcher;\n+import com.splicemachine.derby.test.framework.SpliceUnitTest;\n+import com.splicemachine.derby.test.framework.SpliceWatcher;\n+import com.splicemachine.homeless.TestUtils;\n+import com.splicemachine.test_tools.TableCreator;\n+import org.apache.log4j.Logger;\n+import org.junit.*;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.spark_project.guava.collect.Lists;\n+\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLSyntaxErrorException;\n+import java.util.Collection;\n+\n+import static com.splicemachine.test_tools.Rows.row;\n+import static com.splicemachine.test_tools.Rows.rows;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(Parameterized.class)\n+public class TernaryFunctionForBitDataIT extends SpliceUnitTest {\n+    private static Logger LOG = Logger.getLogger(TernaryFunctionForBitDataIT.class);\n+    public static final String CLASS_NAME = TernaryFunctionForBitDataIT.class.getSimpleName().toUpperCase();\n+    protected static SpliceWatcher spliceClassWatcher = new SpliceWatcher(CLASS_NAME);\n+    protected static SpliceSchemaWatcher spliceSchemaWatcher = new SpliceSchemaWatcher(CLASS_NAME);\n+\n+    @Parameterized.Parameters\n+    public static Collection<Object[]> data() {\n+        Collection<Object[]> params = Lists.newArrayListWithCapacity(2);\n+        params.add(new Object[]{\"true\"});\n+        params.add(new Object[]{\"false\"});\n+\n+        return params;\n+    }\n+\n+    private String useSpark;\n+\n+    public TernaryFunctionForBitDataIT(String useSpark) {\n+        this.useSpark = useSpark;\n+    }\n+\n+    @ClassRule\n+    public static TestRule chain = RuleChain.outerRule(spliceClassWatcher)\n+            .around(spliceSchemaWatcher);\n+    @Rule\n+    public SpliceWatcher methodWatcher = new SpliceWatcher(CLASS_NAME);\n+\n+    public static void createData(Connection conn, String schemaName) throws Exception {\n+\n+        new TableCreator(conn)\n+                .withCreate(\"create table t1(id int, a1 char(10), a2 varchar(10), a3 long varchar, a4 clob, \" +\n+                        \"a5 char(10) for bit data, a6 varchar(10) for bit data, a7 long varchar for bit data, a8 blob, \" +\n+                        \"b1 char(5), b2 varchar(5), b3 long varchar, b4 clob,\" +\n+                        \"b5 char(5) for bit data, b6 varchar(5) for bit data, b7 long varchar for bit data, b8 blob)\")\n+                .withInsert(\"insert into t1 values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) \")\n+                .withRows(rows(\n+                        row(1, \"abac bc\", \"abac bc\", \"abac bc\", \"abac bc\",\n+                                \"abac bc\".getBytes(), \"abac bc\".getBytes(), \"abac bc\".getBytes(), \"abac bc\".getBytes(),\n+                                \"aaa\", \"aaa\", \"aaa\", \"aaa\", \"aaa\".getBytes(), \"aaa\".getBytes(), \"aaa\".getBytes(), \"aaa\".getBytes()),\n+                        row(2, \"abac bc\", \"abac bc\", \"abac bc\", \"abac bc\", \"abac bc\".getBytes(), \"abac bc\".getBytes(), \"abac bc\".getBytes(), \"abac bc\".getBytes(),\n+                               \"ab\", \"ab\", \"ab\", \"ab\", \"ab\".getBytes(), \"ab\".getBytes(), \"ab\".getBytes(), \"ab\".getBytes()),\n+                        row(3, \"abac bc\", \"abac bc\", \"abac bc\", \"abac bc\",\n+                                \"abac bc\".getBytes(), \"abac bc\".getBytes(), \"abac bc\".getBytes(), \"abac bc\".getBytes(),\n+                                \"bc\", \"bc\", \"bc\", \"bc\", \"bc\".getBytes(), \"bc\".getBytes(), \"bc\".getBytes(), \"bc\".getBytes()),\n+                        row(4, \"ab\", \"ab\", \"ab\", \"ab\", \"ab\".getBytes(), \"ab\".getBytes(), \"ab\".getBytes(), \"ab\".getBytes(),\n+                                null, null, null, null, null, null, null, null),\n+                        row(5, \"\", \"\", \"\", \"\", \"\".getBytes(), \"\".getBytes(), \"\".getBytes(), \"\".getBytes(), null, null, null, null, null, null, null, null),\n+                        row(6, \"ab\", \"ab\", \"ab\", \"ab\", \"ab\".getBytes(), \"ab\".getBytes(), \"ab\".getBytes(), \"ab\".getBytes(),\n+                                \"\", \"\", \"\", \"\", \"\".getBytes(), \"\".getBytes(), \"\".getBytes(), \"\".getBytes()),\n+                        row(7, null, null, null, null, null, null, null, null,\n+                                \"aa\", \"aa\", \"aa\", \"aa\", \"aa\".getBytes(), \"aa\".getBytes(),\"aa\".getBytes(),\"aa\".getBytes())\n+                            ))\n+                .create();\n+        conn.commit();\n+    }\n+\n+    @BeforeClass\n+    public static void createDataSet() throws Exception {\n+        createData(spliceClassWatcher.getOrCreateConnection(), spliceSchemaWatcher.toString());\n+    }\n+\n+    @Test\n+    public void testLocateSearchFromSearchForOfDifferentTypeCombination1() throws Exception {\n+        /* fixed type - fixed type */\n+        String[] col1set = {\"a1\", \"a5\"};\n+        String[] col2set = {\"b1\", \"b5\"};\n+\n+        String expected = \"ID |      2      |   3    |  4  |\\n\" +\n+                \"---------------------------------\\n\" +\n+                \" 1 |-abac bc   - |-aaa  - |  0  |\\n\" +\n+                \" 2 |-abac bc   - |-ab   - |  0  |\\n\" +\n+                \" 3 |-abac bc   - |-bc   - |  6  |\\n\" +\n+                \" 4 |-ab        - | NULL   |NULL |\\n\" +\n+                \" 5 |-          - | NULL   |NULL |\\n\" +\n+                \" 6 |-ab        - |-     - |  3  |\\n\" +\n+                \" 7 |    NULL     |-aa   - |NULL |\";\n+\n+        String expected2 = \"ID |      2      |   3    | 4 |\\n\" +\n+                \"-------------------------------\\n\" +\n+                \" 3 |-abac bc   - |-bc   - | 6 |\\n\" +\n+                \" 6 |-ab        - |-     - | 3 |\";\n+\n+        for (String col1: col1set) {\n+            for (String col2 : col2set) {\n+                /* Q1 */\n+                String sqlText = format(\"select id, '-' || a1 || '-', '-' || b1 || '-', locate(%1$s,%2$s) from t1 --splice-properties useSpark=%3$s\\n order by id\", col2, col1, useSpark);\n+\n+                ResultSet rs = methodWatcher.executeQuery(sqlText);\n+                Assert.assertEquals(\"\\nlocate(\" + col2 + \",\" + col1 + \"):\" + sqlText + \"\\n\", expected, TestUtils.FormattedResult.ResultFactory.toString(rs));\n+                rs.close();\n+\n+                /* Q2 */\n+                sqlText = format(\"select id, '-' || a1 || '-', '-' || b1 || '-', locate(%1$s,%2$s) from t1 --splice-properties useSpark=%3$s\\n where locate(%1$s,%2$s)>1 order by id\", col2, col1, useSpark);\n+\n+                rs = methodWatcher.executeQuery(sqlText);\n+                Assert.assertEquals(\"\\nlocate(\" + col2 + \",\" + col1 + \"):\" + sqlText + \"\\n\", expected2, TestUtils.FormattedResult.ResultFactory.toString(rs));\n+                rs.close();\n+            }\n+        }\n+    }\n+\n+\n+    @Test\n+    public void testLocateSearchFromSearchForOfDifferentTypeCombination2() throws Exception {\n+        /* fixed type - var type(no long varchar */\n+        String[] col1set = {\"a1\", \"a5\"};\n+        String[] col2set = {\"b2\", \"b3\", \"b4\", \"b6\", \"b7\", \"b8\"};\n+\n+        String expected = \"ID |      2      |  3   |  4  |\\n\" +\n+        \"-------------------------------\\n\" +\n+                \" 1 |-abac bc   - |-aaa- |  0  |\\n\" +\n+                \" 2 |-abac bc   - |-ab-  |  1  |\\n\" +\n+                \" 3 |-abac bc   - |-bc-  |  6  |\\n\" +\n+                \" 4 |-ab        - |NULL  |NULL |\\n\" +\n+                \" 5 |-          - |NULL  |NULL |\\n\" +\n+                \" 6 |-ab        - | --   |  1  |\\n\" +\n+                \" 7 |    NULL     |-aa-  |NULL |\";\n+\n+        String expected2 = \"ID |      2      |  3  | 4 |\\n\" +\n+                \"----------------------------\\n\" +\n+                \" 3 |-abac bc   - |-bc- | 6 |\";\n+\n+        for (String col1: col1set) {\n+            for (String col2 : col2set) {\n+                try {\n+                    /* Q1 */\n+                    String sqlText = format(\"select id, '-' || a1 || '-', '-' || b2 || '-', locate(%1$s,%2$s) from t1 --splice-properties useSpark=%3$s\\n order by id\", col2, col1, useSpark);\n+\n+                    ResultSet rs = methodWatcher.executeQuery(sqlText);\n+                    Assert.assertEquals(\"\\nlocate(\" + col2 + \",\" + col1 + \"):\" + sqlText + \"\\n\", expected, TestUtils.FormattedResult.ResultFactory.toString(rs));\n+                    rs.close();\n+\n+                    /* Q2 */\n+                    sqlText = format(\"select id, '-' || a1 || '-', '-' || b2 || '-', locate(%1$s,%2$s) from t1 --splice-properties useSpark=%3$s\\n where locate(%1$s,%2$s)>1 order by id\", col2, col1, useSpark);\n+\n+                    rs = methodWatcher.executeQuery(sqlText);\n+                    Assert.assertEquals(\"\\nlocate(\" + col2 + \",\" + col1 + \"):\" + sqlText + \"\\n\", expected2, TestUtils.FormattedResult.ResultFactory.toString(rs));\n+                    rs.close();\n+                } catch (SQLSyntaxErrorException e) {\n+                    // it is expected that long varchar and clob are not compared with bit data type\n+                    if ((col2.equals(\"b3\") || col2.equals(\"b4\")) && col1.equals(\"a5\"))\n+                        Assert.assertEquals(\"locate(\" + col2 + \",\" + col1 + \"):\" + e.getMessage(), SQLState.LANG_DB2_FUNCTION_INCOMPATIBLE, e.getSQLState());\n+                    else\n+                        Assert.fail(\"locate(\" + col2 + \",\" + col1 + \"):\" + e.getMessage());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testLocateSearchFromSearchForOfDifferentTypeCombination3() throws Exception {\n+        /* var type - fix type */\n+        String[] col1set = {\"a2\", \"a3\", \"a4\", \"a6\", \"a7\", \"a8\"};\n+        String[] col2set = {\"b1\", \"b5\"};\n+\n+        String expected = \"ID |    2     |   3    |  4  |\\n\" +\n+                \"------------------------------\\n\" +\n+                \" 1 |-abac bc- |-aaa  - |  0  |\\n\" +\n+                \" 2 |-abac bc- |-ab   - |  0  |\\n\" +\n+                \" 3 |-abac bc- |-bc   - |  0  |\\n\" +\n+                \" 4 |  -ab-    | NULL   |NULL |\\n\" +\n+                \" 5 |   --     | NULL   |NULL |\\n\" +\n+                \" 6 |  -ab-    |-     - |  0  |\\n\" +\n+                \" 7 |  NULL    |-aa   - |NULL |\";\n+\n+        String expected2 = \"\";\n+\n+        for (String col1: col1set) {\n+            for (String col2 : col2set) {\n+                try {\n+                    /* Q1 */\n+                    String sqlText = format(\"select id, '-' || a2 || '-', '-' || b1 || '-', locate(%1$s,%2$s) from t1 --splice-properties useSpark=%3$s\\n order by id\", col2, col1, useSpark);\n+\n+                    ResultSet rs = methodWatcher.executeQuery(sqlText);\n+                    Assert.assertEquals(\"\\nlocate(\" + col2 + \",\" + col1 + \"):\" + sqlText + \"\\n\", expected, TestUtils.FormattedResult.ResultFactory.toString(rs));\n+                    rs.close();\n+\n+                    /* Q2 */\n+                    sqlText = format(\"select id, '-' || a2 || '-', '-' || b1 || '-', locate(%1$s,%2$s) from t1 --splice-properties useSpark=%3$s\\n where locate(%1$s,%2$s)>1 order by id\", col2, col1, useSpark);\n+\n+                    rs = methodWatcher.executeQuery(sqlText);\n+                    Assert.assertEquals(\"\\nlocate(\" + col2 + \",\" + col1 + \"):\" + sqlText + \"\\n\", expected2, TestUtils.FormattedResult.ResultFactory.toString(rs));\n+                    rs.close();\n+                } catch (SQLSyntaxErrorException e) {\n+                    // it is expected that long varchar and clob are not compared with bit data type\n+                    if ((col1.equals(\"a3\") || col1.equals(\"a4\")) && col2.equals(\"b5\"))\n+                        Assert.assertEquals(\"locate(\" + col2 + \",\" + col1 + \"):\" + e.getMessage(), SQLState.LANG_DB2_FUNCTION_INCOMPATIBLE, e.getSQLState());\n+                    else\n+                        Assert.fail(\"locate(\" + col2 + \",\" + col1 + \"):\" + e.getMessage());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testLocateSearchFromSearchForOfDifferentTypeCombination4() throws Exception {\n+        /* var type - var type */\n+        String[] col1set = {\"a2\", \"a3\", \"a4\", \"a6\", \"a7\", \"a8\"};\n+        String[] col2set = {\"b2\", \"b3\", \"b4\", \"b6\", \"b7\", \"b8\"};\n+\n+        String expected = \"ID |    2     |  3   |  4  |\\n\" +\n+                \"----------------------------\\n\" +\n+                \" 1 |-abac bc- |-aaa- |  0  |\\n\" +\n+                \" 2 |-abac bc- |-ab-  |  1  |\\n\" +\n+                \" 3 |-abac bc- |-bc-  |  6  |\\n\" +\n+                \" 4 |  -ab-    |NULL  |NULL |\\n\" +\n+                \" 5 |   --     |NULL  |NULL |\\n\" +\n+                \" 6 |  -ab-    | --   |  1  |\\n\" +\n+                \" 7 |  NULL    |-aa-  |NULL |\";\n+\n+        String expected2 = \"ID |    2     |  3  | 4 |\\n\" +\n+                \"-------------------------\\n\" +\n+                \" 3 |-abac bc- |-bc- | 6 |\";\n+\n+        for (String col1: col1set) {\n+            for (String col2 : col2set) {\n+                try {\n+                    /* Q1 */\n+                    String sqlText = format(\"select id, '-' || a2 || '-', '-' || b2 || '-', locate(%1$s,%2$s) from t1 --splice-properties useSpark=%3$s\\n order by id\", col2, col1, useSpark);\n+\n+                    ResultSet rs = methodWatcher.executeQuery(sqlText);\n+                    Assert.assertEquals(\"\\nlocate(\" + col2 + \",\" + col1 + \"):\" + sqlText + \"\\n\", expected, TestUtils.FormattedResult.ResultFactory.toString(rs));\n+                    rs.close();\n+\n+                    /* Q2 */\n+                    sqlText = format(\"select id, '-' || a2 || '-', '-' || b2 || '-', locate(%1$s,%2$s) from t1 --splice-properties useSpark=%3$s\\n where locate(%1$s,%2$s)>1 order by id\", col2, col1, useSpark);\n+\n+                    rs = methodWatcher.executeQuery(sqlText);\n+                    Assert.assertEquals(\"\\nlocate(\" + col2 + \",\" + col1 + \"):\" + sqlText + \"\\n\", expected2, TestUtils.FormattedResult.ResultFactory.toString(rs));\n+                    rs.close();\n+                } catch (SQLSyntaxErrorException e) {\n+                    // it is expected that long varchar and clob are not compared with bit data type\n+                    if ((col1.equals(\"a3\") || col1.equals(\"a4\")) && (col2.equals(\"b6\") || col2.equals(\"b7\") || col2.equals(\"b8\")) ||\n+                        (col2.equals(\"b3\") || col2.equals(\"b4\")) && (col1.equals(\"a6\") || col1.equals(\"a7\") || col1.equals(\"a8\")))\n+                        Assert.assertEquals(\"locate(\" + col2 + \",\" + col1 + \"):\" + e.getMessage(), SQLState.LANG_DB2_FUNCTION_INCOMPATIBLE, e.getSQLState());\n+                    else\n+                        Assert.fail(\"locate(\" + col2 + \",\" + col1 + \"):\" + e.getMessage());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testLocateParameterizedQuery1() throws Exception {\n+        ResultSet rs = null;\n+        String sqlText = format(\"select id, '-' || a2 || '-', locate(?, a5) from t1 --splice-properties useSpark=%s\\n order by id\", useSpark);\n+        try {\n+            PreparedStatement ps = methodWatcher.prepareStatement(sqlText);\n+            ps.setBytes(1, \"ac\".getBytes());\n+            rs = ps.executeQuery();\n+\n+            String expected = \"ID |    2     |  3  |\\n\" +\n+                    \"---------------------\\n\" +\n+                    \" 1 |-abac bc- |  3  |\\n\" +\n+                    \" 2 |-abac bc- |  3  |\\n\" +\n+                    \" 3 |-abac bc- |  3  |\\n\" +\n+                    \" 4 |  -ab-    |  0  |\\n\" +\n+                    \" 5 |   --     |  0  |\\n\" +\n+                    \" 6 |  -ab-    |  0  |\\n\" +\n+                    \" 7 |  NULL    |NULL |\";\n+\n+            Assert.assertEquals(\"\\n\" + sqlText + \"\\n\", expected, TestUtils.FormattedResult.ResultFactory.toString(rs));\n+        } finally {", "originalCommit": "df221fb220468d5d3529380b43abc6c044f66724", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg5MDk1Nw==", "url": "https://github.com/splicemachine/spliceengine/pull/3270#discussion_r387890957", "bodyText": "Done!", "author": "yxia92", "createdAt": "2020-03-04T19:39:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU5MzgzMw=="}], "type": "inlineReview"}, {"oid": "b316f4a8d29aaed08fc23f210488ff46f22a0035", "url": "https://github.com/splicemachine/spliceengine/commit/b316f4a8d29aaed08fc23f210488ff46f22a0035", "message": "DB-9179 address review comments", "committedDate": "2020-03-04T19:36:40Z", "type": "commit"}, {"oid": "9e17a4cc90a979754a07aac1e6b0f6e9b158f71f", "url": "https://github.com/splicemachine/spliceengine/commit/9e17a4cc90a979754a07aac1e6b0f6e9b158f71f", "message": "Merge remote-tracking branch 'origin/master' into DB-9179", "committedDate": "2020-03-04T20:28:35Z", "type": "commit"}]}