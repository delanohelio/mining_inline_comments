{"pr_number": 4197, "pr_title": "DB-9330 Add option for batched newTimestamp RPCs", "pr_createdAt": "2020-09-29T08:03:12Z", "pr_url": "https://github.com/splicemachine/spliceengine/pull/4197", "timeline": [{"oid": "9ead673016d2594ee0b4d76e9a5b5953f8e30a67", "url": "https://github.com/splicemachine/spliceengine/commit/9ead673016d2594ee0b4d76e9a5b5953f8e30a67", "message": "DB-9330 Add option for batched newTimestamp RPCs\n\nPort Timestamp Client/Server to Netty 4", "committedDate": "2020-09-29T07:59:42Z", "type": "commit"}, {"oid": "9eb6ca65e88b9e23e66a7b7c47e6fa31322fbff3", "url": "https://github.com/splicemachine/spliceengine/commit/9eb6ca65e88b9e23e66a7b7c47e6fa31322fbff3", "message": "Merge remote-tracking branch 'origin/master' into DB-9330", "committedDate": "2020-09-29T09:37:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUzMzc0Mg==", "url": "https://github.com/splicemachine/spliceengine/pull/4197#discussion_r500533742", "bodyText": "Is this comment still relevant?  I don't see the synchronize block.", "author": "msirek", "createdAt": "2020-10-06T19:09:24Z", "path": "splice_timestamp_api/src/main/java/com/splicemachine/timestamp/impl/TimestampConnection.java", "diffHunk": "@@ -0,0 +1,403 @@\n+/*\n+ * Copyright (c) 2012 - 2020 Splice Machine, Inc.\n+ *\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.splicemachine.timestamp.impl;\n+\n+import com.splicemachine.concurrent.CountDownLatches;\n+import com.splicemachine.timestamp.api.Callback;\n+import com.splicemachine.timestamp.api.TimestampClientStatistics;\n+import com.splicemachine.timestamp.api.TimestampHostProvider;\n+import com.splicemachine.timestamp.api.TimestampIOException;\n+import com.splicemachine.utils.SpliceLogUtils;\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioSocketChannel;\n+import io.netty.handler.codec.LengthFieldBasedFrameDecoder;\n+import io.netty.handler.codec.LengthFieldPrepender;\n+import io.netty.handler.codec.protobuf.ProtobufDecoder;\n+import io.netty.handler.codec.protobuf.ProtobufEncoder;\n+import org.apache.log4j.Logger;\n+import splice.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+import javax.management.InstanceAlreadyExistsException;\n+import javax.management.MBeanRegistrationException;\n+import javax.management.MBeanServer;\n+import javax.management.MalformedObjectNameException;\n+import javax.management.NotCompliantMBeanException;\n+import javax.management.ObjectName;\n+import java.lang.management.ManagementFactory;\n+import java.net.InetSocketAddress;\n+import java.util.Random;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * Manages a connection to the Timestamp Server\n+ */\n+public class TimestampConnection extends TimestampBaseHandler<TimestampMessage.TimestampResponse> implements TimestampClientStatistics {\n+\n+\n+    private static final Logger LOG = Logger.getLogger(TimestampConnection.class);\n+\n+    private static final short CLIENT_COUNTER_INIT = 100; // actual value doesn't matter\n+\n+    private enum State {\n+        DISCONNECTED, CONNECTING, CONNECTED, SHUTDOWN\n+    }\n+\n+    /**\n+     * A map representing all currently active callers to this TimestampClient\n+     * waiting for their response.\n+     */\n+    private ConcurrentMap<Short, Callback> clientCallbacks = null;\n+\n+    private final AtomicReference<State> state = new AtomicReference<>(State.DISCONNECTED);\n+\n+    private volatile Channel channel;\n+\n+    /**\n+     * Internal unique identifier for a single synchronous call to this instance\n+     * of {@link TimestampConnection}. Necessary in order to subsequently associate\n+     * a server response with the original request. Although this is an atomic integer,\n+     * we consume it internally as a short so that we only pass two bytes (not four)\n+     * over the wire.\n+     */\n+    // We might even get away with using a byte here (256 concurrent client calls),\n+    // but use a short just in case.\n+    private AtomicInteger clientCallCounter = new AtomicInteger(CLIENT_COUNTER_INIT);\n+\n+    int timeoutMillis;\n+\n+    // Metrics to expose via JMX. See TimestampClientStatistics\n+    // for solid definitions of each metric.\n+    private AtomicLong numRequests = new AtomicLong(0);\n+    private AtomicLong totalRequestDuration = new AtomicLong(0);\n+    private TimestampHostProvider timestampHostProvider;\n+    private Bootstrap bootstrap;\n+    private EventLoopGroup workerGroup;\n+\n+\n+    public TimestampConnection(int timeoutMillis, TimestampHostProvider timestampHostProvider) {\n+        this.timeoutMillis = timeoutMillis;\n+        this.timestampHostProvider = timestampHostProvider;\n+        clientCallbacks = new ConcurrentHashMap<>();\n+\n+        workerGroup =  new NioEventLoopGroup(2, new ThreadFactoryBuilder().setNameFormat(\"TimestampClient-worker-%d\").setDaemon(true).build());\n+\n+        bootstrap = new Bootstrap();\n+        bootstrap.group(workerGroup);\n+        bootstrap.channel(NioSocketChannel.class);\n+        bootstrap.option(ChannelOption.SO_KEEPALIVE, true);\n+        bootstrap.option(ChannelOption.SO_REUSEADDR, true);\n+        bootstrap.option(ChannelOption.TCP_NODELAY, true);\n+        bootstrap.handler(new ChannelInitializer<SocketChannel>() {\n+            @Override\n+            public void initChannel(SocketChannel ch) throws Exception {\n+                ch.pipeline()\n+                .addLast(\"frameDecoder\", new LengthFieldBasedFrameDecoder(1048576, 0, 4, 0, 4))\n+                .addLast(\"protobufDecoder\", new ProtobufDecoder(TimestampMessage.TimestampResponse.getDefaultInstance()))\n+                .addLast(\"frameEncoder\", new LengthFieldPrepender(4))\n+                .addLast(\"protobufEncoder\", new ProtobufEncoder())\n+                .addLast(\"handler\", TimestampConnection.this);\n+            }\n+        });\n+\n+        try {\n+            registerJMX();\n+        } catch (Exception e) {\n+            SpliceLogUtils.error(LOG, \"Unable to register TimestampClient with JMX. Timestamps will still be generated but metrics will not be available.\");\n+        }\n+    }\n+\n+    public void shutdown() {\n+        boolean shouldContinue = true;\n+        while(shouldContinue){\n+            State state=this.state.get();\n+            if(state== State.SHUTDOWN) return;\n+            shouldContinue=!this.state.compareAndSet(state, State.SHUTDOWN);\n+        }\n+        LOG.info(String.format(\"shutting down TimestampClient state=%s\", this.state.get()));\n+        try {\n+            this.state.set(State.SHUTDOWN);\n+            workerGroup.shutdownGracefully();\n+        } catch (Throwable t) {\n+            LOG.error(\"error shutting down\", t);\n+        }\n+    }\n+\n+    /**\n+     * Returns the port number which the client should use when connecting\n+     * to the timestamp server.\n+     */\n+    protected int getPort() {\n+        return timestampHostProvider.getPort();\n+    }\n+\n+    protected void connectIfNeeded() throws TimestampIOException{\n+\n+        // Even though state is an atomic reference, synchronize on whole block\n+        // including code that attempts connection. Otherwise, two threads might\n+        // end up trying to connect at the same time.", "originalCommit": "9eb6ca65e88b9e23e66a7b7c47e6fa31322fbff3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEzOTQ0OQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4197#discussion_r501139449", "bodyText": "It looks outdated, I moved that directly from TimestampClient, if I get a chance I'll update it. Thanks!", "author": "dgomezferro", "createdAt": "2020-10-07T16:14:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUzMzc0Mg=="}], "type": "inlineReview"}]}