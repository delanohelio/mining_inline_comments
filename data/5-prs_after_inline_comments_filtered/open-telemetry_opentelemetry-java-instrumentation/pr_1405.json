{"pr_number": 1405, "pr_title": "Lettuce 5.1 instrumentation should log normalised commands as db.statement", "pr_createdAt": "2020-10-16T16:02:12Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1405", "timeline": [{"oid": "d0f943b7d163f3e7dd981f282bc41f56269d0b7d", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/d0f943b7d163f3e7dd981f282bc41f56269d0b7d", "message": "Lettuce 5.1 instrumentation should log normalised commands as db.statement", "committedDate": "2020-10-16T15:55:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU3MzY3MA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1405#discussion_r506573670", "bodyText": "This class can be reused by other Redis libraries' instrumentations; I'll move it to some common package (javaagent-api?) in next PR and call it whenever args are available. Currently lettuce 5.1 is the only Redis lib instrumentation that logs actual statement, not just the bare command.", "author": "mateuszrzeszutek", "createdAt": "2020-10-16T16:04:41Z", "path": "instrumentation/lettuce/lettuce-5.1/src/main/java/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/RedisCommandNormalizer.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.lettuce.v5_1;\n+\n+import static java.util.Collections.unmodifiableMap;\n+\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.CommandAndNumArgs;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.Default;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.Eval;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.MultiKeyValue;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/** This class is responsible for masking potentially sensitive data in Redis commands. */\n+public final class RedisCommandNormalizer {", "originalCommit": "d0f943b7d163f3e7dd981f282bc41f56269d0b7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU3NzE3MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1405#discussion_r506577171", "bodyText": "#1406", "author": "mateuszrzeszutek", "createdAt": "2020-10-16T16:10:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU3MzY3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjczOTA2OA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1405#discussion_r506739068", "bodyText": "should the default be keepZeroArgs (same as AUTH) to be on the safe side (e.g. for future commands we don't know about yet)", "author": "trask", "createdAt": "2020-10-16T21:58:45Z", "path": "instrumentation/lettuce/lettuce-5.1/src/main/java/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/RedisCommandNormalizer.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.lettuce.v5_1;\n+\n+import static java.util.Collections.unmodifiableMap;\n+\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.CommandAndNumArgs;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.Default;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.Eval;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.MultiKeyValue;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/** This class is responsible for masking potentially sensitive data in Redis commands. */\n+public final class RedisCommandNormalizer {\n+\n+  private static final Map<String, CommandNormalizer> NORMALIZERS;\n+\n+  static {\n+    Map<String, CommandNormalizer> normalizers = new HashMap<>();\n+\n+    CommandNormalizer keepOneArg = new CommandAndNumArgs(1);\n+    CommandNormalizer keepTwoArgs = new CommandAndNumArgs(2);\n+    CommandNormalizer setMultiHashField = new MultiKeyValue(1);\n+    CommandNormalizer setMultiField = new MultiKeyValue(0);\n+\n+    // Connection\n+    // can contain AUTH data\n+    normalizers.put(\"AUTH\", new CommandAndNumArgs(0));\n+    normalizers.put(\"HELLO\", keepTwoArgs);\n+\n+    // Hashes\n+    normalizers.put(\"HMSET\", setMultiHashField);\n+    normalizers.put(\"HSET\", setMultiHashField);\n+    normalizers.put(\"HSETNX\", keepTwoArgs);\n+\n+    // HyperLogLog\n+    normalizers.put(\"PFADD\", keepOneArg);\n+\n+    // Keys\n+    // can contain AUTH data\n+    normalizers.put(\"MIGRATE\", new CommandAndNumArgs(6));\n+\n+    // Lists\n+    normalizers.put(\"LINSERT\", keepTwoArgs);\n+    normalizers.put(\"LPOS\", keepOneArg);\n+    normalizers.put(\"LPUSH\", keepOneArg);\n+    normalizers.put(\"LPUSHX\", keepOneArg);\n+    normalizers.put(\"LREM\", keepOneArg);\n+    normalizers.put(\"LSET\", keepOneArg);\n+    normalizers.put(\"RPUSH\", keepOneArg);\n+    normalizers.put(\"RPUSHX\", keepOneArg);\n+\n+    // Pub/Sub\n+    normalizers.put(\"PUBLISH\", keepOneArg);\n+\n+    // Scripting\n+    normalizers.put(\"EVAL\", Eval.INSTANCE);\n+    normalizers.put(\"EVALSHA\", Eval.INSTANCE);\n+\n+    // Sets\n+    normalizers.put(\"SADD\", keepOneArg);\n+    normalizers.put(\"SISMEMBER\", keepOneArg);\n+    normalizers.put(\"SMISMEMBER\", keepOneArg);\n+    normalizers.put(\"SMOVE\", keepTwoArgs);\n+    normalizers.put(\"SREM\", keepOneArg);\n+\n+    // Sorted Sets\n+    normalizers.put(\"ZADD\", keepOneArg);\n+    normalizers.put(\"ZCOUNT\", keepOneArg);\n+    normalizers.put(\"ZINCRBY\", keepOneArg);\n+    normalizers.put(\"ZLEXCOUNT\", keepOneArg);\n+    normalizers.put(\"ZMSCORE\", keepOneArg);\n+    normalizers.put(\"ZRANGEBYLEX\", keepOneArg);\n+    normalizers.put(\"ZRANGEBYSCORE\", keepOneArg);\n+    normalizers.put(\"ZRANK\", keepOneArg);\n+    normalizers.put(\"ZREM\", keepOneArg);\n+    normalizers.put(\"ZREMRANGEBYLEX\", keepOneArg);\n+    normalizers.put(\"ZREMRANGEBYSCORE\", keepOneArg);\n+    normalizers.put(\"ZREVRANGEBYLEX\", keepOneArg);\n+    normalizers.put(\"ZREVRANGEBYSCORE\", keepOneArg);\n+    normalizers.put(\"ZREVRANK\", keepOneArg);\n+    normalizers.put(\"ZSCORE\", keepOneArg);\n+\n+    // Streams\n+    normalizers.put(\"XADD\", new MultiKeyValue(2));\n+\n+    // Strings\n+    normalizers.put(\"APPEND\", keepOneArg);\n+    normalizers.put(\"GETSET\", keepOneArg);\n+    normalizers.put(\"MSET\", setMultiField);\n+    normalizers.put(\"MSETNX\", setMultiField);\n+    normalizers.put(\"PSETEX\", keepTwoArgs);\n+    normalizers.put(\"SET\", keepOneArg);\n+    normalizers.put(\"SETEX\", keepTwoArgs);\n+    normalizers.put(\"SETNX\", keepOneArg);\n+    normalizers.put(\"SETRANGE\", keepOneArg);\n+\n+    NORMALIZERS = unmodifiableMap(normalizers);\n+  }\n+\n+  public static String normalize(String command, List<String> args) {\n+    return NORMALIZERS\n+        .getOrDefault(command.toUpperCase(), Default.INSTANCE)", "originalCommit": "d0f943b7d163f3e7dd981f282bc41f56269d0b7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzczMzUwNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1405#discussion_r507733505", "bodyText": "That's a very good idea - done.", "author": "mateuszrzeszutek", "createdAt": "2020-10-19T13:12:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjczOTA2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc0MTE0Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1405#discussion_r506741143", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      normalised.append(\" \").append(\"?\");\n          \n          \n            \n                      normalised.append(\" ?\");", "author": "trask", "createdAt": "2020-10-16T22:05:40Z", "path": "instrumentation/lettuce/lettuce-5.1/src/main/java/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/RedisCommandNormalizer.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.lettuce.v5_1;\n+\n+import static java.util.Collections.unmodifiableMap;\n+\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.CommandAndNumArgs;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.Default;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.Eval;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.MultiKeyValue;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/** This class is responsible for masking potentially sensitive data in Redis commands. */\n+public final class RedisCommandNormalizer {\n+\n+  private static final Map<String, CommandNormalizer> NORMALIZERS;\n+\n+  static {\n+    Map<String, CommandNormalizer> normalizers = new HashMap<>();\n+\n+    CommandNormalizer keepOneArg = new CommandAndNumArgs(1);\n+    CommandNormalizer keepTwoArgs = new CommandAndNumArgs(2);\n+    CommandNormalizer setMultiHashField = new MultiKeyValue(1);\n+    CommandNormalizer setMultiField = new MultiKeyValue(0);\n+\n+    // Connection\n+    // can contain AUTH data\n+    normalizers.put(\"AUTH\", new CommandAndNumArgs(0));\n+    normalizers.put(\"HELLO\", keepTwoArgs);\n+\n+    // Hashes\n+    normalizers.put(\"HMSET\", setMultiHashField);\n+    normalizers.put(\"HSET\", setMultiHashField);\n+    normalizers.put(\"HSETNX\", keepTwoArgs);\n+\n+    // HyperLogLog\n+    normalizers.put(\"PFADD\", keepOneArg);\n+\n+    // Keys\n+    // can contain AUTH data\n+    normalizers.put(\"MIGRATE\", new CommandAndNumArgs(6));\n+\n+    // Lists\n+    normalizers.put(\"LINSERT\", keepTwoArgs);\n+    normalizers.put(\"LPOS\", keepOneArg);\n+    normalizers.put(\"LPUSH\", keepOneArg);\n+    normalizers.put(\"LPUSHX\", keepOneArg);\n+    normalizers.put(\"LREM\", keepOneArg);\n+    normalizers.put(\"LSET\", keepOneArg);\n+    normalizers.put(\"RPUSH\", keepOneArg);\n+    normalizers.put(\"RPUSHX\", keepOneArg);\n+\n+    // Pub/Sub\n+    normalizers.put(\"PUBLISH\", keepOneArg);\n+\n+    // Scripting\n+    normalizers.put(\"EVAL\", Eval.INSTANCE);\n+    normalizers.put(\"EVALSHA\", Eval.INSTANCE);\n+\n+    // Sets\n+    normalizers.put(\"SADD\", keepOneArg);\n+    normalizers.put(\"SISMEMBER\", keepOneArg);\n+    normalizers.put(\"SMISMEMBER\", keepOneArg);\n+    normalizers.put(\"SMOVE\", keepTwoArgs);\n+    normalizers.put(\"SREM\", keepOneArg);\n+\n+    // Sorted Sets\n+    normalizers.put(\"ZADD\", keepOneArg);\n+    normalizers.put(\"ZCOUNT\", keepOneArg);\n+    normalizers.put(\"ZINCRBY\", keepOneArg);\n+    normalizers.put(\"ZLEXCOUNT\", keepOneArg);\n+    normalizers.put(\"ZMSCORE\", keepOneArg);\n+    normalizers.put(\"ZRANGEBYLEX\", keepOneArg);\n+    normalizers.put(\"ZRANGEBYSCORE\", keepOneArg);\n+    normalizers.put(\"ZRANK\", keepOneArg);\n+    normalizers.put(\"ZREM\", keepOneArg);\n+    normalizers.put(\"ZREMRANGEBYLEX\", keepOneArg);\n+    normalizers.put(\"ZREMRANGEBYSCORE\", keepOneArg);\n+    normalizers.put(\"ZREVRANGEBYLEX\", keepOneArg);\n+    normalizers.put(\"ZREVRANGEBYSCORE\", keepOneArg);\n+    normalizers.put(\"ZREVRANK\", keepOneArg);\n+    normalizers.put(\"ZSCORE\", keepOneArg);\n+\n+    // Streams\n+    normalizers.put(\"XADD\", new MultiKeyValue(2));\n+\n+    // Strings\n+    normalizers.put(\"APPEND\", keepOneArg);\n+    normalizers.put(\"GETSET\", keepOneArg);\n+    normalizers.put(\"MSET\", setMultiField);\n+    normalizers.put(\"MSETNX\", setMultiField);\n+    normalizers.put(\"PSETEX\", keepTwoArgs);\n+    normalizers.put(\"SET\", keepOneArg);\n+    normalizers.put(\"SETEX\", keepTwoArgs);\n+    normalizers.put(\"SETNX\", keepOneArg);\n+    normalizers.put(\"SETRANGE\", keepOneArg);\n+\n+    NORMALIZERS = unmodifiableMap(normalizers);\n+  }\n+\n+  public static String normalize(String command, List<String> args) {\n+    return NORMALIZERS\n+        .getOrDefault(command.toUpperCase(), Default.INSTANCE)\n+        .normalize(command, args);\n+  }\n+\n+  public interface CommandNormalizer {\n+    String normalize(String command, List<String> args);\n+\n+    enum Default implements CommandNormalizer {\n+      INSTANCE;\n+\n+      @Override\n+      public String normalize(String command, List<String> args) {\n+        StringBuilder normalised = new StringBuilder(command);\n+        for (String arg : args) {\n+          normalised.append(\" \").append(arg);\n+        }\n+        return normalised.toString();\n+      }\n+    }\n+\n+    class CommandAndNumArgs implements CommandNormalizer {\n+      private final int numOfArgsToKeep;\n+\n+      public CommandAndNumArgs(int numOfArgsToKeep) {\n+        this.numOfArgsToKeep = numOfArgsToKeep;\n+      }\n+\n+      @Override\n+      public String normalize(String command, List<String> args) {\n+        StringBuilder normalised = new StringBuilder(command);\n+        int i = 0;\n+        for (; i < numOfArgsToKeep && i < args.size(); ++i) {\n+          normalised.append(\" \").append(args.get(i));\n+        }\n+        for (; i < args.size(); ++i) {\n+          normalised.append(\" \").append(\"?\");", "originalCommit": "d0f943b7d163f3e7dd981f282bc41f56269d0b7d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc0MTMzNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1405#discussion_r506741335", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      normalised.append(\" \").append(\"?\");\n          \n          \n            \n                      normalised.append(\" ?\");", "author": "trask", "createdAt": "2020-10-16T22:06:20Z", "path": "instrumentation/lettuce/lettuce-5.1/src/main/java/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/RedisCommandNormalizer.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.lettuce.v5_1;\n+\n+import static java.util.Collections.unmodifiableMap;\n+\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.CommandAndNumArgs;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.Default;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.Eval;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.MultiKeyValue;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/** This class is responsible for masking potentially sensitive data in Redis commands. */\n+public final class RedisCommandNormalizer {\n+\n+  private static final Map<String, CommandNormalizer> NORMALIZERS;\n+\n+  static {\n+    Map<String, CommandNormalizer> normalizers = new HashMap<>();\n+\n+    CommandNormalizer keepOneArg = new CommandAndNumArgs(1);\n+    CommandNormalizer keepTwoArgs = new CommandAndNumArgs(2);\n+    CommandNormalizer setMultiHashField = new MultiKeyValue(1);\n+    CommandNormalizer setMultiField = new MultiKeyValue(0);\n+\n+    // Connection\n+    // can contain AUTH data\n+    normalizers.put(\"AUTH\", new CommandAndNumArgs(0));\n+    normalizers.put(\"HELLO\", keepTwoArgs);\n+\n+    // Hashes\n+    normalizers.put(\"HMSET\", setMultiHashField);\n+    normalizers.put(\"HSET\", setMultiHashField);\n+    normalizers.put(\"HSETNX\", keepTwoArgs);\n+\n+    // HyperLogLog\n+    normalizers.put(\"PFADD\", keepOneArg);\n+\n+    // Keys\n+    // can contain AUTH data\n+    normalizers.put(\"MIGRATE\", new CommandAndNumArgs(6));\n+\n+    // Lists\n+    normalizers.put(\"LINSERT\", keepTwoArgs);\n+    normalizers.put(\"LPOS\", keepOneArg);\n+    normalizers.put(\"LPUSH\", keepOneArg);\n+    normalizers.put(\"LPUSHX\", keepOneArg);\n+    normalizers.put(\"LREM\", keepOneArg);\n+    normalizers.put(\"LSET\", keepOneArg);\n+    normalizers.put(\"RPUSH\", keepOneArg);\n+    normalizers.put(\"RPUSHX\", keepOneArg);\n+\n+    // Pub/Sub\n+    normalizers.put(\"PUBLISH\", keepOneArg);\n+\n+    // Scripting\n+    normalizers.put(\"EVAL\", Eval.INSTANCE);\n+    normalizers.put(\"EVALSHA\", Eval.INSTANCE);\n+\n+    // Sets\n+    normalizers.put(\"SADD\", keepOneArg);\n+    normalizers.put(\"SISMEMBER\", keepOneArg);\n+    normalizers.put(\"SMISMEMBER\", keepOneArg);\n+    normalizers.put(\"SMOVE\", keepTwoArgs);\n+    normalizers.put(\"SREM\", keepOneArg);\n+\n+    // Sorted Sets\n+    normalizers.put(\"ZADD\", keepOneArg);\n+    normalizers.put(\"ZCOUNT\", keepOneArg);\n+    normalizers.put(\"ZINCRBY\", keepOneArg);\n+    normalizers.put(\"ZLEXCOUNT\", keepOneArg);\n+    normalizers.put(\"ZMSCORE\", keepOneArg);\n+    normalizers.put(\"ZRANGEBYLEX\", keepOneArg);\n+    normalizers.put(\"ZRANGEBYSCORE\", keepOneArg);\n+    normalizers.put(\"ZRANK\", keepOneArg);\n+    normalizers.put(\"ZREM\", keepOneArg);\n+    normalizers.put(\"ZREMRANGEBYLEX\", keepOneArg);\n+    normalizers.put(\"ZREMRANGEBYSCORE\", keepOneArg);\n+    normalizers.put(\"ZREVRANGEBYLEX\", keepOneArg);\n+    normalizers.put(\"ZREVRANGEBYSCORE\", keepOneArg);\n+    normalizers.put(\"ZREVRANK\", keepOneArg);\n+    normalizers.put(\"ZSCORE\", keepOneArg);\n+\n+    // Streams\n+    normalizers.put(\"XADD\", new MultiKeyValue(2));\n+\n+    // Strings\n+    normalizers.put(\"APPEND\", keepOneArg);\n+    normalizers.put(\"GETSET\", keepOneArg);\n+    normalizers.put(\"MSET\", setMultiField);\n+    normalizers.put(\"MSETNX\", setMultiField);\n+    normalizers.put(\"PSETEX\", keepTwoArgs);\n+    normalizers.put(\"SET\", keepOneArg);\n+    normalizers.put(\"SETEX\", keepTwoArgs);\n+    normalizers.put(\"SETNX\", keepOneArg);\n+    normalizers.put(\"SETRANGE\", keepOneArg);\n+\n+    NORMALIZERS = unmodifiableMap(normalizers);\n+  }\n+\n+  public static String normalize(String command, List<String> args) {\n+    return NORMALIZERS\n+        .getOrDefault(command.toUpperCase(), Default.INSTANCE)\n+        .normalize(command, args);\n+  }\n+\n+  public interface CommandNormalizer {\n+    String normalize(String command, List<String> args);\n+\n+    enum Default implements CommandNormalizer {\n+      INSTANCE;\n+\n+      @Override\n+      public String normalize(String command, List<String> args) {\n+        StringBuilder normalised = new StringBuilder(command);\n+        for (String arg : args) {\n+          normalised.append(\" \").append(arg);\n+        }\n+        return normalised.toString();\n+      }\n+    }\n+\n+    class CommandAndNumArgs implements CommandNormalizer {\n+      private final int numOfArgsToKeep;\n+\n+      public CommandAndNumArgs(int numOfArgsToKeep) {\n+        this.numOfArgsToKeep = numOfArgsToKeep;\n+      }\n+\n+      @Override\n+      public String normalize(String command, List<String> args) {\n+        StringBuilder normalised = new StringBuilder(command);\n+        int i = 0;\n+        for (; i < numOfArgsToKeep && i < args.size(); ++i) {\n+          normalised.append(\" \").append(args.get(i));\n+        }\n+        for (; i < args.size(); ++i) {\n+          normalised.append(\" \").append(\"?\");\n+        }\n+        return normalised.toString();\n+      }\n+    }\n+\n+    class MultiKeyValue implements CommandNormalizer {\n+      private final int numOfArgsBeforeKeyValue;\n+\n+      public MultiKeyValue(int numOfArgsBeforeKeyValue) {\n+        this.numOfArgsBeforeKeyValue = numOfArgsBeforeKeyValue;\n+      }\n+\n+      @Override\n+      public String normalize(String command, List<String> args) {\n+        StringBuilder normalised = new StringBuilder(command);\n+        int i = 0;\n+        // append all \"initial\" arguments before key-value pairs start\n+        for (; i < numOfArgsBeforeKeyValue && i < args.size(); ++i) {\n+          normalised.append(\" \").append(args.get(i));\n+        }\n+\n+        // whether keys are on even or odd index depends on the number of initial args\n+        int keys = numOfArgsBeforeKeyValue % 2;\n+        for (; i < args.size(); ++i) {\n+          normalised\n+              .append(\" \")\n+              // append only keys, skip values\n+              .append(i % 2 == keys ? args.get(i) : \"?\");\n+        }\n+        return normalised.toString();\n+      }\n+    }\n+\n+    enum Eval implements CommandNormalizer {\n+      INSTANCE;\n+\n+      @Override\n+      public String normalize(String command, List<String> args) {\n+        StringBuilder normalised = new StringBuilder(command);\n+\n+        // get the number of keys passed from the command itself (second arg)\n+        int numberOfKeys = 0;\n+        if (args.size() > 2) {\n+          try {\n+            numberOfKeys = Integer.parseInt(args.get(1));\n+          } catch (NumberFormatException ignored) {\n+          }\n+        }\n+\n+        int i = 0;\n+        // log the script, number of keys and all keys\n+        for (; i < (numberOfKeys + 2) && i < args.size(); ++i) {\n+          normalised.append(\" \").append(args.get(i));\n+        }\n+        // mask the rest\n+        for (; i < args.size(); ++i) {\n+          normalised.append(\" \").append(\"?\");", "originalCommit": "d0f943b7d163f3e7dd981f282bc41f56269d0b7d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc0MzUxOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1405#discussion_r506743519", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  int end = 0;\n          \n          \n            \n                  int lastEnd = 0;", "author": "trask", "createdAt": "2020-10-16T22:13:57Z", "path": "instrumentation/lettuce/lettuce-5.1/src/main/java/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/OpenTelemetryTracing.java", "diffHunk": "@@ -249,50 +252,44 @@ public OpenTelemetrySpan nextSpan(TraceContext traceContext) {\n     public synchronized void finish() {\n       if (span != null) {\n         if (name != null) {\n-          String statement =\n-              (args != null && !args.isEmpty()) && !name.equals(\"AUTH\") ? name + \" \" + args : name;\n+          String statement = RedisCommandNormalizer.normalize(name, splitArgs());\n           span.setAttribute(SemanticAttributes.DB_STATEMENT, statement);\n         }\n         span.end();\n       }\n     }\n \n-    private static void fillEndpoint(Span.Builder span, OpenTelemetryEndpoint endpoint) {\n-      span.setAttribute(SemanticAttributes.NET_TRANSPORT, \"IP.TCP\");\n-      span.setAttribute(SemanticAttributes.NET_PEER_IP, endpoint.ip);\n-\n-      StringBuilder redisUrl = new StringBuilder(\"redis://\");\n+    private static final Pattern KEY_PATTERN = Pattern.compile(\"(?<wrappedKey>key<(?<key>[^>]+)>)\");\n \n-      if (endpoint.name != null) {\n-        span.setAttribute(SemanticAttributes.NET_PEER_NAME, endpoint.name);\n-        redisUrl.append(endpoint.name);\n-      } else {\n-        redisUrl.append(endpoint.ip);\n+    // this method removes the key<...> wrapper around redis keys and splits the args string\n+    private List<String> splitArgs() {\n+      if (args == null || args.isEmpty()) {\n+        return Collections.emptyList();\n       }\n \n-      if (endpoint.port != 0) {\n-        span.setAttribute(SemanticAttributes.NET_PEER_PORT, (long) endpoint.port);\n-        redisUrl.append(\":\").append(endpoint.port);\n+      StringBuilder newArgs = new StringBuilder(args.length());\n+\n+      Matcher m = KEY_PATTERN.matcher(args);\n+      int end = 0;", "originalCommit": "d0f943b7d163f3e7dd981f282bc41f56269d0b7d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc0NDU4NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1405#discussion_r506744585", "bodyText": "I'm not sure the wrappedKey named grouping helps readability here\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    int wrapperStart = m.start(\"wrappedKey\");\n          \n          \n            \n            \n          \n          \n            \n                    newArgs.append(args, end, wrapperStart).append(m.group(\"key\"));\n          \n          \n            \n            \n          \n          \n            \n                    end = m.end(\"wrappedKey\");\n          \n          \n            \n                    int start = m.start();\n          \n          \n            \n            \n          \n          \n            \n                    newArgs.append(args, lastEnd, start).append(m.group(\"key\"));\n          \n          \n            \n            \n          \n          \n            \n                    lastEnd = m.end();", "author": "trask", "createdAt": "2020-10-16T22:17:32Z", "path": "instrumentation/lettuce/lettuce-5.1/src/main/java/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/OpenTelemetryTracing.java", "diffHunk": "@@ -249,50 +252,44 @@ public OpenTelemetrySpan nextSpan(TraceContext traceContext) {\n     public synchronized void finish() {\n       if (span != null) {\n         if (name != null) {\n-          String statement =\n-              (args != null && !args.isEmpty()) && !name.equals(\"AUTH\") ? name + \" \" + args : name;\n+          String statement = RedisCommandNormalizer.normalize(name, splitArgs());\n           span.setAttribute(SemanticAttributes.DB_STATEMENT, statement);\n         }\n         span.end();\n       }\n     }\n \n-    private static void fillEndpoint(Span.Builder span, OpenTelemetryEndpoint endpoint) {\n-      span.setAttribute(SemanticAttributes.NET_TRANSPORT, \"IP.TCP\");\n-      span.setAttribute(SemanticAttributes.NET_PEER_IP, endpoint.ip);\n-\n-      StringBuilder redisUrl = new StringBuilder(\"redis://\");\n+    private static final Pattern KEY_PATTERN = Pattern.compile(\"(?<wrappedKey>key<(?<key>[^>]+)>)\");\n \n-      if (endpoint.name != null) {\n-        span.setAttribute(SemanticAttributes.NET_PEER_NAME, endpoint.name);\n-        redisUrl.append(endpoint.name);\n-      } else {\n-        redisUrl.append(endpoint.ip);\n+    // this method removes the key<...> wrapper around redis keys and splits the args string\n+    private List<String> splitArgs() {\n+      if (args == null || args.isEmpty()) {\n+        return Collections.emptyList();\n       }\n \n-      if (endpoint.port != 0) {\n-        span.setAttribute(SemanticAttributes.NET_PEER_PORT, (long) endpoint.port);\n-        redisUrl.append(\":\").append(endpoint.port);\n+      StringBuilder newArgs = new StringBuilder(args.length());\n+\n+      Matcher m = KEY_PATTERN.matcher(args);\n+      int end = 0;\n+      while (m.find()) {\n+        int wrapperStart = m.start(\"wrappedKey\");\n+\n+        newArgs.append(args, end, wrapperStart).append(m.group(\"key\"));\n+\n+        end = m.end(\"wrappedKey\");", "originalCommit": "d0f943b7d163f3e7dd981f282bc41f56269d0b7d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc0NzQxMA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1405#discussion_r506747410", "bodyText": "instead of appending and then splitting, does it help if we build the list directly as we iterate above?", "author": "trask", "createdAt": "2020-10-16T22:27:41Z", "path": "instrumentation/lettuce/lettuce-5.1/src/main/java/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/OpenTelemetryTracing.java", "diffHunk": "@@ -249,50 +252,44 @@ public OpenTelemetrySpan nextSpan(TraceContext traceContext) {\n     public synchronized void finish() {\n       if (span != null) {\n         if (name != null) {\n-          String statement =\n-              (args != null && !args.isEmpty()) && !name.equals(\"AUTH\") ? name + \" \" + args : name;\n+          String statement = RedisCommandNormalizer.normalize(name, splitArgs());\n           span.setAttribute(SemanticAttributes.DB_STATEMENT, statement);\n         }\n         span.end();\n       }\n     }\n \n-    private static void fillEndpoint(Span.Builder span, OpenTelemetryEndpoint endpoint) {\n-      span.setAttribute(SemanticAttributes.NET_TRANSPORT, \"IP.TCP\");\n-      span.setAttribute(SemanticAttributes.NET_PEER_IP, endpoint.ip);\n-\n-      StringBuilder redisUrl = new StringBuilder(\"redis://\");\n+    private static final Pattern KEY_PATTERN = Pattern.compile(\"(?<wrappedKey>key<(?<key>[^>]+)>)\");\n \n-      if (endpoint.name != null) {\n-        span.setAttribute(SemanticAttributes.NET_PEER_NAME, endpoint.name);\n-        redisUrl.append(endpoint.name);\n-      } else {\n-        redisUrl.append(endpoint.ip);\n+    // this method removes the key<...> wrapper around redis keys and splits the args string\n+    private List<String> splitArgs() {\n+      if (args == null || args.isEmpty()) {\n+        return Collections.emptyList();\n       }\n \n-      if (endpoint.port != 0) {\n-        span.setAttribute(SemanticAttributes.NET_PEER_PORT, (long) endpoint.port);\n-        redisUrl.append(\":\").append(endpoint.port);\n+      StringBuilder newArgs = new StringBuilder(args.length());\n+\n+      Matcher m = KEY_PATTERN.matcher(args);\n+      int end = 0;\n+      while (m.find()) {\n+        int wrapperStart = m.start(\"wrappedKey\");\n+\n+        newArgs.append(args, end, wrapperStart).append(m.group(\"key\"));\n+\n+        end = m.end(\"wrappedKey\");\n       }\n+      newArgs.append(args, end, args.length());\n \n-      span.setAttribute(SemanticAttributes.DB_CONNECTION_STRING, redisUrl.toString());\n+      return asList(newArgs.toString().split(\" \"));", "originalCommit": "d0f943b7d163f3e7dd981f282bc41f56269d0b7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzYzNDQ5MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1405#discussion_r507634491", "bodyText": "Hmm, that'll be a bit more complicated but certainly doable.", "author": "mateuszrzeszutek", "createdAt": "2020-10-19T10:19:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc0NzQxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc0NzY5NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1405#discussion_r506747695", "bodyText": "\ud83d\udc4d", "author": "trask", "createdAt": "2020-10-16T22:28:54Z", "path": "instrumentation-api/src/main/java/io/opentelemetry/instrumentation/api/tracer/utils/NetPeerUtils.java", "diffHunk": "@@ -81,4 +88,12 @@ private static String mapToPeer(String endpoint) {\n \n     return ENDPOINT_PEER_SERVICE_MAPPING.get(endpoint);\n   }\n+\n+  /**\n+   * This helper interface allows setting attributes on both {@link Span} and {@link Span.Builder}.", "originalCommit": "d0f943b7d163f3e7dd981f282bc41f56269d0b7d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc0OTA1OA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1405#discussion_r506749058", "bodyText": "took me a while to understand the parity matching, I think something like this would be easier to read\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // whether keys are on even or odd index depends on the number of initial args\n          \n          \n            \n                    int keys = numOfArgsBeforeKeyValue % 2;\n          \n          \n            \n                    for (; i < args.size(); ++i) {\n          \n          \n            \n                      normalised\n          \n          \n            \n                          .append(\" \")\n          \n          \n            \n                          // append only keys, skip values\n          \n          \n            \n                          .append(i % 2 == keys ? args.get(i) : \"?\");\n          \n          \n            \n                    }\n          \n          \n            \n                    // loop over keys only\n          \n          \n            \n                    for (i = numOfArgsBeforeKeyValue; i < args.size(); i += 2) {\n          \n          \n            \n                      normalised\n          \n          \n            \n                          .append(\" \")\n          \n          \n            \n                          .append(args.get(i))\n          \n          \n            \n                          .append(\" ?\");\n          \n          \n            \n                    }", "author": "trask", "createdAt": "2020-10-16T22:34:07Z", "path": "instrumentation/lettuce/lettuce-5.1/src/main/java/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/RedisCommandNormalizer.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.lettuce.v5_1;\n+\n+import static java.util.Collections.unmodifiableMap;\n+\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.CommandAndNumArgs;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.Default;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.Eval;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.MultiKeyValue;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/** This class is responsible for masking potentially sensitive data in Redis commands. */\n+public final class RedisCommandNormalizer {\n+\n+  private static final Map<String, CommandNormalizer> NORMALIZERS;\n+\n+  static {\n+    Map<String, CommandNormalizer> normalizers = new HashMap<>();\n+\n+    CommandNormalizer keepOneArg = new CommandAndNumArgs(1);\n+    CommandNormalizer keepTwoArgs = new CommandAndNumArgs(2);\n+    CommandNormalizer setMultiHashField = new MultiKeyValue(1);\n+    CommandNormalizer setMultiField = new MultiKeyValue(0);\n+\n+    // Connection\n+    // can contain AUTH data\n+    normalizers.put(\"AUTH\", new CommandAndNumArgs(0));\n+    normalizers.put(\"HELLO\", keepTwoArgs);\n+\n+    // Hashes\n+    normalizers.put(\"HMSET\", setMultiHashField);\n+    normalizers.put(\"HSET\", setMultiHashField);\n+    normalizers.put(\"HSETNX\", keepTwoArgs);\n+\n+    // HyperLogLog\n+    normalizers.put(\"PFADD\", keepOneArg);\n+\n+    // Keys\n+    // can contain AUTH data\n+    normalizers.put(\"MIGRATE\", new CommandAndNumArgs(6));\n+\n+    // Lists\n+    normalizers.put(\"LINSERT\", keepTwoArgs);\n+    normalizers.put(\"LPOS\", keepOneArg);\n+    normalizers.put(\"LPUSH\", keepOneArg);\n+    normalizers.put(\"LPUSHX\", keepOneArg);\n+    normalizers.put(\"LREM\", keepOneArg);\n+    normalizers.put(\"LSET\", keepOneArg);\n+    normalizers.put(\"RPUSH\", keepOneArg);\n+    normalizers.put(\"RPUSHX\", keepOneArg);\n+\n+    // Pub/Sub\n+    normalizers.put(\"PUBLISH\", keepOneArg);\n+\n+    // Scripting\n+    normalizers.put(\"EVAL\", Eval.INSTANCE);\n+    normalizers.put(\"EVALSHA\", Eval.INSTANCE);\n+\n+    // Sets\n+    normalizers.put(\"SADD\", keepOneArg);\n+    normalizers.put(\"SISMEMBER\", keepOneArg);\n+    normalizers.put(\"SMISMEMBER\", keepOneArg);\n+    normalizers.put(\"SMOVE\", keepTwoArgs);\n+    normalizers.put(\"SREM\", keepOneArg);\n+\n+    // Sorted Sets\n+    normalizers.put(\"ZADD\", keepOneArg);\n+    normalizers.put(\"ZCOUNT\", keepOneArg);\n+    normalizers.put(\"ZINCRBY\", keepOneArg);\n+    normalizers.put(\"ZLEXCOUNT\", keepOneArg);\n+    normalizers.put(\"ZMSCORE\", keepOneArg);\n+    normalizers.put(\"ZRANGEBYLEX\", keepOneArg);\n+    normalizers.put(\"ZRANGEBYSCORE\", keepOneArg);\n+    normalizers.put(\"ZRANK\", keepOneArg);\n+    normalizers.put(\"ZREM\", keepOneArg);\n+    normalizers.put(\"ZREMRANGEBYLEX\", keepOneArg);\n+    normalizers.put(\"ZREMRANGEBYSCORE\", keepOneArg);\n+    normalizers.put(\"ZREVRANGEBYLEX\", keepOneArg);\n+    normalizers.put(\"ZREVRANGEBYSCORE\", keepOneArg);\n+    normalizers.put(\"ZREVRANK\", keepOneArg);\n+    normalizers.put(\"ZSCORE\", keepOneArg);\n+\n+    // Streams\n+    normalizers.put(\"XADD\", new MultiKeyValue(2));\n+\n+    // Strings\n+    normalizers.put(\"APPEND\", keepOneArg);\n+    normalizers.put(\"GETSET\", keepOneArg);\n+    normalizers.put(\"MSET\", setMultiField);\n+    normalizers.put(\"MSETNX\", setMultiField);\n+    normalizers.put(\"PSETEX\", keepTwoArgs);\n+    normalizers.put(\"SET\", keepOneArg);\n+    normalizers.put(\"SETEX\", keepTwoArgs);\n+    normalizers.put(\"SETNX\", keepOneArg);\n+    normalizers.put(\"SETRANGE\", keepOneArg);\n+\n+    NORMALIZERS = unmodifiableMap(normalizers);\n+  }\n+\n+  public static String normalize(String command, List<String> args) {\n+    return NORMALIZERS\n+        .getOrDefault(command.toUpperCase(), Default.INSTANCE)\n+        .normalize(command, args);\n+  }\n+\n+  public interface CommandNormalizer {\n+    String normalize(String command, List<String> args);\n+\n+    enum Default implements CommandNormalizer {\n+      INSTANCE;\n+\n+      @Override\n+      public String normalize(String command, List<String> args) {\n+        StringBuilder normalised = new StringBuilder(command);\n+        for (String arg : args) {\n+          normalised.append(\" \").append(arg);\n+        }\n+        return normalised.toString();\n+      }\n+    }\n+\n+    class CommandAndNumArgs implements CommandNormalizer {\n+      private final int numOfArgsToKeep;\n+\n+      public CommandAndNumArgs(int numOfArgsToKeep) {\n+        this.numOfArgsToKeep = numOfArgsToKeep;\n+      }\n+\n+      @Override\n+      public String normalize(String command, List<String> args) {\n+        StringBuilder normalised = new StringBuilder(command);\n+        int i = 0;\n+        for (; i < numOfArgsToKeep && i < args.size(); ++i) {\n+          normalised.append(\" \").append(args.get(i));\n+        }\n+        for (; i < args.size(); ++i) {\n+          normalised.append(\" \").append(\"?\");\n+        }\n+        return normalised.toString();\n+      }\n+    }\n+\n+    class MultiKeyValue implements CommandNormalizer {\n+      private final int numOfArgsBeforeKeyValue;\n+\n+      public MultiKeyValue(int numOfArgsBeforeKeyValue) {\n+        this.numOfArgsBeforeKeyValue = numOfArgsBeforeKeyValue;\n+      }\n+\n+      @Override\n+      public String normalize(String command, List<String> args) {\n+        StringBuilder normalised = new StringBuilder(command);\n+        int i = 0;\n+        // append all \"initial\" arguments before key-value pairs start\n+        for (; i < numOfArgsBeforeKeyValue && i < args.size(); ++i) {\n+          normalised.append(\" \").append(args.get(i));\n+        }\n+\n+        // whether keys are on even or odd index depends on the number of initial args\n+        int keys = numOfArgsBeforeKeyValue % 2;\n+        for (; i < args.size(); ++i) {\n+          normalised\n+              .append(\" \")\n+              // append only keys, skip values\n+              .append(i % 2 == keys ? args.get(i) : \"?\");\n+        }", "originalCommit": "d0f943b7d163f3e7dd981f282bc41f56269d0b7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzYyNjI0NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1405#discussion_r507626245", "bodyText": "That's much better!", "author": "mateuszrzeszutek", "createdAt": "2020-10-19T10:05:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc0OTA1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc1MDA4NA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1405#discussion_r506750084", "bodyText": "I think this is easier to read, but curious other thoughts, I also see attractiveness of current approach which increments a single counter to show that everything is hit\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    int i = 0;\n          \n          \n            \n                    for (; i < numOfArgsToKeep && i < args.size(); ++i) {\n          \n          \n            \n                      normalised.append(\" \").append(args.get(i));\n          \n          \n            \n                    }\n          \n          \n            \n                    for (; i < args.size(); ++i) {\n          \n          \n            \n                    for (int i = 0; i < numOfArgsToKeep && i < args.size(); ++i) {\n          \n          \n            \n                      normalised.append(\" \").append(args.get(i));\n          \n          \n            \n                    }\n          \n          \n            \n                    for (int i = numOfArgsToKeep; i < args.size(); ++i) {", "author": "trask", "createdAt": "2020-10-16T22:38:15Z", "path": "instrumentation/lettuce/lettuce-5.1/src/main/java/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/RedisCommandNormalizer.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.lettuce.v5_1;\n+\n+import static java.util.Collections.unmodifiableMap;\n+\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.CommandAndNumArgs;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.Default;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.Eval;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.MultiKeyValue;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/** This class is responsible for masking potentially sensitive data in Redis commands. */\n+public final class RedisCommandNormalizer {\n+\n+  private static final Map<String, CommandNormalizer> NORMALIZERS;\n+\n+  static {\n+    Map<String, CommandNormalizer> normalizers = new HashMap<>();\n+\n+    CommandNormalizer keepOneArg = new CommandAndNumArgs(1);\n+    CommandNormalizer keepTwoArgs = new CommandAndNumArgs(2);\n+    CommandNormalizer setMultiHashField = new MultiKeyValue(1);\n+    CommandNormalizer setMultiField = new MultiKeyValue(0);\n+\n+    // Connection\n+    // can contain AUTH data\n+    normalizers.put(\"AUTH\", new CommandAndNumArgs(0));\n+    normalizers.put(\"HELLO\", keepTwoArgs);\n+\n+    // Hashes\n+    normalizers.put(\"HMSET\", setMultiHashField);\n+    normalizers.put(\"HSET\", setMultiHashField);\n+    normalizers.put(\"HSETNX\", keepTwoArgs);\n+\n+    // HyperLogLog\n+    normalizers.put(\"PFADD\", keepOneArg);\n+\n+    // Keys\n+    // can contain AUTH data\n+    normalizers.put(\"MIGRATE\", new CommandAndNumArgs(6));\n+\n+    // Lists\n+    normalizers.put(\"LINSERT\", keepTwoArgs);\n+    normalizers.put(\"LPOS\", keepOneArg);\n+    normalizers.put(\"LPUSH\", keepOneArg);\n+    normalizers.put(\"LPUSHX\", keepOneArg);\n+    normalizers.put(\"LREM\", keepOneArg);\n+    normalizers.put(\"LSET\", keepOneArg);\n+    normalizers.put(\"RPUSH\", keepOneArg);\n+    normalizers.put(\"RPUSHX\", keepOneArg);\n+\n+    // Pub/Sub\n+    normalizers.put(\"PUBLISH\", keepOneArg);\n+\n+    // Scripting\n+    normalizers.put(\"EVAL\", Eval.INSTANCE);\n+    normalizers.put(\"EVALSHA\", Eval.INSTANCE);\n+\n+    // Sets\n+    normalizers.put(\"SADD\", keepOneArg);\n+    normalizers.put(\"SISMEMBER\", keepOneArg);\n+    normalizers.put(\"SMISMEMBER\", keepOneArg);\n+    normalizers.put(\"SMOVE\", keepTwoArgs);\n+    normalizers.put(\"SREM\", keepOneArg);\n+\n+    // Sorted Sets\n+    normalizers.put(\"ZADD\", keepOneArg);\n+    normalizers.put(\"ZCOUNT\", keepOneArg);\n+    normalizers.put(\"ZINCRBY\", keepOneArg);\n+    normalizers.put(\"ZLEXCOUNT\", keepOneArg);\n+    normalizers.put(\"ZMSCORE\", keepOneArg);\n+    normalizers.put(\"ZRANGEBYLEX\", keepOneArg);\n+    normalizers.put(\"ZRANGEBYSCORE\", keepOneArg);\n+    normalizers.put(\"ZRANK\", keepOneArg);\n+    normalizers.put(\"ZREM\", keepOneArg);\n+    normalizers.put(\"ZREMRANGEBYLEX\", keepOneArg);\n+    normalizers.put(\"ZREMRANGEBYSCORE\", keepOneArg);\n+    normalizers.put(\"ZREVRANGEBYLEX\", keepOneArg);\n+    normalizers.put(\"ZREVRANGEBYSCORE\", keepOneArg);\n+    normalizers.put(\"ZREVRANK\", keepOneArg);\n+    normalizers.put(\"ZSCORE\", keepOneArg);\n+\n+    // Streams\n+    normalizers.put(\"XADD\", new MultiKeyValue(2));\n+\n+    // Strings\n+    normalizers.put(\"APPEND\", keepOneArg);\n+    normalizers.put(\"GETSET\", keepOneArg);\n+    normalizers.put(\"MSET\", setMultiField);\n+    normalizers.put(\"MSETNX\", setMultiField);\n+    normalizers.put(\"PSETEX\", keepTwoArgs);\n+    normalizers.put(\"SET\", keepOneArg);\n+    normalizers.put(\"SETEX\", keepTwoArgs);\n+    normalizers.put(\"SETNX\", keepOneArg);\n+    normalizers.put(\"SETRANGE\", keepOneArg);\n+\n+    NORMALIZERS = unmodifiableMap(normalizers);\n+  }\n+\n+  public static String normalize(String command, List<String> args) {\n+    return NORMALIZERS\n+        .getOrDefault(command.toUpperCase(), Default.INSTANCE)\n+        .normalize(command, args);\n+  }\n+\n+  public interface CommandNormalizer {\n+    String normalize(String command, List<String> args);\n+\n+    enum Default implements CommandNormalizer {\n+      INSTANCE;\n+\n+      @Override\n+      public String normalize(String command, List<String> args) {\n+        StringBuilder normalised = new StringBuilder(command);\n+        for (String arg : args) {\n+          normalised.append(\" \").append(arg);\n+        }\n+        return normalised.toString();\n+      }\n+    }\n+\n+    class CommandAndNumArgs implements CommandNormalizer {\n+      private final int numOfArgsToKeep;\n+\n+      public CommandAndNumArgs(int numOfArgsToKeep) {\n+        this.numOfArgsToKeep = numOfArgsToKeep;\n+      }\n+\n+      @Override\n+      public String normalize(String command, List<String> args) {\n+        StringBuilder normalised = new StringBuilder(command);\n+        int i = 0;\n+        for (; i < numOfArgsToKeep && i < args.size(); ++i) {\n+          normalised.append(\" \").append(args.get(i));\n+        }\n+        for (; i < args.size(); ++i) {", "originalCommit": "d0f943b7d163f3e7dd981f282bc41f56269d0b7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzYyNTc2Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1405#discussion_r507625766", "bodyText": "Both are perfectly fine to me, I'll use your version if you think it's more readable.", "author": "mateuszrzeszutek", "createdAt": "2020-10-19T10:04:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc1MDA4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc4Njc2OA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1405#discussion_r506786768", "bodyText": "Can you add examples for the various normalization?", "author": "anuraaga", "createdAt": "2020-10-17T03:09:46Z", "path": "instrumentation/lettuce/lettuce-5.1/src/main/java/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/RedisCommandNormalizer.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.lettuce.v5_1;\n+\n+import static java.util.Collections.unmodifiableMap;\n+\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.CommandAndNumArgs;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.Default;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.Eval;\n+import io.opentelemetry.javaagent.instrumentation.lettuce.v5_1.RedisCommandNormalizer.CommandNormalizer.MultiKeyValue;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/** This class is responsible for masking potentially sensitive data in Redis commands. */\n+public final class RedisCommandNormalizer {\n+\n+  private static final Map<String, CommandNormalizer> NORMALIZERS;\n+\n+  static {\n+    Map<String, CommandNormalizer> normalizers = new HashMap<>();\n+\n+    CommandNormalizer keepOneArg = new CommandAndNumArgs(1);", "originalCommit": "d0f943b7d163f3e7dd981f282bc41f56269d0b7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzczMzI5Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1405#discussion_r507733297", "bodyText": "Added some examples to class JavaDoc.", "author": "mateuszrzeszutek", "createdAt": "2020-10-19T13:11:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc4Njc2OA=="}], "type": "inlineReview"}, {"oid": "f0b9ce2cf62a91a32433c0a8fd8a3d42ae4cccca", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/f0b9ce2cf62a91a32433c0a8fd8a3d42ae4cccca", "message": "Apply suggestions from code review\n\nCo-authored-by: Trask Stalnaker <trask.stalnaker@gmail.com>", "committedDate": "2020-10-19T10:08:51Z", "type": "commit"}, {"oid": "bf591f216acc92b1237cb4e9cd725ca652210d5d", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/bf591f216acc92b1237cb4e9cd725ca652210d5d", "message": "Lettuce 5.1 instrumentation should log normalised commands as db.statement", "committedDate": "2020-10-19T13:11:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk3MzMwNw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1405#discussion_r507973307", "bodyText": "sorry, i didn't explain my thought about this well, this is more what i was thinking, keeping the previous KEY_PATTERN:\nplease pick whichever implementation you want (original, current, or below), i don't see a clear winner myself\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                while (m.find()) {\n          \n          \n            \n                  String wrapped = m.group(\"wrapped\");\n          \n          \n            \n                  if (wrapped != null) {\n          \n          \n            \n                    argsList.add(wrapped);\n          \n          \n            \n                  } else {\n          \n          \n            \n                    argsList.add(m.group(\"plain\"));\n          \n          \n            \n                  }\n          \n          \n            \n                }\n          \n          \n            \n                int lastEnd = 0;\n          \n          \n            \n                while (m.find()) {\n          \n          \n            \n                  int wrapperStart = m.start();\n          \n          \n            \n                  argsList.addAll(split(args, lastEnd, wrapperStart));\n          \n          \n            \n                  argsList.add(m.group(\"key\"));\n          \n          \n            \n                  lastEnd = m.end();\n          \n          \n            \n                }\n          \n          \n            \n                argsList.addAll(split(args, lastEnd, args.length()));\n          \n          \n            \n            \n          \n          \n            \n              ...\n          \n          \n            \n            \n          \n          \n            \n              private static final Pattern SPLIT_PATTERN = Pattern.compile(\" \");\n          \n          \n            \n            \n          \n          \n            \n              private static List<String> split(String args, int from, int to) {\n          \n          \n            \n                return Arrays.asList(SPLIT_PATTERN.split(args.subSequence(from, to)));\n          \n          \n            \n              }", "author": "trask", "createdAt": "2020-10-19T18:28:03Z", "path": "instrumentation/lettuce/lettuce-5.1/src/main/java/io/opentelemetry/javaagent/instrumentation/lettuce/v5_1/LettuceArgSplitter.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.lettuce.v5_1;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+\n+public final class LettuceArgSplitter {\n+  private static final Pattern KEY_PATTERN =\n+      Pattern.compile(\"((key|value)<(?<wrapped>[^>]+)>|(?<plain>[0-9A-Za-z=]+))(\\\\s+|$)\");\n+\n+  // this method removes the key|value<...> wrappers around redis keys or values and splits the args\n+  // string\n+  public static List<String> splitArgs(@Nullable String args) {\n+    if (args == null || args.isEmpty()) {\n+      return Collections.emptyList();\n+    }\n+\n+    List<String> argsList = new ArrayList<>();\n+    Matcher m = KEY_PATTERN.matcher(args);\n+    while (m.find()) {\n+      String wrapped = m.group(\"wrapped\");\n+      if (wrapped != null) {\n+        argsList.add(wrapped);\n+      } else {\n+        argsList.add(m.group(\"plain\"));\n+      }\n+    }", "originalCommit": "bf591f216acc92b1237cb4e9cd725ca652210d5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQxNTY4Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1405#discussion_r508415686", "bodyText": "Oh, I see. Hmm, I think I'll leave it as it is now - the pattern is a bit more complex but I like the fact that we only go through the entire string once.", "author": "mateuszrzeszutek", "createdAt": "2020-10-20T11:14:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk3MzMwNw=="}], "type": "inlineReview"}]}