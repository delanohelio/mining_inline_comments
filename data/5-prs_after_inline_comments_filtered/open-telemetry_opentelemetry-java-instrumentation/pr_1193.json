{"pr_number": 1193, "pr_title": "Muzzle should fail on unimplemented abstract methods", "pr_createdAt": "2020-09-11T14:26:13Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1193", "timeline": [{"oid": "b8eed12c68ba2049cee8cff4ea317531bd490806", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/b8eed12c68ba2049cee8cff4ea317531bd490806", "message": "Muzzle should fail on unimplemented abstract methods", "committedDate": "2020-09-11T15:30:08Z", "type": "forcePushed"}, {"oid": "8cca70514ff33ccb91db9994916fdba540638866", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/8cca70514ff33ccb91db9994916fdba540638866", "message": "Muzzle should fail on unimplemented abstract methods", "committedDate": "2020-09-14T09:28:48Z", "type": "forcePushed"}, {"oid": "87db6c7e3ad73fc39ef6713c34f5a40af7fbaf17", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/87db6c7e3ad73fc39ef6713c34f5a40af7fbaf17", "message": "Muzzle should fail on unimplemented abstract methods", "committedDate": "2020-09-14T10:08:27Z", "type": "forcePushed"}, {"oid": "1ec4b012f45945db1d4e6f96a4a24f71e5688dae", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/1ec4b012f45945db1d4e6f96a4a24f71e5688dae", "message": "Muzzle should fail on unimplemented abstract methods", "committedDate": "2020-09-14T11:39:44Z", "type": "forcePushed"}, {"oid": "42a90e6008cfa736b41cdf49f9c2e91ebba55234", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/42a90e6008cfa736b41cdf49f9c2e91ebba55234", "message": "Muzzle should fail on unimplemented abstract methods", "committedDate": "2020-09-15T12:37:16Z", "type": "forcePushed"}, {"oid": "0adcc5d57fa957efb231de9c2e49cd4f29fe3c60", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/0adcc5d57fa957efb231de9c2e49cd4f29fe3c60", "message": "Muzzle should fail on unimplemented abstract methods", "committedDate": "2020-09-15T13:04:41Z", "type": "forcePushed"}, {"oid": "657025af32ff73b0e4c33968fb73aa131b07f57c", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/657025af32ff73b0e4c33968fb73aa131b07f57c", "message": "Muzzle should fail on unimplemented abstract methods", "committedDate": "2020-09-15T14:20:55Z", "type": "forcePushed"}, {"oid": "55d1846d2d0875de04e4b4efbfb09f050a7536e5", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/55d1846d2d0875de04e4b4efbfb09f050a7536e5", "message": "Muzzle should fail on unimplemented abstract methods", "committedDate": "2020-09-15T14:35:15Z", "type": "forcePushed"}, {"oid": "ec746b36a276ab931a3f4584b9265193bf259c09", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/ec746b36a276ab931a3f4584b9265193bf259c09", "message": "Muzzle should fail on unimplemented abstract methods", "committedDate": "2020-09-17T11:19:19Z", "type": "forcePushed"}, {"oid": "71ebbc31c0713c24cdf509e3f9715b9df4540527", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/71ebbc31c0713c24cdf509e3f9715b9df4540527", "message": "Implement MDC auto-instrumentation for log4j2", "committedDate": "2020-09-17T14:31:17Z", "type": "forcePushed"}, {"oid": "b993119386f3630d3b0c602fa466184cbf54f95b", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/b993119386f3630d3b0c602fa466184cbf54f95b", "message": "Implement MDC auto-instrumentation for log4j2", "committedDate": "2020-09-17T15:24:20Z", "type": "forcePushed"}, {"oid": "00495e98a202468444180ea59d4152edd05450a8", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/00495e98a202468444180ea59d4152edd05450a8", "message": "Muzzle should fail on unimplemented abstract methods\n\nAdd references for super types and interfaces as well", "committedDate": "2020-09-17T16:06:39Z", "type": "forcePushed"}, {"oid": "0ca0c3210c96b8c2ece6a28624dceefe23d53279", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/0ca0c3210c96b8c2ece6a28624dceefe23d53279", "message": "Muzzle should fail on unimplemented abstract methods\n\nAdd references for super types and interfaces as well", "committedDate": "2020-09-17T16:13:31Z", "type": "forcePushed"}, {"oid": "0123d3160403c64ce0858213707a15e34e272974", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/0123d3160403c64ce0858213707a15e34e272974", "message": "Muzzle should fail on unimplemented abstract methods", "committedDate": "2020-09-18T13:06:55Z", "type": "forcePushed"}, {"oid": "3e5d97ddd776626574b6374f5ae598e1d742e9c6", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/3e5d97ddd776626574b6374f5ae598e1d742e9c6", "message": "Muzzle should fail on unimplemented abstract methods", "committedDate": "2020-09-18T13:14:45Z", "type": "forcePushed"}, {"oid": "b8610f72b526b134c057167afdc87755aac49bdd", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/b8610f72b526b134c057167afdc87755aac49bdd", "message": "Muzzle should fail on unimplemented abstract methods", "committedDate": "2020-09-18T13:20:07Z", "type": "forcePushed"}, {"oid": "01e65e29437ef0e7dcea1d095e284d8ae10e0c4e", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/01e65e29437ef0e7dcea1d095e284d8ae10e0c4e", "message": "Muzzle should fail on unimplemented abstract methods", "committedDate": "2020-09-18T14:42:53Z", "type": "forcePushed"}, {"oid": "173db14a4d19cd1a37a77d30163f96e5a3d7dddf", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/173db14a4d19cd1a37a77d30163f96e5a3d7dddf", "message": "Muzzle should fail on unimplemented abstract methods", "committedDate": "2020-09-18T14:58:30Z", "type": "forcePushed"}, {"oid": "ad9d1433c0817b5905db34c95a261d88f53351c9", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/ad9d1433c0817b5905db34c95a261d88f53351c9", "message": "Muzzle should fail on unimplemented abstract methods", "committedDate": "2020-09-18T15:33:26Z", "type": "commit"}, {"oid": "ad9d1433c0817b5905db34c95a261d88f53351c9", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/ad9d1433c0817b5905db34c95a261d88f53351c9", "message": "Muzzle should fail on unimplemented abstract methods", "committedDate": "2020-09-18T15:33:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3MDY1NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1193#discussion_r491970655", "bodyText": "Is private method overridable?", "author": "iNikem", "createdAt": "2020-09-21T11:32:01Z", "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/muzzle/HelperReferenceWrapper.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.javaagent.tooling.muzzle;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singleton;\n+import static net.bytebuddy.description.method.MethodDescription.CONSTRUCTOR_INTERNAL_NAME;\n+\n+import com.google.common.base.Function;\n+import com.google.common.base.Objects;\n+import com.google.common.base.Predicate;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.Iterables;\n+import io.opentelemetry.javaagent.tooling.muzzle.Reference.Flag;\n+import java.util.Map;\n+import net.bytebuddy.description.method.MethodDescription.InDefinedShape;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.pool.TypePool;\n+import net.bytebuddy.pool.TypePool.Resolution;\n+\n+/** This class provides a common interface for {@link Reference} and {@link TypeDescription}. */\n+public interface HelperReferenceWrapper {\n+  boolean isAbstract();\n+\n+  /**\n+   * @return true if the wrapped type extends any class other than {@link Object} or implements any\n+   *     interface.\n+   */\n+  boolean hasSuperTypes();\n+\n+  /**\n+   * @return An iterable containing the wrapped type's super class (if exists) and implemented\n+   *     interfaces.\n+   */\n+  Iterable<HelperReferenceWrapper> getSuperTypes();\n+\n+  /** @return An iterable with all non-private, non-static methods declared in the wrapped type. */\n+  Iterable<Method> getMethods();\n+\n+  final class Method {\n+    private final boolean isAbstract;\n+    private final String declaringClass;\n+    private final String name;\n+    private final String descriptor;\n+\n+    public Method(boolean isAbstract, String declaringClass, String name, String descriptor) {\n+      this.isAbstract = isAbstract;\n+      this.declaringClass = declaringClass;\n+      this.name = name;\n+      this.descriptor = descriptor;\n+    }\n+\n+    public boolean isAbstract() {\n+      return isAbstract;\n+    }\n+\n+    public String getName() {\n+      return name;\n+    }\n+\n+    public String getDescriptor() {\n+      return descriptor;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) return true;\n+      if (o == null || getClass() != o.getClass()) return false;\n+      Method method = (Method) o;\n+      return Objects.equal(name, method.name) && Objects.equal(descriptor, method.descriptor);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hashCode(name, descriptor);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return declaringClass + \"#\" + name + descriptor;\n+    }\n+  }\n+\n+  class Factory {\n+    private final TypePool classpathPool;\n+    private final Map<String, Reference> helperReferences;\n+\n+    public Factory(TypePool classpathPool, Map<String, Reference> helperReferences) {\n+      this.classpathPool = classpathPool;\n+      this.helperReferences = helperReferences;\n+    }\n+\n+    public HelperReferenceWrapper create(Reference reference) {\n+      return new ReferenceType(reference);\n+    }\n+\n+    private HelperReferenceWrapper create(String className) {\n+      if (helperReferences.containsKey(className)) {\n+        return new ReferenceType(helperReferences.get(className));\n+      }\n+      Resolution resolution = classpathPool.describe(className);\n+      if (resolution.isResolved()) {\n+        return new ClasspathType(resolution.resolve());\n+      }\n+      throw new IllegalStateException(\"Missing class \" + className);\n+    }\n+\n+    private final class ReferenceType implements HelperReferenceWrapper {\n+      private final Reference reference;\n+\n+      private ReferenceType(Reference reference) {\n+        this.reference = reference;\n+      }\n+\n+      @Override\n+      public boolean isAbstract() {\n+        return reference.getFlags().contains(Flag.ABSTRACT);\n+      }\n+\n+      @Override\n+      public boolean hasSuperTypes() {\n+        return hasActualSuperType() || reference.getInterfaces().size() > 0;\n+      }\n+\n+      // Uses guava iterables to avoid unnecessary collection copying\n+      @Override\n+      public Iterable<HelperReferenceWrapper> getSuperTypes() {\n+        Iterable<HelperReferenceWrapper> superClass = emptyList();\n+        if (hasActualSuperType()) {\n+          superClass = singleton(Factory.this.create(reference.getSuperName()));\n+        }\n+\n+        Iterable<HelperReferenceWrapper> interfaces =\n+            FluentIterable.from(reference.getInterfaces()).transform(toWrapper());\n+\n+        return Iterables.concat(superClass, interfaces);\n+      }\n+\n+      private boolean hasActualSuperType() {\n+        return reference.getSuperName() != null\n+            && !reference.getSuperName().equals(Object.class.getName());\n+      }\n+\n+      private Function<String, HelperReferenceWrapper> toWrapper() {\n+        return new Function<String, HelperReferenceWrapper>() {\n+          @Override\n+          public HelperReferenceWrapper apply(String interfaceName) {\n+            return Factory.this.create(interfaceName);\n+          }\n+        };\n+      }\n+\n+      // Uses guava iterables to avoid unnecessary collection copying\n+      @Override\n+      public Iterable<Method> getMethods() {\n+        return FluentIterable.from(reference.getMethods())\n+            .filter(isOverrideable())\n+            .transform(toMethod());\n+      }\n+\n+      private Predicate<Reference.Method> isOverrideable() {\n+        return new Predicate<Reference.Method>() {\n+          @Override\n+          public boolean apply(Reference.Method input) {\n+            return !(input.getFlags().contains(Flag.STATIC)\n+                || input.getFlags().contains(Flag.PRIVATE_OR_HIGHER)", "originalCommit": "ad9d1433c0817b5905db34c95a261d88f53351c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA0Mzc5MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1193#discussion_r492043791", "bodyText": "Nope, they're not - so we can skip checking them.", "author": "mateuszrzeszutek", "createdAt": "2020-09-21T13:28:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3MDY1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjEwODY1NA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1193#discussion_r492108654", "bodyText": "Now I am even more confused. We create a predicate for isOverrideable and we say it is true when method\n\nis not static AND\nis not private or higher AND\nis not a constructor\n\naren't ALL methods \"private or higher\"? Which makes this predicate constantly false?", "author": "iNikem", "createdAt": "2020-09-21T14:49:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3MDY1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjEyMDE4Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1193#discussion_r492120187", "bodyText": "Ah, that's what you meant. The problem here is that PRIVATE_OR_HIGHER (and others) is used in two ways in muzzle:\n\nit just simply marks that a method/class is private which is the case here, or\nit describes a minimum access level required between a type and a method/field/class.\n\nI'll split those two types of usage into separate flags to make it a bit more clear.", "author": "mateuszrzeszutek", "createdAt": "2020-09-21T15:00:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3MDY1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3MTgzNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1193#discussion_r491971835", "bodyText": "Why this is not required any more?", "author": "iNikem", "createdAt": "2020-09-21T11:34:36Z", "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/muzzle/MuzzleVisitor.java", "diffHunk": "@@ -133,28 +133,18 @@ public MethodVisitor visitMethod(\n     }\n \n     public Reference[] generateReferences() {\n-      // track sources we've generated references from to avoid recursion", "originalCommit": "ad9d1433c0817b5905db34c95a261d88f53351c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA0MTg2MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1193#discussion_r492041861", "bodyText": "Because it served no purpose from the start: because adviceClassNames always contained unique elements referenceSources.contains(adviceClass) always returned false.", "author": "mateuszrzeszutek", "createdAt": "2020-09-21T13:25:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3MTgzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3MzIzMw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1193#discussion_r491973233", "bodyText": "Can you add javadoc to methods of Flag enum?", "author": "iNikem", "createdAt": "2020-09-21T11:37:40Z", "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/muzzle/Reference.java", "diffHunk": "@@ -363,25 +364,36 @@ public boolean matches(int asmFlags) {\n     NON_FINAL {\n       @Override\n       public boolean contradicts(Flag anotherFlag) {\n-        return anotherFlag == FINAL;\n+        return anotherFlag == FINAL || anotherFlag == ABSTRACT;\n       }\n \n       @Override\n       public boolean matches(int asmFlags) {\n-        return (Opcodes.ACC_FINAL & asmFlags) == 0;\n+        return ((Opcodes.ACC_ABSTRACT | Opcodes.ACC_FINAL) & asmFlags) == 0;\n       }\n     },\n     FINAL {\n       @Override\n       public boolean contradicts(Flag anotherFlag) {\n-        return anotherFlag == NON_FINAL;\n+        return anotherFlag == NON_FINAL || anotherFlag == ABSTRACT;\n       }\n \n       @Override\n       public boolean matches(int asmFlags) {\n         return (Opcodes.ACC_FINAL & asmFlags) != 0;\n       }\n     },\n+    ABSTRACT {", "originalCommit": "ad9d1433c0817b5905db34c95a261d88f53351c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA5MzA0OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1193#discussion_r492093049", "bodyText": "I'll add javadoc to matches() method -- I've checked the usages of all of them and it turned out that contradicts() and supersedes() are never used. I guess that I'll be doing a general code clean-up together with muzzle documentation \ud83d\ude04", "author": "mateuszrzeszutek", "createdAt": "2020-09-21T14:28:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3MzIzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3NjQ1MA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1193#discussion_r491976450", "bodyText": "Do we support abstract helpers?", "author": "iNikem", "createdAt": "2020-09-21T11:44:32Z", "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/muzzle/ReferenceMatcher.java", "diffHunk": "@@ -147,7 +157,64 @@ private boolean doesMatch(ClassLoader loader) {\n     }\n   }\n \n-  public static List<Reference.Mismatch> checkMatch(\n+  // for helper classes we make sure that all abstract methods from super classes and interfaces are\n+  // implemented\n+  private List<Reference.Mismatch> checkHelperClassMatch(Reference helperClass, TypePool typePool) {\n+    List<Mismatch> mismatches = Collections.emptyList();\n+\n+    HelperReferenceWrapper helperWrapper = new Factory(typePool, references).create(helperClass);\n+\n+    if (!helperWrapper.hasSuperTypes() || helperWrapper.isAbstract()) {", "originalCommit": "ad9d1433c0817b5905db34c95a261d88f53351c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAzODE1Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1193#discussion_r492038152", "bodyText": "We do -- we just skip the abstract method check for them, because it's perfectly fine for them to contain abstract methods.", "author": "mateuszrzeszutek", "createdAt": "2020-09-21T13:20:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3NjQ1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3Nzc1OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1193#discussion_r491977759", "bodyText": "clone and finalize?", "author": "iNikem", "createdAt": "2020-09-21T11:47:01Z", "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/muzzle/ReferenceMatcher.java", "diffHunk": "@@ -147,7 +157,64 @@ private boolean doesMatch(ClassLoader loader) {\n     }\n   }\n \n-  public static List<Reference.Mismatch> checkMatch(\n+  // for helper classes we make sure that all abstract methods from super classes and interfaces are\n+  // implemented\n+  private List<Reference.Mismatch> checkHelperClassMatch(Reference helperClass, TypePool typePool) {\n+    List<Mismatch> mismatches = Collections.emptyList();\n+\n+    HelperReferenceWrapper helperWrapper = new Factory(typePool, references).create(helperClass);\n+\n+    if (!helperWrapper.hasSuperTypes() || helperWrapper.isAbstract()) {\n+      return mismatches;\n+    }\n+\n+    // treat the helper type as a bag of methods: collect all methods defined in the helper class,\n+    // all superclasses and interfaces and check if all abstract methods are implemented somewhere\n+    Set<HelperReferenceWrapper.Method> abstractMethods = new HashSet<>();\n+    Set<HelperReferenceWrapper.Method> plainMethods = new HashSet<>();\n+    collectMethodsFromTypeHierarchy(helperWrapper, abstractMethods, plainMethods);\n+\n+    Set<HelperReferenceWrapper.Method> unimplementedMethods =\n+        Sets.difference(abstractMethods, plainMethods);\n+    for (HelperReferenceWrapper.Method unimplementedMethod : unimplementedMethods) {\n+      mismatches =\n+          lazyAdd(\n+              mismatches,\n+              new Reference.Mismatch.MissingMethod(\n+                  helperClass.getSources().toArray(new Reference.Source[0]),\n+                  helperClass.getClassName(),\n+                  unimplementedMethod.toString()));\n+    }\n+\n+    return mismatches;\n+  }\n+\n+  private static void collectMethodsFromTypeHierarchy(\n+      HelperReferenceWrapper type, Set<Method> abstractMethods, Set<Method> plainMethods) {\n+\n+    for (HelperReferenceWrapper.Method method : type.getMethods()) {\n+      if (shouldIgnore(method)) {\n+        continue;\n+      }\n+      (method.isAbstract() ? abstractMethods : plainMethods).add(method);\n+    }\n+\n+    for (HelperReferenceWrapper superType : type.getSuperTypes()) {\n+      collectMethodsFromTypeHierarchy(superType, abstractMethods, plainMethods);\n+    }\n+  }\n+\n+  // ignore Object methods - sometimes defined by interfaces which causes them to be treated as\n+  // abstract\n+  private static boolean shouldIgnore(HelperReferenceWrapper.Method superMethod) {\n+    return \"hashCode\".equals(superMethod.getName()) && \"()I\".equals(superMethod.getDescriptor())\n+        || \"equals\".equals(superMethod.getName())\n+            && \"(Ljava/lang/Object;)Z\".equals(superMethod.getDescriptor())\n+        || \"toString\".equals(superMethod.getName())", "originalCommit": "ad9d1433c0817b5905db34c95a261d88f53351c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA0MDQzNA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1193#discussion_r492040434", "bodyText": "Good catch, will add.", "author": "mateuszrzeszutek", "createdAt": "2020-09-21T13:23:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3Nzc1OQ=="}], "type": "inlineReview"}, {"oid": "ff1833ce1d1a7557b613e1e24aa20d4bdd665606", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/ff1833ce1d1a7557b613e1e24aa20d4bdd665606", "message": "Muzzle should fail on unimplemented abstract methods", "committedDate": "2020-09-21T14:44:56Z", "type": "commit"}, {"oid": "1c95fdfb040b140e8ebc70313694c5305074516b", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/1c95fdfb040b140e8ebc70313694c5305074516b", "message": "Muzzle should fail on unimplemented abstract methods", "committedDate": "2020-09-21T15:44:29Z", "type": "commit"}, {"oid": "dca390491bf5f52be3f3670b88622d95f0b48d78", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/dca390491bf5f52be3f3670b88622d95f0b48d78", "message": "Muzzle should fail on unimplemented abstract methods", "committedDate": "2020-09-21T16:32:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ2Njk5Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1193#discussion_r492466997", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return PUBLIC.matches(asmFlags) || PROTECTED.matches(asmFlags) || PACKAGE.matches(asmFlags);\n          \n          \n            \n                    return !PRIVATE.matches(asmFlags);", "author": "trask", "createdAt": "2020-09-22T04:23:46Z", "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/muzzle/Reference.java", "diffHunk": "@@ -295,62 +296,63 @@ String getMismatchDetails() {\n \n     public static class MissingMethod extends Mismatch {\n       private final String className;\n-      private final String method;\n+      private final String methodSignature;\n \n-      public MissingMethod(Source[] sources, String className, String method) {\n+      public MissingMethod(Source[] sources, String className, String methodSignature) {\n         super(sources);\n         this.className = className;\n-        this.method = method;\n+        this.methodSignature = methodSignature;\n       }\n \n       @Override\n       String getMismatchDetails() {\n-        return \"Missing method \" + className + \"#\" + method;\n+        return \"Missing method \" + className + \"#\" + methodSignature;\n       }\n     }\n   }\n \n   /** Expected flag (or lack of flag) on a class, method, or field reference. */\n   public enum Flag {\n+    // The following constants represent the exact visibility of a referenced class/method\n     PUBLIC {\n       @Override\n-      public boolean supersedes(Flag anotherFlag) {\n-        switch (anotherFlag) {\n-          case PRIVATE_OR_HIGHER:\n-          case PROTECTED_OR_HIGHER:\n-          case PACKAGE_OR_HIGHER:\n-            return true;\n-          default:\n-            return false;\n-        }\n+      public boolean matches(int asmFlags) {\n+        return (Opcodes.ACC_PUBLIC & asmFlags) != 0;\n       }\n-\n+    },\n+    PROTECTED {\n       @Override\n       public boolean matches(int asmFlags) {\n-        return (Opcodes.ACC_PUBLIC & asmFlags) != 0;\n+        return (Opcodes.ACC_PROTECTED & asmFlags) != 0;\n       }\n     },\n-    PACKAGE_OR_HIGHER {\n+    PACKAGE {\n       @Override\n-      public boolean supersedes(Flag anotherFlag) {\n-        return anotherFlag == PRIVATE_OR_HIGHER;\n+      public boolean matches(int asmFlags) {\n+        return !(PUBLIC.matches(asmFlags)\n+            || PROTECTED.matches(asmFlags)\n+            || PRIVATE.matches(asmFlags));\n       }\n-\n+    },\n+    PRIVATE {\n       @Override\n       public boolean matches(int asmFlags) {\n-        return (Opcodes.ACC_PUBLIC & asmFlags) != 0\n-            || ((Opcodes.ACC_PRIVATE & asmFlags) == 0 && (Opcodes.ACC_PROTECTED & asmFlags) == 0);\n+        return (Opcodes.ACC_PRIVATE & asmFlags) != 0;\n       }\n     },\n+\n+    // The following constants represent a minimum access level required by a method call or field\n+    // access\n     PROTECTED_OR_HIGHER {\n       @Override\n-      public boolean supersedes(Flag anotherFlag) {\n-        return anotherFlag == PRIVATE_OR_HIGHER;\n+      public boolean matches(int asmFlags) {\n+        return PUBLIC.matches(asmFlags) || PROTECTED.matches(asmFlags);\n       }\n-\n+    },\n+    PACKAGE_OR_HIGHER {\n       @Override\n       public boolean matches(int asmFlags) {\n-        return PUBLIC.matches(asmFlags) || (Opcodes.ACC_PROTECTED & asmFlags) != 0;\n+        return PUBLIC.matches(asmFlags) || PROTECTED.matches(asmFlags) || PACKAGE.matches(asmFlags);", "originalCommit": "dca390491bf5f52be3f3670b88622d95f0b48d78", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ3MTk1NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1193#discussion_r492471955", "bodyText": "Maybe we can split these grouping out into separate enums? e.g. ExactVisibilityFlag, MinVisibilityFlag, OwnershipFlag (for static?), ManifestationFlag (for abstract/final?)\nAnd then Reference.Method could have separate fields for the different enum types, and merging methods would hopefully make more sense, or at least the limitations of merging methods would be clearer, instead of current behavior of throwing all the flags into a big set during merging methods and hoping for the best \ud83d\ude02\n(doesn't need to be this PR)", "author": "trask", "createdAt": "2020-09-22T04:47:34Z", "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/muzzle/Reference.java", "diffHunk": "@@ -295,62 +296,63 @@ String getMismatchDetails() {\n \n     public static class MissingMethod extends Mismatch {\n       private final String className;\n-      private final String method;\n+      private final String methodSignature;\n \n-      public MissingMethod(Source[] sources, String className, String method) {\n+      public MissingMethod(Source[] sources, String className, String methodSignature) {\n         super(sources);\n         this.className = className;\n-        this.method = method;\n+        this.methodSignature = methodSignature;\n       }\n \n       @Override\n       String getMismatchDetails() {\n-        return \"Missing method \" + className + \"#\" + method;\n+        return \"Missing method \" + className + \"#\" + methodSignature;\n       }\n     }\n   }\n \n   /** Expected flag (or lack of flag) on a class, method, or field reference. */\n   public enum Flag {\n+    // The following constants represent the exact visibility of a referenced class/method", "originalCommit": "dca390491bf5f52be3f3670b88622d95f0b48d78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU4NDAxNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1193#discussion_r492584015", "bodyText": "I thought about extracting a common Flag interface and making all these new enums implement it, but leaving them all in a single enum set. I like the separate fields idea because of how easy it'd be to detect merge conflicts (you can't have a field that is both static and non-static).\nI'll do that in a separate PR - I'll refactor, clean up and document muzzle someday soon.", "author": "mateuszrzeszutek", "createdAt": "2020-09-22T09:08:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ3MTk1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ4NTA0Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1193#discussion_r492485043", "bodyText": "maybe a note about why the recursion ends before superName = java/lang/Object? (otherwise Object methods would get added to plainMethods above and this ignore method wouldn't be needed I think)", "author": "trask", "createdAt": "2020-09-22T05:42:45Z", "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/muzzle/ReferenceMatcher.java", "diffHunk": "@@ -147,7 +157,67 @@ private boolean doesMatch(ClassLoader loader) {\n     }\n   }\n \n-  public static List<Reference.Mismatch> checkMatch(\n+  // for helper classes we make sure that all abstract methods from super classes and interfaces are\n+  // implemented\n+  private List<Reference.Mismatch> checkHelperClassMatch(Reference helperClass, TypePool typePool) {\n+    List<Mismatch> mismatches = Collections.emptyList();\n+\n+    HelperReferenceWrapper helperWrapper = new Factory(typePool, references).create(helperClass);\n+\n+    if (!helperWrapper.hasSuperTypes() || helperWrapper.isAbstract()) {\n+      return mismatches;\n+    }\n+\n+    // treat the helper type as a bag of methods: collect all methods defined in the helper class,\n+    // all superclasses and interfaces and check if all abstract methods are implemented somewhere\n+    Set<HelperReferenceWrapper.Method> abstractMethods = new HashSet<>();\n+    Set<HelperReferenceWrapper.Method> plainMethods = new HashSet<>();\n+    collectMethodsFromTypeHierarchy(helperWrapper, abstractMethods, plainMethods);\n+\n+    Set<HelperReferenceWrapper.Method> unimplementedMethods =\n+        Sets.difference(abstractMethods, plainMethods);\n+    for (HelperReferenceWrapper.Method unimplementedMethod : unimplementedMethods) {\n+      mismatches =\n+          lazyAdd(\n+              mismatches,\n+              new Reference.Mismatch.MissingMethod(\n+                  helperClass.getSources().toArray(new Reference.Source[0]),\n+                  helperClass.getClassName(),\n+                  unimplementedMethod.toString()));\n+    }\n+\n+    return mismatches;\n+  }\n+\n+  private static void collectMethodsFromTypeHierarchy(\n+      HelperReferenceWrapper type, Set<Method> abstractMethods, Set<Method> plainMethods) {\n+\n+    for (HelperReferenceWrapper.Method method : type.getMethods()) {\n+      if (shouldIgnore(method)) {\n+        continue;\n+      }\n+      (method.isAbstract() ? abstractMethods : plainMethods).add(method);\n+    }\n+\n+    for (HelperReferenceWrapper superType : type.getSuperTypes()) {\n+      collectMethodsFromTypeHierarchy(superType, abstractMethods, plainMethods);\n+    }\n+  }\n+\n+  // ignore Object methods - sometimes defined by interfaces which causes them to be treated as\n+  // abstract", "originalCommit": "dca390491bf5f52be3f3670b88622d95f0b48d78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU4ODM4OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1193#discussion_r492588389", "bodyText": "Honestly I can't remember now why I stopped recursion before Object - I must have run into some issue with that, but I can't remember what it was. I've removed both this method and the Object condition in HelperReferenceWrapper and everything works as expected, so I'll remove this code altogether. The simpler it is the better.", "author": "mateuszrzeszutek", "createdAt": "2020-09-22T09:15:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ4NTA0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ4NjM4MA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1193#discussion_r492486380", "bodyText": "see similar comment below, and add extra field to MissingMethod\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                              unimplementedMethod.toString()));\n          \n          \n            \n                              unimplementedMethod.getName(), unimplementedMethod.getDescriptor()));", "author": "trask", "createdAt": "2020-09-22T05:47:32Z", "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/muzzle/ReferenceMatcher.java", "diffHunk": "@@ -147,7 +157,67 @@ private boolean doesMatch(ClassLoader loader) {\n     }\n   }\n \n-  public static List<Reference.Mismatch> checkMatch(\n+  // for helper classes we make sure that all abstract methods from super classes and interfaces are\n+  // implemented\n+  private List<Reference.Mismatch> checkHelperClassMatch(Reference helperClass, TypePool typePool) {\n+    List<Mismatch> mismatches = Collections.emptyList();\n+\n+    HelperReferenceWrapper helperWrapper = new Factory(typePool, references).create(helperClass);\n+\n+    if (!helperWrapper.hasSuperTypes() || helperWrapper.isAbstract()) {\n+      return mismatches;\n+    }\n+\n+    // treat the helper type as a bag of methods: collect all methods defined in the helper class,\n+    // all superclasses and interfaces and check if all abstract methods are implemented somewhere\n+    Set<HelperReferenceWrapper.Method> abstractMethods = new HashSet<>();\n+    Set<HelperReferenceWrapper.Method> plainMethods = new HashSet<>();\n+    collectMethodsFromTypeHierarchy(helperWrapper, abstractMethods, plainMethods);\n+\n+    Set<HelperReferenceWrapper.Method> unimplementedMethods =\n+        Sets.difference(abstractMethods, plainMethods);\n+    for (HelperReferenceWrapper.Method unimplementedMethod : unimplementedMethods) {\n+      mismatches =\n+          lazyAdd(\n+              mismatches,\n+              new Reference.Mismatch.MissingMethod(\n+                  helperClass.getSources().toArray(new Reference.Source[0]),\n+                  helperClass.getClassName(),\n+                  unimplementedMethod.toString()));", "originalCommit": "dca390491bf5f52be3f3670b88622d95f0b48d78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYxOTU2Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1193#discussion_r492619566", "bodyText": "Good point, changed.", "author": "mateuszrzeszutek", "createdAt": "2020-09-22T10:08:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ4NjM4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ4NjQ1MA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1193#discussion_r492486450", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                methodRef.getName() + methodRef.getDescriptor()));\n          \n          \n            \n                                methodRef.getName(), methodRef.getDescriptor()));", "author": "trask", "createdAt": "2020-09-22T05:47:48Z", "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/muzzle/ReferenceMatcher.java", "diffHunk": "@@ -205,8 +275,8 @@ private boolean doesMatch(ClassLoader loader) {\n                 mismatches,\n                 new Reference.Mismatch.MissingMethod(\n                     methodRef.getSources().toArray(new Reference.Source[0]),\n-                    methodRef.getName(),\n-                    methodRef.getDescriptor()));\n+                    reference.getClassName(),\n+                    methodRef.getName() + methodRef.getDescriptor()));", "originalCommit": "dca390491bf5f52be3f3670b88622d95f0b48d78", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ5ODM5MA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1193#discussion_r492498390", "bodyText": "maybe as an optimization here, don't generate method references for private methods,  or  since they can't implement an abstract method", "author": "trask", "createdAt": "2020-09-22T06:27:50Z", "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/muzzle/ReferenceCreator.java", "diffHunk": "@@ -244,12 +253,68 @@ public FieldVisitor visitField(\n   @Override\n   public MethodVisitor visitMethod(\n       int access, String name, String descriptor, String signature, String[] exceptions) {\n+\n+    // declared method references are not generated for advice classes, only for helper classes", "originalCommit": "dca390491bf5f52be3f3670b88622d95f0b48d78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU4OTkzMA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1193#discussion_r492589930", "bodyText": "That's a very good idea, I'll do that. Thanks!", "author": "mateuszrzeszutek", "createdAt": "2020-09-22T09:17:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ5ODM5MA=="}], "type": "inlineReview"}, {"oid": "7df71f3e42dfe935c2dd98161f6ef52e7fc10650", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/7df71f3e42dfe935c2dd98161f6ef52e7fc10650", "message": "Update javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/muzzle/Reference.java\n\nCo-authored-by: Trask Stalnaker <trask.stalnaker@gmail.com>", "committedDate": "2020-09-22T08:42:07Z", "type": "commit"}, {"oid": "91597cdd95baf922776dce1774887c9232399147", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/91597cdd95baf922776dce1774887c9232399147", "message": "Muzzle should fail on unimplemented abstract methods", "committedDate": "2020-09-22T10:00:51Z", "type": "commit"}]}