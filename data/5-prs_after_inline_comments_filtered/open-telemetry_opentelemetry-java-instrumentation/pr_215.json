{"pr_number": 215, "pr_title": "Implemented Apache Geode/Gemfire instrumentation", "pr_createdAt": "2020-03-06T22:01:37Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/215", "timeline": [{"oid": "8489967f2ff04f8836860dae99dbcc0588ed4867", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/8489967f2ff04f8836860dae99dbcc0588ed4867", "message": "WIP", "committedDate": "2020-03-05T02:08:48Z", "type": "commit"}, {"oid": "2b3c007a22b10bf71008d0a5bc171be2a1865b33", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/2b3c007a22b10bf71008d0a5bc171be2a1865b33", "message": "Merge branch 'master' of https://github.com/open-telemetry/opentelemetry-auto-instr-java into prydin-geode", "committedDate": "2020-03-05T02:09:07Z", "type": "commit"}, {"oid": "9a1b33ab9a40c00bbe3825c008f071512f5d4dcf", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/9a1b33ab9a40c00bbe3825c008f071512f5d4dcf", "message": "Working get/put instrumentation", "committedDate": "2020-03-06T15:45:10Z", "type": "commit"}, {"oid": "044bd7add3389cb114d7f87069cbd11a8f35c204", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/044bd7add3389cb114d7f87069cbd11a8f35c204", "message": "Added gradle file", "committedDate": "2020-03-06T15:45:39Z", "type": "commit"}, {"oid": "5c50ef0e4ee11c02b11f4108ba656c29041e99eb", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/5c50ef0e4ee11c02b11f4108ba656c29041e99eb", "message": "Working test cases", "committedDate": "2020-03-06T16:29:32Z", "type": "commit"}, {"oid": "83518e8440bca855149a54aa046dd05c648dcee3", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/83518e8440bca855149a54aa046dd05c648dcee3", "message": "PR candidate", "committedDate": "2020-03-06T21:58:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE5NjAyOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/215#discussion_r389196029", "bodyText": "I think\n.and(takesArgument(0, named(\"java.lang.String\")))\n\nis good corresponding to @Advice.Argument(0) String below", "author": "trask", "createdAt": "2020-03-06T23:45:44Z", "path": "instrumentation/geode-1.7/src/main/java/io/opentelemetry/auto/instrumentation/geode/GeodeInstrumentation.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.auto.instrumentation.geode;\n+\n+import static io.opentelemetry.auto.instrumentation.geode.GeodeDecorator.DECORATE;\n+import static io.opentelemetry.auto.instrumentation.geode.GeodeDecorator.TRACER;\n+import static io.opentelemetry.auto.tooling.bytebuddy.matcher.AgentElementMatchers.hasInterface;\n+import static io.opentelemetry.trace.Span.Kind.CLIENT;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.auto.bootstrap.CallDepthThreadLocalMap;\n+import io.opentelemetry.auto.instrumentation.api.SpanWithScope;\n+import io.opentelemetry.auto.instrumentation.api.Tags;\n+import io.opentelemetry.auto.tooling.Instrumenter;\n+import io.opentelemetry.trace.Span;\n+import java.lang.reflect.Method;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.apache.geode.cache.Region;\n+\n+@AutoService(Instrumenter.class)\n+public class GeodeInstrumentation extends Instrumenter.Default {\n+  public GeodeInstrumentation() {\n+    super(\"geode\", \"geode-client\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return hasInterface(named(\"org.apache.geode.cache.Region\"));\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      \"io.opentelemetry.auto.decorator.BaseDecorator\",\n+      \"io.opentelemetry.auto.decorator.ClientDecorator\",\n+      \"io.opentelemetry.auto.decorator.DatabaseClientDecorator\",\n+      packageName + \".GeodeDecorator\",\n+      packageName + \".GeodeInstrumentation$SimpleAdvice\",\n+      packageName + \".GeodeInstrumentation$QueryAdvice\"\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> map = new HashMap<>(2);\n+    map.put(\n+        isMethod()\n+            .and(\n+                named(\"clear\")\n+                    .or(nameStartsWith(\"contains\"))\n+                    .or(named(\"create\"))\n+                    .or(named(\"destroy\"))\n+                    .or(named(\"entrySet\"))\n+                    .or(named(\"get\"))\n+                    .or(named(\"getAll\"))\n+                    .or(named(\"invalidate\"))\n+                    .or(nameStartsWith(\"keySet\"))\n+                    .or(nameStartsWith(\"put\"))\n+                    .or(nameStartsWith(\"remove\"))\n+                    .or(named(\"replace\"))),\n+        GeodeInstrumentation.class.getName() + \"$SimpleAdvice\");\n+    map.put(\n+        isMethod().and(named(\"existsValue\").or(named(\"query\")).or(named(\"selectValue\"))),", "originalCommit": "83518e8440bca855149a54aa046dd05c648dcee3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE5NjU3NA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/215#discussion_r389196574", "bodyText": "I think this should go before the try/finally, don't need to call reset if it's a nested invocation", "author": "trask", "createdAt": "2020-03-06T23:48:26Z", "path": "instrumentation/geode-1.7/src/main/java/io/opentelemetry/auto/instrumentation/geode/GeodeInstrumentation.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.auto.instrumentation.geode;\n+\n+import static io.opentelemetry.auto.instrumentation.geode.GeodeDecorator.DECORATE;\n+import static io.opentelemetry.auto.instrumentation.geode.GeodeDecorator.TRACER;\n+import static io.opentelemetry.auto.tooling.bytebuddy.matcher.AgentElementMatchers.hasInterface;\n+import static io.opentelemetry.trace.Span.Kind.CLIENT;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.auto.bootstrap.CallDepthThreadLocalMap;\n+import io.opentelemetry.auto.instrumentation.api.SpanWithScope;\n+import io.opentelemetry.auto.instrumentation.api.Tags;\n+import io.opentelemetry.auto.tooling.Instrumenter;\n+import io.opentelemetry.trace.Span;\n+import java.lang.reflect.Method;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.apache.geode.cache.Region;\n+\n+@AutoService(Instrumenter.class)\n+public class GeodeInstrumentation extends Instrumenter.Default {\n+  public GeodeInstrumentation() {\n+    super(\"geode\", \"geode-client\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return hasInterface(named(\"org.apache.geode.cache.Region\"));\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      \"io.opentelemetry.auto.decorator.BaseDecorator\",\n+      \"io.opentelemetry.auto.decorator.ClientDecorator\",\n+      \"io.opentelemetry.auto.decorator.DatabaseClientDecorator\",\n+      packageName + \".GeodeDecorator\",\n+      packageName + \".GeodeInstrumentation$SimpleAdvice\",\n+      packageName + \".GeodeInstrumentation$QueryAdvice\"\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> map = new HashMap<>(2);\n+    map.put(\n+        isMethod()\n+            .and(\n+                named(\"clear\")\n+                    .or(nameStartsWith(\"contains\"))\n+                    .or(named(\"create\"))\n+                    .or(named(\"destroy\"))\n+                    .or(named(\"entrySet\"))\n+                    .or(named(\"get\"))\n+                    .or(named(\"getAll\"))\n+                    .or(named(\"invalidate\"))\n+                    .or(nameStartsWith(\"keySet\"))\n+                    .or(nameStartsWith(\"put\"))\n+                    .or(nameStartsWith(\"remove\"))\n+                    .or(named(\"replace\"))),\n+        GeodeInstrumentation.class.getName() + \"$SimpleAdvice\");\n+    map.put(\n+        isMethod().and(named(\"existsValue\").or(named(\"query\")).or(named(\"selectValue\"))),\n+        GeodeInstrumentation.class.getName() + \"$QueryAdvice\");\n+    return map;\n+  }\n+\n+  public static class SimpleAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static SpanWithScope onEnter(\n+        @Advice.This final Region thiz, @Advice.Origin final Method method) {\n+      if (CallDepthThreadLocalMap.incrementCallDepth(SimpleAdvice.class) > 0) {\n+        return null;\n+      }\n+      final Span span = TRACER.spanBuilder(method.getName()).setSpanKind(CLIENT).startSpan();\n+      DECORATE.afterStart(span);\n+      span.setAttribute(Tags.DB_INSTANCE, thiz.getName());\n+      return new SpanWithScope(span, TRACER.withSpan(span));\n+    }\n+\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void stopSpan(\n+        @Advice.Enter final SpanWithScope spanWithScope, @Advice.Thrown final Throwable throwable) {\n+      try {\n+        if (spanWithScope == null) {\n+          return;\n+        }", "originalCommit": "83518e8440bca855149a54aa046dd05c648dcee3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE5OTgyMg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/215#discussion_r389199822", "bodyText": "same here", "author": "trask", "createdAt": "2020-03-07T00:04:24Z", "path": "instrumentation/geode-1.7/src/main/java/io/opentelemetry/auto/instrumentation/geode/GeodeInstrumentation.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.auto.instrumentation.geode;\n+\n+import static io.opentelemetry.auto.instrumentation.geode.GeodeDecorator.DECORATE;\n+import static io.opentelemetry.auto.instrumentation.geode.GeodeDecorator.TRACER;\n+import static io.opentelemetry.auto.tooling.bytebuddy.matcher.AgentElementMatchers.hasInterface;\n+import static io.opentelemetry.trace.Span.Kind.CLIENT;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.auto.bootstrap.CallDepthThreadLocalMap;\n+import io.opentelemetry.auto.instrumentation.api.SpanWithScope;\n+import io.opentelemetry.auto.instrumentation.api.Tags;\n+import io.opentelemetry.auto.tooling.Instrumenter;\n+import io.opentelemetry.trace.Span;\n+import java.lang.reflect.Method;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.apache.geode.cache.Region;\n+\n+@AutoService(Instrumenter.class)\n+public class GeodeInstrumentation extends Instrumenter.Default {\n+  public GeodeInstrumentation() {\n+    super(\"geode\", \"geode-client\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return hasInterface(named(\"org.apache.geode.cache.Region\"));\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      \"io.opentelemetry.auto.decorator.BaseDecorator\",\n+      \"io.opentelemetry.auto.decorator.ClientDecorator\",\n+      \"io.opentelemetry.auto.decorator.DatabaseClientDecorator\",\n+      packageName + \".GeodeDecorator\",\n+      packageName + \".GeodeInstrumentation$SimpleAdvice\",\n+      packageName + \".GeodeInstrumentation$QueryAdvice\"\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> map = new HashMap<>(2);\n+    map.put(\n+        isMethod()\n+            .and(\n+                named(\"clear\")\n+                    .or(nameStartsWith(\"contains\"))\n+                    .or(named(\"create\"))\n+                    .or(named(\"destroy\"))\n+                    .or(named(\"entrySet\"))\n+                    .or(named(\"get\"))\n+                    .or(named(\"getAll\"))\n+                    .or(named(\"invalidate\"))\n+                    .or(nameStartsWith(\"keySet\"))\n+                    .or(nameStartsWith(\"put\"))\n+                    .or(nameStartsWith(\"remove\"))\n+                    .or(named(\"replace\"))),\n+        GeodeInstrumentation.class.getName() + \"$SimpleAdvice\");\n+    map.put(\n+        isMethod().and(named(\"existsValue\").or(named(\"query\")).or(named(\"selectValue\"))),\n+        GeodeInstrumentation.class.getName() + \"$QueryAdvice\");\n+    return map;\n+  }\n+\n+  public static class SimpleAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static SpanWithScope onEnter(\n+        @Advice.This final Region thiz, @Advice.Origin final Method method) {\n+      if (CallDepthThreadLocalMap.incrementCallDepth(SimpleAdvice.class) > 0) {\n+        return null;\n+      }\n+      final Span span = TRACER.spanBuilder(method.getName()).setSpanKind(CLIENT).startSpan();\n+      DECORATE.afterStart(span);\n+      span.setAttribute(Tags.DB_INSTANCE, thiz.getName());\n+      return new SpanWithScope(span, TRACER.withSpan(span));\n+    }\n+\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void stopSpan(\n+        @Advice.Enter final SpanWithScope spanWithScope, @Advice.Thrown final Throwable throwable) {\n+      try {\n+        if (spanWithScope == null) {\n+          return;\n+        }\n+        final Span span = spanWithScope.getSpan();\n+        DECORATE.onError(span, throwable);\n+        DECORATE.beforeFinish(span);\n+        span.end();\n+        spanWithScope.closeScope();\n+      } finally {\n+        CallDepthThreadLocalMap.reset(SimpleAdvice.class);\n+      }\n+    }\n+  }\n+\n+  public static class QueryAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static SpanWithScope onEnter(\n+        @Advice.This final Region thiz,\n+        @Advice.Origin final Method method,\n+        @Advice.Argument(0) final String query) {\n+      if (CallDepthThreadLocalMap.incrementCallDepth(QueryAdvice.class) > 0) {\n+        return null;\n+      }\n+      final Span span = TRACER.spanBuilder(method.getName()).setSpanKind(CLIENT).startSpan();\n+      DECORATE.afterStart(span);\n+      span.setAttribute(Tags.DB_INSTANCE, thiz.getName());\n+      span.setAttribute(Tags.DB_STATEMENT, query);\n+      return new SpanWithScope(span, TRACER.withSpan(span));\n+    }\n+\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void stopSpan(\n+        @Advice.Enter final SpanWithScope spanWithScope, @Advice.Thrown final Throwable throwable) {\n+      try {\n+        if (spanWithScope == null) {\n+          return;\n+        }", "originalCommit": "83518e8440bca855149a54aa046dd05c648dcee3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e4f219ae4fb3f768c50946e24a93da44e7a2abd2", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/e4f219ae4fb3f768c50946e24a93da44e7a2abd2", "message": "Addressed code review comments", "committedDate": "2020-03-10T00:40:31Z", "type": "commit"}, {"oid": "30038101c9dd26d8c236f6a5f0fea030533447fa", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/30038101c9dd26d8c236f6a5f0fea030533447fa", "message": "Added back advice classes to helpers", "committedDate": "2020-03-10T00:53:52Z", "type": "commit"}, {"oid": "301e2aea37865eb4f523c2bac930e745f22a0673", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/301e2aea37865eb4f523c2bac930e745f22a0673", "message": "Fixed muzzle without listing advice classes as helpers", "committedDate": "2020-03-10T14:40:28Z", "type": "commit"}, {"oid": "de31ad852c945f6bfc42ef4ed3a231299e788da6", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/de31ad852c945f6bfc42ef4ed3a231299e788da6", "message": "Merge branch 'master' into prydin-geode", "committedDate": "2020-03-10T16:45:27Z", "type": "commit"}, {"oid": "7abbcbafabeea57654b12f5c82a151eb0f154b98", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/7abbcbafabeea57654b12f5c82a151eb0f154b98", "message": "Update instrumentation/geode-1.4/geode-1.4.gradle", "committedDate": "2020-03-10T17:50:33Z", "type": "commit"}]}