{"pr_number": 1168, "pr_title": "Properly track causality of kotlin suspend functions", "pr_createdAt": "2020-09-03T16:11:59Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168", "timeline": [{"oid": "d3f3bff91e59adbe3499f5d54bfa118132e4b69a", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/d3f3bff91e59adbe3499f5d54bfa118132e4b69a", "message": "Initial work on kotlin suspend functions.\n\nIntroduce new instrumentation to capture kotlin suspended coroutines\nand track/update Context appropriately.  Add high-concurrency test\nshowing the issue and that it is solved.", "committedDate": "2020-09-03T16:04:06Z", "type": "commit"}, {"oid": "4e79e539cd0aec0003ab984267bcf15b04df9efd", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/4e79e539cd0aec0003ab984267bcf15b04df9efd", "message": "spotlessApply", "committedDate": "2020-09-03T16:07:10Z", "type": "commit"}, {"oid": "79f4b99af966340d18dfa2836dd4521ee5c33fc9", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/79f4b99af966340d18dfa2836dd4521ee5c33fc9", "message": "Fix spelling of continuation.", "committedDate": "2020-09-03T16:08:54Z", "type": "commit"}, {"oid": "db0a92514191069119bc380a788165909a4b4c97", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/db0a92514191069119bc380a788165909a4b4c97", "message": "Fix kotlin style", "committedDate": "2020-09-03T18:07:12Z", "type": "commit"}, {"oid": "b72f3459df4043e11677a0c8f280e2ffdabaab20", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/b72f3459df4043e11677a0c8f280e2ffdabaab20", "message": "Add kotlin dependencies to muzzle", "committedDate": "2020-09-03T19:43:33Z", "type": "commit"}, {"oid": "d9211b9b333dc599159d072737acd37a1201a3ea", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/d9211b9b333dc599159d072737acd37a1201a3ea", "message": "Fix muzzle in another package that pulls in java-concurrent.", "committedDate": "2020-09-03T23:10:55Z", "type": "commit"}, {"oid": "7aae4c4cfe714961f27d62287bbb9134921f51e3", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/7aae4c4cfe714961f27d62287bbb9134921f51e3", "message": "Use runBlocking instead of a sleep to finish test", "committedDate": "2020-09-03T23:30:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyNTEyMw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r483425123", "bodyText": "Could you add a bit more about why exactly it gets lost? Is it because with low concurrency, suspend functions are effectively executed in order on a single thread?", "author": "anuraaga", "createdAt": "2020-09-04T06:57:41Z", "path": "instrumentation/java-concurrent/src/main/java/io/opentelemetry/instrumentation/auto/javaconcurrent/KotlinProbeInstrumentation.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.javaconcurrent;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.util.HashMap;\n+import java.util.Map;\n+import kotlin.coroutines.Continuation;\n+import kotlin.coroutines.CoroutineContext;\n+import kotlin.jvm.functions.Function2;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+@AutoService(Instrumenter.class)\n+public class KotlinProbeInstrumentation extends Instrumenter.Default {\n+  /*\n+  Kotlin coroutines with suspend functions are a form of cooperative \"userland\" threading\n+  (you might also know this pattern as \"fibers\" or \"green threading\", where the OS/kernel-level thread\n+  has no idea of switching between tasks.  Fortunately kotlin exposes hooks for the key events: knowing when\n+  coroutines are being created, when they are suspended (swapped out/inactive), and when they are resumed (about to\n+  run again).\n+\n+  Without this instrumentation, heavy concurrency and usage of kotlin suspend functions will break causality", "originalCommit": "7aae4c4cfe714961f27d62287bbb9134921f51e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY0Mjg3OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r483642879", "bodyText": "Will do.", "author": "johnbley", "createdAt": "2020-09-04T14:15:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyNTEyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyNTI1Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r483425257", "bodyText": "I think the above context is great for this class, this one we can just keep in PR comments :)", "author": "anuraaga", "createdAt": "2020-09-04T06:58:00Z", "path": "instrumentation/java-concurrent/src/main/java/io/opentelemetry/instrumentation/auto/javaconcurrent/KotlinProbeInstrumentation.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.javaconcurrent;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.util.HashMap;\n+import java.util.Map;\n+import kotlin.coroutines.Continuation;\n+import kotlin.coroutines.CoroutineContext;\n+import kotlin.jvm.functions.Function2;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+@AutoService(Instrumenter.class)\n+public class KotlinProbeInstrumentation extends Instrumenter.Default {\n+  /*\n+  Kotlin coroutines with suspend functions are a form of cooperative \"userland\" threading\n+  (you might also know this pattern as \"fibers\" or \"green threading\", where the OS/kernel-level thread\n+  has no idea of switching between tasks.  Fortunately kotlin exposes hooks for the key events: knowing when\n+  coroutines are being created, when they are suspended (swapped out/inactive), and when they are resumed (about to\n+  run again).\n+\n+  Without this instrumentation, heavy concurrency and usage of kotlin suspend functions will break causality\n+  and cause nonsensical span parents/context propagation.\n+\n+  The basic strategy here is:\n+  1) Use the DebugProbes callbacks to learn about coroutine create, resume, and suspend operations\n+  2) Wrap the creation Coroutine and its Context and use that wrapping to add an extra Context \"key\"\n+  3) Use the callback for resume and suspend to manipulate our context \"key\" whereby an appropriate state\n+     object can be found (tied to the chain of Continutations in the Coroutine).\n+  4) Do our swapping-context dance with that appropriate state\n+  5) Test with highly concurrent well-known span causality and ensure everything looks right.\n+     Without this instrumentation, this test fails with concurrency=2; with this instrumentation,\n+     it passes with concurrency=200.\n+\n+  I've run the basic shape of this by an expert in kotlin coroutines (Roman Elizarov) and he agreed that the", "originalCommit": "7aae4c4cfe714961f27d62287bbb9134921f51e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY0MzAzMg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r483643032", "bodyText": "\ud83d\udc4d", "author": "johnbley", "createdAt": "2020-09-04T14:15:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyNTI1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyNjE3Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r483426177", "bodyText": "I think it'd make sense for us to rename kotlin-testing to kotlin-coroutines and add this instrumentation there too since this isn't instrumenting the JDK itself. It removes that corner case of muzzle you found too I believe.", "author": "anuraaga", "createdAt": "2020-09-04T07:00:09Z", "path": "instrumentation/java-concurrent/src/main/java/io/opentelemetry/instrumentation/auto/javaconcurrent/KotlinProbeInstrumentation.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.javaconcurrent;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.util.HashMap;\n+import java.util.Map;\n+import kotlin.coroutines.Continuation;\n+import kotlin.coroutines.CoroutineContext;\n+import kotlin.jvm.functions.Function2;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+@AutoService(Instrumenter.class)\n+public class KotlinProbeInstrumentation extends Instrumenter.Default {", "originalCommit": "7aae4c4cfe714961f27d62287bbb9134921f51e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY0NDMxNg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r483644316", "bodyText": "Are you proposing to move this instrumentation and test to a new <root>/instrumentation/kotlin-coroutines module?  That makes sense to me.  Please confirm my understanding and I'll work on that refactoring.", "author": "johnbley", "createdAt": "2020-09-04T14:17:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyNjE3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY0OTQzOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r483649439", "bodyText": "Yup that's what I'm thinking", "author": "anuraaga", "createdAt": "2020-09-04T14:26:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyNjE3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY1MDEwNg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r483650106", "bodyText": "OK, I'll work on that today.  Thanks!", "author": "johnbley", "createdAt": "2020-09-04T14:27:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyNjE3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyNzU4Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r483427587", "bodyText": "Is it possible to use ThreadContextElement instead of hooking into the lifecycle ourselves? If not, can we add some docs on why that doesn't work? I haven't used kotlin much TBH, but my understanding is that's the standard way of syncing a threadlocal with coroutines, which is what we want to achieve here.\nhttps://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-thread-context-element/", "author": "anuraaga", "createdAt": "2020-09-04T07:03:33Z", "path": "instrumentation/java-concurrent/src/main/java/io/opentelemetry/instrumentation/auto/javaconcurrent/KotlinProbeInstrumentation.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.javaconcurrent;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.util.HashMap;\n+import java.util.Map;\n+import kotlin.coroutines.Continuation;\n+import kotlin.coroutines.CoroutineContext;\n+import kotlin.jvm.functions.Function2;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+@AutoService(Instrumenter.class)\n+public class KotlinProbeInstrumentation extends Instrumenter.Default {\n+  /*\n+  Kotlin coroutines with suspend functions are a form of cooperative \"userland\" threading\n+  (you might also know this pattern as \"fibers\" or \"green threading\", where the OS/kernel-level thread\n+  has no idea of switching between tasks.  Fortunately kotlin exposes hooks for the key events: knowing when\n+  coroutines are being created, when they are suspended (swapped out/inactive), and when they are resumed (about to\n+  run again).\n+\n+  Without this instrumentation, heavy concurrency and usage of kotlin suspend functions will break causality\n+  and cause nonsensical span parents/context propagation.\n+\n+  The basic strategy here is:\n+  1) Use the DebugProbes callbacks to learn about coroutine create, resume, and suspend operations\n+  2) Wrap the creation Coroutine and its Context and use that wrapping to add an extra Context \"key\"\n+  3) Use the callback for resume and suspend to manipulate our context \"key\" whereby an appropriate state\n+     object can be found (tied to the chain of Continutations in the Coroutine).\n+  4) Do our swapping-context dance with that appropriate state\n+  5) Test with highly concurrent well-known span causality and ensure everything looks right.\n+     Without this instrumentation, this test fails with concurrency=2; with this instrumentation,\n+     it passes with concurrency=200.\n+\n+  I've run the basic shape of this by an expert in kotlin coroutines (Roman Elizarov) and he agreed that the\n+  overhead should be fine for production usage.\n+  */\n+\n+  public KotlinProbeInstrumentation() {\n+    super(\"kotlin-coroutines\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"kotlin.coroutines.jvm.internal.DebugProbesKt\");\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        named(\"probeCoroutineCreated\").and(takesArguments(1)),\n+        CoroutineCreatedAdvice.class.getName());\n+    transformers.put(\n+        named(\"probeCoroutineResumed\").and(takesArguments(1)),\n+        CoroutineResumedAdvice.class.getName());\n+    transformers.put(\n+        named(\"probeCoroutineSuspended\").and(takesArguments(1)),\n+        CoroutineSuspendedAdvice.class.getName());\n+    return transformers;\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      \"io.opentelemetry.instrumentation.auto.javaconcurrent.KotlinProbeInstrumentation$CoroutineWrapper\",\n+      \"io.opentelemetry.instrumentation.auto.javaconcurrent.KotlinProbeInstrumentation$TraceScopeKey\",\n+      \"io.opentelemetry.instrumentation.auto.javaconcurrent.KotlinProbeInstrumentation$CoroutineContextWrapper\",\n+    };\n+  }\n+\n+  public static class CoroutineCreatedAdvice {\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void exit(\n+        @Advice.Return(readOnly = false) kotlin.coroutines.Continuation retVal) {\n+      if (!(retVal instanceof CoroutineWrapper)) {\n+        retVal = new CoroutineWrapper(retVal);\n+      }\n+    }\n+  }\n+\n+  public static class CoroutineResumedAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void enter(\n+        @Advice.Argument(0) final kotlin.coroutines.Continuation continuation) {\n+      continuation.getContext().get(TraceScopeKey.INSTANCE);\n+    }\n+  }\n+\n+  public static class CoroutineSuspendedAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void enter(\n+        @Advice.Argument(0) final kotlin.coroutines.Continuation continuation) {\n+      continuation.getContext().minusKey(TraceScopeKey.INSTANCE);\n+    }\n+  }\n+\n+  public static class TraceScopeKey implements CoroutineContext.Key {\n+    public static final TraceScopeKey INSTANCE = new TraceScopeKey();\n+  }\n+\n+  public static class CoroutineWrapper implements kotlin.coroutines.Continuation {\n+    private final Continuation proxy;\n+    private final CoroutineContextWrapper contextWrapper;\n+\n+    public CoroutineWrapper(Continuation proxy) {\n+      this.proxy = proxy;\n+      this.contextWrapper = new CoroutineContextWrapper(proxy.getContext());\n+    }\n+\n+    public String toString() {\n+      return proxy.toString();\n+    }\n+\n+    @NotNull\n+    @Override\n+    public CoroutineContext getContext() {\n+      return contextWrapper;\n+    }\n+\n+    @Override\n+    public void resumeWith(@NotNull Object o) {\n+      proxy.resumeWith(o);\n+    }\n+  }\n+\n+  public static class CoroutineContextWrapper implements CoroutineContext {", "originalCommit": "7aae4c4cfe714961f27d62287bbb9134921f51e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyODQ1Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r483428453", "bodyText": "Also, just brainstorming, but is there an approach that wraps dispatchers using something like https://grpc.github.io/grpc-java/javadoc/io/grpc/Context.html#currentContextExecutor-java.util.concurrent.Executor- ? I have no idea the pros/cons for kotlin :) But in Java, my goto for context propagation is usually a wrapped Executor so it just came to mind. I've used this approach in some of the only kotlin I've ever written outside of build scripts.", "author": "anuraaga", "createdAt": "2020-09-04T07:05:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyNzU4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY0NzIzNw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r483647237", "bodyText": "So, yes, I have experimented with more \"public\" ways of doing this.  I had a version with the ThreadContextElement approach and it passed the tests, but it exposes the attached CoroutineContext in a way that is visible (and modifiable) to the app (in addition to being a bit more awkward to implement owing to the larger implementation surface of CoroutineContext.Element and writing this in Java rather than Kotlin).  I got worried about app code clearing or resetting context and accidentally dropping our bits.  I am not a Kotlin expert at all though, so perhaps there's a cleaner/more elegant way to use the ThreadContextElement approach that I'm not seeing.", "author": "johnbley", "createdAt": "2020-09-04T14:22:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyNzU4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY1MjczOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r483652739", "bodyText": "FWIW, if it helps, I don't see a reason to avoid writing the instrumentation in kotlin for kotlin if it helps - main overhead of kotlin is usually the size of the runtime which is no an issue when the instrumentation already requires it.\nBut given it seems we can expect relative stability from the debug probes API, I wouldn't worry too much either, it's a point in case anything was obvious. We can always investigate more if something breaks in the future instead of now.", "author": "anuraaga", "createdAt": "2020-09-04T14:32:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyNzU4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyOTg2OA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r483429868", "bodyText": "Just to confirm, I guess there's no public entrypoint that is similar to this one? For example, we won't have any breakage across kotlin version if we can stick to public APIs than internal ones. One API that comes to mind is startCoroutine\nhttps://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/start-coroutine.html\nPerhaps my other suggestions can bring to light an idea that can keep interception to the public API. But if not, it's ok too we have other instrumentation reliant on private APIs and use muzzle to bite us when something breaks.", "author": "anuraaga", "createdAt": "2020-09-04T07:08:48Z", "path": "instrumentation/java-concurrent/src/main/java/io/opentelemetry/instrumentation/auto/javaconcurrent/KotlinProbeInstrumentation.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.javaconcurrent;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.util.HashMap;\n+import java.util.Map;\n+import kotlin.coroutines.Continuation;\n+import kotlin.coroutines.CoroutineContext;\n+import kotlin.jvm.functions.Function2;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+@AutoService(Instrumenter.class)\n+public class KotlinProbeInstrumentation extends Instrumenter.Default {\n+  /*\n+  Kotlin coroutines with suspend functions are a form of cooperative \"userland\" threading\n+  (you might also know this pattern as \"fibers\" or \"green threading\", where the OS/kernel-level thread\n+  has no idea of switching between tasks.  Fortunately kotlin exposes hooks for the key events: knowing when\n+  coroutines are being created, when they are suspended (swapped out/inactive), and when they are resumed (about to\n+  run again).\n+\n+  Without this instrumentation, heavy concurrency and usage of kotlin suspend functions will break causality\n+  and cause nonsensical span parents/context propagation.\n+\n+  The basic strategy here is:\n+  1) Use the DebugProbes callbacks to learn about coroutine create, resume, and suspend operations\n+  2) Wrap the creation Coroutine and its Context and use that wrapping to add an extra Context \"key\"\n+  3) Use the callback for resume and suspend to manipulate our context \"key\" whereby an appropriate state\n+     object can be found (tied to the chain of Continutations in the Coroutine).\n+  4) Do our swapping-context dance with that appropriate state\n+  5) Test with highly concurrent well-known span causality and ensure everything looks right.\n+     Without this instrumentation, this test fails with concurrency=2; with this instrumentation,\n+     it passes with concurrency=200.\n+\n+  I've run the basic shape of this by an expert in kotlin coroutines (Roman Elizarov) and he agreed that the\n+  overhead should be fine for production usage.\n+  */\n+\n+  public KotlinProbeInstrumentation() {\n+    super(\"kotlin-coroutines\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"kotlin.coroutines.jvm.internal.DebugProbesKt\");", "originalCommit": "7aae4c4cfe714961f27d62287bbb9134921f51e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY0ODU5Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r483648597", "bodyText": "You raise some good points.  Yes, we're helped by muzzle here.  We're also helped in that kotlin has a debugging extension using this code (hence the name DebugProbes) for tracking coroutine causality, and that their implementation also uses bytecode instrumentation to swap in the debugging version.  Because of the friction introduced by that design, it's unlikely that they'll change this interface frequently \ud83d\ude04", "author": "johnbley", "createdAt": "2020-09-04T14:25:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyOTg2OA=="}], "type": "inlineReview"}, {"oid": "41d9f17beee5f100821da791ceee1631e17e4fce", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/41d9f17beee5f100821da791ceee1631e17e4fce", "message": "Clarify and improve comments on how/why", "committedDate": "2020-09-04T14:25:53Z", "type": "commit"}, {"oid": "9b8346dc04e3b8d9070aa57b066b396b1a772bc4", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/9b8346dc04e3b8d9070aa57b066b396b1a772bc4", "message": "Move kotlin coroutines instrumentation to top-level instrumentation module", "committedDate": "2020-09-04T15:06:59Z", "type": "commit"}, {"oid": "94ba53a9c376753f91edb7f4bfeff0051619b3e8", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/94ba53a9c376753f91edb7f4bfeff0051619b3e8", "message": "Properly build muzzle check for kotlin-coroutines", "committedDate": "2020-09-07T18:24:56Z", "type": "commit"}, {"oid": "96a2b59f33f904cca47dec3382ce15a498431476", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/96a2b59f33f904cca47dec3382ce15a498431476", "message": "Merge kotlin-testing into regular src/test rather than separate module", "committedDate": "2020-09-07T18:31:04Z", "type": "commit"}, {"oid": "81f76506e7b31957e25a22ad6cd723fd373470f6", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/81f76506e7b31957e25a22ad6cd723fd373470f6", "message": "Clean up attach/detach logic", "committedDate": "2020-09-07T18:49:00Z", "type": "commit"}, {"oid": "0b9c1ea6b96204892332d3a88836e26bd70c581c", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/0b9c1ea6b96204892332d3a88836e26bd70c581c", "message": "Tighten bounds and skipVersions on kotlin muzzle", "committedDate": "2020-09-07T20:29:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY4MjE5Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r484682193", "bodyText": "As there are a lot of contexts flying around here, I think it would decrease confusion, if these names somehow referenced \"tracing\" or similar context. To distinguish them from coroutine context.", "author": "iNikem", "createdAt": "2020-09-08T06:36:25Z", "path": "instrumentation/kotlin-coroutines/src/main/java/io/opentelemetry/instrumentation/auto/kotlincoroutines/KotlinProbeInstrumentation.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.kotlincoroutines;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.util.HashMap;\n+import java.util.Map;\n+import kotlin.coroutines.Continuation;\n+import kotlin.coroutines.CoroutineContext;\n+import kotlin.jvm.functions.Function2;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+@AutoService(Instrumenter.class)\n+public class KotlinProbeInstrumentation extends Instrumenter.Default {\n+  /*\n+  Kotlin coroutines with suspend functions are a form of cooperative \"userland\" threading\n+  (you might also know this pattern as \"fibers\" or \"green threading\", where the OS/kernel-level thread\n+  has no idea of switching between tasks.  Fortunately kotlin exposes hooks for the key events: knowing when\n+  coroutines are being created, when they are suspended (swapped out/inactive), and when they are resumed (about to\n+  run again).\n+\n+  Without this instrumentation, heavy concurrency and usage of kotlin suspend functions will break causality\n+  and cause nonsensical span parents/context propagation.  This is because a single JVM thread will run a series of\n+  coroutines in an \"arbitrary\" order, and a context set by coroutine A (which then gets suspended) will be picked up\n+  by completely-unrelated coroutine B.\n+\n+  The basic strategy here is:\n+  1) Use the DebugProbes callbacks to learn about coroutine create, resume, and suspend operations\n+  2) Wrap the creation Coroutine and its Context and use that wrapping to add an extra Context \"key\"\n+  3) Use the callback for resume and suspend to manipulate our context \"key\" whereby an appropriate state\n+     object can be found (tied to the chain of Continutations in the Coroutine).\n+  4) Do our swapping-context dance with that appropriate state\n+  5) Test with highly concurrent well-known span causality and ensure everything looks right.\n+     Without this instrumentation, this test fails with concurrency=2; with this instrumentation,\n+     it passes with concurrency=200.\n+  */\n+\n+  public KotlinProbeInstrumentation() {\n+    super(\"kotlin-coroutines\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"kotlin.coroutines.jvm.internal.DebugProbesKt\");\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        named(\"probeCoroutineCreated\").and(takesArguments(1)),\n+        CoroutineCreatedAdvice.class.getName());\n+    transformers.put(\n+        named(\"probeCoroutineResumed\").and(takesArguments(1)),\n+        CoroutineResumedAdvice.class.getName());\n+    transformers.put(\n+        named(\"probeCoroutineSuspended\").and(takesArguments(1)),\n+        CoroutineSuspendedAdvice.class.getName());\n+    return transformers;\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      \"io.opentelemetry.instrumentation.auto.kotlincoroutines.KotlinProbeInstrumentation$CoroutineWrapper\",\n+      \"io.opentelemetry.instrumentation.auto.kotlincoroutines.KotlinProbeInstrumentation$TraceScopeKey\",\n+      \"io.opentelemetry.instrumentation.auto.kotlincoroutines.KotlinProbeInstrumentation$CoroutineContextWrapper\",\n+    };\n+  }\n+\n+  public static class CoroutineCreatedAdvice {\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void exit(\n+        @Advice.Return(readOnly = false) kotlin.coroutines.Continuation retVal) {\n+      if (!(retVal instanceof CoroutineWrapper)) {\n+        retVal = new CoroutineWrapper(retVal);\n+      }\n+    }\n+  }\n+\n+  public static class CoroutineResumedAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void enter(\n+        @Advice.Argument(0) final kotlin.coroutines.Continuation continuation) {\n+      continuation.getContext().get(TraceScopeKey.INSTANCE);\n+    }\n+  }\n+\n+  public static class CoroutineSuspendedAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void enter(\n+        @Advice.Argument(0) final kotlin.coroutines.Continuation continuation) {\n+      continuation.getContext().minusKey(TraceScopeKey.INSTANCE);\n+    }\n+  }\n+\n+  public static class TraceScopeKey implements CoroutineContext.Key {\n+    public static final TraceScopeKey INSTANCE = new TraceScopeKey();\n+  }\n+\n+  public static class CoroutineWrapper implements kotlin.coroutines.Continuation {\n+    private final Continuation proxy;\n+    private final CoroutineContextWrapper contextWrapper;\n+\n+    public CoroutineWrapper(Continuation proxy) {\n+      this.proxy = proxy;\n+      this.contextWrapper = new CoroutineContextWrapper(proxy.getContext());\n+    }\n+\n+    public String toString() {\n+      return proxy.toString();\n+    }\n+\n+    @NotNull\n+    @Override\n+    public CoroutineContext getContext() {\n+      return contextWrapper;\n+    }\n+\n+    @Override\n+    public void resumeWith(@NotNull Object o) {\n+      proxy.resumeWith(o);\n+    }\n+  }\n+\n+  public static class CoroutineContextWrapper implements CoroutineContext {\n+    private final CoroutineContext proxy;\n+    private Context myContext;\n+    private Context prevContext;", "originalCommit": "0b9c1ea6b96204892332d3a88836e26bd70c581c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY4MzA4Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r484683087", "bodyText": "Reading javadoc for io.grpc.Context#attach, I think you better doing myContext.detach(prevContext) here. Otherwise you just piling contexts on top of each other...", "author": "iNikem", "createdAt": "2020-09-08T06:38:43Z", "path": "instrumentation/kotlin-coroutines/src/main/java/io/opentelemetry/instrumentation/auto/kotlincoroutines/KotlinProbeInstrumentation.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.kotlincoroutines;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.util.HashMap;\n+import java.util.Map;\n+import kotlin.coroutines.Continuation;\n+import kotlin.coroutines.CoroutineContext;\n+import kotlin.jvm.functions.Function2;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+@AutoService(Instrumenter.class)\n+public class KotlinProbeInstrumentation extends Instrumenter.Default {\n+  /*\n+  Kotlin coroutines with suspend functions are a form of cooperative \"userland\" threading\n+  (you might also know this pattern as \"fibers\" or \"green threading\", where the OS/kernel-level thread\n+  has no idea of switching between tasks.  Fortunately kotlin exposes hooks for the key events: knowing when\n+  coroutines are being created, when they are suspended (swapped out/inactive), and when they are resumed (about to\n+  run again).\n+\n+  Without this instrumentation, heavy concurrency and usage of kotlin suspend functions will break causality\n+  and cause nonsensical span parents/context propagation.  This is because a single JVM thread will run a series of\n+  coroutines in an \"arbitrary\" order, and a context set by coroutine A (which then gets suspended) will be picked up\n+  by completely-unrelated coroutine B.\n+\n+  The basic strategy here is:\n+  1) Use the DebugProbes callbacks to learn about coroutine create, resume, and suspend operations\n+  2) Wrap the creation Coroutine and its Context and use that wrapping to add an extra Context \"key\"\n+  3) Use the callback for resume and suspend to manipulate our context \"key\" whereby an appropriate state\n+     object can be found (tied to the chain of Continutations in the Coroutine).\n+  4) Do our swapping-context dance with that appropriate state\n+  5) Test with highly concurrent well-known span causality and ensure everything looks right.\n+     Without this instrumentation, this test fails with concurrency=2; with this instrumentation,\n+     it passes with concurrency=200.\n+  */\n+\n+  public KotlinProbeInstrumentation() {\n+    super(\"kotlin-coroutines\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"kotlin.coroutines.jvm.internal.DebugProbesKt\");\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        named(\"probeCoroutineCreated\").and(takesArguments(1)),\n+        CoroutineCreatedAdvice.class.getName());\n+    transformers.put(\n+        named(\"probeCoroutineResumed\").and(takesArguments(1)),\n+        CoroutineResumedAdvice.class.getName());\n+    transformers.put(\n+        named(\"probeCoroutineSuspended\").and(takesArguments(1)),\n+        CoroutineSuspendedAdvice.class.getName());\n+    return transformers;\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      \"io.opentelemetry.instrumentation.auto.kotlincoroutines.KotlinProbeInstrumentation$CoroutineWrapper\",\n+      \"io.opentelemetry.instrumentation.auto.kotlincoroutines.KotlinProbeInstrumentation$TraceScopeKey\",\n+      \"io.opentelemetry.instrumentation.auto.kotlincoroutines.KotlinProbeInstrumentation$CoroutineContextWrapper\",\n+    };\n+  }\n+\n+  public static class CoroutineCreatedAdvice {\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void exit(\n+        @Advice.Return(readOnly = false) kotlin.coroutines.Continuation retVal) {\n+      if (!(retVal instanceof CoroutineWrapper)) {\n+        retVal = new CoroutineWrapper(retVal);\n+      }\n+    }\n+  }\n+\n+  public static class CoroutineResumedAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void enter(\n+        @Advice.Argument(0) final kotlin.coroutines.Continuation continuation) {\n+      continuation.getContext().get(TraceScopeKey.INSTANCE);\n+    }\n+  }\n+\n+  public static class CoroutineSuspendedAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void enter(\n+        @Advice.Argument(0) final kotlin.coroutines.Continuation continuation) {\n+      continuation.getContext().minusKey(TraceScopeKey.INSTANCE);\n+    }\n+  }\n+\n+  public static class TraceScopeKey implements CoroutineContext.Key {\n+    public static final TraceScopeKey INSTANCE = new TraceScopeKey();\n+  }\n+\n+  public static class CoroutineWrapper implements kotlin.coroutines.Continuation {\n+    private final Continuation proxy;\n+    private final CoroutineContextWrapper contextWrapper;\n+\n+    public CoroutineWrapper(Continuation proxy) {\n+      this.proxy = proxy;\n+      this.contextWrapper = new CoroutineContextWrapper(proxy.getContext());\n+    }\n+\n+    public String toString() {\n+      return proxy.toString();\n+    }\n+\n+    @NotNull\n+    @Override\n+    public CoroutineContext getContext() {\n+      return contextWrapper;\n+    }\n+\n+    @Override\n+    public void resumeWith(@NotNull Object o) {\n+      proxy.resumeWith(o);\n+    }\n+  }\n+\n+  public static class CoroutineContextWrapper implements CoroutineContext {\n+    private final CoroutineContext proxy;\n+    private Context myContext;\n+    private Context prevContext;\n+\n+    public CoroutineContextWrapper(CoroutineContext proxy) {\n+      this.proxy = proxy;\n+      this.myContext = Context.current();\n+    }\n+\n+    @Override\n+    public <R> R fold(R r, @NotNull Function2<? super R, ? super Element, ? extends R> function2) {\n+      return proxy.fold(r, function2);\n+    }\n+\n+    @Nullable\n+    @Override\n+    public <E extends Element> E get(@NotNull Key<E> key) {\n+      if (key == TraceScopeKey.INSTANCE) {\n+        prevContext = myContext.attach();\n+      }\n+      return proxy.get(key);\n+    }\n+\n+    @NotNull\n+    @Override\n+    public CoroutineContext minusKey(@NotNull Key<?> key) {\n+      if (key == TraceScopeKey.INSTANCE) {\n+        myContext = prevContext.attach();", "originalCommit": "0b9c1ea6b96204892332d3a88836e26bd70c581c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY4NDI3MA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r484684270", "bodyText": "Are you sure that get with side effect is a good idea? CoroutineResumedAdvice.enter looks strange as well, when you get a value and then ignore it. May be you can extract context manipulation from get and minusKey and do that directly in advice methods?", "author": "iNikem", "createdAt": "2020-09-08T06:41:33Z", "path": "instrumentation/kotlin-coroutines/src/main/java/io/opentelemetry/instrumentation/auto/kotlincoroutines/KotlinProbeInstrumentation.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.kotlincoroutines;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.grpc.Context;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.util.HashMap;\n+import java.util.Map;\n+import kotlin.coroutines.Continuation;\n+import kotlin.coroutines.CoroutineContext;\n+import kotlin.jvm.functions.Function2;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+@AutoService(Instrumenter.class)\n+public class KotlinProbeInstrumentation extends Instrumenter.Default {\n+  /*\n+  Kotlin coroutines with suspend functions are a form of cooperative \"userland\" threading\n+  (you might also know this pattern as \"fibers\" or \"green threading\", where the OS/kernel-level thread\n+  has no idea of switching between tasks.  Fortunately kotlin exposes hooks for the key events: knowing when\n+  coroutines are being created, when they are suspended (swapped out/inactive), and when they are resumed (about to\n+  run again).\n+\n+  Without this instrumentation, heavy concurrency and usage of kotlin suspend functions will break causality\n+  and cause nonsensical span parents/context propagation.  This is because a single JVM thread will run a series of\n+  coroutines in an \"arbitrary\" order, and a context set by coroutine A (which then gets suspended) will be picked up\n+  by completely-unrelated coroutine B.\n+\n+  The basic strategy here is:\n+  1) Use the DebugProbes callbacks to learn about coroutine create, resume, and suspend operations\n+  2) Wrap the creation Coroutine and its Context and use that wrapping to add an extra Context \"key\"\n+  3) Use the callback for resume and suspend to manipulate our context \"key\" whereby an appropriate state\n+     object can be found (tied to the chain of Continutations in the Coroutine).\n+  4) Do our swapping-context dance with that appropriate state\n+  5) Test with highly concurrent well-known span causality and ensure everything looks right.\n+     Without this instrumentation, this test fails with concurrency=2; with this instrumentation,\n+     it passes with concurrency=200.\n+  */\n+\n+  public KotlinProbeInstrumentation() {\n+    super(\"kotlin-coroutines\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return named(\"kotlin.coroutines.jvm.internal.DebugProbesKt\");\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        named(\"probeCoroutineCreated\").and(takesArguments(1)),\n+        CoroutineCreatedAdvice.class.getName());\n+    transformers.put(\n+        named(\"probeCoroutineResumed\").and(takesArguments(1)),\n+        CoroutineResumedAdvice.class.getName());\n+    transformers.put(\n+        named(\"probeCoroutineSuspended\").and(takesArguments(1)),\n+        CoroutineSuspendedAdvice.class.getName());\n+    return transformers;\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      \"io.opentelemetry.instrumentation.auto.kotlincoroutines.KotlinProbeInstrumentation$CoroutineWrapper\",\n+      \"io.opentelemetry.instrumentation.auto.kotlincoroutines.KotlinProbeInstrumentation$TraceScopeKey\",\n+      \"io.opentelemetry.instrumentation.auto.kotlincoroutines.KotlinProbeInstrumentation$CoroutineContextWrapper\",\n+    };\n+  }\n+\n+  public static class CoroutineCreatedAdvice {\n+    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n+    public static void exit(\n+        @Advice.Return(readOnly = false) kotlin.coroutines.Continuation retVal) {\n+      if (!(retVal instanceof CoroutineWrapper)) {\n+        retVal = new CoroutineWrapper(retVal);\n+      }\n+    }\n+  }\n+\n+  public static class CoroutineResumedAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void enter(\n+        @Advice.Argument(0) final kotlin.coroutines.Continuation continuation) {\n+      continuation.getContext().get(TraceScopeKey.INSTANCE);\n+    }\n+  }\n+\n+  public static class CoroutineSuspendedAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void enter(\n+        @Advice.Argument(0) final kotlin.coroutines.Continuation continuation) {\n+      continuation.getContext().minusKey(TraceScopeKey.INSTANCE);\n+    }\n+  }\n+\n+  public static class TraceScopeKey implements CoroutineContext.Key {\n+    public static final TraceScopeKey INSTANCE = new TraceScopeKey();\n+  }\n+\n+  public static class CoroutineWrapper implements kotlin.coroutines.Continuation {\n+    private final Continuation proxy;\n+    private final CoroutineContextWrapper contextWrapper;\n+\n+    public CoroutineWrapper(Continuation proxy) {\n+      this.proxy = proxy;\n+      this.contextWrapper = new CoroutineContextWrapper(proxy.getContext());\n+    }\n+\n+    public String toString() {\n+      return proxy.toString();\n+    }\n+\n+    @NotNull\n+    @Override\n+    public CoroutineContext getContext() {\n+      return contextWrapper;\n+    }\n+\n+    @Override\n+    public void resumeWith(@NotNull Object o) {\n+      proxy.resumeWith(o);\n+    }\n+  }\n+\n+  public static class CoroutineContextWrapper implements CoroutineContext {\n+    private final CoroutineContext proxy;\n+    private Context myContext;\n+    private Context prevContext;\n+\n+    public CoroutineContextWrapper(CoroutineContext proxy) {\n+      this.proxy = proxy;\n+      this.myContext = Context.current();\n+    }\n+\n+    @Override\n+    public <R> R fold(R r, @NotNull Function2<? super R, ? super Element, ? extends R> function2) {\n+      return proxy.fold(r, function2);\n+    }\n+\n+    @Nullable\n+    @Override\n+    public <E extends Element> E get(@NotNull Key<E> key) {\n+      if (key == TraceScopeKey.INSTANCE) {\n+        prevContext = myContext.attach();", "originalCommit": "0b9c1ea6b96204892332d3a88836e26bd70c581c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA0NDg0Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1168#discussion_r485044847", "bodyText": "Good call; I found a cleaner way to do this (get() the context holder as its own value and call tracingSuspend/tracingResume) in a way that keeps the kotlin types happy.", "author": "johnbley", "createdAt": "2020-09-08T16:21:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY4NDI3MA=="}], "type": "inlineReview"}, {"oid": "2c6341880ef31c94f0e7ac6f1c54973419df2afd", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/2c6341880ef31c94f0e7ac6f1c54973419df2afd", "message": "Rename fields and clean up attach logic", "committedDate": "2020-09-08T15:56:08Z", "type": "commit"}, {"oid": "4248e57013ed84e077048d597e9b23de321fa5de", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/4248e57013ed84e077048d597e9b23de321fa5de", "message": "Clean up types/side-effect code", "committedDate": "2020-09-08T16:19:48Z", "type": "commit"}, {"oid": "1a5a803e4e69468bf86534a0aff692f3f002d11c", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/1a5a803e4e69468bf86534a0aff692f3f002d11c", "message": "spotlessApply", "committedDate": "2020-09-08T17:01:58Z", "type": "commit"}, {"oid": "e4e65d795911654c0122d5281435e3f5ad9d4d0d", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/e4e65d795911654c0122d5281435e3f5ad9d4d0d", "message": "Enhance muzzle testing to properly test latest kotlin.\nRequired updating a few kotlin-y things to latest version to properly resolve the jvm\nvariant of their new multiplatform stuff.", "committedDate": "2020-09-08T21:48:45Z", "type": "commit"}]}