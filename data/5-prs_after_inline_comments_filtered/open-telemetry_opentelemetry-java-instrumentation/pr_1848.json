{"pr_number": 1848, "pr_title": "Add ComponentInstaller SPI and use it for OpenTelemetry SDK", "pr_createdAt": "2020-12-08T10:14:31Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1848", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2NDU3Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1848#discussion_r540864572", "bodyText": "Why did you comment this out?", "author": "mateuszrzeszutek", "createdAt": "2020-12-11T10:58:54Z", "path": "javaagent-bootstrap/src/main/java/io/opentelemetry/javaagent/bootstrap/AgentInitializer.java", "diffHunk": "@@ -130,7 +130,7 @@ public String getName() {\n \n     @Override\n     public void execute() {\n-      installAgentTracer();\n+      //      installAgentTracer();", "originalCommit": "4efa47669cd9107a57488b074c6ac7ce1929daaf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "05526cc2afa4af87c8cdc47c9cea4945e36b3886", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/05526cc2afa4af87c8cdc47c9cea4945e36b3886", "message": "remove comment\n\nSigned-off-by: Pavol Loffay <p.loffay@gmail.com>", "committedDate": "2020-12-14T14:41:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc1NjY1Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1848#discussion_r542756652", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * {@link ComponentInstaller} can be used to install to install any implementation providers that\n          \n          \n            \n             * {@link ComponentInstaller} can be used to install any implementation providers that", "author": "trask", "createdAt": "2020-12-14T20:38:26Z", "path": "javaagent-spi/src/main/java/io/opentelemetry/javaagent/spi/ComponentInstaller.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.spi;\n+\n+/**\n+ * {@link ComponentInstaller} can be used to install to install any implementation providers that", "originalCommit": "e00759cae111833b0f13b0023bb9adcaf0ae64ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc1Nzc0NA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1848#discussion_r542757744", "bodyText": "can we do this automatically before calling ComponentInstallers?", "author": "trask", "createdAt": "2020-12-14T20:39:26Z", "path": "javaagent-spi/src/main/java/io/opentelemetry/javaagent/spi/ComponentInstaller.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.spi;\n+\n+/**\n+ * {@link ComponentInstaller} can be used to install to install any implementation providers that\n+ * are used by instrumentations. For instance Java agent uses this to install OpenTelemetry SDK. The\n+ * instrumentation uses shaded OpenTelemetry API that lives in the bootstrap classlaoder and the\n+ * implementation (SDK) is installed via service loader from agent's classloader. This way the\n+ * application does not have a direct access to the OpenTelemetry SDK classes. The same approach can\n+ * be done for other APIs used by custom instrumentations.\n+ *\n+ * <p>Before using service loader set the context classloader to agent's classloader e.g. {@code\n+ * Thread.currentThread().setContextClassLoader(ComponentInstaller.class.getClassLoader())} if the\n+ * component does not accept classloader when loading implementation via service loader.", "originalCommit": "e00759cae111833b0f13b0023bb9adcaf0ae64ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE4NjAwOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1848#discussion_r543186009", "bodyText": "+1", "author": "pavolloffay", "createdAt": "2020-12-15T09:34:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc1Nzc0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc2MjE5Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1848#discussion_r542762193", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Runs before instrumentations are installed to ByteBuddy. Execute only a minimal code because it\n          \n          \n            \n               * agent boostrap sequence and instrumentations should be installed as early as possible.\n          \n          \n            \n               * Runs before instrumentations are installed to ByteBuddy. Execute only a minimal code because any classes loaded before the instrumentations are installed will have to be retransformed, which takes extra time, and more importantly means that fields can't be added to those classes and InstrumentationContext falls back to the less performant Map implementation for those classes.", "author": "trask", "createdAt": "2020-12-14T20:43:41Z", "path": "javaagent-spi/src/main/java/io/opentelemetry/javaagent/spi/ComponentInstaller.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.spi;\n+\n+/**\n+ * {@link ComponentInstaller} can be used to install to install any implementation providers that\n+ * are used by instrumentations. For instance Java agent uses this to install OpenTelemetry SDK. The\n+ * instrumentation uses shaded OpenTelemetry API that lives in the bootstrap classlaoder and the\n+ * implementation (SDK) is installed via service loader from agent's classloader. This way the\n+ * application does not have a direct access to the OpenTelemetry SDK classes. The same approach can\n+ * be done for other APIs used by custom instrumentations.\n+ *\n+ * <p>Before using service loader set the context classloader to agent's classloader e.g. {@code\n+ * Thread.currentThread().setContextClassLoader(ComponentInstaller.class.getClassLoader())} if the\n+ * component does not accept classloader when loading implementation via service loader.\n+ *\n+ * <p>This is a service provider interface that requires implementations to be registered in {@code\n+ * META-INF/services} folder.\n+ */\n+public interface ComponentInstaller {\n+\n+  /**\n+   * Runs before instrumentations are installed to ByteBuddy. Execute only a minimal code because it\n+   * agent boostrap sequence and instrumentations should be installed as early as possible.", "originalCommit": "e00759cae111833b0f13b0023bb9adcaf0ae64ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc3MzYzMA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1848#discussion_r542773630", "bodyText": "I'm not sure this is correct to call installAgentTracer() here, check out the existing callers of installAgentTracer()", "author": "trask", "createdAt": "2020-12-14T20:54:33Z", "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/OpenTelemetryInstaller.java", "diffHunk": "@@ -30,15 +34,47 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-public class TracerInstaller {\n-  private static final Logger log = LoggerFactory.getLogger(TracerInstaller.class);\n+@AutoService(ComponentInstaller.class)\n+public class OpenTelemetryInstaller implements ComponentInstaller {\n+  private static final Logger log = LoggerFactory.getLogger(OpenTelemetryInstaller.class);\n \n   private static final String EXPORTER_JAR_CONFIG = \"otel.exporter.jar\";\n   private static final String EXPORTERS_CONFIG = \"otel.exporter\"; // this name is from spec\n   private static final String PROPAGATORS_CONFIG = \"otel.propagators\"; // this name is from spec\n   private static final String JAVAAGENT_ENABLED_CONFIG = \"otel.javaagent.enabled\";\n   private static final List<String> DEFAULT_EXPORTERS = Collections.singletonList(\"otlp\");\n \n+  @Override\n+  public void beforeByteBuddyAgent() {\n+    ClassLoader savedContextClassLoader = Thread.currentThread().getContextClassLoader();\n+    try {\n+      // calling (shaded) OpenTelemetry.getGlobalTracerProvider() with context class loader set to\n+      // the\n+      // agent class loader, so that SPI finds the agent's (isolated) SDK, and (shaded)\n+      // OpenTelemetry registers it, and then when instrumentation calls (shaded)\n+      // OpenTelemetry.getGlobalTracerProvider() later, they get back the agent's (isolated) SDK\n+      //\n+      // but if we don't trigger this early registration, then if instrumentation is the first to\n+      // call (shaded) OpenTelemetry.getGlobalTracerProvider(), then SPI can't see the agent class\n+      // loader,\n+      // and so (shaded) OpenTelemetry registers the no-op TracerFactory, and it cannot be replaced\n+      // later\n+      Thread.currentThread().setContextClassLoader(OpenTelemetryInstaller.class.getClassLoader());\n+      OpenTelemetry.getGlobalTracerProvider();\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(savedContextClassLoader);\n+    }\n+\n+    OpenTelemetrySdkAccess.internalSetForceFlush(\n+        (timeout, unit) ->\n+            OpenTelemetrySdk.getGlobalTracerManagement().forceFlush().join(timeout, unit));\n+  }\n+\n+  @Override\n+  public void afterByteBuddyAgent() {\n+    installAgentTracer();\n+  }", "originalCommit": "e00759cae111833b0f13b0023bb9adcaf0ae64ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ2ODcyMw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1848#discussion_r543468723", "bodyText": "this should be correct", "author": "pavolloffay", "createdAt": "2020-12-15T15:57:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc3MzYzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc4MTY5OA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1848#discussion_r543781698", "bodyText": "oh i see this is delayed via the callback when needed \ud83d\udc4d", "author": "trask", "createdAt": "2020-12-16T00:15:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc3MzYzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc3OTI5Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1848#discussion_r542779297", "bodyText": "it feels a little odd to use the OpenTelemetryInstaller class as both an SPI interface and as a static entry point here", "author": "trask", "createdAt": "2020-12-14T20:59:41Z", "path": "javaagent-bootstrap/src/main/java/io/opentelemetry/javaagent/bootstrap/AgentInitializer.java", "diffHunk": "@@ -159,7 +159,7 @@ private static synchronized void installAgentTracer() {\n     try {\n       // install global tracer\n       Class<?> tracerInstallerClass =\n-          AGENT_CLASSLOADER.loadClass(\"io.opentelemetry.javaagent.tooling.TracerInstaller\");\n+          AGENT_CLASSLOADER.loadClass(\"io.opentelemetry.javaagent.tooling.OpenTelemetryInstaller\");", "originalCommit": "e00759cae111833b0f13b0023bb9adcaf0ae64ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjgyOTQ3MA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1848#discussion_r542829470", "bodyText": "the PR is not ready yet :)", "author": "pavolloffay", "createdAt": "2020-12-14T21:46:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc3OTI5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIxMTMyMw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1848#discussion_r543211323", "bodyText": "I have updated the PR, this has been removed from the agentInitializer", "author": "pavolloffay", "createdAt": "2020-12-15T10:09:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc3OTI5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA3NTgyNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1848#discussion_r543075825", "bodyText": "Oh we should be able to remove this now since we're on 0.12.0", "author": "anuraaga", "createdAt": "2020-12-15T06:18:18Z", "path": "testing-common/src/main/groovy/io/opentelemetry/instrumentation/test/TestOpenTelemetryInstaller.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.test;\n+\n+import io.opentelemetry.api.OpenTelemetry;\n+import io.opentelemetry.api.trace.TracerProvider;\n+import io.opentelemetry.api.trace.propagation.HttpTraceContext;\n+import io.opentelemetry.context.propagation.ContextPropagators;\n+import io.opentelemetry.context.propagation.DefaultContextPropagators;\n+import io.opentelemetry.javaagent.tooling.OpenTelemetryInstaller;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.sdk.trace.SpanProcessor;\n+import java.lang.reflect.Method;\n+\n+public class TestOpenTelemetryInstaller extends OpenTelemetryInstaller {\n+\n+  private final SpanProcessor spanProcessor;\n+\n+  public TestOpenTelemetryInstaller(SpanProcessor spanProcessor) {\n+    this.spanProcessor = spanProcessor;\n+  }\n+\n+  @Override\n+  public void afterByteBuddyAgent() {\n+    // TODO this is probably temporary until default propagators are supplied by SDK\n+    //  https://github.com/open-telemetry/opentelemetry-java/issues/1742\n+    //  currently checking against no-op implementation so that it won't override aws-lambda\n+    //  propagator configuration\n+    if (OpenTelemetry.getGlobalPropagators()\n+        .getTextMapPropagator()\n+        .getClass()\n+        .getSimpleName()\n+        .equals(\"NoopTextMapPropagator\")) {\n+      // Workaround https://github.com/open-telemetry/opentelemetry-java/pull/2096\n+      setGlobalPropagators(\n+          DefaultContextPropagators.builder()\n+              .addTextMapPropagator(HttpTraceContext.getInstance())\n+              .build());\n+    }\n+    OpenTelemetrySdk.getGlobalTracerManagement().addSpanProcessor(spanProcessor);\n+  }\n+\n+  // Workaround https://github.com/open-telemetry/opentelemetry-java/pull/2096\n+  public static void setGlobalPropagators(ContextPropagators propagators) {", "originalCommit": "e00759cae111833b0f13b0023bb9adcaf0ae64ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIxNDk4Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1848#discussion_r543214982", "bodyText": "I can clean it up in a separate PR", "author": "pavolloffay", "createdAt": "2020-12-15T10:14:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA3NTgyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzkxOTgxMw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1848#discussion_r543919813", "bodyText": "@pavolloffay I'll do this in #1643", "author": "trask", "createdAt": "2020-12-16T04:13:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA3NTgyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQzNTk0OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1848#discussion_r545435949", "bodyText": "@anuraaga did this in #1924 \ud83d\udc4d", "author": "trask", "createdAt": "2020-12-17T22:10:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA3NTgyNQ=="}], "type": "inlineReview"}, {"oid": "8708742a98e3e628379ba4f198f7cdf29ce77498", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/8708742a98e3e628379ba4f198f7cdf29ce77498", "message": "Fix javadocs\n\nSigned-off-by: Pavol Loffay <p.loffay@gmail.com>", "committedDate": "2020-12-15T09:36:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM4NDQ4OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1848#discussion_r543384489", "bodyText": "JMXFetch is a DataDog thing that's no longer present in OTel javaagent, we should consider removing this code in separate issue/PR.", "author": "mateuszrzeszutek", "createdAt": "2020-12-15T14:19:58Z", "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/AgentInstaller.java", "diffHunk": "@@ -160,7 +140,69 @@ public static ResettableClassFileTransformer installBytebuddyAgent(\n \n     agentBuilder = customizeByteBuddyAgent(agentBuilder);\n     log.debug(\"Installed {} instrumenter(s)\", numInstrumenters);\n-    return agentBuilder.installOn(inst);\n+    ResettableClassFileTransformer resettableClassFileTransformer = agentBuilder.installOn(inst);\n+    installComponentsAfterByteBuddy(componentInstallers);\n+    return resettableClassFileTransformer;\n+  }\n+\n+  private static void installComponentsBeforeByteBuddy(\n+      Iterable<ComponentInstaller> componentInstallers) {\n+    ClassLoader savedContextClassLoader = Thread.currentThread().getContextClassLoader();\n+    try {\n+      // calling (shaded) OpenTelemetry.getGlobalTracerProvider() with context class loader set to\n+      // the\n+      // agent class loader, so that SPI finds the agent's (isolated) SDK, and (shaded)\n+      // OpenTelemetry registers it, and then when instrumentation calls (shaded)\n+      // OpenTelemetry.getGlobalTracerProvider() later, they get back the agent's (isolated) SDK\n+      //\n+      // but if we don't trigger this early registration, then if instrumentation is the first to\n+      // call (shaded) OpenTelemetry.getGlobalTracerProvider(), then SPI can't see the agent class\n+      // loader,\n+      // and so (shaded) OpenTelemetry registers the no-op TracerFactory, and it cannot be replaced\n+      // later\n+      Thread.currentThread().setContextClassLoader(AgentInstaller.class.getClassLoader());\n+      for (ComponentInstaller componentInstaller : componentInstallers) {\n+        componentInstaller.beforeByteBuddyAgent();\n+      }\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(savedContextClassLoader);\n+    }\n+  }\n+\n+  private static void installComponentsAfterByteBuddy(\n+      Iterable<ComponentInstaller> componentInstallers) {\n+    /*\n+     * java.util.logging.LogManager maintains a final static LogManager, which is created during class initialization.\n+     *\n+     * JMXFetch uses jre bootstrap classes which touch this class. This means applications which require a custom log\n+     * manager may not have a chance to set the global log manager if jmxfetch runs first. JMXFetch will incorrectly\n+     * set the global log manager in cases where the app sets the log manager system property or when the log manager\n+     * class is not on the system classpath.\n+     *\n+     * Our solution is to delay the initialization of jmxfetch when we detect a custom log manager being used.\n+     *\n+     * Once we see the LogManager class loading, it's safe to start jmxfetch because the application is already setting\n+     * the global log manager and jmxfetch won't be able to touch it due to classloader locking.\n+     */\n+\n+    /*\n+     * Similar thing happens with AgentTracer on (at least) zulu-8 because it uses OkHttp which indirectly loads JFR\n+     * events which in turn loads LogManager. This is not a problem on newer JDKs because there JFR uses different\n+     * logging facility.\n+     */", "originalCommit": "2fa142a682b973497d47debc0a367dafa6361668", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM5NDQ2Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1848#discussion_r543394462", "bodyText": "I can clean it up once merged", "author": "pavolloffay", "createdAt": "2020-12-15T14:29:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM4NDQ4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA3NjAzNw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1848#discussion_r544076037", "bodyText": "Wait, is this delay needed at all now? We don't have JMXFetch, AgentTracer certainly does not use OkHttp. Do we need this?\nAnd if yes, then do we need this delay here, for all components, or just inside OpenTelemetryInstaller?", "author": "iNikem", "createdAt": "2020-12-16T07:38:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM4NDQ4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDgxMTgzOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1848#discussion_r544811839", "bodyText": "I believe we still need the delay if we are using an exporter that uses SSL.\nThis bit me also when 8u231 was released, at the time I was convinced this enhancement was the cause: https://bugs.openjdk.java.net/browse/JDK-8148188\nI think the chain goes like:\nAgent -> SSL -> JFR -> j.u.l.\nand then thankfully in Java 9, JFR doesn't use j.u.l. anymore, which prevents this chain from reaching j.u.l.", "author": "trask", "createdAt": "2020-12-17T04:55:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM4NDQ4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg5Nzc0Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1848#discussion_r544897746", "bodyText": "@pavolloffay @trask  then do we need this delay here, for all components, or just inside OpenTelemetryInstaller?", "author": "iNikem", "createdAt": "2020-12-17T08:26:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM4NDQ4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ0NTIyNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1848#discussion_r545445225", "bodyText": "seems ok to do it for all, so the components themselves don't need to worry about this weirdness", "author": "trask", "createdAt": "2020-12-17T22:29:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM4NDQ4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM4NjQ3OA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1848#discussion_r543386478", "bodyText": "Can you preserve this comment in OpenTelemetryInstaller?", "author": "mateuszrzeszutek", "createdAt": "2020-12-15T14:21:29Z", "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/AgentInstaller.java", "diffHunk": "@@ -81,30 +81,10 @@ public static void installBytebuddyAgent(Instrumentation inst) {\n   public static ResettableClassFileTransformer installBytebuddyAgent(\n       Instrumentation inst,\n       boolean skipAdditionalLibraryMatcher,\n+      Iterable<ComponentInstaller> componentInstallers,\n       AgentBuilder.Listener... listeners) {\n \n-    ClassLoader savedContextClassLoader = Thread.currentThread().getContextClassLoader();\n-    try {\n-      // calling (shaded) OpenTelemetry.getGlobalTracerProvider() with context class loader set to\n-      // the\n-      // agent class loader, so that SPI finds the agent's (isolated) SDK, and (shaded)\n-      // OpenTelemetry registers it, and then when instrumentation calls (shaded)\n-      // OpenTelemetry.getGlobalTracerProvider() later, they get back the agent's (isolated) SDK\n-      //\n-      // but if we don't trigger this early registration, then if instrumentation is the first to\n-      // call (shaded) OpenTelemetry.getGlobalTracerProvider(), then SPI can't see the agent class\n-      // loader,\n-      // and so (shaded) OpenTelemetry registers the no-op TracerFactory, and it cannot be replaced\n-      // later", "originalCommit": "2fa142a682b973497d47debc0a367dafa6361668", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQyNTk1Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1848#discussion_r543425956", "bodyText": "moved", "author": "pavolloffay", "createdAt": "2020-12-15T15:06:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzM4NjQ3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc4MDM2Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1848#discussion_r543780363", "bodyText": "can move this to AgentInstaller also", "author": "trask", "createdAt": "2020-12-16T00:11:59Z", "path": "javaagent-bootstrap/src/main/java/io/opentelemetry/javaagent/bootstrap/AgentInitializer.java", "diffHunk": "@@ -246,57 +143,11 @@ private static boolean isDebugMode() {\n     return false;\n   }\n \n-  /**\n-   * Search for java or agent-tracer sysprops which indicate that a custom log manager will be used.\n-   * Also search for any app classes known to set a custom log manager.\n-   *\n-   * @return true if we detect a custom log manager being used.\n-   */\n-  private static boolean isAppUsingCustomLogManager() {\n-    String tracerCustomLogManSysprop = \"otel.app.customlogmanager\";\n-    String customLogManagerProp = System.getProperty(tracerCustomLogManSysprop);\n-    String customLogManagerEnv =\n-        System.getenv(tracerCustomLogManSysprop.replace('.', '_').toUpperCase());\n-\n-    if (customLogManagerProp != null || customLogManagerEnv != null) {\n-      log.debug(\"Prop - customlogmanager: \" + customLogManagerProp);\n-      log.debug(\"Env - customlogmanager: \" + customLogManagerEnv);\n-      // Allow setting to skip these automatic checks:\n-      return Boolean.parseBoolean(customLogManagerProp)\n-          || Boolean.parseBoolean(customLogManagerEnv);\n-    }\n-\n-    String jbossHome = System.getenv(\"JBOSS_HOME\");\n-    if (jbossHome != null) {\n-      log.debug(\"Env - jboss: \" + jbossHome);\n-      // JBoss/Wildfly is known to set a custom log manager after startup.\n-      // Originally we were checking for the presence of a jboss class,\n-      // but it seems some non-jboss applications have jboss classes on the classpath.\n-      // This would cause jmxfetch initialization to be delayed indefinitely.\n-      // Checking for an environment variable required by jboss instead.\n-      return true;\n-    }\n-\n-    String logManagerProp = System.getProperty(\"java.util.logging.manager\");\n-    if (logManagerProp != null) {\n-      boolean onSysClasspath =\n-          ClassLoader.getSystemResource(logManagerProp.replaceAll(\"\\\\.\", \"/\") + \".class\") != null;\n-      log.debug(\"Prop - logging.manager: \" + logManagerProp);\n-      log.debug(\"logging.manager on system classpath: \" + onSysClasspath);\n-      // Some applications set java.util.logging.manager but never actually initialize the logger.\n-      // Check to see if the configured manager is on the system classpath.\n-      // If so, it should be safe to initialize jmxfetch which will setup the log manager.\n-      return !onSysClasspath;\n-    }\n-\n-    return false;\n-  }\n-\n   private static boolean isJavaBefore9() {\n     return System.getProperty(\"java.version\").startsWith(\"1.\");\n   }\n \n-  private static boolean isJavaBefore9WithJfr() {\n+  public static boolean isJavaBefore9WithJfr() {", "originalCommit": "acac6d24864595c44f906d2e9f8a2e27d7de114d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDAyNzQxNw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1848#discussion_r544027417", "bodyText": "the method uses\nThread.currentThread().getContextClassLoader().getResource(jfrClassResourceName) != null\n\nwhich I guess might be different in the AgentInstaller (agent classloader). Should I change it to the bootstrap claassloader?", "author": "pavolloffay", "createdAt": "2020-12-16T06:33:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc4MDM2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDgwMjM2NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1848#discussion_r544802365", "bodyText": "Thread.currentThread().getContextClassLoader() won't be different since it's based on the current thread and not the current class you are in", "author": "trask", "createdAt": "2020-12-17T04:24:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc4MDM2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTEzMTY1MA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1848#discussion_r545131650", "bodyText": "done", "author": "pavolloffay", "createdAt": "2020-12-17T14:28:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc4MDM2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc4MjU3OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1848#discussion_r543782579", "bodyText": "I think nice to pass the list into InstallComponentsAfterByteBuddyCallback, consolidating into a single callback", "author": "trask", "createdAt": "2020-12-16T00:17:40Z", "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/AgentInstaller.java", "diffHunk": "@@ -160,7 +140,58 @@ public static ResettableClassFileTransformer installBytebuddyAgent(\n \n     agentBuilder = customizeByteBuddyAgent(agentBuilder);\n     log.debug(\"Installed {} instrumenter(s)\", numInstrumenters);\n-    return agentBuilder.installOn(inst);\n+    ResettableClassFileTransformer resettableClassFileTransformer = agentBuilder.installOn(inst);\n+    installComponentsAfterByteBuddy(componentInstallers);\n+    return resettableClassFileTransformer;\n+  }\n+\n+  private static void installComponentsBeforeByteBuddy(\n+      Iterable<ComponentInstaller> componentInstallers) {\n+    ClassLoader savedContextClassLoader = Thread.currentThread().getContextClassLoader();\n+    try {\n+      Thread.currentThread().setContextClassLoader(AgentInstaller.class.getClassLoader());\n+      for (ComponentInstaller componentInstaller : componentInstallers) {\n+        componentInstaller.beforeByteBuddyAgent();\n+      }\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(savedContextClassLoader);\n+    }\n+  }\n+\n+  private static void installComponentsAfterByteBuddy(\n+      Iterable<ComponentInstaller> componentInstallers) {\n+    /*\n+     * java.util.logging.LogManager maintains a final static LogManager, which is created during class initialization.\n+     *\n+     * JMXFetch uses jre bootstrap classes which touch this class. This means applications which require a custom log\n+     * manager may not have a chance to set the global log manager if jmxfetch runs first. JMXFetch will incorrectly\n+     * set the global log manager in cases where the app sets the log manager system property or when the log manager\n+     * class is not on the system classpath.\n+     *\n+     * Our solution is to delay the initialization of jmxfetch when we detect a custom log manager being used.\n+     *\n+     * Once we see the LogManager class loading, it's safe to start jmxfetch because the application is already setting\n+     * the global log manager and jmxfetch won't be able to touch it due to classloader locking.\n+     */\n+\n+    /*\n+     * Similar thing happens with AgentTracer on (at least) zulu-8 because it uses OkHttp which indirectly loads JFR\n+     * events which in turn loads LogManager. This is not a problem on newer JDKs because there JFR uses different\n+     * logging facility.\n+     */\n+    boolean appUsingCustomLogManager = isAppUsingCustomLogManager();\n+    if (AgentInitializer.isJavaBefore9WithJfr() && appUsingCustomLogManager) {\n+      log.debug(\"Custom logger detected. Delaying Agent Tracer initialization.\");\n+      for (ComponentInstaller componentInstaller : componentInstallers) {\n+        registerClassLoadCallback(\n+            \"java.util.logging.LogManager\",\n+            new InstallComponentAfterByteBuddyCallback(componentInstaller));\n+      }", "originalCommit": "acac6d24864595c44f906d2e9f8a2e27d7de114d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc4ODQyMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1848#discussion_r543788421", "bodyText": "I think setting the context class loader would make more sense (and be more self-explanatory) up in AgentInitializer.startAgent(), e.g.\n        ClassLoader agentClassLoader = createAgentClassLoader(\"inst\", bootstrapUrl);\n        Class<?> agentInstallerClass =\n            agentClassLoader.loadClass(\"io.opentelemetry.javaagent.tooling.AgentInstaller\");\n        Method agentInstallerMethod =\n            agentInstallerClass.getMethod(\"installBytebuddyAgent\", Instrumentation.class);\n        ClassLoader savedContextClassLoader = Thread.currentThread().getContextClassLoader();\n        try {\n          Thread.currentThread().setContextClassLoader(agentClassLoader);\n          agentInstallerMethod.invoke(null, inst);\n        } finally {\n          Thread.currentThread().setContextClassLoader(savedContextClassLoader);\n        }", "author": "trask", "createdAt": "2020-12-16T00:32:38Z", "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/AgentInstaller.java", "diffHunk": "@@ -160,7 +140,58 @@ public static ResettableClassFileTransformer installBytebuddyAgent(\n \n     agentBuilder = customizeByteBuddyAgent(agentBuilder);\n     log.debug(\"Installed {} instrumenter(s)\", numInstrumenters);\n-    return agentBuilder.installOn(inst);\n+    ResettableClassFileTransformer resettableClassFileTransformer = agentBuilder.installOn(inst);\n+    installComponentsAfterByteBuddy(componentInstallers);\n+    return resettableClassFileTransformer;\n+  }\n+\n+  private static void installComponentsBeforeByteBuddy(\n+      Iterable<ComponentInstaller> componentInstallers) {\n+    ClassLoader savedContextClassLoader = Thread.currentThread().getContextClassLoader();\n+    try {\n+      Thread.currentThread().setContextClassLoader(AgentInstaller.class.getClassLoader());\n+      for (ComponentInstaller componentInstaller : componentInstallers) {\n+        componentInstaller.beforeByteBuddyAgent();\n+      }\n+    } finally {\n+      Thread.currentThread().setContextClassLoader(savedContextClassLoader);\n+    }", "originalCommit": "acac6d24864595c44f906d2e9f8a2e27d7de114d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc4ODc5Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1848#discussion_r543788792", "bodyText": "I'm not sure this comment makes sense here", "author": "trask", "createdAt": "2020-12-16T00:33:39Z", "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/OpenTelemetryInstaller.java", "diffHunk": "@@ -30,15 +34,40 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-public class TracerInstaller {\n-  private static final Logger log = LoggerFactory.getLogger(TracerInstaller.class);\n+@AutoService(ComponentInstaller.class)\n+public class OpenTelemetryInstaller implements ComponentInstaller {\n+  private static final Logger log = LoggerFactory.getLogger(OpenTelemetryInstaller.class);\n \n   private static final String EXPORTER_JAR_CONFIG = \"otel.exporter.jar\";\n   private static final String EXPORTERS_CONFIG = \"otel.exporter\"; // this name is from spec\n   private static final String PROPAGATORS_CONFIG = \"otel.propagators\"; // this name is from spec\n   private static final String JAVAAGENT_ENABLED_CONFIG = \"otel.javaagent.enabled\";\n   private static final List<String> DEFAULT_EXPORTERS = Collections.singletonList(\"otlp\");\n \n+  @Override\n+  public void beforeByteBuddyAgent() {\n+    // calling (shaded) OpenTelemetry.getGlobalTracerProvider() with context class loader set to\n+    // the\n+    // agent class loader, so that SPI finds the agent's (isolated) SDK, and (shaded)\n+    // OpenTelemetry registers it, and then when instrumentation calls (shaded)\n+    // OpenTelemetry.getGlobalTracerProvider() later, they get back the agent's (isolated) SDK\n+    //\n+    // but if we don't trigger this early registration, then if instrumentation is the first to\n+    // call (shaded) OpenTelemetry.getGlobalTracerProvider(), then SPI can't see the agent class\n+    // loader,\n+    // and so (shaded) OpenTelemetry registers the no-op TracerFactory, and it cannot be replaced\n+    // later", "originalCommit": "acac6d24864595c44f906d2e9f8a2e27d7de114d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDAzMTc0Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1848#discussion_r544031743", "bodyText": "where to put it, @mateuszrzeszutek suggested to put it here.", "author": "pavolloffay", "createdAt": "2020-12-16T06:38:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc4ODc5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDgxNDc4NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1848#discussion_r544814785", "bodyText": "ya, this is a good place, sorry about that \ud83d\udc4d", "author": "trask", "createdAt": "2020-12-17T05:04:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc4ODc5Mg=="}], "type": "inlineReview"}, {"oid": "5a190772997ff9fc07fc803e9572165787030c6c", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/5a190772997ff9fc07fc803e9572165787030c6c", "message": "Add component installer SPI\n\nSigned-off-by: Pavol Loffay <p.loffay@gmail.com>", "committedDate": "2020-12-17T14:24:28Z", "type": "commit"}, {"oid": "5a190772997ff9fc07fc803e9572165787030c6c", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/5a190772997ff9fc07fc803e9572165787030c6c", "message": "Add component installer SPI\n\nSigned-off-by: Pavol Loffay <p.loffay@gmail.com>", "committedDate": "2020-12-17T14:24:28Z", "type": "forcePushed"}, {"oid": "349aaf8f2f284837d006f27ba8f0f34f89273067", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/349aaf8f2f284837d006f27ba8f0f34f89273067", "message": "Move more code to agent installer\n\nSigned-off-by: Pavol Loffay <p.loffay@gmail.com>", "committedDate": "2020-12-17T14:28:25Z", "type": "commit"}]}