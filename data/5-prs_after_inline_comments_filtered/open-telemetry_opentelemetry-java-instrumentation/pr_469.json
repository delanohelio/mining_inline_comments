{"pr_number": 469, "pr_title": "Deduplicate servlets", "pr_createdAt": "2020-06-02T15:18:53Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469", "timeline": [{"oid": "8fef624fd01bb39a9b8b6e6e3aaf8ac8796bb6df", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/8fef624fd01bb39a9b8b6e6e3aaf8ac8796bb6df", "message": "Servlet instrumentations unified", "committedDate": "2020-05-26T09:31:25Z", "type": "commit"}, {"oid": "6f0c6e7e146cd3d014ffe4b713b405110a983835", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/6f0c6e7e146cd3d014ffe4b713b405110a983835", "message": "Grizzly migrated", "committedDate": "2020-05-26T18:59:58Z", "type": "commit"}, {"oid": "5e02f97cc309fce03b11685d1b1b0f4e12c77815", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/5e02f97cc309fce03b11685d1b1b0f4e12c77815", "message": "Merge remote-tracking branch 'upstream/master' into http-spans", "committedDate": "2020-05-27T10:12:50Z", "type": "commit"}, {"oid": "83624f935b76b4972a831473689f5936dd66e9a1", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/83624f935b76b4972a831473689f5936dd66e9a1", "message": "Fix tests after merge", "committedDate": "2020-05-27T11:10:49Z", "type": "commit"}, {"oid": "e594f536a065b9613cbadad7923550bac439ff82", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/e594f536a065b9613cbadad7923550bac439ff82", "message": "Merge remote-tracking branch 'upstream/master' into deduplicate-servlets", "committedDate": "2020-06-02T12:01:51Z", "type": "commit"}, {"oid": "d69e63c5147d526c6b32ed7776d28b90f4fc3126", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/d69e63c5147d526c6b32ed7776d28b90f4fc3126", "message": "Polish and fix tests", "committedDate": "2020-06-02T15:15:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDExNTk0NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r434115945", "bodyText": "I think I'd keep SpanWithScope out of this this new API, and have HttpServerTracer return and work only on spans.\nSpanWithScope is primarily an auto-instrumentation detail to make it easier to pass them both between @OnMethodEnter and @OnMethodExit (in the future we could potentially get rid of it altogether using an extra @Local bytebuddy parameter, reducing memory allocations).", "author": "trask", "createdAt": "2020-06-02T19:10:58Z", "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/HttpServerTracer.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n+\n+import static io.opentelemetry.OpenTelemetry.getPropagators;\n+import static io.opentelemetry.trace.Span.Kind.SERVER;\n+import static io.opentelemetry.trace.TracingContextUtils.currentContextWith;\n+import static io.opentelemetry.trace.TracingContextUtils.getSpan;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.auto.config.Config;\n+import io.opentelemetry.auto.instrumentation.api.MoreTags;\n+import io.opentelemetry.auto.instrumentation.api.SpanWithScope;\n+import io.opentelemetry.auto.instrumentation.api.Tags;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.reflect.Method;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import lombok.extern.slf4j.Slf4j;\n+\n+// TODO In search for a better home package\n+@Slf4j\n+public abstract class HttpServerTracer<REQUEST> {\n+  public static final String SPAN_ATTRIBUTE = \"io.opentelemetry.auto.span\";\n+\n+  protected final Tracer tracer;\n+\n+  public HttpServerTracer() {\n+    tracer = OpenTelemetry.getTracerProvider().get(getInstrumentationName(), getVersion());\n+  }\n+\n+  public SpanWithScope startSpan(REQUEST request, Method origin, String originType) {", "originalCommit": "d69e63c5147d526c6b32ed7776d28b90f4fc3126", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ2MzUzMg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r434463532", "bodyText": "I see your point, but don't know how do that. Take a look at line 73. This method currently both returns newly created span (or null) and new scope. And that scope incapsulates a span which may be different from the returned value. If we don't need this \"rescoping\" then things become easier.", "author": "iNikem", "createdAt": "2020-06-03T10:20:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDExNTk0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc3MzA1Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r434773053", "bodyText": "Maybe this rescoping should happen in the instrumentation that needs it? I don't think the rescoping is applicable to most of the http server instrumentation anyways?", "author": "trask", "createdAt": "2020-06-03T18:33:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDExNTk0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc3NDAxNA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r434774014", "bodyText": "I have put this rescoping here because it looks like generic concern to me. I don't see how this can be instrumentation-specific.", "author": "iNikem", "createdAt": "2020-06-03T18:34:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDExNTk0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc3NTc1OA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r434775758", "bodyText": "most of the http server instrumentations don't need this rescoping", "author": "trask", "createdAt": "2020-06-03T18:38:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDExNTk0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc5MTA0NA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r434791044", "bodyText": "How do you decide that? I would think that all server instrumentations need that, why not?", "author": "iNikem", "createdAt": "2020-06-03T19:06:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDExNTk0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc5NzUxMA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r434797510", "bodyText": "E.g. in case of async servlet request processing we create span for incoming request in one thread, but actual request continues processing happens in another thread.\nDepending on servlet container implementation, this processing may again arrive into this method.\nE.g. Jetty handles async requests in a way that calls HttpServlet.service method twice.\n\nOther http servers don't do this weird thing of calling the same entrypoint for a second time from another thread", "author": "trask", "createdAt": "2020-06-03T19:18:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDExNTk0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA0Mjg4Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r435042882", "bodyText": "Current comment brings Jetty example only because I have personally seen this effect in Jetty. I have currently no idea if other containers can lead to the same effect. In master this rescoping logic lives in Servlet3Advice, which is servlet-container agnostic. I can move rescoping back there to preserve the current status quo.", "author": "iNikem", "createdAt": "2020-06-04T07:20:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDExNTk0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA0ODgxMw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r435048813", "bodyText": "But coming back to you original request in this thread. Do you propose that tracers should only concern themselves with spans and not scopes? For me managing scope (aka \"what is the current span\") is a cross-cutting concern that we should, ideally, handle centrally. And not in every single instrumentation. If you don't want to do it here, then what common code will handle #465 ? I thought this tracer is a good place for that.", "author": "iNikem", "createdAt": "2020-06-04T07:30:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDExNTk0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5NTE2Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r435695162", "bodyText": "My current thoughts:\n\nHave HttpServerTracer.startSpan() just create a new span (no conditional logic whether to create it or not, and no attaching to scope)\nHave a separate method that we call beforehand: HttpServerTracer.shouldCreateSpan(...) --> boolean, which can check the SERVER attribute in the current context\nHave another method that we call afterwards: HttpServerTracer.withSpan(Span) --> Scope, which can set the span in the SERVER attribute and attach the scope\nYa, let's leave that rescoping logic only in Servlet3Advice, I don't think it's needed anywhere else\n\nSome additional background:\n\nI don't particularly like SpanWithScope, it was basically just a workaround for passing both of those objects between @OnMethodEnter and @OnMethodExit, and at some point I'd like to get rid of SpanWithScope, instead adding a ByteBuddy @Local parameter to carry Span and Scope separately between @OnMethodEnter and @OnMethodExit\nI like being explicit about Scope/Context, and think it's ok to have a couple extra method calls to keep this more explicit", "author": "trask", "createdAt": "2020-06-05T05:19:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDExNTk0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcxMjEyMg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r435712122", "bodyText": "Your suggestion looks good, I will try it. But it defeats one of my goals: to remove \"constant call chains\", where every instrumentation has to call exact same methods in exact same sequence.\nBut I will try first removing rescoping and will see how code will look like then.", "author": "iNikem", "createdAt": "2020-06-05T06:21:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDExNTk0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDExOTQ5Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r434119496", "bodyText": "I think this code is correct, short of checking response.isCommitted().\nFrom the servlet spec:\n\nIf the exception isn't caught and handled, and the response hasn\u2019t been committed, the status code MUST be set to 500", "author": "trask", "createdAt": "2020-06-02T19:16:42Z", "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/HttpServerTracer.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n+\n+import static io.opentelemetry.OpenTelemetry.getPropagators;\n+import static io.opentelemetry.trace.Span.Kind.SERVER;\n+import static io.opentelemetry.trace.TracingContextUtils.currentContextWith;\n+import static io.opentelemetry.trace.TracingContextUtils.getSpan;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.auto.config.Config;\n+import io.opentelemetry.auto.instrumentation.api.MoreTags;\n+import io.opentelemetry.auto.instrumentation.api.SpanWithScope;\n+import io.opentelemetry.auto.instrumentation.api.Tags;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.reflect.Method;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import lombok.extern.slf4j.Slf4j;\n+\n+// TODO In search for a better home package\n+@Slf4j\n+public abstract class HttpServerTracer<REQUEST> {\n+  public static final String SPAN_ATTRIBUTE = \"io.opentelemetry.auto.span\";\n+\n+  protected final Tracer tracer;\n+\n+  public HttpServerTracer() {\n+    tracer = OpenTelemetry.getTracerProvider().get(getInstrumentationName(), getVersion());\n+  }\n+\n+  public SpanWithScope startSpan(REQUEST request, Method origin, String originType) {\n+    final Span existingSpan = getAttachedSpan(request);\n+    if (existingSpan != null) {\n+      /*\n+      Given request already has a span associated with it.\n+      As there should not be nested spans of kind SERVER, we should NOT create a new span here.\n+\n+      But it may happen that there is no span in current Context or it is from a different trace.\n+      E.g. in case of async servlet request processing we create span for incoming request in one thread,\n+      but actual request continues processing happens in another thread.\n+      Depending on servlet container implementation, this processing may again arrive into this method.\n+      E.g. Jetty handles async requests in a way that calls HttpServlet.service method twice.\n+\n+      In this case we have to put the span from the request into current context before continuing.\n+      */\n+      final boolean spanContextWasLost = !sameTrace(tracer.getCurrentSpan(), existingSpan);\n+      if (spanContextWasLost) {\n+        // Put span from request attribute into current context.\n+        // We did not create a new span here, so return null instead\n+        return new SpanWithScope(null, currentContextWith(existingSpan));\n+      } else {\n+        // We are inside nested servlet/filter, don't create new span\n+        return null;\n+      }\n+    }\n+\n+    final Span.Builder builder =\n+        tracer\n+            .spanBuilder(spanNameForMethod(origin))\n+            .setSpanKind(SERVER)\n+            .setParent(extract(request, getGetter()))\n+            // TODO Where span.origin.type is defined?\n+            .setAttribute(\"span.origin.type\", originType);\n+\n+    Span span = builder.startSpan();\n+    onConnection(span, request);\n+    onRequest(span, request);\n+\n+    return new SpanWithScope(span, currentContextWith(span));\n+  }\n+\n+  protected abstract String getVersion();\n+\n+  protected abstract String getInstrumentationName();\n+\n+  protected void onConnection(Span span, REQUEST request) {\n+    SemanticAttributes.NET_PEER_IP.set(span, peerHostIP(request));\n+    final Integer port = peerPort(request);\n+    // Negative or Zero ports might represent an unset/null value for an int type.  Skip setting.\n+    if (port != null && port > 0) {\n+      SemanticAttributes.NET_PEER_PORT.set(span, port);\n+    }\n+  }\n+\n+  private boolean sameTrace(Span oneSpan, Span otherSpan) {\n+    return oneSpan.getContext().getTraceId().equals(otherSpan.getContext().getTraceId());\n+  }\n+\n+  // TODO use semantic attributes\n+\n+  protected void onRequest(final Span span, final REQUEST request) {\n+    attachedSpanToRequest(span, request);\n+    SemanticAttributes.HTTP_METHOD.set(span, method(request));\n+\n+    // Copy of HttpClientDecorator url handling\n+    try {\n+      final URI url = url(request);\n+      if (url != null) {\n+        final StringBuilder urlBuilder = new StringBuilder();\n+        if (url.getScheme() != null) {\n+          urlBuilder.append(url.getScheme());\n+          urlBuilder.append(\"://\");\n+        }\n+        if (url.getHost() != null) {\n+          urlBuilder.append(url.getHost());\n+          if (url.getPort() > 0 && url.getPort() != 80 && url.getPort() != 443) {\n+            urlBuilder.append(\":\");\n+            urlBuilder.append(url.getPort());\n+          }\n+        }\n+        final String path = url.getPath();\n+        if (path.isEmpty()) {\n+          urlBuilder.append(\"/\");\n+        } else {\n+          urlBuilder.append(path);\n+        }\n+        final String query = url.getQuery();\n+        if (query != null) {\n+          urlBuilder.append(\"?\").append(query);\n+        }\n+        final String fragment = url.getFragment();\n+        if (fragment != null) {\n+          urlBuilder.append(\"#\").append(fragment);\n+        }\n+\n+        span.setAttribute(Tags.HTTP_URL, urlBuilder.toString());\n+\n+        if (Config.get().isHttpServerTagQueryString()) {\n+          span.setAttribute(MoreTags.HTTP_QUERY, url.getQuery());\n+          span.setAttribute(MoreTags.HTTP_FRAGMENT, url.getFragment());\n+        }\n+      }\n+    } catch (final Exception e) {\n+      log.debug(\"Error tagging url\", e);\n+    }\n+    // TODO set resource name from URL.\n+  }\n+  /**\n+   * This method is used to generate an acceptable span (operation) name based on a given method\n+   * reference. Anonymous classes are named based on their parent.\n+   */\n+  protected String spanNameForMethod(final Method method) {\n+    return spanNameForClass(method.getDeclaringClass()) + \".\" + method.getName();\n+  }\n+\n+  /**\n+   * This method is used to generate an acceptable span (operation) name based on a given class\n+   * reference. Anonymous classes are named based on their parent.\n+   */\n+  public String spanNameForClass(final Class clazz) {\n+    if (!clazz.isAnonymousClass()) {\n+      return clazz.getSimpleName();\n+    }\n+    String className = clazz.getName();\n+    if (clazz.getPackage() != null) {\n+      final String pkgName = clazz.getPackage().getName();\n+      if (!pkgName.isEmpty()) {\n+        className = clazz.getName().replace(pkgName, \"\").substring(1);\n+      }\n+    }\n+    return className;\n+  }\n+\n+  protected void onError(final Span span, final Throwable throwable) {\n+    addThrowable(span, unwrapThrowable(throwable));\n+  }\n+\n+  // TODO semantic attributes\n+  public static void addThrowable(final Span span, final Throwable throwable) {\n+    span.setAttribute(MoreTags.ERROR_MSG, throwable.getMessage());\n+    span.setAttribute(MoreTags.ERROR_TYPE, throwable.getClass().getName());\n+\n+    final StringWriter errorString = new StringWriter();\n+    throwable.printStackTrace(new PrintWriter(errorString));\n+    span.setAttribute(MoreTags.ERROR_STACK, errorString.toString());\n+  }\n+\n+  public Span getCurrentSpan() {\n+    return tracer.getCurrentSpan();\n+  }\n+\n+  // TODO should end methods remove SPAN attribute from request as well?\n+\n+  public void end(SpanWithScope spanWithScope, int responseCode) {\n+    if (spanWithScope == null) {\n+      return;\n+    }\n+\n+    final Span span = spanWithScope.getSpan();\n+    if (span != null) {\n+      end(span, responseCode);\n+    }\n+\n+    spanWithScope.closeScope();\n+  }\n+\n+  public void end(Span span, int responseStatus) {\n+    setStatus(span, responseStatus);\n+    span.end();\n+  }\n+\n+  public void endExceptionally(\n+      SpanWithScope spanWithScope, Throwable throwable, int responseStatus) {\n+    if (spanWithScope == null) {\n+      return;\n+    }\n+\n+    final Span span = spanWithScope.getSpan();\n+    if (span != null) {\n+      endExceptionally(span, throwable, responseStatus);\n+    }\n+\n+    spanWithScope.closeScope();\n+  }\n+\n+  public void endExceptionally(Span span, Throwable throwable, int responseStatus) {\n+    if (responseStatus == 200) {\n+      // TODO I think this is wrong.\n+      // We must report that response status that was actually sent to end user\n+      // We may change span status, but not http_status attribute", "originalCommit": "d69e63c5147d526c6b32ed7776d28b90f4fc3126", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ2NDA1Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r434464053", "bodyText": "But we don't have response here any more :) By your own suggestion, we now only have response status code :)", "author": "iNikem", "createdAt": "2020-06-03T10:21:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDExOTQ5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc2OTUxMw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r434769513", "bodyText": "Good point, since this behavior (setting status to 500 if response is not committed) is specific to the servlet instrumentation, maybe we should pull this out into the caller?", "author": "trask", "createdAt": "2020-06-03T18:27:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDExOTQ5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc3NDc5OA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r434774798", "bodyText": "But then we have to bring back that ResponseWithStatus because in Servlet 2 you cannot get response code from HttpResponse object.", "author": "iNikem", "createdAt": "2020-06-03T18:36:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDExOTQ5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4MDQwMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r434780401", "bodyText": "See https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469/files#r434780039", "author": "trask", "createdAt": "2020-06-03T18:46:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDExOTQ5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEyMjIwNg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r434122206", "bodyText": "This is for adding traceId and spanId to access logs, so you can correlate access logs with traces (e.g. https://tomcat.apache.org/tomcat-8.0-doc/config/valve.html#Access_Log_Valve/Attributes).", "author": "trask", "createdAt": "2020-06-02T19:21:32Z", "path": "instrumentation/servlet/servlet-common/src/main/java/io/opentelemetry/auto/instrumentation/servlet/ServletHttpServerTracer.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.auto.instrumentation.servlet;\n+\n+import io.opentelemetry.auto.bootstrap.instrumentation.decorator.HttpServerTracer;\n+import io.opentelemetry.auto.instrumentation.api.MoreTags;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.context.propagation.HttpTextFormat.Getter;\n+import io.opentelemetry.trace.Span;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.security.Principal;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public abstract class ServletHttpServerTracer extends HttpServerTracer<HttpServletRequest> {\n+\n+  protected String getVersion() {\n+    return null;\n+  }\n+\n+  @Override\n+  // TODO this violates convention\n+  protected URI url(HttpServletRequest httpServletRequest) throws URISyntaxException {\n+    return new URI(\n+        httpServletRequest.getScheme(),\n+        null,\n+        httpServletRequest.getServerName(),\n+        httpServletRequest.getServerPort(),\n+        httpServletRequest.getRequestURI(),\n+        httpServletRequest.getQueryString(),\n+        null);\n+  }\n+\n+  @Override\n+  protected Span getAttachedSpan(HttpServletRequest request) {\n+    Object span = request.getAttribute(SPAN_ATTRIBUTE);\n+    return span instanceof Span ? (Span) span : null;\n+  }\n+\n+  @Override\n+  protected void attachedSpanToRequest(Span span, HttpServletRequest request) {\n+    request.setAttribute(SPAN_ATTRIBUTE, span);\n+  }\n+\n+  @Override\n+  protected Integer peerPort(HttpServletRequest request) {\n+    // HttpServletResponse doesn't have accessor for remote port prior to Servlet spec 3.0\n+    return null;\n+  }\n+\n+  @Override\n+  protected String peerHostIP(HttpServletRequest request) {\n+    return request.getRemoteAddr();\n+  }\n+\n+  @Override\n+  protected String method(HttpServletRequest request) {\n+    return request.getMethod();\n+  }\n+\n+  public void onRequest(Span span, HttpServletRequest request) {\n+    // TODO why?\n+    request.setAttribute(\"traceId\", span.getContext().getTraceId().toLowerBase16());\n+    request.setAttribute(\"spanId\", span.getContext().getSpanId().toLowerBase16());", "originalCommit": "d69e63c5147d526c6b32ed7776d28b90f4fc3126", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEyNjIyNA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r434126224", "bodyText": "I think it's incorrect that we are not setting \"user.principal\" on the current span here, but it's not related to this PR (which just preserves existing behavior), so I opened a separate issue to track #470", "author": "trask", "createdAt": "2020-06-02T19:28:54Z", "path": "instrumentation/servlet/request-2.3/src/main/java/io/opentelemetry/auto/instrumentation/servlet/v2_3/Servlet2Advice.java", "diffHunk": "@@ -90,40 +55,17 @@ public static void stopSpan(\n       @Advice.Argument(1) final ServletResponse response,\n       @Advice.Enter final SpanWithScope spanWithScope,\n       @Advice.Thrown final Throwable throwable) {\n-    // Set user.principal regardless of who created this span.\n-    final Object spanAttr = request.getAttribute(SPAN_ATTRIBUTE);\n-    if (spanAttr instanceof Span && request instanceof HttpServletRequest) {\n-      final Principal principal = ((HttpServletRequest) request).getUserPrincipal();\n-      if (principal != null) {\n-        ((Span) spanAttr).setAttribute(MoreTags.USER_NAME, principal.getName());\n-      }\n-    }\n+    if (request instanceof HttpServletRequest && response instanceof HttpServletResponse) {\n+      TRACER.setPrincipal((HttpServletRequest) request);", "originalCommit": "d69e63c5147d526c6b32ed7776d28b90f4fc3126", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEyNzU0Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r434127546", "bodyText": "to save on memory:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private final Servlet3HttpServerTracer servletHttpServerTracer;\n          \n          \n            \n              private static final Servlet3HttpServerTracer servletHttpServerTracer = new Servlet3HttpServerTracer();", "author": "trask", "createdAt": "2020-06-02T19:31:27Z", "path": "instrumentation/servlet/request-3.0/src/main/java/io/opentelemetry/auto/instrumentation/servlet/v3_0/TagSettingAsyncListener.java", "diffHunk": "@@ -15,57 +15,48 @@\n  */\n package io.opentelemetry.auto.instrumentation.servlet.v3_0;\n \n-import static io.opentelemetry.auto.instrumentation.servlet.v3_0.Servlet3Decorator.DECORATE;\n-\n-import io.opentelemetry.auto.instrumentation.api.Tags;\n import io.opentelemetry.trace.Span;\n-import io.opentelemetry.trace.Status;\n import java.util.concurrent.atomic.AtomicBoolean;\n import javax.servlet.AsyncEvent;\n import javax.servlet.AsyncListener;\n import javax.servlet.http.HttpServletResponse;\n \n public class TagSettingAsyncListener implements AsyncListener {\n-  private final AtomicBoolean activated;\n+  private final AtomicBoolean responseHandled;\n   private final Span span;\n+  private final Servlet3HttpServerTracer servletHttpServerTracer;", "originalCommit": "d69e63c5147d526c6b32ed7776d28b90f4fc3126", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ac60f9d27cf05a13a5cb4cebc4b0a4adf56f12fc", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/ac60f9d27cf05a13a5cb4cebc4b0a4adf56f12fc", "message": "Polish and fix tests", "committedDate": "2020-06-03T11:32:06Z", "type": "commit"}, {"oid": "b33f4f25ff44297941196f2ba55de1222c998e1f", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/b33f4f25ff44297941196f2ba55de1222c998e1f", "message": "Muzzle fixes", "committedDate": "2020-06-03T12:30:51Z", "type": "commit"}, {"oid": "f1a937f1741260192cf19c2300854936b0a58785", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/f1a937f1741260192cf19c2300854936b0a58785", "message": "Muzzle fixes", "committedDate": "2020-06-03T13:50:06Z", "type": "commit"}, {"oid": "b8cb1f9f262b908a61edad825424ecda879b91f5", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/b8cb1f9f262b908a61edad825424ecda879b91f5", "message": "Muzzle fixes", "committedDate": "2020-06-03T15:52:14Z", "type": "commit"}, {"oid": "0b771c88a806af04e719e52fc34bc6f99d9e2b9c", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/0b771c88a806af04e719e52fc34bc6f99d9e2b9c", "message": "Test fixes", "committedDate": "2020-06-03T17:06:18Z", "type": "commit"}, {"oid": "8f72676cd15cfe623406f69fe05d6b64280bd830", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/8f72676cd15cfe623406f69fe05d6b64280bd830", "message": "One more check fixed", "committedDate": "2020-06-03T17:28:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4MDAzOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r434780039", "bodyText": "something like this is what i was trying to say\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    TRACER.endExceptionally(spanWithScope, throwable, responseStatus);\n          \n          \n            \n                    if (!response.isCommitted()) {\n          \n          \n            \n                      responseStatus = 500;\n          \n          \n            \n                    }\n          \n          \n            \n                    TRACER.endExceptionally(spanWithScope, throwable, responseStatus);", "author": "trask", "createdAt": "2020-06-03T18:45:58Z", "path": "instrumentation/servlet/request-2.3/src/main/java/io/opentelemetry/auto/instrumentation/servlet/v2_3/Servlet2Advice.java", "diffHunk": "@@ -90,40 +55,17 @@ public static void stopSpan(\n       @Advice.Argument(1) final ServletResponse response,\n       @Advice.Enter final SpanWithScope spanWithScope,\n       @Advice.Thrown final Throwable throwable) {\n-    // Set user.principal regardless of who created this span.\n-    final Object spanAttr = request.getAttribute(SPAN_ATTRIBUTE);\n-    if (spanAttr instanceof Span && request instanceof HttpServletRequest) {\n-      final Principal principal = ((HttpServletRequest) request).getUserPrincipal();\n-      if (principal != null) {\n-        ((Span) spanAttr).setAttribute(MoreTags.USER_NAME, principal.getName());\n-      }\n-    }\n+    if (request instanceof HttpServletRequest && response instanceof HttpServletResponse) {\n+      TRACER.setPrincipal((HttpServletRequest) request);\n \n-    if (spanWithScope == null) {\n-      return;\n-    }\n-\n-    final Span span = spanWithScope.getSpan();\n-\n-    if (response instanceof HttpServletResponse) {\n-      DECORATE.onResponse(\n-          span, InstrumentationContext.get(ServletResponse.class, Integer.class).get(response));\n-    } else {\n-      DECORATE.onResponse(span, null);\n-    }\n+      Integer responseStatus =\n+          InstrumentationContext.get(ServletResponse.class, Integer.class).get(response);\n \n-    if (throwable != null) {\n-      if (response instanceof HttpServletResponse\n-          && InstrumentationContext.get(ServletResponse.class, Integer.class).get(response)\n-              == HttpServletResponse.SC_OK) {\n-        // exception was thrown but status code wasn't set\n-        span.setAttribute(Tags.HTTP_STATUS, 500);\n-        span.setStatus(Status.UNKNOWN);\n+      if (throwable == null) {\n+        TRACER.end(spanWithScope, responseStatus);\n+      } else {\n+        TRACER.endExceptionally(spanWithScope, throwable, responseStatus);", "originalCommit": "8f72676cd15cfe623406f69fe05d6b64280bd830", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgwNjM2OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r434806369", "bodyText": "Do you suggest to add this condition check to all servlet instrumentations who calls this method? This means Servlet2Advice, Servlet3Advice and TagSettingAsyncListener. Avoiding such duplication was the original goal of this PR :)\nIn addition, should we check documentation for all other http servers/frameworks, if they require the same logic?\nNow thinking about this... Your citation from servlet spec says about changing status code of the servlet response. We don't do this here and did not do that before. So this current logic will report response status code in Span which is different from the one that client got in response. This was my original concern and why I think this is wrong.", "author": "iNikem", "createdAt": "2020-06-03T19:36:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4MDAzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgxMTg1OA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r434811858", "bodyText": "Do you suggest to add this condition check to all servlet instrumentations who calls this method? This means Servlet2Advice, Servlet3Advice and TagSettingAsyncListener. Avoiding such duplication was the original goal of this PR :)\n\nOh yes \ud83d\ude04. How about a subclass of HttpServerTracer that handles servlet-specific stuff?\n\nNow thinking about this... Your citation from servlet spec says about changing status code of the servlet response. We don't do this here and did not do that before. So this current logic will report response status code in Span which is different from the one that client got in response. This was my original concern and why I think this is wrong.\n\nAdding this logic (checking isCommitted) should make the response code in the Span align with the response code received by the client, no?", "author": "trask", "createdAt": "2020-06-03T19:43:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4MDAzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgxMzU2Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r434813567", "bodyText": "Adding this logic (checking isCommitted) should make the response code in the Span align with the response code received by the client, no?\n\nI think not. We read status code from the response. Then if that status code is not 200 and exception was thrown, then we set http.status_code attribute value to 500. But we don't change response status code in HttpResponse object. So client will still get 200. Or am I wrong?", "author": "iNikem", "createdAt": "2020-06-03T19:46:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4MDAzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgxNzE1OA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r434817158", "bodyText": "Ah, no, this part of the servlet spec is defining how servlet containers behave:\n\nIf the exception isn't caught and handled, and the response hasn\u2019t been committed, the status code MUST be set to 500\n\nSo if an exception is thrown, and the response has not been committed, the servlet container will change the response code to 500 and the client will get 500.", "author": "trask", "createdAt": "2020-06-03T19:54:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4MDAzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA0NTIzMA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r435045230", "bodyText": "How about a subclass of HttpServerTracer that handles servlet-specific stuff?\n\nI already have one in this PR, ServletHttpServerTracer. But it still means that I have to bring back ResponseWithStatus", "author": "iNikem", "createdAt": "2020-06-04T07:24:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4MDAzOQ=="}], "type": "inlineReview"}, {"oid": "04b6f63b6c90d25a0bf432d204b62358cc1bd261", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/04b6f63b6c90d25a0bf432d204b62358cc1bd261", "message": "Stop using SpanWithScope", "committedDate": "2020-06-05T07:21:58Z", "type": "commit"}, {"oid": "62d95d77bb2d7bc8076c520dd4e0ec1369355d08", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/62d95d77bb2d7bc8076c520dd4e0ec1369355d08", "message": "Test fix", "committedDate": "2020-06-05T10:19:05Z", "type": "commit"}, {"oid": "ae3a610b93af44b435d4e77bcc25f27b6a26ffd7", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/ae3a610b93af44b435d4e77bcc25f27b6a26ffd7", "message": "Merge branch 'master' into deduplicate-servlets", "committedDate": "2020-06-05T18:22:35Z", "type": "commit"}, {"oid": "3c9a8066c178138e6b0ff1c3ed5759750db5e3d7", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/3c9a8066c178138e6b0ff1c3ed5759750db5e3d7", "message": "Compilation fix", "committedDate": "2020-06-05T18:37:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA4OTc1NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r436089755", "bodyText": "is this comment still applicable after latest changes?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              // TODO should end methods remove SPAN attribute from request as well?", "author": "trask", "createdAt": "2020-06-05T18:18:57Z", "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/HttpServerTracer.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n+\n+import static io.opentelemetry.OpenTelemetry.getPropagators;\n+import static io.opentelemetry.trace.Span.Kind.SERVER;\n+import static io.opentelemetry.trace.TracingContextUtils.getSpan;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.auto.config.Config;\n+import io.opentelemetry.auto.instrumentation.api.MoreTags;\n+import io.opentelemetry.auto.instrumentation.api.Tags;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.reflect.Method;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import lombok.extern.slf4j.Slf4j;\n+\n+// TODO In search for a better home package\n+@Slf4j\n+public abstract class HttpServerTracer<REQUEST> {\n+  public static final String SPAN_ATTRIBUTE = \"io.opentelemetry.auto.span\";\n+\n+  protected final Tracer tracer;\n+\n+  public HttpServerTracer() {\n+    tracer = OpenTelemetry.getTracerProvider().get(getInstrumentationName(), getVersion());\n+  }\n+\n+  public Span startSpan(REQUEST request, Method origin, String originType) {\n+    if (getAttachedSpan(request) != null) {\n+      return null;\n+    }\n+\n+    final Span.Builder builder =\n+        tracer\n+            .spanBuilder(spanNameForMethod(origin))\n+            .setSpanKind(SERVER)\n+            .setParent(extract(request, getGetter()))\n+            // TODO Where span.origin.type is defined?\n+            .setAttribute(\"span.origin.type\", originType);\n+\n+    Span span = builder.startSpan();\n+    onConnection(span, request);\n+    onRequest(span, request);\n+\n+    return span;\n+  }\n+\n+  protected abstract String getVersion();\n+\n+  protected abstract String getInstrumentationName();\n+\n+  protected void onConnection(Span span, REQUEST request) {\n+    SemanticAttributes.NET_PEER_IP.set(span, peerHostIP(request));\n+    final Integer port = peerPort(request);\n+    // Negative or Zero ports might represent an unset/null value for an int type.  Skip setting.\n+    if (port != null && port > 0) {\n+      SemanticAttributes.NET_PEER_PORT.set(span, port);\n+    }\n+  }\n+\n+  // TODO use semantic attributes\n+  protected void onRequest(final Span span, final REQUEST request) {\n+    attachSpanToRequest(span, request);\n+    SemanticAttributes.HTTP_METHOD.set(span, method(request));\n+\n+    // Copy of HttpClientDecorator url handling\n+    try {\n+      final URI url = url(request);\n+      if (url != null) {\n+        final StringBuilder urlBuilder = new StringBuilder();\n+        if (url.getScheme() != null) {\n+          urlBuilder.append(url.getScheme());\n+          urlBuilder.append(\"://\");\n+        }\n+        if (url.getHost() != null) {\n+          urlBuilder.append(url.getHost());\n+          if (url.getPort() > 0 && url.getPort() != 80 && url.getPort() != 443) {\n+            urlBuilder.append(\":\");\n+            urlBuilder.append(url.getPort());\n+          }\n+        }\n+        final String path = url.getPath();\n+        if (path.isEmpty()) {\n+          urlBuilder.append(\"/\");\n+        } else {\n+          urlBuilder.append(path);\n+        }\n+        final String query = url.getQuery();\n+        if (query != null) {\n+          urlBuilder.append(\"?\").append(query);\n+        }\n+        final String fragment = url.getFragment();\n+        if (fragment != null) {\n+          urlBuilder.append(\"#\").append(fragment);\n+        }\n+\n+        span.setAttribute(Tags.HTTP_URL, urlBuilder.toString());\n+\n+        if (Config.get().isHttpServerTagQueryString()) {\n+          span.setAttribute(MoreTags.HTTP_QUERY, url.getQuery());\n+          span.setAttribute(MoreTags.HTTP_FRAGMENT, url.getFragment());\n+        }\n+      }\n+    } catch (final Exception e) {\n+      log.debug(\"Error tagging url\", e);\n+    }\n+    // TODO set resource name from URL.\n+  }\n+\n+  public boolean sameTrace(Span oneSpan, Span otherSpan) {\n+    return oneSpan.getContext().getTraceId().equals(otherSpan.getContext().getTraceId());\n+  }\n+\n+  /**\n+   * This method is used to generate an acceptable span (operation) name based on a given method\n+   * reference. Anonymous classes are named based on their parent.\n+   */\n+  protected String spanNameForMethod(final Method method) {\n+    return spanNameForClass(method.getDeclaringClass()) + \".\" + method.getName();\n+  }\n+\n+  /**\n+   * This method is used to generate an acceptable span (operation) name based on a given class\n+   * reference. Anonymous classes are named based on their parent.\n+   */\n+  public String spanNameForClass(final Class clazz) {\n+    if (!clazz.isAnonymousClass()) {\n+      return clazz.getSimpleName();\n+    }\n+    String className = clazz.getName();\n+    if (clazz.getPackage() != null) {\n+      final String pkgName = clazz.getPackage().getName();\n+      if (!pkgName.isEmpty()) {\n+        className = clazz.getName().replace(pkgName, \"\").substring(1);\n+      }\n+    }\n+    return className;\n+  }\n+\n+  protected void onError(final Span span, final Throwable throwable) {\n+    addThrowable(span, unwrapThrowable(throwable));\n+  }\n+\n+  // TODO semantic attributes\n+  public static void addThrowable(final Span span, final Throwable throwable) {\n+    span.setAttribute(MoreTags.ERROR_MSG, throwable.getMessage());\n+    span.setAttribute(MoreTags.ERROR_TYPE, throwable.getClass().getName());\n+\n+    final StringWriter errorString = new StringWriter();\n+    throwable.printStackTrace(new PrintWriter(errorString));\n+    span.setAttribute(MoreTags.ERROR_STACK, errorString.toString());\n+  }\n+\n+  public Span getCurrentSpan() {\n+    return tracer.getCurrentSpan();\n+  }\n+\n+  public Scope newScope(Span span) {\n+    return tracer.withSpan(span);\n+  }\n+\n+  // TODO should end methods remove SPAN attribute from request as well?", "originalCommit": "62d95d77bb2d7bc8076c520dd4e0ec1369355d08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEyMzk1Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r436123957", "bodyText": "I think yes. As long as there is attachSpanToRequest and #465 is not implemented, this question remains.", "author": "iNikem", "createdAt": "2020-06-05T19:34:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA4OTc1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA5OTUzOA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r436099538", "bodyText": "looks unused now\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public boolean sameTrace(Span oneSpan, Span otherSpan) {\n          \n          \n            \n                return oneSpan.getContext().getTraceId().equals(otherSpan.getContext().getTraceId());\n          \n          \n            \n              }", "author": "trask", "createdAt": "2020-06-05T18:39:12Z", "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/HttpServerTracer.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n+\n+import static io.opentelemetry.OpenTelemetry.getPropagators;\n+import static io.opentelemetry.trace.Span.Kind.SERVER;\n+import static io.opentelemetry.trace.TracingContextUtils.getSpan;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.auto.config.Config;\n+import io.opentelemetry.auto.instrumentation.api.MoreTags;\n+import io.opentelemetry.auto.instrumentation.api.Tags;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.reflect.Method;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import lombok.extern.slf4j.Slf4j;\n+\n+// TODO In search for a better home package\n+@Slf4j\n+public abstract class HttpServerTracer<REQUEST> {\n+  public static final String SPAN_ATTRIBUTE = \"io.opentelemetry.auto.span\";\n+\n+  protected final Tracer tracer;\n+\n+  public HttpServerTracer() {\n+    tracer = OpenTelemetry.getTracerProvider().get(getInstrumentationName(), getVersion());\n+  }\n+\n+  public Span startSpan(REQUEST request, Method origin, String originType) {\n+    if (getAttachedSpan(request) != null) {\n+      return null;\n+    }\n+\n+    final Span.Builder builder =\n+        tracer\n+            .spanBuilder(spanNameForMethod(origin))\n+            .setSpanKind(SERVER)\n+            .setParent(extract(request, getGetter()))\n+            // TODO Where span.origin.type is defined?\n+            .setAttribute(\"span.origin.type\", originType);\n+\n+    Span span = builder.startSpan();\n+    onConnection(span, request);\n+    onRequest(span, request);\n+\n+    return span;\n+  }\n+\n+  protected abstract String getVersion();\n+\n+  protected abstract String getInstrumentationName();\n+\n+  protected void onConnection(Span span, REQUEST request) {\n+    SemanticAttributes.NET_PEER_IP.set(span, peerHostIP(request));\n+    final Integer port = peerPort(request);\n+    // Negative or Zero ports might represent an unset/null value for an int type.  Skip setting.\n+    if (port != null && port > 0) {\n+      SemanticAttributes.NET_PEER_PORT.set(span, port);\n+    }\n+  }\n+\n+  // TODO use semantic attributes\n+  protected void onRequest(final Span span, final REQUEST request) {\n+    attachSpanToRequest(span, request);\n+    SemanticAttributes.HTTP_METHOD.set(span, method(request));\n+\n+    // Copy of HttpClientDecorator url handling\n+    try {\n+      final URI url = url(request);\n+      if (url != null) {\n+        final StringBuilder urlBuilder = new StringBuilder();\n+        if (url.getScheme() != null) {\n+          urlBuilder.append(url.getScheme());\n+          urlBuilder.append(\"://\");\n+        }\n+        if (url.getHost() != null) {\n+          urlBuilder.append(url.getHost());\n+          if (url.getPort() > 0 && url.getPort() != 80 && url.getPort() != 443) {\n+            urlBuilder.append(\":\");\n+            urlBuilder.append(url.getPort());\n+          }\n+        }\n+        final String path = url.getPath();\n+        if (path.isEmpty()) {\n+          urlBuilder.append(\"/\");\n+        } else {\n+          urlBuilder.append(path);\n+        }\n+        final String query = url.getQuery();\n+        if (query != null) {\n+          urlBuilder.append(\"?\").append(query);\n+        }\n+        final String fragment = url.getFragment();\n+        if (fragment != null) {\n+          urlBuilder.append(\"#\").append(fragment);\n+        }\n+\n+        span.setAttribute(Tags.HTTP_URL, urlBuilder.toString());\n+\n+        if (Config.get().isHttpServerTagQueryString()) {\n+          span.setAttribute(MoreTags.HTTP_QUERY, url.getQuery());\n+          span.setAttribute(MoreTags.HTTP_FRAGMENT, url.getFragment());\n+        }\n+      }\n+    } catch (final Exception e) {\n+      log.debug(\"Error tagging url\", e);\n+    }\n+    // TODO set resource name from URL.\n+  }\n+\n+  public boolean sameTrace(Span oneSpan, Span otherSpan) {\n+    return oneSpan.getContext().getTraceId().equals(otherSpan.getContext().getTraceId());\n+  }\n+", "originalCommit": "3c9a8066c178138e6b0ff1c3ed5759750db5e3d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEyNDE2MA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r436124160", "bodyText": "It is used from io/opentelemetry/auto/instrumentation/servlet/v3_0/Servlet3Advice.java:61", "author": "iNikem", "createdAt": "2020-06-05T19:34:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA5OTUzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwMDA3Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r436100072", "bodyText": "seems good to be consistent with Tracer name?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public Scope newScope(Span span) {\n          \n          \n            \n              public Scope withSpan(Span span) {", "author": "trask", "createdAt": "2020-06-05T18:40:15Z", "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/HttpServerTracer.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n+\n+import static io.opentelemetry.OpenTelemetry.getPropagators;\n+import static io.opentelemetry.trace.Span.Kind.SERVER;\n+import static io.opentelemetry.trace.TracingContextUtils.getSpan;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.auto.config.Config;\n+import io.opentelemetry.auto.instrumentation.api.MoreTags;\n+import io.opentelemetry.auto.instrumentation.api.Tags;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.reflect.Method;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import lombok.extern.slf4j.Slf4j;\n+\n+// TODO In search for a better home package\n+@Slf4j\n+public abstract class HttpServerTracer<REQUEST> {\n+  public static final String SPAN_ATTRIBUTE = \"io.opentelemetry.auto.span\";\n+\n+  protected final Tracer tracer;\n+\n+  public HttpServerTracer() {\n+    tracer = OpenTelemetry.getTracerProvider().get(getInstrumentationName(), getVersion());\n+  }\n+\n+  public Span startSpan(REQUEST request, Method origin, String originType) {\n+    if (getAttachedSpan(request) != null) {\n+      return null;\n+    }\n+\n+    final Span.Builder builder =\n+        tracer\n+            .spanBuilder(spanNameForMethod(origin))\n+            .setSpanKind(SERVER)\n+            .setParent(extract(request, getGetter()))\n+            // TODO Where span.origin.type is defined?\n+            .setAttribute(\"span.origin.type\", originType);\n+\n+    Span span = builder.startSpan();\n+    onConnection(span, request);\n+    onRequest(span, request);\n+\n+    return span;\n+  }\n+\n+  protected abstract String getVersion();\n+\n+  protected abstract String getInstrumentationName();\n+\n+  protected void onConnection(Span span, REQUEST request) {\n+    SemanticAttributes.NET_PEER_IP.set(span, peerHostIP(request));\n+    final Integer port = peerPort(request);\n+    // Negative or Zero ports might represent an unset/null value for an int type.  Skip setting.\n+    if (port != null && port > 0) {\n+      SemanticAttributes.NET_PEER_PORT.set(span, port);\n+    }\n+  }\n+\n+  // TODO use semantic attributes\n+  protected void onRequest(final Span span, final REQUEST request) {\n+    attachSpanToRequest(span, request);\n+    SemanticAttributes.HTTP_METHOD.set(span, method(request));\n+\n+    // Copy of HttpClientDecorator url handling\n+    try {\n+      final URI url = url(request);\n+      if (url != null) {\n+        final StringBuilder urlBuilder = new StringBuilder();\n+        if (url.getScheme() != null) {\n+          urlBuilder.append(url.getScheme());\n+          urlBuilder.append(\"://\");\n+        }\n+        if (url.getHost() != null) {\n+          urlBuilder.append(url.getHost());\n+          if (url.getPort() > 0 && url.getPort() != 80 && url.getPort() != 443) {\n+            urlBuilder.append(\":\");\n+            urlBuilder.append(url.getPort());\n+          }\n+        }\n+        final String path = url.getPath();\n+        if (path.isEmpty()) {\n+          urlBuilder.append(\"/\");\n+        } else {\n+          urlBuilder.append(path);\n+        }\n+        final String query = url.getQuery();\n+        if (query != null) {\n+          urlBuilder.append(\"?\").append(query);\n+        }\n+        final String fragment = url.getFragment();\n+        if (fragment != null) {\n+          urlBuilder.append(\"#\").append(fragment);\n+        }\n+\n+        span.setAttribute(Tags.HTTP_URL, urlBuilder.toString());\n+\n+        if (Config.get().isHttpServerTagQueryString()) {\n+          span.setAttribute(MoreTags.HTTP_QUERY, url.getQuery());\n+          span.setAttribute(MoreTags.HTTP_FRAGMENT, url.getFragment());\n+        }\n+      }\n+    } catch (final Exception e) {\n+      log.debug(\"Error tagging url\", e);\n+    }\n+    // TODO set resource name from URL.\n+  }\n+\n+  public boolean sameTrace(Span oneSpan, Span otherSpan) {\n+    return oneSpan.getContext().getTraceId().equals(otherSpan.getContext().getTraceId());\n+  }\n+\n+  /**\n+   * This method is used to generate an acceptable span (operation) name based on a given method\n+   * reference. Anonymous classes are named based on their parent.\n+   */\n+  protected String spanNameForMethod(final Method method) {\n+    return spanNameForClass(method.getDeclaringClass()) + \".\" + method.getName();\n+  }\n+\n+  /**\n+   * This method is used to generate an acceptable span (operation) name based on a given class\n+   * reference. Anonymous classes are named based on their parent.\n+   */\n+  public String spanNameForClass(final Class clazz) {\n+    if (!clazz.isAnonymousClass()) {\n+      return clazz.getSimpleName();\n+    }\n+    String className = clazz.getName();\n+    if (clazz.getPackage() != null) {\n+      final String pkgName = clazz.getPackage().getName();\n+      if (!pkgName.isEmpty()) {\n+        className = clazz.getName().replace(pkgName, \"\").substring(1);\n+      }\n+    }\n+    return className;\n+  }\n+\n+  protected void onError(final Span span, final Throwable throwable) {\n+    addThrowable(span, unwrapThrowable(throwable));\n+  }\n+\n+  // TODO semantic attributes\n+  public static void addThrowable(final Span span, final Throwable throwable) {\n+    span.setAttribute(MoreTags.ERROR_MSG, throwable.getMessage());\n+    span.setAttribute(MoreTags.ERROR_TYPE, throwable.getClass().getName());\n+\n+    final StringWriter errorString = new StringWriter();\n+    throwable.printStackTrace(new PrintWriter(errorString));\n+    span.setAttribute(MoreTags.ERROR_STACK, errorString.toString());\n+  }\n+\n+  public Span getCurrentSpan() {\n+    return tracer.getCurrentSpan();\n+  }\n+\n+  public Scope newScope(Span span) {", "originalCommit": "3c9a8066c178138e6b0ff1c3ed5759750db5e3d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExMTkzNw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r436111937", "bodyText": "similar comment as above\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public void endExceptionally(Span span, Scope scope, Throwable throwable, int responseStatus) {\n          \n          \n            \n                if (scope == null) {\n          \n          \n            \n                  return;\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                if (span != null) {\n          \n          \n            \n                  endExceptionally(span, throwable, responseStatus);\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                scope.close();\n          \n          \n            \n              }", "author": "trask", "createdAt": "2020-06-05T19:05:53Z", "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/HttpServerTracer.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n+\n+import static io.opentelemetry.OpenTelemetry.getPropagators;\n+import static io.opentelemetry.trace.Span.Kind.SERVER;\n+import static io.opentelemetry.trace.TracingContextUtils.getSpan;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.auto.config.Config;\n+import io.opentelemetry.auto.instrumentation.api.MoreTags;\n+import io.opentelemetry.auto.instrumentation.api.Tags;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.reflect.Method;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import lombok.extern.slf4j.Slf4j;\n+\n+// TODO In search for a better home package\n+@Slf4j\n+public abstract class HttpServerTracer<REQUEST> {\n+  public static final String SPAN_ATTRIBUTE = \"io.opentelemetry.auto.span\";\n+\n+  protected final Tracer tracer;\n+\n+  public HttpServerTracer() {\n+    tracer = OpenTelemetry.getTracerProvider().get(getInstrumentationName(), getVersion());\n+  }\n+\n+  public Span startSpan(REQUEST request, Method origin, String originType) {\n+    if (getAttachedSpan(request) != null) {\n+      return null;\n+    }\n+\n+    final Span.Builder builder =\n+        tracer\n+            .spanBuilder(spanNameForMethod(origin))\n+            .setSpanKind(SERVER)\n+            .setParent(extract(request, getGetter()))\n+            // TODO Where span.origin.type is defined?\n+            .setAttribute(\"span.origin.type\", originType);\n+\n+    Span span = builder.startSpan();\n+    onConnection(span, request);\n+    onRequest(span, request);\n+\n+    return span;\n+  }\n+\n+  protected abstract String getVersion();\n+\n+  protected abstract String getInstrumentationName();\n+\n+  protected void onConnection(Span span, REQUEST request) {\n+    SemanticAttributes.NET_PEER_IP.set(span, peerHostIP(request));\n+    final Integer port = peerPort(request);\n+    // Negative or Zero ports might represent an unset/null value for an int type.  Skip setting.\n+    if (port != null && port > 0) {\n+      SemanticAttributes.NET_PEER_PORT.set(span, port);\n+    }\n+  }\n+\n+  // TODO use semantic attributes\n+  protected void onRequest(final Span span, final REQUEST request) {\n+    attachSpanToRequest(span, request);\n+    SemanticAttributes.HTTP_METHOD.set(span, method(request));\n+\n+    // Copy of HttpClientDecorator url handling\n+    try {\n+      final URI url = url(request);\n+      if (url != null) {\n+        final StringBuilder urlBuilder = new StringBuilder();\n+        if (url.getScheme() != null) {\n+          urlBuilder.append(url.getScheme());\n+          urlBuilder.append(\"://\");\n+        }\n+        if (url.getHost() != null) {\n+          urlBuilder.append(url.getHost());\n+          if (url.getPort() > 0 && url.getPort() != 80 && url.getPort() != 443) {\n+            urlBuilder.append(\":\");\n+            urlBuilder.append(url.getPort());\n+          }\n+        }\n+        final String path = url.getPath();\n+        if (path.isEmpty()) {\n+          urlBuilder.append(\"/\");\n+        } else {\n+          urlBuilder.append(path);\n+        }\n+        final String query = url.getQuery();\n+        if (query != null) {\n+          urlBuilder.append(\"?\").append(query);\n+        }\n+        final String fragment = url.getFragment();\n+        if (fragment != null) {\n+          urlBuilder.append(\"#\").append(fragment);\n+        }\n+\n+        span.setAttribute(Tags.HTTP_URL, urlBuilder.toString());\n+\n+        if (Config.get().isHttpServerTagQueryString()) {\n+          span.setAttribute(MoreTags.HTTP_QUERY, url.getQuery());\n+          span.setAttribute(MoreTags.HTTP_FRAGMENT, url.getFragment());\n+        }\n+      }\n+    } catch (final Exception e) {\n+      log.debug(\"Error tagging url\", e);\n+    }\n+    // TODO set resource name from URL.\n+  }\n+\n+  public boolean sameTrace(Span oneSpan, Span otherSpan) {\n+    return oneSpan.getContext().getTraceId().equals(otherSpan.getContext().getTraceId());\n+  }\n+\n+  /**\n+   * This method is used to generate an acceptable span (operation) name based on a given method\n+   * reference. Anonymous classes are named based on their parent.\n+   */\n+  protected String spanNameForMethod(final Method method) {\n+    return spanNameForClass(method.getDeclaringClass()) + \".\" + method.getName();\n+  }\n+\n+  /**\n+   * This method is used to generate an acceptable span (operation) name based on a given class\n+   * reference. Anonymous classes are named based on their parent.\n+   */\n+  public String spanNameForClass(final Class clazz) {\n+    if (!clazz.isAnonymousClass()) {\n+      return clazz.getSimpleName();\n+    }\n+    String className = clazz.getName();\n+    if (clazz.getPackage() != null) {\n+      final String pkgName = clazz.getPackage().getName();\n+      if (!pkgName.isEmpty()) {\n+        className = clazz.getName().replace(pkgName, \"\").substring(1);\n+      }\n+    }\n+    return className;\n+  }\n+\n+  protected void onError(final Span span, final Throwable throwable) {\n+    addThrowable(span, unwrapThrowable(throwable));\n+  }\n+\n+  // TODO semantic attributes\n+  public static void addThrowable(final Span span, final Throwable throwable) {\n+    span.setAttribute(MoreTags.ERROR_MSG, throwable.getMessage());\n+    span.setAttribute(MoreTags.ERROR_TYPE, throwable.getClass().getName());\n+\n+    final StringWriter errorString = new StringWriter();\n+    throwable.printStackTrace(new PrintWriter(errorString));\n+    span.setAttribute(MoreTags.ERROR_STACK, errorString.toString());\n+  }\n+\n+  public Span getCurrentSpan() {\n+    return tracer.getCurrentSpan();\n+  }\n+\n+  public Scope newScope(Span span) {\n+    return tracer.withSpan(span);\n+  }\n+\n+  // TODO should end methods remove SPAN attribute from request as well?\n+  public void end(Span span, Scope scope, int responseCode) {\n+    if (scope == null) {\n+      return;\n+    }\n+\n+    if (span != null) {\n+      end(span, responseCode);\n+    }\n+\n+    scope.close();\n+  }\n+\n+  public void end(Span span, int responseStatus) {\n+    setStatus(span, responseStatus);\n+    span.end();\n+  }\n+\n+  public void endExceptionally(Span span, Scope scope, Throwable throwable, int responseStatus) {\n+    if (scope == null) {\n+      return;\n+    }\n+\n+    if (span != null) {\n+      endExceptionally(span, throwable, responseStatus);\n+    }\n+\n+    scope.close();\n+  }\n+", "originalCommit": "3c9a8066c178138e6b0ff1c3ed5759750db5e3d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExMjE4MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r436112181", "bodyText": "it doesn't looks like this is ever called with null span or null scope\nalso, i think i like calling end(span, responseStatus) directly, and keeping scope.close() an explicit separate action\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public void end(Span span, Scope scope, int responseCode) {\n          \n          \n            \n                if (scope == null) {\n          \n          \n            \n                  return;\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                if (span != null) {\n          \n          \n            \n                  end(span, responseCode);\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                scope.close();\n          \n          \n            \n              }", "author": "trask", "createdAt": "2020-06-05T19:06:27Z", "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/HttpServerTracer.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n+\n+import static io.opentelemetry.OpenTelemetry.getPropagators;\n+import static io.opentelemetry.trace.Span.Kind.SERVER;\n+import static io.opentelemetry.trace.TracingContextUtils.getSpan;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.auto.config.Config;\n+import io.opentelemetry.auto.instrumentation.api.MoreTags;\n+import io.opentelemetry.auto.instrumentation.api.Tags;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.reflect.Method;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import lombok.extern.slf4j.Slf4j;\n+\n+// TODO In search for a better home package\n+@Slf4j\n+public abstract class HttpServerTracer<REQUEST> {\n+  public static final String SPAN_ATTRIBUTE = \"io.opentelemetry.auto.span\";\n+\n+  protected final Tracer tracer;\n+\n+  public HttpServerTracer() {\n+    tracer = OpenTelemetry.getTracerProvider().get(getInstrumentationName(), getVersion());\n+  }\n+\n+  public Span startSpan(REQUEST request, Method origin, String originType) {\n+    if (getAttachedSpan(request) != null) {\n+      return null;\n+    }\n+\n+    final Span.Builder builder =\n+        tracer\n+            .spanBuilder(spanNameForMethod(origin))\n+            .setSpanKind(SERVER)\n+            .setParent(extract(request, getGetter()))\n+            // TODO Where span.origin.type is defined?\n+            .setAttribute(\"span.origin.type\", originType);\n+\n+    Span span = builder.startSpan();\n+    onConnection(span, request);\n+    onRequest(span, request);\n+\n+    return span;\n+  }\n+\n+  protected abstract String getVersion();\n+\n+  protected abstract String getInstrumentationName();\n+\n+  protected void onConnection(Span span, REQUEST request) {\n+    SemanticAttributes.NET_PEER_IP.set(span, peerHostIP(request));\n+    final Integer port = peerPort(request);\n+    // Negative or Zero ports might represent an unset/null value for an int type.  Skip setting.\n+    if (port != null && port > 0) {\n+      SemanticAttributes.NET_PEER_PORT.set(span, port);\n+    }\n+  }\n+\n+  // TODO use semantic attributes\n+  protected void onRequest(final Span span, final REQUEST request) {\n+    attachSpanToRequest(span, request);\n+    SemanticAttributes.HTTP_METHOD.set(span, method(request));\n+\n+    // Copy of HttpClientDecorator url handling\n+    try {\n+      final URI url = url(request);\n+      if (url != null) {\n+        final StringBuilder urlBuilder = new StringBuilder();\n+        if (url.getScheme() != null) {\n+          urlBuilder.append(url.getScheme());\n+          urlBuilder.append(\"://\");\n+        }\n+        if (url.getHost() != null) {\n+          urlBuilder.append(url.getHost());\n+          if (url.getPort() > 0 && url.getPort() != 80 && url.getPort() != 443) {\n+            urlBuilder.append(\":\");\n+            urlBuilder.append(url.getPort());\n+          }\n+        }\n+        final String path = url.getPath();\n+        if (path.isEmpty()) {\n+          urlBuilder.append(\"/\");\n+        } else {\n+          urlBuilder.append(path);\n+        }\n+        final String query = url.getQuery();\n+        if (query != null) {\n+          urlBuilder.append(\"?\").append(query);\n+        }\n+        final String fragment = url.getFragment();\n+        if (fragment != null) {\n+          urlBuilder.append(\"#\").append(fragment);\n+        }\n+\n+        span.setAttribute(Tags.HTTP_URL, urlBuilder.toString());\n+\n+        if (Config.get().isHttpServerTagQueryString()) {\n+          span.setAttribute(MoreTags.HTTP_QUERY, url.getQuery());\n+          span.setAttribute(MoreTags.HTTP_FRAGMENT, url.getFragment());\n+        }\n+      }\n+    } catch (final Exception e) {\n+      log.debug(\"Error tagging url\", e);\n+    }\n+    // TODO set resource name from URL.\n+  }\n+\n+  public boolean sameTrace(Span oneSpan, Span otherSpan) {\n+    return oneSpan.getContext().getTraceId().equals(otherSpan.getContext().getTraceId());\n+  }\n+\n+  /**\n+   * This method is used to generate an acceptable span (operation) name based on a given method\n+   * reference. Anonymous classes are named based on their parent.\n+   */\n+  protected String spanNameForMethod(final Method method) {\n+    return spanNameForClass(method.getDeclaringClass()) + \".\" + method.getName();\n+  }\n+\n+  /**\n+   * This method is used to generate an acceptable span (operation) name based on a given class\n+   * reference. Anonymous classes are named based on their parent.\n+   */\n+  public String spanNameForClass(final Class clazz) {\n+    if (!clazz.isAnonymousClass()) {\n+      return clazz.getSimpleName();\n+    }\n+    String className = clazz.getName();\n+    if (clazz.getPackage() != null) {\n+      final String pkgName = clazz.getPackage().getName();\n+      if (!pkgName.isEmpty()) {\n+        className = clazz.getName().replace(pkgName, \"\").substring(1);\n+      }\n+    }\n+    return className;\n+  }\n+\n+  protected void onError(final Span span, final Throwable throwable) {\n+    addThrowable(span, unwrapThrowable(throwable));\n+  }\n+\n+  // TODO semantic attributes\n+  public static void addThrowable(final Span span, final Throwable throwable) {\n+    span.setAttribute(MoreTags.ERROR_MSG, throwable.getMessage());\n+    span.setAttribute(MoreTags.ERROR_TYPE, throwable.getClass().getName());\n+\n+    final StringWriter errorString = new StringWriter();\n+    throwable.printStackTrace(new PrintWriter(errorString));\n+    span.setAttribute(MoreTags.ERROR_STACK, errorString.toString());\n+  }\n+\n+  public Span getCurrentSpan() {\n+    return tracer.getCurrentSpan();\n+  }\n+\n+  public Scope newScope(Span span) {\n+    return tracer.withSpan(span);\n+  }\n+\n+  // TODO should end methods remove SPAN attribute from request as well?\n+  public void end(Span span, Scope scope, int responseCode) {\n+    if (scope == null) {\n+      return;\n+    }\n+\n+    if (span != null) {\n+      end(span, responseCode);\n+    }\n+\n+    scope.close();\n+  }\n+", "originalCommit": "3c9a8066c178138e6b0ff1c3ed5759750db5e3d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEyNTY0MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r436125641", "bodyText": "This again will force instrumentation to call several methods on tracer in row. The whole point of these \"semantic/typed tracers\" for me is encapsulating all those steps that are repeated again and again in every instrumentation. I want as few repetitive lines of code in instrumentation classes as possible.", "author": "iNikem", "createdAt": "2020-06-05T19:38:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExMjE4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEyNzAxOA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r436127018", "bodyText": "And it can be called with null span if instrumentation decided not to create new span. Servlet instrumentations do that from time to time.", "author": "iNikem", "createdAt": "2020-06-05T19:41:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExMjE4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NzE2MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r436257161", "bodyText": "I have moved scope management out of tracer for now. But I have a strong feeling that #465 will want to bring it back :)", "author": "iNikem", "createdAt": "2020-06-06T10:22:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExMjE4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExNTU4Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r436115583", "bodyText": "i think we only need this for servlet-ish instrumentations, so maybe provide default so it's more clear subclasses don't need to implement this\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              protected abstract void attachSpanToRequest(Span span, REQUEST request);\n          \n          \n            \n              protected void attachSpanToRequest(Span span, REQUEST request) {\n          \n          \n            \n              }", "author": "trask", "createdAt": "2020-06-05T19:14:30Z", "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/HttpServerTracer.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n+\n+import static io.opentelemetry.OpenTelemetry.getPropagators;\n+import static io.opentelemetry.trace.Span.Kind.SERVER;\n+import static io.opentelemetry.trace.TracingContextUtils.getSpan;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.auto.config.Config;\n+import io.opentelemetry.auto.instrumentation.api.MoreTags;\n+import io.opentelemetry.auto.instrumentation.api.Tags;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.reflect.Method;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import lombok.extern.slf4j.Slf4j;\n+\n+// TODO In search for a better home package\n+@Slf4j\n+public abstract class HttpServerTracer<REQUEST> {\n+  public static final String SPAN_ATTRIBUTE = \"io.opentelemetry.auto.span\";\n+\n+  protected final Tracer tracer;\n+\n+  public HttpServerTracer() {\n+    tracer = OpenTelemetry.getTracerProvider().get(getInstrumentationName(), getVersion());\n+  }\n+\n+  public Span startSpan(REQUEST request, Method origin, String originType) {\n+    if (getAttachedSpan(request) != null) {\n+      return null;\n+    }\n+\n+    final Span.Builder builder =\n+        tracer\n+            .spanBuilder(spanNameForMethod(origin))\n+            .setSpanKind(SERVER)\n+            .setParent(extract(request, getGetter()))\n+            // TODO Where span.origin.type is defined?\n+            .setAttribute(\"span.origin.type\", originType);\n+\n+    Span span = builder.startSpan();\n+    onConnection(span, request);\n+    onRequest(span, request);\n+\n+    return span;\n+  }\n+\n+  protected abstract String getVersion();\n+\n+  protected abstract String getInstrumentationName();\n+\n+  protected void onConnection(Span span, REQUEST request) {\n+    SemanticAttributes.NET_PEER_IP.set(span, peerHostIP(request));\n+    final Integer port = peerPort(request);\n+    // Negative or Zero ports might represent an unset/null value for an int type.  Skip setting.\n+    if (port != null && port > 0) {\n+      SemanticAttributes.NET_PEER_PORT.set(span, port);\n+    }\n+  }\n+\n+  // TODO use semantic attributes\n+  protected void onRequest(final Span span, final REQUEST request) {\n+    attachSpanToRequest(span, request);\n+    SemanticAttributes.HTTP_METHOD.set(span, method(request));\n+\n+    // Copy of HttpClientDecorator url handling\n+    try {\n+      final URI url = url(request);\n+      if (url != null) {\n+        final StringBuilder urlBuilder = new StringBuilder();\n+        if (url.getScheme() != null) {\n+          urlBuilder.append(url.getScheme());\n+          urlBuilder.append(\"://\");\n+        }\n+        if (url.getHost() != null) {\n+          urlBuilder.append(url.getHost());\n+          if (url.getPort() > 0 && url.getPort() != 80 && url.getPort() != 443) {\n+            urlBuilder.append(\":\");\n+            urlBuilder.append(url.getPort());\n+          }\n+        }\n+        final String path = url.getPath();\n+        if (path.isEmpty()) {\n+          urlBuilder.append(\"/\");\n+        } else {\n+          urlBuilder.append(path);\n+        }\n+        final String query = url.getQuery();\n+        if (query != null) {\n+          urlBuilder.append(\"?\").append(query);\n+        }\n+        final String fragment = url.getFragment();\n+        if (fragment != null) {\n+          urlBuilder.append(\"#\").append(fragment);\n+        }\n+\n+        span.setAttribute(Tags.HTTP_URL, urlBuilder.toString());\n+\n+        if (Config.get().isHttpServerTagQueryString()) {\n+          span.setAttribute(MoreTags.HTTP_QUERY, url.getQuery());\n+          span.setAttribute(MoreTags.HTTP_FRAGMENT, url.getFragment());\n+        }\n+      }\n+    } catch (final Exception e) {\n+      log.debug(\"Error tagging url\", e);\n+    }\n+    // TODO set resource name from URL.\n+  }\n+\n+  public boolean sameTrace(Span oneSpan, Span otherSpan) {\n+    return oneSpan.getContext().getTraceId().equals(otherSpan.getContext().getTraceId());\n+  }\n+\n+  /**\n+   * This method is used to generate an acceptable span (operation) name based on a given method\n+   * reference. Anonymous classes are named based on their parent.\n+   */\n+  protected String spanNameForMethod(final Method method) {\n+    return spanNameForClass(method.getDeclaringClass()) + \".\" + method.getName();\n+  }\n+\n+  /**\n+   * This method is used to generate an acceptable span (operation) name based on a given class\n+   * reference. Anonymous classes are named based on their parent.\n+   */\n+  public String spanNameForClass(final Class clazz) {\n+    if (!clazz.isAnonymousClass()) {\n+      return clazz.getSimpleName();\n+    }\n+    String className = clazz.getName();\n+    if (clazz.getPackage() != null) {\n+      final String pkgName = clazz.getPackage().getName();\n+      if (!pkgName.isEmpty()) {\n+        className = clazz.getName().replace(pkgName, \"\").substring(1);\n+      }\n+    }\n+    return className;\n+  }\n+\n+  protected void onError(final Span span, final Throwable throwable) {\n+    addThrowable(span, unwrapThrowable(throwable));\n+  }\n+\n+  // TODO semantic attributes\n+  public static void addThrowable(final Span span, final Throwable throwable) {\n+    span.setAttribute(MoreTags.ERROR_MSG, throwable.getMessage());\n+    span.setAttribute(MoreTags.ERROR_TYPE, throwable.getClass().getName());\n+\n+    final StringWriter errorString = new StringWriter();\n+    throwable.printStackTrace(new PrintWriter(errorString));\n+    span.setAttribute(MoreTags.ERROR_STACK, errorString.toString());\n+  }\n+\n+  public Span getCurrentSpan() {\n+    return tracer.getCurrentSpan();\n+  }\n+\n+  public Scope newScope(Span span) {\n+    return tracer.withSpan(span);\n+  }\n+\n+  // TODO should end methods remove SPAN attribute from request as well?\n+  public void end(Span span, Scope scope, int responseCode) {\n+    if (scope == null) {\n+      return;\n+    }\n+\n+    if (span != null) {\n+      end(span, responseCode);\n+    }\n+\n+    scope.close();\n+  }\n+\n+  public void end(Span span, int responseStatus) {\n+    setStatus(span, responseStatus);\n+    span.end();\n+  }\n+\n+  public void endExceptionally(Span span, Scope scope, Throwable throwable, int responseStatus) {\n+    if (scope == null) {\n+      return;\n+    }\n+\n+    if (span != null) {\n+      endExceptionally(span, throwable, responseStatus);\n+    }\n+\n+    scope.close();\n+  }\n+\n+  public void endExceptionally(Span span, Throwable throwable, int responseStatus) {\n+    if (responseStatus == 200) {\n+      // TODO I think this is wrong.\n+      // We must report that response status that was actually sent to end user\n+      // We may change span status, but not http_status attribute\n+      responseStatus = 500;\n+    }\n+    setStatus(span, responseStatus);\n+    onError(span, unwrapThrowable(throwable));\n+    span.end();\n+  }\n+\n+  protected Throwable unwrapThrowable(Throwable throwable) {\n+    return throwable instanceof ExecutionException ? throwable.getCause() : throwable;\n+  }\n+\n+  private <C> SpanContext extract(final C carrier, final HttpTextFormat.Getter<C> getter) {\n+    final Context context =\n+        getPropagators().getHttpTextFormat().extract(Context.current(), carrier, getter);\n+    final Span span = getSpan(context);\n+    return span.getContext();\n+  }\n+\n+  private void setStatus(Span span, int status) {\n+    SemanticAttributes.HTTP_STATUS_CODE.set(span, status);\n+    // TODO status_message\n+    if (Config.get().getHttpServerErrorStatuses().get(status)) {\n+      span.setStatus(Status.UNKNOWN);\n+    }\n+  }\n+\n+  protected abstract Integer peerPort(REQUEST request);\n+\n+  protected abstract String peerHostIP(REQUEST request);\n+\n+  protected abstract HttpTextFormat.Getter<REQUEST> getGetter();\n+\n+  protected abstract URI url(REQUEST request) throws URISyntaxException;\n+\n+  protected abstract String method(REQUEST request);\n+\n+  protected abstract void attachSpanToRequest(Span span, REQUEST request);", "originalCommit": "3c9a8066c178138e6b0ff1c3ed5759750db5e3d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExNTczNw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/469#discussion_r436115737", "bodyText": "same comment as above\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              protected abstract Span getAttachedSpan(REQUEST request);\n          \n          \n            \n              protected Span getAttachedSpan(REQUEST request) {\n          \n          \n            \n                return null;\n          \n          \n            \n              }", "author": "trask", "createdAt": "2020-06-05T19:14:50Z", "path": "agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/HttpServerTracer.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.opentelemetry.auto.bootstrap.instrumentation.decorator;\n+\n+import static io.opentelemetry.OpenTelemetry.getPropagators;\n+import static io.opentelemetry.trace.Span.Kind.SERVER;\n+import static io.opentelemetry.trace.TracingContextUtils.getSpan;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.auto.config.Config;\n+import io.opentelemetry.auto.instrumentation.api.MoreTags;\n+import io.opentelemetry.auto.instrumentation.api.Tags;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.Tracer;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.reflect.Method;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import lombok.extern.slf4j.Slf4j;\n+\n+// TODO In search for a better home package\n+@Slf4j\n+public abstract class HttpServerTracer<REQUEST> {\n+  public static final String SPAN_ATTRIBUTE = \"io.opentelemetry.auto.span\";\n+\n+  protected final Tracer tracer;\n+\n+  public HttpServerTracer() {\n+    tracer = OpenTelemetry.getTracerProvider().get(getInstrumentationName(), getVersion());\n+  }\n+\n+  public Span startSpan(REQUEST request, Method origin, String originType) {\n+    if (getAttachedSpan(request) != null) {\n+      return null;\n+    }\n+\n+    final Span.Builder builder =\n+        tracer\n+            .spanBuilder(spanNameForMethod(origin))\n+            .setSpanKind(SERVER)\n+            .setParent(extract(request, getGetter()))\n+            // TODO Where span.origin.type is defined?\n+            .setAttribute(\"span.origin.type\", originType);\n+\n+    Span span = builder.startSpan();\n+    onConnection(span, request);\n+    onRequest(span, request);\n+\n+    return span;\n+  }\n+\n+  protected abstract String getVersion();\n+\n+  protected abstract String getInstrumentationName();\n+\n+  protected void onConnection(Span span, REQUEST request) {\n+    SemanticAttributes.NET_PEER_IP.set(span, peerHostIP(request));\n+    final Integer port = peerPort(request);\n+    // Negative or Zero ports might represent an unset/null value for an int type.  Skip setting.\n+    if (port != null && port > 0) {\n+      SemanticAttributes.NET_PEER_PORT.set(span, port);\n+    }\n+  }\n+\n+  // TODO use semantic attributes\n+  protected void onRequest(final Span span, final REQUEST request) {\n+    attachSpanToRequest(span, request);\n+    SemanticAttributes.HTTP_METHOD.set(span, method(request));\n+\n+    // Copy of HttpClientDecorator url handling\n+    try {\n+      final URI url = url(request);\n+      if (url != null) {\n+        final StringBuilder urlBuilder = new StringBuilder();\n+        if (url.getScheme() != null) {\n+          urlBuilder.append(url.getScheme());\n+          urlBuilder.append(\"://\");\n+        }\n+        if (url.getHost() != null) {\n+          urlBuilder.append(url.getHost());\n+          if (url.getPort() > 0 && url.getPort() != 80 && url.getPort() != 443) {\n+            urlBuilder.append(\":\");\n+            urlBuilder.append(url.getPort());\n+          }\n+        }\n+        final String path = url.getPath();\n+        if (path.isEmpty()) {\n+          urlBuilder.append(\"/\");\n+        } else {\n+          urlBuilder.append(path);\n+        }\n+        final String query = url.getQuery();\n+        if (query != null) {\n+          urlBuilder.append(\"?\").append(query);\n+        }\n+        final String fragment = url.getFragment();\n+        if (fragment != null) {\n+          urlBuilder.append(\"#\").append(fragment);\n+        }\n+\n+        span.setAttribute(Tags.HTTP_URL, urlBuilder.toString());\n+\n+        if (Config.get().isHttpServerTagQueryString()) {\n+          span.setAttribute(MoreTags.HTTP_QUERY, url.getQuery());\n+          span.setAttribute(MoreTags.HTTP_FRAGMENT, url.getFragment());\n+        }\n+      }\n+    } catch (final Exception e) {\n+      log.debug(\"Error tagging url\", e);\n+    }\n+    // TODO set resource name from URL.\n+  }\n+\n+  public boolean sameTrace(Span oneSpan, Span otherSpan) {\n+    return oneSpan.getContext().getTraceId().equals(otherSpan.getContext().getTraceId());\n+  }\n+\n+  /**\n+   * This method is used to generate an acceptable span (operation) name based on a given method\n+   * reference. Anonymous classes are named based on their parent.\n+   */\n+  protected String spanNameForMethod(final Method method) {\n+    return spanNameForClass(method.getDeclaringClass()) + \".\" + method.getName();\n+  }\n+\n+  /**\n+   * This method is used to generate an acceptable span (operation) name based on a given class\n+   * reference. Anonymous classes are named based on their parent.\n+   */\n+  public String spanNameForClass(final Class clazz) {\n+    if (!clazz.isAnonymousClass()) {\n+      return clazz.getSimpleName();\n+    }\n+    String className = clazz.getName();\n+    if (clazz.getPackage() != null) {\n+      final String pkgName = clazz.getPackage().getName();\n+      if (!pkgName.isEmpty()) {\n+        className = clazz.getName().replace(pkgName, \"\").substring(1);\n+      }\n+    }\n+    return className;\n+  }\n+\n+  protected void onError(final Span span, final Throwable throwable) {\n+    addThrowable(span, unwrapThrowable(throwable));\n+  }\n+\n+  // TODO semantic attributes\n+  public static void addThrowable(final Span span, final Throwable throwable) {\n+    span.setAttribute(MoreTags.ERROR_MSG, throwable.getMessage());\n+    span.setAttribute(MoreTags.ERROR_TYPE, throwable.getClass().getName());\n+\n+    final StringWriter errorString = new StringWriter();\n+    throwable.printStackTrace(new PrintWriter(errorString));\n+    span.setAttribute(MoreTags.ERROR_STACK, errorString.toString());\n+  }\n+\n+  public Span getCurrentSpan() {\n+    return tracer.getCurrentSpan();\n+  }\n+\n+  public Scope newScope(Span span) {\n+    return tracer.withSpan(span);\n+  }\n+\n+  // TODO should end methods remove SPAN attribute from request as well?\n+  public void end(Span span, Scope scope, int responseCode) {\n+    if (scope == null) {\n+      return;\n+    }\n+\n+    if (span != null) {\n+      end(span, responseCode);\n+    }\n+\n+    scope.close();\n+  }\n+\n+  public void end(Span span, int responseStatus) {\n+    setStatus(span, responseStatus);\n+    span.end();\n+  }\n+\n+  public void endExceptionally(Span span, Scope scope, Throwable throwable, int responseStatus) {\n+    if (scope == null) {\n+      return;\n+    }\n+\n+    if (span != null) {\n+      endExceptionally(span, throwable, responseStatus);\n+    }\n+\n+    scope.close();\n+  }\n+\n+  public void endExceptionally(Span span, Throwable throwable, int responseStatus) {\n+    if (responseStatus == 200) {\n+      // TODO I think this is wrong.\n+      // We must report that response status that was actually sent to end user\n+      // We may change span status, but not http_status attribute\n+      responseStatus = 500;\n+    }\n+    setStatus(span, responseStatus);\n+    onError(span, unwrapThrowable(throwable));\n+    span.end();\n+  }\n+\n+  protected Throwable unwrapThrowable(Throwable throwable) {\n+    return throwable instanceof ExecutionException ? throwable.getCause() : throwable;\n+  }\n+\n+  private <C> SpanContext extract(final C carrier, final HttpTextFormat.Getter<C> getter) {\n+    final Context context =\n+        getPropagators().getHttpTextFormat().extract(Context.current(), carrier, getter);\n+    final Span span = getSpan(context);\n+    return span.getContext();\n+  }\n+\n+  private void setStatus(Span span, int status) {\n+    SemanticAttributes.HTTP_STATUS_CODE.set(span, status);\n+    // TODO status_message\n+    if (Config.get().getHttpServerErrorStatuses().get(status)) {\n+      span.setStatus(Status.UNKNOWN);\n+    }\n+  }\n+\n+  protected abstract Integer peerPort(REQUEST request);\n+\n+  protected abstract String peerHostIP(REQUEST request);\n+\n+  protected abstract HttpTextFormat.Getter<REQUEST> getGetter();\n+\n+  protected abstract URI url(REQUEST request) throws URISyntaxException;\n+\n+  protected abstract String method(REQUEST request);\n+\n+  protected abstract void attachSpanToRequest(Span span, REQUEST request);\n+\n+  protected abstract Span getAttachedSpan(REQUEST request);", "originalCommit": "3c9a8066c178138e6b0ff1c3ed5759750db5e3d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f5de279642b809346eec8923f22fa2988f74adfc", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/f5de279642b809346eec8923f22fa2988f74adfc", "message": "Apply suggestions from code review\n\nCo-authored-by: Trask Stalnaker <trask.stalnaker@gmail.com>", "committedDate": "2020-06-05T19:38:37Z", "type": "commit"}, {"oid": "b81bf1a1371148fd51a602116f27cb345ba96b25", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/b81bf1a1371148fd51a602116f27cb345ba96b25", "message": "Update agent-bootstrap/src/main/java/io/opentelemetry/auto/bootstrap/instrumentation/decorator/HttpServerTracer.java\n\nCo-authored-by: Trask Stalnaker <trask.stalnaker@gmail.com>", "committedDate": "2020-06-05T19:38:50Z", "type": "commit"}, {"oid": "7bf6d0bcd86265a6df85400d83d8f7b902561c41", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/7bf6d0bcd86265a6df85400d83d8f7b902561c41", "message": "Polish", "committedDate": "2020-06-05T19:48:09Z", "type": "commit"}, {"oid": "7bf6d0bcd86265a6df85400d83d8f7b902561c41", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/7bf6d0bcd86265a6df85400d83d8f7b902561c41", "message": "Polish", "committedDate": "2020-06-05T19:48:09Z", "type": "forcePushed"}, {"oid": "075177c82d0518d53db237a54669e5a2b64990b0", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/075177c82d0518d53db237a54669e5a2b64990b0", "message": "Tracer does not manage scope anymore", "committedDate": "2020-06-06T10:19:13Z", "type": "commit"}, {"oid": "0d4ff029a91a7e8f0ba9bf4d24d2ffeefb141eff", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/0d4ff029a91a7e8f0ba9bf4d24d2ffeefb141eff", "message": "Merge branch 'master' into deduplicate-servlets", "committedDate": "2020-06-08T06:54:48Z", "type": "commit"}]}