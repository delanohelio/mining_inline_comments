{"pr_number": 535, "pr_title": "Add lettuce 5.2 instrumentation that uses lettuce's native tracing functionality.", "pr_createdAt": "2020-06-16T06:54:34Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/535", "timeline": [{"oid": "4ed743829e1ec4ad44c9fbe57ad238a4377a2840", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/4ed743829e1ec4ad44c9fbe57ad238a4377a2840", "message": "Copy Lettuce 5.0 to start 5.1 instrumentation", "committedDate": "2020-06-11T07:56:04Z", "type": "commit"}, {"oid": "51ae5740954ea8071eb5034b8f8aacd71e60383d", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/51ae5740954ea8071eb5034b8f8aacd71e60383d", "message": "Begin tracing adapter implementation\n\nCo-authored-by: Dustin Neray <dustin.neray@gmail.com>", "committedDate": "2020-06-11T08:25:20Z", "type": "commit"}, {"oid": "b73576bc9a373331314a50a89f654cfd2cd35b0a", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/b73576bc9a373331314a50a89f654cfd2cd35b0a", "message": "Set floor to 5.2 instead", "committedDate": "2020-06-11T08:43:56Z", "type": "commit"}, {"oid": "80fb2c551ab68c8321b756094c0131918a5dc403", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/80fb2c551ab68c8321b756094c0131918a5dc403", "message": "Move around", "committedDate": "2020-06-12T04:57:31Z", "type": "commit"}, {"oid": "87e8547d14b6ec66592f81e3fc0694d69621da7c", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/87e8547d14b6ec66592f81e3fc0694d69621da7c", "message": "Finish", "committedDate": "2020-06-16T06:44:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDczNDQ1NA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/535#discussion_r440734454", "bodyText": "Do you need this class at all?", "author": "iNikem", "createdAt": "2020-06-16T10:02:17Z", "path": "instrumentation/lettuce/lettuce-5.2/src/main/java8/io/opentelemetry/auto/instrumentation/lettuce/v5_2/LettuceClientDecorator.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.auto.instrumentation.lettuce.v5_2;\n+\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.trace.Tracer;\n+\n+// Currently don't use decorator pattern since lifecycle of lettuce Tracing is too different than\n+// what we expect.\n+public class LettuceClientDecorator {", "originalCommit": "87e8547d14b6ec66592f81e3fc0694d69621da7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE1Njk4MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/535#discussion_r441156981", "bodyText": "probably TRACER could be moved to OpenTelemetryTracing", "author": "trask", "createdAt": "2020-06-16T21:37:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDczNDQ1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDczODg3OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/535#discussion_r440738879", "bodyText": "\"this until then\"? :)", "author": "iNikem", "createdAt": "2020-06-16T10:10:02Z", "path": "instrumentation/lettuce/lettuce-5.2/src/main/java8/io/opentelemetry/auto/instrumentation/lettuce/v5_2/OpenTelemetryTracing.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.auto.instrumentation.lettuce.v5_2;\n+\n+import static io.opentelemetry.auto.instrumentation.lettuce.v5_2.LettuceClientDecorator.TRACER;\n+\n+import io.grpc.Context;\n+import io.lettuce.core.tracing.TraceContext;\n+import io.lettuce.core.tracing.TraceContextProvider;\n+import io.lettuce.core.tracing.Tracer;\n+import io.lettuce.core.tracing.TracerProvider;\n+import io.lettuce.core.tracing.Tracing;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import reactor.util.annotation.Nullable;\n+\n+public enum OpenTelemetryTracing implements Tracing {\n+  INSTANCE;\n+\n+  @Override\n+  public TracerProvider getTracerProvider() {\n+    return OpenTelemetryTracerProvider.INSTANCE;\n+  }\n+\n+  @Override\n+  public TraceContextProvider initialTraceContextProvider() {\n+    return OpenTelemetryTraceContextProvider.INSTANCE;\n+  }\n+\n+  @Override\n+  public boolean isEnabled() {\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean includeCommandArgsInSpanTags() {\n+    return true;\n+  }\n+\n+  @Override\n+  public Endpoint createEndpoint(SocketAddress socketAddress) {\n+    if (socketAddress instanceof InetSocketAddress) {\n+      InetSocketAddress address = (InetSocketAddress) socketAddress;\n+\n+      return new OpenTelemetryEndpoint(\n+          address.getAddress().getHostAddress(), address.getPort(), address.getHostString());\n+    }\n+    return null;\n+  }\n+\n+  enum OpenTelemetryTracerProvider implements TracerProvider {\n+    INSTANCE;\n+\n+    private final Tracer openTelemetryTracer = new OpenTelemetryTracer();\n+\n+    @Override\n+    public Tracer getTracer() {\n+      return openTelemetryTracer;\n+    }\n+  }\n+\n+  enum OpenTelemetryTraceContextProvider implements TraceContextProvider {\n+    INSTANCE;\n+\n+    @Override\n+    public TraceContext getTraceContext() {\n+      return new OpenTelemetryTraceContext();\n+    }\n+  }\n+\n+  static class OpenTelemetryTraceContext implements TraceContext {\n+    private final Context context;\n+\n+    protected OpenTelemetryTraceContext() {\n+      this.context = Context.current();\n+    }\n+\n+    public Context getContext() {\n+      return context;\n+    }\n+  }\n+\n+  static class OpenTelemetryEndpoint implements Endpoint {\n+    final String ip;\n+    final int port;\n+    @Nullable final String name;\n+\n+    protected OpenTelemetryEndpoint(String ip, int port, @Nullable String name) {\n+      this.ip = ip;\n+      this.port = port;\n+      if (!ip.equals(name)) {\n+        this.name = name;\n+      } else {\n+        this.name = null;\n+      }\n+    }\n+  }\n+\n+  static class OpenTelemetryTracer extends Tracer {\n+\n+    protected OpenTelemetryTracer() {}\n+\n+    @Override\n+    public OpenTelemetrySpan nextSpan() {\n+      return new OpenTelemetrySpan(null);\n+    }\n+\n+    @Override\n+    public OpenTelemetrySpan nextSpan(TraceContext traceContext) {\n+      if (!(traceContext instanceof OpenTelemetryTraceContext)) {\n+        return nextSpan();\n+      }\n+\n+      Context context = ((OpenTelemetryTraceContext) traceContext).getContext();\n+\n+      final io.opentelemetry.trace.Span parent = TracingContextUtils.getSpanWithoutDefault(context);\n+\n+      return new OpenTelemetrySpan(parent);\n+    }\n+  }\n+\n+  // The order that callbacks will be called in or which thread they are called from is not well\n+  // defined. We go ahead and buffer all data until we know we have a span. This implementation is\n+  // particularly safe, synchronizing all accesses. Relying on implementation details would allow\n+  // reducing synchronization but the impact should be minimal.\n+  static class OpenTelemetrySpan extends Tracer.Span {\n+    @Nullable private final Span parent;\n+\n+    @Nullable private OpenTelemetryEndpoint endpoint;\n+    @Nullable private String name;\n+\n+    @Nullable private List<Object> events;\n+    @Nullable private List<String> tags;\n+\n+    @Nullable private Status status;\n+\n+    @Nullable private Span span;\n+\n+    protected OpenTelemetrySpan(@Nullable Span parent) {\n+      this.parent = parent;\n+    }\n+\n+    // Called before start. We need to buffer because this until then.", "originalCommit": "87e8547d14b6ec66592f81e3fc0694d69621da7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI4MTA0OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/535#discussion_r441281049", "bodyText": "Hehe this is from when I considered taking advantage of implementation details to reduce synchronization but ended up being safe.", "author": "anuraaga", "createdAt": "2020-06-17T05:00:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDczODg3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDczOTY5Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/535#discussion_r440739697", "bodyText": "If we don't call this, then we may get a span from current Otel context, don't you think?", "author": "iNikem", "createdAt": "2020-06-16T10:11:30Z", "path": "instrumentation/lettuce/lettuce-5.2/src/main/java8/io/opentelemetry/auto/instrumentation/lettuce/v5_2/OpenTelemetryTracing.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.auto.instrumentation.lettuce.v5_2;\n+\n+import static io.opentelemetry.auto.instrumentation.lettuce.v5_2.LettuceClientDecorator.TRACER;\n+\n+import io.grpc.Context;\n+import io.lettuce.core.tracing.TraceContext;\n+import io.lettuce.core.tracing.TraceContextProvider;\n+import io.lettuce.core.tracing.Tracer;\n+import io.lettuce.core.tracing.TracerProvider;\n+import io.lettuce.core.tracing.Tracing;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import reactor.util.annotation.Nullable;\n+\n+public enum OpenTelemetryTracing implements Tracing {\n+  INSTANCE;\n+\n+  @Override\n+  public TracerProvider getTracerProvider() {\n+    return OpenTelemetryTracerProvider.INSTANCE;\n+  }\n+\n+  @Override\n+  public TraceContextProvider initialTraceContextProvider() {\n+    return OpenTelemetryTraceContextProvider.INSTANCE;\n+  }\n+\n+  @Override\n+  public boolean isEnabled() {\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean includeCommandArgsInSpanTags() {\n+    return true;\n+  }\n+\n+  @Override\n+  public Endpoint createEndpoint(SocketAddress socketAddress) {\n+    if (socketAddress instanceof InetSocketAddress) {\n+      InetSocketAddress address = (InetSocketAddress) socketAddress;\n+\n+      return new OpenTelemetryEndpoint(\n+          address.getAddress().getHostAddress(), address.getPort(), address.getHostString());\n+    }\n+    return null;\n+  }\n+\n+  enum OpenTelemetryTracerProvider implements TracerProvider {\n+    INSTANCE;\n+\n+    private final Tracer openTelemetryTracer = new OpenTelemetryTracer();\n+\n+    @Override\n+    public Tracer getTracer() {\n+      return openTelemetryTracer;\n+    }\n+  }\n+\n+  enum OpenTelemetryTraceContextProvider implements TraceContextProvider {\n+    INSTANCE;\n+\n+    @Override\n+    public TraceContext getTraceContext() {\n+      return new OpenTelemetryTraceContext();\n+    }\n+  }\n+\n+  static class OpenTelemetryTraceContext implements TraceContext {\n+    private final Context context;\n+\n+    protected OpenTelemetryTraceContext() {\n+      this.context = Context.current();\n+    }\n+\n+    public Context getContext() {\n+      return context;\n+    }\n+  }\n+\n+  static class OpenTelemetryEndpoint implements Endpoint {\n+    final String ip;\n+    final int port;\n+    @Nullable final String name;\n+\n+    protected OpenTelemetryEndpoint(String ip, int port, @Nullable String name) {\n+      this.ip = ip;\n+      this.port = port;\n+      if (!ip.equals(name)) {\n+        this.name = name;\n+      } else {\n+        this.name = null;\n+      }\n+    }\n+  }\n+\n+  static class OpenTelemetryTracer extends Tracer {\n+\n+    protected OpenTelemetryTracer() {}\n+\n+    @Override\n+    public OpenTelemetrySpan nextSpan() {\n+      return new OpenTelemetrySpan(null);\n+    }\n+\n+    @Override\n+    public OpenTelemetrySpan nextSpan(TraceContext traceContext) {\n+      if (!(traceContext instanceof OpenTelemetryTraceContext)) {\n+        return nextSpan();\n+      }\n+\n+      Context context = ((OpenTelemetryTraceContext) traceContext).getContext();\n+\n+      final io.opentelemetry.trace.Span parent = TracingContextUtils.getSpanWithoutDefault(context);\n+\n+      return new OpenTelemetrySpan(parent);\n+    }\n+  }\n+\n+  // The order that callbacks will be called in or which thread they are called from is not well\n+  // defined. We go ahead and buffer all data until we know we have a span. This implementation is\n+  // particularly safe, synchronizing all accesses. Relying on implementation details would allow\n+  // reducing synchronization but the impact should be minimal.\n+  static class OpenTelemetrySpan extends Tracer.Span {\n+    @Nullable private final Span parent;\n+\n+    @Nullable private OpenTelemetryEndpoint endpoint;\n+    @Nullable private String name;\n+\n+    @Nullable private List<Object> events;\n+    @Nullable private List<String> tags;\n+\n+    @Nullable private Status status;\n+\n+    @Nullable private Span span;\n+\n+    protected OpenTelemetrySpan(@Nullable Span parent) {\n+      this.parent = parent;\n+    }\n+\n+    // Called before start. We need to buffer because this until then.\n+    @Override\n+    public synchronized Tracer.Span name(String name) {\n+      if (span != null) {\n+        span.updateName(name);\n+      } else {\n+        this.name = name;\n+      }\n+\n+      return this;\n+    }\n+\n+    @Override\n+    public synchronized Tracer.Span remoteEndpoint(Endpoint endpoint) {\n+      if (endpoint instanceof OpenTelemetryEndpoint) {\n+        if (span != null) {\n+          fillEndpoint(span, (OpenTelemetryEndpoint) endpoint);\n+        } else {\n+          this.endpoint = (OpenTelemetryEndpoint) endpoint;\n+        }\n+      }\n+      return this;\n+    }\n+\n+    @Override\n+    public synchronized Tracer.Span start() {\n+      // If name() wasn't called yet we will update it later.\n+      String spanName = name != null ? name : \"REDIS\";\n+      Span.Builder builder = TRACER.spanBuilder(spanName).setSpanKind(Kind.CLIENT);\n+      if (parent != null) {\n+        builder.setParent(parent);\n+      } else {\n+        builder.setNoParent();", "originalCommit": "87e8547d14b6ec66592f81e3fc0694d69621da7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzNTU4Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/535#discussion_r441135583", "bodyText": "or maybe new OpenTelemetrySpan(TRACER.getCurrentSpan()) instead of new OpenTelemetrySpan(null) above to capture the parent (if there is one) earlier, and then don't need the conditional here", "author": "trask", "createdAt": "2020-06-16T20:53:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDczOTY5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI4MTYxMA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/535#discussion_r441281610", "bodyText": "Yep - I think we do want to rely on explicit context propagation here since no clue what thread this is being run on (it probably won't but technically there's nothing wrong with a lettuce threadpool itself being traced by lettuce) while Lettuce provides the OpenTelemetryTracer SPI as the place to determine parent. So went with @trask's suggestion.", "author": "anuraaga", "createdAt": "2020-06-17T05:02:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDczOTY5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc0MTM2OA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/535#discussion_r440741368", "bodyText": "Reading javadoc, it seems to be that UNKNOWN suits better here?", "author": "iNikem", "createdAt": "2020-06-16T10:14:31Z", "path": "instrumentation/lettuce/lettuce-5.2/src/main/java8/io/opentelemetry/auto/instrumentation/lettuce/v5_2/OpenTelemetryTracing.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.auto.instrumentation.lettuce.v5_2;\n+\n+import static io.opentelemetry.auto.instrumentation.lettuce.v5_2.LettuceClientDecorator.TRACER;\n+\n+import io.grpc.Context;\n+import io.lettuce.core.tracing.TraceContext;\n+import io.lettuce.core.tracing.TraceContextProvider;\n+import io.lettuce.core.tracing.Tracer;\n+import io.lettuce.core.tracing.TracerProvider;\n+import io.lettuce.core.tracing.Tracing;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import reactor.util.annotation.Nullable;\n+\n+public enum OpenTelemetryTracing implements Tracing {\n+  INSTANCE;\n+\n+  @Override\n+  public TracerProvider getTracerProvider() {\n+    return OpenTelemetryTracerProvider.INSTANCE;\n+  }\n+\n+  @Override\n+  public TraceContextProvider initialTraceContextProvider() {\n+    return OpenTelemetryTraceContextProvider.INSTANCE;\n+  }\n+\n+  @Override\n+  public boolean isEnabled() {\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean includeCommandArgsInSpanTags() {\n+    return true;\n+  }\n+\n+  @Override\n+  public Endpoint createEndpoint(SocketAddress socketAddress) {\n+    if (socketAddress instanceof InetSocketAddress) {\n+      InetSocketAddress address = (InetSocketAddress) socketAddress;\n+\n+      return new OpenTelemetryEndpoint(\n+          address.getAddress().getHostAddress(), address.getPort(), address.getHostString());\n+    }\n+    return null;\n+  }\n+\n+  enum OpenTelemetryTracerProvider implements TracerProvider {\n+    INSTANCE;\n+\n+    private final Tracer openTelemetryTracer = new OpenTelemetryTracer();\n+\n+    @Override\n+    public Tracer getTracer() {\n+      return openTelemetryTracer;\n+    }\n+  }\n+\n+  enum OpenTelemetryTraceContextProvider implements TraceContextProvider {\n+    INSTANCE;\n+\n+    @Override\n+    public TraceContext getTraceContext() {\n+      return new OpenTelemetryTraceContext();\n+    }\n+  }\n+\n+  static class OpenTelemetryTraceContext implements TraceContext {\n+    private final Context context;\n+\n+    protected OpenTelemetryTraceContext() {\n+      this.context = Context.current();\n+    }\n+\n+    public Context getContext() {\n+      return context;\n+    }\n+  }\n+\n+  static class OpenTelemetryEndpoint implements Endpoint {\n+    final String ip;\n+    final int port;\n+    @Nullable final String name;\n+\n+    protected OpenTelemetryEndpoint(String ip, int port, @Nullable String name) {\n+      this.ip = ip;\n+      this.port = port;\n+      if (!ip.equals(name)) {\n+        this.name = name;\n+      } else {\n+        this.name = null;\n+      }\n+    }\n+  }\n+\n+  static class OpenTelemetryTracer extends Tracer {\n+\n+    protected OpenTelemetryTracer() {}\n+\n+    @Override\n+    public OpenTelemetrySpan nextSpan() {\n+      return new OpenTelemetrySpan(null);\n+    }\n+\n+    @Override\n+    public OpenTelemetrySpan nextSpan(TraceContext traceContext) {\n+      if (!(traceContext instanceof OpenTelemetryTraceContext)) {\n+        return nextSpan();\n+      }\n+\n+      Context context = ((OpenTelemetryTraceContext) traceContext).getContext();\n+\n+      final io.opentelemetry.trace.Span parent = TracingContextUtils.getSpanWithoutDefault(context);\n+\n+      return new OpenTelemetrySpan(parent);\n+    }\n+  }\n+\n+  // The order that callbacks will be called in or which thread they are called from is not well\n+  // defined. We go ahead and buffer all data until we know we have a span. This implementation is\n+  // particularly safe, synchronizing all accesses. Relying on implementation details would allow\n+  // reducing synchronization but the impact should be minimal.\n+  static class OpenTelemetrySpan extends Tracer.Span {\n+    @Nullable private final Span parent;\n+\n+    @Nullable private OpenTelemetryEndpoint endpoint;\n+    @Nullable private String name;\n+\n+    @Nullable private List<Object> events;\n+    @Nullable private List<String> tags;\n+\n+    @Nullable private Status status;\n+\n+    @Nullable private Span span;\n+\n+    protected OpenTelemetrySpan(@Nullable Span parent) {\n+      this.parent = parent;\n+    }\n+\n+    // Called before start. We need to buffer because this until then.\n+    @Override\n+    public synchronized Tracer.Span name(String name) {\n+      if (span != null) {\n+        span.updateName(name);\n+      } else {\n+        this.name = name;\n+      }\n+\n+      return this;\n+    }\n+\n+    @Override\n+    public synchronized Tracer.Span remoteEndpoint(Endpoint endpoint) {\n+      if (endpoint instanceof OpenTelemetryEndpoint) {\n+        if (span != null) {\n+          fillEndpoint(span, (OpenTelemetryEndpoint) endpoint);\n+        } else {\n+          this.endpoint = (OpenTelemetryEndpoint) endpoint;\n+        }\n+      }\n+      return this;\n+    }\n+\n+    @Override\n+    public synchronized Tracer.Span start() {\n+      // If name() wasn't called yet we will update it later.\n+      String spanName = name != null ? name : \"REDIS\";\n+      Span.Builder builder = TRACER.spanBuilder(spanName).setSpanKind(Kind.CLIENT);\n+      if (parent != null) {\n+        builder.setParent(parent);\n+      } else {\n+        builder.setNoParent();\n+      }\n+\n+      builder.setAttribute(SemanticAttributes.DB_TYPE.key(), \"redis\");\n+\n+      span = builder.startSpan();\n+\n+      if (endpoint != null) {\n+        fillEndpoint(span, endpoint);\n+        endpoint = null;\n+      }\n+\n+      if (events != null) {\n+        for (int i = 0; i < events.size(); i += 2) {\n+          span.addEvent((String) events.get(i), (long) events.get(i + 1));\n+        }\n+        events = null;\n+      }\n+\n+      if (tags != null) {\n+        for (int i = 0; i < tags.size(); i += 2) {\n+          span.setAttribute(tags.get(i), tags.get(i + 1));\n+        }\n+        tags = null;\n+      }\n+\n+      if (status != null) {\n+        span.setStatus(status);\n+        status = null;\n+      }\n+\n+      return this;\n+    }\n+\n+    @Override\n+    public synchronized Tracer.Span annotate(String value) {\n+      if (span != null) {\n+        span.addEvent(value);\n+      } else {\n+        if (events == null) {\n+          events = new ArrayList<>();\n+        }\n+        events.add(value);\n+        final Instant now = Instant.now();\n+        events.add(TimeUnit.SECONDS.toNanos(now.getEpochSecond()) + now.getNano());\n+      }\n+      return this;\n+    }\n+\n+    @Override\n+    public synchronized Tracer.Span tag(String key, String value) {\n+      key = translateTagKey(key);\n+      if (span != null) {\n+        span.setAttribute(key, value);\n+      } else {\n+        if (tags == null) {\n+          tags = new ArrayList<>();\n+        }\n+        tags.add(key);\n+        tags.add(value);\n+      }\n+      return this;\n+    }\n+\n+    @Override\n+    public synchronized Tracer.Span error(Throwable throwable) {\n+      // TODO(anuraaga): Check if any lettuce exceptions map well to a Status and try mapping.\n+      final Status status =\n+          Status.INTERNAL.withDescription(throwable.getClass() + \": \" + throwable.getMessage());", "originalCommit": "87e8547d14b6ec66592f81e3fc0694d69621da7c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE1ODU2OA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/535#discussion_r441158568", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return new OpenTelemetrySpan(null);\n          \n          \n            \n                  return new OpenTelemetrySpan(TRACER.getCurrentSpan());", "author": "trask", "createdAt": "2020-06-16T21:41:36Z", "path": "instrumentation/lettuce/lettuce-5.2/src/main/java8/io/opentelemetry/auto/instrumentation/lettuce/v5_2/OpenTelemetryTracing.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.auto.instrumentation.lettuce.v5_2;\n+\n+import static io.opentelemetry.auto.instrumentation.lettuce.v5_2.LettuceClientDecorator.TRACER;\n+\n+import io.grpc.Context;\n+import io.lettuce.core.tracing.TraceContext;\n+import io.lettuce.core.tracing.TraceContextProvider;\n+import io.lettuce.core.tracing.Tracer;\n+import io.lettuce.core.tracing.TracerProvider;\n+import io.lettuce.core.tracing.Tracing;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import reactor.util.annotation.Nullable;\n+\n+public enum OpenTelemetryTracing implements Tracing {\n+  INSTANCE;\n+\n+  @Override\n+  public TracerProvider getTracerProvider() {\n+    return OpenTelemetryTracerProvider.INSTANCE;\n+  }\n+\n+  @Override\n+  public TraceContextProvider initialTraceContextProvider() {\n+    return OpenTelemetryTraceContextProvider.INSTANCE;\n+  }\n+\n+  @Override\n+  public boolean isEnabled() {\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean includeCommandArgsInSpanTags() {\n+    return true;\n+  }\n+\n+  @Override\n+  public Endpoint createEndpoint(SocketAddress socketAddress) {\n+    if (socketAddress instanceof InetSocketAddress) {\n+      InetSocketAddress address = (InetSocketAddress) socketAddress;\n+\n+      return new OpenTelemetryEndpoint(\n+          address.getAddress().getHostAddress(), address.getPort(), address.getHostString());\n+    }\n+    return null;\n+  }\n+\n+  enum OpenTelemetryTracerProvider implements TracerProvider {\n+    INSTANCE;\n+\n+    private final Tracer openTelemetryTracer = new OpenTelemetryTracer();\n+\n+    @Override\n+    public Tracer getTracer() {\n+      return openTelemetryTracer;\n+    }\n+  }\n+\n+  enum OpenTelemetryTraceContextProvider implements TraceContextProvider {\n+    INSTANCE;\n+\n+    @Override\n+    public TraceContext getTraceContext() {\n+      return new OpenTelemetryTraceContext();\n+    }\n+  }\n+\n+  static class OpenTelemetryTraceContext implements TraceContext {\n+    private final Context context;\n+\n+    protected OpenTelemetryTraceContext() {\n+      this.context = Context.current();\n+    }\n+\n+    public Context getContext() {\n+      return context;\n+    }\n+  }\n+\n+  static class OpenTelemetryEndpoint implements Endpoint {\n+    final String ip;\n+    final int port;\n+    @Nullable final String name;\n+\n+    protected OpenTelemetryEndpoint(String ip, int port, @Nullable String name) {\n+      this.ip = ip;\n+      this.port = port;\n+      if (!ip.equals(name)) {\n+        this.name = name;\n+      } else {\n+        this.name = null;\n+      }\n+    }\n+  }\n+\n+  static class OpenTelemetryTracer extends Tracer {\n+\n+    protected OpenTelemetryTracer() {}\n+\n+    @Override\n+    public OpenTelemetrySpan nextSpan() {\n+      return new OpenTelemetrySpan(null);", "originalCommit": "87e8547d14b6ec66592f81e3fc0694d69621da7c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE2OTI1MA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/535#discussion_r441169250", "bodyText": "what do u think about replacing parent, endpoint, name and tags with Span.Builder?", "author": "trask", "createdAt": "2020-06-16T22:07:03Z", "path": "instrumentation/lettuce/lettuce-5.2/src/main/java8/io/opentelemetry/auto/instrumentation/lettuce/v5_2/OpenTelemetryTracing.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.auto.instrumentation.lettuce.v5_2;\n+\n+import static io.opentelemetry.auto.instrumentation.lettuce.v5_2.LettuceClientDecorator.TRACER;\n+\n+import io.grpc.Context;\n+import io.lettuce.core.tracing.TraceContext;\n+import io.lettuce.core.tracing.TraceContextProvider;\n+import io.lettuce.core.tracing.Tracer;\n+import io.lettuce.core.tracing.TracerProvider;\n+import io.lettuce.core.tracing.Tracing;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Status;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import reactor.util.annotation.Nullable;\n+\n+public enum OpenTelemetryTracing implements Tracing {\n+  INSTANCE;\n+\n+  @Override\n+  public TracerProvider getTracerProvider() {\n+    return OpenTelemetryTracerProvider.INSTANCE;\n+  }\n+\n+  @Override\n+  public TraceContextProvider initialTraceContextProvider() {\n+    return OpenTelemetryTraceContextProvider.INSTANCE;\n+  }\n+\n+  @Override\n+  public boolean isEnabled() {\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean includeCommandArgsInSpanTags() {\n+    return true;\n+  }\n+\n+  @Override\n+  public Endpoint createEndpoint(SocketAddress socketAddress) {\n+    if (socketAddress instanceof InetSocketAddress) {\n+      InetSocketAddress address = (InetSocketAddress) socketAddress;\n+\n+      return new OpenTelemetryEndpoint(\n+          address.getAddress().getHostAddress(), address.getPort(), address.getHostString());\n+    }\n+    return null;\n+  }\n+\n+  enum OpenTelemetryTracerProvider implements TracerProvider {\n+    INSTANCE;\n+\n+    private final Tracer openTelemetryTracer = new OpenTelemetryTracer();\n+\n+    @Override\n+    public Tracer getTracer() {\n+      return openTelemetryTracer;\n+    }\n+  }\n+\n+  enum OpenTelemetryTraceContextProvider implements TraceContextProvider {\n+    INSTANCE;\n+\n+    @Override\n+    public TraceContext getTraceContext() {\n+      return new OpenTelemetryTraceContext();\n+    }\n+  }\n+\n+  static class OpenTelemetryTraceContext implements TraceContext {\n+    private final Context context;\n+\n+    protected OpenTelemetryTraceContext() {\n+      this.context = Context.current();\n+    }\n+\n+    public Context getContext() {\n+      return context;\n+    }\n+  }\n+\n+  static class OpenTelemetryEndpoint implements Endpoint {\n+    final String ip;\n+    final int port;\n+    @Nullable final String name;\n+\n+    protected OpenTelemetryEndpoint(String ip, int port, @Nullable String name) {\n+      this.ip = ip;\n+      this.port = port;\n+      if (!ip.equals(name)) {\n+        this.name = name;\n+      } else {\n+        this.name = null;\n+      }\n+    }\n+  }\n+\n+  static class OpenTelemetryTracer extends Tracer {\n+\n+    protected OpenTelemetryTracer() {}\n+\n+    @Override\n+    public OpenTelemetrySpan nextSpan() {\n+      return new OpenTelemetrySpan(null);\n+    }\n+\n+    @Override\n+    public OpenTelemetrySpan nextSpan(TraceContext traceContext) {\n+      if (!(traceContext instanceof OpenTelemetryTraceContext)) {\n+        return nextSpan();\n+      }\n+\n+      Context context = ((OpenTelemetryTraceContext) traceContext).getContext();\n+\n+      final io.opentelemetry.trace.Span parent = TracingContextUtils.getSpanWithoutDefault(context);\n+\n+      return new OpenTelemetrySpan(parent);\n+    }\n+  }\n+\n+  // The order that callbacks will be called in or which thread they are called from is not well\n+  // defined. We go ahead and buffer all data until we know we have a span. This implementation is\n+  // particularly safe, synchronizing all accesses. Relying on implementation details would allow\n+  // reducing synchronization but the impact should be minimal.\n+  static class OpenTelemetrySpan extends Tracer.Span {\n+    @Nullable private final Span parent;\n+\n+    @Nullable private OpenTelemetryEndpoint endpoint;\n+    @Nullable private String name;\n+\n+    @Nullable private List<Object> events;\n+    @Nullable private List<String> tags;", "originalCommit": "87e8547d14b6ec66592f81e3fc0694d69621da7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI4NDUyOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/535#discussion_r441284529", "bodyText": "Unfortunately had to keep name since spanBuilder doesn't allow setting it, and some awkwardness for endpoint, but it seems to still be worth it.", "author": "anuraaga", "createdAt": "2020-06-17T05:13:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE2OTI1MA=="}], "type": "inlineReview"}, {"oid": "7cdf7ecbf8c555e339220c2507f3e75453f3d8e4", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/7cdf7ecbf8c555e339220c2507f3e75453f3d8e4", "message": "Cleanups", "committedDate": "2020-06-17T05:50:56Z", "type": "commit"}, {"oid": "36b141e9cca5910746e1b389ca2e7d153b5436f5", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/36b141e9cca5910746e1b389ca2e7d153b5436f5", "message": "Instrument 5.1+ instead", "committedDate": "2020-06-17T06:25:03Z", "type": "commit"}, {"oid": "5fab23d0b1d171973b1eec353a2c1193ca9d5601", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/5fab23d0b1d171973b1eec353a2c1193ca9d5601", "message": "Cleanup", "committedDate": "2020-06-17T07:24:43Z", "type": "commit"}, {"oid": "d8ee86fa2cf866c06d1850419a2f5b5ef9c3324b", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/d8ee86fa2cf866c06d1850419a2f5b5ef9c3324b", "message": "5.1", "committedDate": "2020-06-17T07:30:31Z", "type": "commit"}, {"oid": "e516d1ad6bacbde9da1bc6caf2332d916e2e0457", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/e516d1ad6bacbde9da1bc6caf2332d916e2e0457", "message": "Remove latestDepTest from lettuce-5.0 since we have a newer lettuce-5.1.", "committedDate": "2020-06-17T08:06:19Z", "type": "commit"}, {"oid": "09a2b49f96e5a2391fb2818448bce06010677c95", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/09a2b49f96e5a2391fb2818448bce06010677c95", "message": "Remove", "committedDate": "2020-06-17T08:10:18Z", "type": "commit"}, {"oid": "3faa4dea420b8144dcf0ad6564ba72e127ecc82c", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/3faa4dea420b8144dcf0ad6564ba72e127ecc82c", "message": "Remove package check", "committedDate": "2020-06-18T05:26:33Z", "type": "commit"}, {"oid": "8b5e8c78be855b28f03b228091d46bfb9c4ccd69", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/8b5e8c78be855b28f03b228091d46bfb9c4ccd69", "message": "Spotless", "committedDate": "2020-06-18T06:46:31Z", "type": "commit"}, {"oid": "8595dd87b12eff137e730779645636d9dcfd6f9e", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/8595dd87b12eff137e730779645636d9dcfd6f9e", "message": "Merge branch 'master' into lettuce-51", "committedDate": "2020-06-18T08:05:49Z", "type": "commit"}]}