{"pr_number": 1397, "pr_title": "apache camel 2.20.x instrumentation", "pr_createdAt": "2020-10-15T11:00:09Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ2MDM0OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505460349", "bodyText": "You don't need advices in helperClassNames()", "author": "mateuszrzeszutek", "createdAt": "2020-10-15T11:16:08Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/instrumentation/auto/apachecamel/CamelContextInstrumentation.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.apachecamel;\n+\n+import static io.opentelemetry.javaagent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.implementsInterface;\n+import static net.bytebuddy.matcher.ElementMatchers.isAbstract;\n+import static net.bytebuddy.matcher.ElementMatchers.isPublic;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.not;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.apache.camel.CamelContext;\n+\n+@AutoService(Instrumenter.class)\n+public class CamelContextInstrumentation extends Instrumenter.Default {\n+\n+  public CamelContextInstrumentation() {\n+    super(\"apachecamel\", \"apache-camel\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\"org.apache.camel.CamelContext\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+\n+    return not(isAbstract()).and(implementsInterface(named(\"org.apache.camel.CamelContext\")));\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      getClass().getName() + \"$ContextAdvice\",", "originalCommit": "abb947614a28a92f1329d99d58bc97c753e95779", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY5NjkyOA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505696928", "bodyText": "\ud83d\ude46\u200d\u2642\ufe0f", "author": "kubawach", "createdAt": "2020-10-15T16:56:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ2MDM0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ2MDg0MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505460841", "bodyText": "Nitpicking: why not just \"camel\"?", "author": "mateuszrzeszutek", "createdAt": "2020-10-15T11:17:07Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/instrumentation/auto/apachecamel/CamelContextInstrumentation.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.apachecamel;\n+\n+import static io.opentelemetry.javaagent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.implementsInterface;\n+import static net.bytebuddy.matcher.ElementMatchers.isAbstract;\n+import static net.bytebuddy.matcher.ElementMatchers.isPublic;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.not;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.apache.camel.CamelContext;\n+\n+@AutoService(Instrumenter.class)\n+public class CamelContextInstrumentation extends Instrumenter.Default {\n+\n+  public CamelContextInstrumentation() {\n+    super(\"apachecamel\", \"apache-camel\");", "originalCommit": "abb947614a28a92f1329d99d58bc97c753e95779", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY5NzU4Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505697586", "bodyText": "In source lib authors always used \"apache camel\" not just \"camel\". I guess it's a matter of full, proper naming - ther eare many camels, but only one by apache ;)", "author": "kubawach", "createdAt": "2020-10-15T16:57:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ2MDg0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ2MTE1NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505461155", "bodyText": "Nitpicking again (\ud83d\ude04 ): how about just Collections.singletonMap()?", "author": "mateuszrzeszutek", "createdAt": "2020-10-15T11:17:46Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/instrumentation/auto/apachecamel/CamelContextInstrumentation.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.apachecamel;\n+\n+import static io.opentelemetry.javaagent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static io.opentelemetry.javaagent.tooling.bytebuddy.matcher.AgentElementMatchers.implementsInterface;\n+import static net.bytebuddy.matcher.ElementMatchers.isAbstract;\n+import static net.bytebuddy.matcher.ElementMatchers.isPublic;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.not;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import io.opentelemetry.javaagent.tooling.Instrumenter;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.apache.camel.CamelContext;\n+\n+@AutoService(Instrumenter.class)\n+public class CamelContextInstrumentation extends Instrumenter.Default {\n+\n+  public CamelContextInstrumentation() {\n+    super(\"apachecamel\", \"apache-camel\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\"org.apache.camel.CamelContext\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+\n+    return not(isAbstract()).and(implementsInterface(named(\"org.apache.camel.CamelContext\")));\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      getClass().getName() + \"$ContextAdvice\",\n+      \"io.opentelemetry.instrumentation.auto.apachecamel.SpanDecorator\",\n+      \"io.opentelemetry.instrumentation.auto.apachecamel.decorators.BaseSpanDecorator\",\n+      \"io.opentelemetry.instrumentation.auto.apachecamel.decorators.DbSpanDecorator\",\n+      \"io.opentelemetry.instrumentation.auto.apachecamel.decorators.MessagingSpanDecorator\",\n+      \"io.opentelemetry.instrumentation.auto.apachecamel.decorators.HttpSpanDecorator\",\n+      \"io.opentelemetry.instrumentation.auto.apachecamel.decorators.InternalSpanDecorator\",\n+      \"io.opentelemetry.instrumentation.auto.apachecamel.decorators.KafkaSpanDecorator\",\n+      \"io.opentelemetry.instrumentation.auto.apachecamel.decorators.LogSpanDecorator\",\n+      \"io.opentelemetry.instrumentation.auto.apachecamel.decorators.RestSpanDecorator\",\n+      \"io.opentelemetry.instrumentation.auto.apachecamel.decorators.TimerSpanDecorator\",\n+      \"io.opentelemetry.instrumentation.auto.apachecamel.decorators.DecoratorRegistry\",\n+      \"io.opentelemetry.instrumentation.auto.apachecamel.ActiveSpanManager\",\n+      \"io.opentelemetry.instrumentation.auto.apachecamel.ActiveSpanManager$SpanWithScope\",\n+      \"io.opentelemetry.instrumentation.auto.apachecamel.CamelPropagationUtil\",\n+      \"io.opentelemetry.instrumentation.auto.apachecamel.CamelPropagationUtil$MapGetter\",\n+      \"io.opentelemetry.instrumentation.auto.apachecamel.CamelPropagationUtil$MapSetter\",\n+      \"io.opentelemetry.instrumentation.auto.apachecamel.CamelTracer\",\n+      \"io.opentelemetry.instrumentation.auto.apachecamel.CamelEventNotifier\",\n+      \"io.opentelemetry.instrumentation.auto.apachecamel.CamelRoutePolicy\",\n+      \"io.opentelemetry.instrumentation.auto.apachecamel.CamelTracingService\",\n+      \"io.opentelemetry.instrumentation.auto.apachecamel.CamelContextInstrumentation\"\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();", "originalCommit": "abb947614a28a92f1329d99d58bc97c753e95779", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY5ODY1Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505698657", "bodyText": "That's actually not that NITpicking - done.", "author": "kubawach", "createdAt": "2020-10-15T16:59:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ2MTE1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ2Mjc4OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505462789", "bodyText": "The package naming convention has changed recently, please rename this to io.opentelemetry.javaagent.instrumentation.apachecamel", "author": "mateuszrzeszutek", "createdAt": "2020-10-15T11:20:53Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/instrumentation/auto/apachecamel/CamelTracingService.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.apachecamel;", "originalCommit": "abb947614a28a92f1329d99d58bc97c753e95779", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcwNzEyMA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505707120", "bodyText": "It had to be really recently \ud83d\ude03", "author": "kubawach", "createdAt": "2020-10-15T17:12:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ2Mjc4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ2NTYzMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505465631", "bodyText": "Consider adding @Nullable to parent", "author": "mateuszrzeszutek", "createdAt": "2020-10-15T11:26:22Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/instrumentation/auto/apachecamel/ActiveSpanManager.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.apachecamel;\n+/*\n+ * Includes work from:\n+ * Copyright Apache Camel Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.Span;\n+import org.apache.camel.Exchange;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** Utility class for managing active spans as a stack associated with an exchange. */\n+class ActiveSpanManager {\n+\n+  private static final String ACTIVE_SPAN_PROPERTY = \"OpenTelemetry.activeSpan\";\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(ActiveSpanManager.class);\n+\n+  private ActiveSpanManager() {}\n+\n+  public static Span getSpan(Exchange exchange) {\n+    SpanWithScope spanWithScope = (SpanWithScope) exchange.getProperty(ACTIVE_SPAN_PROPERTY);\n+    if (spanWithScope != null) {\n+      return spanWithScope.getSpan();\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * This method activates the supplied span for the supplied exchange. If an existing span is found\n+   * for the exchange, this will be pushed onto a stack.\n+   *\n+   * @param exchange The exchange\n+   * @param span The span\n+   */\n+  public static void activate(Exchange exchange, Span span) {\n+\n+    SpanWithScope parent = (SpanWithScope) exchange.getProperty(ACTIVE_SPAN_PROPERTY);\n+    SpanWithScope spanWithScope = SpanWithScope.activate(span, parent);\n+    exchange.setProperty(ACTIVE_SPAN_PROPERTY, spanWithScope);\n+    if (LOG.isTraceEnabled()) {\n+      LOG.trace(\"Activated span: \" + spanWithScope);\n+    }\n+  }\n+\n+  /**\n+   * This method deactivates an existing active span associated with the supplied exchange. Once\n+   * deactivated, if a parent span is found associated with the stack for the exchange, it will be\n+   * restored as the current span for that exchange.\n+   *\n+   * @param exchange The exchange\n+   */\n+  public static void deactivate(Exchange exchange) {\n+\n+    SpanWithScope spanWithScope = (SpanWithScope) exchange.getProperty(ACTIVE_SPAN_PROPERTY);\n+    if (spanWithScope != null) {\n+      spanWithScope.deactivate();\n+      exchange.setProperty(ACTIVE_SPAN_PROPERTY, spanWithScope.getParent());\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\"Deactivated span: \" + spanWithScope);\n+      }\n+    }\n+  }\n+\n+  public static class SpanWithScope {\n+    private SpanWithScope parent;", "originalCommit": "abb947614a28a92f1329d99d58bc97c753e95779", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcwNzMzNg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505707336", "bodyText": "+1", "author": "kubawach", "createdAt": "2020-10-15T17:12:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ2NTYzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ2NjMzMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505466331", "bodyText": "Camel has type-safe getProperty(String, Class<T>) variant, consider using it instead of casting.", "author": "mateuszrzeszutek", "createdAt": "2020-10-15T11:27:35Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/instrumentation/auto/apachecamel/ActiveSpanManager.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.apachecamel;\n+/*\n+ * Includes work from:\n+ * Copyright Apache Camel Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.Span;\n+import org.apache.camel.Exchange;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** Utility class for managing active spans as a stack associated with an exchange. */\n+class ActiveSpanManager {\n+\n+  private static final String ACTIVE_SPAN_PROPERTY = \"OpenTelemetry.activeSpan\";\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(ActiveSpanManager.class);\n+\n+  private ActiveSpanManager() {}\n+\n+  public static Span getSpan(Exchange exchange) {\n+    SpanWithScope spanWithScope = (SpanWithScope) exchange.getProperty(ACTIVE_SPAN_PROPERTY);\n+    if (spanWithScope != null) {\n+      return spanWithScope.getSpan();\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * This method activates the supplied span for the supplied exchange. If an existing span is found\n+   * for the exchange, this will be pushed onto a stack.\n+   *\n+   * @param exchange The exchange\n+   * @param span The span\n+   */\n+  public static void activate(Exchange exchange, Span span) {\n+\n+    SpanWithScope parent = (SpanWithScope) exchange.getProperty(ACTIVE_SPAN_PROPERTY);", "originalCommit": "abb947614a28a92f1329d99d58bc97c753e95779", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIxODQxMg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r506218412", "bodyText": "+1", "author": "kubawach", "createdAt": "2020-10-16T09:30:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ2NjMzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ2NzI4Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505467287", "bodyText": "Nitpicking: consider making it an enum singleton", "author": "mateuszrzeszutek", "createdAt": "2020-10-15T11:29:25Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/instrumentation/auto/apachecamel/CamelPropagationUtil.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.apachecamel;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.context.propagation.TextMapPropagator.Getter;\n+import io.opentelemetry.context.propagation.TextMapPropagator.Setter;\n+import java.util.Map;\n+\n+public class CamelPropagationUtil {\n+\n+  static Context extractParent(final Map<String, Object> exchangeHeaders) {\n+    return OpenTelemetry.getPropagators()\n+        .getTextMapPropagator()\n+        .extract(Context.current(), exchangeHeaders, MapGetter.INSTANCE);\n+  }\n+\n+  static void injectParent(Context context, final Map<String, Object> exchangeHeaders) {\n+    OpenTelemetry.getPropagators()\n+        .getTextMapPropagator()\n+        .inject(context, exchangeHeaders, MapSetter.INSTANCE);\n+  }\n+\n+  private static class MapGetter implements Getter<Map<String, Object>> {\n+\n+    private static final MapGetter INSTANCE = new MapGetter();", "originalCommit": "abb947614a28a92f1329d99d58bc97c753e95779", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc1NDY2NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505754665", "bodyText": "I believe that in OTEL such instances are always static finals (multiple places, really).", "author": "kubawach", "createdAt": "2020-10-15T18:28:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ2NzI4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ2NzU2NA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505467564", "bodyText": "How about making it final and adding private default constructor (since it's a util class)?", "author": "mateuszrzeszutek", "createdAt": "2020-10-15T11:29:55Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/instrumentation/auto/apachecamel/CamelPropagationUtil.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.apachecamel;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.context.propagation.TextMapPropagator.Getter;\n+import io.opentelemetry.context.propagation.TextMapPropagator.Setter;\n+import java.util.Map;\n+\n+public class CamelPropagationUtil {", "originalCommit": "abb947614a28a92f1329d99d58bc97c753e95779", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc1ODU2NA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505758564", "bodyText": "+1", "author": "kubawach", "createdAt": "2020-10-15T18:35:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ2NzU2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTUxNDc1OA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505514758", "bodyText": "Shouldn't you use span.recordException(throwable); here?", "author": "mateuszrzeszutek", "createdAt": "2020-10-15T12:51:02Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/instrumentation/auto/apachecamel/decorators/BaseSpanDecorator.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.apachecamel.decorators;\n+/*\n+ * Includes work from:\n+ * Copyright Apache Camel Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import io.opentelemetry.common.Attributes;\n+import io.opentelemetry.instrumentation.auto.apachecamel.SpanDecorator;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.util.StringHelper;\n+import org.apache.camel.util.URISupport;\n+\n+/** An abstract base implementation of the {@link SpanDecorator} interface. */\n+class BaseSpanDecorator implements SpanDecorator {\n+\n+  /**\n+   * This method removes the scheme, any leading slash characters and options from the supplied URI.\n+   * This is intended to extract a meaningful name from the URI that can be used in situations, such\n+   * as the operation name.\n+   *\n+   * @param endpoint The endpoint\n+   * @return The stripped value from the URI\n+   */\n+  public static String stripSchemeAndOptions(Endpoint endpoint) {\n+    int start = endpoint.getEndpointUri().indexOf(':');\n+    start++;\n+    // Remove any leading '/'\n+    while (endpoint.getEndpointUri().charAt(start) == '/') {\n+      start++;\n+    }\n+    int end = endpoint.getEndpointUri().indexOf('?');\n+    return end == -1\n+        ? endpoint.getEndpointUri().substring(start)\n+        : endpoint.getEndpointUri().substring(start, end);\n+  }\n+\n+  public static Map<String, String> toQueryParameters(String uri) {\n+    int index = uri.indexOf('?');\n+    if (index != -1) {\n+      String queryString = uri.substring(index + 1);\n+      Map<String, String> map = new HashMap<>();\n+      for (String param : queryString.split(\"&\")) {\n+        String[] parts = param.split(\"=\");\n+        if (parts.length == 2) {\n+          map.put(parts[0], parts[1]);\n+        }\n+      }\n+      return map;\n+    }\n+    return Collections.emptyMap();\n+  }\n+\n+  @Override\n+  public boolean shouldStartNewSpan() {\n+    return true;\n+  }\n+\n+  @Override\n+  public String getOperationName(Exchange exchange, Endpoint endpoint) {\n+    String[] splitURI = StringHelper.splitOnCharacter(endpoint.getEndpointUri(), \":\", 2);\n+    if (splitURI.length > 0) {\n+      return splitURI[0];\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void pre(Span span, Exchange exchange, Endpoint endpoint) {\n+    span.setAttribute(\"camel.uri\", URISupport.sanitizeUri(endpoint.getEndpointUri()));\n+  }\n+\n+  @Override\n+  public void post(Span span, Exchange exchange, Endpoint endpoint) {\n+    if (exchange.isFailed()) {\n+      span.setAttribute(\"error\", true);\n+      if (exchange.getException() != null) {\n+        Attributes logEvent =\n+            Attributes.newBuilder()\n+                .setAttribute(\"error.kind\", \"Exception\")\n+                .setAttribute(\"message\", exchange.getException().getMessage())\n+                .build();\n+        span.addEvent(\"error\", logEvent);", "originalCommit": "abb947614a28a92f1329d99d58bc97c753e95779", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc1NzgzOA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505757838", "bodyText": "Didn't know about that feature, nice!", "author": "kubawach", "createdAt": "2020-10-15T18:33:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTUxNDc1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU0MjM2Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505542366", "bodyText": "All parameters are the DB name?", "author": "mateuszrzeszutek", "createdAt": "2020-10-15T13:29:32Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/instrumentation/auto/apachecamel/decorators/DbSpanDecorator.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.apachecamel.decorators;\n+/*\n+ * Includes work from:\n+ * Copyright Apache Camel Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.net.URI;\n+import java.util.Map;\n+import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n+\n+class DbSpanDecorator extends BaseSpanDecorator {\n+\n+  private final String component;\n+  private final String system;\n+\n+  DbSpanDecorator(String component, String system) {\n+    this.component = component;\n+    this.system = system;\n+  }\n+\n+  @Override\n+  public String getOperationName(Exchange exchange, Endpoint endpoint) {\n+\n+    switch (component) {\n+      case \"mongodb\":\n+      case \"elasticsearch\":\n+        {\n+          Map<String, String> queryParameters = toQueryParameters(endpoint.getEndpointUri());\n+          if (queryParameters.containsKey(\"operation\")) {\n+            return queryParameters.get(\"operation\");\n+          }\n+        }\n+    }\n+    return super.getOperationName(exchange, endpoint);\n+  }\n+\n+  private String getStatement(Exchange exchange, Endpoint endpoint) {\n+    switch (component) {\n+      case \"mongodb\":\n+        {\n+          Map<String, String> queryParameters = toQueryParameters(endpoint.getEndpointUri());\n+          return queryParameters.get(\"database\");\n+        }\n+      case \"cql\":\n+        {\n+          Object cql = exchange.getIn().getHeader(\"CamelCqlQuery\");\n+          if (cql != null) {\n+            return cql.toString();\n+          } else {\n+            Map<String, String> queryParameters = toQueryParameters(endpoint.getEndpointUri());\n+            if (queryParameters.containsKey(\"cql\")) {\n+              return queryParameters.get(\"cql\");\n+            }\n+          }\n+        }\n+      case \"jdbc\":\n+        {\n+          Object body = exchange.getIn().getBody();\n+          if (body instanceof String) {\n+            return (String) body;\n+          }\n+        }\n+      case \"sql\":\n+        {\n+          Object sqlquery = exchange.getIn().getHeader(\"CamelSqlQuery\");\n+          if (sqlquery instanceof String) {\n+            return (String) sqlquery;\n+          }\n+        }\n+    }\n+    return null;\n+  }\n+\n+  private String getDbName(Endpoint endpoint) {\n+    switch (component) {\n+      case \"mongodb\":\n+        {\n+          Map<String, String> queryParameters = toQueryParameters(endpoint.getEndpointUri());\n+          return queryParameters.toString();", "originalCommit": "abb947614a28a92f1329d99d58bc97c753e95779", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIxOTg3OA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r506219878", "bodyText": "+1", "author": "kubawach", "createdAt": "2020-10-16T09:33:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU0MjM2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU0ODA0Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505548047", "bodyText": "What do you think about replacing this stuff with a regex pattern?", "author": "mateuszrzeszutek", "createdAt": "2020-10-15T13:37:11Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/instrumentation/auto/apachecamel/decorators/RestSpanDecorator.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.apachecamel.decorators;\n+/*\n+ * Includes work from:\n+ * Copyright Apache Camel Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+import io.opentelemetry.trace.Span;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class RestSpanDecorator extends HttpSpanDecorator {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(RestSpanDecorator.class);\n+\n+  protected static String getPath(String uri) {\n+    // Obtain the 'path' part of the URI format: rest://method:path[:uriTemplate]?[options]\n+    String path = null;\n+    int index = uri.indexOf(':');\n+    if (index != -1) {\n+      index = uri.indexOf(':', index + 1);\n+      if (index != -1) {\n+        path = uri.substring(index + 1);\n+        index = path.indexOf('?');\n+        if (index != -1) {\n+          path = path.substring(0, index);\n+        }", "originalCommit": "1328be6ece97aff27b9216fd3bd229195599ead6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc1ODg5OA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505758898", "bodyText": "Programmer had an issue. He decided to fix it with regexp. Now programmer had two issues.", "author": "kubawach", "createdAt": "2020-10-15T18:35:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU0ODA0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU1MjE1NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505552155", "bodyText": "These are different than attribute names in KafkaConsumerTracer and KafkaProducerTracer. And by the way, shouldn't we add semantic conventions for Kafka?", "author": "mateuszrzeszutek", "createdAt": "2020-10-15T13:42:26Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/instrumentation/auto/apachecamel/decorators/KafkaSpanDecorator.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.apachecamel.decorators;\n+/*\n+ * Includes work from:\n+ * Copyright Apache Camel Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+import io.opentelemetry.trace.Span;\n+import java.util.Map;\n+import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n+\n+class KafkaSpanDecorator extends MessagingSpanDecorator {\n+\n+  public static final String KAFKA_PARTITION_TAG = \"kafka.partition\";\n+  public static final String KAFKA_PARTITION_KEY_TAG = \"kafka.partition.key\";\n+  public static final String KAFKA_KEY_TAG = \"kafka.key\";\n+  public static final String KAFKA_OFFSET_TAG = \"kafka.offset\";", "originalCommit": "1328be6ece97aff27b9216fd3bd229195599ead6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIyMzc3Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r506223776", "bodyText": "Well, the instrumentation for Kafka was changed 3 days ago, it was hard 7 days ago to reference it :D", "author": "kubawach", "createdAt": "2020-10-16T09:37:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU1MjE1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjI1MzE4Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r506253186", "bodyText": "But yeah, let's align.", "author": "kubawach", "createdAt": "2020-10-16T10:07:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU1MjE1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU3MDY0Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505570647", "bodyText": "Is it possible to use the route for operation name? (ass suggested in semantic conventions)", "author": "mateuszrzeszutek", "createdAt": "2020-10-15T14:05:21Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/instrumentation/auto/apachecamel/decorators/HttpSpanDecorator.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.auto.apachecamel.decorators;\n+/*\n+ * Includes work from:\n+ * Copyright Apache Camel Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n+\n+class HttpSpanDecorator extends BaseSpanDecorator {\n+\n+  private static final String POST_METHOD = \"POST\";\n+  private static final String GET_METHOD = \"GET\";\n+\n+  public static String getHttpMethod(Exchange exchange, Endpoint endpoint) {\n+    // 1. Use method provided in header.\n+    Object method = exchange.getIn().getHeader(Exchange.HTTP_METHOD);\n+    if (method instanceof String) {\n+      return (String) method;\n+    }\n+\n+    // 2. GET if query string is provided in header.\n+    if (exchange.getIn().getHeader(Exchange.HTTP_QUERY) != null) {\n+      return GET_METHOD;\n+    }\n+\n+    // 3. GET if endpoint is configured with a query string.\n+    if (endpoint.getEndpointUri().indexOf('?') != -1) {\n+      return GET_METHOD;\n+    }\n+\n+    // 4. POST if there is data to send (body is not null).\n+    if (exchange.getIn().getBody() != null) {\n+      return POST_METHOD;\n+    }\n+\n+    // 5. GET otherwise.\n+    return GET_METHOD;\n+  }\n+\n+  @Override\n+  public String getOperationName(Exchange exchange, Endpoint endpoint) {\n+    // Based on HTTP component documentation:\n+    return getHttpMethod(exchange, endpoint);", "originalCommit": "1328be6ece97aff27b9216fd3bd229195599ead6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc0NzQwMg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r505747402", "bodyText": "Theoretically - yes, obviously. Practically- not that much.\n\nHttp decorator serves multiple components - ahc, http, jetty, undertow.\nComponent route can include all GET parameters (query) - would yield high cardinality\nSame decorator is used for both sides (SERVER, CLIENT) - so being conservative (always use HTTP method) won\n\nAt the same time if there is a consensus that using method in all cases is wrong, I'm open to discuss alternatives, like:\n\nadding more http decorators to handle different cases separately\nremoving query\nThis however won't allow us to eg sanitize path fragments that are values and inevitably yields high cardinality.", "author": "kubawach", "createdAt": "2020-10-15T18:17:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU3MDY0Nw=="}], "type": "inlineReview"}, {"oid": "7a7bff262b48b44feabf0644de6d7248fdfbe22f", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/7a7bff262b48b44feabf0644de6d7248fdfbe22f", "message": "code review #2 / experimental server name update", "committedDate": "2020-10-16T10:24:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc4NjUyMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r506786521", "bodyText": "I'm trying this pattern and it seems to work well to keep the copyrights together, what do you think?\nhttps://github.com/open-telemetry/opentelemetry-java/blob/master/build.gradle#L331\nAlso if the original isn't shortened I don't know if we're allowed to - IANAL but my understanding is we need to preserve the original header without modification.", "author": "anuraaga", "createdAt": "2020-10-17T03:06:35Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/javaagent/instrumentation/apachecamel/ActiveSpanManager.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.apachecamel;\n+/*\n+ * Includes work from:", "originalCommit": "7a7bff262b48b44feabf0644de6d7248fdfbe22f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ5MTU0NA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r508491544", "bodyText": "Excellent idea! Reformatted to put \"includes\" header right after our license. Also, unwinded the original one per suggestion.", "author": "kubawach", "createdAt": "2020-10-20T13:16:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc4NjUyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODcxMTg5OA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r508711898", "bodyText": "super minor...but why the extra CR here at the beginning of the method? I see this on some methods, but not all of them.", "author": "jkwatson", "createdAt": "2020-10-20T17:30:57Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/javaagent/instrumentation/apachecamel/ActiveSpanManager.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+// Includes work from:\n+/*\n+ * Apache Camel Opentracing Component\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * <p>http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * <p>Unless required by applicable law or agreed to in writing, software distributed under the\n+ * License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.apachecamel;\n+\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.Span;\n+import org.apache.camel.Exchange;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** Utility class for managing active spans as a stack associated with an exchange. */\n+class ActiveSpanManager {\n+\n+  private static final String ACTIVE_SPAN_PROPERTY = \"OpenTelemetry.activeSpan\";\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(ActiveSpanManager.class);\n+\n+  private ActiveSpanManager() {}\n+\n+  public static Span getSpan(Exchange exchange) {\n+    SpanWithScope spanWithScope = exchange.getProperty(ACTIVE_SPAN_PROPERTY, SpanWithScope.class);\n+    if (spanWithScope != null) {\n+      return spanWithScope.getSpan();\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * This method activates the supplied span for the supplied exchange. If an existing span is found\n+   * for the exchange, this will be pushed onto a stack.\n+   *\n+   * @param exchange The exchange\n+   * @param span The span\n+   */\n+  public static void activate(Exchange exchange, Span span) {\n+", "originalCommit": "a678c0826714380753504a3e66299c7cfc38ad0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk4NDM0Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r515984342", "bodyText": "Usually I add extra CR when I believe it increases readability of the code (due to long method signature). Rule of thumb frankly.", "author": "kubawach", "createdAt": "2020-11-02T13:52:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODcxMTg5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODcxNTAzNg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r508715036", "bodyText": "this method is really big. What do you think about extracting methods for each of the two branches?", "author": "jkwatson", "createdAt": "2020-10-20T17:36:23Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/javaagent/instrumentation/apachecamel/CamelEventNotifier.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+// Includes work from:\n+/*\n+ * Apache Camel Opentracing Component\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * <p>http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * <p>Unless required by applicable law or agreed to in writing, software distributed under the\n+ * License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.apachecamel;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.trace.Span;\n+import java.util.EventObject;\n+import org.apache.camel.management.event.ExchangeSendingEvent;\n+import org.apache.camel.management.event.ExchangeSentEvent;\n+import org.apache.camel.support.EventNotifierSupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+final class CamelEventNotifier extends EventNotifierSupport {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CamelEventNotifier.class);\n+\n+  @Override\n+  public void notify(EventObject event) {\n+\n+    try {\n+      /** Camel about to send (outbound). */\n+      if (event instanceof ExchangeSendingEvent) {\n+        ExchangeSendingEvent ese = (ExchangeSendingEvent) event;\n+        SpanDecorator sd = CamelTracer.TRACER.getSpanDecorator(ese.getEndpoint());\n+        if (!sd.shouldStartNewSpan()) {\n+          return;\n+        }\n+\n+        Span span =\n+            CamelTracer.TRACER.startSpan(\n+                sd.getOperationName(ese.getExchange(), ese.getEndpoint()),\n+                sd.getInitiatorSpanKind());\n+        sd.pre(span, ese.getExchange(), ese.getEndpoint(), CamelDirection.OUTBOUND);\n+        CamelPropagationUtil.injectParent(\n+            Context.current(), ese.getExchange().getIn().getHeaders());\n+        ActiveSpanManager.activate(ese.getExchange(), span);\n+\n+        if (LOG.isTraceEnabled()) {\n+          LOG.trace(\"[Exchange sending] Initiator span started \" + span);\n+        }\n+        /** Camel finished sending (outbound). Finish span and remove it from CAMEL holder. */\n+      } else if (event instanceof ExchangeSentEvent) {\n+        ExchangeSentEvent ese = (ExchangeSentEvent) event;\n+        SpanDecorator sd = CamelTracer.TRACER.getSpanDecorator(ese.getEndpoint());\n+        if (!sd.shouldStartNewSpan()) {\n+          return;\n+        }\n+        Span span = ActiveSpanManager.getSpan(ese.getExchange());\n+        if (span != null) {\n+          if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"[Exchange sent] Initiator span finished \" + span);\n+          }\n+          sd.post(span, ese.getExchange(), ese.getEndpoint());\n+          ActiveSpanManager.deactivate(ese.getExchange());\n+        } else {\n+          LOG.warn(\"Could not find managed span for exchange \" + ese.getExchange());\n+        }\n+      }\n+    } catch (Throwable t) {\n+      LOG.warn(\"Failed to capture tracing data\", t);\n+    }\n+  }", "originalCommit": "a678c0826714380753504a3e66299c7cfc38ad0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDAzNjcyNw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r510036727", "bodyText": "Done.", "author": "kubawach", "createdAt": "2020-10-22T10:01:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODcxNTAzNg=="}], "type": "inlineReview"}, {"oid": "cf28e5b441a5918c575b65ba4cf7639c845c7f20", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/cf28e5b441a5918c575b65ba4cf7639c845c7f20", "message": "rebase changes", "committedDate": "2020-10-20T19:43:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE2MDEwMA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r510160100", "bodyText": "Minor: those fields can be final", "author": "mateuszrzeszutek", "createdAt": "2020-10-22T13:27:01Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/javaagent/instrumentation/apachecamel/ActiveSpanManager.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+// Includes work from:\n+/*\n+ * Apache Camel Opentracing Component\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * <p>http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * <p>Unless required by applicable law or agreed to in writing, software distributed under the\n+ * License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.apachecamel;\n+\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.Span;\n+import org.apache.camel.Exchange;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** Utility class for managing active spans as a stack associated with an exchange. */\n+class ActiveSpanManager {\n+\n+  private static final String ACTIVE_SPAN_PROPERTY = \"OpenTelemetry.activeSpan\";\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(ActiveSpanManager.class);\n+\n+  private ActiveSpanManager() {}\n+\n+  public static Span getSpan(Exchange exchange) {\n+    SpanWithScope spanWithScope = exchange.getProperty(ACTIVE_SPAN_PROPERTY, SpanWithScope.class);\n+    if (spanWithScope != null) {\n+      return spanWithScope.getSpan();\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * This method activates the supplied span for the supplied exchange. If an existing span is found\n+   * for the exchange, this will be pushed onto a stack.\n+   *\n+   * @param exchange The exchange\n+   * @param span The span\n+   */\n+  public static void activate(Exchange exchange, Span span) {\n+\n+    SpanWithScope parent = exchange.getProperty(ACTIVE_SPAN_PROPERTY, SpanWithScope.class);\n+    SpanWithScope spanWithScope = SpanWithScope.activate(span, parent);\n+    exchange.setProperty(ACTIVE_SPAN_PROPERTY, spanWithScope);\n+    if (LOG.isTraceEnabled()) {\n+      LOG.trace(\"Activated a span: \" + spanWithScope);\n+    }\n+  }\n+\n+  /**\n+   * This method deactivates an existing active span associated with the supplied exchange. Once\n+   * deactivated, if a parent span is found associated with the stack for the exchange, it will be\n+   * restored as the current span for that exchange.\n+   *\n+   * @param exchange The exchange\n+   */\n+  public static void deactivate(Exchange exchange) {\n+\n+    SpanWithScope spanWithScope = exchange.getProperty(ACTIVE_SPAN_PROPERTY, SpanWithScope.class);\n+    if (spanWithScope != null) {\n+      spanWithScope.deactivate();\n+      exchange.setProperty(ACTIVE_SPAN_PROPERTY, spanWithScope.getParent());\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\"Deactivated span: \" + spanWithScope);\n+      }\n+    }\n+  }\n+\n+  public static class SpanWithScope {\n+    @Nullable private SpanWithScope parent;\n+    private Span span;\n+    private Scope scope;", "originalCommit": "9553c8d8da3650d64fa9644d19a6bbd6d6efeef8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk1OTk1OA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r511959958", "bodyText": "+3", "author": "kubawach", "createdAt": "2020-10-26T13:30:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE2MDEwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE2MTcyNA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r510161724", "bodyText": "You can use slf4j placeholders:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (LOG.isTraceEnabled()) {\n          \n          \n            \n                  LOG.trace(\"Activated a span: \" + spanWithScope);\n          \n          \n            \n                }\n          \n          \n            \n                LOG.trace(\"Activated a span: {}\", spanWithScope);", "author": "mateuszrzeszutek", "createdAt": "2020-10-22T13:29:10Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/javaagent/instrumentation/apachecamel/ActiveSpanManager.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+// Includes work from:\n+/*\n+ * Apache Camel Opentracing Component\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * <p>http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * <p>Unless required by applicable law or agreed to in writing, software distributed under the\n+ * License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.apachecamel;\n+\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.trace.Span;\n+import org.apache.camel.Exchange;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** Utility class for managing active spans as a stack associated with an exchange. */\n+class ActiveSpanManager {\n+\n+  private static final String ACTIVE_SPAN_PROPERTY = \"OpenTelemetry.activeSpan\";\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(ActiveSpanManager.class);\n+\n+  private ActiveSpanManager() {}\n+\n+  public static Span getSpan(Exchange exchange) {\n+    SpanWithScope spanWithScope = exchange.getProperty(ACTIVE_SPAN_PROPERTY, SpanWithScope.class);\n+    if (spanWithScope != null) {\n+      return spanWithScope.getSpan();\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * This method activates the supplied span for the supplied exchange. If an existing span is found\n+   * for the exchange, this will be pushed onto a stack.\n+   *\n+   * @param exchange The exchange\n+   * @param span The span\n+   */\n+  public static void activate(Exchange exchange, Span span) {\n+\n+    SpanWithScope parent = exchange.getProperty(ACTIVE_SPAN_PROPERTY, SpanWithScope.class);\n+    SpanWithScope spanWithScope = SpanWithScope.activate(span, parent);\n+    exchange.setProperty(ACTIVE_SPAN_PROPERTY, spanWithScope);\n+    if (LOG.isTraceEnabled()) {\n+      LOG.trace(\"Activated a span: \" + spanWithScope);\n+    }", "originalCommit": "9553c8d8da3650d64fa9644d19a6bbd6d6efeef8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE2Njc5NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r510166795", "bodyText": "Is this really needed?", "author": "mateuszrzeszutek", "createdAt": "2020-10-22T13:36:00Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/javaagent/instrumentation/apachecamel/CamelEventNotifier.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+// Includes work from:\n+/*\n+ * Apache Camel Opentracing Component\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * <p>http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * <p>Unless required by applicable law or agreed to in writing, software distributed under the\n+ * License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.apachecamel;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.trace.Span;\n+import java.util.EventObject;\n+import org.apache.camel.management.event.ExchangeSendingEvent;\n+import org.apache.camel.management.event.ExchangeSentEvent;\n+import org.apache.camel.support.EventNotifierSupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+final class CamelEventNotifier extends EventNotifierSupport {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CamelEventNotifier.class);\n+\n+  @Override\n+  public void notify(EventObject event) {\n+\n+    try {\n+      if (event instanceof ExchangeSendingEvent) {\n+        onExchangeSending((ExchangeSendingEvent) event);\n+      } else if (event instanceof ExchangeSentEvent) {\n+        onExchangeSent((ExchangeSentEvent) event);\n+      }\n+    } catch (Throwable t) {\n+      LOG.warn(\"Failed to capture tracing data\", t);\n+    }\n+  }\n+\n+  /** Camel about to send (outbound). */\n+  private void onExchangeSending(ExchangeSendingEvent event) {\n+    ExchangeSendingEvent ese = event;", "originalCommit": "9553c8d8da3650d64fa9644d19a6bbd6d6efeef8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk2MDUzMw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r511960533", "bodyText": "Nope.", "author": "kubawach", "createdAt": "2020-10-26T13:31:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE2Njc5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE3MjY2MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r510172661", "bodyText": "I don't think that span name can be null. Can you return any default string value? Like just \"Camel\"; I believe that is an edge case anyway.", "author": "mateuszrzeszutek", "createdAt": "2020-10-22T13:43:53Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/javaagent/instrumentation/apachecamel/decorators/BaseSpanDecorator.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+// Includes work from:\n+/*\n+ * Apache Camel Opentracing Component\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * <p>http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * <p>Unless required by applicable law or agreed to in writing, software distributed under the\n+ * License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.apachecamel.decorators;\n+\n+import io.opentelemetry.javaagent.instrumentation.apachecamel.CamelDirection;\n+import io.opentelemetry.javaagent.instrumentation.apachecamel.SpanDecorator;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.util.StringHelper;\n+import org.apache.camel.util.URISupport;\n+\n+/** An abstract base implementation of the {@link SpanDecorator} interface. */\n+class BaseSpanDecorator implements SpanDecorator {\n+\n+  /**\n+   * This method removes the scheme, any leading slash characters and options from the supplied URI.\n+   * This is intended to extract a meaningful name from the URI that can be used in situations, such\n+   * as the operation name.\n+   *\n+   * @param endpoint The endpoint\n+   * @return The stripped value from the URI\n+   */\n+  public static String stripSchemeAndOptions(Endpoint endpoint) {\n+    int start = endpoint.getEndpointUri().indexOf(':');\n+    start++;\n+    // Remove any leading '/'\n+    while (endpoint.getEndpointUri().charAt(start) == '/') {\n+      start++;\n+    }\n+    int end = endpoint.getEndpointUri().indexOf('?');\n+    return end == -1\n+        ? endpoint.getEndpointUri().substring(start)\n+        : endpoint.getEndpointUri().substring(start, end);\n+  }\n+\n+  public static Map<String, String> toQueryParameters(String uri) {\n+    int index = uri.indexOf('?');\n+    if (index != -1) {\n+      String queryString = uri.substring(index + 1);\n+      Map<String, String> map = new HashMap<>();\n+      for (String param : queryString.split(\"&\")) {\n+        String[] parts = param.split(\"=\");\n+        if (parts.length == 2) {\n+          map.put(parts[0], parts[1]);\n+        }\n+      }\n+      return map;\n+    }\n+    return Collections.emptyMap();\n+  }\n+\n+  @Override\n+  public boolean shouldStartNewSpan() {\n+    return true;\n+  }\n+\n+  @Override\n+  public String getOperationName(Exchange exchange, Endpoint endpoint) {\n+    String[] splitURI = StringHelper.splitOnCharacter(endpoint.getEndpointUri(), \":\", 2);\n+    if (splitURI.length > 0) {\n+      return splitURI[0];\n+    } else {\n+      return null;", "originalCommit": "9553c8d8da3650d64fa9644d19a6bbd6d6efeef8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk2MTc3Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r511961777", "bodyText": "+1", "author": "kubawach", "createdAt": "2020-10-26T13:33:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE3MjY2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE3NzY4OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r510177689", "bodyText": "I don't think that this is in accordance with the spec.\nFor the case when exchange.getException() is null (so the exchange message has a fault, whatever that means) how about you add an almost-empty exception event? Without stacktrace or anything, just a message saying that the exchange had a fault.", "author": "mateuszrzeszutek", "createdAt": "2020-10-22T13:50:25Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/javaagent/instrumentation/apachecamel/decorators/BaseSpanDecorator.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+// Includes work from:\n+/*\n+ * Apache Camel Opentracing Component\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * <p>http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * <p>Unless required by applicable law or agreed to in writing, software distributed under the\n+ * License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.apachecamel.decorators;\n+\n+import io.opentelemetry.javaagent.instrumentation.apachecamel.CamelDirection;\n+import io.opentelemetry.javaagent.instrumentation.apachecamel.SpanDecorator;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.util.StringHelper;\n+import org.apache.camel.util.URISupport;\n+\n+/** An abstract base implementation of the {@link SpanDecorator} interface. */\n+class BaseSpanDecorator implements SpanDecorator {\n+\n+  /**\n+   * This method removes the scheme, any leading slash characters and options from the supplied URI.\n+   * This is intended to extract a meaningful name from the URI that can be used in situations, such\n+   * as the operation name.\n+   *\n+   * @param endpoint The endpoint\n+   * @return The stripped value from the URI\n+   */\n+  public static String stripSchemeAndOptions(Endpoint endpoint) {\n+    int start = endpoint.getEndpointUri().indexOf(':');\n+    start++;\n+    // Remove any leading '/'\n+    while (endpoint.getEndpointUri().charAt(start) == '/') {\n+      start++;\n+    }\n+    int end = endpoint.getEndpointUri().indexOf('?');\n+    return end == -1\n+        ? endpoint.getEndpointUri().substring(start)\n+        : endpoint.getEndpointUri().substring(start, end);\n+  }\n+\n+  public static Map<String, String> toQueryParameters(String uri) {\n+    int index = uri.indexOf('?');\n+    if (index != -1) {\n+      String queryString = uri.substring(index + 1);\n+      Map<String, String> map = new HashMap<>();\n+      for (String param : queryString.split(\"&\")) {\n+        String[] parts = param.split(\"=\");\n+        if (parts.length == 2) {\n+          map.put(parts[0], parts[1]);\n+        }\n+      }\n+      return map;\n+    }\n+    return Collections.emptyMap();\n+  }\n+\n+  @Override\n+  public boolean shouldStartNewSpan() {\n+    return true;\n+  }\n+\n+  @Override\n+  public String getOperationName(Exchange exchange, Endpoint endpoint) {\n+    String[] splitURI = StringHelper.splitOnCharacter(endpoint.getEndpointUri(), \":\", 2);\n+    if (splitURI.length > 0) {\n+      return splitURI[0];\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void pre(Span span, Exchange exchange, Endpoint endpoint, CamelDirection camelDirection) {\n+    span.setAttribute(\"camel.uri\", URISupport.sanitizeUri(endpoint.getEndpointUri()));\n+  }\n+\n+  @Override\n+  public void post(Span span, Exchange exchange, Endpoint endpoint) {\n+    if (exchange.isFailed()) {\n+      span.setAttribute(\"error\", true);", "originalCommit": "9553c8d8da3650d64fa9644d19a6bbd6d6efeef8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk3NjgzMA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r511976830", "bodyText": "Digging deeper - I'll change the attribute to status (span.setStatus(StatusCanonicalCode.ERROR). Adding an exception however IMO goes against the spec that specifically describes exception (not error in general) handling. Also looking into eg BaseDecorator class we see that there is no \"empty exception\" added if throwable passed is null.", "author": "kubawach", "createdAt": "2020-10-26T13:54:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE3NzY4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE3OTg2OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r510179869", "bodyText": "We should probably mask those statements - I'm in the middle of implementing masking for all databases that don't have it, so how about you create another issue for using those in camel?", "author": "mateuszrzeszutek", "createdAt": "2020-10-22T13:53:13Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/javaagent/instrumentation/apachecamel/decorators/DbSpanDecorator.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+// Includes work from:\n+/*\n+ * Apache Camel Opentracing Component\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * <p>http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * <p>Unless required by applicable law or agreed to in writing, software distributed under the\n+ * License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.apachecamel.decorators;\n+\n+import io.opentelemetry.javaagent.instrumentation.apachecamel.CamelDirection;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.net.URI;\n+import java.util.Map;\n+import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n+\n+class DbSpanDecorator extends BaseSpanDecorator {\n+\n+  private final String component;\n+  private final String system;\n+\n+  DbSpanDecorator(String component, String system) {\n+    this.component = component;\n+    this.system = system;\n+  }\n+\n+  @Override\n+  public String getOperationName(Exchange exchange, Endpoint endpoint) {\n+\n+    switch (component) {\n+      case \"mongodb\":\n+      case \"elasticsearch\":\n+        {\n+          Map<String, String> queryParameters = toQueryParameters(endpoint.getEndpointUri());\n+          if (queryParameters.containsKey(\"operation\")) {\n+            return queryParameters.get(\"operation\");\n+          }\n+        }\n+    }\n+    return super.getOperationName(exchange, endpoint);\n+  }\n+\n+  private String getStatement(Exchange exchange, Endpoint endpoint) {\n+    switch (component) {\n+      case \"mongodb\":\n+        {\n+          Map<String, String> queryParameters = toQueryParameters(endpoint.getEndpointUri());\n+          return queryParameters.get(\"database\");\n+        }\n+      case \"cql\":\n+        {\n+          Object cql = exchange.getIn().getHeader(\"CamelCqlQuery\");\n+          if (cql != null) {\n+            return cql.toString();\n+          } else {\n+            Map<String, String> queryParameters = toQueryParameters(endpoint.getEndpointUri());\n+            if (queryParameters.containsKey(\"cql\")) {\n+              return queryParameters.get(\"cql\");\n+            }\n+          }\n+        }\n+      case \"jdbc\":\n+        {\n+          Object body = exchange.getIn().getBody();\n+          if (body instanceof String) {\n+            return (String) body;\n+          }\n+        }\n+      case \"sql\":\n+        {\n+          Object sqlquery = exchange.getIn().getHeader(\"CamelSqlQuery\");\n+          if (sqlquery instanceof String) {\n+            return (String) sqlquery;\n+          }\n+        }\n+    }\n+    return null;\n+  }\n+\n+  private String getDbName(Endpoint endpoint) {\n+    switch (component) {\n+      case \"mongodb\":\n+        {\n+          Map<String, String> queryParameters = toQueryParameters(endpoint.getEndpointUri());\n+          return queryParameters.get(\"database\");\n+        }\n+      case \"cql\":\n+        {\n+          URI uri = URI.create(endpoint.getEndpointUri());\n+          if (uri.getPath() != null && uri.getPath().length() > 0) {\n+            // Strip leading '/' from path\n+            return uri.getPath().substring(1);\n+          }\n+        }\n+      case \"elasticsearch\":\n+        {\n+          Map<String, String> queryParameters = toQueryParameters(endpoint.getEndpointUri());\n+          if (queryParameters.containsKey(\"indexName\")) {\n+            return queryParameters.get(\"indexName\");\n+          }\n+        }\n+    }\n+    return null;\n+  }\n+\n+  @Override\n+  public void pre(Span span, Exchange exchange, Endpoint endpoint, CamelDirection camelDirection) {\n+    super.pre(span, exchange, endpoint, camelDirection);\n+\n+    span.setAttribute(SemanticAttributes.DB_SYSTEM, system);\n+    String statement = getStatement(exchange, endpoint);", "originalCommit": "9553c8d8da3650d64fa9644d19a6bbd6d6efeef8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjcyNDU2NA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r512724564", "bodyText": "Yep. Good idea.", "author": "kubawach", "createdAt": "2020-10-27T14:10:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE3OTg2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjcyNzMwNw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r512727307", "bodyText": "#1499", "author": "kubawach", "createdAt": "2020-10-27T14:14:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE3OTg2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE4MDIzMw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r510180233", "bodyText": "db.name is same as db.statement?", "author": "mateuszrzeszutek", "createdAt": "2020-10-22T13:53:41Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/javaagent/instrumentation/apachecamel/decorators/DbSpanDecorator.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+// Includes work from:\n+/*\n+ * Apache Camel Opentracing Component\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * <p>http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * <p>Unless required by applicable law or agreed to in writing, software distributed under the\n+ * License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.apachecamel.decorators;\n+\n+import io.opentelemetry.javaagent.instrumentation.apachecamel.CamelDirection;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.net.URI;\n+import java.util.Map;\n+import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n+\n+class DbSpanDecorator extends BaseSpanDecorator {\n+\n+  private final String component;\n+  private final String system;\n+\n+  DbSpanDecorator(String component, String system) {\n+    this.component = component;\n+    this.system = system;\n+  }\n+\n+  @Override\n+  public String getOperationName(Exchange exchange, Endpoint endpoint) {\n+\n+    switch (component) {\n+      case \"mongodb\":\n+      case \"elasticsearch\":\n+        {\n+          Map<String, String> queryParameters = toQueryParameters(endpoint.getEndpointUri());\n+          if (queryParameters.containsKey(\"operation\")) {\n+            return queryParameters.get(\"operation\");\n+          }\n+        }\n+    }\n+    return super.getOperationName(exchange, endpoint);\n+  }\n+\n+  private String getStatement(Exchange exchange, Endpoint endpoint) {\n+    switch (component) {\n+      case \"mongodb\":\n+        {\n+          Map<String, String> queryParameters = toQueryParameters(endpoint.getEndpointUri());\n+          return queryParameters.get(\"database\");\n+        }\n+      case \"cql\":\n+        {\n+          Object cql = exchange.getIn().getHeader(\"CamelCqlQuery\");\n+          if (cql != null) {\n+            return cql.toString();\n+          } else {\n+            Map<String, String> queryParameters = toQueryParameters(endpoint.getEndpointUri());\n+            if (queryParameters.containsKey(\"cql\")) {\n+              return queryParameters.get(\"cql\");\n+            }\n+          }\n+        }\n+      case \"jdbc\":\n+        {\n+          Object body = exchange.getIn().getBody();\n+          if (body instanceof String) {\n+            return (String) body;\n+          }\n+        }\n+      case \"sql\":\n+        {\n+          Object sqlquery = exchange.getIn().getHeader(\"CamelSqlQuery\");\n+          if (sqlquery instanceof String) {\n+            return (String) sqlquery;\n+          }\n+        }\n+    }\n+    return null;\n+  }\n+\n+  private String getDbName(Endpoint endpoint) {\n+    switch (component) {\n+      case \"mongodb\":\n+        {\n+          Map<String, String> queryParameters = toQueryParameters(endpoint.getEndpointUri());\n+          return queryParameters.get(\"database\");", "originalCommit": "9553c8d8da3650d64fa9644d19a6bbd6d6efeef8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc0MDc1MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r512740751", "bodyText": "Good catch, should serialize all params for statement.", "author": "kubawach", "createdAt": "2020-10-27T14:29:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE4MDIzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDIyNTcxNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r510225715", "bodyText": "s/partition/value/", "author": "mateuszrzeszutek", "createdAt": "2020-10-22T14:50:10Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/javaagent/instrumentation/apachecamel/decorators/KafkaSpanDecorator.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+// Includes work from:\n+/*\n+ * Apache Camel Opentracing Component\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * <p>http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * <p>Unless required by applicable law or agreed to in writing, software distributed under the\n+ * License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.apachecamel.decorators;\n+\n+import io.opentelemetry.javaagent.instrumentation.apachecamel.CamelDirection;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.util.Map;\n+import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n+\n+class KafkaSpanDecorator extends MessagingSpanDecorator {\n+\n+  private static final String PARTITION_KEY = \"kafka.PARTITION_KEY\";\n+  private static final String PARTITION = \"kafka.PARTITION\";\n+  private static final String KEY = \"kafka.KEY\";\n+  private static final String TOPIC = \"kafka.TOPIC\";\n+  private static final String OFFSET = \"kafka.OFFSET\";\n+\n+  public KafkaSpanDecorator() {\n+    super(\"kafka\");\n+  }\n+\n+  @Override\n+  public String getDestination(Exchange exchange, Endpoint endpoint) {\n+    String topic = (String) exchange.getIn().getHeader(TOPIC);\n+    if (topic == null) {\n+      Map<String, String> queryParameters = toQueryParameters(endpoint.getEndpointUri());\n+      topic = queryParameters.get(\"topic\");\n+    }\n+    return topic != null ? topic : super.getDestination(exchange, endpoint);\n+  }\n+\n+  @Override\n+  public void pre(Span span, Exchange exchange, Endpoint endpoint, CamelDirection camelDirection) {\n+    super.pre(span, exchange, endpoint, camelDirection);\n+\n+    span.setAttribute(SemanticAttributes.MESSAGING_OPERATION, \"process\");\n+    span.setAttribute(SemanticAttributes.MESSAGING_DESTINATION_KIND, \"topic\");\n+\n+    String partition = getValue(exchange, PARTITION, Integer.class);\n+    if (partition != null) {\n+      span.setAttribute(\"partition\", partition);\n+    }\n+\n+    String partitionKey = (String) exchange.getIn().getHeader(PARTITION_KEY);\n+    if (partitionKey != null) {\n+      span.setAttribute(\"partitionKey\", partitionKey);\n+    }\n+\n+    String key = (String) exchange.getIn().getHeader(KEY);\n+    if (key != null) {\n+      span.setAttribute(\"key\", key);\n+    }\n+\n+    String offset = getValue(exchange, OFFSET, Long.class);\n+    if (offset != null) {\n+      span.setAttribute(\"offset\", offset);\n+    }\n+  }\n+\n+  /**\n+   * Extracts header value from the exchange for given header\n+   *\n+   * @param exchange the {@link Exchange}\n+   * @param header the header name\n+   * @param type the class type of the exchange header\n+   * @return\n+   */\n+  private <T> String getValue(final Exchange exchange, final String header, Class<T> type) {\n+    T partition = exchange.getIn().getHeader(header, type);", "originalCommit": "9553c8d8da3650d64fa9644d19a6bbd6d6efeef8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk2MjczMA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r511962730", "bodyText": "+1", "author": "kubawach", "createdAt": "2020-10-26T13:34:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDIyNTcxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDIzMjE3NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r510232175", "bodyText": "Hmm, why are you storing all the path params as attributes?", "author": "mateuszrzeszutek", "createdAt": "2020-10-22T14:58:22Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/javaagent/instrumentation/apachecamel/decorators/RestSpanDecorator.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+// Includes work from:\n+/*\n+ * Apache Camel Opentracing Component\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * <p>http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * <p>Unless required by applicable law or agreed to in writing, software distributed under the\n+ * License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.apachecamel.decorators;\n+\n+import io.opentelemetry.javaagent.instrumentation.apachecamel.CamelDirection;\n+import io.opentelemetry.trace.Span;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class RestSpanDecorator extends HttpSpanDecorator {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(RestSpanDecorator.class);\n+\n+  protected static String getPath(String uri) {\n+    // Obtain the 'path' part of the URI format: rest://method:path[:uriTemplate]?[options]\n+    String path = null;\n+    int index = uri.indexOf(':');\n+    if (index != -1) {\n+      index = uri.indexOf(':', index + 1);\n+      if (index != -1) {\n+        path = uri.substring(index + 1);\n+        index = path.indexOf('?');\n+        if (index != -1) {\n+          path = path.substring(0, index);\n+        }\n+        path = path.replaceAll(\":\", \"\");\n+        try {\n+          path = URLDecoder.decode(path, \"UTF-8\");\n+        } catch (UnsupportedEncodingException e) {\n+          LOG.debug(\"Failed to decode URL path '\" + path + \"', ignoring exception\", e);\n+        }\n+      }\n+    }\n+    return path;\n+  }\n+\n+  protected static List<String> getParameters(String path) {\n+    List<String> parameters = null;\n+\n+    int startIndex = path.indexOf('{');\n+    while (startIndex != -1) {\n+      int endIndex = path.indexOf('}', startIndex);\n+      if (endIndex != -1) {\n+        if (parameters == null) {\n+          parameters = new ArrayList<>();\n+        }\n+        parameters.add(path.substring(startIndex + 1, endIndex));\n+        startIndex = path.indexOf('{', endIndex);\n+      } else {\n+        // Break out of loop as no valid end token\n+        startIndex = -1;\n+      }\n+    }\n+\n+    return parameters == null ? Collections.emptyList() : parameters;\n+  }\n+\n+  @Override\n+  public String getOperationName(Exchange exchange, Endpoint endpoint) {\n+    return getPath(endpoint.getEndpointUri());\n+  }\n+\n+  @Override\n+  public void pre(Span span, Exchange exchange, Endpoint endpoint, CamelDirection camelDirection) {\n+    super.pre(span, exchange, endpoint, camelDirection);\n+\n+    getParameters(getPath(endpoint.getEndpointUri()))\n+        .forEach(\n+            param -> {\n+              Object value = exchange.getIn().getHeader(param);\n+              if (value != null) {\n+                span.setAttribute(param, (String) value);\n+              }\n+            });", "originalCommit": "9553c8d8da3650d64fa9644d19a6bbd6d6efeef8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk3MTQzNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r511971435", "bodyText": "This was Camel's authors decision to store all REST parameters as separate attributes. The idea behind that is a mystery for me. The question is - does this fit into our (OTEL) spec? It's clearly not \"semantic\" but may be of some benefit for customers.", "author": "kubawach", "createdAt": "2020-10-26T13:47:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDIzMjE3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA5MjA3MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r512092071", "bodyText": "All other web frameworks do not log params. Besides, the full URI is still available as http.url, right?", "author": "mateuszrzeszutek", "createdAt": "2020-10-26T16:22:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDIzMjE3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIxNTE0OA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r512215148", "bodyText": "It is - but as camel.uri. I can remove the params, the question is if a customer already using Camel instrumentation won't miss these.", "author": "kubawach", "createdAt": "2020-10-26T19:29:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDIzMjE3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDIzNTg1Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r510235852", "bodyText": "I guess that for server components (jetty, servlet, ...) it's fine to just use the path, there shouldn't be any path parameters there. But for rest component we should use the route - can you make sure that RestSpanDecorator uses the correct value here?", "author": "mateuszrzeszutek", "createdAt": "2020-10-22T15:03:08Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/javaagent/instrumentation/apachecamel/decorators/HttpSpanDecorator.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+// Includes work from:\n+/*\n+ * Apache Camel Opentracing Component\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * <p>http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * <p>Unless required by applicable law or agreed to in writing, software distributed under the\n+ * License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.apachecamel.decorators;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.instrumentation.api.tracer.BaseTracer;\n+import io.opentelemetry.javaagent.instrumentation.apachecamel.CamelDirection;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n+\n+class HttpSpanDecorator extends BaseSpanDecorator {\n+\n+  private static final String POST_METHOD = \"POST\";\n+  private static final String GET_METHOD = \"GET\";\n+\n+  public static String getHttpMethod(Exchange exchange, Endpoint endpoint) {\n+    // 1. Use method provided in header.\n+    Object method = exchange.getIn().getHeader(Exchange.HTTP_METHOD);\n+    if (method instanceof String) {\n+      return (String) method;\n+    }\n+\n+    // 2. GET if query string is provided in header.\n+    if (exchange.getIn().getHeader(Exchange.HTTP_QUERY) != null) {\n+      return GET_METHOD;\n+    }\n+\n+    // 3. GET if endpoint is configured with a query string.\n+    if (endpoint.getEndpointUri().indexOf('?') != -1) {\n+      return GET_METHOD;\n+    }\n+\n+    // 4. POST if there is data to send (body is not null).\n+    if (exchange.getIn().getBody() != null) {\n+      return POST_METHOD;\n+    }\n+\n+    // 5. GET otherwise.\n+    return GET_METHOD;\n+  }\n+\n+  @Override\n+  public String getOperationName(Exchange exchange, Endpoint endpoint) {\n+    // Based on HTTP component documentation:\n+    return getHttpMethod(exchange, endpoint);\n+  }\n+\n+  @Override\n+  public void pre(Span span, Exchange exchange, Endpoint endpoint, CamelDirection camelDirection) {\n+    super.pre(span, exchange, endpoint, camelDirection);\n+\n+    String httpUrl = getHttpURL(exchange, endpoint);\n+    if (httpUrl != null) {\n+      span.setAttribute(SemanticAttributes.HTTP_URL, httpUrl);\n+    }\n+\n+    span.setAttribute(SemanticAttributes.HTTP_METHOD, getHttpMethod(exchange, endpoint));\n+\n+    Span serverSpan = BaseTracer.CONTEXT_SERVER_SPAN_KEY.get(Context.current());\n+    if (shouldUpdateServerSpanName(serverSpan, camelDirection)) {\n+      updateServerSpanName(serverSpan, httpUrl);\n+    }\n+  }\n+\n+  private boolean shouldUpdateServerSpanName(Span serverSpan, CamelDirection camelDirection) {\n+\n+    return (serverSpan != null && CamelDirection.INBOUND.equals(camelDirection));\n+  }\n+\n+  private void updateServerSpanName(Span serverSpan, String httpUrl) {\n+    try {\n+      URL url = new URL(httpUrl);\n+      serverSpan.updateName(url.getPath());\n+    } catch (MalformedURLException e) {\n+      // ignored\n+    }", "originalCommit": "9553c8d8da3650d64fa9644d19a6bbd6d6efeef8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk2NDcwMA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r511964700", "bodyText": "It's for inbound only - so jetty, servlet, undertow, restlet server. After previous code review i decided to use path (instead of operation name). What do you mean by \"route\" then ?", "author": "kubawach", "createdAt": "2020-10-26T13:37:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDIzNTg1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA5MjcyMA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r512092720", "bodyText": "What do you mean by \"route\" then ?\n\nThe URI template, like /resource/{id}/something", "author": "mateuszrzeszutek", "createdAt": "2020-10-26T16:23:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDIzNTg1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIxNTk0Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r512215947", "bodyText": "But it is - have a look at the RestSpanDecorator - it logs \"path\" of the rest component.", "author": "kubawach", "createdAt": "2020-10-26T19:30:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDIzNTg1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDIzOTkzNw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r510239937", "bodyText": "HTTP clients should use HTTP METHOD span name:\n\nHTTP client spans SHOULD be using conservative, low cardinality names formed from the available parameters of an HTTP request, such as \"HTTP {METHOD_NAME}\".\n\nIn case of inbound spans I think using the path would be fine here.", "author": "mateuszrzeszutek", "createdAt": "2020-10-22T15:08:34Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/javaagent/instrumentation/apachecamel/decorators/HttpSpanDecorator.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+// Includes work from:\n+/*\n+ * Apache Camel Opentracing Component\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * <p>http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * <p>Unless required by applicable law or agreed to in writing, software distributed under the\n+ * License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.apachecamel.decorators;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.instrumentation.api.tracer.BaseTracer;\n+import io.opentelemetry.javaagent.instrumentation.apachecamel.CamelDirection;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n+\n+class HttpSpanDecorator extends BaseSpanDecorator {\n+\n+  private static final String POST_METHOD = \"POST\";\n+  private static final String GET_METHOD = \"GET\";\n+\n+  public static String getHttpMethod(Exchange exchange, Endpoint endpoint) {\n+    // 1. Use method provided in header.\n+    Object method = exchange.getIn().getHeader(Exchange.HTTP_METHOD);\n+    if (method instanceof String) {\n+      return (String) method;\n+    }\n+\n+    // 2. GET if query string is provided in header.\n+    if (exchange.getIn().getHeader(Exchange.HTTP_QUERY) != null) {\n+      return GET_METHOD;\n+    }\n+\n+    // 3. GET if endpoint is configured with a query string.\n+    if (endpoint.getEndpointUri().indexOf('?') != -1) {\n+      return GET_METHOD;\n+    }\n+\n+    // 4. POST if there is data to send (body is not null).\n+    if (exchange.getIn().getBody() != null) {\n+      return POST_METHOD;\n+    }\n+\n+    // 5. GET otherwise.\n+    return GET_METHOD;\n+  }\n+\n+  @Override\n+  public String getOperationName(Exchange exchange, Endpoint endpoint) {\n+    // Based on HTTP component documentation:\n+    return getHttpMethod(exchange, endpoint);", "originalCommit": "9553c8d8da3650d64fa9644d19a6bbd6d6efeef8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk4Mjc5NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r511982795", "bodyText": "Yep, we can do that, since we already update server span.", "author": "kubawach", "createdAt": "2020-10-26T14:02:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDIzOTkzNw=="}], "type": "inlineReview"}, {"oid": "4ca07f65841955813dda2c92e1e44bfdc12db906", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/4ca07f65841955813dda2c92e1e44bfdc12db906", "message": "code review changes, REST tests added", "committedDate": "2020-10-26T22:15:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDMyMDIzNA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r514320234", "bodyText": "All other classes have to be public? Or some of them can have reduce visibility?", "author": "iNikem", "createdAt": "2020-10-29T14:51:21Z", "path": "instrumentation/apache-camel-2.20/src/main/java/io/opentelemetry/javaagent/instrumentation/apachecamel/decorators/DbSpanDecorator.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+// Includes work from:\n+/*\n+ * Apache Camel Opentracing Component\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at\n+ *\n+ * <p>http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * <p>Unless required by applicable law or agreed to in writing, software distributed under the\n+ * License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.javaagent.instrumentation.apachecamel.decorators;\n+\n+import io.opentelemetry.javaagent.instrumentation.apachecamel.CamelDirection;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+import java.net.URI;\n+import java.util.Map;\n+import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n+\n+class DbSpanDecorator extends BaseSpanDecorator {", "originalCommit": "db74f28b2aec874ec7a2f90a80d3a4186e969c67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk4ODQ1Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1397#discussion_r515988453", "bodyText": "Following are public:\n\ndecorator registry (used from another package)\ndecorator interface (used from another package)\ndirection enum (used from another package)\nservice (as injected into camel code)\ninstrumentation (accessed externally)\nRest is already package-protected.", "author": "kubawach", "createdAt": "2020-11-02T13:58:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDMyMDIzNA=="}], "type": "inlineReview"}, {"oid": "fcecece016ab4e92cac25a41cd2c4d1c3c16c198", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/fcecece016ab4e92cac25a41cd2c4d1c3c16c198", "message": "apache camel 2.20.x instrumentation", "committedDate": "2020-11-02T14:20:27Z", "type": "commit"}, {"oid": "60a887b580d923ff1ac8b42c54c833f6a87bff95", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/60a887b580d923ff1ac8b42c54c833f6a87bff95", "message": "removed instrumentation advice from helper classes", "committedDate": "2020-11-02T14:20:27Z", "type": "commit"}, {"oid": "18b4e43ab600c425afce6160e54e95a1433501ea", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/18b4e43ab600c425afce6160e54e95a1433501ea", "message": "code review #1", "committedDate": "2020-11-02T14:20:27Z", "type": "commit"}, {"oid": "672e2c1b7ae736818b84c4ed6f35ff3185e6e024", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/672e2c1b7ae736818b84c4ed6f35ff3185e6e024", "message": "code review #2 / experimental server name update", "committedDate": "2020-11-02T14:20:27Z", "type": "commit"}, {"oid": "155f9f3e710c2937d9ea954f2904bd6504b648e2", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/155f9f3e710c2937d9ea954f2904bd6504b648e2", "message": "code review changes / new tests, improved direct, new license header", "committedDate": "2020-11-02T14:20:28Z", "type": "commit"}, {"oid": "80ce95dc8f9bc77bc6917647c3aefe4391028e64", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/80ce95dc8f9bc77bc6917647c3aefe4391028e64", "message": "rebase changes", "committedDate": "2020-11-02T14:20:28Z", "type": "commit"}, {"oid": "a1574361bf0ef6878c38926bf2d6347519afa0c7", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/a1574361bf0ef6878c38926bf2d6347519afa0c7", "message": "code review changes", "committedDate": "2020-11-02T14:20:28Z", "type": "commit"}, {"oid": "72e789f56f4cdc9a53a81d6973804da3c36f97c7", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/72e789f56f4cdc9a53a81d6973804da3c36f97c7", "message": "code review changes, REST tests added", "committedDate": "2020-11-02T14:20:28Z", "type": "commit"}, {"oid": "a32561c5ab8a77a0a494b1eb6d582826193f17d8", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/a32561c5ab8a77a0a494b1eb6d582826193f17d8", "message": "changes after rebase to newest master", "committedDate": "2020-11-02T14:20:28Z", "type": "commit"}, {"oid": "5c217a79c4b1aec550d13c3ebdcb13449e813dbe", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/5c217a79c4b1aec550d13c3ebdcb13449e813dbe", "message": "code review changes", "committedDate": "2020-11-02T14:20:28Z", "type": "commit"}, {"oid": "b700b3ef0371ff9ecfb75c87092a2674d1d995e3", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/b700b3ef0371ff9ecfb75c87092a2674d1d995e3", "message": "code review", "committedDate": "2020-11-02T14:20:28Z", "type": "commit"}, {"oid": "d4eeeb68eb299bde2d124033b7c3b596e91a9480", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/d4eeeb68eb299bde2d124033b7c3b596e91a9480", "message": "code review", "committedDate": "2020-11-02T14:20:28Z", "type": "commit"}, {"oid": "94bccd3cd7867dbfd4ef31e002d2dc0263a01742", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/94bccd3cd7867dbfd4ef31e002d2dc0263a01742", "message": "rebase to master", "committedDate": "2020-11-02T15:28:01Z", "type": "commit"}, {"oid": "94bccd3cd7867dbfd4ef31e002d2dc0263a01742", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/94bccd3cd7867dbfd4ef31e002d2dc0263a01742", "message": "rebase to master", "committedDate": "2020-11-02T15:28:01Z", "type": "forcePushed"}]}