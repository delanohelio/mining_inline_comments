{"pr_number": 7270, "pr_title": "Resources importer", "pr_createdAt": "2020-03-05T19:23:36Z", "pr_url": "https://github.com/cBioPortal/cbioportal/pull/7270", "timeline": [{"oid": "401e6d5055c9f2adbc485adc0abe44923e26c4cc", "url": "https://github.com/cBioPortal/cbioportal/commit/401e6d5055c9f2adbc485adc0abe44923e26c4cc", "message": "resource importer implementation", "committedDate": "2020-03-05T19:25:39Z", "type": "forcePushed"}, {"oid": "790781f7536ff8719f620d1783c759c3338934e7", "url": "https://github.com/cBioPortal/cbioportal/commit/790781f7536ff8719f620d1783c759c3338934e7", "message": "resource importer implementation", "committedDate": "2020-03-05T20:01:05Z", "type": "forcePushed"}, {"oid": "9b2242e3b46bd89411d9c121b55f195e22b6f864", "url": "https://github.com/cBioPortal/cbioportal/commit/9b2242e3b46bd89411d9c121b55f195e22b6f864", "message": "resource importer implementation", "committedDate": "2020-03-10T14:04:00Z", "type": "forcePushed"}, {"oid": "f3b76f989338af24b515934087b1985e65353f6a", "url": "https://github.com/cBioPortal/cbioportal/commit/f3b76f989338af24b515934087b1985e65353f6a", "message": "resource importer implementation", "committedDate": "2020-03-10T17:20:29Z", "type": "forcePushed"}, {"oid": "a0abfde3ef57056a1a1b2a9bc49d9b323691b0a2", "url": "https://github.com/cBioPortal/cbioportal/commit/a0abfde3ef57056a1a1b2a9bc49d9b323691b0a2", "message": "resource importer implementation", "committedDate": "2020-03-10T18:26:58Z", "type": "forcePushed"}, {"oid": "a6a6e985ef99ae2a8ad16dfc6be31cede568319b", "url": "https://github.com/cBioPortal/cbioportal/commit/a6a6e985ef99ae2a8ad16dfc6be31cede568319b", "message": "update tests", "committedDate": "2020-03-11T14:54:11Z", "type": "forcePushed"}, {"oid": "f2be70fbc3c17a4443099da9b00deecbfd0b5efb", "url": "https://github.com/cBioPortal/cbioportal/commit/f2be70fbc3c17a4443099da9b00deecbfd0b5efb", "message": "update documentation", "committedDate": "2020-03-11T18:56:42Z", "type": "forcePushed"}, {"oid": "a57f48b9fb2bdd9d61c649d3dfce425877b8bf28", "url": "https://github.com/cBioPortal/cbioportal/commit/a57f48b9fb2bdd9d61c649d3dfce425877b8bf28", "message": "update documentation", "committedDate": "2020-03-11T19:35:30Z", "type": "forcePushed"}, {"oid": "40cec718fc69678e066b4100e162f79234f7e63f", "url": "https://github.com/cBioPortal/cbioportal/commit/40cec718fc69678e066b4100e162f79234f7e63f", "message": "resource importer implementation", "committedDate": "2020-03-11T19:48:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgzMzI5Nw==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r391833297", "bodyText": "are these missing values different from some other enum already in the code? This seems like something that's not resource specific", "author": "inodb", "createdAt": "2020-03-12T19:07:05Z", "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "diffHunk": "@@ -0,0 +1,618 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+import java.util.regex.*;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections.map.MultiKeyMap;\n+\n+public class ImportResourceData extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String METADATA_PREFIX = \"#\";\n+    public static final String SAMPLE_ID_COLUMN_NAME = \"SAMPLE_ID\";\n+    public static final String PATIENT_ID_COLUMN_NAME = \"PATIENT_ID\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String URL_COLUMN_NAME = \"URL\";\n+    public static final String SAMPLE_TYPE_COLUMN_NAME = \"SAMPLE_TYPE\";\n+    private int numSampleSpecificResourcesAdded = 0;\n+    private int numPatientSpecificResourcesAdded = 0;\n+    private int numStudySpecificResourcesAdded = 0;\n+    private int numEmptyResourcesSkipped = 0;\n+    private int numSamplesProcessed = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private ResourceTypes resourceType;\n+    private boolean relaxed;\n+    private Set<String> patientIds = new HashSet<String>();\n+\n+    public static enum MissingResourceValues {\n+        NOT_APPLICABLE(\"Not Applicable\"), NOT_AVAILABLE(\"Not Available\"), PENDING(\"Pending\"),\n+        DISCREPANCY(\"Discrepancy\"), COMPLETED(\"Completed\"), NULL(\"null\"), MISSING(\"\"), NA(\"NA\");", "originalCommit": "40cec718fc69678e066b4100e162f79234f7e63f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgzNDUwMQ==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r391834501", "bodyText": "No, I borrow the same definition from the Clinical Data. I can import it from that class also.", "author": "dippindots", "createdAt": "2020-03-12T19:09:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgzMzI5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg0MTIyNA==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r391841224", "bodyText": "yeah there can maybe be some shared class with common N/A values. I do think some of these don't really look like N/A to me, e.g. Discrepancy, Pending and Completed. That seems very specific to some pipeline that we have set up", "author": "inodb", "createdAt": "2020-03-12T19:23:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgzMzI5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM3MjMyNA==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r392372324", "bodyText": "@inodb I haven't found common null values in the project, so I created one ValuesUtils.java", "author": "dippindots", "createdAt": "2020-03-13T17:31:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgzMzI5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkyOTYwNw==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r391929607", "bodyText": "I would break these lines into multiple lines", "author": "onursumer", "createdAt": "2020-03-12T22:00:49Z", "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "diffHunk": "@@ -0,0 +1,618 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+import java.util.regex.*;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections.map.MultiKeyMap;\n+\n+public class ImportResourceData extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String METADATA_PREFIX = \"#\";\n+    public static final String SAMPLE_ID_COLUMN_NAME = \"SAMPLE_ID\";\n+    public static final String PATIENT_ID_COLUMN_NAME = \"PATIENT_ID\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String URL_COLUMN_NAME = \"URL\";\n+    public static final String SAMPLE_TYPE_COLUMN_NAME = \"SAMPLE_TYPE\";\n+    private int numSampleSpecificResourcesAdded = 0;\n+    private int numPatientSpecificResourcesAdded = 0;\n+    private int numStudySpecificResourcesAdded = 0;\n+    private int numEmptyResourcesSkipped = 0;\n+    private int numSamplesProcessed = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private ResourceTypes resourceType;\n+    private boolean relaxed;\n+    private Set<String> patientIds = new HashSet<String>();\n+\n+    public static enum MissingResourceValues {\n+        NOT_APPLICABLE(\"Not Applicable\"), NOT_AVAILABLE(\"Not Available\"), PENDING(\"Pending\"),\n+        DISCREPANCY(\"Discrepancy\"), COMPLETED(\"Completed\"), NULL(\"null\"), MISSING(\"\"), NA(\"NA\");\n+\n+        private String propertyName;\n+\n+        MissingResourceValues(String propertyName) {\n+            this.propertyName = propertyName;\n+        }\n+\n+        public String toString() {\n+            return propertyName;\n+        }\n+\n+        static public boolean has(String value) {\n+            if (value == null)\n+                return false;\n+            if (value.trim().equals(\"\"))\n+                return true;\n+            try {\n+                value = value.replaceAll(\"[\\\\[|\\\\]]\", \"\");\n+                value = value.replaceAll(\" \", \"_\");\n+                return valueOf(value.toUpperCase()) != null;\n+            } catch (IllegalArgumentException x) {\n+                return false;\n+            }\n+        }\n+\n+        static public String getNotAvailable() {\n+            return \"[\" + NOT_AVAILABLE.toString() + \"]\";\n+        }\n+    }\n+\n+    public static enum ResourceTypes {\n+        PATIENT(\"PATIENT\"), SAMPLE(\"SAMPLE\"), STUDY(\"STUDY\");\n+\n+        private String resourceTypes;\n+\n+        ResourceTypes(String resourceTypes) {\n+            this.resourceTypes = resourceTypes;\n+        }\n+\n+        public String toString() {\n+            return resourceTypes;\n+        }\n+    }\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, String resourceType, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.resourceType = ResourceTypes.valueOf(resourceType);\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+        List<ResourceDefinition> resources = grabResources(buff);\n+        String currentLine = buff.readLine();\n+        String[] headerNames = currentLine.split(\"\\t\");\n+        \n+        int patientIdIndex = findPatientIdColumn(headerNames);\n+        int sampleIdIndex = findSampleIdColumn(headerNames);\n+        int resourceIdIndex = findResourceIdColumn(headerNames);\n+        int urlIndex = findURLColumn(headerNames);\n+\n+        // validate required columns:\n+        if (resourceIdIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + RESOURCE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (urlIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + URL_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if ((resourceType.toString().equalsIgnoreCase(\"sample\") || resourceType.toString().equalsIgnoreCase(\"patient\")) && patientIdIndex < 0) {\n+            // PATIENT_ID is required in both patient and sample file types:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + PATIENT_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (resourceType.toString().equalsIgnoreCase(\"sample\") && sampleIdIndex < 0) {\n+            // SAMPLE_ID is required in SAMPLE file type:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + SAMPLE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        importData(buff, resources, headerNames);\n+\n+        if (MySQLbulkLoader.isBulkLoad()) {\n+            MySQLbulkLoader.flushAll();\n+            MySQLbulkLoader.relaxedModeOff();\n+        }\n+    }\n+\n+    private List<ResourceDefinition> grabResources(BufferedReader buff) throws DaoException, IOException {\n+        List<ResourceDefinition> resources = new ArrayList<ResourceDefinition>();\n+        resources = DaoResourceDefinition.getDatumByStudy(cancerStudy.getInternalId());\n+        return resources;\n+    }\n+\n+    private String[] splitFields(String line) throws IOException {\n+        line = line.replaceAll(\"^\" + METADATA_PREFIX + \"+\", \"\");\n+        String[] fields = line.split(DELIMITER, -1);\n+\n+        return fields;\n+    }\n+\n+    private void importData(BufferedReader buff, List<ResourceDefinition> resources, String[] headerNames) throws Exception {\n+        String line;\n+        MultiKeyMap resourceMap = new MultiKeyMap();\n+        while ((line = buff.readLine()) != null) {\n+            if (skipLine(line.trim())) {\n+                continue;\n+            }\n+\n+            String[] fieldValues = getFieldValues(line, headerNames);\n+            addDatum(fieldValues, resources, resourceMap, headerNames);\n+        }\n+    }\n+\n+    private boolean skipLine(String line) {\n+        return (line.isEmpty() || line.substring(0, 1).equals(METADATA_PREFIX));\n+    }\n+\n+    /**\n+     * Takes in the given line and returns the list of field values by splitting the\n+     * line on DELIMITER.\n+     * \n+     * @param line\n+     * @param headerNames\n+     * @return the list of values, one for each column. Value will be \"\" for empty\n+     *         columns.\n+     */\n+    private String[] getFieldValues(String line, String[] headerNames) {\n+        // split on delimiter:\n+        String[] fieldValues = line.split(DELIMITER, -1);\n+\n+        // validate: if number of fields is incorrect, give exception\n+        if (fieldValues.length != headerNames.length) {\n+            throw new IllegalArgumentException(\"Number of columns in line is not as expected. Expected: \"\n+                    + headerNames.length + \" columns, found: \" + fieldValues.length + \", for line: \" + line);\n+        }\n+\n+        // now iterate over lines and trim each value:\n+        for (int i = 0; i < fieldValues.length; i++) {\n+            fieldValues[i] = fieldValues[i].trim();\n+        }\n+        return fieldValues;\n+    }\n+\n+    private boolean addDatum(String[] fields, List<ResourceDefinition> resources, MultiKeyMap resourceMap, String[] headerNames)\n+            throws Exception {\n+        int sampleIdIndex = findSampleIdColumn(headerNames);\n+        String stableSampleId = (sampleIdIndex >= 0) ? fields[sampleIdIndex] : \"\";\n+        stableSampleId = StableIdUtil.getSampleId(stableSampleId);\n+        int patientIdIndex = findPatientIdColumn(headerNames);\n+        String stablePatientId = (patientIdIndex >= 0) ? fields[patientIdIndex] : \"\";\n+        stablePatientId = StableIdUtil.getPatientId(stablePatientId);\n+        int resourceIdIndex = findResourceIdColumn(headerNames);\n+        int urlIndex = findURLColumn(headerNames);\n+        int internalSampleId = -1;\n+        int internalPatientId = -1;\n+\n+        // create resource_id set\n+        Set<String> patientResourceIdSet = resources.stream().filter(resource -> resource.getResourceType().equals(ResourceDefinition.PATIENT_RESOURCE_TYPE)).map(resource -> resource.getResourceId()).collect(Collectors.toSet());\n+        Set<String> sampleResourceIdSet = resources.stream().filter(resource -> resource.getResourceType().equals(ResourceDefinition.SAMPLE_RESOURCE_TYPE)).map(resource -> resource.getResourceId()).collect(Collectors.toSet());\n+        Set<String> studyResourceIdSet = resources.stream().filter(resource -> resource.getResourceType().equals(ResourceDefinition.STUDY_RESOURCE_TYPE)).map(resource -> resource.getResourceId()).collect(Collectors.toSet());", "originalCommit": "40cec718fc69678e066b4100e162f79234f7e63f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI1NTEwNg==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r392255106", "bodyText": "Yeah, that would be better.", "author": "dippindots", "createdAt": "2020-03-13T14:17:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkyOTYwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkzMTI3Ng==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r391931276", "bodyText": "this else block seems to complex to review", "author": "onursumer", "createdAt": "2020-03-12T22:05:23Z", "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "diffHunk": "@@ -0,0 +1,618 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+import java.util.regex.*;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections.map.MultiKeyMap;\n+\n+public class ImportResourceData extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String METADATA_PREFIX = \"#\";\n+    public static final String SAMPLE_ID_COLUMN_NAME = \"SAMPLE_ID\";\n+    public static final String PATIENT_ID_COLUMN_NAME = \"PATIENT_ID\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String URL_COLUMN_NAME = \"URL\";\n+    public static final String SAMPLE_TYPE_COLUMN_NAME = \"SAMPLE_TYPE\";\n+    private int numSampleSpecificResourcesAdded = 0;\n+    private int numPatientSpecificResourcesAdded = 0;\n+    private int numStudySpecificResourcesAdded = 0;\n+    private int numEmptyResourcesSkipped = 0;\n+    private int numSamplesProcessed = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private ResourceTypes resourceType;\n+    private boolean relaxed;\n+    private Set<String> patientIds = new HashSet<String>();\n+\n+    public static enum MissingResourceValues {\n+        NOT_APPLICABLE(\"Not Applicable\"), NOT_AVAILABLE(\"Not Available\"), PENDING(\"Pending\"),\n+        DISCREPANCY(\"Discrepancy\"), COMPLETED(\"Completed\"), NULL(\"null\"), MISSING(\"\"), NA(\"NA\");\n+\n+        private String propertyName;\n+\n+        MissingResourceValues(String propertyName) {\n+            this.propertyName = propertyName;\n+        }\n+\n+        public String toString() {\n+            return propertyName;\n+        }\n+\n+        static public boolean has(String value) {\n+            if (value == null)\n+                return false;\n+            if (value.trim().equals(\"\"))\n+                return true;\n+            try {\n+                value = value.replaceAll(\"[\\\\[|\\\\]]\", \"\");\n+                value = value.replaceAll(\" \", \"_\");\n+                return valueOf(value.toUpperCase()) != null;\n+            } catch (IllegalArgumentException x) {\n+                return false;\n+            }\n+        }\n+\n+        static public String getNotAvailable() {\n+            return \"[\" + NOT_AVAILABLE.toString() + \"]\";\n+        }\n+    }\n+\n+    public static enum ResourceTypes {\n+        PATIENT(\"PATIENT\"), SAMPLE(\"SAMPLE\"), STUDY(\"STUDY\");\n+\n+        private String resourceTypes;\n+\n+        ResourceTypes(String resourceTypes) {\n+            this.resourceTypes = resourceTypes;\n+        }\n+\n+        public String toString() {\n+            return resourceTypes;\n+        }\n+    }\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, String resourceType, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.resourceType = ResourceTypes.valueOf(resourceType);\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+        List<ResourceDefinition> resources = grabResources(buff);\n+        String currentLine = buff.readLine();\n+        String[] headerNames = currentLine.split(\"\\t\");\n+        \n+        int patientIdIndex = findPatientIdColumn(headerNames);\n+        int sampleIdIndex = findSampleIdColumn(headerNames);\n+        int resourceIdIndex = findResourceIdColumn(headerNames);\n+        int urlIndex = findURLColumn(headerNames);\n+\n+        // validate required columns:\n+        if (resourceIdIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + RESOURCE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (urlIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + URL_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if ((resourceType.toString().equalsIgnoreCase(\"sample\") || resourceType.toString().equalsIgnoreCase(\"patient\")) && patientIdIndex < 0) {\n+            // PATIENT_ID is required in both patient and sample file types:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + PATIENT_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (resourceType.toString().equalsIgnoreCase(\"sample\") && sampleIdIndex < 0) {\n+            // SAMPLE_ID is required in SAMPLE file type:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + SAMPLE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        importData(buff, resources, headerNames);\n+\n+        if (MySQLbulkLoader.isBulkLoad()) {\n+            MySQLbulkLoader.flushAll();\n+            MySQLbulkLoader.relaxedModeOff();\n+        }\n+    }\n+\n+    private List<ResourceDefinition> grabResources(BufferedReader buff) throws DaoException, IOException {\n+        List<ResourceDefinition> resources = new ArrayList<ResourceDefinition>();\n+        resources = DaoResourceDefinition.getDatumByStudy(cancerStudy.getInternalId());\n+        return resources;\n+    }\n+\n+    private String[] splitFields(String line) throws IOException {\n+        line = line.replaceAll(\"^\" + METADATA_PREFIX + \"+\", \"\");\n+        String[] fields = line.split(DELIMITER, -1);\n+\n+        return fields;\n+    }\n+\n+    private void importData(BufferedReader buff, List<ResourceDefinition> resources, String[] headerNames) throws Exception {\n+        String line;\n+        MultiKeyMap resourceMap = new MultiKeyMap();\n+        while ((line = buff.readLine()) != null) {\n+            if (skipLine(line.trim())) {\n+                continue;\n+            }\n+\n+            String[] fieldValues = getFieldValues(line, headerNames);\n+            addDatum(fieldValues, resources, resourceMap, headerNames);\n+        }\n+    }\n+\n+    private boolean skipLine(String line) {\n+        return (line.isEmpty() || line.substring(0, 1).equals(METADATA_PREFIX));\n+    }\n+\n+    /**\n+     * Takes in the given line and returns the list of field values by splitting the\n+     * line on DELIMITER.\n+     * \n+     * @param line\n+     * @param headerNames\n+     * @return the list of values, one for each column. Value will be \"\" for empty\n+     *         columns.\n+     */\n+    private String[] getFieldValues(String line, String[] headerNames) {\n+        // split on delimiter:\n+        String[] fieldValues = line.split(DELIMITER, -1);\n+\n+        // validate: if number of fields is incorrect, give exception\n+        if (fieldValues.length != headerNames.length) {\n+            throw new IllegalArgumentException(\"Number of columns in line is not as expected. Expected: \"\n+                    + headerNames.length + \" columns, found: \" + fieldValues.length + \", for line: \" + line);\n+        }\n+\n+        // now iterate over lines and trim each value:\n+        for (int i = 0; i < fieldValues.length; i++) {\n+            fieldValues[i] = fieldValues[i].trim();\n+        }\n+        return fieldValues;\n+    }\n+\n+    private boolean addDatum(String[] fields, List<ResourceDefinition> resources, MultiKeyMap resourceMap, String[] headerNames)\n+            throws Exception {\n+        int sampleIdIndex = findSampleIdColumn(headerNames);\n+        String stableSampleId = (sampleIdIndex >= 0) ? fields[sampleIdIndex] : \"\";\n+        stableSampleId = StableIdUtil.getSampleId(stableSampleId);\n+        int patientIdIndex = findPatientIdColumn(headerNames);\n+        String stablePatientId = (patientIdIndex >= 0) ? fields[patientIdIndex] : \"\";\n+        stablePatientId = StableIdUtil.getPatientId(stablePatientId);\n+        int resourceIdIndex = findResourceIdColumn(headerNames);\n+        int urlIndex = findURLColumn(headerNames);\n+        int internalSampleId = -1;\n+        int internalPatientId = -1;\n+\n+        // create resource_id set\n+        Set<String> patientResourceIdSet = resources.stream().filter(resource -> resource.getResourceType().equals(ResourceDefinition.PATIENT_RESOURCE_TYPE)).map(resource -> resource.getResourceId()).collect(Collectors.toSet());\n+        Set<String> sampleResourceIdSet = resources.stream().filter(resource -> resource.getResourceType().equals(ResourceDefinition.SAMPLE_RESOURCE_TYPE)).map(resource -> resource.getResourceId()).collect(Collectors.toSet());\n+        Set<String> studyResourceIdSet = resources.stream().filter(resource -> resource.getResourceType().equals(ResourceDefinition.STUDY_RESOURCE_TYPE)).map(resource -> resource.getResourceId()).collect(Collectors.toSet());\n+\n+        // check if sample is not already added:\n+        Sample sample = DaoSample.getSampleByCancerStudyAndSampleId(cancerStudy.getInternalId(), stableSampleId, false);\n+        if (sample != null) {\n+            // get internal sample id if sample exists\n+            internalSampleId = sample.getInternalId();\n+        } else {\n+            Patient patient = DaoPatient.getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(),\n+                    stablePatientId);\n+            if (patient != null) {\n+                // patient exists, get internal id:\n+                internalPatientId = patient.getInternalId();\n+            } else {\n+                // add patient:\n+                internalPatientId = (patientIdIndex >= 0) ? addPatientToDatabase(fields[patientIdIndex]) : -1;\n+            }\n+            // sample is new, so attempt to add to DB\n+            internalSampleId = (stableSampleId.length() > 0) ? addSampleToDatabase(stableSampleId, fields, headerNames)\n+                    : -1;\n+        }\n+\n+        // validate and count:\n+        if (internalSampleId != -1) {\n+            // some minimal validation/fail safe for now: only continue if patientId is same\n+            // as patient id in\n+            // existing sample (can occur in case of this.isSupplementalData or in case of\n+            // parsing bug in addSampleToDatabase):\n+            internalPatientId = DaoPatient\n+                    .getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(), stablePatientId).getInternalId();\n+            if (internalPatientId != DaoSample.getSampleById(internalSampleId).getInternalPatientId()) {\n+                throw new RuntimeException(\"Error: Sample \" + stableSampleId\n+                        + \" was previously linked to another patient, and not to \" + stablePatientId);\n+            }\n+            numSamplesProcessed++;\n+        }\n+\n+        // if the resource id or url matches one of the missing values, skip this resource:\n+        if ((resourceIdIndex != -1 && MissingResourceValues.has(fields[resourceIdIndex])) || (urlIndex != -1 && MissingResourceValues.has(fields[urlIndex]))) {\n+            numEmptyResourcesSkipped++;\n+        } else {", "originalCommit": "40cec718fc69678e066b4100e162f79234f7e63f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM3MDcxNA==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r392370714", "bodyText": "@onursumer I updated the solution, could you take a look if that's better?", "author": "dippindots", "createdAt": "2020-03-13T17:28:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkzMTI3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUxMTE4OA==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r392511188", "bodyText": "@dippindots looks better, thanks!", "author": "onursumer", "createdAt": "2020-03-13T22:20:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkzMTI3Ng=="}], "type": "inlineReview"}, {"oid": "e4d7e6e9eb5909cb7ebb019f68b6b13d5b33bfd4", "url": "https://github.com/cBioPortal/cbioportal/commit/e4d7e6e9eb5909cb7ebb019f68b6b13d5b33bfd4", "message": "address comments", "committedDate": "2020-03-17T16:28:50Z", "type": "forcePushed"}, {"oid": "ad5abf7c9634a54ebf671517257638ed6e6141d8", "url": "https://github.com/cBioPortal/cbioportal/commit/ad5abf7c9634a54ebf671517257638ed6e6141d8", "message": "address comments", "committedDate": "2020-03-18T20:23:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA2Nzg3NQ==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395067875", "bodyText": "note: DaoClinicalData also refers to the clinical_sample and clinical_patient tables simply as SAMPLE_TABLE and PATIENT_TABLE \ud83d\udc4d", "author": "ao508", "createdAt": "2020-03-19T14:29:04Z", "path": "core/src/main/java/org/mskcc/cbio/portal/dao/DaoResourceData.java", "diffHunk": "@@ -0,0 +1,219 @@\n+package org.mskcc.cbio.portal.dao;\n+\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.InternalIdUtil;\n+\n+import org.apache.commons.lang.StringUtils;\n+\n+import java.sql.*;\n+import java.util.*;\n+\n+/**\n+ * Data Access Object for `resource` tables\n+ */\n+public final class DaoResourceData {\n+\n+    public static final String SAMPLE_TABLE = \"resource_sample\";", "originalCommit": "ad5abf7c9634a54ebf671517257638ed6e6141d8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIyODE1NQ==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395228155", "bodyText": "I will rename them to RESOURCE_SAMPLE_TABLE and RESOURCE_PATIENT_TABLE", "author": "dippindots", "createdAt": "2020-03-19T18:16:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA2Nzg3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTEwMjg4NQ==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395102885", "bodyText": "typo pari --> pair", "author": "ao508", "createdAt": "2020-03-19T15:14:04Z", "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "diffHunk": "@@ -0,0 +1,574 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+import org.mskcc.cbio.portal.util.ValuesUtils.MissingValues;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+import java.util.regex.*;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections.map.MultiKeyMap;\n+\n+public class ImportResourceData extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String METADATA_PREFIX = \"#\";\n+    public static final String SAMPLE_ID_COLUMN_NAME = \"SAMPLE_ID\";\n+    public static final String PATIENT_ID_COLUMN_NAME = \"PATIENT_ID\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String URL_COLUMN_NAME = \"URL\";\n+    public static final String SAMPLE_TYPE_COLUMN_NAME = \"SAMPLE_TYPE\";\n+    private int numSampleSpecificResourcesAdded = 0;\n+    private int numPatientSpecificResourcesAdded = 0;\n+    private int numStudySpecificResourcesAdded = 0;\n+    private int numEmptyResourcesSkipped = 0;\n+    private int numSamplesProcessed = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private ResourceTypes resourceType;\n+    private boolean relaxed;\n+    private Set<String> patientIds = new HashSet<String>();\n+\n+    public static enum ResourceTypes {\n+        PATIENT(\"PATIENT\"), SAMPLE(\"SAMPLE\"), STUDY(\"STUDY\");\n+\n+        private String resourceTypes;\n+\n+        ResourceTypes(String resourceTypes) {\n+            this.resourceTypes = resourceTypes;\n+        }\n+\n+        public String toString() {\n+            return resourceTypes;\n+        }\n+    }\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, String resourceType, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.resourceType = ResourceTypes.valueOf(resourceType);\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+        List<ResourceDefinition> resources = grabResources(buff);\n+        String currentLine = buff.readLine();\n+        String[] headerNames = currentLine.split(\"\\t\");\n+        \n+        int patientIdIndex = findPatientIdColumn(headerNames);\n+        int sampleIdIndex = findSampleIdColumn(headerNames);\n+        int resourceIdIndex = findResourceIdColumn(headerNames);\n+        int urlIndex = findURLColumn(headerNames);\n+\n+        // validate required columns:\n+        if (resourceIdIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + RESOURCE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (urlIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + URL_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if ((resourceType.toString().equalsIgnoreCase(\"sample\") || resourceType.toString().equalsIgnoreCase(\"patient\")) && patientIdIndex < 0) {\n+            // PATIENT_ID is required in both patient and sample file types:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + PATIENT_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (resourceType.toString().equalsIgnoreCase(\"sample\") && sampleIdIndex < 0) {\n+            // SAMPLE_ID is required in SAMPLE file type:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + SAMPLE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        importData(buff, resources, headerNames);\n+\n+        if (MySQLbulkLoader.isBulkLoad()) {\n+            MySQLbulkLoader.flushAll();\n+            MySQLbulkLoader.relaxedModeOff();\n+        }\n+    }\n+\n+    private List<ResourceDefinition> grabResources(BufferedReader buff) throws DaoException, IOException {\n+        List<ResourceDefinition> resources = new ArrayList<ResourceDefinition>();\n+        resources = DaoResourceDefinition.getDatumByStudy(cancerStudy.getInternalId());\n+        return resources;\n+    }\n+\n+    private String[] splitFields(String line) throws IOException {\n+        line = line.replaceAll(\"^\" + METADATA_PREFIX + \"+\", \"\");\n+        String[] fields = line.split(DELIMITER, -1);\n+\n+        return fields;\n+    }\n+\n+    private void importData(BufferedReader buff, List<ResourceDefinition> resources, String[] headerNames) throws Exception {\n+        String line;\n+        MultiKeyMap resourceMap = new MultiKeyMap();\n+        while ((line = buff.readLine()) != null) {\n+            if (skipLine(line.trim())) {\n+                continue;\n+            }\n+\n+            String[] fieldValues = getFieldValues(line, headerNames);\n+            addDatum(fieldValues, resources, resourceMap, headerNames);\n+        }\n+    }\n+\n+    private boolean skipLine(String line) {\n+        return (line.isEmpty() || line.substring(0, 1).equals(METADATA_PREFIX));\n+    }\n+\n+    /**\n+     * Takes in the given line and returns the list of field values by splitting the\n+     * line on DELIMITER.\n+     * \n+     * @param line\n+     * @param headerNames\n+     * @return the list of values, one for each column. Value will be \"\" for empty\n+     *         columns.\n+     */\n+    private String[] getFieldValues(String line, String[] headerNames) {\n+        // split on delimiter:\n+        String[] fieldValues = line.split(DELIMITER, -1);\n+\n+        // validate: if number of fields is incorrect, give exception\n+        if (fieldValues.length != headerNames.length) {\n+            throw new IllegalArgumentException(\"Number of columns in line is not as expected. Expected: \"\n+                    + headerNames.length + \" columns, found: \" + fieldValues.length + \", for line: \" + line);\n+        }\n+\n+        // now iterate over lines and trim each value:\n+        for (int i = 0; i < fieldValues.length; i++) {\n+            fieldValues[i] = fieldValues[i].trim();\n+        }\n+        return fieldValues;\n+    }\n+\n+    private boolean addDatum(String[] fields, List<ResourceDefinition> resources, MultiKeyMap resourceMap, String[] headerNames)\n+            throws Exception {\n+        int sampleIdIndex = findSampleIdColumn(headerNames);\n+        String stableSampleId = (sampleIdIndex >= 0) ? fields[sampleIdIndex] : \"\";\n+        stableSampleId = StableIdUtil.getSampleId(stableSampleId);\n+        int patientIdIndex = findPatientIdColumn(headerNames);\n+        String stablePatientId = (patientIdIndex >= 0) ? fields[patientIdIndex] : \"\";\n+        stablePatientId = StableIdUtil.getPatientId(stablePatientId);\n+        int resourceIdIndex = findResourceIdColumn(headerNames);\n+        int urlIndex = findURLColumn(headerNames);\n+        int internalSampleId = -1;\n+        int internalPatientId = -1;\n+\n+        // create resource_id set\n+        Set<String> patientResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceDefinition.PATIENT_RESOURCE_TYPE))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+        Set<String> sampleResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceDefinition.SAMPLE_RESOURCE_TYPE))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+        Set<String> studyResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceDefinition.STUDY_RESOURCE_TYPE))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+\n+        // check if sample is not already added:\n+        Sample sample = DaoSample.getSampleByCancerStudyAndSampleId(cancerStudy.getInternalId(), stableSampleId, false);\n+        if (sample != null) {\n+            // get internal sample id if sample exists\n+            internalSampleId = sample.getInternalId();\n+        } else {\n+            Patient patient = DaoPatient.getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(),\n+                    stablePatientId);\n+            if (patient != null) {\n+                // patient exists, get internal id:\n+                internalPatientId = patient.getInternalId();\n+            } else {\n+                // add patient:\n+                internalPatientId = (patientIdIndex >= 0) ? addPatientToDatabase(fields[patientIdIndex]) : -1;\n+            }\n+            // sample is new, so attempt to add to DB\n+            internalSampleId = (stableSampleId.length() > 0) ? addSampleToDatabase(stableSampleId, fields, headerNames)\n+                    : -1;\n+        }\n+\n+        // validate and count:\n+        if (internalSampleId != -1) {\n+            // some minimal validation/fail safe for now: only continue if patientId is same\n+            // as patient id in\n+            // existing sample (can occur in case of this.isSupplementalData or in case of\n+            // parsing bug in addSampleToDatabase):\n+            internalPatientId = DaoPatient\n+                    .getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(), stablePatientId).getInternalId();\n+            if (internalPatientId != DaoSample.getSampleById(internalSampleId).getInternalPatientId()) {\n+                throw new RuntimeException(\"Error: Sample \" + stableSampleId\n+                        + \" was previously linked to another patient, and not to \" + stablePatientId);\n+            }\n+            numSamplesProcessed++;\n+        }\n+\n+        // if the resource id or url matches one of the missing values, skip this resource:\n+        if ((resourceIdIndex != -1 && MissingValues.has(fields[resourceIdIndex])) || (urlIndex != -1 && MissingValues.has(fields[urlIndex]))) {\n+            numEmptyResourcesSkipped++;\n+        } else {\n+            // if patient_id column exists and resource type is patient\n+            if (getResourceType() == ImportResourceData.ResourceTypes.PATIENT && internalPatientId != -1) {\n+                validateAddDatum(internalPatientId, stablePatientId, fields[resourceIdIndex], fields[urlIndex], \n+                        ResourceDefinition.PATIENT_RESOURCE_TYPE, patientResourceIdSet, resourceMap);\n+            } \n+            // if sample_id column exists and resource type is sample\n+            else if (getResourceType() == ImportResourceData.ResourceTypes.SAMPLE && internalSampleId != -1) {\n+                validateAddDatum(internalSampleId, stableSampleId, fields[resourceIdIndex], fields[urlIndex], \n+                        ResourceDefinition.SAMPLE_RESOURCE_TYPE, sampleResourceIdSet, resourceMap);\n+            }\n+            // if resource type is study\n+            else if (getResourceType() == ImportResourceData.ResourceTypes.STUDY) {\n+                validateAddDatum(cancerStudy.getInternalId(), cancerStudy.getCancerStudyStableId(), fields[resourceIdIndex], fields[urlIndex], \n+                        ResourceDefinition.STUDY_RESOURCE_TYPE, studyResourceIdSet, resourceMap);\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private int findPatientIdColumn(String[] headerNames) {\n+        return findColumnIndexInHeaders(PATIENT_ID_COLUMN_NAME, headerNames);\n+    }\n+\n+    private int findSampleIdColumn(String[] headerNames) {\n+        return findColumnIndexInHeaders(SAMPLE_ID_COLUMN_NAME, headerNames);\n+    }\n+\n+    private int findResourceIdColumn(String[] headerNames) {\n+        return findColumnIndexInHeaders(RESOURCE_ID_COLUMN_NAME, headerNames);\n+    }\n+\n+    private int findURLColumn(String[] headerNames) {\n+        return findColumnIndexInHeaders(URL_COLUMN_NAME, headerNames);\n+    }\n+\n+    private int findSampleTypeColumn(String[] headerNames) {\n+        return findColumnIndexInHeaders(SAMPLE_TYPE_COLUMN_NAME, headerNames);\n+    }\n+\n+    private int findColumnIndexInHeaders(String columnHeader, String[] headerNames) {\n+        for (int lc = 0; lc < headerNames.length; lc++) {\n+            if (headerNames[lc].equals(columnHeader)) {\n+                return lc;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    private int addPatientToDatabase(String patientId) throws Exception {\n+        int internalPatientId = -1;\n+        if (validPatientId(patientId)) {\n+            Patient patient = DaoPatient.getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(), patientId);\n+            // other validations:\n+            // in case of PATIENT data import, there are some special checks:\n+            if (getResourceType() == ImportResourceData.ResourceTypes.PATIENT) {\n+                // if resource data is already there, then something has gone wrong (e.g.\n+                // patient is duplicated in file), abort:\n+                if (patient != null\n+                        && DaoResourceData.getDataByPatientId(cancerStudy.getInternalId(), patientId).size() > 0) {\n+                    throw new RuntimeException(\n+                            \"Something has gone wrong. Patient \" + patientId + \" already has resource data loaded.\");\n+                }\n+                // if patient is duplicated, abort as well in this case:\n+                if (!patientIds.add(patientId)) {\n+                    throw new RuntimeException(\"Error. Patient \" + patientId + \" found to be duplicated in your file.\");\n+                }\n+            }\n+\n+            if (patient != null) {\n+                // in all cases (SAMPLE, PATIENT, or STUDY) this can be expected, so\n+                // just fetch it:\n+                internalPatientId = patient.getInternalId();\n+            } else {\n+                // in case of PATIENT data import and patient == null :\n+                if (getResourceType() == ImportResourceData.ResourceTypes.PATIENT) {\n+                    // not finding the patient it unexpected (as SAMPLE data import should always\n+                    // precede it), but\n+                    // can happen when this patient does not have any samples for example. In any\n+                    // case, warn about it:\n+                    ProgressMonitor.logWarning(\"Patient \" + patientId\n+                            + \" being added for the first time. Apparently this patient was not in the samples file, or the samples file is not yet loaded (should be loaded before this one)\");\n+                }\n+\n+                patient = new Patient(cancerStudy, patientId);\n+                internalPatientId = DaoPatient.addPatient(patient);\n+            }\n+        }\n+        return internalPatientId;\n+    }\n+\n+    private int addSampleToDatabase(String sampleId, String[] fields, String[] headerNames)\n+            throws Exception {\n+        int sampleTypeIndex = findSampleTypeColumn(headerNames);\n+        String sampleTypeStr = (sampleTypeIndex != -1) ? fields[sampleTypeIndex] : null;\n+        if (sampleTypeStr != null) {\n+            // want to match Sample.Type enum names\n+            sampleTypeStr = sampleTypeStr.trim().toUpperCase().replaceAll(\" \", \"_\");\n+        }\n+        Sample.Type sampleType = Sample.Type.has(sampleTypeStr) ? Sample.Type.valueOf(sampleTypeStr) : null;\n+\n+        int internalSampleId = -1;\n+        if (validSampleId(sampleId) && !StableIdUtil.isNormal(sampleId)) {\n+            // want to try and capture normal sample types based on value for SAMPLE_TYPE\n+            // if present in resource data\n+            if (sampleType != null && sampleType.isNormal()) {\n+                return internalSampleId;\n+            }\n+            String stablePatientId = getStablePatientId(sampleId, fields, headerNames);\n+            if (validPatientId(stablePatientId)) {\n+                Patient patient = DaoPatient.getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(),\n+                        stablePatientId);\n+                if (patient == null) {\n+                    addPatientToDatabase(stablePatientId);\n+                    patient = DaoPatient.getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(),\n+                            stablePatientId);\n+                }\n+                sampleId = StableIdUtil.getSampleId(sampleId);\n+                internalSampleId = DaoSample.addSample(\n+                        new Sample(sampleId, patient.getInternalId(), cancerStudy.getTypeOfCancerId(), sampleTypeStr));\n+            }\n+        }\n+\n+        return internalSampleId;\n+    }\n+\n+    private String getStablePatientId(String sampleId, String[] fields, String[] headerNames) {\n+        Matcher tcgaSampleBarcodeMatcher = StableIdUtil.TCGA_PATIENT_BARCODE_FROM_SAMPLE_REGEX.matcher(sampleId);\n+        if (tcgaSampleBarcodeMatcher.find()) {\n+            return tcgaSampleBarcodeMatcher.group(1);\n+        } else {\n+            // internal studies should have a patient id column\n+            int patientIdIndex = findPatientIdColumn(headerNames);\n+            if (patientIdIndex >= 0) {\n+                return fields[patientIdIndex];\n+            }\n+            // sample and patient id are the same\n+            else {\n+                return sampleId;\n+            }\n+        }\n+    }\n+\n+    private boolean validPatientId(String patientId) {\n+        return (patientId != null && !patientId.isEmpty());\n+    }\n+\n+    private boolean validSampleId(String sampleId) {\n+        return (sampleId != null && !sampleId.isEmpty());\n+    }\n+\n+    private void validateAddDatum(int internalId, String stableId, String resourceId, String resourceURL, String resourceType, Set<String> resourceSet, MultiKeyMap resourceMap) throws Exception {\n+        // throw exception if resource definition is not exist in the database\n+        if (!resourceSet.contains(resourceId)) {\n+            throw new RuntimeException(\"Error: \" + resourceType.toLowerCase() + \" \" + stableId\n+            + \" with resource \" + resourceId\n+            + \" does not have matching resources information in database, please make sure to include resource definition in the resource definition file\");\n+        }\n+        // The resourceMap makes sure a pari of (internalId/resource_id/url) is unique", "originalCommit": "ad5abf7c9634a54ebf671517257638ed6e6141d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTExMjMxNQ==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395112315", "bodyText": "here you just want to parse the boolean value right? and if it's not \"true\" or \"false\" then the default would be false?\nthe Boolean java docs describes a built in method for parsing a boolean from a string and I think it's the exact behavior you're looking for too\nhttps://docs.oracle.com/javase/8/docs/api/java/lang/Boolean.html", "author": "ao508", "createdAt": "2020-03-19T15:26:24Z", "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceDefinition.java", "diffHunk": "@@ -0,0 +1,330 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.scripts.ImportResourceData.ResourceTypes;\n+import org.mskcc.cbio.portal.util.*;\n+import org.mskcc.cbio.portal.util.ValuesUtils.MissingValues;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+\n+public class ImportResourceDefinition extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String DISPLAY_NAME_COLUMN_NAME = \"DISPLAY_NAME\";\n+    public static final String DESCRIPTION_COLUMN_NAME = \"DESCRIPTION\";\n+    public static final String RESOURCE_TYPE_COLUMN_NAME = \"RESOURCE_TYPE\";\n+    public static final String OPEN_BY_DEFAULT_COLUMN_NAME = \"OPEN_BY_DEFAULT\";\n+    public static final String PRIORITY_COLUMN_NAME = \"PRIORITY\";\n+    private int numResourceDefinitionsAdded = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private boolean relaxed;\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+\n+        String line = buff.readLine();\n+        String[] headerNames = splitFields(line);\n+\n+        // validate columns and get index\n+        int resourceIdIndex = findAndValidateResourceIdColumn(headerNames);\n+        int displayNameIndex = findAndValidateDisplayNameColumn(headerNames);\n+        int descriptionIndex = findAndValidateDescriptionColumn(headerNames);\n+        int resourceTypeIndex = findAndValidateResourceTypeColumn(headerNames);\n+        int openByDefaultIndex = findAndValidateOpenByDefaultColumn(headerNames);\n+        int priorityIndex = findAndValidatePriorityColumn(headerNames);\n+\n+        while ((line = buff.readLine()) != null) {\n+            if (skipLine(line.trim())) {\n+                continue;\n+            }\n+\n+            String[] fieldValues = getFieldValues(line, headerNames);\n+\n+            // set default value\n+            String resourceId = \"\";\n+            String displayName = \"\";\n+            String description = \"\";\n+            String resourceType = \"\";\n+            Boolean openByDefault = false;\n+            int priority = 1;\n+            // get resource definitions from columns\n+            // get resourceId\n+            if (resourceIdIndex != -1 && isValueNotMissing(fieldValues[resourceIdIndex].toUpperCase())) {\n+                resourceId = fieldValues[resourceIdIndex].toUpperCase();\n+            } else {\n+                throw new RuntimeException(\n+                        \"Please provide a valid resource id\");\n+            }\n+            // get displayName\n+            if (resourceIdIndex != -1 && isValueNotMissing(fieldValues[displayNameIndex])) {\n+                displayName = fieldValues[displayNameIndex];\n+            }\n+            else {\n+                throw new RuntimeException(\n+                        \"Please provide a valid display name\");\n+            }\n+            // get description (optional)\n+            if (descriptionIndex != -1 && isValueNotMissing(fieldValues[descriptionIndex])) {\n+                description = fieldValues[descriptionIndex];\n+            }\n+            // get resourceType (must be value of ResourceTypes)\n+            if (resourceTypeIndex != -1 && isValidResourceType(fieldValues[resourceTypeIndex])) {\n+                resourceType = fieldValues[resourceTypeIndex];\n+            }\n+            // get openByDefault (optional)\n+            if (openByDefaultIndex != -1 && isValidOpenByDefault(fieldValues[openByDefaultIndex])) {\n+                openByDefault = fieldValues[openByDefaultIndex].equalsIgnoreCase(\"true\");", "originalCommit": "ad5abf7c9634a54ebf671517257638ed6e6141d8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIyNzU3OA==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395227578", "bodyText": "Thanks! Good to know this!", "author": "dippindots", "createdAt": "2020-03-19T18:15:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTExMjMxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTExNDU2NQ==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395114565", "bodyText": "for consistency would you mind putting these enum types on their own separate lines?", "author": "ao508", "createdAt": "2020-03-19T15:29:17Z", "path": "core/src/main/java/org/mskcc/cbio/portal/util/ValuesUtils.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package org.mskcc.cbio.portal.util;\n+\n+public class ValuesUtils {\n+    public static enum MissingValues {\n+        NOT_APPLICABLE(\"Not Applicable\"), NOT_AVAILABLE(\"Not Available\"), PENDING(\"Pending\"),\t", "originalCommit": "ad5abf7c9634a54ebf671517257638ed6e6141d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA5MTQ3Ng==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395091476", "bodyText": "This class looks similar to what's in https://github.com/cBioPortal/cbioportal/pull/7260/files#diff-9c956027ecfb618e20f86039fc7d88b5. Instead of two should be merge them?", "author": "kalletlak", "createdAt": "2020-03-19T14:59:07Z", "path": "core/src/main/java/org/mskcc/cbio/portal/model/ResourceDefinition.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package org.mskcc.cbio.portal.model;\n+\n+public class ResourceDefinition {", "originalCommit": "ad5abf7c9634a54ebf671517257638ed6e6141d8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIyODU5MQ==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395228591", "bodyText": "Yes, definitely, I will rebase and use that one.", "author": "dippindots", "createdAt": "2020-03-19T18:17:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA5MTQ3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA5MzM2Ng==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395093366", "bodyText": "Instead of String this can be Enum https://github.com/cBioPortal/cbioportal/pull/7260/files#diff-c093101e82d85d9e9aa964dd73fec8ba", "author": "kalletlak", "createdAt": "2020-03-19T15:01:36Z", "path": "core/src/main/java/org/mskcc/cbio/portal/model/ResourceDefinition.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package org.mskcc.cbio.portal.model;\n+\n+public class ResourceDefinition {\n+\n+    public static final String STUDY_RESOURCE_TYPE = \"STUDY\";\n+    public static final String SAMPLE_RESOURCE_TYPE = \"SAMPLE\";\n+    public static final String PATIENT_RESOURCE_TYPE = \"PATIENT\";\n+    public static final String MISSING = \"MISSING\";\n+\n+    private String resourceId;\n+    private String displayName;\n+    private String description;\n+    private String resourceType;", "originalCommit": "ad5abf7c9634a54ebf671517257638ed6e6141d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA5NDE0MA==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395094140", "bodyText": "STUDY_RESOURCE_TYPE, SAMPLE_RESOURCE_TYPE, PATIENT_RESOURCE_TYPE can be replaced with https://github.com/cBioPortal/cbioportal/pull/7260/files#diff-c093101e82d85d9e9aa964dd73fec8ba", "author": "kalletlak", "createdAt": "2020-03-19T15:02:36Z", "path": "core/src/main/java/org/mskcc/cbio/portal/model/ResourceDefinition.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package org.mskcc.cbio.portal.model;\n+\n+public class ResourceDefinition {\n+\n+    public static final String STUDY_RESOURCE_TYPE = \"STUDY\";\n+    public static final String SAMPLE_RESOURCE_TYPE = \"SAMPLE\";\n+    public static final String PATIENT_RESOURCE_TYPE = \"PATIENT\";", "originalCommit": "ad5abf7c9634a54ebf671517257638ed6e6141d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA5NjkzMQ==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395096931", "bodyText": "This can just be instead of creating local variable\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return resources;\n          \n          \n            \n                    return DaoResourceDefinition.getDatumByStudy(cancerStudy.getInternalId());", "author": "kalletlak", "createdAt": "2020-03-19T15:06:19Z", "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "diffHunk": "@@ -0,0 +1,574 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+import org.mskcc.cbio.portal.util.ValuesUtils.MissingValues;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+import java.util.regex.*;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections.map.MultiKeyMap;\n+\n+public class ImportResourceData extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String METADATA_PREFIX = \"#\";\n+    public static final String SAMPLE_ID_COLUMN_NAME = \"SAMPLE_ID\";\n+    public static final String PATIENT_ID_COLUMN_NAME = \"PATIENT_ID\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String URL_COLUMN_NAME = \"URL\";\n+    public static final String SAMPLE_TYPE_COLUMN_NAME = \"SAMPLE_TYPE\";\n+    private int numSampleSpecificResourcesAdded = 0;\n+    private int numPatientSpecificResourcesAdded = 0;\n+    private int numStudySpecificResourcesAdded = 0;\n+    private int numEmptyResourcesSkipped = 0;\n+    private int numSamplesProcessed = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private ResourceTypes resourceType;\n+    private boolean relaxed;\n+    private Set<String> patientIds = new HashSet<String>();\n+\n+    public static enum ResourceTypes {\n+        PATIENT(\"PATIENT\"), SAMPLE(\"SAMPLE\"), STUDY(\"STUDY\");\n+\n+        private String resourceTypes;\n+\n+        ResourceTypes(String resourceTypes) {\n+            this.resourceTypes = resourceTypes;\n+        }\n+\n+        public String toString() {\n+            return resourceTypes;\n+        }\n+    }\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, String resourceType, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.resourceType = ResourceTypes.valueOf(resourceType);\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+        List<ResourceDefinition> resources = grabResources(buff);\n+        String currentLine = buff.readLine();\n+        String[] headerNames = currentLine.split(\"\\t\");\n+        \n+        int patientIdIndex = findPatientIdColumn(headerNames);\n+        int sampleIdIndex = findSampleIdColumn(headerNames);\n+        int resourceIdIndex = findResourceIdColumn(headerNames);\n+        int urlIndex = findURLColumn(headerNames);\n+\n+        // validate required columns:\n+        if (resourceIdIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + RESOURCE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (urlIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + URL_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if ((resourceType.toString().equalsIgnoreCase(\"sample\") || resourceType.toString().equalsIgnoreCase(\"patient\")) && patientIdIndex < 0) {\n+            // PATIENT_ID is required in both patient and sample file types:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + PATIENT_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (resourceType.toString().equalsIgnoreCase(\"sample\") && sampleIdIndex < 0) {\n+            // SAMPLE_ID is required in SAMPLE file type:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + SAMPLE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        importData(buff, resources, headerNames);\n+\n+        if (MySQLbulkLoader.isBulkLoad()) {\n+            MySQLbulkLoader.flushAll();\n+            MySQLbulkLoader.relaxedModeOff();\n+        }\n+    }\n+\n+    private List<ResourceDefinition> grabResources(BufferedReader buff) throws DaoException, IOException {\n+        List<ResourceDefinition> resources = new ArrayList<ResourceDefinition>();\n+        resources = DaoResourceDefinition.getDatumByStudy(cancerStudy.getInternalId());\n+        return resources;", "originalCommit": "ad5abf7c9634a54ebf671517257638ed6e6141d8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE1NzU5Nw==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395157597", "bodyText": "or line 73 can be  List<ResourceDefinition> resources = DaoResourceDefinition.getDatumByStudy(cancerStudy.getInternalId());", "author": "kalletlak", "createdAt": "2020-03-19T16:28:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA5NjkzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTExMTUyMA==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395111520", "bodyText": "looks like it is used just at one place and the method is just one line. better remove this method and replace line 116", "author": "kalletlak", "createdAt": "2020-03-19T15:25:22Z", "path": "core/src/main/java/org/mskcc/cbio/portal/dao/DaoResourceData.java", "diffHunk": "@@ -0,0 +1,219 @@\n+package org.mskcc.cbio.portal.dao;\n+\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.InternalIdUtil;\n+\n+import org.apache.commons.lang.StringUtils;\n+\n+import java.sql.*;\n+import java.util.*;\n+\n+/**\n+ * Data Access Object for `resource` tables\n+ */\n+public final class DaoResourceData {\n+\n+    public static final String SAMPLE_TABLE = \"resource_sample\";\n+    public static final String PATIENT_TABLE = \"resource_patient\";\n+    public static final String STUDY_TABLE = \"resource_study\";\n+\n+    private static final String SAMPLE_INSERT = \"INSERT INTO \" + SAMPLE_TABLE\n+            + \"(`INTERNAL_ID`,`RESOURCE_ID`,`URL` VALUES(?,?,?)\";\n+    private static final String PATIENT_INSERT = \"INSERT INTO \" + PATIENT_TABLE\n+            + \"(`INTERNAL_ID`,`RESOURCE_ID`,`URL` VALUES(?,?,?)\";\n+    private static final String STUDY_INSERT = \"INSERT INTO \" + STUDY_TABLE\n+            + \"(`INTERNAL_ID`,`RESOURCE_ID`,`URL` VALUES(?,?,?)\";\n+\n+    private static final Map<String, String> sampleResources = new HashMap<String, String>();\n+    private static final Map<String, String> patientResources = new HashMap<String, String>();\n+    private static final Map<String, String> studyResources = new HashMap<String, String>();\n+\n+    private DaoResourceData() {\n+    }\n+\n+    public static synchronized void reCache() {\n+        clearCache();\n+        cacheResources(SAMPLE_TABLE, sampleResources);\n+        cacheResources(PATIENT_TABLE, patientResources);\n+        cacheResources(STUDY_TABLE, studyResources);\n+    }\n+\n+    private static void clearCache() {\n+        sampleResources.clear();\n+        patientResources.clear();\n+        studyResources.clear();\n+    }\n+\n+    private static void cacheResources(String table, Map<String, String> cache) {\n+        Connection con = null;\n+        PreparedStatement pstmt = null;\n+        ResultSet rs = null;\n+        try {\n+            con = JdbcUtil.getDbConnection(DaoResourceData.class);\n+            pstmt = con.prepareStatement(\"SELECT * FROM \" + table);\n+            rs = pstmt.executeQuery();\n+            while (rs.next()) {\n+                cache.put(rs.getString(\"RESOURCE_ID\"), rs.getString(\"RESOURCE_ID\"));\n+            }\n+        } catch (SQLException e) {\n+            e.printStackTrace();\n+        } finally {\n+            JdbcUtil.closeAll(DaoResourceData.class, con, pstmt, rs);\n+        }\n+    }\n+\n+    public static int addSampleDatum(int internalSampleId, String resourceId, String url) throws DaoException {\n+        sampleResources.put(resourceId, resourceId);\n+        return addDatum(SAMPLE_INSERT, SAMPLE_TABLE, internalSampleId, resourceId, url);\n+    }\n+\n+    public static int addPatientDatum(int internalPatientId, String resourceId, String url) throws DaoException {\n+        patientResources.put(resourceId, resourceId);\n+        return addDatum(PATIENT_INSERT, PATIENT_TABLE, internalPatientId, resourceId, url);\n+    }\n+\n+    public static int addStudyDatum(int internalStudyId, String resourceId, String url) throws DaoException {\n+        patientResources.put(resourceId, resourceId);\n+        return addDatum(STUDY_INSERT, STUDY_TABLE, internalStudyId, resourceId, url);\n+    }\n+\n+    public static int addDatum(String query, String tableName, int internalId, String resourceId, String url)\n+            throws DaoException {\n+        if (MySQLbulkLoader.isBulkLoad()) {\n+            MySQLbulkLoader.getMySQLbulkLoader(tableName).insertRecord(Integer.toString(internalId), resourceId, url);\n+            return 1;\n+        }\n+\n+        Connection con = null;\n+        PreparedStatement pstmt = null;\n+        ResultSet rs = null;\n+        try {\n+            con = JdbcUtil.getDbConnection(DaoResourceData.class);\n+\n+            pstmt = con.prepareStatement(query);\n+            pstmt.setInt(1, internalId);\n+            pstmt.setString(2, resourceId);\n+            pstmt.setString(3, url);\n+            int toReturn = pstmt.executeUpdate();\n+\n+            if (tableName.equals(PATIENT_TABLE)) {\n+                patientResources.put(resourceId, resourceId);\n+            } else if (tableName.equals(SAMPLE_TABLE)){\n+                sampleResources.put(resourceId, resourceId);\n+            } else {\n+                studyResources.put(resourceId, resourceId);\n+            }\n+\n+            return toReturn;\n+        } catch (SQLException e) {\n+            throw new DaoException(e);\n+        } finally {\n+            JdbcUtil.closeAll(DaoResourceData.class, con, pstmt, rs);\n+        }\n+    }\n+\n+    public static ResourceBaseData getDatum(String cancerStudyId, String patientId, String resourceId) throws DaoException {\n+        int internalCancerStudyId = getInternalCancerStudyId(cancerStudyId);\n+        String table = getResourceTable(resourceId);\n+        if (table == null) {\n+            return null;\n+        }\n+        return getDatum(internalCancerStudyId, table,\n+                DaoPatient.getPatientByCancerStudyAndPatientId(internalCancerStudyId, patientId).getInternalId(),\n+                resourceId);\n+    }\n+\n+    private static int getInternalCancerStudyId(String cancerStudyId) throws DaoException {", "originalCommit": "ad5abf7c9634a54ebf671517257638ed6e6141d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE1NjE4NA==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395156184", "bodyText": "buff is never used", "author": "kalletlak", "createdAt": "2020-03-19T16:26:47Z", "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "diffHunk": "@@ -0,0 +1,574 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+import org.mskcc.cbio.portal.util.ValuesUtils.MissingValues;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+import java.util.regex.*;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections.map.MultiKeyMap;\n+\n+public class ImportResourceData extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String METADATA_PREFIX = \"#\";\n+    public static final String SAMPLE_ID_COLUMN_NAME = \"SAMPLE_ID\";\n+    public static final String PATIENT_ID_COLUMN_NAME = \"PATIENT_ID\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String URL_COLUMN_NAME = \"URL\";\n+    public static final String SAMPLE_TYPE_COLUMN_NAME = \"SAMPLE_TYPE\";\n+    private int numSampleSpecificResourcesAdded = 0;\n+    private int numPatientSpecificResourcesAdded = 0;\n+    private int numStudySpecificResourcesAdded = 0;\n+    private int numEmptyResourcesSkipped = 0;\n+    private int numSamplesProcessed = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private ResourceTypes resourceType;\n+    private boolean relaxed;\n+    private Set<String> patientIds = new HashSet<String>();\n+\n+    public static enum ResourceTypes {\n+        PATIENT(\"PATIENT\"), SAMPLE(\"SAMPLE\"), STUDY(\"STUDY\");\n+\n+        private String resourceTypes;\n+\n+        ResourceTypes(String resourceTypes) {\n+            this.resourceTypes = resourceTypes;\n+        }\n+\n+        public String toString() {\n+            return resourceTypes;\n+        }\n+    }\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, String resourceType, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.resourceType = ResourceTypes.valueOf(resourceType);\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+        List<ResourceDefinition> resources = grabResources(buff);\n+        String currentLine = buff.readLine();\n+        String[] headerNames = currentLine.split(\"\\t\");\n+        \n+        int patientIdIndex = findPatientIdColumn(headerNames);\n+        int sampleIdIndex = findSampleIdColumn(headerNames);\n+        int resourceIdIndex = findResourceIdColumn(headerNames);\n+        int urlIndex = findURLColumn(headerNames);\n+\n+        // validate required columns:\n+        if (resourceIdIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + RESOURCE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (urlIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + URL_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if ((resourceType.toString().equalsIgnoreCase(\"sample\") || resourceType.toString().equalsIgnoreCase(\"patient\")) && patientIdIndex < 0) {\n+            // PATIENT_ID is required in both patient and sample file types:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + PATIENT_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (resourceType.toString().equalsIgnoreCase(\"sample\") && sampleIdIndex < 0) {\n+            // SAMPLE_ID is required in SAMPLE file type:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + SAMPLE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        importData(buff, resources, headerNames);\n+\n+        if (MySQLbulkLoader.isBulkLoad()) {\n+            MySQLbulkLoader.flushAll();\n+            MySQLbulkLoader.relaxedModeOff();\n+        }\n+    }\n+\n+    private List<ResourceDefinition> grabResources(BufferedReader buff) throws DaoException, IOException {", "originalCommit": "ad5abf7c9634a54ebf671517257638ed6e6141d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE1ODU0NQ==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395158545", "bodyText": "Same here. I have already defined ResourceType in model directory", "author": "kalletlak", "createdAt": "2020-03-19T16:30:07Z", "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "diffHunk": "@@ -0,0 +1,574 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+import org.mskcc.cbio.portal.util.ValuesUtils.MissingValues;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+import java.util.regex.*;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections.map.MultiKeyMap;\n+\n+public class ImportResourceData extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String METADATA_PREFIX = \"#\";\n+    public static final String SAMPLE_ID_COLUMN_NAME = \"SAMPLE_ID\";\n+    public static final String PATIENT_ID_COLUMN_NAME = \"PATIENT_ID\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String URL_COLUMN_NAME = \"URL\";\n+    public static final String SAMPLE_TYPE_COLUMN_NAME = \"SAMPLE_TYPE\";\n+    private int numSampleSpecificResourcesAdded = 0;\n+    private int numPatientSpecificResourcesAdded = 0;\n+    private int numStudySpecificResourcesAdded = 0;\n+    private int numEmptyResourcesSkipped = 0;\n+    private int numSamplesProcessed = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private ResourceTypes resourceType;\n+    private boolean relaxed;\n+    private Set<String> patientIds = new HashSet<String>();\n+\n+    public static enum ResourceTypes {", "originalCommit": "ad5abf7c9634a54ebf671517257638ed6e6141d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE2MTUwOA==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395161508", "bodyText": "for each and every line block lines from 179-193 is executed which is not performance efficient. instead why not calculate them once and pass them as parameters", "author": "kalletlak", "createdAt": "2020-03-19T16:34:18Z", "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "diffHunk": "@@ -0,0 +1,574 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+import org.mskcc.cbio.portal.util.ValuesUtils.MissingValues;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+import java.util.regex.*;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections.map.MultiKeyMap;\n+\n+public class ImportResourceData extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String METADATA_PREFIX = \"#\";\n+    public static final String SAMPLE_ID_COLUMN_NAME = \"SAMPLE_ID\";\n+    public static final String PATIENT_ID_COLUMN_NAME = \"PATIENT_ID\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String URL_COLUMN_NAME = \"URL\";\n+    public static final String SAMPLE_TYPE_COLUMN_NAME = \"SAMPLE_TYPE\";\n+    private int numSampleSpecificResourcesAdded = 0;\n+    private int numPatientSpecificResourcesAdded = 0;\n+    private int numStudySpecificResourcesAdded = 0;\n+    private int numEmptyResourcesSkipped = 0;\n+    private int numSamplesProcessed = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private ResourceTypes resourceType;\n+    private boolean relaxed;\n+    private Set<String> patientIds = new HashSet<String>();\n+\n+    public static enum ResourceTypes {\n+        PATIENT(\"PATIENT\"), SAMPLE(\"SAMPLE\"), STUDY(\"STUDY\");\n+\n+        private String resourceTypes;\n+\n+        ResourceTypes(String resourceTypes) {\n+            this.resourceTypes = resourceTypes;\n+        }\n+\n+        public String toString() {\n+            return resourceTypes;\n+        }\n+    }\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, String resourceType, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.resourceType = ResourceTypes.valueOf(resourceType);\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+        List<ResourceDefinition> resources = grabResources(buff);\n+        String currentLine = buff.readLine();\n+        String[] headerNames = currentLine.split(\"\\t\");\n+        \n+        int patientIdIndex = findPatientIdColumn(headerNames);\n+        int sampleIdIndex = findSampleIdColumn(headerNames);\n+        int resourceIdIndex = findResourceIdColumn(headerNames);\n+        int urlIndex = findURLColumn(headerNames);\n+\n+        // validate required columns:\n+        if (resourceIdIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + RESOURCE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (urlIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + URL_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if ((resourceType.toString().equalsIgnoreCase(\"sample\") || resourceType.toString().equalsIgnoreCase(\"patient\")) && patientIdIndex < 0) {\n+            // PATIENT_ID is required in both patient and sample file types:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + PATIENT_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (resourceType.toString().equalsIgnoreCase(\"sample\") && sampleIdIndex < 0) {\n+            // SAMPLE_ID is required in SAMPLE file type:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + SAMPLE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        importData(buff, resources, headerNames);\n+\n+        if (MySQLbulkLoader.isBulkLoad()) {\n+            MySQLbulkLoader.flushAll();\n+            MySQLbulkLoader.relaxedModeOff();\n+        }\n+    }\n+\n+    private List<ResourceDefinition> grabResources(BufferedReader buff) throws DaoException, IOException {\n+        List<ResourceDefinition> resources = new ArrayList<ResourceDefinition>();\n+        resources = DaoResourceDefinition.getDatumByStudy(cancerStudy.getInternalId());\n+        return resources;\n+    }\n+\n+    private String[] splitFields(String line) throws IOException {\n+        line = line.replaceAll(\"^\" + METADATA_PREFIX + \"+\", \"\");\n+        String[] fields = line.split(DELIMITER, -1);\n+\n+        return fields;\n+    }\n+\n+    private void importData(BufferedReader buff, List<ResourceDefinition> resources, String[] headerNames) throws Exception {\n+        String line;\n+        MultiKeyMap resourceMap = new MultiKeyMap();\n+        while ((line = buff.readLine()) != null) {\n+            if (skipLine(line.trim())) {\n+                continue;\n+            }\n+\n+            String[] fieldValues = getFieldValues(line, headerNames);\n+            addDatum(fieldValues, resources, resourceMap, headerNames);", "originalCommit": "ad5abf7c9634a54ebf671517257638ed6e6141d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE3MTI4OA==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395171288", "bodyText": "could be resourceType.equals(ResourceType.SAMPLE)", "author": "kalletlak", "createdAt": "2020-03-19T16:48:15Z", "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "diffHunk": "@@ -0,0 +1,574 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+import org.mskcc.cbio.portal.util.ValuesUtils.MissingValues;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+import java.util.regex.*;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections.map.MultiKeyMap;\n+\n+public class ImportResourceData extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String METADATA_PREFIX = \"#\";\n+    public static final String SAMPLE_ID_COLUMN_NAME = \"SAMPLE_ID\";\n+    public static final String PATIENT_ID_COLUMN_NAME = \"PATIENT_ID\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String URL_COLUMN_NAME = \"URL\";\n+    public static final String SAMPLE_TYPE_COLUMN_NAME = \"SAMPLE_TYPE\";\n+    private int numSampleSpecificResourcesAdded = 0;\n+    private int numPatientSpecificResourcesAdded = 0;\n+    private int numStudySpecificResourcesAdded = 0;\n+    private int numEmptyResourcesSkipped = 0;\n+    private int numSamplesProcessed = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private ResourceTypes resourceType;\n+    private boolean relaxed;\n+    private Set<String> patientIds = new HashSet<String>();\n+\n+    public static enum ResourceTypes {\n+        PATIENT(\"PATIENT\"), SAMPLE(\"SAMPLE\"), STUDY(\"STUDY\");\n+\n+        private String resourceTypes;\n+\n+        ResourceTypes(String resourceTypes) {\n+            this.resourceTypes = resourceTypes;\n+        }\n+\n+        public String toString() {\n+            return resourceTypes;\n+        }\n+    }\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, String resourceType, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.resourceType = ResourceTypes.valueOf(resourceType);\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+        List<ResourceDefinition> resources = grabResources(buff);\n+        String currentLine = buff.readLine();\n+        String[] headerNames = currentLine.split(\"\\t\");\n+        \n+        int patientIdIndex = findPatientIdColumn(headerNames);\n+        int sampleIdIndex = findSampleIdColumn(headerNames);\n+        int resourceIdIndex = findResourceIdColumn(headerNames);\n+        int urlIndex = findURLColumn(headerNames);\n+\n+        // validate required columns:\n+        if (resourceIdIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + RESOURCE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (urlIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + URL_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if ((resourceType.toString().equalsIgnoreCase(\"sample\") || resourceType.toString().equalsIgnoreCase(\"patient\")) && patientIdIndex < 0) {", "originalCommit": "ad5abf7c9634a54ebf671517257638ed6e6141d8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE3MTQ3Mg==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395171472", "bodyText": "same for patient and study", "author": "kalletlak", "createdAt": "2020-03-19T16:48:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE3MTI4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE3NjA4Ng==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395176086", "bodyText": "instead of fetching sample for every record, why not fetch data(sample/patient) depending on the resource type?", "author": "kalletlak", "createdAt": "2020-03-19T16:55:11Z", "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "diffHunk": "@@ -0,0 +1,574 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+import org.mskcc.cbio.portal.util.ValuesUtils.MissingValues;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+import java.util.regex.*;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections.map.MultiKeyMap;\n+\n+public class ImportResourceData extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String METADATA_PREFIX = \"#\";\n+    public static final String SAMPLE_ID_COLUMN_NAME = \"SAMPLE_ID\";\n+    public static final String PATIENT_ID_COLUMN_NAME = \"PATIENT_ID\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String URL_COLUMN_NAME = \"URL\";\n+    public static final String SAMPLE_TYPE_COLUMN_NAME = \"SAMPLE_TYPE\";\n+    private int numSampleSpecificResourcesAdded = 0;\n+    private int numPatientSpecificResourcesAdded = 0;\n+    private int numStudySpecificResourcesAdded = 0;\n+    private int numEmptyResourcesSkipped = 0;\n+    private int numSamplesProcessed = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private ResourceTypes resourceType;\n+    private boolean relaxed;\n+    private Set<String> patientIds = new HashSet<String>();\n+\n+    public static enum ResourceTypes {\n+        PATIENT(\"PATIENT\"), SAMPLE(\"SAMPLE\"), STUDY(\"STUDY\");\n+\n+        private String resourceTypes;\n+\n+        ResourceTypes(String resourceTypes) {\n+            this.resourceTypes = resourceTypes;\n+        }\n+\n+        public String toString() {\n+            return resourceTypes;\n+        }\n+    }\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, String resourceType, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.resourceType = ResourceTypes.valueOf(resourceType);\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+        List<ResourceDefinition> resources = grabResources(buff);\n+        String currentLine = buff.readLine();\n+        String[] headerNames = currentLine.split(\"\\t\");\n+        \n+        int patientIdIndex = findPatientIdColumn(headerNames);\n+        int sampleIdIndex = findSampleIdColumn(headerNames);\n+        int resourceIdIndex = findResourceIdColumn(headerNames);\n+        int urlIndex = findURLColumn(headerNames);\n+\n+        // validate required columns:\n+        if (resourceIdIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + RESOURCE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (urlIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + URL_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if ((resourceType.toString().equalsIgnoreCase(\"sample\") || resourceType.toString().equalsIgnoreCase(\"patient\")) && patientIdIndex < 0) {\n+            // PATIENT_ID is required in both patient and sample file types:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + PATIENT_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (resourceType.toString().equalsIgnoreCase(\"sample\") && sampleIdIndex < 0) {\n+            // SAMPLE_ID is required in SAMPLE file type:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + SAMPLE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        importData(buff, resources, headerNames);\n+\n+        if (MySQLbulkLoader.isBulkLoad()) {\n+            MySQLbulkLoader.flushAll();\n+            MySQLbulkLoader.relaxedModeOff();\n+        }\n+    }\n+\n+    private List<ResourceDefinition> grabResources(BufferedReader buff) throws DaoException, IOException {\n+        List<ResourceDefinition> resources = new ArrayList<ResourceDefinition>();\n+        resources = DaoResourceDefinition.getDatumByStudy(cancerStudy.getInternalId());\n+        return resources;\n+    }\n+\n+    private String[] splitFields(String line) throws IOException {\n+        line = line.replaceAll(\"^\" + METADATA_PREFIX + \"+\", \"\");\n+        String[] fields = line.split(DELIMITER, -1);\n+\n+        return fields;\n+    }\n+\n+    private void importData(BufferedReader buff, List<ResourceDefinition> resources, String[] headerNames) throws Exception {\n+        String line;\n+        MultiKeyMap resourceMap = new MultiKeyMap();\n+        while ((line = buff.readLine()) != null) {\n+            if (skipLine(line.trim())) {\n+                continue;\n+            }\n+\n+            String[] fieldValues = getFieldValues(line, headerNames);\n+            addDatum(fieldValues, resources, resourceMap, headerNames);\n+        }\n+    }\n+\n+    private boolean skipLine(String line) {\n+        return (line.isEmpty() || line.substring(0, 1).equals(METADATA_PREFIX));\n+    }\n+\n+    /**\n+     * Takes in the given line and returns the list of field values by splitting the\n+     * line on DELIMITER.\n+     * \n+     * @param line\n+     * @param headerNames\n+     * @return the list of values, one for each column. Value will be \"\" for empty\n+     *         columns.\n+     */\n+    private String[] getFieldValues(String line, String[] headerNames) {\n+        // split on delimiter:\n+        String[] fieldValues = line.split(DELIMITER, -1);\n+\n+        // validate: if number of fields is incorrect, give exception\n+        if (fieldValues.length != headerNames.length) {\n+            throw new IllegalArgumentException(\"Number of columns in line is not as expected. Expected: \"\n+                    + headerNames.length + \" columns, found: \" + fieldValues.length + \", for line: \" + line);\n+        }\n+\n+        // now iterate over lines and trim each value:\n+        for (int i = 0; i < fieldValues.length; i++) {\n+            fieldValues[i] = fieldValues[i].trim();\n+        }\n+        return fieldValues;\n+    }\n+\n+    private boolean addDatum(String[] fields, List<ResourceDefinition> resources, MultiKeyMap resourceMap, String[] headerNames)\n+            throws Exception {\n+        int sampleIdIndex = findSampleIdColumn(headerNames);\n+        String stableSampleId = (sampleIdIndex >= 0) ? fields[sampleIdIndex] : \"\";\n+        stableSampleId = StableIdUtil.getSampleId(stableSampleId);\n+        int patientIdIndex = findPatientIdColumn(headerNames);\n+        String stablePatientId = (patientIdIndex >= 0) ? fields[patientIdIndex] : \"\";\n+        stablePatientId = StableIdUtil.getPatientId(stablePatientId);\n+        int resourceIdIndex = findResourceIdColumn(headerNames);\n+        int urlIndex = findURLColumn(headerNames);\n+        int internalSampleId = -1;\n+        int internalPatientId = -1;\n+\n+        // create resource_id set\n+        Set<String> patientResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceDefinition.PATIENT_RESOURCE_TYPE))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+        Set<String> sampleResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceDefinition.SAMPLE_RESOURCE_TYPE))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+        Set<String> studyResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceDefinition.STUDY_RESOURCE_TYPE))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+\n+        // check if sample is not already added:\n+        Sample sample = DaoSample.getSampleByCancerStudyAndSampleId(cancerStudy.getInternalId(), stableSampleId, false);", "originalCommit": "ad5abf7c9634a54ebf671517257638ed6e6141d8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTcyOTYyNQ==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395729625", "bodyText": "I don't think I can fetch data by resource type since the sample and patient can have no association with resources before we adding the resource data into the database.", "author": "dippindots", "createdAt": "2020-03-20T15:52:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE3NjA4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc0NzcwMg==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395747702", "bodyText": "I mean to say that for a study resource you don't need to fetch Sample. and similarly for patient resource", "author": "kalletlak", "createdAt": "2020-03-20T16:21:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE3NjA4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc3NzMwOA==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395777308", "bodyText": "I see! I will update this!", "author": "dippindots", "createdAt": "2020-03-20T17:10:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE3NjA4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE4NDc0Mg==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395184742", "bodyText": "could we send Map<String,Integer> of headerNames instead of array? checking in map is more efficient than iterating an array", "author": "kalletlak", "createdAt": "2020-03-19T17:07:54Z", "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceDefinition.java", "diffHunk": "@@ -0,0 +1,330 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.scripts.ImportResourceData.ResourceTypes;\n+import org.mskcc.cbio.portal.util.*;\n+import org.mskcc.cbio.portal.util.ValuesUtils.MissingValues;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+\n+public class ImportResourceDefinition extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String DISPLAY_NAME_COLUMN_NAME = \"DISPLAY_NAME\";\n+    public static final String DESCRIPTION_COLUMN_NAME = \"DESCRIPTION\";\n+    public static final String RESOURCE_TYPE_COLUMN_NAME = \"RESOURCE_TYPE\";\n+    public static final String OPEN_BY_DEFAULT_COLUMN_NAME = \"OPEN_BY_DEFAULT\";\n+    public static final String PRIORITY_COLUMN_NAME = \"PRIORITY\";\n+    private int numResourceDefinitionsAdded = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private boolean relaxed;\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+\n+        String line = buff.readLine();\n+        String[] headerNames = splitFields(line);\n+\n+        // validate columns and get index\n+        int resourceIdIndex = findAndValidateResourceIdColumn(headerNames);\n+        int displayNameIndex = findAndValidateDisplayNameColumn(headerNames);\n+        int descriptionIndex = findAndValidateDescriptionColumn(headerNames);\n+        int resourceTypeIndex = findAndValidateResourceTypeColumn(headerNames);\n+        int openByDefaultIndex = findAndValidateOpenByDefaultColumn(headerNames);\n+        int priorityIndex = findAndValidatePriorityColumn(headerNames);\n+\n+        while ((line = buff.readLine()) != null) {\n+            if (skipLine(line.trim())) {\n+                continue;\n+            }\n+\n+            String[] fieldValues = getFieldValues(line, headerNames);\n+\n+            // set default value\n+            String resourceId = \"\";\n+            String displayName = \"\";\n+            String description = \"\";\n+            String resourceType = \"\";\n+            Boolean openByDefault = false;\n+            int priority = 1;\n+            // get resource definitions from columns\n+            // get resourceId\n+            if (resourceIdIndex != -1 && isValueNotMissing(fieldValues[resourceIdIndex].toUpperCase())) {\n+                resourceId = fieldValues[resourceIdIndex].toUpperCase();\n+            } else {\n+                throw new RuntimeException(\n+                        \"Please provide a valid resource id\");\n+            }\n+            // get displayName\n+            if (resourceIdIndex != -1 && isValueNotMissing(fieldValues[displayNameIndex])) {\n+                displayName = fieldValues[displayNameIndex];\n+            }\n+            else {\n+                throw new RuntimeException(\n+                        \"Please provide a valid display name\");\n+            }\n+            // get description (optional)\n+            if (descriptionIndex != -1 && isValueNotMissing(fieldValues[descriptionIndex])) {\n+                description = fieldValues[descriptionIndex];\n+            }\n+            // get resourceType (must be value of ResourceTypes)\n+            if (resourceTypeIndex != -1 && isValidResourceType(fieldValues[resourceTypeIndex])) {\n+                resourceType = fieldValues[resourceTypeIndex];\n+            }\n+            // get openByDefault (optional)\n+            if (openByDefaultIndex != -1 && isValidOpenByDefault(fieldValues[openByDefaultIndex])) {\n+                openByDefault = fieldValues[openByDefaultIndex].equalsIgnoreCase(\"true\");\n+            }\n+            // get priority (optional)\n+            try {\n+                priority = Integer.parseInt(fieldValues[priorityIndex]);\n+            } catch (NumberFormatException ex) {\n+                throw new DaoException(\n+                    \"priority cannot be parsed as an integer, all priority should be an integer.\");\n+            }\n+\n+            // add resource definitions into database\n+            ResourceDefinition resource = new ResourceDefinition(resourceId, displayName,\n+                    description, resourceType, openByDefault,\n+                    priority, cancerStudy.getInternalId());\n+\n+            ResourceDefinition resourceInDb = DaoResourceDefinition.getDatum(resource.getResourceId(),\n+                    cancerStudy.getInternalId());\n+            if (resourceInDb != null) {\n+                ProgressMonitor.logWarning(\"Resource \" + resourceInDb.getResourceId() + \" found twice in your study!\");\n+                continue;\n+            }\n+            if (DaoResourceDefinition.addDatum(resource) > 0) {\n+                numResourceDefinitionsAdded++;\n+            }\n+        }\n+        buff.close();\n+\n+        if (MySQLbulkLoader.isBulkLoad()) {\n+            MySQLbulkLoader.flushAll();\n+            MySQLbulkLoader.relaxedModeOff();\n+        }\n+    }\n+\n+    private String[] splitFields(String line) throws IOException {\n+        String[] fields = line.split(DELIMITER, -1);\n+\n+        return fields;\n+    }\n+\n+    private boolean skipLine(String line) {\n+        return line.isEmpty();\n+    }\n+\n+    /**\n+     * Takes in the given line and returns the list of field values by splitting the\n+     * line on DELIMITER.\n+     * \n+     * @param line\n+     * @param headerNames\n+     * @return the list of values, one for each column. Value will be \"\" for empty\n+     *         columns.\n+     */\n+    private String[] getFieldValues(String line, String[] headerNames) {\n+        // split on delimiter:\n+        String[] fieldValues = line.split(DELIMITER, -1);\n+\n+        // validate: if number of fields is incorrect, give exception\n+        if (fieldValues.length != headerNames.length) {\n+            throw new IllegalArgumentException(\"Number of columns in line is not as expected. Expected: \"\n+                    + headerNames.length + \" columns, found: \" + fieldValues.length + \", for line: \" + line);\n+        }\n+\n+        // now iterate over lines and trim each value:\n+        for (int i = 0; i < fieldValues.length; i++) {\n+            fieldValues[i] = fieldValues[i].trim();\n+        }\n+        return fieldValues;\n+    }\n+\n+    private Boolean isValueNotMissing(String value) {\n+        if (MissingValues.has(value)) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private Boolean isValidResourceType(String value) {\n+        try {\n+            ResourceTypes.valueOf(value);\n+        } catch (IllegalArgumentException ex) {\n+            throw new IllegalArgumentException(\"Resource_Type should be one of the following : 'SAMPLE', 'PATIENT' or 'STUDY'.\"\n+                    + \"found: \" + value);\n+        }\n+        return true;\n+    }\n+\n+    private Boolean isValidOpenByDefault(String value) {\n+        if (value.equalsIgnoreCase(\"true\") || value.equalsIgnoreCase(\"false\")) {\n+            return true;\n+        }\n+        // open by default value not valid, will set as false by default\n+        ProgressMonitor.logWarning(\"OpenByDefault value is not true or false, set to false by default.\");\n+        return false;\n+    }\n+\n+    private int findAndValidateResourceIdColumn(String[] headerNames) {\n+        return findAndValidateColumnIndexInHeaders(RESOURCE_ID_COLUMN_NAME, headerNames);\n+    }\n+\n+    private int findAndValidateDisplayNameColumn(String[] headerNames) {\n+        return findAndValidateColumnIndexInHeaders(DISPLAY_NAME_COLUMN_NAME, headerNames);\n+    }\n+\n+    private int findAndValidateDescriptionColumn(String[] headerNames) {\n+        return findAndValidateColumnIndexInHeaders(DESCRIPTION_COLUMN_NAME, headerNames);\n+    }\n+\n+    private int findAndValidateResourceTypeColumn(String[] headerNames) {\n+        return findAndValidateColumnIndexInHeaders(RESOURCE_TYPE_COLUMN_NAME, headerNames);\n+    }\n+\n+    private int findAndValidateOpenByDefaultColumn(String[] headerNames) {\n+        return findAndValidateColumnIndexInHeaders(OPEN_BY_DEFAULT_COLUMN_NAME, headerNames);\n+    }\n+\n+    private int findAndValidatePriorityColumn(String[] headerNames) {\n+        return findAndValidateColumnIndexInHeaders(PRIORITY_COLUMN_NAME, headerNames);\n+    }\n+\n+    private int findAndValidateColumnIndexInHeaders(String columnHeader, String[] headerNames) {", "originalCommit": "ad5abf7c9634a54ebf671517257638ed6e6141d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d74442020a1b8e9e8ae90b124026151bbc31e14f", "url": "https://github.com/cBioPortal/cbioportal/commit/d74442020a1b8e9e8ae90b124026151bbc31e14f", "message": "address new comments", "committedDate": "2020-03-20T17:06:17Z", "type": "forcePushed"}, {"oid": "7a02f1fe6d7876b81ccca114d9423e745129900e", "url": "https://github.com/cBioPortal/cbioportal/commit/7a02f1fe6d7876b81ccca114d9423e745129900e", "message": "address new comments", "committedDate": "2020-03-20T17:58:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg1ODQ3MA==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395858470", "bodyText": "Any specific reason for overriding the value? its better to keep simple", "author": "kalletlak", "createdAt": "2020-03-20T19:50:53Z", "path": "model/src/main/java/org/cbioportal/model/ResourceType.java", "diffHunk": "@@ -1,7 +1,17 @@\n package org.cbioportal.model;\n \n public enum ResourceType {\n-    STUDY,\n-    SAMPLE,\n-    PATIENT\n+    STUDY(\"STUDY\"),", "originalCommit": "7a02f1fe6d7876b81ccca114d9423e745129900e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4NjM2MQ==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395886361", "bodyText": "I want to get the string value from the ResourceType, I didn't have a way to do that, so I overrode this.\nIs there a way to get the value of the ResourceType? For example https://github.com/cBioPortal/cbioportal/pull/7270/files#diff-5041ba5290d6be4231695bde8b85883bR28.", "author": "dippindots", "createdAt": "2020-03-20T20:57:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg1ODQ3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU1NzE0Nw==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r396557147", "bodyText": "there is name() to get string value", "author": "kalletlak", "createdAt": "2020-03-23T15:53:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg1ODQ3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU5MTA3NQ==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r396591075", "bodyText": "Thanks! Got it!", "author": "dippindots", "createdAt": "2020-03-23T16:37:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg1ODQ3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg2MDgyNw==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395860827", "bodyText": "looks like resourceIdIndex cannot be -1. It would throw RuntimeException", "author": "kalletlak", "createdAt": "2020-03-20T19:56:10Z", "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceDefinition.java", "diffHunk": "@@ -0,0 +1,337 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.cbioportal.model.ResourceType;\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+import org.mskcc.cbio.portal.util.ValuesUtils.MissingValues;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+\n+public class ImportResourceDefinition extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String DISPLAY_NAME_COLUMN_NAME = \"DISPLAY_NAME\";\n+    public static final String DESCRIPTION_COLUMN_NAME = \"DESCRIPTION\";\n+    public static final String RESOURCE_TYPE_COLUMN_NAME = \"RESOURCE_TYPE\";\n+    public static final String OPEN_BY_DEFAULT_COLUMN_NAME = \"OPEN_BY_DEFAULT\";\n+    public static final String PRIORITY_COLUMN_NAME = \"PRIORITY\";\n+    private int numResourceDefinitionsAdded = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private boolean relaxed;\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+\n+        String line = buff.readLine();\n+        String[] headerNames = splitFields(line);\n+        Map<String, Integer> headerIndexMap = makeHeaderIndexMap(headerNames);\n+\n+        // validate columns and get index\n+        int resourceIdIndex = findAndValidateResourceIdColumn(headerIndexMap);\n+        int displayNameIndex = findAndValidateDisplayNameColumn(headerIndexMap);\n+        int descriptionIndex = findAndValidateDescriptionColumn(headerIndexMap);\n+        int resourceTypeIndex = findAndValidateResourceTypeColumn(headerIndexMap);\n+        int openByDefaultIndex = findAndValidateOpenByDefaultColumn(headerIndexMap);\n+        int priorityIndex = findAndValidatePriorityColumn(headerIndexMap);\n+\n+        while ((line = buff.readLine()) != null) {\n+            if (skipLine(line.trim())) {\n+                continue;\n+            }\n+\n+            String[] fieldValues = getFieldValues(line, headerIndexMap);\n+\n+            // set default value\n+            String resourceId = \"\";\n+            String displayName = \"\";\n+            String description = \"\";\n+            ResourceType resourceType = null;\n+            Boolean openByDefault = false;\n+            int priority = 1;\n+            // get resource definitions from columns\n+            // get resourceId\n+            if (resourceIdIndex != -1 && isValueNotMissing(fieldValues[resourceIdIndex].toUpperCase())) {", "originalCommit": "7a02f1fe6d7876b81ccca114d9423e745129900e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg2MTQ4Nw==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395861487", "bodyText": "should be displayNameIndex", "author": "kalletlak", "createdAt": "2020-03-20T19:57:34Z", "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceDefinition.java", "diffHunk": "@@ -0,0 +1,337 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.cbioportal.model.ResourceType;\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+import org.mskcc.cbio.portal.util.ValuesUtils.MissingValues;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+\n+public class ImportResourceDefinition extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String DISPLAY_NAME_COLUMN_NAME = \"DISPLAY_NAME\";\n+    public static final String DESCRIPTION_COLUMN_NAME = \"DESCRIPTION\";\n+    public static final String RESOURCE_TYPE_COLUMN_NAME = \"RESOURCE_TYPE\";\n+    public static final String OPEN_BY_DEFAULT_COLUMN_NAME = \"OPEN_BY_DEFAULT\";\n+    public static final String PRIORITY_COLUMN_NAME = \"PRIORITY\";\n+    private int numResourceDefinitionsAdded = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private boolean relaxed;\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+\n+        String line = buff.readLine();\n+        String[] headerNames = splitFields(line);\n+        Map<String, Integer> headerIndexMap = makeHeaderIndexMap(headerNames);\n+\n+        // validate columns and get index\n+        int resourceIdIndex = findAndValidateResourceIdColumn(headerIndexMap);\n+        int displayNameIndex = findAndValidateDisplayNameColumn(headerIndexMap);\n+        int descriptionIndex = findAndValidateDescriptionColumn(headerIndexMap);\n+        int resourceTypeIndex = findAndValidateResourceTypeColumn(headerIndexMap);\n+        int openByDefaultIndex = findAndValidateOpenByDefaultColumn(headerIndexMap);\n+        int priorityIndex = findAndValidatePriorityColumn(headerIndexMap);\n+\n+        while ((line = buff.readLine()) != null) {\n+            if (skipLine(line.trim())) {\n+                continue;\n+            }\n+\n+            String[] fieldValues = getFieldValues(line, headerIndexMap);\n+\n+            // set default value\n+            String resourceId = \"\";\n+            String displayName = \"\";\n+            String description = \"\";\n+            ResourceType resourceType = null;\n+            Boolean openByDefault = false;\n+            int priority = 1;\n+            // get resource definitions from columns\n+            // get resourceId\n+            if (resourceIdIndex != -1 && isValueNotMissing(fieldValues[resourceIdIndex].toUpperCase())) {\n+                resourceId = fieldValues[resourceIdIndex].toUpperCase();\n+            } else {\n+                throw new RuntimeException(\n+                        \"Please provide a valid resource id\");\n+            }\n+            // get displayName\n+            if (resourceIdIndex != -1 && isValueNotMissing(fieldValues[displayNameIndex])) {", "originalCommit": "7a02f1fe6d7876b81ccca114d9423e745129900e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg3MTU4Mw==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395871583", "bodyText": "why not MissingValues enum directly instead of ValuesUtils", "author": "kalletlak", "createdAt": "2020-03-20T20:21:21Z", "path": "core/src/main/java/org/mskcc/cbio/portal/util/ValuesUtils.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package org.mskcc.cbio.portal.util;\n+\n+public class ValuesUtils {\n+    public static enum MissingValues {", "originalCommit": "7a02f1fe6d7876b81ccca114d9423e745129900e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg3MjA2NA==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395872064", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    String[] fields = line.split(DELIMITER, -1);\n          \n          \n            \n                   return line.split(DELIMITER, -1);", "author": "kalletlak", "createdAt": "2020-03-20T20:22:31Z", "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceDefinition.java", "diffHunk": "@@ -0,0 +1,337 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.cbioportal.model.ResourceType;\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+import org.mskcc.cbio.portal.util.ValuesUtils.MissingValues;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+\n+public class ImportResourceDefinition extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String DISPLAY_NAME_COLUMN_NAME = \"DISPLAY_NAME\";\n+    public static final String DESCRIPTION_COLUMN_NAME = \"DESCRIPTION\";\n+    public static final String RESOURCE_TYPE_COLUMN_NAME = \"RESOURCE_TYPE\";\n+    public static final String OPEN_BY_DEFAULT_COLUMN_NAME = \"OPEN_BY_DEFAULT\";\n+    public static final String PRIORITY_COLUMN_NAME = \"PRIORITY\";\n+    private int numResourceDefinitionsAdded = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private boolean relaxed;\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+\n+        String line = buff.readLine();\n+        String[] headerNames = splitFields(line);\n+        Map<String, Integer> headerIndexMap = makeHeaderIndexMap(headerNames);\n+\n+        // validate columns and get index\n+        int resourceIdIndex = findAndValidateResourceIdColumn(headerIndexMap);\n+        int displayNameIndex = findAndValidateDisplayNameColumn(headerIndexMap);\n+        int descriptionIndex = findAndValidateDescriptionColumn(headerIndexMap);\n+        int resourceTypeIndex = findAndValidateResourceTypeColumn(headerIndexMap);\n+        int openByDefaultIndex = findAndValidateOpenByDefaultColumn(headerIndexMap);\n+        int priorityIndex = findAndValidatePriorityColumn(headerIndexMap);\n+\n+        while ((line = buff.readLine()) != null) {\n+            if (skipLine(line.trim())) {\n+                continue;\n+            }\n+\n+            String[] fieldValues = getFieldValues(line, headerIndexMap);\n+\n+            // set default value\n+            String resourceId = \"\";\n+            String displayName = \"\";\n+            String description = \"\";\n+            ResourceType resourceType = null;\n+            Boolean openByDefault = false;\n+            int priority = 1;\n+            // get resource definitions from columns\n+            // get resourceId\n+            if (resourceIdIndex != -1 && isValueNotMissing(fieldValues[resourceIdIndex].toUpperCase())) {\n+                resourceId = fieldValues[resourceIdIndex].toUpperCase();\n+            } else {\n+                throw new RuntimeException(\n+                        \"Please provide a valid resource id\");\n+            }\n+            // get displayName\n+            if (resourceIdIndex != -1 && isValueNotMissing(fieldValues[displayNameIndex])) {\n+                displayName = fieldValues[displayNameIndex];\n+            }\n+            else {\n+                throw new RuntimeException(\n+                        \"Please provide a valid display name\");\n+            }\n+            // get description (optional)\n+            if (descriptionIndex != -1 && isValueNotMissing(fieldValues[descriptionIndex])) {\n+                description = fieldValues[descriptionIndex];\n+            }\n+            // get resourceType (must be value of ResourceTypes)\n+            if (resourceTypeIndex != -1 && isValidResourceType(fieldValues[resourceTypeIndex])) {\n+                resourceType = ResourceType.valueOf(fieldValues[resourceTypeIndex]);\n+            }\n+            // get openByDefault (optional)\n+            if (openByDefaultIndex != -1 && isValidOpenByDefault(fieldValues[openByDefaultIndex])) {\n+                openByDefault = Boolean.parseBoolean(fieldValues[openByDefaultIndex]);\n+            }\n+            // get priority (optional)\n+            try {\n+                priority = Integer.parseInt(fieldValues[priorityIndex]);\n+            } catch (NumberFormatException ex) {\n+                throw new DaoException(\n+                    \"priority cannot be parsed as an integer, all priority should be an integer.\");\n+            }\n+\n+            // add resource definitions into database\n+            ResourceDefinition resource = new ResourceDefinition(resourceId, displayName,\n+                    description, resourceType, openByDefault,\n+                    priority, cancerStudy.getInternalId());\n+\n+            ResourceDefinition resourceInDb = DaoResourceDefinition.getDatum(resource.getResourceId(),\n+                    cancerStudy.getInternalId());\n+            if (resourceInDb != null) {\n+                ProgressMonitor.logWarning(\"Resource \" + resourceInDb.getResourceId() + \" found twice in your study!\");\n+                continue;\n+            }\n+            if (DaoResourceDefinition.addDatum(resource) > 0) {\n+                numResourceDefinitionsAdded++;\n+            }\n+        }\n+        buff.close();\n+\n+        if (MySQLbulkLoader.isBulkLoad()) {\n+            MySQLbulkLoader.flushAll();\n+            MySQLbulkLoader.relaxedModeOff();\n+        }\n+    }\n+\n+    private String[] splitFields(String line) throws IOException {\n+        String[] fields = line.split(DELIMITER, -1);", "originalCommit": "7a02f1fe6d7876b81ccca114d9423e745129900e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg3MjMzMQ==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395872331", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (MissingValues.has(value)) {\n          \n          \n            \n                    return !MissingValues.has(value);", "author": "kalletlak", "createdAt": "2020-03-20T20:23:07Z", "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceDefinition.java", "diffHunk": "@@ -0,0 +1,337 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.cbioportal.model.ResourceType;\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+import org.mskcc.cbio.portal.util.ValuesUtils.MissingValues;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+\n+public class ImportResourceDefinition extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String DISPLAY_NAME_COLUMN_NAME = \"DISPLAY_NAME\";\n+    public static final String DESCRIPTION_COLUMN_NAME = \"DESCRIPTION\";\n+    public static final String RESOURCE_TYPE_COLUMN_NAME = \"RESOURCE_TYPE\";\n+    public static final String OPEN_BY_DEFAULT_COLUMN_NAME = \"OPEN_BY_DEFAULT\";\n+    public static final String PRIORITY_COLUMN_NAME = \"PRIORITY\";\n+    private int numResourceDefinitionsAdded = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private boolean relaxed;\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+\n+        String line = buff.readLine();\n+        String[] headerNames = splitFields(line);\n+        Map<String, Integer> headerIndexMap = makeHeaderIndexMap(headerNames);\n+\n+        // validate columns and get index\n+        int resourceIdIndex = findAndValidateResourceIdColumn(headerIndexMap);\n+        int displayNameIndex = findAndValidateDisplayNameColumn(headerIndexMap);\n+        int descriptionIndex = findAndValidateDescriptionColumn(headerIndexMap);\n+        int resourceTypeIndex = findAndValidateResourceTypeColumn(headerIndexMap);\n+        int openByDefaultIndex = findAndValidateOpenByDefaultColumn(headerIndexMap);\n+        int priorityIndex = findAndValidatePriorityColumn(headerIndexMap);\n+\n+        while ((line = buff.readLine()) != null) {\n+            if (skipLine(line.trim())) {\n+                continue;\n+            }\n+\n+            String[] fieldValues = getFieldValues(line, headerIndexMap);\n+\n+            // set default value\n+            String resourceId = \"\";\n+            String displayName = \"\";\n+            String description = \"\";\n+            ResourceType resourceType = null;\n+            Boolean openByDefault = false;\n+            int priority = 1;\n+            // get resource definitions from columns\n+            // get resourceId\n+            if (resourceIdIndex != -1 && isValueNotMissing(fieldValues[resourceIdIndex].toUpperCase())) {\n+                resourceId = fieldValues[resourceIdIndex].toUpperCase();\n+            } else {\n+                throw new RuntimeException(\n+                        \"Please provide a valid resource id\");\n+            }\n+            // get displayName\n+            if (resourceIdIndex != -1 && isValueNotMissing(fieldValues[displayNameIndex])) {\n+                displayName = fieldValues[displayNameIndex];\n+            }\n+            else {\n+                throw new RuntimeException(\n+                        \"Please provide a valid display name\");\n+            }\n+            // get description (optional)\n+            if (descriptionIndex != -1 && isValueNotMissing(fieldValues[descriptionIndex])) {\n+                description = fieldValues[descriptionIndex];\n+            }\n+            // get resourceType (must be value of ResourceTypes)\n+            if (resourceTypeIndex != -1 && isValidResourceType(fieldValues[resourceTypeIndex])) {\n+                resourceType = ResourceType.valueOf(fieldValues[resourceTypeIndex]);\n+            }\n+            // get openByDefault (optional)\n+            if (openByDefaultIndex != -1 && isValidOpenByDefault(fieldValues[openByDefaultIndex])) {\n+                openByDefault = Boolean.parseBoolean(fieldValues[openByDefaultIndex]);\n+            }\n+            // get priority (optional)\n+            try {\n+                priority = Integer.parseInt(fieldValues[priorityIndex]);\n+            } catch (NumberFormatException ex) {\n+                throw new DaoException(\n+                    \"priority cannot be parsed as an integer, all priority should be an integer.\");\n+            }\n+\n+            // add resource definitions into database\n+            ResourceDefinition resource = new ResourceDefinition(resourceId, displayName,\n+                    description, resourceType, openByDefault,\n+                    priority, cancerStudy.getInternalId());\n+\n+            ResourceDefinition resourceInDb = DaoResourceDefinition.getDatum(resource.getResourceId(),\n+                    cancerStudy.getInternalId());\n+            if (resourceInDb != null) {\n+                ProgressMonitor.logWarning(\"Resource \" + resourceInDb.getResourceId() + \" found twice in your study!\");\n+                continue;\n+            }\n+            if (DaoResourceDefinition.addDatum(resource) > 0) {\n+                numResourceDefinitionsAdded++;\n+            }\n+        }\n+        buff.close();\n+\n+        if (MySQLbulkLoader.isBulkLoad()) {\n+            MySQLbulkLoader.flushAll();\n+            MySQLbulkLoader.relaxedModeOff();\n+        }\n+    }\n+\n+    private String[] splitFields(String line) throws IOException {\n+        String[] fields = line.split(DELIMITER, -1);\n+\n+        return fields;\n+    }\n+\n+    private boolean skipLine(String line) {\n+        return line.isEmpty();\n+    }\n+\n+    /**\n+     * Takes in the given line and returns the list of field values by splitting the\n+     * line on DELIMITER.\n+     * \n+     * @param line\n+     * @param headerIndexMap\n+     * @return the list of values, one for each column. Value will be \"\" for empty\n+     *         columns.\n+     */\n+    private String[] getFieldValues(String line, Map<String, Integer> headerIndexMap) {\n+        // split on delimiter:\n+        String[] fieldValues = line.split(DELIMITER, -1);\n+\n+        // validate: if number of fields is incorrect, give exception\n+        if (fieldValues.length != headerIndexMap.size()) {\n+            throw new IllegalArgumentException(\"Number of columns in line is not as expected. Expected: \"\n+                    + headerIndexMap.size() + \" columns, found: \" + fieldValues.length + \", for line: \" + line);\n+        }\n+\n+        // now iterate over lines and trim each value:\n+        for (int i = 0; i < fieldValues.length; i++) {\n+            fieldValues[i] = fieldValues[i].trim();\n+        }\n+        return fieldValues;\n+    }\n+\n+    private Boolean isValueNotMissing(String value) {\n+        if (MissingValues.has(value)) {", "originalCommit": "7a02f1fe6d7876b81ccca114d9423e745129900e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg3Njk1MQ==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r395876951", "bodyText": "may be\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (headerIndexMap.containsKey(columnHeader)) {\n          \n          \n            \n                    return headerIndexMap.getOrDefault(columnHeader, -1);", "author": "kalletlak", "createdAt": "2020-03-20T20:34:10Z", "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "diffHunk": "@@ -0,0 +1,559 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+import org.mskcc.cbio.portal.util.ValuesUtils.MissingValues;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+import java.util.regex.*;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections.map.MultiKeyMap;\n+import org.cbioportal.model.ResourceType;\n+\n+public class ImportResourceData extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String METADATA_PREFIX = \"#\";\n+    public static final String SAMPLE_ID_COLUMN_NAME = \"SAMPLE_ID\";\n+    public static final String PATIENT_ID_COLUMN_NAME = \"PATIENT_ID\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String URL_COLUMN_NAME = \"URL\";\n+    public static final String SAMPLE_TYPE_COLUMN_NAME = \"SAMPLE_TYPE\";\n+    private int numSampleSpecificResourcesAdded = 0;\n+    private int numPatientSpecificResourcesAdded = 0;\n+    private int numStudySpecificResourcesAdded = 0;\n+    private int numEmptyResourcesSkipped = 0;\n+    private int numSamplesProcessed = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private ResourceType resourceType;\n+    private boolean relaxed;\n+    private Set<String> patientIds = new HashSet<String>();\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, String resourceType, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.resourceType = ResourceType.valueOf(resourceType);\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+        List<ResourceDefinition> resources = DaoResourceDefinition.getDatumByStudy(cancerStudy.getInternalId());\n+        String currentLine = buff.readLine();\n+        String[] headerNames = currentLine.split(\"\\t\");\n+        Map<String, Integer> headerIndexMap = makeHeaderIndexMap(headerNames);\n+        \n+        int patientIdIndex = findPatientIdColumn(headerIndexMap);\n+        int sampleIdIndex = findSampleIdColumn(headerIndexMap);\n+        int resourceIdIndex = findResourceIdColumn(headerIndexMap);\n+        int urlIndex = findURLColumn(headerIndexMap);\n+\n+        // validate required columns:\n+        if (resourceIdIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + RESOURCE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (urlIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + URL_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if ((resourceType.equals(ResourceType.SAMPLE) || resourceType.equals(ResourceType.PATIENT)) && patientIdIndex < 0) {\n+            // PATIENT_ID is required in both patient and sample file types:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + PATIENT_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (resourceType.equals(ResourceType.SAMPLE) && sampleIdIndex < 0) {\n+            // SAMPLE_ID is required in SAMPLE file type:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + SAMPLE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        importData(buff, resources, headerIndexMap);\n+        buff.close();\n+\n+        if (MySQLbulkLoader.isBulkLoad()) {\n+            MySQLbulkLoader.flushAll();\n+            MySQLbulkLoader.relaxedModeOff();\n+        }\n+    }\n+\n+    private void importData(BufferedReader buff, List<ResourceDefinition> resources, Map<String, Integer> headerIndexMap) throws Exception {\n+        String line;\n+        MultiKeyMap resourceMap = new MultiKeyMap();\n+        // create resource_id set\n+        Set<String> patientResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceType.PATIENT))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+        Set<String> sampleResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceType.SAMPLE))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+        Set<String> studyResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceType.STUDY))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+\n+        while ((line = buff.readLine()) != null) {\n+            if (skipLine(line.trim())) {\n+                continue;\n+            }\n+\n+            String[] fieldValues = getFieldValues(line, headerIndexMap);\n+            addDatum(fieldValues, resources, resourceMap, headerIndexMap, patientResourceIdSet, sampleResourceIdSet, studyResourceIdSet);\n+        }\n+    }\n+\n+    private boolean skipLine(String line) {\n+        return (line.isEmpty() || line.substring(0, 1).equals(METADATA_PREFIX));\n+    }\n+\n+    /**\n+     * Takes in the given line and returns the list of field values by splitting the\n+     * line on DELIMITER.\n+     * \n+     * @param line\n+     * @param headerIndexMap\n+     * @return the list of values, one for each column. Value will be \"\" for empty\n+     *         columns.\n+     */\n+    private String[] getFieldValues(String line, Map<String, Integer> headerIndexMap) {\n+        // split on delimiter:\n+        String[] fieldValues = line.split(DELIMITER, -1);\n+\n+        // validate: if number of fields is incorrect, give exception\n+        if (fieldValues.length != headerIndexMap.size()) {\n+            throw new IllegalArgumentException(\"Number of columns in line is not as expected. Expected: \"\n+                    + headerIndexMap.size() + \" columns, found: \" + fieldValues.length + \", for line: \" + line);\n+        }\n+\n+        // now iterate over lines and trim each value:\n+        for (int i = 0; i < fieldValues.length; i++) {\n+            fieldValues[i] = fieldValues[i].trim();\n+        }\n+        return fieldValues;\n+    }\n+\n+    private boolean addDatum(String[] fields, List<ResourceDefinition> resources, MultiKeyMap resourceMap, Map<String, Integer> headerIndexMap, Set<String> patientResourceIdSet, Set<String> sampleResourceIdSet, Set<String> studyResourceIdSet)\n+            throws Exception {\n+        int sampleIdIndex = findSampleIdColumn(headerIndexMap);\n+        String stableSampleId = (sampleIdIndex >= 0) ? fields[sampleIdIndex] : \"\";\n+        stableSampleId = StableIdUtil.getSampleId(stableSampleId);\n+        int patientIdIndex = findPatientIdColumn(headerIndexMap);\n+        String stablePatientId = (patientIdIndex >= 0) ? fields[patientIdIndex] : \"\";\n+        stablePatientId = StableIdUtil.getPatientId(stablePatientId);\n+        int resourceIdIndex = findResourceIdColumn(headerIndexMap);\n+        int urlIndex = findURLColumn(headerIndexMap);\n+        int internalSampleId = -1;\n+        int internalPatientId = -1;\n+\n+        // validate sample and patient for sample or patient attibutes\n+        if (resourceType.equals(ResourceType.SAMPLE) || resourceType.equals(ResourceType.PATIENT)) {\n+            // check if sample is not already added:\n+            Sample sample = DaoSample.getSampleByCancerStudyAndSampleId(cancerStudy.getInternalId(), stableSampleId, false);\n+            if (sample != null) {\n+                // get internal sample id if sample exists\n+                internalSampleId = sample.getInternalId();\n+            } else {\n+                Patient patient = DaoPatient.getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(),\n+                        stablePatientId);\n+                if (patient != null) {\n+                    // patient exists, get internal id:\n+                    internalPatientId = patient.getInternalId();\n+                } else {\n+                    // add patient:\n+                    internalPatientId = (patientIdIndex >= 0) ? addPatientToDatabase(fields[patientIdIndex]) : -1;\n+                }\n+                // sample is new, so attempt to add to DB\n+                internalSampleId = (stableSampleId.length() > 0) ? addSampleToDatabase(stableSampleId, fields, headerIndexMap)\n+                        : -1;\n+            }\n+\n+            // validate and count:\n+            if (internalSampleId != -1) {\n+                // some minimal validation/fail safe for now: only continue if patientId is same\n+                // as patient id in\n+                // existing sample (can occur in case of this.isSupplementalData or in case of\n+                // parsing bug in addSampleToDatabase):\n+                internalPatientId = DaoPatient\n+                        .getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(), stablePatientId).getInternalId();\n+                if (internalPatientId != DaoSample.getSampleById(internalSampleId).getInternalPatientId()) {\n+                    throw new RuntimeException(\"Error: Sample \" + stableSampleId\n+                            + \" was previously linked to another patient, and not to \" + stablePatientId);\n+                }\n+                numSamplesProcessed++;\n+            }\n+        }\n+\n+        // if the resource id or url matches one of the missing values, skip this resource:\n+        if ((resourceIdIndex != -1 && MissingValues.has(fields[resourceIdIndex])) || (urlIndex != -1 && MissingValues.has(fields[urlIndex]))) {\n+            numEmptyResourcesSkipped++;\n+        } else {\n+            // if patient_id column exists and resource type is patient\n+            if (getResourceType() == ResourceType.PATIENT && internalPatientId != -1) {\n+                validateAddDatum(internalPatientId, stablePatientId, fields[resourceIdIndex], fields[urlIndex], \n+                        ResourceType.PATIENT, patientResourceIdSet, resourceMap);\n+            } \n+            // if sample_id column exists and resource type is sample\n+            else if (getResourceType() == ResourceType.SAMPLE && internalSampleId != -1) {\n+                validateAddDatum(internalSampleId, stableSampleId, fields[resourceIdIndex], fields[urlIndex], \n+                        ResourceType.SAMPLE, sampleResourceIdSet, resourceMap);\n+            }\n+            // if resource type is study\n+            else if (getResourceType() == ResourceType.STUDY) {\n+                validateAddDatum(cancerStudy.getInternalId(), cancerStudy.getCancerStudyStableId(), fields[resourceIdIndex], fields[urlIndex], \n+                        ResourceType.STUDY, studyResourceIdSet, resourceMap);\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private Map<String, Integer> makeHeaderIndexMap(String[] headerNames) {\n+        Map<String, Integer> headerIndexMap = new HashMap<String, Integer>();\n+        for (int i= 0; i < headerNames.length; i++) {\n+            headerIndexMap.put(headerNames[i], i);\n+        }\n+        return headerIndexMap;\n+    }\n+\n+    private int findPatientIdColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(PATIENT_ID_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findSampleIdColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(SAMPLE_ID_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findResourceIdColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(RESOURCE_ID_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findURLColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(URL_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findSampleTypeColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(SAMPLE_TYPE_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findColumnIndexInHeaders(String columnHeader, Map<String, Integer> headerIndexMap) {\n+        if (headerIndexMap.containsKey(columnHeader)) {", "originalCommit": "7a02f1fe6d7876b81ccca114d9423e745129900e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ3NjI3NQ==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r396476275", "bodyText": "looks like this method is never used", "author": "kalletlak", "createdAt": "2020-03-23T14:07:07Z", "path": "core/src/main/java/org/mskcc/cbio/portal/dao/DaoResourceData.java", "diffHunk": "@@ -0,0 +1,214 @@\n+package org.mskcc.cbio.portal.dao;\n+\n+import org.mskcc.cbio.portal.model.*;\n+\n+import org.apache.commons.lang.StringUtils;\n+\n+import java.sql.*;\n+import java.util.*;\n+\n+/**\n+ * Data Access Object for `resource` tables\n+ */\n+public final class DaoResourceData {\n+\n+    public static final String RESOURCE_SAMPLE_TABLE = \"resource_sample\";\n+    public static final String RESOURCE_PATIENT_TABLE = \"resource_patient\";\n+    public static final String RESOURCE_STUDY_TABLE = \"resource_study\";\n+\n+    private static final String SAMPLE_INSERT = \"INSERT INTO \" + RESOURCE_SAMPLE_TABLE\n+            + \"(`INTERNAL_ID`,`RESOURCE_ID`,`URL` VALUES(?,?,?)\";\n+    private static final String PATIENT_INSERT = \"INSERT INTO \" + RESOURCE_PATIENT_TABLE\n+            + \"(`INTERNAL_ID`,`RESOURCE_ID`,`URL` VALUES(?,?,?)\";\n+    private static final String STUDY_INSERT = \"INSERT INTO \" + RESOURCE_STUDY_TABLE\n+            + \"(`INTERNAL_ID`,`RESOURCE_ID`,`URL` VALUES(?,?,?)\";\n+\n+    private static final Map<String, String> sampleResources = new HashMap<String, String>();\n+    private static final Map<String, String> patientResources = new HashMap<String, String>();\n+    private static final Map<String, String> studyResources = new HashMap<String, String>();\n+\n+    private DaoResourceData() {\n+    }\n+\n+    public static synchronized void reCache() {\n+        clearCache();\n+        cacheResources(RESOURCE_SAMPLE_TABLE, sampleResources);\n+        cacheResources(RESOURCE_PATIENT_TABLE, patientResources);\n+        cacheResources(RESOURCE_STUDY_TABLE, studyResources);\n+    }\n+\n+    private static void clearCache() {\n+        sampleResources.clear();\n+        patientResources.clear();\n+        studyResources.clear();\n+    }\n+\n+    private static void cacheResources(String table, Map<String, String> cache) {\n+        Connection con = null;\n+        PreparedStatement pstmt = null;\n+        ResultSet rs = null;\n+        try {\n+            con = JdbcUtil.getDbConnection(DaoResourceData.class);\n+            pstmt = con.prepareStatement(\"SELECT * FROM \" + table);\n+            rs = pstmt.executeQuery();\n+            while (rs.next()) {\n+                cache.put(rs.getString(\"RESOURCE_ID\"), rs.getString(\"RESOURCE_ID\"));\n+            }\n+        } catch (SQLException e) {\n+            e.printStackTrace();\n+        } finally {\n+            JdbcUtil.closeAll(DaoResourceData.class, con, pstmt, rs);\n+        }\n+    }\n+\n+    public static int addSampleDatum(int internalSampleId, String resourceId, String url) throws DaoException {\n+        sampleResources.put(resourceId, resourceId);\n+        return addDatum(SAMPLE_INSERT, RESOURCE_SAMPLE_TABLE, internalSampleId, resourceId, url);\n+    }\n+\n+    public static int addPatientDatum(int internalPatientId, String resourceId, String url) throws DaoException {\n+        patientResources.put(resourceId, resourceId);\n+        return addDatum(PATIENT_INSERT, RESOURCE_PATIENT_TABLE, internalPatientId, resourceId, url);\n+    }\n+\n+    public static int addStudyDatum(int internalStudyId, String resourceId, String url) throws DaoException {\n+        patientResources.put(resourceId, resourceId);\n+        return addDatum(STUDY_INSERT, RESOURCE_STUDY_TABLE, internalStudyId, resourceId, url);\n+    }\n+\n+    public static int addDatum(String query, String tableName, int internalId, String resourceId, String url)\n+            throws DaoException {\n+        if (MySQLbulkLoader.isBulkLoad()) {\n+            MySQLbulkLoader.getMySQLbulkLoader(tableName).insertRecord(Integer.toString(internalId), resourceId, url);\n+            return 1;\n+        }\n+\n+        Connection con = null;\n+        PreparedStatement pstmt = null;\n+        ResultSet rs = null;\n+        try {\n+            con = JdbcUtil.getDbConnection(DaoResourceData.class);\n+\n+            pstmt = con.prepareStatement(query);\n+            pstmt.setInt(1, internalId);\n+            pstmt.setString(2, resourceId);\n+            pstmt.setString(3, url);\n+            int toReturn = pstmt.executeUpdate();\n+\n+            if (tableName.equals(RESOURCE_PATIENT_TABLE)) {\n+                patientResources.put(resourceId, resourceId);\n+            } else if (tableName.equals(RESOURCE_SAMPLE_TABLE)){\n+                sampleResources.put(resourceId, resourceId);\n+            } else {\n+                studyResources.put(resourceId, resourceId);\n+            }\n+\n+            return toReturn;\n+        } catch (SQLException e) {\n+            throw new DaoException(e);\n+        } finally {\n+            JdbcUtil.closeAll(DaoResourceData.class, con, pstmt, rs);\n+        }\n+    }\n+\n+    public static ResourceBaseData getDatum(String cancerStudyId, String patientId, String resourceId) throws DaoException {", "originalCommit": "7a02f1fe6d7876b81ccca114d9423e745129900e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "863f86325bec0d8c34e1a9edd271a0351761301b", "url": "https://github.com/cBioPortal/cbioportal/commit/863f86325bec0d8c34e1a9edd271a0351761301b", "message": "address new comments", "committedDate": "2020-03-23T15:33:11Z", "type": "forcePushed"}, {"oid": "4e724ff759a02f25a33335b5d8aab57376718488", "url": "https://github.com/cBioPortal/cbioportal/commit/4e724ff759a02f25a33335b5d8aab57376718488", "message": "address new comments", "committedDate": "2020-03-23T16:36:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYwMDM3MA==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r396600370", "bodyText": "sampleResources, patientResources and studyResources are never used. only data is added or updated. I think all the cache related code can be removed", "author": "kalletlak", "createdAt": "2020-03-23T16:50:24Z", "path": "core/src/main/java/org/mskcc/cbio/portal/dao/DaoResourceData.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package org.mskcc.cbio.portal.dao;\n+\n+import org.mskcc.cbio.portal.model.*;\n+import org.apache.commons.lang.StringUtils;\n+import java.sql.*;\n+import java.util.*;\n+\n+/**\n+ * Data Access Object for `resource` tables\n+ */\n+public final class DaoResourceData {\n+\n+    public static final String RESOURCE_SAMPLE_TABLE = \"resource_sample\";\n+    public static final String RESOURCE_PATIENT_TABLE = \"resource_patient\";\n+    public static final String RESOURCE_STUDY_TABLE = \"resource_study\";\n+\n+    private static final String SAMPLE_INSERT = \"INSERT INTO \" + RESOURCE_SAMPLE_TABLE\n+            + \"(`INTERNAL_ID`,`RESOURCE_ID`,`URL` VALUES(?,?,?)\";\n+    private static final String PATIENT_INSERT = \"INSERT INTO \" + RESOURCE_PATIENT_TABLE\n+            + \"(`INTERNAL_ID`,`RESOURCE_ID`,`URL` VALUES(?,?,?)\";\n+    private static final String STUDY_INSERT = \"INSERT INTO \" + RESOURCE_STUDY_TABLE\n+            + \"(`INTERNAL_ID`,`RESOURCE_ID`,`URL` VALUES(?,?,?)\";\n+\n+    private static final Map<String, String> sampleResources = new HashMap<String, String>();\n+    private static final Map<String, String> patientResources = new HashMap<String, String>();\n+    private static final Map<String, String> studyResources = new HashMap<String, String>();", "originalCommit": "4e724ff759a02f25a33335b5d8aab57376718488", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYwNDczMQ==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r396604731", "bodyText": "this method is executed when patient is null(i.e from line 185). any specific reason for fetching patient again?", "author": "kalletlak", "createdAt": "2020-03-23T16:56:41Z", "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "diffHunk": "@@ -0,0 +1,555 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+import java.util.regex.*;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections.map.MultiKeyMap;\n+import org.cbioportal.model.ResourceType;\n+\n+public class ImportResourceData extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String METADATA_PREFIX = \"#\";\n+    public static final String SAMPLE_ID_COLUMN_NAME = \"SAMPLE_ID\";\n+    public static final String PATIENT_ID_COLUMN_NAME = \"PATIENT_ID\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String URL_COLUMN_NAME = \"URL\";\n+    public static final String SAMPLE_TYPE_COLUMN_NAME = \"SAMPLE_TYPE\";\n+    private int numSampleSpecificResourcesAdded = 0;\n+    private int numPatientSpecificResourcesAdded = 0;\n+    private int numStudySpecificResourcesAdded = 0;\n+    private int numEmptyResourcesSkipped = 0;\n+    private int numSamplesProcessed = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private ResourceType resourceType;\n+    private boolean relaxed;\n+    private Set<String> patientIds = new HashSet<String>();\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, String resourceType, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.resourceType = ResourceType.valueOf(resourceType);\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+        List<ResourceDefinition> resources = DaoResourceDefinition.getDatumByStudy(cancerStudy.getInternalId());\n+        String currentLine = buff.readLine();\n+        String[] headerNames = currentLine.split(\"\\t\");\n+        Map<String, Integer> headerIndexMap = makeHeaderIndexMap(headerNames);\n+        \n+        int patientIdIndex = findPatientIdColumn(headerIndexMap);\n+        int sampleIdIndex = findSampleIdColumn(headerIndexMap);\n+        int resourceIdIndex = findResourceIdColumn(headerIndexMap);\n+        int urlIndex = findURLColumn(headerIndexMap);\n+\n+        // validate required columns:\n+        if (resourceIdIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + RESOURCE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (urlIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + URL_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if ((resourceType.equals(ResourceType.SAMPLE) || resourceType.equals(ResourceType.PATIENT)) && patientIdIndex < 0) {\n+            // PATIENT_ID is required in both patient and sample file types:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + PATIENT_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (resourceType.equals(ResourceType.SAMPLE) && sampleIdIndex < 0) {\n+            // SAMPLE_ID is required in SAMPLE file type:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + SAMPLE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        importData(buff, resources, headerIndexMap);\n+        buff.close();\n+\n+        if (MySQLbulkLoader.isBulkLoad()) {\n+            MySQLbulkLoader.flushAll();\n+            MySQLbulkLoader.relaxedModeOff();\n+        }\n+    }\n+\n+    private void importData(BufferedReader buff, List<ResourceDefinition> resources, Map<String, Integer> headerIndexMap) throws Exception {\n+        String line;\n+        MultiKeyMap resourceMap = new MultiKeyMap();\n+        // create resource_id set\n+        Set<String> patientResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceType.PATIENT))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+        Set<String> sampleResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceType.SAMPLE))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+        Set<String> studyResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceType.STUDY))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+\n+        while ((line = buff.readLine()) != null) {\n+            if (skipLine(line.trim())) {\n+                continue;\n+            }\n+\n+            String[] fieldValues = getFieldValues(line, headerIndexMap);\n+            addDatum(fieldValues, resources, resourceMap, headerIndexMap, patientResourceIdSet, sampleResourceIdSet, studyResourceIdSet);\n+        }\n+    }\n+\n+    private boolean skipLine(String line) {\n+        return (line.isEmpty() || line.substring(0, 1).equals(METADATA_PREFIX));\n+    }\n+\n+    /**\n+     * Takes in the given line and returns the list of field values by splitting the\n+     * line on DELIMITER.\n+     * \n+     * @param line\n+     * @param headerIndexMap\n+     * @return the list of values, one for each column. Value will be \"\" for empty\n+     *         columns.\n+     */\n+    private String[] getFieldValues(String line, Map<String, Integer> headerIndexMap) {\n+        // split on delimiter:\n+        String[] fieldValues = line.split(DELIMITER, -1);\n+\n+        // validate: if number of fields is incorrect, give exception\n+        if (fieldValues.length != headerIndexMap.size()) {\n+            throw new IllegalArgumentException(\"Number of columns in line is not as expected. Expected: \"\n+                    + headerIndexMap.size() + \" columns, found: \" + fieldValues.length + \", for line: \" + line);\n+        }\n+\n+        // now iterate over lines and trim each value:\n+        for (int i = 0; i < fieldValues.length; i++) {\n+            fieldValues[i] = fieldValues[i].trim();\n+        }\n+        return fieldValues;\n+    }\n+\n+    private boolean addDatum(String[] fields, List<ResourceDefinition> resources, MultiKeyMap resourceMap, Map<String, Integer> headerIndexMap, Set<String> patientResourceIdSet, Set<String> sampleResourceIdSet, Set<String> studyResourceIdSet)\n+            throws Exception {\n+        int sampleIdIndex = findSampleIdColumn(headerIndexMap);\n+        String stableSampleId = (sampleIdIndex >= 0) ? fields[sampleIdIndex] : \"\";\n+        stableSampleId = StableIdUtil.getSampleId(stableSampleId);\n+        int patientIdIndex = findPatientIdColumn(headerIndexMap);\n+        String stablePatientId = (patientIdIndex >= 0) ? fields[patientIdIndex] : \"\";\n+        stablePatientId = StableIdUtil.getPatientId(stablePatientId);\n+        int resourceIdIndex = findResourceIdColumn(headerIndexMap);\n+        int urlIndex = findURLColumn(headerIndexMap);\n+        int internalSampleId = -1;\n+        int internalPatientId = -1;\n+\n+        // validate sample and patient for sample or patient attibutes\n+        if (resourceType.equals(ResourceType.SAMPLE) || resourceType.equals(ResourceType.PATIENT)) {\n+            // check if sample is not already added:\n+            Sample sample = DaoSample.getSampleByCancerStudyAndSampleId(cancerStudy.getInternalId(), stableSampleId, false);\n+            if (sample != null) {\n+                // get internal sample id if sample exists\n+                internalSampleId = sample.getInternalId();\n+            } else {\n+                Patient patient = DaoPatient.getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(),\n+                        stablePatientId);\n+                if (patient != null) {\n+                    // patient exists, get internal id:\n+                    internalPatientId = patient.getInternalId();\n+                } else {\n+                    // add patient:\n+                    internalPatientId = (patientIdIndex >= 0) ? addPatientToDatabase(fields[patientIdIndex]) : -1;\n+                }\n+                // sample is new, so attempt to add to DB\n+                internalSampleId = (stableSampleId.length() > 0) ? addSampleToDatabase(stableSampleId, fields, headerIndexMap)\n+                        : -1;\n+            }\n+\n+            // validate and count:\n+            if (internalSampleId != -1) {\n+                // some minimal validation/fail safe for now: only continue if patientId is same\n+                // as patient id in\n+                // existing sample (can occur in case of this.isSupplementalData or in case of\n+                // parsing bug in addSampleToDatabase):\n+                internalPatientId = DaoPatient\n+                        .getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(), stablePatientId).getInternalId();\n+                if (internalPatientId != DaoSample.getSampleById(internalSampleId).getInternalPatientId()) {\n+                    throw new RuntimeException(\"Error: Sample \" + stableSampleId\n+                            + \" was previously linked to another patient, and not to \" + stablePatientId);\n+                }\n+                numSamplesProcessed++;\n+            }\n+        }\n+\n+        // if the resource id or url matches one of the missing values, skip this resource:\n+        if ((resourceIdIndex != -1 && MissingValues.has(fields[resourceIdIndex])) || (urlIndex != -1 && MissingValues.has(fields[urlIndex]))) {\n+            numEmptyResourcesSkipped++;\n+        } else {\n+            // if patient_id column exists and resource type is patient\n+            if (getResourceType() == ResourceType.PATIENT && internalPatientId != -1) {\n+                validateAddDatum(internalPatientId, stablePatientId, fields[resourceIdIndex], fields[urlIndex], \n+                        ResourceType.PATIENT, patientResourceIdSet, resourceMap);\n+            } \n+            // if sample_id column exists and resource type is sample\n+            else if (getResourceType() == ResourceType.SAMPLE && internalSampleId != -1) {\n+                validateAddDatum(internalSampleId, stableSampleId, fields[resourceIdIndex], fields[urlIndex], \n+                        ResourceType.SAMPLE, sampleResourceIdSet, resourceMap);\n+            }\n+            // if resource type is study\n+            else if (getResourceType() == ResourceType.STUDY) {\n+                validateAddDatum(cancerStudy.getInternalId(), cancerStudy.getCancerStudyStableId(), fields[resourceIdIndex], fields[urlIndex], \n+                        ResourceType.STUDY, studyResourceIdSet, resourceMap);\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private Map<String, Integer> makeHeaderIndexMap(String[] headerNames) {\n+        Map<String, Integer> headerIndexMap = new HashMap<String, Integer>();\n+        for (int i= 0; i < headerNames.length; i++) {\n+            headerIndexMap.put(headerNames[i], i);\n+        }\n+        return headerIndexMap;\n+    }\n+\n+    private int findPatientIdColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(PATIENT_ID_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findSampleIdColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(SAMPLE_ID_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findResourceIdColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(RESOURCE_ID_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findURLColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(URL_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findSampleTypeColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(SAMPLE_TYPE_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findColumnIndexInHeaders(String columnHeader, Map<String, Integer> headerIndexMap) {\n+        return headerIndexMap.getOrDefault(columnHeader, -1);\n+    }\n+\n+    private int addPatientToDatabase(String patientId) throws Exception {\n+        int internalPatientId = -1;\n+        if (validPatientId(patientId)) {\n+            Patient patient = DaoPatient.getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(), patientId);", "originalCommit": "4e724ff759a02f25a33335b5d8aab57376718488", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYxMzM2MA==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r396613360", "bodyText": "Are we going to have sampleType(SAMPLE_TYPE column) in data file?", "author": "kalletlak", "createdAt": "2020-03-23T17:08:57Z", "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "diffHunk": "@@ -0,0 +1,555 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+import java.util.regex.*;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections.map.MultiKeyMap;\n+import org.cbioportal.model.ResourceType;\n+\n+public class ImportResourceData extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String METADATA_PREFIX = \"#\";\n+    public static final String SAMPLE_ID_COLUMN_NAME = \"SAMPLE_ID\";\n+    public static final String PATIENT_ID_COLUMN_NAME = \"PATIENT_ID\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String URL_COLUMN_NAME = \"URL\";\n+    public static final String SAMPLE_TYPE_COLUMN_NAME = \"SAMPLE_TYPE\";\n+    private int numSampleSpecificResourcesAdded = 0;\n+    private int numPatientSpecificResourcesAdded = 0;\n+    private int numStudySpecificResourcesAdded = 0;\n+    private int numEmptyResourcesSkipped = 0;\n+    private int numSamplesProcessed = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private ResourceType resourceType;\n+    private boolean relaxed;\n+    private Set<String> patientIds = new HashSet<String>();\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, String resourceType, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.resourceType = ResourceType.valueOf(resourceType);\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+        List<ResourceDefinition> resources = DaoResourceDefinition.getDatumByStudy(cancerStudy.getInternalId());\n+        String currentLine = buff.readLine();\n+        String[] headerNames = currentLine.split(\"\\t\");\n+        Map<String, Integer> headerIndexMap = makeHeaderIndexMap(headerNames);\n+        \n+        int patientIdIndex = findPatientIdColumn(headerIndexMap);\n+        int sampleIdIndex = findSampleIdColumn(headerIndexMap);\n+        int resourceIdIndex = findResourceIdColumn(headerIndexMap);\n+        int urlIndex = findURLColumn(headerIndexMap);\n+\n+        // validate required columns:\n+        if (resourceIdIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + RESOURCE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (urlIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + URL_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if ((resourceType.equals(ResourceType.SAMPLE) || resourceType.equals(ResourceType.PATIENT)) && patientIdIndex < 0) {\n+            // PATIENT_ID is required in both patient and sample file types:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + PATIENT_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (resourceType.equals(ResourceType.SAMPLE) && sampleIdIndex < 0) {\n+            // SAMPLE_ID is required in SAMPLE file type:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + SAMPLE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        importData(buff, resources, headerIndexMap);\n+        buff.close();\n+\n+        if (MySQLbulkLoader.isBulkLoad()) {\n+            MySQLbulkLoader.flushAll();\n+            MySQLbulkLoader.relaxedModeOff();\n+        }\n+    }\n+\n+    private void importData(BufferedReader buff, List<ResourceDefinition> resources, Map<String, Integer> headerIndexMap) throws Exception {\n+        String line;\n+        MultiKeyMap resourceMap = new MultiKeyMap();\n+        // create resource_id set\n+        Set<String> patientResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceType.PATIENT))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+        Set<String> sampleResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceType.SAMPLE))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+        Set<String> studyResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceType.STUDY))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+\n+        while ((line = buff.readLine()) != null) {\n+            if (skipLine(line.trim())) {\n+                continue;\n+            }\n+\n+            String[] fieldValues = getFieldValues(line, headerIndexMap);\n+            addDatum(fieldValues, resources, resourceMap, headerIndexMap, patientResourceIdSet, sampleResourceIdSet, studyResourceIdSet);\n+        }\n+    }\n+\n+    private boolean skipLine(String line) {\n+        return (line.isEmpty() || line.substring(0, 1).equals(METADATA_PREFIX));\n+    }\n+\n+    /**\n+     * Takes in the given line and returns the list of field values by splitting the\n+     * line on DELIMITER.\n+     * \n+     * @param line\n+     * @param headerIndexMap\n+     * @return the list of values, one for each column. Value will be \"\" for empty\n+     *         columns.\n+     */\n+    private String[] getFieldValues(String line, Map<String, Integer> headerIndexMap) {\n+        // split on delimiter:\n+        String[] fieldValues = line.split(DELIMITER, -1);\n+\n+        // validate: if number of fields is incorrect, give exception\n+        if (fieldValues.length != headerIndexMap.size()) {\n+            throw new IllegalArgumentException(\"Number of columns in line is not as expected. Expected: \"\n+                    + headerIndexMap.size() + \" columns, found: \" + fieldValues.length + \", for line: \" + line);\n+        }\n+\n+        // now iterate over lines and trim each value:\n+        for (int i = 0; i < fieldValues.length; i++) {\n+            fieldValues[i] = fieldValues[i].trim();\n+        }\n+        return fieldValues;\n+    }\n+\n+    private boolean addDatum(String[] fields, List<ResourceDefinition> resources, MultiKeyMap resourceMap, Map<String, Integer> headerIndexMap, Set<String> patientResourceIdSet, Set<String> sampleResourceIdSet, Set<String> studyResourceIdSet)\n+            throws Exception {\n+        int sampleIdIndex = findSampleIdColumn(headerIndexMap);\n+        String stableSampleId = (sampleIdIndex >= 0) ? fields[sampleIdIndex] : \"\";\n+        stableSampleId = StableIdUtil.getSampleId(stableSampleId);\n+        int patientIdIndex = findPatientIdColumn(headerIndexMap);\n+        String stablePatientId = (patientIdIndex >= 0) ? fields[patientIdIndex] : \"\";\n+        stablePatientId = StableIdUtil.getPatientId(stablePatientId);\n+        int resourceIdIndex = findResourceIdColumn(headerIndexMap);\n+        int urlIndex = findURLColumn(headerIndexMap);\n+        int internalSampleId = -1;\n+        int internalPatientId = -1;\n+\n+        // validate sample and patient for sample or patient attibutes\n+        if (resourceType.equals(ResourceType.SAMPLE) || resourceType.equals(ResourceType.PATIENT)) {\n+            // check if sample is not already added:\n+            Sample sample = DaoSample.getSampleByCancerStudyAndSampleId(cancerStudy.getInternalId(), stableSampleId, false);\n+            if (sample != null) {\n+                // get internal sample id if sample exists\n+                internalSampleId = sample.getInternalId();\n+            } else {\n+                Patient patient = DaoPatient.getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(),\n+                        stablePatientId);\n+                if (patient != null) {\n+                    // patient exists, get internal id:\n+                    internalPatientId = patient.getInternalId();\n+                } else {\n+                    // add patient:\n+                    internalPatientId = (patientIdIndex >= 0) ? addPatientToDatabase(fields[patientIdIndex]) : -1;\n+                }\n+                // sample is new, so attempt to add to DB\n+                internalSampleId = (stableSampleId.length() > 0) ? addSampleToDatabase(stableSampleId, fields, headerIndexMap)\n+                        : -1;\n+            }\n+\n+            // validate and count:\n+            if (internalSampleId != -1) {\n+                // some minimal validation/fail safe for now: only continue if patientId is same\n+                // as patient id in\n+                // existing sample (can occur in case of this.isSupplementalData or in case of\n+                // parsing bug in addSampleToDatabase):\n+                internalPatientId = DaoPatient\n+                        .getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(), stablePatientId).getInternalId();\n+                if (internalPatientId != DaoSample.getSampleById(internalSampleId).getInternalPatientId()) {\n+                    throw new RuntimeException(\"Error: Sample \" + stableSampleId\n+                            + \" was previously linked to another patient, and not to \" + stablePatientId);\n+                }\n+                numSamplesProcessed++;\n+            }\n+        }\n+\n+        // if the resource id or url matches one of the missing values, skip this resource:\n+        if ((resourceIdIndex != -1 && MissingValues.has(fields[resourceIdIndex])) || (urlIndex != -1 && MissingValues.has(fields[urlIndex]))) {\n+            numEmptyResourcesSkipped++;\n+        } else {\n+            // if patient_id column exists and resource type is patient\n+            if (getResourceType() == ResourceType.PATIENT && internalPatientId != -1) {\n+                validateAddDatum(internalPatientId, stablePatientId, fields[resourceIdIndex], fields[urlIndex], \n+                        ResourceType.PATIENT, patientResourceIdSet, resourceMap);\n+            } \n+            // if sample_id column exists and resource type is sample\n+            else if (getResourceType() == ResourceType.SAMPLE && internalSampleId != -1) {\n+                validateAddDatum(internalSampleId, stableSampleId, fields[resourceIdIndex], fields[urlIndex], \n+                        ResourceType.SAMPLE, sampleResourceIdSet, resourceMap);\n+            }\n+            // if resource type is study\n+            else if (getResourceType() == ResourceType.STUDY) {\n+                validateAddDatum(cancerStudy.getInternalId(), cancerStudy.getCancerStudyStableId(), fields[resourceIdIndex], fields[urlIndex], \n+                        ResourceType.STUDY, studyResourceIdSet, resourceMap);\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private Map<String, Integer> makeHeaderIndexMap(String[] headerNames) {\n+        Map<String, Integer> headerIndexMap = new HashMap<String, Integer>();\n+        for (int i= 0; i < headerNames.length; i++) {\n+            headerIndexMap.put(headerNames[i], i);\n+        }\n+        return headerIndexMap;\n+    }\n+\n+    private int findPatientIdColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(PATIENT_ID_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findSampleIdColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(SAMPLE_ID_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findResourceIdColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(RESOURCE_ID_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findURLColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(URL_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findSampleTypeColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(SAMPLE_TYPE_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findColumnIndexInHeaders(String columnHeader, Map<String, Integer> headerIndexMap) {\n+        return headerIndexMap.getOrDefault(columnHeader, -1);\n+    }\n+\n+    private int addPatientToDatabase(String patientId) throws Exception {\n+        int internalPatientId = -1;\n+        if (validPatientId(patientId)) {\n+            Patient patient = DaoPatient.getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(), patientId);\n+            // other validations:\n+            // in case of PATIENT data import, there are some special checks:\n+            if (getResourceType() == ResourceType.PATIENT) {\n+                // if resource data is already there, then something has gone wrong (e.g.\n+                // patient is duplicated in file), abort:\n+                if (patient != null\n+                        && DaoResourceData.getDataByPatientId(cancerStudy.getInternalId(), patientId).size() > 0) {\n+                    throw new RuntimeException(\n+                            \"Something has gone wrong. Patient \" + patientId + \" already has resource data loaded.\");\n+                }\n+                // if patient is duplicated, abort as well in this case:\n+                if (!patientIds.add(patientId)) {\n+                    throw new RuntimeException(\"Error. Patient \" + patientId + \" found to be duplicated in your file.\");\n+                }\n+            }\n+\n+            if (patient != null) {\n+                // in all cases (SAMPLE, PATIENT, or STUDY) this can be expected, so\n+                // just fetch it:\n+                internalPatientId = patient.getInternalId();\n+            } else {\n+                // in case of PATIENT data import and patient == null :\n+                if (getResourceType() == ResourceType.PATIENT) {\n+                    // not finding the patient it unexpected (as SAMPLE data import should always\n+                    // precede it), but\n+                    // can happen when this patient does not have any samples for example. In any\n+                    // case, warn about it:\n+                    ProgressMonitor.logWarning(\"Patient \" + patientId\n+                            + \" being added for the first time. Apparently this patient was not in the samples file, or the samples file is not yet loaded (should be loaded before this one)\");\n+                }\n+\n+                patient = new Patient(cancerStudy, patientId);\n+                internalPatientId = DaoPatient.addPatient(patient);\n+            }\n+        }\n+        return internalPatientId;\n+    }\n+\n+    private int addSampleToDatabase(String sampleId, String[] fields, Map<String, Integer> headerIndexMap)\n+            throws Exception {\n+        int sampleTypeIndex = findSampleTypeColumn(headerIndexMap);", "originalCommit": "4e724ff759a02f25a33335b5d8aab57376718488", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjcxMDAzMw==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r396710033", "bodyText": "Yes, IMO, if someone introduces a new sample in the resource data file, SAMPLE_TYPE can be an optional column in the data file.", "author": "dippindots", "createdAt": "2020-03-23T19:40:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYxMzM2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYxNTgzNQ==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r396615835", "bodyText": "addPatientToDatabase already return patient internal id. do we still need this query?", "author": "kalletlak", "createdAt": "2020-03-23T17:12:21Z", "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "diffHunk": "@@ -0,0 +1,555 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+import java.util.regex.*;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections.map.MultiKeyMap;\n+import org.cbioportal.model.ResourceType;\n+\n+public class ImportResourceData extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String METADATA_PREFIX = \"#\";\n+    public static final String SAMPLE_ID_COLUMN_NAME = \"SAMPLE_ID\";\n+    public static final String PATIENT_ID_COLUMN_NAME = \"PATIENT_ID\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String URL_COLUMN_NAME = \"URL\";\n+    public static final String SAMPLE_TYPE_COLUMN_NAME = \"SAMPLE_TYPE\";\n+    private int numSampleSpecificResourcesAdded = 0;\n+    private int numPatientSpecificResourcesAdded = 0;\n+    private int numStudySpecificResourcesAdded = 0;\n+    private int numEmptyResourcesSkipped = 0;\n+    private int numSamplesProcessed = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private ResourceType resourceType;\n+    private boolean relaxed;\n+    private Set<String> patientIds = new HashSet<String>();\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, String resourceType, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.resourceType = ResourceType.valueOf(resourceType);\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+        List<ResourceDefinition> resources = DaoResourceDefinition.getDatumByStudy(cancerStudy.getInternalId());\n+        String currentLine = buff.readLine();\n+        String[] headerNames = currentLine.split(\"\\t\");\n+        Map<String, Integer> headerIndexMap = makeHeaderIndexMap(headerNames);\n+        \n+        int patientIdIndex = findPatientIdColumn(headerIndexMap);\n+        int sampleIdIndex = findSampleIdColumn(headerIndexMap);\n+        int resourceIdIndex = findResourceIdColumn(headerIndexMap);\n+        int urlIndex = findURLColumn(headerIndexMap);\n+\n+        // validate required columns:\n+        if (resourceIdIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + RESOURCE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (urlIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + URL_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if ((resourceType.equals(ResourceType.SAMPLE) || resourceType.equals(ResourceType.PATIENT)) && patientIdIndex < 0) {\n+            // PATIENT_ID is required in both patient and sample file types:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + PATIENT_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (resourceType.equals(ResourceType.SAMPLE) && sampleIdIndex < 0) {\n+            // SAMPLE_ID is required in SAMPLE file type:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + SAMPLE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        importData(buff, resources, headerIndexMap);\n+        buff.close();\n+\n+        if (MySQLbulkLoader.isBulkLoad()) {\n+            MySQLbulkLoader.flushAll();\n+            MySQLbulkLoader.relaxedModeOff();\n+        }\n+    }\n+\n+    private void importData(BufferedReader buff, List<ResourceDefinition> resources, Map<String, Integer> headerIndexMap) throws Exception {\n+        String line;\n+        MultiKeyMap resourceMap = new MultiKeyMap();\n+        // create resource_id set\n+        Set<String> patientResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceType.PATIENT))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+        Set<String> sampleResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceType.SAMPLE))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+        Set<String> studyResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceType.STUDY))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+\n+        while ((line = buff.readLine()) != null) {\n+            if (skipLine(line.trim())) {\n+                continue;\n+            }\n+\n+            String[] fieldValues = getFieldValues(line, headerIndexMap);\n+            addDatum(fieldValues, resources, resourceMap, headerIndexMap, patientResourceIdSet, sampleResourceIdSet, studyResourceIdSet);\n+        }\n+    }\n+\n+    private boolean skipLine(String line) {\n+        return (line.isEmpty() || line.substring(0, 1).equals(METADATA_PREFIX));\n+    }\n+\n+    /**\n+     * Takes in the given line and returns the list of field values by splitting the\n+     * line on DELIMITER.\n+     * \n+     * @param line\n+     * @param headerIndexMap\n+     * @return the list of values, one for each column. Value will be \"\" for empty\n+     *         columns.\n+     */\n+    private String[] getFieldValues(String line, Map<String, Integer> headerIndexMap) {\n+        // split on delimiter:\n+        String[] fieldValues = line.split(DELIMITER, -1);\n+\n+        // validate: if number of fields is incorrect, give exception\n+        if (fieldValues.length != headerIndexMap.size()) {\n+            throw new IllegalArgumentException(\"Number of columns in line is not as expected. Expected: \"\n+                    + headerIndexMap.size() + \" columns, found: \" + fieldValues.length + \", for line: \" + line);\n+        }\n+\n+        // now iterate over lines and trim each value:\n+        for (int i = 0; i < fieldValues.length; i++) {\n+            fieldValues[i] = fieldValues[i].trim();\n+        }\n+        return fieldValues;\n+    }\n+\n+    private boolean addDatum(String[] fields, List<ResourceDefinition> resources, MultiKeyMap resourceMap, Map<String, Integer> headerIndexMap, Set<String> patientResourceIdSet, Set<String> sampleResourceIdSet, Set<String> studyResourceIdSet)\n+            throws Exception {\n+        int sampleIdIndex = findSampleIdColumn(headerIndexMap);\n+        String stableSampleId = (sampleIdIndex >= 0) ? fields[sampleIdIndex] : \"\";\n+        stableSampleId = StableIdUtil.getSampleId(stableSampleId);\n+        int patientIdIndex = findPatientIdColumn(headerIndexMap);\n+        String stablePatientId = (patientIdIndex >= 0) ? fields[patientIdIndex] : \"\";\n+        stablePatientId = StableIdUtil.getPatientId(stablePatientId);\n+        int resourceIdIndex = findResourceIdColumn(headerIndexMap);\n+        int urlIndex = findURLColumn(headerIndexMap);\n+        int internalSampleId = -1;\n+        int internalPatientId = -1;\n+\n+        // validate sample and patient for sample or patient attibutes\n+        if (resourceType.equals(ResourceType.SAMPLE) || resourceType.equals(ResourceType.PATIENT)) {\n+            // check if sample is not already added:\n+            Sample sample = DaoSample.getSampleByCancerStudyAndSampleId(cancerStudy.getInternalId(), stableSampleId, false);\n+            if (sample != null) {\n+                // get internal sample id if sample exists\n+                internalSampleId = sample.getInternalId();\n+            } else {\n+                Patient patient = DaoPatient.getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(),\n+                        stablePatientId);\n+                if (patient != null) {\n+                    // patient exists, get internal id:\n+                    internalPatientId = patient.getInternalId();\n+                } else {\n+                    // add patient:\n+                    internalPatientId = (patientIdIndex >= 0) ? addPatientToDatabase(fields[patientIdIndex]) : -1;\n+                }\n+                // sample is new, so attempt to add to DB\n+                internalSampleId = (stableSampleId.length() > 0) ? addSampleToDatabase(stableSampleId, fields, headerIndexMap)\n+                        : -1;\n+            }\n+\n+            // validate and count:\n+            if (internalSampleId != -1) {\n+                // some minimal validation/fail safe for now: only continue if patientId is same\n+                // as patient id in\n+                // existing sample (can occur in case of this.isSupplementalData or in case of\n+                // parsing bug in addSampleToDatabase):\n+                internalPatientId = DaoPatient\n+                        .getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(), stablePatientId).getInternalId();\n+                if (internalPatientId != DaoSample.getSampleById(internalSampleId).getInternalPatientId()) {\n+                    throw new RuntimeException(\"Error: Sample \" + stableSampleId\n+                            + \" was previously linked to another patient, and not to \" + stablePatientId);\n+                }\n+                numSamplesProcessed++;\n+            }\n+        }\n+\n+        // if the resource id or url matches one of the missing values, skip this resource:\n+        if ((resourceIdIndex != -1 && MissingValues.has(fields[resourceIdIndex])) || (urlIndex != -1 && MissingValues.has(fields[urlIndex]))) {\n+            numEmptyResourcesSkipped++;\n+        } else {\n+            // if patient_id column exists and resource type is patient\n+            if (getResourceType() == ResourceType.PATIENT && internalPatientId != -1) {\n+                validateAddDatum(internalPatientId, stablePatientId, fields[resourceIdIndex], fields[urlIndex], \n+                        ResourceType.PATIENT, patientResourceIdSet, resourceMap);\n+            } \n+            // if sample_id column exists and resource type is sample\n+            else if (getResourceType() == ResourceType.SAMPLE && internalSampleId != -1) {\n+                validateAddDatum(internalSampleId, stableSampleId, fields[resourceIdIndex], fields[urlIndex], \n+                        ResourceType.SAMPLE, sampleResourceIdSet, resourceMap);\n+            }\n+            // if resource type is study\n+            else if (getResourceType() == ResourceType.STUDY) {\n+                validateAddDatum(cancerStudy.getInternalId(), cancerStudy.getCancerStudyStableId(), fields[resourceIdIndex], fields[urlIndex], \n+                        ResourceType.STUDY, studyResourceIdSet, resourceMap);\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private Map<String, Integer> makeHeaderIndexMap(String[] headerNames) {\n+        Map<String, Integer> headerIndexMap = new HashMap<String, Integer>();\n+        for (int i= 0; i < headerNames.length; i++) {\n+            headerIndexMap.put(headerNames[i], i);\n+        }\n+        return headerIndexMap;\n+    }\n+\n+    private int findPatientIdColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(PATIENT_ID_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findSampleIdColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(SAMPLE_ID_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findResourceIdColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(RESOURCE_ID_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findURLColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(URL_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findSampleTypeColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(SAMPLE_TYPE_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findColumnIndexInHeaders(String columnHeader, Map<String, Integer> headerIndexMap) {\n+        return headerIndexMap.getOrDefault(columnHeader, -1);\n+    }\n+\n+    private int addPatientToDatabase(String patientId) throws Exception {\n+        int internalPatientId = -1;\n+        if (validPatientId(patientId)) {\n+            Patient patient = DaoPatient.getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(), patientId);\n+            // other validations:\n+            // in case of PATIENT data import, there are some special checks:\n+            if (getResourceType() == ResourceType.PATIENT) {\n+                // if resource data is already there, then something has gone wrong (e.g.\n+                // patient is duplicated in file), abort:\n+                if (patient != null\n+                        && DaoResourceData.getDataByPatientId(cancerStudy.getInternalId(), patientId).size() > 0) {\n+                    throw new RuntimeException(\n+                            \"Something has gone wrong. Patient \" + patientId + \" already has resource data loaded.\");\n+                }\n+                // if patient is duplicated, abort as well in this case:\n+                if (!patientIds.add(patientId)) {\n+                    throw new RuntimeException(\"Error. Patient \" + patientId + \" found to be duplicated in your file.\");\n+                }\n+            }\n+\n+            if (patient != null) {\n+                // in all cases (SAMPLE, PATIENT, or STUDY) this can be expected, so\n+                // just fetch it:\n+                internalPatientId = patient.getInternalId();\n+            } else {\n+                // in case of PATIENT data import and patient == null :\n+                if (getResourceType() == ResourceType.PATIENT) {\n+                    // not finding the patient it unexpected (as SAMPLE data import should always\n+                    // precede it), but\n+                    // can happen when this patient does not have any samples for example. In any\n+                    // case, warn about it:\n+                    ProgressMonitor.logWarning(\"Patient \" + patientId\n+                            + \" being added for the first time. Apparently this patient was not in the samples file, or the samples file is not yet loaded (should be loaded before this one)\");\n+                }\n+\n+                patient = new Patient(cancerStudy, patientId);\n+                internalPatientId = DaoPatient.addPatient(patient);\n+            }\n+        }\n+        return internalPatientId;\n+    }\n+\n+    private int addSampleToDatabase(String sampleId, String[] fields, Map<String, Integer> headerIndexMap)\n+            throws Exception {\n+        int sampleTypeIndex = findSampleTypeColumn(headerIndexMap);\n+        String sampleTypeStr = (sampleTypeIndex != -1) ? fields[sampleTypeIndex] : null;\n+        if (sampleTypeStr != null) {\n+            // want to match Sample.Type enum names\n+            sampleTypeStr = sampleTypeStr.trim().toUpperCase().replaceAll(\" \", \"_\");\n+        }\n+        Sample.Type sampleType = Sample.Type.has(sampleTypeStr) ? Sample.Type.valueOf(sampleTypeStr) : null;\n+\n+        int internalSampleId = -1;\n+        if (validSampleId(sampleId) && !StableIdUtil.isNormal(sampleId)) {\n+            // want to try and capture normal sample types based on value for SAMPLE_TYPE\n+            // if present in resource data\n+            if (sampleType != null && sampleType.isNormal()) {\n+                return internalSampleId;\n+            }\n+            String stablePatientId = getStablePatientId(sampleId, fields, headerIndexMap);\n+            if (validPatientId(stablePatientId)) {\n+                Patient patient = DaoPatient.getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(),\n+                        stablePatientId);\n+                if (patient == null) {\n+                    addPatientToDatabase(stablePatientId);\n+                    patient = DaoPatient.getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(),", "originalCommit": "4e724ff759a02f25a33335b5d8aab57376718488", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYyMDg3MA==", "url": "https://github.com/cBioPortal/cbioportal/pull/7270#discussion_r396620870", "bodyText": "I think addSampleToDatabase should be executed only when patient is added. I prefer passing patient object in the method parameter. this would reduce the number of queries made to database to fetch patient(getPatientByCancerStudyAndPatientId)", "author": "kalletlak", "createdAt": "2020-03-23T17:19:28Z", "path": "core/src/main/java/org/mskcc/cbio/portal/scripts/ImportResourceData.java", "diffHunk": "@@ -0,0 +1,555 @@\n+package org.mskcc.cbio.portal.scripts;\n+\n+import org.mskcc.cbio.portal.dao.*;\n+import org.mskcc.cbio.portal.model.*;\n+import org.mskcc.cbio.portal.util.*;\n+\n+import java.io.*;\n+import joptsimple.*;\n+import java.util.*;\n+import java.util.regex.*;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections.map.MultiKeyMap;\n+import org.cbioportal.model.ResourceType;\n+\n+public class ImportResourceData extends ConsoleRunnable {\n+\n+    public static final String DELIMITER = \"\\t\";\n+    public static final String METADATA_PREFIX = \"#\";\n+    public static final String SAMPLE_ID_COLUMN_NAME = \"SAMPLE_ID\";\n+    public static final String PATIENT_ID_COLUMN_NAME = \"PATIENT_ID\";\n+    public static final String RESOURCE_ID_COLUMN_NAME = \"RESOURCE_ID\";\n+    public static final String URL_COLUMN_NAME = \"URL\";\n+    public static final String SAMPLE_TYPE_COLUMN_NAME = \"SAMPLE_TYPE\";\n+    private int numSampleSpecificResourcesAdded = 0;\n+    private int numPatientSpecificResourcesAdded = 0;\n+    private int numStudySpecificResourcesAdded = 0;\n+    private int numEmptyResourcesSkipped = 0;\n+    private int numSamplesProcessed = 0;\n+\n+    private static Properties properties;\n+\n+    private File resourceDataFile;\n+    private CancerStudy cancerStudy;\n+    private ResourceType resourceType;\n+    private boolean relaxed;\n+    private Set<String> patientIds = new HashSet<String>();\n+\n+    public void setFile(CancerStudy cancerStudy, File resourceDataFile, String resourceType, boolean relaxed) {\n+        this.cancerStudy = cancerStudy;\n+        this.resourceDataFile = resourceDataFile;\n+        this.resourceType = ResourceType.valueOf(resourceType);\n+        this.relaxed = relaxed;\n+    }\n+\n+    public void importData() throws Exception {\n+        // if bulkLoading is ever turned off,\n+        // code has to be added to check whether\n+        // a resource data update should be\n+        // perform instead of an insert\n+        MySQLbulkLoader.bulkLoadOn();\n+\n+        if (relaxed) {\n+            MySQLbulkLoader.relaxedModeOn();\n+        }\n+\n+        FileReader reader = new FileReader(resourceDataFile);\n+        BufferedReader buff = new BufferedReader(reader);\n+        List<ResourceDefinition> resources = DaoResourceDefinition.getDatumByStudy(cancerStudy.getInternalId());\n+        String currentLine = buff.readLine();\n+        String[] headerNames = currentLine.split(\"\\t\");\n+        Map<String, Integer> headerIndexMap = makeHeaderIndexMap(headerNames);\n+        \n+        int patientIdIndex = findPatientIdColumn(headerIndexMap);\n+        int sampleIdIndex = findSampleIdColumn(headerIndexMap);\n+        int resourceIdIndex = findResourceIdColumn(headerIndexMap);\n+        int urlIndex = findURLColumn(headerIndexMap);\n+\n+        // validate required columns:\n+        if (resourceIdIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + RESOURCE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (urlIndex < 0) {\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + URL_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if ((resourceType.equals(ResourceType.SAMPLE) || resourceType.equals(ResourceType.PATIENT)) && patientIdIndex < 0) {\n+            // PATIENT_ID is required in both patient and sample file types:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + PATIENT_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        if (resourceType.equals(ResourceType.SAMPLE) && sampleIdIndex < 0) {\n+            // SAMPLE_ID is required in SAMPLE file type:\n+            throw new RuntimeException(\"Aborting owing to failure to find \" + SAMPLE_ID_COLUMN_NAME\n+                    + \" in file. Please check your file format and try again.\");\n+        }\n+        importData(buff, resources, headerIndexMap);\n+        buff.close();\n+\n+        if (MySQLbulkLoader.isBulkLoad()) {\n+            MySQLbulkLoader.flushAll();\n+            MySQLbulkLoader.relaxedModeOff();\n+        }\n+    }\n+\n+    private void importData(BufferedReader buff, List<ResourceDefinition> resources, Map<String, Integer> headerIndexMap) throws Exception {\n+        String line;\n+        MultiKeyMap resourceMap = new MultiKeyMap();\n+        // create resource_id set\n+        Set<String> patientResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceType.PATIENT))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+        Set<String> sampleResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceType.SAMPLE))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+        Set<String> studyResourceIdSet = resources\n+                .stream()\n+                .filter(resource -> resource.getResourceType().equals(ResourceType.STUDY))\n+                .map(resource -> resource.getResourceId())\n+                .collect(Collectors.toSet());\n+\n+        while ((line = buff.readLine()) != null) {\n+            if (skipLine(line.trim())) {\n+                continue;\n+            }\n+\n+            String[] fieldValues = getFieldValues(line, headerIndexMap);\n+            addDatum(fieldValues, resources, resourceMap, headerIndexMap, patientResourceIdSet, sampleResourceIdSet, studyResourceIdSet);\n+        }\n+    }\n+\n+    private boolean skipLine(String line) {\n+        return (line.isEmpty() || line.substring(0, 1).equals(METADATA_PREFIX));\n+    }\n+\n+    /**\n+     * Takes in the given line and returns the list of field values by splitting the\n+     * line on DELIMITER.\n+     * \n+     * @param line\n+     * @param headerIndexMap\n+     * @return the list of values, one for each column. Value will be \"\" for empty\n+     *         columns.\n+     */\n+    private String[] getFieldValues(String line, Map<String, Integer> headerIndexMap) {\n+        // split on delimiter:\n+        String[] fieldValues = line.split(DELIMITER, -1);\n+\n+        // validate: if number of fields is incorrect, give exception\n+        if (fieldValues.length != headerIndexMap.size()) {\n+            throw new IllegalArgumentException(\"Number of columns in line is not as expected. Expected: \"\n+                    + headerIndexMap.size() + \" columns, found: \" + fieldValues.length + \", for line: \" + line);\n+        }\n+\n+        // now iterate over lines and trim each value:\n+        for (int i = 0; i < fieldValues.length; i++) {\n+            fieldValues[i] = fieldValues[i].trim();\n+        }\n+        return fieldValues;\n+    }\n+\n+    private boolean addDatum(String[] fields, List<ResourceDefinition> resources, MultiKeyMap resourceMap, Map<String, Integer> headerIndexMap, Set<String> patientResourceIdSet, Set<String> sampleResourceIdSet, Set<String> studyResourceIdSet)\n+            throws Exception {\n+        int sampleIdIndex = findSampleIdColumn(headerIndexMap);\n+        String stableSampleId = (sampleIdIndex >= 0) ? fields[sampleIdIndex] : \"\";\n+        stableSampleId = StableIdUtil.getSampleId(stableSampleId);\n+        int patientIdIndex = findPatientIdColumn(headerIndexMap);\n+        String stablePatientId = (patientIdIndex >= 0) ? fields[patientIdIndex] : \"\";\n+        stablePatientId = StableIdUtil.getPatientId(stablePatientId);\n+        int resourceIdIndex = findResourceIdColumn(headerIndexMap);\n+        int urlIndex = findURLColumn(headerIndexMap);\n+        int internalSampleId = -1;\n+        int internalPatientId = -1;\n+\n+        // validate sample and patient for sample or patient attibutes\n+        if (resourceType.equals(ResourceType.SAMPLE) || resourceType.equals(ResourceType.PATIENT)) {\n+            // check if sample is not already added:\n+            Sample sample = DaoSample.getSampleByCancerStudyAndSampleId(cancerStudy.getInternalId(), stableSampleId, false);\n+            if (sample != null) {\n+                // get internal sample id if sample exists\n+                internalSampleId = sample.getInternalId();\n+            } else {\n+                Patient patient = DaoPatient.getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(),\n+                        stablePatientId);\n+                if (patient != null) {\n+                    // patient exists, get internal id:\n+                    internalPatientId = patient.getInternalId();\n+                } else {\n+                    // add patient:\n+                    internalPatientId = (patientIdIndex >= 0) ? addPatientToDatabase(fields[patientIdIndex]) : -1;\n+                }\n+                // sample is new, so attempt to add to DB\n+                internalSampleId = (stableSampleId.length() > 0) ? addSampleToDatabase(stableSampleId, fields, headerIndexMap)\n+                        : -1;\n+            }\n+\n+            // validate and count:\n+            if (internalSampleId != -1) {\n+                // some minimal validation/fail safe for now: only continue if patientId is same\n+                // as patient id in\n+                // existing sample (can occur in case of this.isSupplementalData or in case of\n+                // parsing bug in addSampleToDatabase):\n+                internalPatientId = DaoPatient\n+                        .getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(), stablePatientId).getInternalId();\n+                if (internalPatientId != DaoSample.getSampleById(internalSampleId).getInternalPatientId()) {\n+                    throw new RuntimeException(\"Error: Sample \" + stableSampleId\n+                            + \" was previously linked to another patient, and not to \" + stablePatientId);\n+                }\n+                numSamplesProcessed++;\n+            }\n+        }\n+\n+        // if the resource id or url matches one of the missing values, skip this resource:\n+        if ((resourceIdIndex != -1 && MissingValues.has(fields[resourceIdIndex])) || (urlIndex != -1 && MissingValues.has(fields[urlIndex]))) {\n+            numEmptyResourcesSkipped++;\n+        } else {\n+            // if patient_id column exists and resource type is patient\n+            if (getResourceType() == ResourceType.PATIENT && internalPatientId != -1) {\n+                validateAddDatum(internalPatientId, stablePatientId, fields[resourceIdIndex], fields[urlIndex], \n+                        ResourceType.PATIENT, patientResourceIdSet, resourceMap);\n+            } \n+            // if sample_id column exists and resource type is sample\n+            else if (getResourceType() == ResourceType.SAMPLE && internalSampleId != -1) {\n+                validateAddDatum(internalSampleId, stableSampleId, fields[resourceIdIndex], fields[urlIndex], \n+                        ResourceType.SAMPLE, sampleResourceIdSet, resourceMap);\n+            }\n+            // if resource type is study\n+            else if (getResourceType() == ResourceType.STUDY) {\n+                validateAddDatum(cancerStudy.getInternalId(), cancerStudy.getCancerStudyStableId(), fields[resourceIdIndex], fields[urlIndex], \n+                        ResourceType.STUDY, studyResourceIdSet, resourceMap);\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private Map<String, Integer> makeHeaderIndexMap(String[] headerNames) {\n+        Map<String, Integer> headerIndexMap = new HashMap<String, Integer>();\n+        for (int i= 0; i < headerNames.length; i++) {\n+            headerIndexMap.put(headerNames[i], i);\n+        }\n+        return headerIndexMap;\n+    }\n+\n+    private int findPatientIdColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(PATIENT_ID_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findSampleIdColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(SAMPLE_ID_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findResourceIdColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(RESOURCE_ID_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findURLColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(URL_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findSampleTypeColumn(Map<String, Integer> headerIndexMap) {\n+        return findColumnIndexInHeaders(SAMPLE_TYPE_COLUMN_NAME, headerIndexMap);\n+    }\n+\n+    private int findColumnIndexInHeaders(String columnHeader, Map<String, Integer> headerIndexMap) {\n+        return headerIndexMap.getOrDefault(columnHeader, -1);\n+    }\n+\n+    private int addPatientToDatabase(String patientId) throws Exception {\n+        int internalPatientId = -1;\n+        if (validPatientId(patientId)) {\n+            Patient patient = DaoPatient.getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(), patientId);\n+            // other validations:\n+            // in case of PATIENT data import, there are some special checks:\n+            if (getResourceType() == ResourceType.PATIENT) {\n+                // if resource data is already there, then something has gone wrong (e.g.\n+                // patient is duplicated in file), abort:\n+                if (patient != null\n+                        && DaoResourceData.getDataByPatientId(cancerStudy.getInternalId(), patientId).size() > 0) {\n+                    throw new RuntimeException(\n+                            \"Something has gone wrong. Patient \" + patientId + \" already has resource data loaded.\");\n+                }\n+                // if patient is duplicated, abort as well in this case:\n+                if (!patientIds.add(patientId)) {\n+                    throw new RuntimeException(\"Error. Patient \" + patientId + \" found to be duplicated in your file.\");\n+                }\n+            }\n+\n+            if (patient != null) {\n+                // in all cases (SAMPLE, PATIENT, or STUDY) this can be expected, so\n+                // just fetch it:\n+                internalPatientId = patient.getInternalId();\n+            } else {\n+                // in case of PATIENT data import and patient == null :\n+                if (getResourceType() == ResourceType.PATIENT) {\n+                    // not finding the patient it unexpected (as SAMPLE data import should always\n+                    // precede it), but\n+                    // can happen when this patient does not have any samples for example. In any\n+                    // case, warn about it:\n+                    ProgressMonitor.logWarning(\"Patient \" + patientId\n+                            + \" being added for the first time. Apparently this patient was not in the samples file, or the samples file is not yet loaded (should be loaded before this one)\");\n+                }\n+\n+                patient = new Patient(cancerStudy, patientId);\n+                internalPatientId = DaoPatient.addPatient(patient);\n+            }\n+        }\n+        return internalPatientId;\n+    }\n+\n+    private int addSampleToDatabase(String sampleId, String[] fields, Map<String, Integer> headerIndexMap)\n+            throws Exception {\n+        int sampleTypeIndex = findSampleTypeColumn(headerIndexMap);\n+        String sampleTypeStr = (sampleTypeIndex != -1) ? fields[sampleTypeIndex] : null;\n+        if (sampleTypeStr != null) {\n+            // want to match Sample.Type enum names\n+            sampleTypeStr = sampleTypeStr.trim().toUpperCase().replaceAll(\" \", \"_\");\n+        }\n+        Sample.Type sampleType = Sample.Type.has(sampleTypeStr) ? Sample.Type.valueOf(sampleTypeStr) : null;\n+\n+        int internalSampleId = -1;\n+        if (validSampleId(sampleId) && !StableIdUtil.isNormal(sampleId)) {\n+            // want to try and capture normal sample types based on value for SAMPLE_TYPE\n+            // if present in resource data\n+            if (sampleType != null && sampleType.isNormal()) {\n+                return internalSampleId;\n+            }\n+            String stablePatientId = getStablePatientId(sampleId, fields, headerIndexMap);\n+            if (validPatientId(stablePatientId)) {\n+                Patient patient = DaoPatient.getPatientByCancerStudyAndPatientId(cancerStudy.getInternalId(),\n+                        stablePatientId);\n+                if (patient == null) {", "originalCommit": "4e724ff759a02f25a33335b5d8aab57376718488", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "24204a458a2a755d54b9f91841eccd6c0d22a10b", "url": "https://github.com/cBioPortal/cbioportal/commit/24204a458a2a755d54b9f91841eccd6c0d22a10b", "message": "sample and patient comments", "committedDate": "2020-03-24T16:32:48Z", "type": "forcePushed"}, {"oid": "a6352b767bc6da1db3b1a87ee157b69af905a6ac", "url": "https://github.com/cBioPortal/cbioportal/commit/a6352b767bc6da1db3b1a87ee157b69af905a6ac", "message": "sample and patient comments", "committedDate": "2020-03-24T16:38:06Z", "type": "forcePushed"}, {"oid": "389de284a1cd0153b92a90ff82c92c24008482e8", "url": "https://github.com/cBioPortal/cbioportal/commit/389de284a1cd0153b92a90ff82c92c24008482e8", "message": "resource importer implementation", "committedDate": "2020-03-24T16:39:51Z", "type": "commit"}, {"oid": "389de284a1cd0153b92a90ff82c92c24008482e8", "url": "https://github.com/cBioPortal/cbioportal/commit/389de284a1cd0153b92a90ff82c92c24008482e8", "message": "resource importer implementation", "committedDate": "2020-03-24T16:39:51Z", "type": "forcePushed"}]}