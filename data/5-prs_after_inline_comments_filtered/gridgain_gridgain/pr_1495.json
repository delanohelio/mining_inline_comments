{"pr_number": 1495, "pr_title": "GG-18652 Statistics collection", "pr_createdAt": "2020-10-13T10:22:03Z", "pr_url": "https://github.com/gridgain/gridgain/pull/1495", "timeline": [{"oid": "15b0aea9fcf0bab67d1f40781cf134585d81740e", "url": "https://github.com/gridgain/gridgain/commit/15b0aea9fcf0bab67d1f40781cf134585d81740e", "message": "GG-18638 Add HLL structure & tests", "committedDate": "2020-10-13T08:41:17Z", "type": "commit"}, {"oid": "5696f5d6f1a3c3031d47704687039a0145d916bf", "url": "https://github.com/gridgain/gridgain/commit/5696f5d6f1a3c3031d47704687039a0145d916bf", "message": "GG-18638 start", "committedDate": "2020-10-13T08:41:23Z", "type": "commit"}, {"oid": "50ef3e317b91e01b91f4283f77e1dbbd6d928cfd", "url": "https://github.com/gridgain/gridgain/commit/50ef3e317b91e01b91f4283f77e1dbbd6d928cfd", "message": "GG-18638 Implement Murmur Hasher for byte arrays", "committedDate": "2020-10-13T08:41:28Z", "type": "commit"}, {"oid": "ba5ad35f2720d549da44aadade714ec39c1335f3", "url": "https://github.com/gridgain/gridgain/commit/ba5ad35f2720d549da44aadade714ec39c1335f3", "message": "GG-18638 fix HLL to work with traditional closed collections", "committedDate": "2020-10-13T08:41:32Z", "type": "commit"}, {"oid": "3911fe459f5df5d780c3bf48f47a5f359b26140b", "url": "https://github.com/gridgain/gridgain/commit/3911fe459f5df5d780c3bf48f47a5f359b26140b", "message": "GG-18638 implementation of statistics collection", "committedDate": "2020-10-13T08:41:40Z", "type": "commit"}, {"oid": "135531763e6d09d5de68e236cd3af27390272392", "url": "https://github.com/gridgain/gridgain/commit/135531763e6d09d5de68e236cd3af27390272392", "message": "GG-18652 fix self tests", "committedDate": "2020-10-13T08:41:46Z", "type": "commit"}, {"oid": "e497f5753d93b043ab0fe67c0e9132e58077559c", "url": "https://github.com/gridgain/gridgain/commit/e497f5753d93b043ab0fe67c0e9132e58077559c", "message": "GG-18652 revert unnecessary changes", "committedDate": "2020-10-13T08:41:50Z", "type": "commit"}, {"oid": "4597416836387070b28e64985e114809280874b0", "url": "https://github.com/gridgain/gridgain/commit/4597416836387070b28e64985e114809280874b0", "message": "GG-18652: style fixes", "committedDate": "2020-10-13T08:41:54Z", "type": "commit"}, {"oid": "b143cf3bcc37e289727618feb670c27baa396395", "url": "https://github.com/gridgain/gridgain/commit/b143cf3bcc37e289727618feb670c27baa396395", "message": "GG-18652 additional libraries mentioned in licence", "committedDate": "2020-10-13T08:41:59Z", "type": "commit"}, {"oid": "8f71a9b6e47342b9aac244f642cdda744807e7c9", "url": "https://github.com/gridgain/gridgain/commit/8f71a9b6e47342b9aac244f642cdda744807e7c9", "message": "GG-18652: fix statistics usage on client", "committedDate": "2020-10-13T08:42:03Z", "type": "commit"}, {"oid": "7f85204c97652a5e4efaf3954816bacb382d92b9", "url": "https://github.com/gridgain/gridgain/commit/7f85204c97652a5e4efaf3954816bacb382d92b9", "message": "GG-18652 fix cost function", "committedDate": "2020-10-13T08:42:07Z", "type": "commit"}, {"oid": "341b34f98ca9955f08ca3d1cb9cd867c92087dd3", "url": "https://github.com/gridgain/gridgain/commit/341b34f98ca9955f08ca3d1cb9cd867c92087dd3", "message": "GG-18652: revert some of the cost function fixes", "committedDate": "2020-10-13T08:42:11Z", "type": "commit"}, {"oid": "3b4214c6e285a0b307f5b34666d8aa84739a39dd", "url": "https://github.com/gridgain/gridgain/commit/3b4214c6e285a0b307f5b34666d8aa84739a39dd", "message": "gg-18652: update cost function", "committedDate": "2020-10-13T10:01:27Z", "type": "commit"}, {"oid": "afad665e1ef5ec57005226e689a0b425cae63b34", "url": "https://github.com/gridgain/gridgain/commit/afad665e1ef5ec57005226e689a0b425cae63b34", "message": "GG-18652: fix partial statistics collection.", "committedDate": "2020-10-13T14:44:52Z", "type": "commit"}, {"oid": "b55b041892fa33267efda7b3be61a4aa22659015", "url": "https://github.com/gridgain/gridgain/commit/b55b041892fa33267efda7b3be61a4aa22659015", "message": "GG-18652: add StaticPartialCollectionTest to BinaryCacheQuery suite", "committedDate": "2020-10-14T07:11:02Z", "type": "commit"}, {"oid": "1e84ddd850887e2897bbcab904a086818d589fcf", "url": "https://github.com/gridgain/gridgain/commit/1e84ddd850887e2897bbcab904a086818d589fcf", "message": "GG-18652: improved tests readability", "committedDate": "2020-10-14T11:54:57Z", "type": "commit"}, {"oid": "0d7df9b54d06b32bae6069b1067da108e19a8f96", "url": "https://github.com/gridgain/gridgain/commit/0d7df9b54d06b32bae6069b1067da108e19a8f96", "message": "GG-18652: fix statistics collection test (to select with proper range values)", "committedDate": "2020-10-14T18:55:48Z", "type": "commit"}, {"oid": "83c3dca5f1d9084d244e8f1e2e9d0a3650e7e96a", "url": "https://github.com/gridgain/gridgain/commit/83c3dca5f1d9084d244e8f1e2e9d0a3650e7e96a", "message": "GG-18652: improve cost function", "committedDate": "2020-10-14T18:58:53Z", "type": "commit"}, {"oid": "d43e917e7347f310424d0773845532b2287d96c8", "url": "https://github.com/gridgain/gridgain/commit/d43e917e7347f310424d0773845532b2287d96c8", "message": "GG-18652: codestyle", "committedDate": "2020-10-14T19:55:10Z", "type": "commit"}, {"oid": "2160b9599db3903e090c31c7fb4d65257bbe01b6", "url": "https://github.com/gridgain/gridgain/commit/2160b9599db3903e090c31c7fb4d65257bbe01b6", "message": "gg-18652: license up", "committedDate": "2020-10-15T08:34:35Z", "type": "commit"}, {"oid": "5a788f21b6abcad6554f09babe1c9fe7488aae34", "url": "https://github.com/gridgain/gridgain/commit/5a788f21b6abcad6554f09babe1c9fe7488aae34", "message": "Merge remote-tracking branch 'gridgain-ce/master' into gg-18652_from_origin", "committedDate": "2020-10-15T08:45:00Z", "type": "commit"}, {"oid": "9287048b6b66d93f2f4332e16038c3f8be652d40", "url": "https://github.com/gridgain/gridgain/commit/9287048b6b66d93f2f4332e16038c3f8be652d40", "message": "gg-18652: fix NPE for HashJoinQueryTest", "committedDate": "2020-10-15T13:06:23Z", "type": "commit"}, {"oid": "ed494880989fa84ae17c9894ba72e630741227fb", "url": "https://github.com/gridgain/gridgain/commit/ed494880989fa84ae17c9894ba72e630741227fb", "message": "GG-18652: exclusion for rat, licenses for a few classes.", "committedDate": "2020-10-15T13:42:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE2NzY0Mg==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r506167642", "bodyText": "missed javadoc", "author": "korlov42", "createdAt": "2020-10-16T08:28:22Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/query/DummyQueryIndexing.java", "diffHunk": "@@ -338,4 +338,8 @@\n         String colNamePtrn) {\n         return null;\n     }\n+\n+    @Override public IgniteStatisticsManager statsManager() {", "originalCommit": "ed494880989fa84ae17c9894ba72e630741227fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE2ODEyNg==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r506168126", "bodyText": "let's update copyrights with current year", "author": "korlov42", "createdAt": "2020-10-16T08:28:53Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/query/stat/ObjectStatistics.java", "diffHunk": "@@ -0,0 +1,22 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.", "originalCommit": "ed494880989fa84ae17c9894ba72e630741227fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE3Mjc3Nw==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r506172777", "bodyText": "How it affects costs calculation? I concerned about how new cost function will be ported to AI. Is there a way to overcome this without modifying the code of H2?", "author": "korlov42", "createdAt": "2020-10-16T08:34:06Z", "path": "modules/h2/src/main/java/org/gridgain/internal/h2/table/Table.java", "diffHunk": "@@ -744,7 +744,7 @@ public PlanItem getBestPlanItem(Session session, int[] masks,\n             AllColumnsForPlan allColumnsSet, boolean isEquiJoined) {\n         PlanItem item = new PlanItem();\n         item.setIndex(getScanIndex(session));\n-        item.cost = item.getIndex().getCost(session, null, filters, filter, null, allColumnsSet);\n+        item.cost = item.getIndex().getCost(session, null, filters, filter, sortOrder, allColumnsSet);", "originalCommit": "ed494880989fa84ae17c9894ba72e630741227fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY1NTMzMQ==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r507655331", "bodyText": "I'll revert it to not change H2, but I believe that it should be work better with it.", "author": "Berkof", "createdAt": "2020-10-19T10:56:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE3Mjc3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY3Nzk5Mw==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r507677993", "bodyText": "Actually I didn't mean that it should be reverted =) My point was that we should know about all pitfalls in case this particular change will be omitted", "author": "korlov42", "createdAt": "2020-10-19T11:39:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE3Mjc3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE3MzI2NQ==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r506173265", "bodyText": "missed javadoc", "author": "korlov42", "createdAt": "2020-10-16T08:34:39Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/IgniteStatisticsRepositoryImpl.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query;\n+\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheUtils;\n+import org.apache.ignite.internal.processors.cache.query.QueryTable;\n+import org.apache.ignite.internal.processors.query.stat.ColumnStatistics;\n+import org.apache.ignite.internal.processors.query.stat.IgniteStatisticsManagerImpl;\n+import org.apache.ignite.internal.processors.query.stat.IgniteStatisticsRepository;\n+import org.apache.ignite.internal.processors.query.stat.ObjectPartitionStatistics;\n+import org.apache.ignite.internal.processors.query.stat.ObjectStatistics;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class IgniteStatisticsRepositoryImpl implements IgniteStatisticsRepository {", "originalCommit": "ed494880989fa84ae17c9894ba72e630741227fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE5OTg3Mw==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r506199873", "bodyText": "missed dot at the end", "author": "korlov42", "createdAt": "2020-10-16T09:07:57Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/ObjectStatistics.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * All statistics by some object (table or index)", "originalCommit": "ed494880989fa84ae17c9894ba72e630741227fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIwMDY4OQ==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r506200689", "bodyText": "javadoc is missed", "author": "korlov42", "createdAt": "2020-10-16T09:08:38Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/ObjectStatistics.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * All statistics by some object (table or index)\n+ */\n+public class ObjectStatistics implements Cloneable {\n+    /** Total number of rows in object. */\n+    private final long rowsCnt;\n+\n+    /** Map columnKey to its statistic. */\n+    private final Map<String, ColumnStatistics> colNameToStat;\n+\n+    public ObjectStatistics(long rowsCnt, Map<String, ColumnStatistics> colNameToStat) {", "originalCommit": "ed494880989fa84ae17c9894ba72e630741227fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIwNjgwNQ==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r506206805", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param fullStat if {@code True} - replace whole statistics, try to merge with existing - otherwise.\n          \n          \n            \n                 * @param fullStat if {@code true} - replace whole statistics, try to merge with existing - otherwise.", "author": "korlov42", "createdAt": "2020-10-16T09:14:37Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/IgniteStatisticsRepository.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import org.apache.ignite.internal.processors.cache.query.QueryTable;\n+\n+import java.util.Collection;\n+\n+/**\n+ * Repository to store all necessary statistics. Can request absent ones from cluster and store to\n+ * {@link SqlStatisticsStoreImpl}.\n+ */\n+public interface IgniteStatisticsRepository {\n+\n+    /**\n+     * Replace all table statistics with specified ones.\n+     *\n+     * @param tbl table.\n+     * @param statistics collection of tables partition statistics.\n+     * @param fullStat if {@code True} - replace whole statistics, try to merge with existing - otherwise.", "originalCommit": "ed494880989fa84ae17c9894ba72e630741227fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIyMzQwNQ==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r506223405", "bodyText": "\u00a0there are a lot of problems with styles. Please read it: https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines", "author": "korlov42", "createdAt": "2020-10-16T09:36:46Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/Hasher.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+\n+/**\n+ * Implement Murmur8_128 hash function for byte arrays.\n+ */\n+public class Hasher {", "originalCommit": "ed494880989fa84ae17c9894ba72e630741227fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIyNjQyNQ==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r506226425", "bodyText": "redundant brackets", "author": "korlov42", "createdAt": "2020-10-16T09:39:48Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/ColumnStatisticsCollector.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import java.math.BigInteger;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Comparator;\n+import java.util.List;\n+\n+import org.apache.ignite.internal.processors.query.stat.hll.HLL;\n+import org.gridgain.internal.h2.table.Column;\n+import org.gridgain.internal.h2.value.Value;\n+\n+/**\n+ * Collector to compute statistic by single column.\n+ */\n+public class ColumnStatisticsCollector {\n+\n+    /** */\n+    private final Column col;\n+\n+    /** Hyper Log Log structure */\n+    private final HLL hll = new HLL(13/*log2m*/, 5/*registerWidth*/);\n+\n+    /** Minimum value. */\n+    private Value min = null;\n+\n+    /** Maximum value. */\n+    private Value max = null;\n+\n+    /** Total vals in column. */\n+    private long total = 0;\n+\n+    /** Total size of all non nulls values (in bytes).*/\n+    private long size = 0;\n+\n+    /** Temporary byte buffer just to avoid unnecessary object creation. */\n+    private ByteBuffer bb;\n+\n+    /** Column value comparator. */\n+    private final Comparator<Value> comp;\n+\n+    /** Null values counter. */\n+    private long nullsCnt;\n+\n+    /** Hasher. */\n+    private final Hasher hash = new Hasher();\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param col column to collect statistics by.\n+     * @param comp column values comparator.\n+     */\n+    public ColumnStatisticsCollector(Column col, Comparator<Value> comp) {\n+        this.col = col;\n+        this.comp = comp;\n+    }\n+\n+    /**\n+     * Try to fix unexpected behaviour of base Value class.\n+     *\n+     * @param value value to convert\n+     * @return byte array\n+     */\n+    private byte[] getBytes(Value value) {\n+        switch (value.getValueType()) {\n+            case Value.STRING:\n+                String strValue = value.getString();\n+                return strValue.getBytes(StandardCharsets.UTF_8);\n+            case Value.BOOLEAN:\n+                return value.getBoolean() ? new byte[]{1} : new byte[]{0} ;\n+            case Value.DECIMAL:\n+            case Value.DOUBLE:\n+            case Value.FLOAT:\n+                return value.getBigDecimal().unscaledValue().toByteArray();\n+            case Value.TIME:\n+                return BigInteger.valueOf(value.getTime().getTime()).toByteArray();\n+            case Value.DATE:\n+                return BigInteger.valueOf(value.getDate().getTime()).toByteArray();\n+            case Value.TIMESTAMP:\n+                return BigInteger.valueOf(value.getTimestamp().getTime()).toByteArray();\n+            default:\n+                return value.getBytes();\n+        }\n+    }\n+\n+    public void add(Value val) {\n+        total++;\n+\n+        if (isNull((val))) {", "originalCommit": "ed494880989fa84ae17c9894ba72e630741227fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIyODExMg==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r506228112", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    int cardinality = 0;\n          \n          \n            \n            \n          \n          \n            \n                    cardinality = cardinalityPercent(nullsCnt, total, hll.cardinality());\n          \n          \n            \n                    int cardinality = cardinalityPercent(nullsCnt, total, hll.cardinality());", "author": "korlov42", "createdAt": "2020-10-16T09:41:34Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/ColumnStatisticsCollector.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import java.math.BigInteger;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Comparator;\n+import java.util.List;\n+\n+import org.apache.ignite.internal.processors.query.stat.hll.HLL;\n+import org.gridgain.internal.h2.table.Column;\n+import org.gridgain.internal.h2.value.Value;\n+\n+/**\n+ * Collector to compute statistic by single column.\n+ */\n+public class ColumnStatisticsCollector {\n+\n+    /** */\n+    private final Column col;\n+\n+    /** Hyper Log Log structure */\n+    private final HLL hll = new HLL(13/*log2m*/, 5/*registerWidth*/);\n+\n+    /** Minimum value. */\n+    private Value min = null;\n+\n+    /** Maximum value. */\n+    private Value max = null;\n+\n+    /** Total vals in column. */\n+    private long total = 0;\n+\n+    /** Total size of all non nulls values (in bytes).*/\n+    private long size = 0;\n+\n+    /** Temporary byte buffer just to avoid unnecessary object creation. */\n+    private ByteBuffer bb;\n+\n+    /** Column value comparator. */\n+    private final Comparator<Value> comp;\n+\n+    /** Null values counter. */\n+    private long nullsCnt;\n+\n+    /** Hasher. */\n+    private final Hasher hash = new Hasher();\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param col column to collect statistics by.\n+     * @param comp column values comparator.\n+     */\n+    public ColumnStatisticsCollector(Column col, Comparator<Value> comp) {\n+        this.col = col;\n+        this.comp = comp;\n+    }\n+\n+    /**\n+     * Try to fix unexpected behaviour of base Value class.\n+     *\n+     * @param value value to convert\n+     * @return byte array\n+     */\n+    private byte[] getBytes(Value value) {\n+        switch (value.getValueType()) {\n+            case Value.STRING:\n+                String strValue = value.getString();\n+                return strValue.getBytes(StandardCharsets.UTF_8);\n+            case Value.BOOLEAN:\n+                return value.getBoolean() ? new byte[]{1} : new byte[]{0} ;\n+            case Value.DECIMAL:\n+            case Value.DOUBLE:\n+            case Value.FLOAT:\n+                return value.getBigDecimal().unscaledValue().toByteArray();\n+            case Value.TIME:\n+                return BigInteger.valueOf(value.getTime().getTime()).toByteArray();\n+            case Value.DATE:\n+                return BigInteger.valueOf(value.getDate().getTime()).toByteArray();\n+            case Value.TIMESTAMP:\n+                return BigInteger.valueOf(value.getTimestamp().getTime()).toByteArray();\n+            default:\n+                return value.getBytes();\n+        }\n+    }\n+\n+    public void add(Value val) {\n+        total++;\n+\n+        if (isNull((val))) {\n+            nullsCnt++;\n+\n+            return;\n+        }\n+\n+        byte bytes[] = getBytes(val);\n+        size += bytes.length;\n+\n+        hll.addRaw(hash.fastHash(bytes));\n+\n+        if (null == min || comp.compare(val, min) < 0)\n+            min = val;\n+\n+        if (null == max || comp.compare(val, max) > 0)\n+            max = val;\n+    }\n+\n+    private boolean isNull(Value v) {\n+        return v == null || v.getType().getValueType() == Value.NULL;\n+    }\n+\n+    /**\n+     * Get total column statistics.\n+     *\n+     * @return aggregated column statistics.\n+     */\n+    public ColumnStatistics finish() {\n+        int nulls = nullsPercent(nullsCnt, total);\n+\n+        int cardinality = 0;\n+\n+        cardinality = cardinalityPercent(nullsCnt, total, hll.cardinality());", "originalCommit": "ed494880989fa84ae17c9894ba72e630741227fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIzMTY2Mw==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r506231663", "bodyText": "How did you decide what is supposed to be a separate method and what is supposed to be just a ternary operator?", "author": "korlov42", "createdAt": "2020-10-16T09:46:04Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/ColumnStatisticsCollector.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import java.math.BigInteger;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Comparator;\n+import java.util.List;\n+\n+import org.apache.ignite.internal.processors.query.stat.hll.HLL;\n+import org.gridgain.internal.h2.table.Column;\n+import org.gridgain.internal.h2.value.Value;\n+\n+/**\n+ * Collector to compute statistic by single column.\n+ */\n+public class ColumnStatisticsCollector {\n+\n+    /** */\n+    private final Column col;\n+\n+    /** Hyper Log Log structure */\n+    private final HLL hll = new HLL(13/*log2m*/, 5/*registerWidth*/);\n+\n+    /** Minimum value. */\n+    private Value min = null;\n+\n+    /** Maximum value. */\n+    private Value max = null;\n+\n+    /** Total vals in column. */\n+    private long total = 0;\n+\n+    /** Total size of all non nulls values (in bytes).*/\n+    private long size = 0;\n+\n+    /** Temporary byte buffer just to avoid unnecessary object creation. */\n+    private ByteBuffer bb;\n+\n+    /** Column value comparator. */\n+    private final Comparator<Value> comp;\n+\n+    /** Null values counter. */\n+    private long nullsCnt;\n+\n+    /** Hasher. */\n+    private final Hasher hash = new Hasher();\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param col column to collect statistics by.\n+     * @param comp column values comparator.\n+     */\n+    public ColumnStatisticsCollector(Column col, Comparator<Value> comp) {\n+        this.col = col;\n+        this.comp = comp;\n+    }\n+\n+    /**\n+     * Try to fix unexpected behaviour of base Value class.\n+     *\n+     * @param value value to convert\n+     * @return byte array\n+     */\n+    private byte[] getBytes(Value value) {\n+        switch (value.getValueType()) {\n+            case Value.STRING:\n+                String strValue = value.getString();\n+                return strValue.getBytes(StandardCharsets.UTF_8);\n+            case Value.BOOLEAN:\n+                return value.getBoolean() ? new byte[]{1} : new byte[]{0} ;\n+            case Value.DECIMAL:\n+            case Value.DOUBLE:\n+            case Value.FLOAT:\n+                return value.getBigDecimal().unscaledValue().toByteArray();\n+            case Value.TIME:\n+                return BigInteger.valueOf(value.getTime().getTime()).toByteArray();\n+            case Value.DATE:\n+                return BigInteger.valueOf(value.getDate().getTime()).toByteArray();\n+            case Value.TIMESTAMP:\n+                return BigInteger.valueOf(value.getTimestamp().getTime()).toByteArray();\n+            default:\n+                return value.getBytes();\n+        }\n+    }\n+\n+    public void add(Value val) {\n+        total++;\n+\n+        if (isNull((val))) {\n+            nullsCnt++;\n+\n+            return;\n+        }\n+\n+        byte bytes[] = getBytes(val);\n+        size += bytes.length;\n+\n+        hll.addRaw(hash.fastHash(bytes));\n+\n+        if (null == min || comp.compare(val, min) < 0)\n+            min = val;\n+\n+        if (null == max || comp.compare(val, max) > 0)\n+            max = val;\n+    }\n+\n+    private boolean isNull(Value v) {\n+        return v == null || v.getType().getValueType() == Value.NULL;\n+    }\n+\n+    /**\n+     * Get total column statistics.\n+     *\n+     * @return aggregated column statistics.\n+     */\n+    public ColumnStatistics finish() {\n+        int nulls = nullsPercent(nullsCnt, total);\n+\n+        int cardinality = 0;\n+\n+        cardinality = cardinalityPercent(nullsCnt, total, hll.cardinality());\n+\n+        int averageSize = (total - nullsCnt > 0) ? (int) (size / (total - nullsCnt)) : 0;", "originalCommit": "ed494880989fa84ae17c9894ba72e630741227fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU3MDcxOQ==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r507570719", "bodyText": "It should be a static method just to use both from \"finish\" and \"aggregate\" methods.", "author": "Berkof", "createdAt": "2020-10-19T08:38:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIzMTY2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIzMzY1MQ==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r506233651", "bodyText": "let's extract HLL structure creation to a separated method, since there are two places and it is easy to miss one of them if we will decide sometime to adjust this params", "author": "korlov42", "createdAt": "2020-10-16T09:49:05Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/ColumnStatisticsCollector.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import java.math.BigInteger;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Comparator;\n+import java.util.List;\n+\n+import org.apache.ignite.internal.processors.query.stat.hll.HLL;\n+import org.gridgain.internal.h2.table.Column;\n+import org.gridgain.internal.h2.value.Value;\n+\n+/**\n+ * Collector to compute statistic by single column.\n+ */\n+public class ColumnStatisticsCollector {\n+\n+    /** */\n+    private final Column col;\n+\n+    /** Hyper Log Log structure */\n+    private final HLL hll = new HLL(13/*log2m*/, 5/*registerWidth*/);\n+\n+    /** Minimum value. */\n+    private Value min = null;\n+\n+    /** Maximum value. */\n+    private Value max = null;\n+\n+    /** Total vals in column. */\n+    private long total = 0;\n+\n+    /** Total size of all non nulls values (in bytes).*/\n+    private long size = 0;\n+\n+    /** Temporary byte buffer just to avoid unnecessary object creation. */\n+    private ByteBuffer bb;\n+\n+    /** Column value comparator. */\n+    private final Comparator<Value> comp;\n+\n+    /** Null values counter. */\n+    private long nullsCnt;\n+\n+    /** Hasher. */\n+    private final Hasher hash = new Hasher();\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param col column to collect statistics by.\n+     * @param comp column values comparator.\n+     */\n+    public ColumnStatisticsCollector(Column col, Comparator<Value> comp) {\n+        this.col = col;\n+        this.comp = comp;\n+    }\n+\n+    /**\n+     * Try to fix unexpected behaviour of base Value class.\n+     *\n+     * @param value value to convert\n+     * @return byte array\n+     */\n+    private byte[] getBytes(Value value) {\n+        switch (value.getValueType()) {\n+            case Value.STRING:\n+                String strValue = value.getString();\n+                return strValue.getBytes(StandardCharsets.UTF_8);\n+            case Value.BOOLEAN:\n+                return value.getBoolean() ? new byte[]{1} : new byte[]{0} ;\n+            case Value.DECIMAL:\n+            case Value.DOUBLE:\n+            case Value.FLOAT:\n+                return value.getBigDecimal().unscaledValue().toByteArray();\n+            case Value.TIME:\n+                return BigInteger.valueOf(value.getTime().getTime()).toByteArray();\n+            case Value.DATE:\n+                return BigInteger.valueOf(value.getDate().getTime()).toByteArray();\n+            case Value.TIMESTAMP:\n+                return BigInteger.valueOf(value.getTimestamp().getTime()).toByteArray();\n+            default:\n+                return value.getBytes();\n+        }\n+    }\n+\n+    public void add(Value val) {\n+        total++;\n+\n+        if (isNull((val))) {\n+            nullsCnt++;\n+\n+            return;\n+        }\n+\n+        byte bytes[] = getBytes(val);\n+        size += bytes.length;\n+\n+        hll.addRaw(hash.fastHash(bytes));\n+\n+        if (null == min || comp.compare(val, min) < 0)\n+            min = val;\n+\n+        if (null == max || comp.compare(val, max) > 0)\n+            max = val;\n+    }\n+\n+    private boolean isNull(Value v) {\n+        return v == null || v.getType().getValueType() == Value.NULL;\n+    }\n+\n+    /**\n+     * Get total column statistics.\n+     *\n+     * @return aggregated column statistics.\n+     */\n+    public ColumnStatistics finish() {\n+        int nulls = nullsPercent(nullsCnt, total);\n+\n+        int cardinality = 0;\n+\n+        cardinality = cardinalityPercent(nullsCnt, total, hll.cardinality());\n+\n+        int averageSize = (total - nullsCnt > 0) ? (int) (size / (total - nullsCnt)) : 0;\n+\n+        return new ColumnStatistics(min, max, nulls, cardinality, total, averageSize, hll.toBytes());\n+    }\n+\n+    private static int nullsPercent(long nullsCnt, long totalRows) {\n+        if (totalRows > 0)\n+            return (int)(100 * nullsCnt / totalRows);\n+        return 0;\n+    }\n+\n+    private static int cardinalityPercent(long nullsCnt, long totalRows, long cardinality) {\n+        if (totalRows - nullsCnt > 0)\n+            return (int)(100 * cardinality / (totalRows - nullsCnt));\n+        return 0;\n+    }\n+\n+    /**\n+     * @return get column.\n+     */\n+    public Column col() {\n+        return col;\n+    }\n+\n+    /**\n+     * Aggregate specified (partition or local) column statistics into (local or global) single one.\n+     *\n+     * @param comp value comparator.\n+     * @param partStats column statistics by partitions.\n+     * @return column statistics for all partitions.\n+     */\n+    public static ColumnStatistics aggregate(Comparator<Value> comp, List<ColumnStatistics> partStats) {\n+        HLL hll = new HLL(13/*log2m*/, 5/*registerWidth*/);", "originalCommit": "ed494880989fa84ae17c9894ba72e630741227fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjI5MzYwOQ==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r506293609", "bodyText": "think it should be stored in long", "author": "korlov42", "createdAt": "2020-10-16T10:58:40Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/ColumnStatistics.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import org.gridgain.internal.h2.value.Value;\n+\n+/**\n+ * Values statistic in particular column.\n+ */\n+public class ColumnStatistics {\n+    /** Minimum value in column or {@code null} if there are no non null values in the column. */\n+    private final Value min;\n+\n+    /** Maximum value in column or {@code null} if there are no non null values in the column. */\n+    private final Value max;\n+\n+    /** Percent of null values in column. */\n+    private final int nulls;\n+\n+    /** Percent of different values in column, i.e. 100 means that all values are unique, 0% means that all values\n+     * are the same. */\n+    private final int cardinality;\n+\n+    /** Total number of vals in column. */\n+    private final long total;\n+\n+    /** Average size in bytes, for variable size only. */\n+    private final int size;\n+\n+    private final byte[] raw;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param min min value in column or {@code null}.\n+     * @param max max value in column or {@code null}.\n+     * @param nulls percent of null values in column.\n+     * @param cardinality percent of unique value in column.\n+     * @param total total number of values in column.\n+     * @param size average size in bytes, for variable size only.\n+     * @param raw raw data to aggregate statistics.\n+     */\n+    public ColumnStatistics(Value min, Value max, int nulls, int cardinality, long total, int size, byte[] raw) {\n+        this.min = min;\n+        this.max = max;\n+        this.nulls = nulls;\n+        this.cardinality = cardinality;\n+        this.total = total;\n+        this.size = size;\n+        this.raw = raw;\n+    }\n+\n+    /**\n+     * @return min value in column.\n+     */\n+    public Value min() {\n+        return min;\n+    }\n+\n+    /**\n+     * @return max value in column.\n+     */\n+    public Value max() {\n+        return max;\n+    }\n+\n+    /**\n+     * @return percent of null values.\n+     */\n+    public int nulls() {\n+        return nulls;\n+    }\n+\n+    /**\n+     * @return percent of unique not null values.\n+     */\n+    public int cardinality() {\n+        return cardinality;\n+    }\n+\n+    /**\n+     * @return total number of values in column.\n+     */\n+    public long total() {\n+        return total;\n+    }\n+\n+    /**\n+     * @return average size in bytes, for variable size only.\n+     */\n+    public int size() {", "originalCommit": "ed494880989fa84ae17c9894ba72e630741227fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU2NTc1MA==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r507565750", "bodyText": "Added checks to handle size > Integer.MAX_VALUE and return Integer.MAX_VALUE. No one shouldn't store DVD in DB values.", "author": "Berkof", "createdAt": "2020-10-19T08:31:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjI5MzYwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjM3MjA1Mg==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r506372052", "bodyText": "it's possible to decrease nesting level by inverting the condition", "author": "korlov42", "createdAt": "2020-10-16T12:41:03Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/IgniteStatisticsRepositoryImpl.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query;\n+\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheUtils;\n+import org.apache.ignite.internal.processors.cache.query.QueryTable;\n+import org.apache.ignite.internal.processors.query.stat.ColumnStatistics;\n+import org.apache.ignite.internal.processors.query.stat.IgniteStatisticsManagerImpl;\n+import org.apache.ignite.internal.processors.query.stat.IgniteStatisticsRepository;\n+import org.apache.ignite.internal.processors.query.stat.ObjectPartitionStatistics;\n+import org.apache.ignite.internal.processors.query.stat.ObjectStatistics;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class IgniteStatisticsRepositoryImpl implements IgniteStatisticsRepository {\n+    /** Logger. */\n+    private IgniteLogger log;\n+\n+    /** */\n+    private final GridKernalContext ctx;\n+\n+    /** Table->Partition->Partition Statistics map, populated only on server nodes without persistence enabled.  */\n+    private final Map<QueryTable, Map<Integer, ObjectPartitionStatistics>> partsStats;\n+\n+    /** Local (for current node) object statistics. */\n+    private final Map<QueryTable, ObjectStatistics> localStats;\n+\n+    /** Global (for whole cluster) object statistics. */\n+    private final Map<QueryTable, ObjectStatistics> globalStats = new ConcurrentHashMap<>();\n+\n+\n+    public IgniteStatisticsRepositoryImpl(GridKernalContext ctx) {\n+        this.ctx = ctx;\n+\n+        if (ctx.config().isClientMode() || ctx.isDaemon()) {\n+            // Cache only global statistics, no store\n+            partsStats = null;\n+            localStats = null;\n+        } else {\n+            if (GridCacheUtils.isPersistenceEnabled(ctx.config())) {\n+                // Persistence store\n+                partsStats = null;\n+            } else {\n+                // Cache partitions statistics, no store\n+                partsStats = new ConcurrentHashMap<>();\n+            }\n+            localStats = new ConcurrentHashMap<>();\n+        }\n+        log = ctx.log(IgniteStatisticsRepositoryImpl.class);\n+    }\n+\n+    @Override public void saveLocalPartitionsStatistics(QueryTable tbl, Collection<ObjectPartitionStatistics> statistics,\n+                                                        boolean fullStat) {\n+        if (partsStats != null) {", "originalCommit": "ed494880989fa84ae17c9894ba72e630741227fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU1NTg0OA==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r507555848", "bodyText": "There will be some problems when we'll add storage. Because here we should cache statistics in partsStats or store it into metastore.", "author": "Berkof", "createdAt": "2020-10-19T08:15:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjM3MjA1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzYyMzM3Ng==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r507623376", "bodyText": "and do you have strong vision about how it will be?", "author": "korlov42", "createdAt": "2020-10-19T10:00:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjM3MjA1Mg=="}], "type": "inlineReview"}, {"oid": "dfc17374c7dc23034fa1ed56add4f262861f1661", "url": "https://github.com/gridgain/gridgain/commit/dfc17374c7dc23034fa1ed56add4f262861f1661", "message": "GG-18652: fix HLL int-byte map usage.", "committedDate": "2020-10-16T13:56:49Z", "type": "commit"}, {"oid": "b2e759f60632b8cfedffbb3cd6df720a2bee641c", "url": "https://github.com/gridgain/gridgain/commit/b2e759f60632b8cfedffbb3cd6df720a2bee641c", "message": "GG-18652: use ObjectStatistics interface", "committedDate": "2020-10-16T14:11:48Z", "type": "commit"}, {"oid": "7c1a9eecbab1c108a58ab8895c3a79142708f3c1", "url": "https://github.com/gridgain/gridgain/commit/7c1a9eecbab1c108a58ab8895c3a79142708f3c1", "message": "GG-18652: fix checkstyle supressions and its new warnings.", "committedDate": "2020-10-16T15:09:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU0MjIxMg==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r507542212", "bodyText": "all TBDs should be either deleted or replaced by a TODO with a description of the concern/problem/etc; it should be clear to others when this could be safely deleted.", "author": "korlov42", "createdAt": "2020-10-19T07:52:58Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/stat/ValueDistributionTableStatisticsUsageTest.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.cache.CacheMode;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import static org.apache.ignite.cache.CacheMode.REPLICATED;\n+\n+/**\n+ * Test cases to ensure that proper index is chosen by H2 optimizer when value distribution statistics is collected.\n+ */\n+@RunWith(Parameterized.class)\n+public class ValueDistributionTableStatisticsUsageTest extends TableStatisticsAbstractTest {\n+    /** */\n+    @Parameterized.Parameter(0)\n+    public CacheMode cacheMode;\n+\n+    /**\n+     * @return Test parameters.\n+     */\n+    @Parameterized.Parameters(name = \"cacheMode={0}\")\n+    public static Collection parameters() {\n+        return Arrays.asList(new Object[][] {\n+                { REPLICATED },\n+                // { PARTITIONED }, // TBD!!!", "originalCommit": "7c1a9eecbab1c108a58ab8895c3a79142708f3c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU0MzQ0NQ==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r507543445", "bodyText": "@Ignore annotation should contain reason by which this test ignored. Ideally it should be link to a Jira-ticket", "author": "korlov42", "createdAt": "2020-10-19T07:55:02Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/stat/ValueDistributionTableStatisticsUsageTest.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.cache.CacheMode;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import static org.apache.ignite.cache.CacheMode.REPLICATED;\n+\n+/**\n+ * Test cases to ensure that proper index is chosen by H2 optimizer when value distribution statistics is collected.\n+ */\n+@RunWith(Parameterized.class)\n+public class ValueDistributionTableStatisticsUsageTest extends TableStatisticsAbstractTest {\n+    /** */\n+    @Parameterized.Parameter(0)\n+    public CacheMode cacheMode;\n+\n+    /**\n+     * @return Test parameters.\n+     */\n+    @Parameterized.Parameters(name = \"cacheMode={0}\")\n+    public static Collection parameters() {\n+        return Arrays.asList(new Object[][] {\n+                { REPLICATED },\n+                // { PARTITIONED }, // TBD!!!\n+        });\n+    }\n+\n+    @Override protected void beforeTestsStarted() throws Exception {\n+        Ignite node = startGridsMultiThreaded(1); // TBD 1!!!!!\n+\n+        node.getOrCreateCache(DEFAULT_CACHE_NAME);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void beforeTest() throws Exception {\n+        runSql(\"DROP TABLE IF EXISTS sized\");\n+\n+        runSql(\"CREATE TABLE sized (ID INT PRIMARY KEY, small VARCHAR, small_nulls VARCHAR,\" +\n+                \" big VARCHAR, big_nulls VARCHAR) WITH \\\"TEMPLATE=\" + cacheMode + \"\\\"\");\n+\n+        runSql(\"CREATE INDEX sized_small ON sized(small)\");\n+        runSql(\"CREATE INDEX sized_small_nulls ON sized(small_nulls)\");\n+        runSql(\"CREATE INDEX sized_big ON sized(big)\");\n+        runSql(\"CREATE INDEX sized_big_nulls ON sized(big_nulls)\");\n+\n+        String bigValue = \"someBigLongValueWithTheSameTextAtFirst\";\n+        String smallNulls, bigNulls;\n+        int valAdd;\n+        for (int i = 0; i < BIG_SIZE; i++) {\n+            if ((i & 1) == 0) {\n+                smallNulls = \"null\";\n+                bigNulls = null;\n+                valAdd = 0;\n+            } else {\n+                smallNulls = String.format(\"'small%d'\", i);\n+                bigNulls = String.format(\"'%s%d'\", bigValue, i);\n+                valAdd = 1;\n+            }\n+            String sql = String.format(\"INSERT INTO sized(id, small, small_nulls, big, big_nulls)\" +\n+                    \" VALUES(%d,'small%d', %s, '%s%d', %s)\", i, i + valAdd, smallNulls, bigValue, i + valAdd, bigNulls);\n+            runSql(sql);\n+        }\n+        runSql(\"INSERT INTO sized(id, small, big) VALUES(\" + BIG_SIZE + \", null, null)\");\n+        updateStatistics(\"sized\");\n+    }\n+\n+    @Test\n+    public void selectWithManyCond() {\n+        String sql = \"SELECT COUNT(*) FROM sized i1 USE INDEX (sized_small) where big like '3%' and small like '3%'\";\n+        checkOptimalPlanChosenForDifferentIndexes(grid(0), new String[]{\"SIZED_SMALL\"}, sql, new String[1][]);\n+    }\n+\n+    @Test\n+    public void selectNullCond() {\n+        String sql = \"select count(*) from sized i1 where small is null\";\n+        checkOptimalPlanChosenForDifferentIndexes(grid(0), new String[]{\"SIZED_SMALL\"}, sql, new String[1][]);\n+    }\n+\n+    @Test\n+    @Ignore", "originalCommit": "7c1a9eecbab1c108a58ab8895c3a79142708f3c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU0NDQyNA==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r507544424", "bodyText": "Why did you use hint here?", "author": "korlov42", "createdAt": "2020-10-19T07:56:42Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/stat/ValueDistributionTableStatisticsUsageTest.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.cache.CacheMode;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import static org.apache.ignite.cache.CacheMode.REPLICATED;\n+\n+/**\n+ * Test cases to ensure that proper index is chosen by H2 optimizer when value distribution statistics is collected.\n+ */\n+@RunWith(Parameterized.class)\n+public class ValueDistributionTableStatisticsUsageTest extends TableStatisticsAbstractTest {\n+    /** */\n+    @Parameterized.Parameter(0)\n+    public CacheMode cacheMode;\n+\n+    /**\n+     * @return Test parameters.\n+     */\n+    @Parameterized.Parameters(name = \"cacheMode={0}\")\n+    public static Collection parameters() {\n+        return Arrays.asList(new Object[][] {\n+                { REPLICATED },\n+                // { PARTITIONED }, // TBD!!!\n+        });\n+    }\n+\n+    @Override protected void beforeTestsStarted() throws Exception {\n+        Ignite node = startGridsMultiThreaded(1); // TBD 1!!!!!\n+\n+        node.getOrCreateCache(DEFAULT_CACHE_NAME);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void beforeTest() throws Exception {\n+        runSql(\"DROP TABLE IF EXISTS sized\");\n+\n+        runSql(\"CREATE TABLE sized (ID INT PRIMARY KEY, small VARCHAR, small_nulls VARCHAR,\" +\n+                \" big VARCHAR, big_nulls VARCHAR) WITH \\\"TEMPLATE=\" + cacheMode + \"\\\"\");\n+\n+        runSql(\"CREATE INDEX sized_small ON sized(small)\");\n+        runSql(\"CREATE INDEX sized_small_nulls ON sized(small_nulls)\");\n+        runSql(\"CREATE INDEX sized_big ON sized(big)\");\n+        runSql(\"CREATE INDEX sized_big_nulls ON sized(big_nulls)\");\n+\n+        String bigValue = \"someBigLongValueWithTheSameTextAtFirst\";\n+        String smallNulls, bigNulls;\n+        int valAdd;\n+        for (int i = 0; i < BIG_SIZE; i++) {\n+            if ((i & 1) == 0) {\n+                smallNulls = \"null\";\n+                bigNulls = null;\n+                valAdd = 0;\n+            } else {\n+                smallNulls = String.format(\"'small%d'\", i);\n+                bigNulls = String.format(\"'%s%d'\", bigValue, i);\n+                valAdd = 1;\n+            }\n+            String sql = String.format(\"INSERT INTO sized(id, small, small_nulls, big, big_nulls)\" +\n+                    \" VALUES(%d,'small%d', %s, '%s%d', %s)\", i, i + valAdd, smallNulls, bigValue, i + valAdd, bigNulls);\n+            runSql(sql);\n+        }\n+        runSql(\"INSERT INTO sized(id, small, big) VALUES(\" + BIG_SIZE + \", null, null)\");\n+        updateStatistics(\"sized\");\n+    }\n+\n+    @Test\n+    public void selectWithManyCond() {\n+        String sql = \"SELECT COUNT(*) FROM sized i1 USE INDEX (sized_small) where big like '3%' and small like '3%'\";", "originalCommit": "7c1a9eecbab1c108a58ab8895c3a79142708f3c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU0NzU3MQ==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r507547571", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (idx != null && idx.length > 0) {\n          \n          \n            \n                        if (!F.isEmpty(idx)) {", "author": "korlov42", "createdAt": "2020-10-19T08:01:47Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/stat/TableStatisticsAbstractTest.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.cache.query.SqlFieldsQuery;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.processors.cache.query.SqlFieldsQueryEx;\n+import org.apache.ignite.internal.util.typedef.G;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+\n+/**\n+ * Base test for table statistics.\n+ */\n+public abstract class TableStatisticsAbstractTest extends GridCommonAbstractTest {\n+    /** */\n+    static final int BIG_SIZE = 1000;\n+\n+    /** */\n+    static final int MED_SIZE = 500;\n+\n+    /** */\n+    static final int SMALL_SIZE = 100;\n+\n+    static {\n+        assertTrue(SMALL_SIZE < MED_SIZE && MED_SIZE < BIG_SIZE);\n+    }\n+\n+    /**\n+     * Compare different index used for the given query.\n+     *\n+     * @param grid qrid to run queries on.\n+     * @param optimal array of optimal indexes\n+     * @param sql Query with placeholders to hint indexes (i1, i2, ...)\n+     * @param indexes arrays of indexes to put into placeholders.\n+     */\n+    protected void checkOptimalPlanChosenForDifferentIndexes(Ignite grid, String[] optimal, String sql, String[][] indexes) {\n+        int size = -1;\n+        for (String[] idxs : indexes) {\n+            if (size == -1)\n+                size = (idxs == null) ? 0 : idxs.length;\n+\n+            assert idxs == null || idxs.length == size;\n+        }\n+        sql = replaceIndexHintPlaceholders(sql, indexes);\n+        String actual[] = runLocalExplainIdx(grid, sql);\n+\n+        assertTrue(String.format(\"got %s, expected %s in query %s\", Arrays.asList(actual), Arrays.asList(optimal), sql),\n+                Arrays.equals(actual, optimal));\n+    }\n+\n+    /**\n+     * Compares different orders of joins for the given query.\n+     *\n+     * @param grid qrid to run queries on.\n+     * @param sql Query.\n+     * @param tbls Table names.\n+     */\n+    protected void checkOptimalPlanChosenForDifferentJoinOrders(Ignite grid, String sql, String... tbls) {\n+        String directOrder = replaceTablePlaceholders(sql, tbls);\n+\n+        if (log.isDebugEnabled())\n+            log.debug(\"Direct join order=\" + directOrder);\n+\n+        ensureOptimalPlanChosen(grid, directOrder);\n+\n+        // Reverse tables order.\n+        List<String> dirOrdTbls = Arrays.asList(tbls);\n+\n+        Collections.reverse(dirOrdTbls);\n+\n+        String reversedOrder = replaceTablePlaceholders(sql, dirOrdTbls.toArray(new String[dirOrdTbls.size()]));\n+\n+        if (log.isDebugEnabled())\n+            log.debug(\"Reversed join order=\" + reversedOrder);\n+\n+        ensureOptimalPlanChosen(grid, reversedOrder);\n+    }\n+\n+    /**\n+     * Compares join orders by actually scanned rows. Join command is run twice:\n+     * with {@code enforceJoinOrder = true} and without. The latest allows join order optimization\n+     * based or table row count.\n+     *\n+     * Actual scan row count is obtained from the EXPLAIN ANALYZE command result.\n+     */\n+    private void ensureOptimalPlanChosen(Ignite grid, String sql, String... tbls) {\n+        int cntNoStats = runLocalExplainAnalyze(grid, true, sql);\n+\n+        int cntStats = runLocalExplainAnalyze(grid, false, sql);\n+\n+        String res = \"Scanned rows count [noStats=\" + cntNoStats + \", withStats=\" + cntStats +\n+                \", diff=\" + (cntNoStats - cntStats) + ']';\n+\n+        if (log.isInfoEnabled())\n+            log.info(res);\n+\n+        assertTrue(res, cntStats <= cntNoStats);\n+    }\n+\n+    /**\n+     * Run specified query with EXPLAIN and return array of used indexes.\n+     *\n+     * @param grid grid where query should be executed.\n+     * @param sql query to explain.\n+     * @return array of selected indexes.\n+     */\n+    protected String[] runLocalExplainIdx(Ignite grid, String sql) {\n+        List<List<?>> res = grid.cache(DEFAULT_CACHE_NAME).query(new SqlFieldsQuery(\"EXPLAIN \" + sql).setLocal(true))\n+                .getAll();\n+        String explainRes = (String)res.get(0).get(0);\n+\n+        // Extract scan count from EXPLAIN ANALYZE with regex: return all numbers after \"scanCount: \".\n+        Matcher m = Pattern.compile(\".*\\\\/\\\\*.+?\\\\.(\\\\w+):.*\\\\R*.*\\\\R*.*\\\\R*.*\\\\R*\\\\*\\\\/.*\").matcher(explainRes);\n+        //\".*\\\\/\\\\*.+?\\\\.(\\\\w+).*\\\\/.*\").matcher(explainRes);\n+        List<String> result = new ArrayList<>();\n+        while (m.find()) {\n+            result.add(m.group(1).trim());\n+        }\n+        return result.toArray(new String[result.size()]);\n+    }\n+\n+    /**\n+     * Runs local join sql in EXPLAIN ANALYZE mode and extracts actual scanned row count from the result.\n+     *\n+     * @param enfJoinOrder Enforce join order flag.\n+     * @param sql Sql string.\n+     * @return Actual scanned rows count.\n+     */\n+    protected int runLocalExplainAnalyze(Ignite grid, boolean enfJoinOrder, String sql) {\n+        List<List<?>> res = grid.cache(DEFAULT_CACHE_NAME)\n+                .query(new SqlFieldsQueryEx(\"EXPLAIN ANALYZE \" + sql, null)\n+                        .setEnforceJoinOrder(enfJoinOrder)\n+                        .setLocal(true))\n+                .getAll();\n+\n+        if (log.isDebugEnabled())\n+            log.debug(\"ExplainAnalyze enfJoinOrder=\" + enfJoinOrder + \", res=\" + res);\n+\n+        return extractScanCountFromExplain(res);\n+    }\n+\n+    /**\n+     * Extracts actual scanned rows count from EXPLAIN ANALYZE result.\n+     *\n+     * @param res EXPLAIN ANALYZE result.\n+     * @return actual scanned rows count.\n+     */\n+    private int extractScanCountFromExplain(List<List<?>> res) {\n+        String explainRes = (String)res.get(0).get(0);\n+\n+        // Extract scan count from EXPLAIN ANALYZE with regex: return all numbers after \"scanCount: \".\n+        Matcher m = Pattern.compile(\"scanCount: (?=(\\\\d+))\").matcher(explainRes);\n+\n+        int scanCnt = 0;\n+\n+        while (m.find())\n+            scanCnt += Integer.valueOf(m.group(1));\n+\n+        return scanCnt;\n+    }\n+\n+    /**\n+     * @param sql Statement.\n+     */\n+    protected void runSql(String sql) {\n+        grid(0).cache(DEFAULT_CACHE_NAME).query(new SqlFieldsQuery(sql)).getAll();\n+    }\n+\n+    /**\n+     * Replaces index hint placeholder like \"i1\", \"i2\" with specified index names in the ISQL query.\n+     *\n+     * @param sql\n+     * @param idxs\n+     * @return\n+     */\n+    private static String replaceIndexHintPlaceholders(String sql, String[][] idxs) {\n+        assert !sql.contains(\"i0\");\n+\n+        int i = 0;\n+\n+        for (String idx[] : idxs) {\n+            String idxPlaceHolder = \"i\" + (++i);\n+\n+            assert sql.contains(idxPlaceHolder);\n+\n+            if (idx != null && idx.length > 0) {", "originalCommit": "7c1a9eecbab1c108a58ab8895c3a79142708f3c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU0ODkyOA==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r507548928", "bodyText": "commented code", "author": "korlov42", "createdAt": "2020-10-19T08:04:16Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/stat/TableStatisticsAbstractTest.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.cache.query.SqlFieldsQuery;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.processors.cache.query.SqlFieldsQueryEx;\n+import org.apache.ignite.internal.util.typedef.G;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+\n+/**\n+ * Base test for table statistics.\n+ */\n+public abstract class TableStatisticsAbstractTest extends GridCommonAbstractTest {\n+    /** */\n+    static final int BIG_SIZE = 1000;\n+\n+    /** */\n+    static final int MED_SIZE = 500;\n+\n+    /** */\n+    static final int SMALL_SIZE = 100;\n+\n+    static {\n+        assertTrue(SMALL_SIZE < MED_SIZE && MED_SIZE < BIG_SIZE);\n+    }\n+\n+    /**\n+     * Compare different index used for the given query.\n+     *\n+     * @param grid qrid to run queries on.\n+     * @param optimal array of optimal indexes\n+     * @param sql Query with placeholders to hint indexes (i1, i2, ...)\n+     * @param indexes arrays of indexes to put into placeholders.\n+     */\n+    protected void checkOptimalPlanChosenForDifferentIndexes(Ignite grid, String[] optimal, String sql, String[][] indexes) {\n+        int size = -1;\n+        for (String[] idxs : indexes) {\n+            if (size == -1)\n+                size = (idxs == null) ? 0 : idxs.length;\n+\n+            assert idxs == null || idxs.length == size;\n+        }\n+        sql = replaceIndexHintPlaceholders(sql, indexes);\n+        String actual[] = runLocalExplainIdx(grid, sql);\n+\n+        assertTrue(String.format(\"got %s, expected %s in query %s\", Arrays.asList(actual), Arrays.asList(optimal), sql),\n+                Arrays.equals(actual, optimal));\n+    }\n+\n+    /**\n+     * Compares different orders of joins for the given query.\n+     *\n+     * @param grid qrid to run queries on.\n+     * @param sql Query.\n+     * @param tbls Table names.\n+     */\n+    protected void checkOptimalPlanChosenForDifferentJoinOrders(Ignite grid, String sql, String... tbls) {\n+        String directOrder = replaceTablePlaceholders(sql, tbls);\n+\n+        if (log.isDebugEnabled())\n+            log.debug(\"Direct join order=\" + directOrder);\n+\n+        ensureOptimalPlanChosen(grid, directOrder);\n+\n+        // Reverse tables order.\n+        List<String> dirOrdTbls = Arrays.asList(tbls);\n+\n+        Collections.reverse(dirOrdTbls);\n+\n+        String reversedOrder = replaceTablePlaceholders(sql, dirOrdTbls.toArray(new String[dirOrdTbls.size()]));\n+\n+        if (log.isDebugEnabled())\n+            log.debug(\"Reversed join order=\" + reversedOrder);\n+\n+        ensureOptimalPlanChosen(grid, reversedOrder);\n+    }\n+\n+    /**\n+     * Compares join orders by actually scanned rows. Join command is run twice:\n+     * with {@code enforceJoinOrder = true} and without. The latest allows join order optimization\n+     * based or table row count.\n+     *\n+     * Actual scan row count is obtained from the EXPLAIN ANALYZE command result.\n+     */\n+    private void ensureOptimalPlanChosen(Ignite grid, String sql, String... tbls) {\n+        int cntNoStats = runLocalExplainAnalyze(grid, true, sql);\n+\n+        int cntStats = runLocalExplainAnalyze(grid, false, sql);\n+\n+        String res = \"Scanned rows count [noStats=\" + cntNoStats + \", withStats=\" + cntStats +\n+                \", diff=\" + (cntNoStats - cntStats) + ']';\n+\n+        if (log.isInfoEnabled())\n+            log.info(res);\n+\n+        assertTrue(res, cntStats <= cntNoStats);\n+    }\n+\n+    /**\n+     * Run specified query with EXPLAIN and return array of used indexes.\n+     *\n+     * @param grid grid where query should be executed.\n+     * @param sql query to explain.\n+     * @return array of selected indexes.\n+     */\n+    protected String[] runLocalExplainIdx(Ignite grid, String sql) {\n+        List<List<?>> res = grid.cache(DEFAULT_CACHE_NAME).query(new SqlFieldsQuery(\"EXPLAIN \" + sql).setLocal(true))\n+                .getAll();\n+        String explainRes = (String)res.get(0).get(0);\n+\n+        // Extract scan count from EXPLAIN ANALYZE with regex: return all numbers after \"scanCount: \".\n+        Matcher m = Pattern.compile(\".*\\\\/\\\\*.+?\\\\.(\\\\w+):.*\\\\R*.*\\\\R*.*\\\\R*.*\\\\R*\\\\*\\\\/.*\").matcher(explainRes);\n+        //\".*\\\\/\\\\*.+?\\\\.(\\\\w+).*\\\\/.*\").matcher(explainRes);", "originalCommit": "7c1a9eecbab1c108a58ab8895c3a79142708f3c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzYwNjM1OQ==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r507606359", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Chack that specified index is used in query plan with specified where clause tables.\n          \n          \n            \n                 * Check that specified index is used in query plan with specified where clause tables.", "author": "korlov42", "createdAt": "2020-10-19T09:33:42Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/cache/index/BasicIndexTest.java", "diffHunk": "@@ -522,17 +522,47 @@ private void runEqualFieldsDynamicIndexes(boolean persistEnabled) throws Excepti\n         assertFalse(lsnrIdx7.check());\n     }\n \n+    /**\n+     * Check that specified index is used in query plan with specified where clause tables.\n+     *\n+     * @param qryProc query processor to run queries on.\n+     * @param idxName index name to test.\n+     * @param tblName table to query.\n+     * @param reqFlds fields to add into where clause.\n+     */\n+    private void checkIdxIsUsed(GridQueryProcessor qryProc, String idxName, String tblName, String... reqFlds) {\n+       checkIdxUsage(qryProc, idxName, null, tblName, reqFlds);\n+    }\n+\n+    /**\n+     * Chack that specified index is used in query plan with specified where clause tables.", "originalCommit": "7c1a9eecbab1c108a58ab8895c3a79142708f3c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzYwODcxNg==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r507608716", "bodyText": "is javadoc complete?", "author": "korlov42", "createdAt": "2020-10-19T09:37:21Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/ObjectPartitionStatisticsImpl.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Statistic for some partition of data object.\n+ */\n+public class ObjectPartitionStatisticsImpl extends ObjectStatisticsImpl {\n+    /** Partition id. */\n+    private final int partId;\n+\n+    /** Partition update counter at the moment when */", "originalCommit": "7c1a9eecbab1c108a58ab8895c3a79142708f3c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzYxMzQ1NQ==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r507613455", "bodyText": "Depends on params the behavior may change. Let's state it in description", "author": "korlov42", "createdAt": "2020-10-19T09:44:47Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/IgniteStatisticsRepository.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import org.apache.ignite.internal.processors.cache.query.QueryTable;\n+\n+import java.util.Collection;\n+\n+/**\n+ * Repository to store all necessary statistics. Can request absent ones from cluster and store to\n+ * {@link SqlStatisticsStoreImpl}.\n+ */\n+public interface IgniteStatisticsRepository {\n+\n+    /**\n+     * Replace all table statistics with specified ones.", "originalCommit": "7c1a9eecbab1c108a58ab8895c3a79142708f3c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzYyNjc4Nw==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r507626787", "bodyText": "unrelated changes", "author": "korlov42", "createdAt": "2020-10-19T10:06:20Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/opt/H2IndexCostedBase.java", "diffHunk": "@@ -16,57 +16,77 @@\n \n package org.apache.ignite.internal.processors.query.h2.opt;\n \n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.math.MathContext;\n import java.util.ArrayList;\n import java.util.Arrays;\n+\n import org.apache.ignite.IgniteLogger;\n import org.apache.ignite.IgniteSystemProperties;\n+import org.apache.ignite.internal.processors.query.stat.ColumnStatistics;\n+import org.apache.ignite.internal.processors.query.stat.ObjectStatisticsImpl;\n import org.apache.ignite.internal.util.typedef.F;\n import org.apache.ignite.internal.util.typedef.internal.LT;\n import org.gridgain.internal.h2.command.dml.AllColumnsForPlan;\n import org.gridgain.internal.h2.engine.Constants;\n+import org.gridgain.internal.h2.engine.Session;\n+import org.gridgain.internal.h2.expression.Expression;\n+import org.gridgain.internal.h2.expression.condition.Comparison;\n import org.gridgain.internal.h2.index.BaseIndex;\n import org.gridgain.internal.h2.index.IndexCondition;\n import org.gridgain.internal.h2.index.IndexType;\n import org.gridgain.internal.h2.result.SortOrder;\n import org.gridgain.internal.h2.table.Column;\n import org.gridgain.internal.h2.table.IndexColumn;\n import org.gridgain.internal.h2.table.TableFilter;\n+import org.gridgain.internal.h2.value.Value;\n+import org.jetbrains.annotations.Nullable;\n \n /**\n  * Index base.\n  */\n public abstract class H2IndexCostedBase extends BaseIndex {\n-    /** Const function. */\n+    /**\n+     * Const function.\n+     */\n     private final CostFunction constFunc;\n \n-    /** Logger. */\n+    private final GridH2Table tbl;\n+\n+    private final CostFunctionLast cfl = new CostFunctionLast();\n+\n+    /**\n+     * Logger.\n+     */\n     private final IgniteLogger log;\n \n     /**\n      * Constructor.\n      *\n-     * @param tbl Table.\n+     * @param tbl  Table.\n      * @param name Index name.\n      * @param cols Indexed columns.\n      * @param type Index type.\n      */\n     protected H2IndexCostedBase(GridH2Table tbl, String name, IndexColumn[] cols, IndexType type) {\n         super(tbl, 0, name, cols, type);\n \n+        this.tbl = tbl;\n+\n         log = tbl.rowDescriptor().tableDescriptor().indexing().kernalContext().log(\"H2Index\");\n \n         CostFunctionType costFuncType;\n \n         try {\n             costFuncType = CostFunctionType.valueOf(\n-                IgniteSystemProperties.getString(", "originalCommit": "7c1a9eecbab1c108a58ab8895c3a79142708f3c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzYyODMzNw==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r507628337", "bodyText": "unrelated changes", "author": "korlov42", "createdAt": "2020-10-19T10:09:07Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/opt/H2IndexCostedBase.java", "diffHunk": "@@ -92,18 +117,27 @@ protected H2IndexCostedBase(GridH2Table tbl, String name, IndexColumn[] cols, In\n     /**\n      * Re-implement {@link BaseIndex#getCostRangeIndex} to dispatch cost function on new and old versions.\n      */\n-    protected long costRangeIndex(int[] masks, long rowCount,\n-        TableFilter[] filters, int filter, SortOrder sortOrder,\n-        boolean isScanIndex, AllColumnsForPlan allColumnsSet) {\n-        return constFunc.getCostRangeIndex(masks, rowCount, filters, filter, sortOrder, isScanIndex, allColumnsSet);\n+    protected long costRangeIndex(Session ses, int[] masks, long rowCount,\n+                                  TableFilter[] filters, int filter, SortOrder sortOrder,", "originalCommit": "7c1a9eecbab1c108a58ab8895c3a79142708f3c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY0MjE5NQ==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r507642195", "bodyText": "I think it is not good idea to use QueryTable here, because in order to get stats for index you have to create QueryTable with name from index, and this could be a quite confusing.", "author": "korlov42", "createdAt": "2020-10-19T10:33:02Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/IgniteStatisticsRepository.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import org.apache.ignite.internal.processors.cache.query.QueryTable;\n+\n+import java.util.Collection;\n+\n+/**\n+ * Repository to store all necessary statistics. Can request absent ones from cluster and store to\n+ * {@link SqlStatisticsStoreImpl}.\n+ */\n+public interface IgniteStatisticsRepository {\n+\n+    /**\n+     * Replace all table statistics with specified ones.\n+     *\n+     * @param tbl table.\n+     * @param statistics collection of tables partition statistics.\n+     * @param fullStat if {@code True} - replace whole statistics, try to merge with existing - otherwise.\n+     */\n+    void saveLocalPartitionsStatistics(QueryTable tbl, Collection<ObjectPartitionStatisticsImpl> statistics, boolean fullStat);\n+\n+    /**\n+     * Get local partition statistics by specified table.\n+     *\n+     * @param tbl table to get statistics by.\n+     * @return collection of partitions statistics.\n+     */\n+    Collection<ObjectPartitionStatisticsImpl> getLocalPartitionsStatistics(QueryTable tbl);", "originalCommit": "7c1a9eecbab1c108a58ab8895c3a79142708f3c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6c3c8ad524c4cd230102a17f99f57f6c825fa138", "url": "https://github.com/gridgain/gridgain/commit/6c3c8ad524c4cd230102a17f99f57f6c825fa138", "message": "GG-18652: minor formatting, remove sorting cost in H2.Table, add size > Integer.MAX_VALUE handling in statistics collection.", "committedDate": "2020-10-19T10:58:15Z", "type": "commit"}, {"oid": "23c52cbf8cdd23b3038f151fb3a094ba6abb4e55", "url": "https://github.com/gridgain/gridgain/commit/23c52cbf8cdd23b3038f151fb3a094ba6abb4e55", "message": "GG-18652: minor formatting, switch from QueryTable to StatsKey to cache collected statistics.", "committedDate": "2020-10-19T12:20:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzc4NzM0NA==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r507787344", "bodyText": "Seems, partStats.merge() method can be used instead.", "author": "AMashenkov", "createdAt": "2020-10-19T14:18:48Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/IgniteStatisticsRepositoryImpl.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query;\n+\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheUtils;\n+import org.apache.ignite.internal.processors.query.stat.ColumnStatistics;\n+import org.apache.ignite.internal.processors.query.stat.IgniteStatisticsManagerImpl;\n+import org.apache.ignite.internal.processors.query.stat.IgniteStatisticsRepository;\n+import org.apache.ignite.internal.processors.query.stat.ObjectPartitionStatisticsImpl;\n+import org.apache.ignite.internal.processors.query.stat.ObjectStatisticsImpl;\n+import org.apache.ignite.internal.processors.query.stat.StatsKey;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Statistics repository implementation.\n+ */\n+public class IgniteStatisticsRepositoryImpl implements IgniteStatisticsRepository {\n+    /** Logger. */\n+    private IgniteLogger log;\n+\n+    /** */\n+    private final GridKernalContext ctx;\n+\n+    /** Table->Partition->Partition Statistics map, populated only on server nodes without persistence enabled.  */\n+    private final Map<StatsKey, Map<Integer, ObjectPartitionStatisticsImpl>> partsStats;\n+\n+    /** Local (for current node) object statistics. */\n+    private final Map<StatsKey, ObjectStatisticsImpl> localStats;\n+\n+    /** Global (for whole cluster) object statistics. */\n+    private final Map<StatsKey, ObjectStatisticsImpl> globalStats = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Constructor.\n+     */\n+    public IgniteStatisticsRepositoryImpl(GridKernalContext ctx) {\n+        this.ctx = ctx;\n+\n+        if (ctx.config().isClientMode() || ctx.isDaemon()) {\n+            // Cache only global statistics, no store\n+            partsStats = null;\n+            localStats = null;\n+        } else {\n+            if (GridCacheUtils.isPersistenceEnabled(ctx.config())) {\n+                // Persistence store\n+                partsStats = null;\n+            } else {\n+                // Cache partitions statistics, no store\n+                partsStats = new ConcurrentHashMap<>();\n+            }\n+            localStats = new ConcurrentHashMap<>();\n+        }\n+        log = ctx.log(IgniteStatisticsRepositoryImpl.class);\n+    }\n+\n+    @Override public void saveLocalPartitionsStatistics(StatsKey key,\n+                                                        Collection<ObjectPartitionStatisticsImpl> statistics,\n+                                                        boolean fullStat) {\n+        if (partsStats != null) {\n+            Map<Integer, ObjectPartitionStatisticsImpl> statisticsMap = new ConcurrentHashMap<>();\n+            for (ObjectPartitionStatisticsImpl s : statistics) {\n+                if (statisticsMap.put(s.partId(), s) != null)\n+                    log.warning(String.format(\"Trying to save more than one %s.%s partition statistics for partition %d\",\n+                            key.schema(), key.obj(), s.partId()));\n+            }\n+\n+            if (fullStat) {\n+                partsStats.compute(key, (k, v) -> {\n+                    if (v == null)\n+                        v = statisticsMap;\n+                    else\n+                        v.putAll(statisticsMap);\n+\n+                    return v;\n+                });\n+            } else {\n+                partsStats.compute(key, (k, v) -> {\n+                    if (v != null) {\n+                        for (Map.Entry<Integer, ObjectPartitionStatisticsImpl> partStat : v.entrySet()) {\n+                            ObjectPartitionStatisticsImpl newStat = statisticsMap.get(partStat.getKey());", "originalCommit": "23c52cbf8cdd23b3038f151fb3a094ba6abb4e55", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzc5MjM2MA==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r507792360", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        Map<Integer, ObjectPartitionStatisticsImpl> objectStatisticsMap = partsStats.get(key);\n          \n          \n            \n            \n          \n          \n            \n                        return (objectStatisticsMap == null) ? null : objectStatisticsMap.values();\n          \n          \n            \n                        return objectStatisticsMap = partsStats.getOrDefault(key, Collections.EMPTY_MAP).values();", "author": "AMashenkov", "createdAt": "2020-10-19T14:25:05Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/IgniteStatisticsRepositoryImpl.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query;\n+\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheUtils;\n+import org.apache.ignite.internal.processors.query.stat.ColumnStatistics;\n+import org.apache.ignite.internal.processors.query.stat.IgniteStatisticsManagerImpl;\n+import org.apache.ignite.internal.processors.query.stat.IgniteStatisticsRepository;\n+import org.apache.ignite.internal.processors.query.stat.ObjectPartitionStatisticsImpl;\n+import org.apache.ignite.internal.processors.query.stat.ObjectStatisticsImpl;\n+import org.apache.ignite.internal.processors.query.stat.StatsKey;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Statistics repository implementation.\n+ */\n+public class IgniteStatisticsRepositoryImpl implements IgniteStatisticsRepository {\n+    /** Logger. */\n+    private IgniteLogger log;\n+\n+    /** */\n+    private final GridKernalContext ctx;\n+\n+    /** Table->Partition->Partition Statistics map, populated only on server nodes without persistence enabled.  */\n+    private final Map<StatsKey, Map<Integer, ObjectPartitionStatisticsImpl>> partsStats;\n+\n+    /** Local (for current node) object statistics. */\n+    private final Map<StatsKey, ObjectStatisticsImpl> localStats;\n+\n+    /** Global (for whole cluster) object statistics. */\n+    private final Map<StatsKey, ObjectStatisticsImpl> globalStats = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Constructor.\n+     */\n+    public IgniteStatisticsRepositoryImpl(GridKernalContext ctx) {\n+        this.ctx = ctx;\n+\n+        if (ctx.config().isClientMode() || ctx.isDaemon()) {\n+            // Cache only global statistics, no store\n+            partsStats = null;\n+            localStats = null;\n+        } else {\n+            if (GridCacheUtils.isPersistenceEnabled(ctx.config())) {\n+                // Persistence store\n+                partsStats = null;\n+            } else {\n+                // Cache partitions statistics, no store\n+                partsStats = new ConcurrentHashMap<>();\n+            }\n+            localStats = new ConcurrentHashMap<>();\n+        }\n+        log = ctx.log(IgniteStatisticsRepositoryImpl.class);\n+    }\n+\n+    @Override public void saveLocalPartitionsStatistics(StatsKey key,\n+                                                        Collection<ObjectPartitionStatisticsImpl> statistics,\n+                                                        boolean fullStat) {\n+        if (partsStats != null) {\n+            Map<Integer, ObjectPartitionStatisticsImpl> statisticsMap = new ConcurrentHashMap<>();\n+            for (ObjectPartitionStatisticsImpl s : statistics) {\n+                if (statisticsMap.put(s.partId(), s) != null)\n+                    log.warning(String.format(\"Trying to save more than one %s.%s partition statistics for partition %d\",\n+                            key.schema(), key.obj(), s.partId()));\n+            }\n+\n+            if (fullStat) {\n+                partsStats.compute(key, (k, v) -> {\n+                    if (v == null)\n+                        v = statisticsMap;\n+                    else\n+                        v.putAll(statisticsMap);\n+\n+                    return v;\n+                });\n+            } else {\n+                partsStats.compute(key, (k, v) -> {\n+                    if (v != null) {\n+                        for (Map.Entry<Integer, ObjectPartitionStatisticsImpl> partStat : v.entrySet()) {\n+                            ObjectPartitionStatisticsImpl newStat = statisticsMap.get(partStat.getKey());\n+                            if (newStat != null) {\n+                                ObjectPartitionStatisticsImpl combinedStat = add(partStat.getValue(), newStat);\n+                                statisticsMap.put(partStat.getKey(), combinedStat);\n+                            }\n+                        }\n+                    }\n+                    return statisticsMap;\n+                });\n+            }\n+        }\n+    }\n+\n+    public Collection<ObjectPartitionStatisticsImpl> getLocalPartitionsStatistics(StatsKey key) {\n+        if (partsStats != null) {\n+            Map<Integer, ObjectPartitionStatisticsImpl> objectStatisticsMap = partsStats.get(key);\n+\n+            return (objectStatisticsMap == null) ? null : objectStatisticsMap.values();", "originalCommit": "23c52cbf8cdd23b3038f151fb3a094ba6abb4e55", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzc5OTM5OA==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r507799398", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (colNames == null || colNames.length == 0) {\n          \n          \n            \n                        if (partsStats != null)\n          \n          \n            \n                            partsStats.remove(key);\n          \n          \n            \n                    } else {\n          \n          \n            \n                        if (partsStats != null) {\n          \n          \n            \n                            partsStats.computeIfPresent(key, (tblKey, partMap) -> {\n          \n          \n            \n                                partMap.replaceAll((partId, partStat) -> {\n          \n          \n            \n                                    ObjectPartitionStatisticsImpl partStatNew = substract(partStat, colNames);\n          \n          \n            \n                                    return (partStatNew.columnsStatistics().isEmpty()) ? null : partStat;\n          \n          \n            \n            \n          \n          \n            \n                                });\n          \n          \n            \n                                partMap.entrySet().removeIf(e -> e.getValue() == null);\n          \n          \n            \n                                return partMap.isEmpty() ? null : partMap;\n          \n          \n            \n                            });\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                    if (partsStats == null)\n          \n          \n            \n                        return;\n          \n          \n            \n                        \n          \n          \n            \n                    if (F.isEmpty(colNames)) {\n          \n          \n            \n                        partsStats.remove(key);\n          \n          \n            \n                    } else {            \n          \n          \n            \n                            partsStats.computeIfPresent(key, (tblKey, partMap) -> {\n          \n          \n            \n                                partMap.replaceAll((partId, partStat) -> {\n          \n          \n            \n                                    ObjectPartitionStatisticsImpl partStatNew = substract(partStat, colNames);\n          \n          \n            \n                                    return (partStatNew.columnsStatistics().isEmpty()) ? null : partStat;\n          \n          \n            \n            \n          \n          \n            \n                                });\n          \n          \n            \n                                partMap.entrySet().removeIf(e -> e.getValue() == null);\n          \n          \n            \n                                return partMap.isEmpty() ? null : partMap;\n          \n          \n            \n                            });           \n          \n          \n            \n                    }", "author": "AMashenkov", "createdAt": "2020-10-19T14:31:25Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/IgniteStatisticsRepositoryImpl.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query;\n+\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheUtils;\n+import org.apache.ignite.internal.processors.query.stat.ColumnStatistics;\n+import org.apache.ignite.internal.processors.query.stat.IgniteStatisticsManagerImpl;\n+import org.apache.ignite.internal.processors.query.stat.IgniteStatisticsRepository;\n+import org.apache.ignite.internal.processors.query.stat.ObjectPartitionStatisticsImpl;\n+import org.apache.ignite.internal.processors.query.stat.ObjectStatisticsImpl;\n+import org.apache.ignite.internal.processors.query.stat.StatsKey;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Statistics repository implementation.\n+ */\n+public class IgniteStatisticsRepositoryImpl implements IgniteStatisticsRepository {\n+    /** Logger. */\n+    private IgniteLogger log;\n+\n+    /** */\n+    private final GridKernalContext ctx;\n+\n+    /** Table->Partition->Partition Statistics map, populated only on server nodes without persistence enabled.  */\n+    private final Map<StatsKey, Map<Integer, ObjectPartitionStatisticsImpl>> partsStats;\n+\n+    /** Local (for current node) object statistics. */\n+    private final Map<StatsKey, ObjectStatisticsImpl> localStats;\n+\n+    /** Global (for whole cluster) object statistics. */\n+    private final Map<StatsKey, ObjectStatisticsImpl> globalStats = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Constructor.\n+     */\n+    public IgniteStatisticsRepositoryImpl(GridKernalContext ctx) {\n+        this.ctx = ctx;\n+\n+        if (ctx.config().isClientMode() || ctx.isDaemon()) {\n+            // Cache only global statistics, no store\n+            partsStats = null;\n+            localStats = null;\n+        } else {\n+            if (GridCacheUtils.isPersistenceEnabled(ctx.config())) {\n+                // Persistence store\n+                partsStats = null;\n+            } else {\n+                // Cache partitions statistics, no store\n+                partsStats = new ConcurrentHashMap<>();\n+            }\n+            localStats = new ConcurrentHashMap<>();\n+        }\n+        log = ctx.log(IgniteStatisticsRepositoryImpl.class);\n+    }\n+\n+    @Override public void saveLocalPartitionsStatistics(StatsKey key,\n+                                                        Collection<ObjectPartitionStatisticsImpl> statistics,\n+                                                        boolean fullStat) {\n+        if (partsStats != null) {\n+            Map<Integer, ObjectPartitionStatisticsImpl> statisticsMap = new ConcurrentHashMap<>();\n+            for (ObjectPartitionStatisticsImpl s : statistics) {\n+                if (statisticsMap.put(s.partId(), s) != null)\n+                    log.warning(String.format(\"Trying to save more than one %s.%s partition statistics for partition %d\",\n+                            key.schema(), key.obj(), s.partId()));\n+            }\n+\n+            if (fullStat) {\n+                partsStats.compute(key, (k, v) -> {\n+                    if (v == null)\n+                        v = statisticsMap;\n+                    else\n+                        v.putAll(statisticsMap);\n+\n+                    return v;\n+                });\n+            } else {\n+                partsStats.compute(key, (k, v) -> {\n+                    if (v != null) {\n+                        for (Map.Entry<Integer, ObjectPartitionStatisticsImpl> partStat : v.entrySet()) {\n+                            ObjectPartitionStatisticsImpl newStat = statisticsMap.get(partStat.getKey());\n+                            if (newStat != null) {\n+                                ObjectPartitionStatisticsImpl combinedStat = add(partStat.getValue(), newStat);\n+                                statisticsMap.put(partStat.getKey(), combinedStat);\n+                            }\n+                        }\n+                    }\n+                    return statisticsMap;\n+                });\n+            }\n+        }\n+    }\n+\n+    public Collection<ObjectPartitionStatisticsImpl> getLocalPartitionsStatistics(StatsKey key) {\n+        if (partsStats != null) {\n+            Map<Integer, ObjectPartitionStatisticsImpl> objectStatisticsMap = partsStats.get(key);\n+\n+            return (objectStatisticsMap == null) ? null : objectStatisticsMap.values();\n+        }\n+\n+        return Collections.emptyList();\n+    }\n+\n+    @Override public void clearLocalPartitionsStatistics(StatsKey key, String... colNames) {\n+        if (colNames == null || colNames.length == 0) {\n+            if (partsStats != null)\n+                partsStats.remove(key);\n+        } else {\n+            if (partsStats != null) {\n+                partsStats.computeIfPresent(key, (tblKey, partMap) -> {\n+                    partMap.replaceAll((partId, partStat) -> {\n+                        ObjectPartitionStatisticsImpl partStatNew = substract(partStat, colNames);\n+                        return (partStatNew.columnsStatistics().isEmpty()) ? null : partStat;\n+\n+                    });\n+                    partMap.entrySet().removeIf(e -> e.getValue() == null);\n+                    return partMap.isEmpty() ? null : partMap;\n+                });\n+            }\n+        }", "originalCommit": "23c52cbf8cdd23b3038f151fb3a094ba6abb4e55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzgwNjc3Mg==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r507806772", "bodyText": "seems, replace all is inefficient here as partStatNew is never used as result.\niterate over partMap and remove from iterator can used instead.", "author": "AMashenkov", "createdAt": "2020-10-19T14:38:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzc5OTM5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzgwOTE4Ng==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r507809186", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (GridCacheUtils.isPersistenceEnabled(ctx.config())) {\n          \n          \n            \n                            // Persistence store\n          \n          \n            \n                            partsStats = null;\n          \n          \n            \n                        } else {\n          \n          \n            \n                            // Cache partitions statistics, no store\n          \n          \n            \n                            partsStats = new ConcurrentHashMap<>();\n          \n          \n            \n                        }\n          \n          \n            \n                        // In-memory cache partitions statistics, if no presistent store.\n          \n          \n            \n                        partStats = (GridCacheUtils.isPersistenceEnabled(ctx.config())) ? new ConcurrentHashMap<>() : null;", "author": "AMashenkov", "createdAt": "2020-10-19T14:41:36Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/IgniteStatisticsRepositoryImpl.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query;\n+\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheUtils;\n+import org.apache.ignite.internal.processors.query.stat.ColumnStatistics;\n+import org.apache.ignite.internal.processors.query.stat.IgniteStatisticsManagerImpl;\n+import org.apache.ignite.internal.processors.query.stat.IgniteStatisticsRepository;\n+import org.apache.ignite.internal.processors.query.stat.ObjectPartitionStatisticsImpl;\n+import org.apache.ignite.internal.processors.query.stat.ObjectStatisticsImpl;\n+import org.apache.ignite.internal.processors.query.stat.StatsKey;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Statistics repository implementation.\n+ */\n+public class IgniteStatisticsRepositoryImpl implements IgniteStatisticsRepository {\n+    /** Logger. */\n+    private IgniteLogger log;\n+\n+    /** */\n+    private final GridKernalContext ctx;\n+\n+    /** Table->Partition->Partition Statistics map, populated only on server nodes without persistence enabled.  */\n+    private final Map<StatsKey, Map<Integer, ObjectPartitionStatisticsImpl>> partsStats;\n+\n+    /** Local (for current node) object statistics. */\n+    private final Map<StatsKey, ObjectStatisticsImpl> localStats;\n+\n+    /** Global (for whole cluster) object statistics. */\n+    private final Map<StatsKey, ObjectStatisticsImpl> globalStats = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Constructor.\n+     */\n+    public IgniteStatisticsRepositoryImpl(GridKernalContext ctx) {\n+        this.ctx = ctx;\n+\n+        if (ctx.config().isClientMode() || ctx.isDaemon()) {\n+            // Cache only global statistics, no store\n+            partsStats = null;\n+            localStats = null;\n+        } else {\n+            if (GridCacheUtils.isPersistenceEnabled(ctx.config())) {\n+                // Persistence store\n+                partsStats = null;\n+            } else {\n+                // Cache partitions statistics, no store\n+                partsStats = new ConcurrentHashMap<>();\n+            }", "originalCommit": "23c52cbf8cdd23b3038f151fb3a094ba6abb4e55", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f901007903dbe98d8fdfab3f983a2448b26d288b", "url": "https://github.com/gridgain/gridgain/commit/f901007903dbe98d8fdfab3f983a2448b26d288b", "message": "GG-18652: fix UUID, bytes and comparsion with <min or >max", "committedDate": "2020-10-20T14:05:16Z", "type": "commit"}, {"oid": "71b5964ecf232e018207af5caf69767ad3d11fa8", "url": "https://github.com/gridgain/gridgain/commit/71b5964ecf232e018207af5caf69767ad3d11fa8", "message": "GG-18652: return sorting cost to scan index cost estimation", "committedDate": "2020-10-20T14:06:39Z", "type": "commit"}, {"oid": "631e2e0d42e4f3fd7096f8d141634eeda0346200", "url": "https://github.com/gridgain/gridgain/commit/631e2e0d42e4f3fd7096f8d141634eeda0346200", "message": "GG-18652: style fixes", "committedDate": "2020-10-20T14:07:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU1MzcyNQ==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508553725", "bodyText": "Javadoc", "author": "AMashenkov", "createdAt": "2020-10-20T14:24:06Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/opt/H2IndexCostedBase.java", "diffHunk": "@@ -16,57 +16,77 @@\n \n package org.apache.ignite.internal.processors.query.h2.opt;\n \n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.math.MathContext;\n import java.util.ArrayList;\n import java.util.Arrays;\n+\n import org.apache.ignite.IgniteLogger;\n import org.apache.ignite.IgniteSystemProperties;\n+import org.apache.ignite.internal.processors.query.stat.ColumnStatistics;\n+import org.apache.ignite.internal.processors.query.stat.ObjectStatisticsImpl;\n import org.apache.ignite.internal.util.typedef.F;\n import org.apache.ignite.internal.util.typedef.internal.LT;\n import org.gridgain.internal.h2.command.dml.AllColumnsForPlan;\n import org.gridgain.internal.h2.engine.Constants;\n+import org.gridgain.internal.h2.engine.Session;\n+import org.gridgain.internal.h2.expression.Expression;\n+import org.gridgain.internal.h2.expression.condition.Comparison;\n import org.gridgain.internal.h2.index.BaseIndex;\n import org.gridgain.internal.h2.index.IndexCondition;\n import org.gridgain.internal.h2.index.IndexType;\n import org.gridgain.internal.h2.result.SortOrder;\n import org.gridgain.internal.h2.table.Column;\n import org.gridgain.internal.h2.table.IndexColumn;\n import org.gridgain.internal.h2.table.TableFilter;\n+import org.gridgain.internal.h2.value.Value;\n+import org.jetbrains.annotations.Nullable;\n \n /**\n  * Index base.\n  */\n public abstract class H2IndexCostedBase extends BaseIndex {\n-    /** Const function. */\n+    /**\n+     * Const function.\n+     */\n     private final CostFunction constFunc;\n \n-    /** Logger. */\n+    private final GridH2Table tbl;", "originalCommit": "71b5964ecf232e018207af5caf69767ad3d11fa8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU1NDAyOA==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508554028", "bodyText": "Space", "author": "AMashenkov", "createdAt": "2020-10-20T14:24:28Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/opt/H2IndexCostedBase.java", "diffHunk": "@@ -16,57 +16,77 @@\n \n package org.apache.ignite.internal.processors.query.h2.opt;\n \n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.math.MathContext;\n import java.util.ArrayList;\n import java.util.Arrays;\n+\n import org.apache.ignite.IgniteLogger;\n import org.apache.ignite.IgniteSystemProperties;\n+import org.apache.ignite.internal.processors.query.stat.ColumnStatistics;\n+import org.apache.ignite.internal.processors.query.stat.ObjectStatisticsImpl;\n import org.apache.ignite.internal.util.typedef.F;\n import org.apache.ignite.internal.util.typedef.internal.LT;\n import org.gridgain.internal.h2.command.dml.AllColumnsForPlan;\n import org.gridgain.internal.h2.engine.Constants;\n+import org.gridgain.internal.h2.engine.Session;\n+import org.gridgain.internal.h2.expression.Expression;\n+import org.gridgain.internal.h2.expression.condition.Comparison;\n import org.gridgain.internal.h2.index.BaseIndex;\n import org.gridgain.internal.h2.index.IndexCondition;\n import org.gridgain.internal.h2.index.IndexType;\n import org.gridgain.internal.h2.result.SortOrder;\n import org.gridgain.internal.h2.table.Column;\n import org.gridgain.internal.h2.table.IndexColumn;\n import org.gridgain.internal.h2.table.TableFilter;\n+import org.gridgain.internal.h2.value.Value;\n+import org.jetbrains.annotations.Nullable;\n \n /**\n  * Index base.\n  */\n public abstract class H2IndexCostedBase extends BaseIndex {\n-    /** Const function. */\n+    /**\n+     * Const function.\n+     */\n     private final CostFunction constFunc;\n \n-    /** Logger. */\n+    private final GridH2Table tbl;\n+\n+    private final CostFunctionLast cfl = new CostFunctionLast();\n+\n+    /**\n+     * Logger.\n+     */\n     private final IgniteLogger log;\n \n     /**\n      * Constructor.\n      *\n-     * @param tbl Table.\n+     * @param tbl  Table.", "originalCommit": "71b5964ecf232e018207af5caf69767ad3d11fa8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU1NTQ5OA==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508555498", "bodyText": "\"else if\" on  new line.", "author": "AMashenkov", "createdAt": "2020-10-20T14:26:15Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/opt/H2IndexCostedBase.java", "diffHunk": "@@ -315,34 +346,30 @@ protected final long getCostRangeIndex_8_7_12(int[] masks, long rowCount,\n                     }\n \n                     totalSelectivity = 100 - ((100 - totalSelectivity) *\n-                        (100 - column.getSelectivity()) / 100);\n+                            (100 - column.getSelectivity()) / 100);\n \n                     long distinctRows = rowCount * totalSelectivity / 100;\n \n                     if (distinctRows <= 0)\n                         distinctRows = 1;\n \n                     rowsCost = 2 + Math.max(rowCount / distinctRows, 1);\n-                }\n-                else if ((mask & IndexCondition.RANGE) == IndexCondition.RANGE) {\n+                } else if ((mask & IndexCondition.RANGE) == IndexCondition.RANGE) {", "originalCommit": "71b5964ecf232e018207af5caf69767ad3d11fa8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU1NjgxNQ==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508556815", "bodyText": "Javadoc", "author": "AMashenkov", "createdAt": "2020-10-20T14:27:46Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/opt/H2IndexCostedBase.java", "diffHunk": "@@ -641,22 +664,558 @@ else if (needsToReadFromScanIndex)\n          * Cost function.\n          * See more: {@link BaseIndex#getCostRangeIndex}.\n          */\n-        long getCostRangeIndex(int[] masks, long rowCount,\n-            TableFilter[] filters, int filter, SortOrder sortOrder,\n-            boolean isScanIndex, AllColumnsForPlan allColumnsSet);\n+        long getCostRangeIndex(Session ses, int[] masks, long rowCount,\n+                               TableFilter[] filters, int filter, SortOrder sortOrder,\n+                               boolean isScanIndex, AllColumnsForPlan allColumnsSet);\n     }\n \n     /**\n      *\n      */\n     private enum CostFunctionType {\n-        /** Last. */\n+        /**\n+         * Last.\n+         */\n         LAST,\n \n-        /** Compatible with ver. 8.7.12. */\n+        /**\n+         * Compatible with ver. 8.7.28\n+         */\n+        COMPATIBLE_8_7_28,\n+\n+        /**\n+         * Compatible with ver. 8.7.12.\n+         */\n         COMPATIBLE_8_7_12,\n \n-        /** Compatible with ver. 8.7.6. */\n+        /**\n+         * Compatible with ver. 8.7.6.\n+         */\n         COMPATIBLE_8_7_6\n     }\n+\n+    private final class CostFunctionLast {", "originalCommit": "71b5964ecf232e018207af5caf69767ad3d11fa8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU1NzU2OQ==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508557569", "bodyText": "Javadoc", "author": "AMashenkov", "createdAt": "2020-10-20T14:28:39Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/ColumnStatisticsCollector.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import java.math.BigInteger;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Comparator;\n+import java.util.List;\n+\n+import org.apache.ignite.internal.processors.query.stat.hll.HLL;\n+import org.gridgain.internal.h2.table.Column;\n+import org.gridgain.internal.h2.value.Value;\n+\n+/**\n+ * Collector to compute statistic by single column.\n+ */\n+public class ColumnStatisticsCollector {\n+\n+    /** */\n+    private final Column col;\n+\n+    /** Hyper Log Log structure */\n+    private final HLL hll = buildHll();\n+\n+    /** Minimum value. */\n+    private Value min = null;\n+\n+    /** Maximum value. */\n+    private Value max = null;\n+\n+    /** Total vals in column. */\n+    private long total = 0;\n+\n+    /** Total size of all non nulls values (in bytes).*/\n+    private long size = 0;\n+\n+    /** Temporary byte buffer just to avoid unnecessary object creation. */\n+    private ByteBuffer bb;\n+\n+    /** Column value comparator. */\n+    private final Comparator<Value> comp;\n+\n+    /** Null values counter. */\n+    private long nullsCnt;\n+\n+    /** Hasher. */\n+    private final Hasher hash = new Hasher();\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param col column to collect statistics by.\n+     * @param comp column values comparator.\n+     */\n+    public ColumnStatisticsCollector(Column col, Comparator<Value> comp) {\n+        this.col = col;\n+        this.comp = comp;\n+    }\n+\n+    /**\n+     * Try to fix unexpected behaviour of base Value class.\n+     *\n+     * @param value value to convert\n+     * @return byte array\n+     */\n+    private byte[] getBytes(Value value) {\n+        switch (value.getValueType()) {\n+            case Value.STRING:\n+                String strValue = value.getString();\n+                return strValue.getBytes(StandardCharsets.UTF_8);\n+            case Value.BOOLEAN:\n+                return value.getBoolean() ? new byte[]{1} : new byte[]{0};\n+            case Value.DECIMAL:\n+            case Value.DOUBLE:\n+            case Value.FLOAT:\n+                return value.getBigDecimal().unscaledValue().toByteArray();\n+            case Value.TIME:\n+                return BigInteger.valueOf(value.getTime().getTime()).toByteArray();\n+            case Value.DATE:\n+                return BigInteger.valueOf(value.getDate().getTime()).toByteArray();\n+            case Value.TIMESTAMP:\n+                return BigInteger.valueOf(value.getTimestamp().getTime()).toByteArray();\n+            default:\n+                return value.getBytes();\n+        }\n+    }\n+\n+    public void add(Value val) {", "originalCommit": "71b5964ecf232e018207af5caf69767ad3d11fa8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU2MTE3MQ==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508561171", "bodyText": "Javadoc.\nLet's make a static method in some utility class for this? e.g. H2Utils?", "author": "AMashenkov", "createdAt": "2020-10-20T14:32:50Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/ColumnStatisticsCollector.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import java.math.BigInteger;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Comparator;\n+import java.util.List;\n+\n+import org.apache.ignite.internal.processors.query.stat.hll.HLL;\n+import org.gridgain.internal.h2.table.Column;\n+import org.gridgain.internal.h2.value.Value;\n+\n+/**\n+ * Collector to compute statistic by single column.\n+ */\n+public class ColumnStatisticsCollector {\n+\n+    /** */\n+    private final Column col;\n+\n+    /** Hyper Log Log structure */\n+    private final HLL hll = buildHll();\n+\n+    /** Minimum value. */\n+    private Value min = null;\n+\n+    /** Maximum value. */\n+    private Value max = null;\n+\n+    /** Total vals in column. */\n+    private long total = 0;\n+\n+    /** Total size of all non nulls values (in bytes).*/\n+    private long size = 0;\n+\n+    /** Temporary byte buffer just to avoid unnecessary object creation. */\n+    private ByteBuffer bb;\n+\n+    /** Column value comparator. */\n+    private final Comparator<Value> comp;\n+\n+    /** Null values counter. */\n+    private long nullsCnt;\n+\n+    /** Hasher. */\n+    private final Hasher hash = new Hasher();\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param col column to collect statistics by.\n+     * @param comp column values comparator.\n+     */\n+    public ColumnStatisticsCollector(Column col, Comparator<Value> comp) {\n+        this.col = col;\n+        this.comp = comp;\n+    }\n+\n+    /**\n+     * Try to fix unexpected behaviour of base Value class.\n+     *\n+     * @param value value to convert\n+     * @return byte array\n+     */\n+    private byte[] getBytes(Value value) {\n+        switch (value.getValueType()) {\n+            case Value.STRING:\n+                String strValue = value.getString();\n+                return strValue.getBytes(StandardCharsets.UTF_8);\n+            case Value.BOOLEAN:\n+                return value.getBoolean() ? new byte[]{1} : new byte[]{0};\n+            case Value.DECIMAL:\n+            case Value.DOUBLE:\n+            case Value.FLOAT:\n+                return value.getBigDecimal().unscaledValue().toByteArray();\n+            case Value.TIME:\n+                return BigInteger.valueOf(value.getTime().getTime()).toByteArray();\n+            case Value.DATE:\n+                return BigInteger.valueOf(value.getDate().getTime()).toByteArray();\n+            case Value.TIMESTAMP:\n+                return BigInteger.valueOf(value.getTimestamp().getTime()).toByteArray();\n+            default:\n+                return value.getBytes();\n+        }\n+    }\n+\n+    public void add(Value val) {\n+        total++;\n+\n+        if (isNull(val)) {\n+            nullsCnt++;\n+\n+            return;\n+        }\n+\n+        byte bytes[] = getBytes(val);\n+        size += bytes.length;\n+\n+        hll.addRaw(hash.fastHash(bytes));\n+\n+        if (null == min || comp.compare(val, min) < 0)\n+            min = val;\n+\n+        if (null == max || comp.compare(val, max) > 0)\n+            max = val;\n+    }\n+\n+    private boolean isNull(Value v) {", "originalCommit": "71b5964ecf232e018207af5caf69767ad3d11fa8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU2MTQwNw==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508561407", "bodyText": "javadoc", "author": "AMashenkov", "createdAt": "2020-10-20T14:33:06Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/ColumnStatisticsCollector.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import java.math.BigInteger;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Comparator;\n+import java.util.List;\n+\n+import org.apache.ignite.internal.processors.query.stat.hll.HLL;\n+import org.gridgain.internal.h2.table.Column;\n+import org.gridgain.internal.h2.value.Value;\n+\n+/**\n+ * Collector to compute statistic by single column.\n+ */\n+public class ColumnStatisticsCollector {\n+\n+    /** */\n+    private final Column col;\n+\n+    /** Hyper Log Log structure */\n+    private final HLL hll = buildHll();\n+\n+    /** Minimum value. */\n+    private Value min = null;\n+\n+    /** Maximum value. */\n+    private Value max = null;\n+\n+    /** Total vals in column. */\n+    private long total = 0;\n+\n+    /** Total size of all non nulls values (in bytes).*/\n+    private long size = 0;\n+\n+    /** Temporary byte buffer just to avoid unnecessary object creation. */\n+    private ByteBuffer bb;\n+\n+    /** Column value comparator. */\n+    private final Comparator<Value> comp;\n+\n+    /** Null values counter. */\n+    private long nullsCnt;\n+\n+    /** Hasher. */\n+    private final Hasher hash = new Hasher();\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param col column to collect statistics by.\n+     * @param comp column values comparator.\n+     */\n+    public ColumnStatisticsCollector(Column col, Comparator<Value> comp) {\n+        this.col = col;\n+        this.comp = comp;\n+    }\n+\n+    /**\n+     * Try to fix unexpected behaviour of base Value class.\n+     *\n+     * @param value value to convert\n+     * @return byte array\n+     */\n+    private byte[] getBytes(Value value) {\n+        switch (value.getValueType()) {\n+            case Value.STRING:\n+                String strValue = value.getString();\n+                return strValue.getBytes(StandardCharsets.UTF_8);\n+            case Value.BOOLEAN:\n+                return value.getBoolean() ? new byte[]{1} : new byte[]{0};\n+            case Value.DECIMAL:\n+            case Value.DOUBLE:\n+            case Value.FLOAT:\n+                return value.getBigDecimal().unscaledValue().toByteArray();\n+            case Value.TIME:\n+                return BigInteger.valueOf(value.getTime().getTime()).toByteArray();\n+            case Value.DATE:\n+                return BigInteger.valueOf(value.getDate().getTime()).toByteArray();\n+            case Value.TIMESTAMP:\n+                return BigInteger.valueOf(value.getTimestamp().getTime()).toByteArray();\n+            default:\n+                return value.getBytes();\n+        }\n+    }\n+\n+    public void add(Value val) {\n+        total++;\n+\n+        if (isNull(val)) {\n+            nullsCnt++;\n+\n+            return;\n+        }\n+\n+        byte bytes[] = getBytes(val);\n+        size += bytes.length;\n+\n+        hll.addRaw(hash.fastHash(bytes));\n+\n+        if (null == min || comp.compare(val, min) < 0)\n+            min = val;\n+\n+        if (null == max || comp.compare(val, max) > 0)\n+            max = val;\n+    }\n+\n+    private boolean isNull(Value v) {\n+        return v == null || v.getType().getValueType() == Value.NULL;\n+    }\n+\n+    /**\n+     * Get total column statistics.\n+     *\n+     * @return aggregated column statistics.\n+     */\n+    public ColumnStatistics finish() {\n+        int nulls = nullsPercent(nullsCnt, total);\n+\n+        int cardinality = cardinalityPercent(nullsCnt, total, hll.cardinality());\n+\n+        int averageSize = averageSize(size, total, nullsCnt);\n+\n+        return new ColumnStatistics(min, max, nulls, cardinality, total, averageSize, hll.toBytes());\n+    }\n+\n+    private static int nullsPercent(long nullsCnt, long totalRows) {", "originalCommit": "71b5964ecf232e018207af5caf69767ad3d11fa8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU2MTUwMw==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508561503", "bodyText": "javadoc", "author": "AMashenkov", "createdAt": "2020-10-20T14:33:13Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/ColumnStatisticsCollector.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import java.math.BigInteger;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Comparator;\n+import java.util.List;\n+\n+import org.apache.ignite.internal.processors.query.stat.hll.HLL;\n+import org.gridgain.internal.h2.table.Column;\n+import org.gridgain.internal.h2.value.Value;\n+\n+/**\n+ * Collector to compute statistic by single column.\n+ */\n+public class ColumnStatisticsCollector {\n+\n+    /** */\n+    private final Column col;\n+\n+    /** Hyper Log Log structure */\n+    private final HLL hll = buildHll();\n+\n+    /** Minimum value. */\n+    private Value min = null;\n+\n+    /** Maximum value. */\n+    private Value max = null;\n+\n+    /** Total vals in column. */\n+    private long total = 0;\n+\n+    /** Total size of all non nulls values (in bytes).*/\n+    private long size = 0;\n+\n+    /** Temporary byte buffer just to avoid unnecessary object creation. */\n+    private ByteBuffer bb;\n+\n+    /** Column value comparator. */\n+    private final Comparator<Value> comp;\n+\n+    /** Null values counter. */\n+    private long nullsCnt;\n+\n+    /** Hasher. */\n+    private final Hasher hash = new Hasher();\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param col column to collect statistics by.\n+     * @param comp column values comparator.\n+     */\n+    public ColumnStatisticsCollector(Column col, Comparator<Value> comp) {\n+        this.col = col;\n+        this.comp = comp;\n+    }\n+\n+    /**\n+     * Try to fix unexpected behaviour of base Value class.\n+     *\n+     * @param value value to convert\n+     * @return byte array\n+     */\n+    private byte[] getBytes(Value value) {\n+        switch (value.getValueType()) {\n+            case Value.STRING:\n+                String strValue = value.getString();\n+                return strValue.getBytes(StandardCharsets.UTF_8);\n+            case Value.BOOLEAN:\n+                return value.getBoolean() ? new byte[]{1} : new byte[]{0};\n+            case Value.DECIMAL:\n+            case Value.DOUBLE:\n+            case Value.FLOAT:\n+                return value.getBigDecimal().unscaledValue().toByteArray();\n+            case Value.TIME:\n+                return BigInteger.valueOf(value.getTime().getTime()).toByteArray();\n+            case Value.DATE:\n+                return BigInteger.valueOf(value.getDate().getTime()).toByteArray();\n+            case Value.TIMESTAMP:\n+                return BigInteger.valueOf(value.getTimestamp().getTime()).toByteArray();\n+            default:\n+                return value.getBytes();\n+        }\n+    }\n+\n+    public void add(Value val) {\n+        total++;\n+\n+        if (isNull(val)) {\n+            nullsCnt++;\n+\n+            return;\n+        }\n+\n+        byte bytes[] = getBytes(val);\n+        size += bytes.length;\n+\n+        hll.addRaw(hash.fastHash(bytes));\n+\n+        if (null == min || comp.compare(val, min) < 0)\n+            min = val;\n+\n+        if (null == max || comp.compare(val, max) > 0)\n+            max = val;\n+    }\n+\n+    private boolean isNull(Value v) {\n+        return v == null || v.getType().getValueType() == Value.NULL;\n+    }\n+\n+    /**\n+     * Get total column statistics.\n+     *\n+     * @return aggregated column statistics.\n+     */\n+    public ColumnStatistics finish() {\n+        int nulls = nullsPercent(nullsCnt, total);\n+\n+        int cardinality = cardinalityPercent(nullsCnt, total, hll.cardinality());\n+\n+        int averageSize = averageSize(size, total, nullsCnt);\n+\n+        return new ColumnStatistics(min, max, nulls, cardinality, total, averageSize, hll.toBytes());\n+    }\n+\n+    private static int nullsPercent(long nullsCnt, long totalRows) {\n+        if (totalRows > 0)\n+            return (int)(100 * nullsCnt / totalRows);\n+        return 0;\n+    }\n+\n+    private static int cardinalityPercent(long nullsCnt, long totalRows, long cardinality) {", "originalCommit": "71b5964ecf232e018207af5caf69767ad3d11fa8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU3MTE3Mw==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508571173", "bodyText": "Javadoc", "author": "AMashenkov", "createdAt": "2020-10-20T14:44:34Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/IgniteStatisticsManagerImpl.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.ignite.IgniteAuthenticationException;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.processors.cache.distributed.dht.topology.GridDhtLocalPartition;\n+import org.apache.ignite.internal.processors.cache.persistence.CacheDataRow;\n+import org.apache.ignite.internal.processors.cache.query.QueryTable;\n+import org.apache.ignite.internal.processors.query.GridQueryTypeDescriptor;\n+import org.apache.ignite.internal.processors.query.IgniteStatisticsRepositoryImpl;\n+import org.apache.ignite.internal.processors.query.h2.SchemaManager;\n+import org.apache.ignite.internal.processors.query.h2.opt.GridH2RowDescriptor;\n+import org.apache.ignite.internal.processors.query.h2.opt.GridH2Table;\n+import org.apache.ignite.internal.processors.query.h2.opt.H2Row;\n+import org.gridgain.internal.h2.table.Column;\n+\n+import static org.apache.ignite.internal.processors.cache.distributed.dht.topology.GridDhtPartitionState.MOVING;\n+import static org.apache.ignite.internal.processors.cache.distributed.dht.topology.GridDhtPartitionState.OWNING;\n+\n+public class IgniteStatisticsManagerImpl implements IgniteStatisticsManager {", "originalCommit": "71b5964ecf232e018207af5caf69767ad3d11fa8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU3NzQ2Mg==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508577462", "bodyText": "Will be more effective to use a Set here instead of array iteration?", "author": "AMashenkov", "createdAt": "2020-10-20T14:51:44Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/IgniteStatisticsManagerImpl.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.ignite.IgniteAuthenticationException;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.processors.cache.distributed.dht.topology.GridDhtLocalPartition;\n+import org.apache.ignite.internal.processors.cache.persistence.CacheDataRow;\n+import org.apache.ignite.internal.processors.cache.query.QueryTable;\n+import org.apache.ignite.internal.processors.query.GridQueryTypeDescriptor;\n+import org.apache.ignite.internal.processors.query.IgniteStatisticsRepositoryImpl;\n+import org.apache.ignite.internal.processors.query.h2.SchemaManager;\n+import org.apache.ignite.internal.processors.query.h2.opt.GridH2RowDescriptor;\n+import org.apache.ignite.internal.processors.query.h2.opt.GridH2Table;\n+import org.apache.ignite.internal.processors.query.h2.opt.H2Row;\n+import org.gridgain.internal.h2.table.Column;\n+\n+import static org.apache.ignite.internal.processors.cache.distributed.dht.topology.GridDhtPartitionState.MOVING;\n+import static org.apache.ignite.internal.processors.cache.distributed.dht.topology.GridDhtPartitionState.OWNING;\n+\n+public class IgniteStatisticsManagerImpl implements IgniteStatisticsManager {\n+\n+    /** Logger. */\n+    private IgniteLogger log;\n+\n+    private final GridKernalContext ctx;\n+\n+    private final SchemaManager schemaMgr;\n+\n+    private final IgniteStatisticsRepository statsRepos;\n+\n+    public IgniteStatisticsManagerImpl(GridKernalContext ctx, SchemaManager schemaMgr) {\n+        this.ctx = ctx;\n+        this.schemaMgr = schemaMgr;\n+\n+        log = ctx.log(IgniteStatisticsManagerImpl.class);\n+        statsRepos = new IgniteStatisticsRepositoryImpl(ctx);\n+    }\n+\n+    public IgniteStatisticsRepository statisticsRepository() {\n+        return statsRepos;\n+    }\n+\n+    @Override public ObjectStatistics getLocalStatistics(String schemaName, String objName) {\n+        return statsRepos.getLocalStatistics(new StatsKey(schemaName, objName));\n+    }\n+\n+    @Override public void clearObjectStatistics(String schemaName, String objName, String... colNames) {\n+        StatsKey key = new StatsKey(schemaName, objName);\n+        statsRepos.clearLocalPartitionsStatistics(key, colNames);\n+        statsRepos.clearLocalStatistics(key, colNames);\n+        statsRepos.clearGlobalStatistics(key, colNames);\n+    }\n+\n+    /**\n+     * Filter columns by specified names.\n+     *\n+     * @param columns columns to filter.\n+     * @param colNames names.\n+     * @return column with specified names.\n+     */\n+    private Column[] filterColumns(Column[] columns, String... colNames) {\n+        if (colNames == null || colNames.length == 0) {\n+            return columns;\n+        }\n+        List<Column> resultList = new ArrayList<>(colNames.length);\n+\n+        for (String colName : colNames)\n+            for (Column col : columns)", "originalCommit": "71b5964ecf232e018207af5caf69767ad3d11fa8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU4Mjc2OQ==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508582769", "bodyText": "Do we really want to gather statictics on partially moved partition?\nActually, primary can't be in moving state.\nDiscovery component gives you latest observed topology in grid, but assignment can be NOT ready yet.\nI'd think you can get lastTopologyReady version from exchange(), not discovery().", "author": "AMashenkov", "createdAt": "2020-10-20T14:57:49Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/IgniteStatisticsManagerImpl.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.ignite.IgniteAuthenticationException;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.processors.cache.distributed.dht.topology.GridDhtLocalPartition;\n+import org.apache.ignite.internal.processors.cache.persistence.CacheDataRow;\n+import org.apache.ignite.internal.processors.cache.query.QueryTable;\n+import org.apache.ignite.internal.processors.query.GridQueryTypeDescriptor;\n+import org.apache.ignite.internal.processors.query.IgniteStatisticsRepositoryImpl;\n+import org.apache.ignite.internal.processors.query.h2.SchemaManager;\n+import org.apache.ignite.internal.processors.query.h2.opt.GridH2RowDescriptor;\n+import org.apache.ignite.internal.processors.query.h2.opt.GridH2Table;\n+import org.apache.ignite.internal.processors.query.h2.opt.H2Row;\n+import org.gridgain.internal.h2.table.Column;\n+\n+import static org.apache.ignite.internal.processors.cache.distributed.dht.topology.GridDhtPartitionState.MOVING;\n+import static org.apache.ignite.internal.processors.cache.distributed.dht.topology.GridDhtPartitionState.OWNING;\n+\n+public class IgniteStatisticsManagerImpl implements IgniteStatisticsManager {\n+\n+    /** Logger. */\n+    private IgniteLogger log;\n+\n+    private final GridKernalContext ctx;\n+\n+    private final SchemaManager schemaMgr;\n+\n+    private final IgniteStatisticsRepository statsRepos;\n+\n+    public IgniteStatisticsManagerImpl(GridKernalContext ctx, SchemaManager schemaMgr) {\n+        this.ctx = ctx;\n+        this.schemaMgr = schemaMgr;\n+\n+        log = ctx.log(IgniteStatisticsManagerImpl.class);\n+        statsRepos = new IgniteStatisticsRepositoryImpl(ctx);\n+    }\n+\n+    public IgniteStatisticsRepository statisticsRepository() {\n+        return statsRepos;\n+    }\n+\n+    @Override public ObjectStatistics getLocalStatistics(String schemaName, String objName) {\n+        return statsRepos.getLocalStatistics(new StatsKey(schemaName, objName));\n+    }\n+\n+    @Override public void clearObjectStatistics(String schemaName, String objName, String... colNames) {\n+        StatsKey key = new StatsKey(schemaName, objName);\n+        statsRepos.clearLocalPartitionsStatistics(key, colNames);\n+        statsRepos.clearLocalStatistics(key, colNames);\n+        statsRepos.clearGlobalStatistics(key, colNames);\n+    }\n+\n+    /**\n+     * Filter columns by specified names.\n+     *\n+     * @param columns columns to filter.\n+     * @param colNames names.\n+     * @return column with specified names.\n+     */\n+    private Column[] filterColumns(Column[] columns, String... colNames) {\n+        if (colNames == null || colNames.length == 0) {\n+            return columns;\n+        }\n+        List<Column> resultList = new ArrayList<>(colNames.length);\n+\n+        for (String colName : colNames)\n+            for (Column col : columns)\n+\n+                if (colName.equals(col.getName())) {\n+                    resultList.add(col);\n+                    break;\n+                }\n+\n+        return resultList.toArray(new Column[resultList.size()]);\n+    }\n+\n+    @Override public void collectObjectStatistics(String schemaName, String objName, String... colNames)\n+            throws IgniteCheckedException {\n+        GridH2Table tbl = schemaMgr.dataTable(schemaName, objName);\n+        if (tbl == null)\n+            throw new IgniteAuthenticationException(String.format(\"Can't find table %s.%s\", schemaName, objName));\n+\n+        if (log.isDebugEnabled())\n+            log.debug(String.format(\"Starting statistics collection by %s.%s object\", schemaName, objName));\n+\n+        Column[] selectedColumns;\n+        boolean fullStat;\n+        if (colNames == null || colNames.length == 0) {\n+            fullStat = true;\n+            selectedColumns = tbl.getColumns();\n+        } else {\n+            fullStat = false;\n+            selectedColumns = filterColumns(tbl.getColumns(), colNames);\n+        }\n+\n+        Collection<ObjectPartitionStatisticsImpl> partsStats = collectPartitionStatistics(tbl, selectedColumns);\n+        StatsKey key = new StatsKey(tbl.identifier().schema(), tbl.identifier().table());\n+        statsRepos.saveLocalPartitionsStatistics(key, partsStats, fullStat);\n+\n+        ObjectStatisticsImpl tblStats = aggregateLocalStatistics(tbl, selectedColumns, partsStats);\n+        statsRepos.saveLocalStatistics(key, tblStats, fullStat);\n+        if (log.isDebugEnabled())\n+            log.debug(String.format(\"Statistics collection by %s.%s object is finished.\", schemaName, objName));\n+    }\n+\n+    private Collection<ObjectPartitionStatisticsImpl> collectPartitionStatistics(GridH2Table tbl, Column[] selectedColumns)\n+            throws IgniteCheckedException {\n+        List<ObjectPartitionStatisticsImpl> tblPartStats = new ArrayList<>();\n+        GridH2RowDescriptor desc = tbl.rowDescriptor();\n+        String tblName = tbl.getName();\n+\n+        for (GridDhtLocalPartition locPart : tbl.cacheContext().topology().localPartitions()) {\n+            final boolean reserved = locPart.reserve();\n+\n+            try {\n+                if (!reserved || (locPart.state() != OWNING && locPart.state() != MOVING)\n+                        || !locPart.primary(ctx.discovery().topologyVersionEx()))", "originalCommit": "71b5964ecf232e018207af5caf69767ad3d11fa8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6e542dba4c81179ed1a8fab253f3a1fb85c02eb1", "url": "https://github.com/gridgain/gridgain/commit/6e542dba4c81179ed1a8fab253f3a1fb85c02eb1", "message": "GG-18652: Merge remote-tracking branch 'gridgain-ce/master' into gg-18652", "committedDate": "2020-10-20T15:56:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY4MTg0NA==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508681844", "bodyText": "it would be better to split this on two methods: save that would just save new stats and replace old ones in case of overlapping; and merge that would merge all stats.\nThe same suggestion for the rest of save* methods", "author": "korlov42", "createdAt": "2020-10-20T16:43:44Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/IgniteStatisticsRepositoryImpl.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query;\n+\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheUtils;\n+import org.apache.ignite.internal.processors.query.stat.ColumnStatistics;\n+import org.apache.ignite.internal.processors.query.stat.IgniteStatisticsManagerImpl;\n+import org.apache.ignite.internal.processors.query.stat.IgniteStatisticsRepository;\n+import org.apache.ignite.internal.processors.query.stat.ObjectPartitionStatisticsImpl;\n+import org.apache.ignite.internal.processors.query.stat.ObjectStatisticsImpl;\n+import org.apache.ignite.internal.processors.query.stat.StatsKey;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Statistics repository implementation.\n+ */\n+public class IgniteStatisticsRepositoryImpl implements IgniteStatisticsRepository {\n+    /** Logger. */\n+    private IgniteLogger log;\n+\n+    /** */\n+    private final GridKernalContext ctx;\n+\n+    /** Table->Partition->Partition Statistics map, populated only on server nodes without persistence enabled.  */\n+    private final Map<StatsKey, Map<Integer, ObjectPartitionStatisticsImpl>> partsStats;\n+\n+    /** Local (for current node) object statistics. */\n+    private final Map<StatsKey, ObjectStatisticsImpl> localStats;\n+\n+    /** Global (for whole cluster) object statistics. */\n+    private final Map<StatsKey, ObjectStatisticsImpl> globalStats = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Constructor.\n+     */\n+    public IgniteStatisticsRepositoryImpl(GridKernalContext ctx) {\n+        this.ctx = ctx;\n+\n+        if (ctx.config().isClientMode() || ctx.isDaemon()) {\n+            // Cache only global statistics, no store\n+            partsStats = null;\n+            localStats = null;\n+        } else {\n+            if (GridCacheUtils.isPersistenceEnabled(ctx.config())) {\n+                // Persistence store\n+                partsStats = null;\n+            } else {\n+                // Cache partitions statistics, no store\n+                partsStats = new ConcurrentHashMap<>();\n+            }\n+            localStats = new ConcurrentHashMap<>();\n+        }\n+        log = ctx.log(IgniteStatisticsRepositoryImpl.class);\n+    }\n+\n+    @Override public void saveLocalPartitionsStatistics(StatsKey key,", "originalCommit": "6e542dba4c81179ed1a8fab253f3a1fb85c02eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc1NjQzNQ==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508756435", "bodyText": "IgniteAuthenticationException seems inappropriate", "author": "korlov42", "createdAt": "2020-10-20T18:41:27Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/IgniteStatisticsManagerImpl.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.ignite.IgniteAuthenticationException;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.processors.cache.distributed.dht.topology.GridDhtLocalPartition;\n+import org.apache.ignite.internal.processors.cache.persistence.CacheDataRow;\n+import org.apache.ignite.internal.processors.cache.query.QueryTable;\n+import org.apache.ignite.internal.processors.query.GridQueryTypeDescriptor;\n+import org.apache.ignite.internal.processors.query.IgniteStatisticsRepositoryImpl;\n+import org.apache.ignite.internal.processors.query.h2.SchemaManager;\n+import org.apache.ignite.internal.processors.query.h2.opt.GridH2RowDescriptor;\n+import org.apache.ignite.internal.processors.query.h2.opt.GridH2Table;\n+import org.apache.ignite.internal.processors.query.h2.opt.H2Row;\n+import org.gridgain.internal.h2.table.Column;\n+\n+import static org.apache.ignite.internal.processors.cache.distributed.dht.topology.GridDhtPartitionState.MOVING;\n+import static org.apache.ignite.internal.processors.cache.distributed.dht.topology.GridDhtPartitionState.OWNING;\n+\n+public class IgniteStatisticsManagerImpl implements IgniteStatisticsManager {\n+\n+    /** Logger. */\n+    private IgniteLogger log;\n+\n+    private final GridKernalContext ctx;\n+\n+    private final SchemaManager schemaMgr;\n+\n+    private final IgniteStatisticsRepository statsRepos;\n+\n+    public IgniteStatisticsManagerImpl(GridKernalContext ctx, SchemaManager schemaMgr) {\n+        this.ctx = ctx;\n+        this.schemaMgr = schemaMgr;\n+\n+        log = ctx.log(IgniteStatisticsManagerImpl.class);\n+        statsRepos = new IgniteStatisticsRepositoryImpl(ctx);\n+    }\n+\n+    public IgniteStatisticsRepository statisticsRepository() {\n+        return statsRepos;\n+    }\n+\n+    @Override public ObjectStatistics getLocalStatistics(String schemaName, String objName) {\n+        return statsRepos.getLocalStatistics(new StatsKey(schemaName, objName));\n+    }\n+\n+    @Override public void clearObjectStatistics(String schemaName, String objName, String... colNames) {\n+        StatsKey key = new StatsKey(schemaName, objName);\n+        statsRepos.clearLocalPartitionsStatistics(key, colNames);\n+        statsRepos.clearLocalStatistics(key, colNames);\n+        statsRepos.clearGlobalStatistics(key, colNames);\n+    }\n+\n+    /**\n+     * Filter columns by specified names.\n+     *\n+     * @param columns columns to filter.\n+     * @param colNames names.\n+     * @return column with specified names.\n+     */\n+    private Column[] filterColumns(Column[] columns, String... colNames) {\n+        if (colNames == null || colNames.length == 0) {\n+            return columns;\n+        }\n+        List<Column> resultList = new ArrayList<>(colNames.length);\n+\n+        for (String colName : colNames)\n+            for (Column col : columns)\n+\n+                if (colName.equals(col.getName())) {\n+                    resultList.add(col);\n+                    break;\n+                }\n+\n+        return resultList.toArray(new Column[resultList.size()]);\n+    }\n+\n+    @Override public void collectObjectStatistics(String schemaName, String objName, String... colNames)\n+            throws IgniteCheckedException {\n+        GridH2Table tbl = schemaMgr.dataTable(schemaName, objName);\n+        if (tbl == null)\n+            throw new IgniteAuthenticationException(String.format(\"Can't find table %s.%s\", schemaName, objName));", "originalCommit": "6e542dba4c81179ed1a8fab253f3a1fb85c02eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyMjk5MA==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508822990", "bodyText": "Why did it have a suffix \"_Last\"?", "author": "korlov42", "createdAt": "2020-10-20T20:36:53Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/opt/H2IndexCostedBase.java", "diffHunk": "@@ -92,18 +117,27 @@ protected H2IndexCostedBase(GridH2Table tbl, String name, IndexColumn[] cols, In\n     /**\n      * Re-implement {@link BaseIndex#getCostRangeIndex} to dispatch cost function on new and old versions.\n      */\n-    protected long costRangeIndex(int[] masks, long rowCount,\n-        TableFilter[] filters, int filter, SortOrder sortOrder,\n-        boolean isScanIndex, AllColumnsForPlan allColumnsSet) {\n-        return constFunc.getCostRangeIndex(masks, rowCount, filters, filter, sortOrder, isScanIndex, allColumnsSet);\n+    protected long costRangeIndex(Session ses, int[] masks, long rowCount,\n+                                  TableFilter[] filters, int filter, SortOrder sortOrder,\n+                                  boolean isScanIndex, AllColumnsForPlan allColumnsSet) {\n+        return constFunc.getCostRangeIndex(ses, masks, rowCount, filters, filter, sortOrder, isScanIndex, allColumnsSet);\n     }\n \n     /**\n      * Re-implement {@link BaseIndex#getCostRangeIndex} to support  compatibility with old version.\n      */\n-    private long getCostRangeIndex_Last(int[] masks, long rowCount,\n-        TableFilter[] filters, int filter, SortOrder sortOrder,\n-        boolean isScanIndex, AllColumnsForPlan allColumnsSet) {\n+    private long getCostRangeIndex_Last(Session ses, int[] masks, long rowCount,\n+                                        TableFilter[] filters, int filter, SortOrder sortOrder,\n+                                        boolean isScanIndex, AllColumnsForPlan allColumnsSet) {\n+        return cfl.getCostRangeIndex_Last(ses, masks, rowCount, filters, filter, sortOrder, isScanIndex, allColumnsSet);", "originalCommit": "6e542dba4c81179ed1a8fab253f3a1fb85c02eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyMzg4MQ==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508823881", "bodyText": "Why did you use suffix '_Last' everywhere?", "author": "korlov42", "createdAt": "2020-10-20T20:38:32Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/opt/H2IndexCostedBase.java", "diffHunk": "@@ -641,22 +664,558 @@ else if (needsToReadFromScanIndex)\n          * Cost function.\n          * See more: {@link BaseIndex#getCostRangeIndex}.\n          */\n-        long getCostRangeIndex(int[] masks, long rowCount,\n-            TableFilter[] filters, int filter, SortOrder sortOrder,\n-            boolean isScanIndex, AllColumnsForPlan allColumnsSet);\n+        long getCostRangeIndex(Session ses, int[] masks, long rowCount,\n+                               TableFilter[] filters, int filter, SortOrder sortOrder,\n+                               boolean isScanIndex, AllColumnsForPlan allColumnsSet);\n     }\n \n     /**\n      *\n      */\n     private enum CostFunctionType {\n-        /** Last. */\n+        /**\n+         * Last.\n+         */\n         LAST,\n \n-        /** Compatible with ver. 8.7.12. */\n+        /**\n+         * Compatible with ver. 8.7.28\n+         */\n+        COMPATIBLE_8_7_28,\n+\n+        /**\n+         * Compatible with ver. 8.7.12.\n+         */\n         COMPATIBLE_8_7_12,\n \n-        /** Compatible with ver. 8.7.6. */\n+        /**\n+         * Compatible with ver. 8.7.6.\n+         */\n         COMPATIBLE_8_7_6\n     }\n+\n+    private final class CostFunctionLast {\n+        /**\n+         * Math context to use in estimations calculations.\n+         */\n+        private final MathContext MATH_CONTEXT = MathContext.DECIMAL64;\n+\n+        /**\n+         * Selectivity for closed range queries, in percent\n+         */\n+        private final int RANGE_CLOSE_SELECTIVITY_LAST = 25;", "originalCommit": "6e542dba4c81179ed1a8fab253f3a1fb85c02eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyNzA1Mw==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508827053", "bodyText": "is it correct that for index (c1, c2, c3) and conditions like c1 > -inf AND c2 > -inf and c3 = 1, rowCost will be equal to 3?", "author": "korlov42", "createdAt": "2020-10-20T20:44:11Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/opt/H2IndexCostedBase.java", "diffHunk": "@@ -641,22 +664,558 @@ else if (needsToReadFromScanIndex)\n          * Cost function.\n          * See more: {@link BaseIndex#getCostRangeIndex}.\n          */\n-        long getCostRangeIndex(int[] masks, long rowCount,\n-            TableFilter[] filters, int filter, SortOrder sortOrder,\n-            boolean isScanIndex, AllColumnsForPlan allColumnsSet);\n+        long getCostRangeIndex(Session ses, int[] masks, long rowCount,\n+                               TableFilter[] filters, int filter, SortOrder sortOrder,\n+                               boolean isScanIndex, AllColumnsForPlan allColumnsSet);\n     }\n \n     /**\n      *\n      */\n     private enum CostFunctionType {\n-        /** Last. */\n+        /**\n+         * Last.\n+         */\n         LAST,\n \n-        /** Compatible with ver. 8.7.12. */\n+        /**\n+         * Compatible with ver. 8.7.28\n+         */\n+        COMPATIBLE_8_7_28,\n+\n+        /**\n+         * Compatible with ver. 8.7.12.\n+         */\n         COMPATIBLE_8_7_12,\n \n-        /** Compatible with ver. 8.7.6. */\n+        /**\n+         * Compatible with ver. 8.7.6.\n+         */\n         COMPATIBLE_8_7_6\n     }\n+\n+    private final class CostFunctionLast {\n+        /**\n+         * Math context to use in estimations calculations.\n+         */\n+        private final MathContext MATH_CONTEXT = MathContext.DECIMAL64;\n+\n+        /**\n+         * Selectivity for closed range queries, in percent\n+         */\n+        private final int RANGE_CLOSE_SELECTIVITY_LAST = 25;\n+\n+        /**\n+         * Selectivity for open range queries, in percent\n+         */\n+        private final int RANGE_OPEN_SELECTIVITY_LAST = 33;\n+\n+        private long getCostRangeIndexRowCost_Last(Session ses, TableFilter filter, int[] masks, long rowCount,\n+                                                   ObjectStatisticsImpl locTblStats) {\n+            int totalCardinality = 0;\n+\n+            long rowsCost = rowCount;\n+\n+            if (masks != null) {\n+                int i = 0, len = columns.length;\n+\n+                while (i < len) {\n+                    Column column = columns[i++];\n+                    ColumnStatistics colStats = getColumnStatistics(locTblStats, column);\n+\n+                    int index = column.getColumnId();\n+                    int mask = masks[index];\n+\n+                    if (isByteFlag(mask, IndexCondition.EQUALITY)) {\n+                        if (i == len && getIndexType().isUnique()) {\n+                            rowsCost = 3;", "originalCommit": "6e542dba4c81179ed1a8fab253f3a1fb85c02eb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTMyNjU3NQ==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r521326575", "bodyText": "the problem still exists. Please consider the follow case: c1 is not null and c2 is not null and c3 = 1", "author": "korlov42", "createdAt": "2020-11-11T12:33:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyNzA1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgzNDk3Mw==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508834973", "bodyText": "why not just compare?", "author": "korlov42", "createdAt": "2020-10-20T20:58:17Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/opt/H2IndexCostedBase.java", "diffHunk": "@@ -641,22 +664,558 @@ else if (needsToReadFromScanIndex)\n          * Cost function.\n          * See more: {@link BaseIndex#getCostRangeIndex}.\n          */\n-        long getCostRangeIndex(int[] masks, long rowCount,\n-            TableFilter[] filters, int filter, SortOrder sortOrder,\n-            boolean isScanIndex, AllColumnsForPlan allColumnsSet);\n+        long getCostRangeIndex(Session ses, int[] masks, long rowCount,\n+                               TableFilter[] filters, int filter, SortOrder sortOrder,\n+                               boolean isScanIndex, AllColumnsForPlan allColumnsSet);\n     }\n \n     /**\n      *\n      */\n     private enum CostFunctionType {\n-        /** Last. */\n+        /**\n+         * Last.\n+         */\n         LAST,\n \n-        /** Compatible with ver. 8.7.12. */\n+        /**\n+         * Compatible with ver. 8.7.28\n+         */\n+        COMPATIBLE_8_7_28,\n+\n+        /**\n+         * Compatible with ver. 8.7.12.\n+         */\n         COMPATIBLE_8_7_12,\n \n-        /** Compatible with ver. 8.7.6. */\n+        /**\n+         * Compatible with ver. 8.7.6.\n+         */\n         COMPATIBLE_8_7_6\n     }\n+\n+    private final class CostFunctionLast {\n+        /**\n+         * Math context to use in estimations calculations.\n+         */\n+        private final MathContext MATH_CONTEXT = MathContext.DECIMAL64;\n+\n+        /**\n+         * Selectivity for closed range queries, in percent\n+         */\n+        private final int RANGE_CLOSE_SELECTIVITY_LAST = 25;\n+\n+        /**\n+         * Selectivity for open range queries, in percent\n+         */\n+        private final int RANGE_OPEN_SELECTIVITY_LAST = 33;\n+\n+        private long getCostRangeIndexRowCost_Last(Session ses, TableFilter filter, int[] masks, long rowCount,\n+                                                   ObjectStatisticsImpl locTblStats) {\n+            int totalCardinality = 0;\n+\n+            long rowsCost = rowCount;\n+\n+            if (masks != null) {\n+                int i = 0, len = columns.length;\n+\n+                while (i < len) {\n+                    Column column = columns[i++];\n+                    ColumnStatistics colStats = getColumnStatistics(locTblStats, column);\n+\n+                    int index = column.getColumnId();\n+                    int mask = masks[index];\n+\n+                    if (isByteFlag(mask, IndexCondition.EQUALITY)) {\n+                        if (i == len && getIndexType().isUnique()) {\n+                            rowsCost = 3;\n+\n+                            break;\n+                        }\n+                        // Estimate by is null\n+\n+                        Value equalValue = getEqualValue(ses, column, filter);\n+                        Boolean equalNull = (equalValue == null) ? null : equalValue.getValueType() == Value.NULL;\n+                        rowCount = getColumnSize(colStats, rowCount, equalNull);\n+\n+                        if (colStats != null && equalNull == Boolean.TRUE) {\n+                            rowsCost = Math.min(5 + Math.max(rowsCost * colStats.nulls() / 100, 1), rowsCost - (i > 0 ? 1 : 0));\n+                            continue;\n+                        }\n+                        if (colStats != null && equalNull == Boolean.FALSE)\n+                            rowsCost = rowsCost * (100 - colStats.nulls()) / 100;\n+\n+                        int cardinality = getColumnCardinality(colStats, column);\n+\n+                        totalCardinality = 100 - ((100 - totalCardinality) * (100 - cardinality) / 100);\n+\n+                        long distinctRows = Math.round((double) rowCount * totalCardinality / 100);\n+\n+                        if (distinctRows <= 0)\n+                            distinctRows = 1;\n+\n+                        if (colStats != null && equalNull != null)\n+                            distinctRows = distinctRows * 100 / (100 - colStats.nulls());\n+\n+                        rowsCost = Math.min(5 + Math.max(rowsCost / distinctRows, 1), rowsCost - (i > 0 ? 1 : 0));\n+                    } else if (isByteFlag(mask, IndexCondition.RANGE)) {\n+                        Value min = getStartValue(ses, column, filter);\n+                        Value max = getEndValue(ses, column, filter);\n+                        int percent = estimatePercent(colStats, min, max);\n+\n+                        rowsCost = Math.min(5 + rowsCost * percent / 100, rowsCost - (i > 0 ? 1 : 0));\n+\n+                        break;\n+                    } else if (isByteFlag(mask, IndexCondition.START)) {\n+                        Value min = getStartValue(ses, column, filter);\n+                        Value max = getEndValue(ses, column, filter);\n+                        int percent = estimatePercent(colStats, min, max);\n+\n+                        rowsCost = Math.min(5 + rowsCost * percent / 100, rowsCost - (i > 0 ? 1 : 0));\n+\n+                        break;\n+                    } else if (isByteFlag(mask, IndexCondition.END)) {\n+                        Value min = getStartValue(ses, column, filter);\n+                        Value max = getEndValue(ses, column, filter);\n+                        int percent = estimatePercent(colStats, min, max);\n+\n+                        rowsCost = Math.min(5 + rowsCost * percent / 100, rowsCost - (i > 0 ? 1 : 0));\n+\n+                        break;\n+                    } else if (isNullFilter(ses, column, filter)) {\n+                        if (colStats != null)\n+                            rowsCost = Math.min(5 + Math.max(rowsCost * colStats.nulls() / 100, 1), rowsCost - (i > 0 ? 1 : 0));\n+                    } else if (isNotNullFilter(ses, column, filter)) {\n+                        if (colStats != null)\n+                            rowsCost = Math.min(5 + Math.max(rowsCost * (100 - colStats.nulls()) / 100, 1), rowsCost - (i > 0 ? 1 : 0));\n+                    } else\n+                        break;\n+                }\n+            }\n+            return rowsCost;\n+        }\n+\n+        /**\n+         * Try to get column cardinality from statistics, if there is no such - fall back to H2 column selectivity.\n+         *\n+         * @param colStats column statistics.\n+         * @param column   column.\n+         * @return column cardinality in percents.\n+         */\n+        private int getColumnCardinality(@Nullable ColumnStatistics colStats, Column column) {\n+            return (colStats == null) ? column.getSelectivity() : colStats.cardinality();\n+        }\n+\n+        /**\n+         * Get total number of values in column.\n+         *\n+         * @param colStats column statistics.\n+         * @param rowCount total row count in table.\n+         * @param nulls    if {@code true} - try to estimate only nulls count,\n+         *                 if @{code false} - try to estimate only non null count,\n+         *                 if {@code null} - try to estimate total count of values.\n+         * @return column value count.\n+         */\n+        private long getColumnSize(@Nullable ColumnStatistics colStats, long rowCount, Boolean nulls) {\n+            if (colStats == null)\n+                return rowCount;\n+            else if (nulls == null)\n+                return colStats.total();\n+            else if (nulls)\n+                return colStats.total() * colStats.nulls() / 100;\n+            else\n+                return colStats.total() * (100 - colStats.nulls()) / 100;\n+        }\n+\n+        private Value getEqualValue(Session ses, Column column, TableFilter filter) {\n+            Value maxValue = null;\n+            for (IndexCondition cond : filter.getIndexConditions()) {\n+                if (!column.equals(cond.getColumn()))\n+                    continue;\n+\n+                if (isByteFlag(cond.getCompareType(), Comparison.EQUAL) && cond.isEvaluatable()) {\n+\n+                    Expression expr = cond.getExpression();\n+                    if (expr != null && expr.isConstant()) {\n+                        Value curVal = cond.getCurrentValue(ses);\n+                        if (null == maxValue || (curVal != null || filter.getTable().compareValues(curVal, maxValue) < 0))\n+                            maxValue = curVal;\n+                    }\n+                }\n+            }\n+            return maxValue;\n+        }\n+\n+        private Value getStartValue(Session ses, Column column, TableFilter filter) {\n+            if (filter == null)\n+                return null;\n+            Value maxValue = null;\n+            for (IndexCondition cond : filter.getIndexConditions()) {\n+                if (!column.equals(cond.getColumn()))\n+                    continue;\n+\n+                if ((isByteFlag(cond.getCompareType(), Comparison.BIGGER)\n+                        || isByteFlag(cond.getCompareType(), Comparison.BIGGER_EQUAL))\n+                        && cond.isEvaluatable()) {\n+\n+                    Expression expr = cond.getExpression();\n+                    if (expr != null && expr.isConstant()) {\n+                        Value curVal = cond.getCurrentValue(ses);\n+                        if (null == maxValue || (curVal != null || filter.getTable().compareValues(curVal, maxValue) < 0))\n+                            maxValue = curVal;\n+                    }\n+                }\n+            }\n+            return maxValue;\n+        }\n+\n+        private Value getEndValue(Session ses, Column column, TableFilter filter) {\n+            if (filter == null)\n+                return null;\n+            Value minValue = null;\n+            for (IndexCondition cond : filter.getIndexConditions()) {\n+                if (!column.equals(cond.getColumn()))\n+                    continue;\n+\n+                if ((isByteFlag(cond.getCompareType(), Comparison.SMALLER)\n+                        || isByteFlag(cond.getCompareType(), Comparison.SMALLER_EQUAL))\n+                        && cond.isEvaluatable()) {\n+                    Expression expr = cond.getExpression();\n+                    if (expr != null && expr.isConstant()) {\n+                        Value curVal = cond.getCurrentValue(ses);\n+                        if (null == minValue || (curVal != null || filter.getTable().compareValues(minValue, curVal) < 0))\n+                            minValue = curVal;\n+                    }\n+                }\n+            }\n+            return minValue;\n+        }\n+\n+        /**\n+         * Check if specified filter compare specified column to not null.\n+         *\n+         * @param ses    session to resolv values\n+         * @param column column to check\n+         * @param filter filter\n+         * @return {@code true} if column value should be null, {@code falce} otherwise (or if it not sure)\n+         */\n+        private boolean isNotNullFilter(Session ses, Column column, TableFilter filter) {\n+            // TODO: check not null expression (TableFilter contains only fullCondition without getter to check it)\n+            return false;\n+        }\n+\n+        /**\n+         * Check if specified filter compare specified column to null.\n+         *\n+         * @param ses    session to resolv values\n+         * @param column column to check\n+         * @param filter filter\n+         * @return {@code true} if column value should be null, {@code falce} otherwise (or if it not sure)\n+         */\n+        private boolean isNullFilter(Session ses, Column column, TableFilter filter) {\n+            if (filter == null)\n+                return false;\n+            for (IndexCondition cond : filter.getIndexConditions()) {\n+                if (column.equals(cond.getColumn()))\n+                    continue;\n+\n+                if (isByteFlag(cond.getCompareType(), Comparison.SPATIAL_INTERSECTS) && cond.isEvaluatable()) {\n+                    Expression expr = cond.getExpression();\n+\n+                    if (expr != null && expr.isConstant()) {\n+                        Value curVal = cond.getCurrentValue(ses);\n+\n+                        if (curVal != null && curVal.getValueType() == Value.NULL)\n+                            return true;\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+\n+        /**\n+         * Test if value contains all masks bits.\n+         *\n+         * @param value value to test.\n+         * @param mask  mask to test by.\n+         * @return {@code true} if value contains all necessary bits, {@code false} otherwise.\n+         */\n+        private boolean isByteFlag(int value, int mask) {\n+            return (value & mask) == mask;\n+        }\n+\n+        /**\n+         * Estimate percent of selected rows by specified min/max conditions (of total rows, with nulls).\n+         *\n+         * @param colStat column statistics to use, if exists.\n+         * @param min     lower border.\n+         * @param max     higher border.\n+         * @return percent of rows, selected with specified conditions (0-100)\n+         */\n+        private int estimatePercent(ColumnStatistics colStat, Value min, Value max) {\n+            if (colStat == null || colStat.min() == null || colStat.max() == null)\n+                // Fall back to previous behaviour without statistics, even without min/max testing\n+                return estimatePercentFallback(min, max);\n+\n+            BigDecimal minValue = (min == null) ? null : getComparableValue(min);\n+            BigDecimal maxValue = (max == null) ? null : getComparableValue(max);\n+\n+            if (minValue == null && maxValue == null)\n+                return estimatePercentFallback(min, max);\n+\n+            BigDecimal minStat = getComparableValue(colStat.min());\n+            BigDecimal maxStat = getComparableValue(colStat.max());\n+\n+            if (minStat == null || maxStat == null)\n+                return estimatePercentFallback(min, max);\n+\n+            BigDecimal start = (minValue == null || minValue.compareTo(minStat) < 0) ? minStat : minValue;\n+            BigDecimal end = (maxValue == null || maxValue.compareTo(maxStat) > 0) ? maxStat : maxValue;\n+\n+            BigDecimal actual = end.subtract(start);", "originalCommit": "6e542dba4c81179ed1a8fab253f3a1fb85c02eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgzNjE1MA==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508836150", "bodyText": "could you please clarify what is happening here and till the end of the method", "author": "korlov42", "createdAt": "2020-10-20T21:00:22Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/opt/H2IndexCostedBase.java", "diffHunk": "@@ -641,22 +664,558 @@ else if (needsToReadFromScanIndex)\n          * Cost function.\n          * See more: {@link BaseIndex#getCostRangeIndex}.\n          */\n-        long getCostRangeIndex(int[] masks, long rowCount,\n-            TableFilter[] filters, int filter, SortOrder sortOrder,\n-            boolean isScanIndex, AllColumnsForPlan allColumnsSet);\n+        long getCostRangeIndex(Session ses, int[] masks, long rowCount,\n+                               TableFilter[] filters, int filter, SortOrder sortOrder,\n+                               boolean isScanIndex, AllColumnsForPlan allColumnsSet);\n     }\n \n     /**\n      *\n      */\n     private enum CostFunctionType {\n-        /** Last. */\n+        /**\n+         * Last.\n+         */\n         LAST,\n \n-        /** Compatible with ver. 8.7.12. */\n+        /**\n+         * Compatible with ver. 8.7.28\n+         */\n+        COMPATIBLE_8_7_28,\n+\n+        /**\n+         * Compatible with ver. 8.7.12.\n+         */\n         COMPATIBLE_8_7_12,\n \n-        /** Compatible with ver. 8.7.6. */\n+        /**\n+         * Compatible with ver. 8.7.6.\n+         */\n         COMPATIBLE_8_7_6\n     }\n+\n+    private final class CostFunctionLast {\n+        /**\n+         * Math context to use in estimations calculations.\n+         */\n+        private final MathContext MATH_CONTEXT = MathContext.DECIMAL64;\n+\n+        /**\n+         * Selectivity for closed range queries, in percent\n+         */\n+        private final int RANGE_CLOSE_SELECTIVITY_LAST = 25;\n+\n+        /**\n+         * Selectivity for open range queries, in percent\n+         */\n+        private final int RANGE_OPEN_SELECTIVITY_LAST = 33;\n+\n+        private long getCostRangeIndexRowCost_Last(Session ses, TableFilter filter, int[] masks, long rowCount,\n+                                                   ObjectStatisticsImpl locTblStats) {\n+            int totalCardinality = 0;\n+\n+            long rowsCost = rowCount;\n+\n+            if (masks != null) {\n+                int i = 0, len = columns.length;\n+\n+                while (i < len) {\n+                    Column column = columns[i++];\n+                    ColumnStatistics colStats = getColumnStatistics(locTblStats, column);\n+\n+                    int index = column.getColumnId();\n+                    int mask = masks[index];\n+\n+                    if (isByteFlag(mask, IndexCondition.EQUALITY)) {\n+                        if (i == len && getIndexType().isUnique()) {\n+                            rowsCost = 3;\n+\n+                            break;\n+                        }\n+                        // Estimate by is null\n+\n+                        Value equalValue = getEqualValue(ses, column, filter);\n+                        Boolean equalNull = (equalValue == null) ? null : equalValue.getValueType() == Value.NULL;\n+                        rowCount = getColumnSize(colStats, rowCount, equalNull);\n+\n+                        if (colStats != null && equalNull == Boolean.TRUE) {\n+                            rowsCost = Math.min(5 + Math.max(rowsCost * colStats.nulls() / 100, 1), rowsCost - (i > 0 ? 1 : 0));\n+                            continue;\n+                        }\n+                        if (colStats != null && equalNull == Boolean.FALSE)\n+                            rowsCost = rowsCost * (100 - colStats.nulls()) / 100;\n+\n+                        int cardinality = getColumnCardinality(colStats, column);\n+\n+                        totalCardinality = 100 - ((100 - totalCardinality) * (100 - cardinality) / 100);\n+\n+                        long distinctRows = Math.round((double) rowCount * totalCardinality / 100);\n+\n+                        if (distinctRows <= 0)\n+                            distinctRows = 1;\n+\n+                        if (colStats != null && equalNull != null)\n+                            distinctRows = distinctRows * 100 / (100 - colStats.nulls());\n+\n+                        rowsCost = Math.min(5 + Math.max(rowsCost / distinctRows, 1), rowsCost - (i > 0 ? 1 : 0));\n+                    } else if (isByteFlag(mask, IndexCondition.RANGE)) {\n+                        Value min = getStartValue(ses, column, filter);\n+                        Value max = getEndValue(ses, column, filter);\n+                        int percent = estimatePercent(colStats, min, max);\n+\n+                        rowsCost = Math.min(5 + rowsCost * percent / 100, rowsCost - (i > 0 ? 1 : 0));\n+\n+                        break;\n+                    } else if (isByteFlag(mask, IndexCondition.START)) {\n+                        Value min = getStartValue(ses, column, filter);\n+                        Value max = getEndValue(ses, column, filter);\n+                        int percent = estimatePercent(colStats, min, max);\n+\n+                        rowsCost = Math.min(5 + rowsCost * percent / 100, rowsCost - (i > 0 ? 1 : 0));\n+\n+                        break;\n+                    } else if (isByteFlag(mask, IndexCondition.END)) {\n+                        Value min = getStartValue(ses, column, filter);\n+                        Value max = getEndValue(ses, column, filter);\n+                        int percent = estimatePercent(colStats, min, max);\n+\n+                        rowsCost = Math.min(5 + rowsCost * percent / 100, rowsCost - (i > 0 ? 1 : 0));\n+\n+                        break;\n+                    } else if (isNullFilter(ses, column, filter)) {\n+                        if (colStats != null)\n+                            rowsCost = Math.min(5 + Math.max(rowsCost * colStats.nulls() / 100, 1), rowsCost - (i > 0 ? 1 : 0));\n+                    } else if (isNotNullFilter(ses, column, filter)) {\n+                        if (colStats != null)\n+                            rowsCost = Math.min(5 + Math.max(rowsCost * (100 - colStats.nulls()) / 100, 1), rowsCost - (i > 0 ? 1 : 0));\n+                    } else\n+                        break;\n+                }\n+            }\n+            return rowsCost;\n+        }\n+\n+        /**\n+         * Try to get column cardinality from statistics, if there is no such - fall back to H2 column selectivity.\n+         *\n+         * @param colStats column statistics.\n+         * @param column   column.\n+         * @return column cardinality in percents.\n+         */\n+        private int getColumnCardinality(@Nullable ColumnStatistics colStats, Column column) {\n+            return (colStats == null) ? column.getSelectivity() : colStats.cardinality();\n+        }\n+\n+        /**\n+         * Get total number of values in column.\n+         *\n+         * @param colStats column statistics.\n+         * @param rowCount total row count in table.\n+         * @param nulls    if {@code true} - try to estimate only nulls count,\n+         *                 if @{code false} - try to estimate only non null count,\n+         *                 if {@code null} - try to estimate total count of values.\n+         * @return column value count.\n+         */\n+        private long getColumnSize(@Nullable ColumnStatistics colStats, long rowCount, Boolean nulls) {\n+            if (colStats == null)\n+                return rowCount;\n+            else if (nulls == null)\n+                return colStats.total();\n+            else if (nulls)\n+                return colStats.total() * colStats.nulls() / 100;\n+            else\n+                return colStats.total() * (100 - colStats.nulls()) / 100;\n+        }\n+\n+        private Value getEqualValue(Session ses, Column column, TableFilter filter) {\n+            Value maxValue = null;\n+            for (IndexCondition cond : filter.getIndexConditions()) {\n+                if (!column.equals(cond.getColumn()))\n+                    continue;\n+\n+                if (isByteFlag(cond.getCompareType(), Comparison.EQUAL) && cond.isEvaluatable()) {\n+\n+                    Expression expr = cond.getExpression();\n+                    if (expr != null && expr.isConstant()) {\n+                        Value curVal = cond.getCurrentValue(ses);\n+                        if (null == maxValue || (curVal != null || filter.getTable().compareValues(curVal, maxValue) < 0))\n+                            maxValue = curVal;\n+                    }\n+                }\n+            }\n+            return maxValue;\n+        }\n+\n+        private Value getStartValue(Session ses, Column column, TableFilter filter) {\n+            if (filter == null)\n+                return null;\n+            Value maxValue = null;\n+            for (IndexCondition cond : filter.getIndexConditions()) {\n+                if (!column.equals(cond.getColumn()))\n+                    continue;\n+\n+                if ((isByteFlag(cond.getCompareType(), Comparison.BIGGER)\n+                        || isByteFlag(cond.getCompareType(), Comparison.BIGGER_EQUAL))\n+                        && cond.isEvaluatable()) {\n+\n+                    Expression expr = cond.getExpression();\n+                    if (expr != null && expr.isConstant()) {\n+                        Value curVal = cond.getCurrentValue(ses);\n+                        if (null == maxValue || (curVal != null || filter.getTable().compareValues(curVal, maxValue) < 0))\n+                            maxValue = curVal;\n+                    }\n+                }\n+            }\n+            return maxValue;\n+        }\n+\n+        private Value getEndValue(Session ses, Column column, TableFilter filter) {\n+            if (filter == null)\n+                return null;\n+            Value minValue = null;\n+            for (IndexCondition cond : filter.getIndexConditions()) {\n+                if (!column.equals(cond.getColumn()))\n+                    continue;\n+\n+                if ((isByteFlag(cond.getCompareType(), Comparison.SMALLER)\n+                        || isByteFlag(cond.getCompareType(), Comparison.SMALLER_EQUAL))\n+                        && cond.isEvaluatable()) {\n+                    Expression expr = cond.getExpression();\n+                    if (expr != null && expr.isConstant()) {\n+                        Value curVal = cond.getCurrentValue(ses);\n+                        if (null == minValue || (curVal != null || filter.getTable().compareValues(minValue, curVal) < 0))\n+                            minValue = curVal;\n+                    }\n+                }\n+            }\n+            return minValue;\n+        }\n+\n+        /**\n+         * Check if specified filter compare specified column to not null.\n+         *\n+         * @param ses    session to resolv values\n+         * @param column column to check\n+         * @param filter filter\n+         * @return {@code true} if column value should be null, {@code falce} otherwise (or if it not sure)\n+         */\n+        private boolean isNotNullFilter(Session ses, Column column, TableFilter filter) {\n+            // TODO: check not null expression (TableFilter contains only fullCondition without getter to check it)\n+            return false;\n+        }\n+\n+        /**\n+         * Check if specified filter compare specified column to null.\n+         *\n+         * @param ses    session to resolv values\n+         * @param column column to check\n+         * @param filter filter\n+         * @return {@code true} if column value should be null, {@code falce} otherwise (or if it not sure)\n+         */\n+        private boolean isNullFilter(Session ses, Column column, TableFilter filter) {\n+            if (filter == null)\n+                return false;\n+            for (IndexCondition cond : filter.getIndexConditions()) {\n+                if (column.equals(cond.getColumn()))\n+                    continue;\n+\n+                if (isByteFlag(cond.getCompareType(), Comparison.SPATIAL_INTERSECTS) && cond.isEvaluatable()) {\n+                    Expression expr = cond.getExpression();\n+\n+                    if (expr != null && expr.isConstant()) {\n+                        Value curVal = cond.getCurrentValue(ses);\n+\n+                        if (curVal != null && curVal.getValueType() == Value.NULL)\n+                            return true;\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+\n+        /**\n+         * Test if value contains all masks bits.\n+         *\n+         * @param value value to test.\n+         * @param mask  mask to test by.\n+         * @return {@code true} if value contains all necessary bits, {@code false} otherwise.\n+         */\n+        private boolean isByteFlag(int value, int mask) {\n+            return (value & mask) == mask;\n+        }\n+\n+        /**\n+         * Estimate percent of selected rows by specified min/max conditions (of total rows, with nulls).\n+         *\n+         * @param colStat column statistics to use, if exists.\n+         * @param min     lower border.\n+         * @param max     higher border.\n+         * @return percent of rows, selected with specified conditions (0-100)\n+         */\n+        private int estimatePercent(ColumnStatistics colStat, Value min, Value max) {\n+            if (colStat == null || colStat.min() == null || colStat.max() == null)\n+                // Fall back to previous behaviour without statistics, even without min/max testing\n+                return estimatePercentFallback(min, max);\n+\n+            BigDecimal minValue = (min == null) ? null : getComparableValue(min);\n+            BigDecimal maxValue = (max == null) ? null : getComparableValue(max);\n+\n+            if (minValue == null && maxValue == null)\n+                return estimatePercentFallback(min, max);\n+\n+            BigDecimal minStat = getComparableValue(colStat.min());\n+            BigDecimal maxStat = getComparableValue(colStat.max());\n+\n+            if (minStat == null || maxStat == null)\n+                return estimatePercentFallback(min, max);\n+\n+            BigDecimal start = (minValue == null || minValue.compareTo(minStat) < 0) ? minStat : minValue;\n+            BigDecimal end = (maxValue == null || maxValue.compareTo(maxStat) > 0) ? maxStat : maxValue;\n+\n+            BigDecimal actual = end.subtract(start);\n+\n+            if (actual.signum() < 0)\n+                return 0;\n+\n+            BigDecimal total = maxStat.subtract(minStat);\n+\n+            if (total.signum() < 0)\n+                return estimatePercentFallback(min, max);\n+\n+            if (total.signum() == 0)", "originalCommit": "6e542dba4c81179ed1a8fab253f3a1fb85c02eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgzNjUyMg==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508836522", "bodyText": "all nulls could be grouped together", "author": "korlov42", "createdAt": "2020-10-20T21:01:04Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/opt/H2IndexCostedBase.java", "diffHunk": "@@ -641,22 +664,558 @@ else if (needsToReadFromScanIndex)\n          * Cost function.\n          * See more: {@link BaseIndex#getCostRangeIndex}.\n          */\n-        long getCostRangeIndex(int[] masks, long rowCount,\n-            TableFilter[] filters, int filter, SortOrder sortOrder,\n-            boolean isScanIndex, AllColumnsForPlan allColumnsSet);\n+        long getCostRangeIndex(Session ses, int[] masks, long rowCount,\n+                               TableFilter[] filters, int filter, SortOrder sortOrder,\n+                               boolean isScanIndex, AllColumnsForPlan allColumnsSet);\n     }\n \n     /**\n      *\n      */\n     private enum CostFunctionType {\n-        /** Last. */\n+        /**\n+         * Last.\n+         */\n         LAST,\n \n-        /** Compatible with ver. 8.7.12. */\n+        /**\n+         * Compatible with ver. 8.7.28\n+         */\n+        COMPATIBLE_8_7_28,\n+\n+        /**\n+         * Compatible with ver. 8.7.12.\n+         */\n         COMPATIBLE_8_7_12,\n \n-        /** Compatible with ver. 8.7.6. */\n+        /**\n+         * Compatible with ver. 8.7.6.\n+         */\n         COMPATIBLE_8_7_6\n     }\n+\n+    private final class CostFunctionLast {\n+        /**\n+         * Math context to use in estimations calculations.\n+         */\n+        private final MathContext MATH_CONTEXT = MathContext.DECIMAL64;\n+\n+        /**\n+         * Selectivity for closed range queries, in percent\n+         */\n+        private final int RANGE_CLOSE_SELECTIVITY_LAST = 25;\n+\n+        /**\n+         * Selectivity for open range queries, in percent\n+         */\n+        private final int RANGE_OPEN_SELECTIVITY_LAST = 33;\n+\n+        private long getCostRangeIndexRowCost_Last(Session ses, TableFilter filter, int[] masks, long rowCount,\n+                                                   ObjectStatisticsImpl locTblStats) {\n+            int totalCardinality = 0;\n+\n+            long rowsCost = rowCount;\n+\n+            if (masks != null) {\n+                int i = 0, len = columns.length;\n+\n+                while (i < len) {\n+                    Column column = columns[i++];\n+                    ColumnStatistics colStats = getColumnStatistics(locTblStats, column);\n+\n+                    int index = column.getColumnId();\n+                    int mask = masks[index];\n+\n+                    if (isByteFlag(mask, IndexCondition.EQUALITY)) {\n+                        if (i == len && getIndexType().isUnique()) {\n+                            rowsCost = 3;\n+\n+                            break;\n+                        }\n+                        // Estimate by is null\n+\n+                        Value equalValue = getEqualValue(ses, column, filter);\n+                        Boolean equalNull = (equalValue == null) ? null : equalValue.getValueType() == Value.NULL;\n+                        rowCount = getColumnSize(colStats, rowCount, equalNull);\n+\n+                        if (colStats != null && equalNull == Boolean.TRUE) {\n+                            rowsCost = Math.min(5 + Math.max(rowsCost * colStats.nulls() / 100, 1), rowsCost - (i > 0 ? 1 : 0));\n+                            continue;\n+                        }\n+                        if (colStats != null && equalNull == Boolean.FALSE)\n+                            rowsCost = rowsCost * (100 - colStats.nulls()) / 100;\n+\n+                        int cardinality = getColumnCardinality(colStats, column);\n+\n+                        totalCardinality = 100 - ((100 - totalCardinality) * (100 - cardinality) / 100);\n+\n+                        long distinctRows = Math.round((double) rowCount * totalCardinality / 100);\n+\n+                        if (distinctRows <= 0)\n+                            distinctRows = 1;\n+\n+                        if (colStats != null && equalNull != null)\n+                            distinctRows = distinctRows * 100 / (100 - colStats.nulls());\n+\n+                        rowsCost = Math.min(5 + Math.max(rowsCost / distinctRows, 1), rowsCost - (i > 0 ? 1 : 0));\n+                    } else if (isByteFlag(mask, IndexCondition.RANGE)) {\n+                        Value min = getStartValue(ses, column, filter);\n+                        Value max = getEndValue(ses, column, filter);\n+                        int percent = estimatePercent(colStats, min, max);\n+\n+                        rowsCost = Math.min(5 + rowsCost * percent / 100, rowsCost - (i > 0 ? 1 : 0));\n+\n+                        break;\n+                    } else if (isByteFlag(mask, IndexCondition.START)) {\n+                        Value min = getStartValue(ses, column, filter);\n+                        Value max = getEndValue(ses, column, filter);\n+                        int percent = estimatePercent(colStats, min, max);\n+\n+                        rowsCost = Math.min(5 + rowsCost * percent / 100, rowsCost - (i > 0 ? 1 : 0));\n+\n+                        break;\n+                    } else if (isByteFlag(mask, IndexCondition.END)) {\n+                        Value min = getStartValue(ses, column, filter);\n+                        Value max = getEndValue(ses, column, filter);\n+                        int percent = estimatePercent(colStats, min, max);\n+\n+                        rowsCost = Math.min(5 + rowsCost * percent / 100, rowsCost - (i > 0 ? 1 : 0));\n+\n+                        break;\n+                    } else if (isNullFilter(ses, column, filter)) {\n+                        if (colStats != null)\n+                            rowsCost = Math.min(5 + Math.max(rowsCost * colStats.nulls() / 100, 1), rowsCost - (i > 0 ? 1 : 0));\n+                    } else if (isNotNullFilter(ses, column, filter)) {\n+                        if (colStats != null)\n+                            rowsCost = Math.min(5 + Math.max(rowsCost * (100 - colStats.nulls()) / 100, 1), rowsCost - (i > 0 ? 1 : 0));\n+                    } else\n+                        break;\n+                }\n+            }\n+            return rowsCost;\n+        }\n+\n+        /**\n+         * Try to get column cardinality from statistics, if there is no such - fall back to H2 column selectivity.\n+         *\n+         * @param colStats column statistics.\n+         * @param column   column.\n+         * @return column cardinality in percents.\n+         */\n+        private int getColumnCardinality(@Nullable ColumnStatistics colStats, Column column) {\n+            return (colStats == null) ? column.getSelectivity() : colStats.cardinality();\n+        }\n+\n+        /**\n+         * Get total number of values in column.\n+         *\n+         * @param colStats column statistics.\n+         * @param rowCount total row count in table.\n+         * @param nulls    if {@code true} - try to estimate only nulls count,\n+         *                 if @{code false} - try to estimate only non null count,\n+         *                 if {@code null} - try to estimate total count of values.\n+         * @return column value count.\n+         */\n+        private long getColumnSize(@Nullable ColumnStatistics colStats, long rowCount, Boolean nulls) {\n+            if (colStats == null)\n+                return rowCount;\n+            else if (nulls == null)\n+                return colStats.total();\n+            else if (nulls)\n+                return colStats.total() * colStats.nulls() / 100;\n+            else\n+                return colStats.total() * (100 - colStats.nulls()) / 100;\n+        }\n+\n+        private Value getEqualValue(Session ses, Column column, TableFilter filter) {\n+            Value maxValue = null;\n+            for (IndexCondition cond : filter.getIndexConditions()) {\n+                if (!column.equals(cond.getColumn()))\n+                    continue;\n+\n+                if (isByteFlag(cond.getCompareType(), Comparison.EQUAL) && cond.isEvaluatable()) {\n+\n+                    Expression expr = cond.getExpression();\n+                    if (expr != null && expr.isConstant()) {\n+                        Value curVal = cond.getCurrentValue(ses);\n+                        if (null == maxValue || (curVal != null || filter.getTable().compareValues(curVal, maxValue) < 0))\n+                            maxValue = curVal;\n+                    }\n+                }\n+            }\n+            return maxValue;\n+        }\n+\n+        private Value getStartValue(Session ses, Column column, TableFilter filter) {\n+            if (filter == null)\n+                return null;\n+            Value maxValue = null;\n+            for (IndexCondition cond : filter.getIndexConditions()) {\n+                if (!column.equals(cond.getColumn()))\n+                    continue;\n+\n+                if ((isByteFlag(cond.getCompareType(), Comparison.BIGGER)\n+                        || isByteFlag(cond.getCompareType(), Comparison.BIGGER_EQUAL))\n+                        && cond.isEvaluatable()) {\n+\n+                    Expression expr = cond.getExpression();\n+                    if (expr != null && expr.isConstant()) {\n+                        Value curVal = cond.getCurrentValue(ses);\n+                        if (null == maxValue || (curVal != null || filter.getTable().compareValues(curVal, maxValue) < 0))\n+                            maxValue = curVal;\n+                    }\n+                }\n+            }\n+            return maxValue;\n+        }\n+\n+        private Value getEndValue(Session ses, Column column, TableFilter filter) {\n+            if (filter == null)\n+                return null;\n+            Value minValue = null;\n+            for (IndexCondition cond : filter.getIndexConditions()) {\n+                if (!column.equals(cond.getColumn()))\n+                    continue;\n+\n+                if ((isByteFlag(cond.getCompareType(), Comparison.SMALLER)\n+                        || isByteFlag(cond.getCompareType(), Comparison.SMALLER_EQUAL))\n+                        && cond.isEvaluatable()) {\n+                    Expression expr = cond.getExpression();\n+                    if (expr != null && expr.isConstant()) {\n+                        Value curVal = cond.getCurrentValue(ses);\n+                        if (null == minValue || (curVal != null || filter.getTable().compareValues(minValue, curVal) < 0))\n+                            minValue = curVal;\n+                    }\n+                }\n+            }\n+            return minValue;\n+        }\n+\n+        /**\n+         * Check if specified filter compare specified column to not null.\n+         *\n+         * @param ses    session to resolv values\n+         * @param column column to check\n+         * @param filter filter\n+         * @return {@code true} if column value should be null, {@code falce} otherwise (or if it not sure)\n+         */\n+        private boolean isNotNullFilter(Session ses, Column column, TableFilter filter) {\n+            // TODO: check not null expression (TableFilter contains only fullCondition without getter to check it)\n+            return false;\n+        }\n+\n+        /**\n+         * Check if specified filter compare specified column to null.\n+         *\n+         * @param ses    session to resolv values\n+         * @param column column to check\n+         * @param filter filter\n+         * @return {@code true} if column value should be null, {@code falce} otherwise (or if it not sure)\n+         */\n+        private boolean isNullFilter(Session ses, Column column, TableFilter filter) {\n+            if (filter == null)\n+                return false;\n+            for (IndexCondition cond : filter.getIndexConditions()) {\n+                if (column.equals(cond.getColumn()))\n+                    continue;\n+\n+                if (isByteFlag(cond.getCompareType(), Comparison.SPATIAL_INTERSECTS) && cond.isEvaluatable()) {\n+                    Expression expr = cond.getExpression();\n+\n+                    if (expr != null && expr.isConstant()) {\n+                        Value curVal = cond.getCurrentValue(ses);\n+\n+                        if (curVal != null && curVal.getValueType() == Value.NULL)\n+                            return true;\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+\n+        /**\n+         * Test if value contains all masks bits.\n+         *\n+         * @param value value to test.\n+         * @param mask  mask to test by.\n+         * @return {@code true} if value contains all necessary bits, {@code false} otherwise.\n+         */\n+        private boolean isByteFlag(int value, int mask) {\n+            return (value & mask) == mask;\n+        }\n+\n+        /**\n+         * Estimate percent of selected rows by specified min/max conditions (of total rows, with nulls).\n+         *\n+         * @param colStat column statistics to use, if exists.\n+         * @param min     lower border.\n+         * @param max     higher border.\n+         * @return percent of rows, selected with specified conditions (0-100)\n+         */\n+        private int estimatePercent(ColumnStatistics colStat, Value min, Value max) {\n+            if (colStat == null || colStat.min() == null || colStat.max() == null)\n+                // Fall back to previous behaviour without statistics, even without min/max testing\n+                return estimatePercentFallback(min, max);\n+\n+            BigDecimal minValue = (min == null) ? null : getComparableValue(min);\n+            BigDecimal maxValue = (max == null) ? null : getComparableValue(max);\n+\n+            if (minValue == null && maxValue == null)\n+                return estimatePercentFallback(min, max);\n+\n+            BigDecimal minStat = getComparableValue(colStat.min());\n+            BigDecimal maxStat = getComparableValue(colStat.max());\n+\n+            if (minStat == null || maxStat == null)\n+                return estimatePercentFallback(min, max);\n+\n+            BigDecimal start = (minValue == null || minValue.compareTo(minStat) < 0) ? minStat : minValue;\n+            BigDecimal end = (maxValue == null || maxValue.compareTo(maxStat) > 0) ? maxStat : maxValue;\n+\n+            BigDecimal actual = end.subtract(start);\n+\n+            if (actual.signum() < 0)\n+                return 0;\n+\n+            BigDecimal total = maxStat.subtract(minStat);\n+\n+            if (total.signum() < 0)\n+                return estimatePercentFallback(min, max);\n+\n+            if (total.signum() == 0)\n+                return (minStat.equals(min)) ? 100 : 0;\n+\n+            int result = actual.multiply(BigDecimal.valueOf(100 - colStat.nulls())).divide(total, MATH_CONTEXT).intValue();\n+            return result > 100 ? 100 : result;\n+        }\n+\n+        private int estimatePercentFallback(Value min, Value max) {\n+            return (min == null || max == null) ? RANGE_OPEN_SELECTIVITY_LAST : RANGE_CLOSE_SELECTIVITY_LAST;\n+        }\n+\n+        /**\n+         * Convert specified value into comparable type: BigDecimal,\n+         *\n+         * @param value\n+         * @return\n+         */\n+        private BigDecimal getComparableValue(Value value) {\n+            switch (value.getValueType()) {\n+                case Value.NULL:\n+                    throw new IllegalArgumentException(\"Can't compare null values\");\n+\n+                case Value.BOOLEAN:\n+                    return new BigDecimal(value.getBoolean() ? 1 : 0);\n+\n+                case Value.BYTE:\n+                    return new BigDecimal(value.getByte());\n+\n+                case Value.SHORT:\n+                    return new BigDecimal(value.getShort());\n+\n+                case Value.INT:\n+                    return new BigDecimal(value.getInt());\n+\n+                case Value.LONG:\n+                    return new BigDecimal(value.getLong());\n+\n+                case Value.DECIMAL:\n+                    return value.getBigDecimal();\n+\n+                case Value.DOUBLE:\n+                    return new BigDecimal(value.getDouble());\n+\n+                case Value.FLOAT:\n+                    return new BigDecimal(value.getFloat());\n+\n+                case Value.DATE:\n+                    return new BigDecimal(value.getDate().getTime());\n+\n+                case Value.TIME:\n+                    return new BigDecimal(value.getTime().getTime());\n+\n+                case Value.TIMESTAMP:\n+                    return new BigDecimal(value.getTimestamp().getTime());\n+\n+                case Value.BYTES:\n+                    BigInteger bigInteger = new BigInteger(1, value.getBytes());\n+                    return new BigDecimal(bigInteger);\n+\n+                case Value.STRING:\n+                case Value.STRING_FIXED:\n+                case Value.STRING_IGNORECASE:\n+                    return null;\n+\n+                case Value.ROW: // Intentionally converts Value.ROW to GridH2Array to preserve compatibility\n+                case Value.ARRAY:", "originalCommit": "6e542dba4c81179ed1a8fab253f3a1fb85c02eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA3OTk5Ng==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r509079996", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     *                 if @{code false} - try to estimate only non null count,\n          \n          \n            \n                     *                 if {@code false} - try to estimate only non null count,", "author": "korlov42", "createdAt": "2020-10-21T08:17:39Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/opt/H2IndexCostedBase.java", "diffHunk": "@@ -641,22 +664,558 @@ else if (needsToReadFromScanIndex)\n          * Cost function.\n          * See more: {@link BaseIndex#getCostRangeIndex}.\n          */\n-        long getCostRangeIndex(int[] masks, long rowCount,\n-            TableFilter[] filters, int filter, SortOrder sortOrder,\n-            boolean isScanIndex, AllColumnsForPlan allColumnsSet);\n+        long getCostRangeIndex(Session ses, int[] masks, long rowCount,\n+                               TableFilter[] filters, int filter, SortOrder sortOrder,\n+                               boolean isScanIndex, AllColumnsForPlan allColumnsSet);\n     }\n \n     /**\n      *\n      */\n     private enum CostFunctionType {\n-        /** Last. */\n+        /**\n+         * Last.\n+         */\n         LAST,\n \n-        /** Compatible with ver. 8.7.12. */\n+        /**\n+         * Compatible with ver. 8.7.28\n+         */\n+        COMPATIBLE_8_7_28,\n+\n+        /**\n+         * Compatible with ver. 8.7.12.\n+         */\n         COMPATIBLE_8_7_12,\n \n-        /** Compatible with ver. 8.7.6. */\n+        /**\n+         * Compatible with ver. 8.7.6.\n+         */\n         COMPATIBLE_8_7_6\n     }\n+\n+    private final class CostFunctionLast {\n+        /**\n+         * Math context to use in estimations calculations.\n+         */\n+        private final MathContext MATH_CONTEXT = MathContext.DECIMAL64;\n+\n+        /**\n+         * Selectivity for closed range queries, in percent\n+         */\n+        private final int RANGE_CLOSE_SELECTIVITY_LAST = 25;\n+\n+        /**\n+         * Selectivity for open range queries, in percent\n+         */\n+        private final int RANGE_OPEN_SELECTIVITY_LAST = 33;\n+\n+        private long getCostRangeIndexRowCost_Last(Session ses, TableFilter filter, int[] masks, long rowCount,\n+                                                   ObjectStatisticsImpl locTblStats) {\n+            int totalCardinality = 0;\n+\n+            long rowsCost = rowCount;\n+\n+            if (masks != null) {\n+                int i = 0, len = columns.length;\n+\n+                while (i < len) {\n+                    Column column = columns[i++];\n+                    ColumnStatistics colStats = getColumnStatistics(locTblStats, column);\n+\n+                    int index = column.getColumnId();\n+                    int mask = masks[index];\n+\n+                    if (isByteFlag(mask, IndexCondition.EQUALITY)) {\n+                        if (i == len && getIndexType().isUnique()) {\n+                            rowsCost = 3;\n+\n+                            break;\n+                        }\n+                        // Estimate by is null\n+\n+                        Value equalValue = getEqualValue(ses, column, filter);\n+                        Boolean equalNull = (equalValue == null) ? null : equalValue.getValueType() == Value.NULL;\n+                        rowCount = getColumnSize(colStats, rowCount, equalNull);\n+\n+                        if (colStats != null && equalNull == Boolean.TRUE) {\n+                            rowsCost = Math.min(5 + Math.max(rowsCost * colStats.nulls() / 100, 1), rowsCost - (i > 0 ? 1 : 0));\n+                            continue;\n+                        }\n+                        if (colStats != null && equalNull == Boolean.FALSE)\n+                            rowsCost = rowsCost * (100 - colStats.nulls()) / 100;\n+\n+                        int cardinality = getColumnCardinality(colStats, column);\n+\n+                        totalCardinality = 100 - ((100 - totalCardinality) * (100 - cardinality) / 100);\n+\n+                        long distinctRows = Math.round((double) rowCount * totalCardinality / 100);\n+\n+                        if (distinctRows <= 0)\n+                            distinctRows = 1;\n+\n+                        if (colStats != null && equalNull != null)\n+                            distinctRows = distinctRows * 100 / (100 - colStats.nulls());\n+\n+                        rowsCost = Math.min(5 + Math.max(rowsCost / distinctRows, 1), rowsCost - (i > 0 ? 1 : 0));\n+                    } else if (isByteFlag(mask, IndexCondition.RANGE)) {\n+                        Value min = getStartValue(ses, column, filter);\n+                        Value max = getEndValue(ses, column, filter);\n+                        int percent = estimatePercent(colStats, min, max);\n+\n+                        rowsCost = Math.min(5 + rowsCost * percent / 100, rowsCost - (i > 0 ? 1 : 0));\n+\n+                        break;\n+                    } else if (isByteFlag(mask, IndexCondition.START)) {\n+                        Value min = getStartValue(ses, column, filter);\n+                        Value max = getEndValue(ses, column, filter);\n+                        int percent = estimatePercent(colStats, min, max);\n+\n+                        rowsCost = Math.min(5 + rowsCost * percent / 100, rowsCost - (i > 0 ? 1 : 0));\n+\n+                        break;\n+                    } else if (isByteFlag(mask, IndexCondition.END)) {\n+                        Value min = getStartValue(ses, column, filter);\n+                        Value max = getEndValue(ses, column, filter);\n+                        int percent = estimatePercent(colStats, min, max);\n+\n+                        rowsCost = Math.min(5 + rowsCost * percent / 100, rowsCost - (i > 0 ? 1 : 0));\n+\n+                        break;\n+                    } else if (isNullFilter(ses, column, filter)) {\n+                        if (colStats != null)\n+                            rowsCost = Math.min(5 + Math.max(rowsCost * colStats.nulls() / 100, 1), rowsCost - (i > 0 ? 1 : 0));\n+                    } else if (isNotNullFilter(ses, column, filter)) {\n+                        if (colStats != null)\n+                            rowsCost = Math.min(5 + Math.max(rowsCost * (100 - colStats.nulls()) / 100, 1), rowsCost - (i > 0 ? 1 : 0));\n+                    } else\n+                        break;\n+                }\n+            }\n+            return rowsCost;\n+        }\n+\n+        /**\n+         * Try to get column cardinality from statistics, if there is no such - fall back to H2 column selectivity.\n+         *\n+         * @param colStats column statistics.\n+         * @param column   column.\n+         * @return column cardinality in percents.\n+         */\n+        private int getColumnCardinality(@Nullable ColumnStatistics colStats, Column column) {\n+            return (colStats == null) ? column.getSelectivity() : colStats.cardinality();\n+        }\n+\n+        /**\n+         * Get total number of values in column.\n+         *\n+         * @param colStats column statistics.\n+         * @param rowCount total row count in table.\n+         * @param nulls    if {@code true} - try to estimate only nulls count,\n+         *                 if @{code false} - try to estimate only non null count,", "originalCommit": "6e542dba4c81179ed1a8fab253f3a1fb85c02eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA5MDMyMA==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r509090320", "bodyText": "let's get rid of this method since it just delegates invocation to cfl", "author": "korlov42", "createdAt": "2020-10-21T08:32:02Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/opt/H2IndexCostedBase.java", "diffHunk": "@@ -92,18 +117,27 @@ protected H2IndexCostedBase(GridH2Table tbl, String name, IndexColumn[] cols, In\n     /**\n      * Re-implement {@link BaseIndex#getCostRangeIndex} to dispatch cost function on new and old versions.\n      */\n-    protected long costRangeIndex(int[] masks, long rowCount,\n-        TableFilter[] filters, int filter, SortOrder sortOrder,\n-        boolean isScanIndex, AllColumnsForPlan allColumnsSet) {\n-        return constFunc.getCostRangeIndex(masks, rowCount, filters, filter, sortOrder, isScanIndex, allColumnsSet);\n+    protected long costRangeIndex(Session ses, int[] masks, long rowCount,\n+                                  TableFilter[] filters, int filter, SortOrder sortOrder,\n+                                  boolean isScanIndex, AllColumnsForPlan allColumnsSet) {\n+        return constFunc.getCostRangeIndex(ses, masks, rowCount, filters, filter, sortOrder, isScanIndex, allColumnsSet);\n     }\n \n     /**\n      * Re-implement {@link BaseIndex#getCostRangeIndex} to support  compatibility with old version.\n      */\n-    private long getCostRangeIndex_Last(int[] masks, long rowCount,\n-        TableFilter[] filters, int filter, SortOrder sortOrder,\n-        boolean isScanIndex, AllColumnsForPlan allColumnsSet) {\n+    private long getCostRangeIndex_Last(Session ses, int[] masks, long rowCount,", "originalCommit": "6e542dba4c81179ed1a8fab253f3a1fb85c02eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA5MTk5Mw==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r509091993", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final class CostFunctionLast {\n          \n          \n            \n                private final class CostFunctionImpl implements CostFunction {", "author": "korlov42", "createdAt": "2020-10-21T08:34:32Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/opt/H2IndexCostedBase.java", "diffHunk": "@@ -641,22 +664,558 @@ else if (needsToReadFromScanIndex)\n          * Cost function.\n          * See more: {@link BaseIndex#getCostRangeIndex}.\n          */\n-        long getCostRangeIndex(int[] masks, long rowCount,\n-            TableFilter[] filters, int filter, SortOrder sortOrder,\n-            boolean isScanIndex, AllColumnsForPlan allColumnsSet);\n+        long getCostRangeIndex(Session ses, int[] masks, long rowCount,\n+                               TableFilter[] filters, int filter, SortOrder sortOrder,\n+                               boolean isScanIndex, AllColumnsForPlan allColumnsSet);\n     }\n \n     /**\n      *\n      */\n     private enum CostFunctionType {\n-        /** Last. */\n+        /**\n+         * Last.\n+         */\n         LAST,\n \n-        /** Compatible with ver. 8.7.12. */\n+        /**\n+         * Compatible with ver. 8.7.28\n+         */\n+        COMPATIBLE_8_7_28,\n+\n+        /**\n+         * Compatible with ver. 8.7.12.\n+         */\n         COMPATIBLE_8_7_12,\n \n-        /** Compatible with ver. 8.7.6. */\n+        /**\n+         * Compatible with ver. 8.7.6.\n+         */\n         COMPATIBLE_8_7_6\n     }\n+\n+    private final class CostFunctionLast {", "originalCommit": "6e542dba4c81179ed1a8fab253f3a1fb85c02eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA5Mjk3MA==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r509092970", "bodyText": "we don't need to store this because we could create this at the very moment of choosing a cost function", "author": "korlov42", "createdAt": "2020-10-21T08:35:51Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/opt/H2IndexCostedBase.java", "diffHunk": "@@ -16,57 +16,77 @@\n \n package org.apache.ignite.internal.processors.query.h2.opt;\n \n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.math.MathContext;\n import java.util.ArrayList;\n import java.util.Arrays;\n+\n import org.apache.ignite.IgniteLogger;\n import org.apache.ignite.IgniteSystemProperties;\n+import org.apache.ignite.internal.processors.query.stat.ColumnStatistics;\n+import org.apache.ignite.internal.processors.query.stat.ObjectStatisticsImpl;\n import org.apache.ignite.internal.util.typedef.F;\n import org.apache.ignite.internal.util.typedef.internal.LT;\n import org.gridgain.internal.h2.command.dml.AllColumnsForPlan;\n import org.gridgain.internal.h2.engine.Constants;\n+import org.gridgain.internal.h2.engine.Session;\n+import org.gridgain.internal.h2.expression.Expression;\n+import org.gridgain.internal.h2.expression.condition.Comparison;\n import org.gridgain.internal.h2.index.BaseIndex;\n import org.gridgain.internal.h2.index.IndexCondition;\n import org.gridgain.internal.h2.index.IndexType;\n import org.gridgain.internal.h2.result.SortOrder;\n import org.gridgain.internal.h2.table.Column;\n import org.gridgain.internal.h2.table.IndexColumn;\n import org.gridgain.internal.h2.table.TableFilter;\n+import org.gridgain.internal.h2.value.Value;\n+import org.jetbrains.annotations.Nullable;\n \n /**\n  * Index base.\n  */\n public abstract class H2IndexCostedBase extends BaseIndex {\n-    /** Const function. */\n+    /**\n+     * Const function.\n+     */\n     private final CostFunction constFunc;\n \n-    /** Logger. */\n+    private final GridH2Table tbl;\n+\n+    private final CostFunctionLast cfl = new CostFunctionLast();", "originalCommit": "6e542dba4c81179ed1a8fab253f3a1fb85c02eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA5ODU3MA==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r509098570", "bodyText": "let's get rid of the rowCount param, since we could get this by  getRowCountApproximation(ses); where it is actually needed", "author": "korlov42", "createdAt": "2020-10-21T08:44:05Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/opt/H2IndexCostedBase.java", "diffHunk": "@@ -641,22 +664,558 @@ else if (needsToReadFromScanIndex)\n          * Cost function.\n          * See more: {@link BaseIndex#getCostRangeIndex}.\n          */\n-        long getCostRangeIndex(int[] masks, long rowCount,\n-            TableFilter[] filters, int filter, SortOrder sortOrder,\n-            boolean isScanIndex, AllColumnsForPlan allColumnsSet);\n+        long getCostRangeIndex(Session ses, int[] masks, long rowCount,", "originalCommit": "6e542dba4c81179ed1a8fab253f3a1fb85c02eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTExMTIwNQ==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r509111205", "bodyText": "let's simplify name to just rowCost and sortingCost", "author": "korlov42", "createdAt": "2020-10-21T09:01:39Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/opt/H2IndexCostedBase.java", "diffHunk": "@@ -641,22 +664,558 @@ else if (needsToReadFromScanIndex)\n          * Cost function.\n          * See more: {@link BaseIndex#getCostRangeIndex}.\n          */\n-        long getCostRangeIndex(int[] masks, long rowCount,\n-            TableFilter[] filters, int filter, SortOrder sortOrder,\n-            boolean isScanIndex, AllColumnsForPlan allColumnsSet);\n+        long getCostRangeIndex(Session ses, int[] masks, long rowCount,\n+                               TableFilter[] filters, int filter, SortOrder sortOrder,\n+                               boolean isScanIndex, AllColumnsForPlan allColumnsSet);\n     }\n \n     /**\n      *\n      */\n     private enum CostFunctionType {\n-        /** Last. */\n+        /**\n+         * Last.\n+         */\n         LAST,\n \n-        /** Compatible with ver. 8.7.12. */\n+        /**\n+         * Compatible with ver. 8.7.28\n+         */\n+        COMPATIBLE_8_7_28,\n+\n+        /**\n+         * Compatible with ver. 8.7.12.\n+         */\n         COMPATIBLE_8_7_12,\n \n-        /** Compatible with ver. 8.7.6. */\n+        /**\n+         * Compatible with ver. 8.7.6.\n+         */\n         COMPATIBLE_8_7_6\n     }\n+\n+    private final class CostFunctionLast {\n+        /**\n+         * Math context to use in estimations calculations.\n+         */\n+        private final MathContext MATH_CONTEXT = MathContext.DECIMAL64;\n+\n+        /**\n+         * Selectivity for closed range queries, in percent\n+         */\n+        private final int RANGE_CLOSE_SELECTIVITY_LAST = 25;\n+\n+        /**\n+         * Selectivity for open range queries, in percent\n+         */\n+        private final int RANGE_OPEN_SELECTIVITY_LAST = 33;\n+\n+        private long getCostRangeIndexRowCost_Last(Session ses, TableFilter filter, int[] masks, long rowCount,", "originalCommit": "6e542dba4c81179ed1a8fab253f3a1fb85c02eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTEzMzE3OA==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r509133178", "bodyText": "it's possible to have column with only nulls, so we will get division by zero here", "author": "korlov42", "createdAt": "2020-10-21T09:34:04Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/opt/H2IndexCostedBase.java", "diffHunk": "@@ -641,22 +664,558 @@ else if (needsToReadFromScanIndex)\n          * Cost function.\n          * See more: {@link BaseIndex#getCostRangeIndex}.\n          */\n-        long getCostRangeIndex(int[] masks, long rowCount,\n-            TableFilter[] filters, int filter, SortOrder sortOrder,\n-            boolean isScanIndex, AllColumnsForPlan allColumnsSet);\n+        long getCostRangeIndex(Session ses, int[] masks, long rowCount,\n+                               TableFilter[] filters, int filter, SortOrder sortOrder,\n+                               boolean isScanIndex, AllColumnsForPlan allColumnsSet);\n     }\n \n     /**\n      *\n      */\n     private enum CostFunctionType {\n-        /** Last. */\n+        /**\n+         * Last.\n+         */\n         LAST,\n \n-        /** Compatible with ver. 8.7.12. */\n+        /**\n+         * Compatible with ver. 8.7.28\n+         */\n+        COMPATIBLE_8_7_28,\n+\n+        /**\n+         * Compatible with ver. 8.7.12.\n+         */\n         COMPATIBLE_8_7_12,\n \n-        /** Compatible with ver. 8.7.6. */\n+        /**\n+         * Compatible with ver. 8.7.6.\n+         */\n         COMPATIBLE_8_7_6\n     }\n+\n+    private final class CostFunctionLast {\n+        /**\n+         * Math context to use in estimations calculations.\n+         */\n+        private final MathContext MATH_CONTEXT = MathContext.DECIMAL64;\n+\n+        /**\n+         * Selectivity for closed range queries, in percent\n+         */\n+        private final int RANGE_CLOSE_SELECTIVITY_LAST = 25;\n+\n+        /**\n+         * Selectivity for open range queries, in percent\n+         */\n+        private final int RANGE_OPEN_SELECTIVITY_LAST = 33;\n+\n+        private long getCostRangeIndexRowCost_Last(Session ses, TableFilter filter, int[] masks, long rowCount,\n+                                                   ObjectStatisticsImpl locTblStats) {\n+            int totalCardinality = 0;\n+\n+            long rowsCost = rowCount;\n+\n+            if (masks != null) {\n+                int i = 0, len = columns.length;\n+\n+                while (i < len) {\n+                    Column column = columns[i++];\n+                    ColumnStatistics colStats = getColumnStatistics(locTblStats, column);\n+\n+                    int index = column.getColumnId();\n+                    int mask = masks[index];\n+\n+                    if (isByteFlag(mask, IndexCondition.EQUALITY)) {\n+                        if (i == len && getIndexType().isUnique()) {\n+                            rowsCost = 3;\n+\n+                            break;\n+                        }\n+                        // Estimate by is null\n+\n+                        Value equalValue = getEqualValue(ses, column, filter);\n+                        Boolean equalNull = (equalValue == null) ? null : equalValue.getValueType() == Value.NULL;\n+                        rowCount = getColumnSize(colStats, rowCount, equalNull);\n+\n+                        if (colStats != null && equalNull == Boolean.TRUE) {\n+                            rowsCost = Math.min(5 + Math.max(rowsCost * colStats.nulls() / 100, 1), rowsCost - (i > 0 ? 1 : 0));\n+                            continue;\n+                        }\n+                        if (colStats != null && equalNull == Boolean.FALSE)\n+                            rowsCost = rowsCost * (100 - colStats.nulls()) / 100;\n+\n+                        int cardinality = getColumnCardinality(colStats, column);\n+\n+                        totalCardinality = 100 - ((100 - totalCardinality) * (100 - cardinality) / 100);\n+\n+                        long distinctRows = Math.round((double) rowCount * totalCardinality / 100);\n+\n+                        if (distinctRows <= 0)\n+                            distinctRows = 1;\n+\n+                        if (colStats != null && equalNull != null)\n+                            distinctRows = distinctRows * 100 / (100 - colStats.nulls());", "originalCommit": "6e542dba4c81179ed1a8fab253f3a1fb85c02eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTEzNjk2NQ==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r509136965", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                } else if (isByteFlag(mask, IndexCondition.RANGE)) {\n          \n          \n            \n                                    Value min = getStartValue(ses, column, filter);\n          \n          \n            \n                                    Value max = getEndValue(ses, column, filter);\n          \n          \n            \n                                    int percent = estimatePercent(colStats, min, max);\n          \n          \n            \n            \n          \n          \n            \n                                    rowsCost = Math.min(5 + rowsCost * percent / 100, rowsCost - (i > 0 ? 1 : 0));\n          \n          \n            \n            \n          \n          \n            \n                                    break;\n          \n          \n            \n                                } else if (isByteFlag(mask, IndexCondition.START)) {\n          \n          \n            \n                                    Value min = getStartValue(ses, column, filter);\n          \n          \n            \n                                    Value max = getEndValue(ses, column, filter);\n          \n          \n            \n                                    int percent = estimatePercent(colStats, min, max);\n          \n          \n            \n            \n          \n          \n            \n                                    rowsCost = Math.min(5 + rowsCost * percent / 100, rowsCost - (i > 0 ? 1 : 0));\n          \n          \n            \n            \n          \n          \n            \n                                    break;\n          \n          \n            \n                                } else if (isByteFlag(mask, IndexCondition.END)) {\n          \n          \n            \n                                    Value min = getStartValue(ses, column, filter);\n          \n          \n            \n                                    Value max = getEndValue(ses, column, filter);\n          \n          \n            \n                                    int percent = estimatePercent(colStats, min, max);\n          \n          \n            \n            \n          \n          \n            \n                                    rowsCost = Math.min(5 + rowsCost * percent / 100, rowsCost - (i > 0 ? 1 : 0));\n          \n          \n            \n            \n          \n          \n            \n                                    break;\n          \n          \n            \n                                }\n          \n          \n            \n                                else if (isByteFlag(mask, IndexCondition.RANGE)\n          \n          \n            \n                                    || isByteFlag(mask, IndexCondition.START)\n          \n          \n            \n                                    || isByteFlag(mask, IndexCondition.END)\n          \n          \n            \n                                ) {\n          \n          \n            \n                                    Value min = getStartValue(ses, column, filter);\n          \n          \n            \n                                    Value max = getEndValue(ses, column, filter);\n          \n          \n            \n                                    int percent = estimatePercent(colStats, min, max);\n          \n          \n            \n            \n          \n          \n            \n                                    rowsCost = Math.min(5 + rowsCost * percent / 100, rowsCost - (i > 0 ? 1 : 0));\n          \n          \n            \n            \n          \n          \n            \n                                    break;", "author": "korlov42", "createdAt": "2020-10-21T09:39:55Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/opt/H2IndexCostedBase.java", "diffHunk": "@@ -641,22 +664,558 @@ else if (needsToReadFromScanIndex)\n          * Cost function.\n          * See more: {@link BaseIndex#getCostRangeIndex}.\n          */\n-        long getCostRangeIndex(int[] masks, long rowCount,\n-            TableFilter[] filters, int filter, SortOrder sortOrder,\n-            boolean isScanIndex, AllColumnsForPlan allColumnsSet);\n+        long getCostRangeIndex(Session ses, int[] masks, long rowCount,\n+                               TableFilter[] filters, int filter, SortOrder sortOrder,\n+                               boolean isScanIndex, AllColumnsForPlan allColumnsSet);\n     }\n \n     /**\n      *\n      */\n     private enum CostFunctionType {\n-        /** Last. */\n+        /**\n+         * Last.\n+         */\n         LAST,\n \n-        /** Compatible with ver. 8.7.12. */\n+        /**\n+         * Compatible with ver. 8.7.28\n+         */\n+        COMPATIBLE_8_7_28,\n+\n+        /**\n+         * Compatible with ver. 8.7.12.\n+         */\n         COMPATIBLE_8_7_12,\n \n-        /** Compatible with ver. 8.7.6. */\n+        /**\n+         * Compatible with ver. 8.7.6.\n+         */\n         COMPATIBLE_8_7_6\n     }\n+\n+    private final class CostFunctionLast {\n+        /**\n+         * Math context to use in estimations calculations.\n+         */\n+        private final MathContext MATH_CONTEXT = MathContext.DECIMAL64;\n+\n+        /**\n+         * Selectivity for closed range queries, in percent\n+         */\n+        private final int RANGE_CLOSE_SELECTIVITY_LAST = 25;\n+\n+        /**\n+         * Selectivity for open range queries, in percent\n+         */\n+        private final int RANGE_OPEN_SELECTIVITY_LAST = 33;\n+\n+        private long getCostRangeIndexRowCost_Last(Session ses, TableFilter filter, int[] masks, long rowCount,\n+                                                   ObjectStatisticsImpl locTblStats) {\n+            int totalCardinality = 0;\n+\n+            long rowsCost = rowCount;\n+\n+            if (masks != null) {\n+                int i = 0, len = columns.length;\n+\n+                while (i < len) {\n+                    Column column = columns[i++];\n+                    ColumnStatistics colStats = getColumnStatistics(locTblStats, column);\n+\n+                    int index = column.getColumnId();\n+                    int mask = masks[index];\n+\n+                    if (isByteFlag(mask, IndexCondition.EQUALITY)) {\n+                        if (i == len && getIndexType().isUnique()) {\n+                            rowsCost = 3;\n+\n+                            break;\n+                        }\n+                        // Estimate by is null\n+\n+                        Value equalValue = getEqualValue(ses, column, filter);\n+                        Boolean equalNull = (equalValue == null) ? null : equalValue.getValueType() == Value.NULL;\n+                        rowCount = getColumnSize(colStats, rowCount, equalNull);\n+\n+                        if (colStats != null && equalNull == Boolean.TRUE) {\n+                            rowsCost = Math.min(5 + Math.max(rowsCost * colStats.nulls() / 100, 1), rowsCost - (i > 0 ? 1 : 0));\n+                            continue;\n+                        }\n+                        if (colStats != null && equalNull == Boolean.FALSE)\n+                            rowsCost = rowsCost * (100 - colStats.nulls()) / 100;\n+\n+                        int cardinality = getColumnCardinality(colStats, column);\n+\n+                        totalCardinality = 100 - ((100 - totalCardinality) * (100 - cardinality) / 100);\n+\n+                        long distinctRows = Math.round((double) rowCount * totalCardinality / 100);\n+\n+                        if (distinctRows <= 0)\n+                            distinctRows = 1;\n+\n+                        if (colStats != null && equalNull != null)\n+                            distinctRows = distinctRows * 100 / (100 - colStats.nulls());\n+\n+                        rowsCost = Math.min(5 + Math.max(rowsCost / distinctRows, 1), rowsCost - (i > 0 ? 1 : 0));\n+                    } else if (isByteFlag(mask, IndexCondition.RANGE)) {\n+                        Value min = getStartValue(ses, column, filter);\n+                        Value max = getEndValue(ses, column, filter);\n+                        int percent = estimatePercent(colStats, min, max);\n+\n+                        rowsCost = Math.min(5 + rowsCost * percent / 100, rowsCost - (i > 0 ? 1 : 0));\n+\n+                        break;\n+                    } else if (isByteFlag(mask, IndexCondition.START)) {\n+                        Value min = getStartValue(ses, column, filter);\n+                        Value max = getEndValue(ses, column, filter);\n+                        int percent = estimatePercent(colStats, min, max);\n+\n+                        rowsCost = Math.min(5 + rowsCost * percent / 100, rowsCost - (i > 0 ? 1 : 0));\n+\n+                        break;\n+                    } else if (isByteFlag(mask, IndexCondition.END)) {\n+                        Value min = getStartValue(ses, column, filter);\n+                        Value max = getEndValue(ses, column, filter);\n+                        int percent = estimatePercent(colStats, min, max);\n+\n+                        rowsCost = Math.min(5 + rowsCost * percent / 100, rowsCost - (i > 0 ? 1 : 0));\n+\n+                        break;", "originalCommit": "6e542dba4c81179ed1a8fab253f3a1fb85c02eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTE1ODkwMg==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r509158902", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        long sortingCost = 0;\n          \n          \n            \n            \n          \n          \n            \n                        if (sortOrder != null)\n          \n          \n            \n                            sortingCost = 100 + rowCount / 10;\n          \n          \n            \n            \n          \n          \n            \n                        if (sortOrder != null && !isScanIndex) {\n          \n          \n            \n                        if (sortOrder == null)\n          \n          \n            \n                            return 0;\n          \n          \n            \n                            \n          \n          \n            \n                        long sortingCost = 100 + rowCount / 10;\n          \n          \n            \n            \n          \n          \n            \n                        if (!isScanIndex) {", "author": "korlov42", "createdAt": "2020-10-21T10:14:33Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/opt/H2IndexCostedBase.java", "diffHunk": "@@ -641,22 +664,558 @@ else if (needsToReadFromScanIndex)\n          * Cost function.\n          * See more: {@link BaseIndex#getCostRangeIndex}.\n          */\n-        long getCostRangeIndex(int[] masks, long rowCount,\n-            TableFilter[] filters, int filter, SortOrder sortOrder,\n-            boolean isScanIndex, AllColumnsForPlan allColumnsSet);\n+        long getCostRangeIndex(Session ses, int[] masks, long rowCount,\n+                               TableFilter[] filters, int filter, SortOrder sortOrder,\n+                               boolean isScanIndex, AllColumnsForPlan allColumnsSet);\n     }\n \n     /**\n      *\n      */\n     private enum CostFunctionType {\n-        /** Last. */\n+        /**\n+         * Last.\n+         */\n         LAST,\n \n-        /** Compatible with ver. 8.7.12. */\n+        /**\n+         * Compatible with ver. 8.7.28\n+         */\n+        COMPATIBLE_8_7_28,\n+\n+        /**\n+         * Compatible with ver. 8.7.12.\n+         */\n         COMPATIBLE_8_7_12,\n \n-        /** Compatible with ver. 8.7.6. */\n+        /**\n+         * Compatible with ver. 8.7.6.\n+         */\n         COMPATIBLE_8_7_6\n     }\n+\n+    private final class CostFunctionLast {\n+        /**\n+         * Math context to use in estimations calculations.\n+         */\n+        private final MathContext MATH_CONTEXT = MathContext.DECIMAL64;\n+\n+        /**\n+         * Selectivity for closed range queries, in percent\n+         */\n+        private final int RANGE_CLOSE_SELECTIVITY_LAST = 25;\n+\n+        /**\n+         * Selectivity for open range queries, in percent\n+         */\n+        private final int RANGE_OPEN_SELECTIVITY_LAST = 33;\n+\n+        private long getCostRangeIndexRowCost_Last(Session ses, TableFilter filter, int[] masks, long rowCount,\n+                                                   ObjectStatisticsImpl locTblStats) {\n+            int totalCardinality = 0;\n+\n+            long rowsCost = rowCount;\n+\n+            if (masks != null) {\n+                int i = 0, len = columns.length;\n+\n+                while (i < len) {\n+                    Column column = columns[i++];\n+                    ColumnStatistics colStats = getColumnStatistics(locTblStats, column);\n+\n+                    int index = column.getColumnId();\n+                    int mask = masks[index];\n+\n+                    if (isByteFlag(mask, IndexCondition.EQUALITY)) {\n+                        if (i == len && getIndexType().isUnique()) {\n+                            rowsCost = 3;\n+\n+                            break;\n+                        }\n+                        // Estimate by is null\n+\n+                        Value equalValue = getEqualValue(ses, column, filter);\n+                        Boolean equalNull = (equalValue == null) ? null : equalValue.getValueType() == Value.NULL;\n+                        rowCount = getColumnSize(colStats, rowCount, equalNull);\n+\n+                        if (colStats != null && equalNull == Boolean.TRUE) {\n+                            rowsCost = Math.min(5 + Math.max(rowsCost * colStats.nulls() / 100, 1), rowsCost - (i > 0 ? 1 : 0));\n+                            continue;\n+                        }\n+                        if (colStats != null && equalNull == Boolean.FALSE)\n+                            rowsCost = rowsCost * (100 - colStats.nulls()) / 100;\n+\n+                        int cardinality = getColumnCardinality(colStats, column);\n+\n+                        totalCardinality = 100 - ((100 - totalCardinality) * (100 - cardinality) / 100);\n+\n+                        long distinctRows = Math.round((double) rowCount * totalCardinality / 100);\n+\n+                        if (distinctRows <= 0)\n+                            distinctRows = 1;\n+\n+                        if (colStats != null && equalNull != null)\n+                            distinctRows = distinctRows * 100 / (100 - colStats.nulls());\n+\n+                        rowsCost = Math.min(5 + Math.max(rowsCost / distinctRows, 1), rowsCost - (i > 0 ? 1 : 0));\n+                    } else if (isByteFlag(mask, IndexCondition.RANGE)) {\n+                        Value min = getStartValue(ses, column, filter);\n+                        Value max = getEndValue(ses, column, filter);\n+                        int percent = estimatePercent(colStats, min, max);\n+\n+                        rowsCost = Math.min(5 + rowsCost * percent / 100, rowsCost - (i > 0 ? 1 : 0));\n+\n+                        break;\n+                    } else if (isByteFlag(mask, IndexCondition.START)) {\n+                        Value min = getStartValue(ses, column, filter);\n+                        Value max = getEndValue(ses, column, filter);\n+                        int percent = estimatePercent(colStats, min, max);\n+\n+                        rowsCost = Math.min(5 + rowsCost * percent / 100, rowsCost - (i > 0 ? 1 : 0));\n+\n+                        break;\n+                    } else if (isByteFlag(mask, IndexCondition.END)) {\n+                        Value min = getStartValue(ses, column, filter);\n+                        Value max = getEndValue(ses, column, filter);\n+                        int percent = estimatePercent(colStats, min, max);\n+\n+                        rowsCost = Math.min(5 + rowsCost * percent / 100, rowsCost - (i > 0 ? 1 : 0));\n+\n+                        break;\n+                    } else if (isNullFilter(ses, column, filter)) {\n+                        if (colStats != null)\n+                            rowsCost = Math.min(5 + Math.max(rowsCost * colStats.nulls() / 100, 1), rowsCost - (i > 0 ? 1 : 0));\n+                    } else if (isNotNullFilter(ses, column, filter)) {\n+                        if (colStats != null)\n+                            rowsCost = Math.min(5 + Math.max(rowsCost * (100 - colStats.nulls()) / 100, 1), rowsCost - (i > 0 ? 1 : 0));\n+                    } else\n+                        break;\n+                }\n+            }\n+            return rowsCost;\n+        }\n+\n+        /**\n+         * Try to get column cardinality from statistics, if there is no such - fall back to H2 column selectivity.\n+         *\n+         * @param colStats column statistics.\n+         * @param column   column.\n+         * @return column cardinality in percents.\n+         */\n+        private int getColumnCardinality(@Nullable ColumnStatistics colStats, Column column) {\n+            return (colStats == null) ? column.getSelectivity() : colStats.cardinality();\n+        }\n+\n+        /**\n+         * Get total number of values in column.\n+         *\n+         * @param colStats column statistics.\n+         * @param rowCount total row count in table.\n+         * @param nulls    if {@code true} - try to estimate only nulls count,\n+         *                 if @{code false} - try to estimate only non null count,\n+         *                 if {@code null} - try to estimate total count of values.\n+         * @return column value count.\n+         */\n+        private long getColumnSize(@Nullable ColumnStatistics colStats, long rowCount, Boolean nulls) {\n+            if (colStats == null)\n+                return rowCount;\n+            else if (nulls == null)\n+                return colStats.total();\n+            else if (nulls)\n+                return colStats.total() * colStats.nulls() / 100;\n+            else\n+                return colStats.total() * (100 - colStats.nulls()) / 100;\n+        }\n+\n+        private Value getEqualValue(Session ses, Column column, TableFilter filter) {\n+            Value maxValue = null;\n+            for (IndexCondition cond : filter.getIndexConditions()) {\n+                if (!column.equals(cond.getColumn()))\n+                    continue;\n+\n+                if (isByteFlag(cond.getCompareType(), Comparison.EQUAL) && cond.isEvaluatable()) {\n+\n+                    Expression expr = cond.getExpression();\n+                    if (expr != null && expr.isConstant()) {\n+                        Value curVal = cond.getCurrentValue(ses);\n+                        if (null == maxValue || (curVal != null || filter.getTable().compareValues(curVal, maxValue) < 0))\n+                            maxValue = curVal;\n+                    }\n+                }\n+            }\n+            return maxValue;\n+        }\n+\n+        private Value getStartValue(Session ses, Column column, TableFilter filter) {\n+            if (filter == null)\n+                return null;\n+            Value maxValue = null;\n+            for (IndexCondition cond : filter.getIndexConditions()) {\n+                if (!column.equals(cond.getColumn()))\n+                    continue;\n+\n+                if ((isByteFlag(cond.getCompareType(), Comparison.BIGGER)\n+                        || isByteFlag(cond.getCompareType(), Comparison.BIGGER_EQUAL))\n+                        && cond.isEvaluatable()) {\n+\n+                    Expression expr = cond.getExpression();\n+                    if (expr != null && expr.isConstant()) {\n+                        Value curVal = cond.getCurrentValue(ses);\n+                        if (null == maxValue || (curVal != null || filter.getTable().compareValues(curVal, maxValue) < 0))\n+                            maxValue = curVal;\n+                    }\n+                }\n+            }\n+            return maxValue;\n+        }\n+\n+        private Value getEndValue(Session ses, Column column, TableFilter filter) {\n+            if (filter == null)\n+                return null;\n+            Value minValue = null;\n+            for (IndexCondition cond : filter.getIndexConditions()) {\n+                if (!column.equals(cond.getColumn()))\n+                    continue;\n+\n+                if ((isByteFlag(cond.getCompareType(), Comparison.SMALLER)\n+                        || isByteFlag(cond.getCompareType(), Comparison.SMALLER_EQUAL))\n+                        && cond.isEvaluatable()) {\n+                    Expression expr = cond.getExpression();\n+                    if (expr != null && expr.isConstant()) {\n+                        Value curVal = cond.getCurrentValue(ses);\n+                        if (null == minValue || (curVal != null || filter.getTable().compareValues(minValue, curVal) < 0))\n+                            minValue = curVal;\n+                    }\n+                }\n+            }\n+            return minValue;\n+        }\n+\n+        /**\n+         * Check if specified filter compare specified column to not null.\n+         *\n+         * @param ses    session to resolv values\n+         * @param column column to check\n+         * @param filter filter\n+         * @return {@code true} if column value should be null, {@code falce} otherwise (or if it not sure)\n+         */\n+        private boolean isNotNullFilter(Session ses, Column column, TableFilter filter) {\n+            // TODO: check not null expression (TableFilter contains only fullCondition without getter to check it)\n+            return false;\n+        }\n+\n+        /**\n+         * Check if specified filter compare specified column to null.\n+         *\n+         * @param ses    session to resolv values\n+         * @param column column to check\n+         * @param filter filter\n+         * @return {@code true} if column value should be null, {@code falce} otherwise (or if it not sure)\n+         */\n+        private boolean isNullFilter(Session ses, Column column, TableFilter filter) {\n+            if (filter == null)\n+                return false;\n+            for (IndexCondition cond : filter.getIndexConditions()) {\n+                if (column.equals(cond.getColumn()))\n+                    continue;\n+\n+                if (isByteFlag(cond.getCompareType(), Comparison.SPATIAL_INTERSECTS) && cond.isEvaluatable()) {\n+                    Expression expr = cond.getExpression();\n+\n+                    if (expr != null && expr.isConstant()) {\n+                        Value curVal = cond.getCurrentValue(ses);\n+\n+                        if (curVal != null && curVal.getValueType() == Value.NULL)\n+                            return true;\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+\n+        /**\n+         * Test if value contains all masks bits.\n+         *\n+         * @param value value to test.\n+         * @param mask  mask to test by.\n+         * @return {@code true} if value contains all necessary bits, {@code false} otherwise.\n+         */\n+        private boolean isByteFlag(int value, int mask) {\n+            return (value & mask) == mask;\n+        }\n+\n+        /**\n+         * Estimate percent of selected rows by specified min/max conditions (of total rows, with nulls).\n+         *\n+         * @param colStat column statistics to use, if exists.\n+         * @param min     lower border.\n+         * @param max     higher border.\n+         * @return percent of rows, selected with specified conditions (0-100)\n+         */\n+        private int estimatePercent(ColumnStatistics colStat, Value min, Value max) {\n+            if (colStat == null || colStat.min() == null || colStat.max() == null)\n+                // Fall back to previous behaviour without statistics, even without min/max testing\n+                return estimatePercentFallback(min, max);\n+\n+            BigDecimal minValue = (min == null) ? null : getComparableValue(min);\n+            BigDecimal maxValue = (max == null) ? null : getComparableValue(max);\n+\n+            if (minValue == null && maxValue == null)\n+                return estimatePercentFallback(min, max);\n+\n+            BigDecimal minStat = getComparableValue(colStat.min());\n+            BigDecimal maxStat = getComparableValue(colStat.max());\n+\n+            if (minStat == null || maxStat == null)\n+                return estimatePercentFallback(min, max);\n+\n+            BigDecimal start = (minValue == null || minValue.compareTo(minStat) < 0) ? minStat : minValue;\n+            BigDecimal end = (maxValue == null || maxValue.compareTo(maxStat) > 0) ? maxStat : maxValue;\n+\n+            BigDecimal actual = end.subtract(start);\n+\n+            if (actual.signum() < 0)\n+                return 0;\n+\n+            BigDecimal total = maxStat.subtract(minStat);\n+\n+            if (total.signum() < 0)\n+                return estimatePercentFallback(min, max);\n+\n+            if (total.signum() == 0)\n+                return (minStat.equals(min)) ? 100 : 0;\n+\n+            int result = actual.multiply(BigDecimal.valueOf(100 - colStat.nulls())).divide(total, MATH_CONTEXT).intValue();\n+            return result > 100 ? 100 : result;\n+        }\n+\n+        private int estimatePercentFallback(Value min, Value max) {\n+            return (min == null || max == null) ? RANGE_OPEN_SELECTIVITY_LAST : RANGE_CLOSE_SELECTIVITY_LAST;\n+        }\n+\n+        /**\n+         * Convert specified value into comparable type: BigDecimal,\n+         *\n+         * @param value\n+         * @return\n+         */\n+        private BigDecimal getComparableValue(Value value) {\n+            switch (value.getValueType()) {\n+                case Value.NULL:\n+                    throw new IllegalArgumentException(\"Can't compare null values\");\n+\n+                case Value.BOOLEAN:\n+                    return new BigDecimal(value.getBoolean() ? 1 : 0);\n+\n+                case Value.BYTE:\n+                    return new BigDecimal(value.getByte());\n+\n+                case Value.SHORT:\n+                    return new BigDecimal(value.getShort());\n+\n+                case Value.INT:\n+                    return new BigDecimal(value.getInt());\n+\n+                case Value.LONG:\n+                    return new BigDecimal(value.getLong());\n+\n+                case Value.DECIMAL:\n+                    return value.getBigDecimal();\n+\n+                case Value.DOUBLE:\n+                    return new BigDecimal(value.getDouble());\n+\n+                case Value.FLOAT:\n+                    return new BigDecimal(value.getFloat());\n+\n+                case Value.DATE:\n+                    return new BigDecimal(value.getDate().getTime());\n+\n+                case Value.TIME:\n+                    return new BigDecimal(value.getTime().getTime());\n+\n+                case Value.TIMESTAMP:\n+                    return new BigDecimal(value.getTimestamp().getTime());\n+\n+                case Value.BYTES:\n+                    BigInteger bigInteger = new BigInteger(1, value.getBytes());\n+                    return new BigDecimal(bigInteger);\n+\n+                case Value.STRING:\n+                case Value.STRING_FIXED:\n+                case Value.STRING_IGNORECASE:\n+                    return null;\n+\n+                case Value.ROW: // Intentionally converts Value.ROW to GridH2Array to preserve compatibility\n+                case Value.ARRAY:\n+                    return null;\n+\n+                case Value.JAVA_OBJECT:\n+                    return null;\n+\n+                case Value.UUID:\n+                    BigInteger bigInt = new BigInteger(1, value.getBytes());\n+                    return new BigDecimal(bigInt);\n+\n+                case Value.GEOMETRY:\n+                    return null;\n+\n+                default:\n+                    throw new IllegalStateException(\"Unsupported H2 type: \" + value.getType());\n+            }\n+        }\n+\n+        private ColumnStatistics getColumnStatistics(@Nullable ObjectStatisticsImpl locTblStats, Column column) {\n+            return (locTblStats == null) ? null : locTblStats.columnStatistics(column.getName());\n+        }\n+\n+        private long getCostRangeIndexSortingCost_Last(long rowCount, TableFilter[] filters, int filter,\n+                                                       SortOrder sortOrder, boolean isScanIndex) {\n+            long sortingCost = 0;\n+\n+            if (sortOrder != null)\n+                sortingCost = 100 + rowCount / 10;\n+\n+            if (sortOrder != null && !isScanIndex) {", "originalCommit": "6e542dba4c81179ed1a8fab253f3a1fb85c02eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTIwODA2Nw==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r509208067", "bodyText": "BTW this will always be false because you are comparing BigDec with Value", "author": "korlov42", "createdAt": "2020-10-21T11:42:12Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/opt/H2IndexCostedBase.java", "diffHunk": "@@ -641,22 +664,558 @@ else if (needsToReadFromScanIndex)\n          * Cost function.\n          * See more: {@link BaseIndex#getCostRangeIndex}.\n          */\n-        long getCostRangeIndex(int[] masks, long rowCount,\n-            TableFilter[] filters, int filter, SortOrder sortOrder,\n-            boolean isScanIndex, AllColumnsForPlan allColumnsSet);\n+        long getCostRangeIndex(Session ses, int[] masks, long rowCount,\n+                               TableFilter[] filters, int filter, SortOrder sortOrder,\n+                               boolean isScanIndex, AllColumnsForPlan allColumnsSet);\n     }\n \n     /**\n      *\n      */\n     private enum CostFunctionType {\n-        /** Last. */\n+        /**\n+         * Last.\n+         */\n         LAST,\n \n-        /** Compatible with ver. 8.7.12. */\n+        /**\n+         * Compatible with ver. 8.7.28\n+         */\n+        COMPATIBLE_8_7_28,\n+\n+        /**\n+         * Compatible with ver. 8.7.12.\n+         */\n         COMPATIBLE_8_7_12,\n \n-        /** Compatible with ver. 8.7.6. */\n+        /**\n+         * Compatible with ver. 8.7.6.\n+         */\n         COMPATIBLE_8_7_6\n     }\n+\n+    private final class CostFunctionLast {\n+        /**\n+         * Math context to use in estimations calculations.\n+         */\n+        private final MathContext MATH_CONTEXT = MathContext.DECIMAL64;\n+\n+        /**\n+         * Selectivity for closed range queries, in percent\n+         */\n+        private final int RANGE_CLOSE_SELECTIVITY_LAST = 25;\n+\n+        /**\n+         * Selectivity for open range queries, in percent\n+         */\n+        private final int RANGE_OPEN_SELECTIVITY_LAST = 33;\n+\n+        private long getCostRangeIndexRowCost_Last(Session ses, TableFilter filter, int[] masks, long rowCount,\n+                                                   ObjectStatisticsImpl locTblStats) {\n+            int totalCardinality = 0;\n+\n+            long rowsCost = rowCount;\n+\n+            if (masks != null) {\n+                int i = 0, len = columns.length;\n+\n+                while (i < len) {\n+                    Column column = columns[i++];\n+                    ColumnStatistics colStats = getColumnStatistics(locTblStats, column);\n+\n+                    int index = column.getColumnId();\n+                    int mask = masks[index];\n+\n+                    if (isByteFlag(mask, IndexCondition.EQUALITY)) {\n+                        if (i == len && getIndexType().isUnique()) {\n+                            rowsCost = 3;\n+\n+                            break;\n+                        }\n+                        // Estimate by is null\n+\n+                        Value equalValue = getEqualValue(ses, column, filter);\n+                        Boolean equalNull = (equalValue == null) ? null : equalValue.getValueType() == Value.NULL;\n+                        rowCount = getColumnSize(colStats, rowCount, equalNull);\n+\n+                        if (colStats != null && equalNull == Boolean.TRUE) {\n+                            rowsCost = Math.min(5 + Math.max(rowsCost * colStats.nulls() / 100, 1), rowsCost - (i > 0 ? 1 : 0));\n+                            continue;\n+                        }\n+                        if (colStats != null && equalNull == Boolean.FALSE)\n+                            rowsCost = rowsCost * (100 - colStats.nulls()) / 100;\n+\n+                        int cardinality = getColumnCardinality(colStats, column);\n+\n+                        totalCardinality = 100 - ((100 - totalCardinality) * (100 - cardinality) / 100);\n+\n+                        long distinctRows = Math.round((double) rowCount * totalCardinality / 100);\n+\n+                        if (distinctRows <= 0)\n+                            distinctRows = 1;\n+\n+                        if (colStats != null && equalNull != null)\n+                            distinctRows = distinctRows * 100 / (100 - colStats.nulls());\n+\n+                        rowsCost = Math.min(5 + Math.max(rowsCost / distinctRows, 1), rowsCost - (i > 0 ? 1 : 0));\n+                    } else if (isByteFlag(mask, IndexCondition.RANGE)) {\n+                        Value min = getStartValue(ses, column, filter);\n+                        Value max = getEndValue(ses, column, filter);\n+                        int percent = estimatePercent(colStats, min, max);\n+\n+                        rowsCost = Math.min(5 + rowsCost * percent / 100, rowsCost - (i > 0 ? 1 : 0));\n+\n+                        break;\n+                    } else if (isByteFlag(mask, IndexCondition.START)) {\n+                        Value min = getStartValue(ses, column, filter);\n+                        Value max = getEndValue(ses, column, filter);\n+                        int percent = estimatePercent(colStats, min, max);\n+\n+                        rowsCost = Math.min(5 + rowsCost * percent / 100, rowsCost - (i > 0 ? 1 : 0));\n+\n+                        break;\n+                    } else if (isByteFlag(mask, IndexCondition.END)) {\n+                        Value min = getStartValue(ses, column, filter);\n+                        Value max = getEndValue(ses, column, filter);\n+                        int percent = estimatePercent(colStats, min, max);\n+\n+                        rowsCost = Math.min(5 + rowsCost * percent / 100, rowsCost - (i > 0 ? 1 : 0));\n+\n+                        break;\n+                    } else if (isNullFilter(ses, column, filter)) {\n+                        if (colStats != null)\n+                            rowsCost = Math.min(5 + Math.max(rowsCost * colStats.nulls() / 100, 1), rowsCost - (i > 0 ? 1 : 0));\n+                    } else if (isNotNullFilter(ses, column, filter)) {\n+                        if (colStats != null)\n+                            rowsCost = Math.min(5 + Math.max(rowsCost * (100 - colStats.nulls()) / 100, 1), rowsCost - (i > 0 ? 1 : 0));\n+                    } else\n+                        break;\n+                }\n+            }\n+            return rowsCost;\n+        }\n+\n+        /**\n+         * Try to get column cardinality from statistics, if there is no such - fall back to H2 column selectivity.\n+         *\n+         * @param colStats column statistics.\n+         * @param column   column.\n+         * @return column cardinality in percents.\n+         */\n+        private int getColumnCardinality(@Nullable ColumnStatistics colStats, Column column) {\n+            return (colStats == null) ? column.getSelectivity() : colStats.cardinality();\n+        }\n+\n+        /**\n+         * Get total number of values in column.\n+         *\n+         * @param colStats column statistics.\n+         * @param rowCount total row count in table.\n+         * @param nulls    if {@code true} - try to estimate only nulls count,\n+         *                 if @{code false} - try to estimate only non null count,\n+         *                 if {@code null} - try to estimate total count of values.\n+         * @return column value count.\n+         */\n+        private long getColumnSize(@Nullable ColumnStatistics colStats, long rowCount, Boolean nulls) {\n+            if (colStats == null)\n+                return rowCount;\n+            else if (nulls == null)\n+                return colStats.total();\n+            else if (nulls)\n+                return colStats.total() * colStats.nulls() / 100;\n+            else\n+                return colStats.total() * (100 - colStats.nulls()) / 100;\n+        }\n+\n+        private Value getEqualValue(Session ses, Column column, TableFilter filter) {\n+            Value maxValue = null;\n+            for (IndexCondition cond : filter.getIndexConditions()) {\n+                if (!column.equals(cond.getColumn()))\n+                    continue;\n+\n+                if (isByteFlag(cond.getCompareType(), Comparison.EQUAL) && cond.isEvaluatable()) {\n+\n+                    Expression expr = cond.getExpression();\n+                    if (expr != null && expr.isConstant()) {\n+                        Value curVal = cond.getCurrentValue(ses);\n+                        if (null == maxValue || (curVal != null || filter.getTable().compareValues(curVal, maxValue) < 0))\n+                            maxValue = curVal;\n+                    }\n+                }\n+            }\n+            return maxValue;\n+        }\n+\n+        private Value getStartValue(Session ses, Column column, TableFilter filter) {\n+            if (filter == null)\n+                return null;\n+            Value maxValue = null;\n+            for (IndexCondition cond : filter.getIndexConditions()) {\n+                if (!column.equals(cond.getColumn()))\n+                    continue;\n+\n+                if ((isByteFlag(cond.getCompareType(), Comparison.BIGGER)\n+                        || isByteFlag(cond.getCompareType(), Comparison.BIGGER_EQUAL))\n+                        && cond.isEvaluatable()) {\n+\n+                    Expression expr = cond.getExpression();\n+                    if (expr != null && expr.isConstant()) {\n+                        Value curVal = cond.getCurrentValue(ses);\n+                        if (null == maxValue || (curVal != null || filter.getTable().compareValues(curVal, maxValue) < 0))\n+                            maxValue = curVal;\n+                    }\n+                }\n+            }\n+            return maxValue;\n+        }\n+\n+        private Value getEndValue(Session ses, Column column, TableFilter filter) {\n+            if (filter == null)\n+                return null;\n+            Value minValue = null;\n+            for (IndexCondition cond : filter.getIndexConditions()) {\n+                if (!column.equals(cond.getColumn()))\n+                    continue;\n+\n+                if ((isByteFlag(cond.getCompareType(), Comparison.SMALLER)\n+                        || isByteFlag(cond.getCompareType(), Comparison.SMALLER_EQUAL))\n+                        && cond.isEvaluatable()) {\n+                    Expression expr = cond.getExpression();\n+                    if (expr != null && expr.isConstant()) {\n+                        Value curVal = cond.getCurrentValue(ses);\n+                        if (null == minValue || (curVal != null || filter.getTable().compareValues(minValue, curVal) < 0))\n+                            minValue = curVal;\n+                    }\n+                }\n+            }\n+            return minValue;\n+        }\n+\n+        /**\n+         * Check if specified filter compare specified column to not null.\n+         *\n+         * @param ses    session to resolv values\n+         * @param column column to check\n+         * @param filter filter\n+         * @return {@code true} if column value should be null, {@code falce} otherwise (or if it not sure)\n+         */\n+        private boolean isNotNullFilter(Session ses, Column column, TableFilter filter) {\n+            // TODO: check not null expression (TableFilter contains only fullCondition without getter to check it)\n+            return false;\n+        }\n+\n+        /**\n+         * Check if specified filter compare specified column to null.\n+         *\n+         * @param ses    session to resolv values\n+         * @param column column to check\n+         * @param filter filter\n+         * @return {@code true} if column value should be null, {@code falce} otherwise (or if it not sure)\n+         */\n+        private boolean isNullFilter(Session ses, Column column, TableFilter filter) {\n+            if (filter == null)\n+                return false;\n+            for (IndexCondition cond : filter.getIndexConditions()) {\n+                if (column.equals(cond.getColumn()))\n+                    continue;\n+\n+                if (isByteFlag(cond.getCompareType(), Comparison.SPATIAL_INTERSECTS) && cond.isEvaluatable()) {\n+                    Expression expr = cond.getExpression();\n+\n+                    if (expr != null && expr.isConstant()) {\n+                        Value curVal = cond.getCurrentValue(ses);\n+\n+                        if (curVal != null && curVal.getValueType() == Value.NULL)\n+                            return true;\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+\n+        /**\n+         * Test if value contains all masks bits.\n+         *\n+         * @param value value to test.\n+         * @param mask  mask to test by.\n+         * @return {@code true} if value contains all necessary bits, {@code false} otherwise.\n+         */\n+        private boolean isByteFlag(int value, int mask) {\n+            return (value & mask) == mask;\n+        }\n+\n+        /**\n+         * Estimate percent of selected rows by specified min/max conditions (of total rows, with nulls).\n+         *\n+         * @param colStat column statistics to use, if exists.\n+         * @param min     lower border.\n+         * @param max     higher border.\n+         * @return percent of rows, selected with specified conditions (0-100)\n+         */\n+        private int estimatePercent(ColumnStatistics colStat, Value min, Value max) {\n+            if (colStat == null || colStat.min() == null || colStat.max() == null)\n+                // Fall back to previous behaviour without statistics, even without min/max testing\n+                return estimatePercentFallback(min, max);\n+\n+            BigDecimal minValue = (min == null) ? null : getComparableValue(min);\n+            BigDecimal maxValue = (max == null) ? null : getComparableValue(max);\n+\n+            if (minValue == null && maxValue == null)\n+                return estimatePercentFallback(min, max);\n+\n+            BigDecimal minStat = getComparableValue(colStat.min());\n+            BigDecimal maxStat = getComparableValue(colStat.max());\n+\n+            if (minStat == null || maxStat == null)\n+                return estimatePercentFallback(min, max);\n+\n+            BigDecimal start = (minValue == null || minValue.compareTo(minStat) < 0) ? minStat : minValue;\n+            BigDecimal end = (maxValue == null || maxValue.compareTo(maxStat) > 0) ? maxStat : maxValue;\n+\n+            BigDecimal actual = end.subtract(start);\n+\n+            if (actual.signum() < 0)\n+                return 0;\n+\n+            BigDecimal total = maxStat.subtract(minStat);\n+\n+            if (total.signum() < 0)\n+                return estimatePercentFallback(min, max);\n+\n+            if (total.signum() == 0)\n+                return (minStat.equals(min)) ? 100 : 0;", "originalCommit": "6e542dba4c81179ed1a8fab253f3a1fb85c02eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTIxNDI2NA==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r509214264", "bodyText": "Consider the following case: you try to query some values with condition col1 in range 0..100, but stats claims that all values belongs to range 200..300 and there is no nulls. It seems in this particular case estimatePercent returns 100, but actually no rows should be returned, so correct estimation is 0", "author": "korlov42", "createdAt": "2020-10-21T11:52:53Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/opt/H2IndexCostedBase.java", "diffHunk": "@@ -641,22 +664,558 @@ else if (needsToReadFromScanIndex)\n          * Cost function.\n          * See more: {@link BaseIndex#getCostRangeIndex}.\n          */\n-        long getCostRangeIndex(int[] masks, long rowCount,\n-            TableFilter[] filters, int filter, SortOrder sortOrder,\n-            boolean isScanIndex, AllColumnsForPlan allColumnsSet);\n+        long getCostRangeIndex(Session ses, int[] masks, long rowCount,\n+                               TableFilter[] filters, int filter, SortOrder sortOrder,\n+                               boolean isScanIndex, AllColumnsForPlan allColumnsSet);\n     }\n \n     /**\n      *\n      */\n     private enum CostFunctionType {\n-        /** Last. */\n+        /**\n+         * Last.\n+         */\n         LAST,\n \n-        /** Compatible with ver. 8.7.12. */\n+        /**\n+         * Compatible with ver. 8.7.28\n+         */\n+        COMPATIBLE_8_7_28,\n+\n+        /**\n+         * Compatible with ver. 8.7.12.\n+         */\n         COMPATIBLE_8_7_12,\n \n-        /** Compatible with ver. 8.7.6. */\n+        /**\n+         * Compatible with ver. 8.7.6.\n+         */\n         COMPATIBLE_8_7_6\n     }\n+\n+    private final class CostFunctionLast {\n+        /**\n+         * Math context to use in estimations calculations.\n+         */\n+        private final MathContext MATH_CONTEXT = MathContext.DECIMAL64;\n+\n+        /**\n+         * Selectivity for closed range queries, in percent\n+         */\n+        private final int RANGE_CLOSE_SELECTIVITY_LAST = 25;\n+\n+        /**\n+         * Selectivity for open range queries, in percent\n+         */\n+        private final int RANGE_OPEN_SELECTIVITY_LAST = 33;\n+\n+        private long getCostRangeIndexRowCost_Last(Session ses, TableFilter filter, int[] masks, long rowCount,\n+                                                   ObjectStatisticsImpl locTblStats) {\n+            int totalCardinality = 0;\n+\n+            long rowsCost = rowCount;\n+\n+            if (masks != null) {\n+                int i = 0, len = columns.length;\n+\n+                while (i < len) {\n+                    Column column = columns[i++];\n+                    ColumnStatistics colStats = getColumnStatistics(locTblStats, column);\n+\n+                    int index = column.getColumnId();\n+                    int mask = masks[index];\n+\n+                    if (isByteFlag(mask, IndexCondition.EQUALITY)) {\n+                        if (i == len && getIndexType().isUnique()) {\n+                            rowsCost = 3;\n+\n+                            break;\n+                        }\n+                        // Estimate by is null\n+\n+                        Value equalValue = getEqualValue(ses, column, filter);\n+                        Boolean equalNull = (equalValue == null) ? null : equalValue.getValueType() == Value.NULL;\n+                        rowCount = getColumnSize(colStats, rowCount, equalNull);\n+\n+                        if (colStats != null && equalNull == Boolean.TRUE) {\n+                            rowsCost = Math.min(5 + Math.max(rowsCost * colStats.nulls() / 100, 1), rowsCost - (i > 0 ? 1 : 0));\n+                            continue;\n+                        }\n+                        if (colStats != null && equalNull == Boolean.FALSE)\n+                            rowsCost = rowsCost * (100 - colStats.nulls()) / 100;\n+\n+                        int cardinality = getColumnCardinality(colStats, column);\n+\n+                        totalCardinality = 100 - ((100 - totalCardinality) * (100 - cardinality) / 100);\n+\n+                        long distinctRows = Math.round((double) rowCount * totalCardinality / 100);\n+\n+                        if (distinctRows <= 0)\n+                            distinctRows = 1;\n+\n+                        if (colStats != null && equalNull != null)\n+                            distinctRows = distinctRows * 100 / (100 - colStats.nulls());\n+\n+                        rowsCost = Math.min(5 + Math.max(rowsCost / distinctRows, 1), rowsCost - (i > 0 ? 1 : 0));\n+                    } else if (isByteFlag(mask, IndexCondition.RANGE)) {\n+                        Value min = getStartValue(ses, column, filter);\n+                        Value max = getEndValue(ses, column, filter);\n+                        int percent = estimatePercent(colStats, min, max);\n+\n+                        rowsCost = Math.min(5 + rowsCost * percent / 100, rowsCost - (i > 0 ? 1 : 0));\n+\n+                        break;\n+                    } else if (isByteFlag(mask, IndexCondition.START)) {\n+                        Value min = getStartValue(ses, column, filter);\n+                        Value max = getEndValue(ses, column, filter);\n+                        int percent = estimatePercent(colStats, min, max);\n+\n+                        rowsCost = Math.min(5 + rowsCost * percent / 100, rowsCost - (i > 0 ? 1 : 0));\n+\n+                        break;\n+                    } else if (isByteFlag(mask, IndexCondition.END)) {\n+                        Value min = getStartValue(ses, column, filter);\n+                        Value max = getEndValue(ses, column, filter);\n+                        int percent = estimatePercent(colStats, min, max);\n+\n+                        rowsCost = Math.min(5 + rowsCost * percent / 100, rowsCost - (i > 0 ? 1 : 0));\n+\n+                        break;\n+                    } else if (isNullFilter(ses, column, filter)) {\n+                        if (colStats != null)\n+                            rowsCost = Math.min(5 + Math.max(rowsCost * colStats.nulls() / 100, 1), rowsCost - (i > 0 ? 1 : 0));\n+                    } else if (isNotNullFilter(ses, column, filter)) {\n+                        if (colStats != null)\n+                            rowsCost = Math.min(5 + Math.max(rowsCost * (100 - colStats.nulls()) / 100, 1), rowsCost - (i > 0 ? 1 : 0));\n+                    } else\n+                        break;\n+                }\n+            }\n+            return rowsCost;\n+        }\n+\n+        /**\n+         * Try to get column cardinality from statistics, if there is no such - fall back to H2 column selectivity.\n+         *\n+         * @param colStats column statistics.\n+         * @param column   column.\n+         * @return column cardinality in percents.\n+         */\n+        private int getColumnCardinality(@Nullable ColumnStatistics colStats, Column column) {\n+            return (colStats == null) ? column.getSelectivity() : colStats.cardinality();\n+        }\n+\n+        /**\n+         * Get total number of values in column.\n+         *\n+         * @param colStats column statistics.\n+         * @param rowCount total row count in table.\n+         * @param nulls    if {@code true} - try to estimate only nulls count,\n+         *                 if @{code false} - try to estimate only non null count,\n+         *                 if {@code null} - try to estimate total count of values.\n+         * @return column value count.\n+         */\n+        private long getColumnSize(@Nullable ColumnStatistics colStats, long rowCount, Boolean nulls) {\n+            if (colStats == null)\n+                return rowCount;\n+            else if (nulls == null)\n+                return colStats.total();\n+            else if (nulls)\n+                return colStats.total() * colStats.nulls() / 100;\n+            else\n+                return colStats.total() * (100 - colStats.nulls()) / 100;\n+        }\n+\n+        private Value getEqualValue(Session ses, Column column, TableFilter filter) {\n+            Value maxValue = null;\n+            for (IndexCondition cond : filter.getIndexConditions()) {\n+                if (!column.equals(cond.getColumn()))\n+                    continue;\n+\n+                if (isByteFlag(cond.getCompareType(), Comparison.EQUAL) && cond.isEvaluatable()) {\n+\n+                    Expression expr = cond.getExpression();\n+                    if (expr != null && expr.isConstant()) {\n+                        Value curVal = cond.getCurrentValue(ses);\n+                        if (null == maxValue || (curVal != null || filter.getTable().compareValues(curVal, maxValue) < 0))\n+                            maxValue = curVal;\n+                    }\n+                }\n+            }\n+            return maxValue;\n+        }\n+\n+        private Value getStartValue(Session ses, Column column, TableFilter filter) {\n+            if (filter == null)\n+                return null;\n+            Value maxValue = null;\n+            for (IndexCondition cond : filter.getIndexConditions()) {\n+                if (!column.equals(cond.getColumn()))\n+                    continue;\n+\n+                if ((isByteFlag(cond.getCompareType(), Comparison.BIGGER)\n+                        || isByteFlag(cond.getCompareType(), Comparison.BIGGER_EQUAL))\n+                        && cond.isEvaluatable()) {\n+\n+                    Expression expr = cond.getExpression();\n+                    if (expr != null && expr.isConstant()) {\n+                        Value curVal = cond.getCurrentValue(ses);\n+                        if (null == maxValue || (curVal != null || filter.getTable().compareValues(curVal, maxValue) < 0))\n+                            maxValue = curVal;\n+                    }\n+                }\n+            }\n+            return maxValue;\n+        }\n+\n+        private Value getEndValue(Session ses, Column column, TableFilter filter) {\n+            if (filter == null)\n+                return null;\n+            Value minValue = null;\n+            for (IndexCondition cond : filter.getIndexConditions()) {\n+                if (!column.equals(cond.getColumn()))\n+                    continue;\n+\n+                if ((isByteFlag(cond.getCompareType(), Comparison.SMALLER)\n+                        || isByteFlag(cond.getCompareType(), Comparison.SMALLER_EQUAL))\n+                        && cond.isEvaluatable()) {\n+                    Expression expr = cond.getExpression();\n+                    if (expr != null && expr.isConstant()) {\n+                        Value curVal = cond.getCurrentValue(ses);\n+                        if (null == minValue || (curVal != null || filter.getTable().compareValues(minValue, curVal) < 0))\n+                            minValue = curVal;\n+                    }\n+                }\n+            }\n+            return minValue;\n+        }\n+\n+        /**\n+         * Check if specified filter compare specified column to not null.\n+         *\n+         * @param ses    session to resolv values\n+         * @param column column to check\n+         * @param filter filter\n+         * @return {@code true} if column value should be null, {@code falce} otherwise (or if it not sure)\n+         */\n+        private boolean isNotNullFilter(Session ses, Column column, TableFilter filter) {\n+            // TODO: check not null expression (TableFilter contains only fullCondition without getter to check it)\n+            return false;\n+        }\n+\n+        /**\n+         * Check if specified filter compare specified column to null.\n+         *\n+         * @param ses    session to resolv values\n+         * @param column column to check\n+         * @param filter filter\n+         * @return {@code true} if column value should be null, {@code falce} otherwise (or if it not sure)\n+         */\n+        private boolean isNullFilter(Session ses, Column column, TableFilter filter) {\n+            if (filter == null)\n+                return false;\n+            for (IndexCondition cond : filter.getIndexConditions()) {\n+                if (column.equals(cond.getColumn()))\n+                    continue;\n+\n+                if (isByteFlag(cond.getCompareType(), Comparison.SPATIAL_INTERSECTS) && cond.isEvaluatable()) {\n+                    Expression expr = cond.getExpression();\n+\n+                    if (expr != null && expr.isConstant()) {\n+                        Value curVal = cond.getCurrentValue(ses);\n+\n+                        if (curVal != null && curVal.getValueType() == Value.NULL)\n+                            return true;\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+\n+        /**\n+         * Test if value contains all masks bits.\n+         *\n+         * @param value value to test.\n+         * @param mask  mask to test by.\n+         * @return {@code true} if value contains all necessary bits, {@code false} otherwise.\n+         */\n+        private boolean isByteFlag(int value, int mask) {\n+            return (value & mask) == mask;\n+        }\n+\n+        /**\n+         * Estimate percent of selected rows by specified min/max conditions (of total rows, with nulls).\n+         *\n+         * @param colStat column statistics to use, if exists.\n+         * @param min     lower border.\n+         * @param max     higher border.\n+         * @return percent of rows, selected with specified conditions (0-100)\n+         */\n+        private int estimatePercent(ColumnStatistics colStat, Value min, Value max) {", "originalCommit": "6e542dba4c81179ed1a8fab253f3a1fb85c02eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7a928182c4099d699896433eb8632ce998d29c8e", "url": "https://github.com/gridgain/gridgain/commit/7a928182c4099d699896433eb8632ce998d29c8e", "message": "GG-18652: minor fixes", "committedDate": "2020-10-21T13:30:55Z", "type": "commit"}, {"oid": "abbe4d464f68c0e155da54ab9c3c98ec997e2eac", "url": "https://github.com/gridgain/gridgain/commit/abbe4d464f68c0e155da54ab9c3c98ec997e2eac", "message": "GG-18652: minor fixes", "committedDate": "2020-10-31T06:52:59Z", "type": "commit"}, {"oid": "078a8a69f83a8c1e9ab3c53e710914dc66c290ea", "url": "https://github.com/gridgain/gridgain/commit/078a8a69f83a8c1e9ab3c53e710914dc66c290ea", "message": "Merge remote-tracking branch 'gridgain-ce/master' into gg-18652", "committedDate": "2020-10-31T07:00:35Z", "type": "commit"}, {"oid": "247a5b5ad1ef395f57fc6293900b928b01ffcf0d", "url": "https://github.com/gridgain/gridgain/commit/247a5b5ad1ef395f57fc6293900b928b01ffcf0d", "message": "GG-18652: minor codestyle and comments; some changes in cost function", "committedDate": "2020-11-05T13:51:28Z", "type": "commit"}, {"oid": "30a45e15992853daf4731d327b4dd6084dec3328", "url": "https://github.com/gridgain/gridgain/commit/30a45e15992853daf4731d327b4dd6084dec3328", "message": "GG-18652: some more tests", "committedDate": "2020-11-05T19:23:41Z", "type": "commit"}, {"oid": "048b3a968a36fa00f17efa612cbace2d308aa3f4", "url": "https://github.com/gridgain/gridgain/commit/048b3a968a36fa00f17efa612cbace2d308aa3f4", "message": "Merge remote-tracking branch 'gridgain-ce/master' into gg-18652", "committedDate": "2020-11-05T19:24:06Z", "type": "commit"}, {"oid": "7df9b8b8ce61703fe956c4359917671da287d050", "url": "https://github.com/gridgain/gridgain/commit/7df9b8b8ce61703fe956c4359917671da287d050", "message": "GG-18652: add comments.", "committedDate": "2020-11-06T13:59:29Z", "type": "commit"}, {"oid": "b89199e9c31c035069377b664c1b28f65bcc3e65", "url": "https://github.com/gridgain/gridgain/commit/b89199e9c31c035069377b664c1b28f65bcc3e65", "message": "GG-18652: Codestyle.", "committedDate": "2020-11-09T13:26:26Z", "type": "commit"}, {"oid": "bd7b54c77f5706581c4af1f3f2e6cf5345ae2ff1", "url": "https://github.com/gridgain/gridgain/commit/bd7b54c77f5706581c4af1f3f2e6cf5345ae2ff1", "message": "GG-18652: licenses", "committedDate": "2020-11-09T14:52:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDU0MjY0MQ==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r520542641", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /** Percent of different values in column, i.e. 100 means that all values are unique, 0% means that all values\n          \n          \n            \n                 * are the same. */\n          \n          \n            \n                /**\n          \n          \n            \n                 * Percent of different values in column, i.e. 100 means that all values are unique, 0% means that all values\n          \n          \n            \n                 * are the same.\n          \n          \n            \n                 */", "author": "korlov42", "createdAt": "2020-11-10T12:59:29Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/ColumnStatistics.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import org.gridgain.internal.h2.value.Value;\n+\n+/**\n+ * Values statistic in particular column.\n+ */\n+public class ColumnStatistics {\n+    /** Minimum value in column or {@code null} if there are no non null values in the column. */\n+    private final Value min;\n+\n+    /** Maximum value in column or {@code null} if there are no non null values in the column. */\n+    private final Value max;\n+\n+    /** Percent of null values in column. */\n+    private final int nulls;\n+\n+    /** Percent of different values in column, i.e. 100 means that all values are unique, 0% means that all values\n+     * are the same. */", "originalCommit": "bd7b54c77f5706581c4af1f3f2e6cf5345ae2ff1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYzNTMyMg==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r520635322", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param tbl table to aggregate statistics by.\n          \n          \n            \n                 * @param tbl Table to aggregate statistics by.\n          \n      \n    \n    \n  \n\nhere and below", "author": "korlov42", "createdAt": "2020-11-10T15:08:31Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/IgniteStatisticsManagerImpl.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.processors.cache.distributed.dht.topology.GridDhtLocalPartition;\n+import org.apache.ignite.internal.processors.cache.persistence.CacheDataRow;\n+import org.apache.ignite.internal.processors.query.GridQueryTypeDescriptor;\n+import org.apache.ignite.internal.processors.query.h2.SchemaManager;\n+import org.apache.ignite.internal.processors.query.h2.opt.GridH2RowDescriptor;\n+import org.apache.ignite.internal.processors.query.h2.opt.GridH2Table;\n+import org.apache.ignite.internal.processors.query.h2.opt.H2Row;\n+import org.apache.ignite.internal.util.typedef.F;\n+import org.gridgain.internal.h2.table.Column;\n+\n+import static org.apache.ignite.internal.processors.cache.distributed.dht.topology.GridDhtPartitionState.MOVING;\n+import static org.apache.ignite.internal.processors.cache.distributed.dht.topology.GridDhtPartitionState.OWNING;\n+\n+/**\n+ * Statistics manager implementation.\n+ */\n+public class IgniteStatisticsManagerImpl implements IgniteStatisticsManager {\n+    /** Logger. */\n+    private IgniteLogger log;\n+\n+    /** Kernal context. */\n+    private final GridKernalContext ctx;\n+\n+    /** Schema manager. */\n+    private final SchemaManager schemaMgr;\n+\n+    /** Statistics repository. */\n+    private final IgniteStatisticsRepository statsRepos;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param ctx Kernal context.\n+     * @param schemaMgr Schema manager.\n+     */\n+    public IgniteStatisticsManagerImpl(GridKernalContext ctx, SchemaManager schemaMgr) {\n+        this.ctx = ctx;\n+        this.schemaMgr = schemaMgr;\n+\n+        log = ctx.log(IgniteStatisticsManagerImpl.class);\n+        statsRepos = new IgniteStatisticsRepositoryImpl(ctx);\n+    }\n+\n+    /**\n+     * @return Statistics repository.\n+     */\n+    public IgniteStatisticsRepository statisticsRepository() {\n+        return statsRepos;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public ObjectStatistics getLocalStatistics(String schemaName, String objName) {\n+        return statsRepos.getLocalStatistics(new StatsKey(schemaName, objName));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void clearObjectStatistics(String schemaName, String objName, String... colNames) {\n+        StatsKey key = new StatsKey(schemaName, objName);\n+        statsRepos.clearLocalPartitionsStatistics(key, colNames);\n+        statsRepos.clearLocalStatistics(key, colNames);\n+        statsRepos.clearGlobalStatistics(key, colNames);\n+    }\n+\n+    /**\n+     * Filter columns by specified names.\n+     *\n+     * @param columns Columns to filter.\n+     * @param colNames Column names.\n+     * @return Column with specified names.\n+     */\n+    private Column[] filterColumns(Column[] columns, String... colNames) {\n+        if (F.isEmpty(colNames))\n+            return columns;\n+\n+        Set<String> colNamesSet = new HashSet(Arrays.asList(colNames));\n+        List<Column> resultList = new ArrayList<>(colNames.length);\n+\n+        for (Column col : columns)\n+            if (colNamesSet.contains(col.getName()))\n+                resultList.add(col);\n+\n+        return resultList.toArray(new Column[resultList.size()]);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void collectObjectStatistics(String schemaName, String objName, String... colNames)\n+            throws IgniteCheckedException {\n+        GridH2Table tbl = schemaMgr.dataTable(schemaName, objName);\n+        if (tbl == null)\n+            throw new IllegalArgumentException(String.format(\"Can't find table %s.%s\", schemaName, objName));\n+\n+        if (log.isDebugEnabled())\n+            log.debug(String.format(\"Starting statistics collection by %s.%s object\", schemaName, objName));\n+\n+        Column[] selectedColumns;\n+        boolean fullStat;\n+        if (F.isEmpty(colNames)) {\n+            fullStat = true;\n+            selectedColumns = tbl.getColumns();\n+        } else {\n+            fullStat = false;\n+            selectedColumns = filterColumns(tbl.getColumns(), colNames);\n+        }\n+\n+        Collection<ObjectPartitionStatisticsImpl> partsStats = collectPartitionStatistics(tbl, selectedColumns);\n+        StatsKey key = new StatsKey(tbl.identifier().schema(), tbl.identifier().table());\n+        statsRepos.saveLocalPartitionsStatistics(key, partsStats, fullStat);\n+\n+        ObjectStatisticsImpl tblStats = aggregateLocalStatistics(tbl, selectedColumns, partsStats);\n+        statsRepos.saveLocalStatistics(key, tblStats, fullStat);\n+        if (log.isDebugEnabled())\n+            log.debug(String.format(\"Statistics collection by %s.%s object is finished.\", schemaName, objName));\n+    }\n+\n+    /**\n+     * Collect partition level statistics.\n+     *\n+     * @param tbl Table to collect statistics by.\n+     * @param selectedColumns Columns to collect statistics by.\n+     * @return Collection of partition level statistics by local primary partitions.\n+     * @throws IgniteCheckedException in case of error.\n+     */\n+    private Collection<ObjectPartitionStatisticsImpl> collectPartitionStatistics(GridH2Table tbl, Column[] selectedColumns)\n+            throws IgniteCheckedException {\n+        List<ObjectPartitionStatisticsImpl> tblPartStats = new ArrayList<>();\n+        GridH2RowDescriptor desc = tbl.rowDescriptor();\n+        String tblName = tbl.getName();\n+\n+        for (GridDhtLocalPartition locPart : tbl.cacheContext().topology().localPartitions()) {\n+            final boolean reserved = locPart.reserve();\n+\n+            try {\n+                if (!reserved || (locPart.state() != OWNING && locPart.state() != MOVING)\n+                        || !locPart.primary(ctx.discovery().topologyVersionEx()))\n+                    continue;\n+\n+                if (locPart.state() == MOVING)\n+                    tbl.cacheContext().preloader().syncFuture().get();\n+\n+                long rowsCnt = 0;\n+\n+                List<ColumnStatisticsCollector> colStatsCollectors = new ArrayList<>(selectedColumns.length);\n+\n+                for (Column col : selectedColumns)\n+                    colStatsCollectors.add(new ColumnStatisticsCollector(col, tbl::compareValues));\n+\n+                for (CacheDataRow row : tbl.cacheContext().offheap().cachePartitionIterator(tbl.cacheId(), locPart.id(),\n+                        null, true)) {\n+                    GridQueryTypeDescriptor typeDesc = ctx.query().typeByValue(tbl.cacheName(),\n+                            tbl.cacheContext().cacheObjectContext(), row.key(), row.value(), false);\n+                    if (!tblName.equals(typeDesc.tableName()))\n+                        continue;\n+\n+                    rowsCnt++;\n+\n+                    H2Row row0 = desc.createRow(row);\n+\n+                    for (ColumnStatisticsCollector colStat : colStatsCollectors)\n+                        colStat.add(row0.getValue(colStat.col().getColumnId()));\n+\n+                }\n+\n+                Map<String, ColumnStatistics> colStats = colStatsCollectors.stream().collect(Collectors.toMap(\n+                        csc -> csc.col().getName(), csc -> csc.finish()\n+                ));\n+\n+                tblPartStats.add(new ObjectPartitionStatisticsImpl(locPart.id(), true, rowsCnt,\n+                        locPart.updateCounter(), colStats));\n+            }\n+            finally {\n+                if (reserved)\n+                    locPart.release();\n+            }\n+        }\n+\n+        return tblPartStats;\n+    }\n+\n+    /**\n+     * Aggregate specified partition level statistics to local level statistics.\n+     *\n+     * @param key Aggregation key.\n+     * @param tblPartStats Collection of all local partition level statistics by specified key.\n+     * @return Local level aggregated statistics.\n+     */\n+    public ObjectStatisticsImpl aggregateLocalStatistics(StatsKey key, Collection<ObjectPartitionStatisticsImpl> tblPartStats) {\n+        // For now there can be only tables\n+        GridH2Table table = schemaMgr.dataTable(key.schema(), key.obj());\n+\n+        if (table == null) {\n+            // remove all loaded statistics.\n+            log.info(\"Removing statistics for object \" + key + \" cause table doesn't exists.\");\n+            statsRepos.clearLocalPartitionsStatistics(key);\n+        }\n+        return aggregateLocalStatistics(table, table.getColumns(), tblPartStats);\n+    }\n+\n+    /**\n+     * Aggregate partition level statistics to local level one.\n+     *\n+     * @param tbl table to aggregate statistics by.", "originalCommit": "bd7b54c77f5706581c4af1f3f2e6cf5345ae2ff1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDY0MTQzMg==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r520641432", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param qryProc query processor to run queries on.\n          \n          \n            \n                 * @param qryProc Query processor to run queries on.", "author": "korlov42", "createdAt": "2020-11-10T15:16:00Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/cache/index/BasicIndexTest.java", "diffHunk": "@@ -522,17 +522,47 @@ private void runEqualFieldsDynamicIndexes(boolean persistEnabled) throws Excepti\n         assertFalse(lsnrIdx7.check());\n     }\n \n+    /**\n+     * Check that specified index is used in query plan with specified where clause tables.\n+     *\n+     * @param qryProc Query processor to run queries on.\n+     * @param idxName Index name to test.\n+     * @param tblName Table to query.\n+     * @param reqFlds Fields to add into where clause.\n+     */\n+    private void checkIdxIsUsed(GridQueryProcessor qryProc, String idxName, String tblName, String... reqFlds) {\n+       checkIdxUsage(qryProc, idxName, null, tblName, reqFlds);\n+    }\n+\n+    /**\n+     * Check that specified index is used in query plan with specified where clause tables.\n+     *\n+     * @param qryProc query processor to run queries on.", "originalCommit": "bd7b54c77f5706581c4af1f3f2e6cf5345ae2ff1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTIyMDk4NA==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r521220984", "bodyText": "The only value of grid param is grid(0). The value of optimal param is either empty array or array with length==1. So let's simplify this. Parma indexes could be simplified as well", "author": "korlov42", "createdAt": "2020-11-11T09:19:04Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/stat/TableStatisticsAbstractTest.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.cache.query.SqlFieldsQuery;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.processors.cache.query.SqlFieldsQueryEx;\n+import org.apache.ignite.internal.util.typedef.F;\n+import org.apache.ignite.internal.util.typedef.G;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+\n+/**\n+ * Base test for table statistics.\n+ */\n+public abstract class TableStatisticsAbstractTest extends GridCommonAbstractTest {\n+    /** Big table size. */\n+    static final int BIG_SIZE = 1000;\n+\n+    /** Medium table size. */\n+    static final int MED_SIZE = 500;\n+\n+    /** Small table size. */\n+    static final int SMALL_SIZE = 100;\n+\n+    static {\n+        assertTrue(SMALL_SIZE < MED_SIZE && MED_SIZE < BIG_SIZE);\n+    }\n+\n+    /**\n+     * Compare different index used for the given query.\n+     *\n+     * @param grid Grid to run queries on.\n+     * @param optimal Array of optimal indexes.\n+     * @param sql Query with placeholders to hint indexes (i1, i2, ...).\n+     * @param indexes Arrays of indexes to put into placeholders.\n+     */\n+    protected void checkOptimalPlanChosenForDifferentIndexes(Ignite grid, String[] optimal, String sql, String[][] indexes) {", "originalCommit": "bd7b54c77f5706581c4af1f3f2e6cf5345ae2ff1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTIzNjY4NQ==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r521236685", "bodyText": "runLocalExplainIdx should return List and no explicit conversion would be needed then", "author": "korlov42", "createdAt": "2020-11-11T09:45:40Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/stat/TableStatisticsAbstractTest.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.cache.query.SqlFieldsQuery;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.processors.cache.query.SqlFieldsQueryEx;\n+import org.apache.ignite.internal.util.typedef.F;\n+import org.apache.ignite.internal.util.typedef.G;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+\n+/**\n+ * Base test for table statistics.\n+ */\n+public abstract class TableStatisticsAbstractTest extends GridCommonAbstractTest {\n+    /** Big table size. */\n+    static final int BIG_SIZE = 1000;\n+\n+    /** Medium table size. */\n+    static final int MED_SIZE = 500;\n+\n+    /** Small table size. */\n+    static final int SMALL_SIZE = 100;\n+\n+    static {\n+        assertTrue(SMALL_SIZE < MED_SIZE && MED_SIZE < BIG_SIZE);\n+    }\n+\n+    /**\n+     * Compare different index used for the given query.\n+     *\n+     * @param grid Grid to run queries on.\n+     * @param optimal Array of optimal indexes.\n+     * @param sql Query with placeholders to hint indexes (i1, i2, ...).\n+     * @param indexes Arrays of indexes to put into placeholders.\n+     */\n+    protected void checkOptimalPlanChosenForDifferentIndexes(Ignite grid, String[] optimal, String sql, String[][] indexes) {\n+        int size = -1;\n+        for (String[] idxs : indexes) {\n+            if (size == -1)\n+                size = (idxs == null) ? 0 : idxs.length;\n+\n+            assert idxs == null || idxs.length == size;\n+        }\n+        sql = replaceIndexHintPlaceholders(sql, indexes);\n+        String actual[] = runLocalExplainIdx(grid, sql);", "originalCommit": "bd7b54c77f5706581c4af1f3f2e6cf5345ae2ff1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI0MzE1NA==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r521243154", "bodyText": "broken link", "author": "korlov42", "createdAt": "2020-11-11T09:56:37Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/IgniteStatisticsRepository.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import java.util.Collection;\n+\n+/**\n+ * Repository to store all necessary statistics. Can request absent ones from cluster and store to\n+ * {@link SqlStatisticsStoreImpl}.", "originalCommit": "bd7b54c77f5706581c4af1f3f2e6cf5345ae2ff1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI0MzM4OQ==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r521243389", "bodyText": "wrong param name", "author": "korlov42", "createdAt": "2020-11-11T09:57:02Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/IgniteStatisticsRepository.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import java.util.Collection;\n+\n+/**\n+ * Repository to store all necessary statistics. Can request absent ones from cluster and store to\n+ * {@link SqlStatisticsStoreImpl}.\n+ */\n+public interface IgniteStatisticsRepository {\n+\n+    /**\n+     * Replace all object statistics with specified ones if fillStat is {@code true} or merge it otherwise.\n+     *\n+     * @param key Object key.\n+     * @param statistics Collection of tables partition statistics.\n+     * @param fullStat if {@code true} - replace whole statistics, try to merge with existing - otherwise.\n+     */\n+    void saveLocalPartitionsStatistics(StatsKey key, Collection<ObjectPartitionStatisticsImpl> statistics, boolean fullStat);\n+\n+    /**\n+     * Get local partition statistics by specified object.\n+     *\n+     * @param key Object to get statistics by.\n+     * @return Collection of partitions statistics.\n+     */\n+    Collection<ObjectPartitionStatisticsImpl> getLocalPartitionsStatistics(StatsKey key);\n+\n+    /**\n+     * Clear partition statistics for specified object.\n+     *\n+     * @param key Object to clear statistics by.\n+     * @param colNames if specified - only statistics by specified columns will be cleared.\n+     */\n+    void clearLocalPartitionsStatistics(StatsKey key, String... colNames);\n+\n+    /**\n+     * Save specified local partition statistics.\n+     *\n+     * @param tbl Object key.", "originalCommit": "bd7b54c77f5706581c4af1f3f2e6cf5345ae2ff1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI0MzgxNg==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r521243816", "bodyText": "missed @Override", "author": "korlov42", "createdAt": "2020-11-11T09:57:47Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/IgniteStatisticsRepositoryImpl.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheUtils;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Statistics repository implementation.\n+ */\n+public class IgniteStatisticsRepositoryImpl implements IgniteStatisticsRepository {\n+    /** Logger. */\n+    private IgniteLogger log;\n+\n+    /** Kernal context. */\n+    private final GridKernalContext ctx;\n+\n+    /** Table->Partition->Partition Statistics map, populated only on server nodes without persistence enabled. */\n+    private final Map<StatsKey, Map<Integer, ObjectPartitionStatisticsImpl>> partsStats;\n+\n+    /** Local (for current node) object statistics. */\n+    private final Map<StatsKey, ObjectStatisticsImpl> localStats;\n+\n+    /** Global (for whole cluster) object statistics. */\n+    private final Map<StatsKey, ObjectStatisticsImpl> globalStats = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param ctx Kernal context.\n+     */\n+    public IgniteStatisticsRepositoryImpl(GridKernalContext ctx) {\n+        this.ctx = ctx;\n+\n+        if (ctx.config().isClientMode() || ctx.isDaemon()) {\n+            // Cache only global statistics, no store\n+            partsStats = null;\n+            localStats = null;\n+        } else {\n+            // Persistence store\n+            partsStats = GridCacheUtils.isPersistenceEnabled(ctx.config()) ? null : new ConcurrentHashMap<>();\n+\n+            localStats = new ConcurrentHashMap<>();\n+        }\n+        log = ctx.log(IgniteStatisticsRepositoryImpl.class);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void saveLocalPartitionsStatistics(StatsKey key,\n+                                                        Collection<ObjectPartitionStatisticsImpl> statistics,\n+                                                        boolean fullStat) {\n+        if (partsStats != null) {\n+            Map<Integer, ObjectPartitionStatisticsImpl> statisticsMap = new ConcurrentHashMap<>();\n+            for (ObjectPartitionStatisticsImpl s : statistics) {\n+                if (statisticsMap.put(s.partId(), s) != null)\n+                    log.warning(String.format(\"Trying to save more than one %s.%s partition statistics for partition %d\",\n+                            key.schema(), key.obj(), s.partId()));\n+            }\n+\n+            if (fullStat) {\n+                partsStats.compute(key, (k, v) -> {\n+                    if (v == null)\n+                        v = statisticsMap;\n+                    else\n+                        v.putAll(statisticsMap);\n+\n+                    return v;\n+                });\n+            } else {\n+                partsStats.compute(key, (k, v) -> {\n+                    if (v != null) {\n+                        for (Map.Entry<Integer, ObjectPartitionStatisticsImpl> partStat : v.entrySet()) {\n+                            ObjectPartitionStatisticsImpl newStat = statisticsMap.get(partStat.getKey());\n+                            if (newStat != null) {\n+                                ObjectPartitionStatisticsImpl combinedStat = add(partStat.getValue(), newStat);\n+                                statisticsMap.put(partStat.getKey(), combinedStat);\n+                            }\n+                        }\n+                    }\n+                    return statisticsMap;\n+                });\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get local partition statistics.\n+     *\n+     * @param key Object to get statistics by.\n+     * @return Collection of local partitions statistics.\n+     */\n+    public Collection<ObjectPartitionStatisticsImpl> getLocalPartitionsStatistics(StatsKey key) {", "originalCommit": "bd7b54c77f5706581c4af1f3f2e6cf5345ae2ff1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI0NDAwOQ==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r521244009", "bodyText": "missed @Override", "author": "korlov42", "createdAt": "2020-11-11T09:58:08Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/IgniteStatisticsRepositoryImpl.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheUtils;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Statistics repository implementation.\n+ */\n+public class IgniteStatisticsRepositoryImpl implements IgniteStatisticsRepository {\n+    /** Logger. */\n+    private IgniteLogger log;\n+\n+    /** Kernal context. */\n+    private final GridKernalContext ctx;\n+\n+    /** Table->Partition->Partition Statistics map, populated only on server nodes without persistence enabled. */\n+    private final Map<StatsKey, Map<Integer, ObjectPartitionStatisticsImpl>> partsStats;\n+\n+    /** Local (for current node) object statistics. */\n+    private final Map<StatsKey, ObjectStatisticsImpl> localStats;\n+\n+    /** Global (for whole cluster) object statistics. */\n+    private final Map<StatsKey, ObjectStatisticsImpl> globalStats = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param ctx Kernal context.\n+     */\n+    public IgniteStatisticsRepositoryImpl(GridKernalContext ctx) {\n+        this.ctx = ctx;\n+\n+        if (ctx.config().isClientMode() || ctx.isDaemon()) {\n+            // Cache only global statistics, no store\n+            partsStats = null;\n+            localStats = null;\n+        } else {\n+            // Persistence store\n+            partsStats = GridCacheUtils.isPersistenceEnabled(ctx.config()) ? null : new ConcurrentHashMap<>();\n+\n+            localStats = new ConcurrentHashMap<>();\n+        }\n+        log = ctx.log(IgniteStatisticsRepositoryImpl.class);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void saveLocalPartitionsStatistics(StatsKey key,\n+                                                        Collection<ObjectPartitionStatisticsImpl> statistics,\n+                                                        boolean fullStat) {\n+        if (partsStats != null) {\n+            Map<Integer, ObjectPartitionStatisticsImpl> statisticsMap = new ConcurrentHashMap<>();\n+            for (ObjectPartitionStatisticsImpl s : statistics) {\n+                if (statisticsMap.put(s.partId(), s) != null)\n+                    log.warning(String.format(\"Trying to save more than one %s.%s partition statistics for partition %d\",\n+                            key.schema(), key.obj(), s.partId()));\n+            }\n+\n+            if (fullStat) {\n+                partsStats.compute(key, (k, v) -> {\n+                    if (v == null)\n+                        v = statisticsMap;\n+                    else\n+                        v.putAll(statisticsMap);\n+\n+                    return v;\n+                });\n+            } else {\n+                partsStats.compute(key, (k, v) -> {\n+                    if (v != null) {\n+                        for (Map.Entry<Integer, ObjectPartitionStatisticsImpl> partStat : v.entrySet()) {\n+                            ObjectPartitionStatisticsImpl newStat = statisticsMap.get(partStat.getKey());\n+                            if (newStat != null) {\n+                                ObjectPartitionStatisticsImpl combinedStat = add(partStat.getValue(), newStat);\n+                                statisticsMap.put(partStat.getKey(), combinedStat);\n+                            }\n+                        }\n+                    }\n+                    return statisticsMap;\n+                });\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get local partition statistics.\n+     *\n+     * @param key Object to get statistics by.\n+     * @return Collection of local partitions statistics.\n+     */\n+    public Collection<ObjectPartitionStatisticsImpl> getLocalPartitionsStatistics(StatsKey key) {\n+        if (partsStats != null) {\n+            Map<Integer, ObjectPartitionStatisticsImpl> objectStatisticsMap = partsStats.get(key);\n+\n+            return (objectStatisticsMap == null) ? null : objectStatisticsMap.values();\n+        }\n+\n+        return Collections.emptyList();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void clearLocalPartitionsStatistics(StatsKey key, String... colNames) {\n+        if (colNames == null || colNames.length == 0) {\n+            if (partsStats != null)\n+                partsStats.remove(key);\n+        } else {\n+            if (partsStats != null) {\n+                partsStats.computeIfPresent(key, (tblKey, partMap) -> {\n+                    partMap.replaceAll((partId, partStat) -> {\n+                        ObjectPartitionStatisticsImpl partStatNew = substract(partStat, colNames);\n+                        return (partStatNew.columnsStatistics().isEmpty()) ? null : partStat;\n+\n+                    });\n+                    partMap.entrySet().removeIf(e -> e.getValue() == null);\n+                    return partMap.isEmpty() ? null : partMap;\n+                });\n+            }\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void saveLocalPartitionStatistics(StatsKey key, ObjectPartitionStatisticsImpl statistics) {\n+        if (partsStats != null) {\n+            partsStats.compute(key, (k,v) -> {\n+                if (v == null)\n+                    v = new ConcurrentHashMap<>();\n+                ObjectPartitionStatisticsImpl oldPartStat = v.get(statistics.partId());\n+                if (oldPartStat == null)\n+                    v.put(statistics.partId(), statistics);\n+                else {\n+                    ObjectPartitionStatisticsImpl combinedStats = add(oldPartStat, statistics);\n+                    v.put(statistics.partId(), combinedStats);\n+                }\n+                return v;\n+            });\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public ObjectPartitionStatisticsImpl getLocalPartitionStatistics(StatsKey key, int partId) {\n+        if (partsStats != null) {\n+            Map<Integer, ObjectPartitionStatisticsImpl> objectPartStats = partsStats.get(key);\n+            return objectPartStats == null ? null : objectPartStats.get(partId);\n+        }\n+        return null;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void clearLocalPartitionStatistics(StatsKey key, int partId) {\n+        if (partsStats != null) {\n+            partsStats.computeIfPresent(key, (k, v) -> {\n+                v.remove(partId);\n+                return v.isEmpty() ? null : v;\n+            });\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void saveLocalStatistics(StatsKey key, ObjectStatisticsImpl statistics, boolean fullStat) {\n+        if (localStats != null) {\n+            if (fullStat)\n+                localStats.put(key, statistics);\n+            else {\n+                localStats.compute(key, (k, v) -> {\n+                    if (v == null)\n+                        return statistics;\n+                    return add(v, statistics);\n+                });\n+            }\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void cacheLocalStatistics(StatsKey key, Collection<ObjectPartitionStatisticsImpl> statistics) {\n+        IgniteStatisticsManagerImpl statManager = (IgniteStatisticsManagerImpl)ctx.query().getIndexing().statsManager();\n+        if (localStats != null)\n+            localStats.put(key, statManager.aggregateLocalStatistics(key, statistics));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public ObjectStatisticsImpl getLocalStatistics(StatsKey key) {\n+        return localStats == null ? null : localStats.get(key);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void clearLocalStatistics(StatsKey key, String... colNames) {\n+        if (colNames == null || colNames.length == 0) {\n+            if (localStats != null)\n+                localStats.remove(key);\n+        } else {\n+            if (localStats != null) {\n+                localStats.computeIfPresent(key, (k, v) -> {\n+                    ObjectStatisticsImpl locStatNew = substract(v, colNames);\n+                    return locStatNew.columnsStatistics().isEmpty() ? null : locStatNew;\n+                });\n+            }\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void saveGlobalStatistics(StatsKey key, ObjectStatisticsImpl statistics, boolean fullStat) {\n+        globalStats.put(key, statistics);\n+    }\n+\n+    /**\n+     * Get global statistics by key.\n+     *\n+     * @param key Object key to get global statistics by.\n+     * @return Object global statistics or {@code null} if there are no global statistics.\n+     */\n+    public ObjectStatisticsImpl getGlobalStatistics(StatsKey key) {", "originalCommit": "bd7b54c77f5706581c4af1f3f2e6cf5345ae2ff1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI0Njg0OQ==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r521246849", "bodyText": "wrong formatting", "author": "korlov42", "createdAt": "2020-11-11T10:02:55Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/IgniteStatisticsRepositoryImpl.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheUtils;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Statistics repository implementation.\n+ */\n+public class IgniteStatisticsRepositoryImpl implements IgniteStatisticsRepository {\n+    /** Logger. */\n+    private IgniteLogger log;\n+\n+    /** Kernal context. */\n+    private final GridKernalContext ctx;\n+\n+    /** Table->Partition->Partition Statistics map, populated only on server nodes without persistence enabled. */\n+    private final Map<StatsKey, Map<Integer, ObjectPartitionStatisticsImpl>> partsStats;\n+\n+    /** Local (for current node) object statistics. */\n+    private final Map<StatsKey, ObjectStatisticsImpl> localStats;\n+\n+    /** Global (for whole cluster) object statistics. */\n+    private final Map<StatsKey, ObjectStatisticsImpl> globalStats = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param ctx Kernal context.\n+     */\n+    public IgniteStatisticsRepositoryImpl(GridKernalContext ctx) {\n+        this.ctx = ctx;\n+\n+        if (ctx.config().isClientMode() || ctx.isDaemon()) {\n+            // Cache only global statistics, no store\n+            partsStats = null;\n+            localStats = null;\n+        } else {\n+            // Persistence store\n+            partsStats = GridCacheUtils.isPersistenceEnabled(ctx.config()) ? null : new ConcurrentHashMap<>();\n+\n+            localStats = new ConcurrentHashMap<>();\n+        }\n+        log = ctx.log(IgniteStatisticsRepositoryImpl.class);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void saveLocalPartitionsStatistics(StatsKey key,", "originalCommit": "bd7b54c77f5706581c4af1f3f2e6cf5345ae2ff1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI1MjA5Ng==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r521252096", "bodyText": "I can't find any usages of this. Let's get rid of it", "author": "korlov42", "createdAt": "2020-11-11T10:11:48Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/IgniteStatisticsRepositoryImpl.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheUtils;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Statistics repository implementation.\n+ */\n+public class IgniteStatisticsRepositoryImpl implements IgniteStatisticsRepository {\n+    /** Logger. */\n+    private IgniteLogger log;\n+\n+    /** Kernal context. */\n+    private final GridKernalContext ctx;\n+\n+    /** Table->Partition->Partition Statistics map, populated only on server nodes without persistence enabled. */\n+    private final Map<StatsKey, Map<Integer, ObjectPartitionStatisticsImpl>> partsStats;\n+\n+    /** Local (for current node) object statistics. */\n+    private final Map<StatsKey, ObjectStatisticsImpl> localStats;\n+\n+    /** Global (for whole cluster) object statistics. */\n+    private final Map<StatsKey, ObjectStatisticsImpl> globalStats = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param ctx Kernal context.\n+     */\n+    public IgniteStatisticsRepositoryImpl(GridKernalContext ctx) {\n+        this.ctx = ctx;\n+\n+        if (ctx.config().isClientMode() || ctx.isDaemon()) {\n+            // Cache only global statistics, no store\n+            partsStats = null;\n+            localStats = null;\n+        } else {\n+            // Persistence store\n+            partsStats = GridCacheUtils.isPersistenceEnabled(ctx.config()) ? null : new ConcurrentHashMap<>();\n+\n+            localStats = new ConcurrentHashMap<>();\n+        }\n+        log = ctx.log(IgniteStatisticsRepositoryImpl.class);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void saveLocalPartitionsStatistics(StatsKey key,\n+                                                        Collection<ObjectPartitionStatisticsImpl> statistics,\n+                                                        boolean fullStat) {\n+        if (partsStats != null) {\n+            Map<Integer, ObjectPartitionStatisticsImpl> statisticsMap = new ConcurrentHashMap<>();\n+            for (ObjectPartitionStatisticsImpl s : statistics) {\n+                if (statisticsMap.put(s.partId(), s) != null)\n+                    log.warning(String.format(\"Trying to save more than one %s.%s partition statistics for partition %d\",\n+                            key.schema(), key.obj(), s.partId()));\n+            }\n+\n+            if (fullStat) {\n+                partsStats.compute(key, (k, v) -> {\n+                    if (v == null)\n+                        v = statisticsMap;\n+                    else\n+                        v.putAll(statisticsMap);\n+\n+                    return v;\n+                });\n+            } else {\n+                partsStats.compute(key, (k, v) -> {\n+                    if (v != null) {\n+                        for (Map.Entry<Integer, ObjectPartitionStatisticsImpl> partStat : v.entrySet()) {\n+                            ObjectPartitionStatisticsImpl newStat = statisticsMap.get(partStat.getKey());\n+                            if (newStat != null) {\n+                                ObjectPartitionStatisticsImpl combinedStat = add(partStat.getValue(), newStat);\n+                                statisticsMap.put(partStat.getKey(), combinedStat);\n+                            }\n+                        }\n+                    }\n+                    return statisticsMap;\n+                });\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get local partition statistics.\n+     *\n+     * @param key Object to get statistics by.\n+     * @return Collection of local partitions statistics.\n+     */\n+    public Collection<ObjectPartitionStatisticsImpl> getLocalPartitionsStatistics(StatsKey key) {\n+        if (partsStats != null) {\n+            Map<Integer, ObjectPartitionStatisticsImpl> objectStatisticsMap = partsStats.get(key);\n+\n+            return (objectStatisticsMap == null) ? null : objectStatisticsMap.values();\n+        }\n+\n+        return Collections.emptyList();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void clearLocalPartitionsStatistics(StatsKey key, String... colNames) {\n+        if (colNames == null || colNames.length == 0) {\n+            if (partsStats != null)\n+                partsStats.remove(key);\n+        } else {\n+            if (partsStats != null) {\n+                partsStats.computeIfPresent(key, (tblKey, partMap) -> {\n+                    partMap.replaceAll((partId, partStat) -> {\n+                        ObjectPartitionStatisticsImpl partStatNew = substract(partStat, colNames);\n+                        return (partStatNew.columnsStatistics().isEmpty()) ? null : partStat;\n+\n+                    });\n+                    partMap.entrySet().removeIf(e -> e.getValue() == null);\n+                    return partMap.isEmpty() ? null : partMap;\n+                });\n+            }\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void saveLocalPartitionStatistics(StatsKey key, ObjectPartitionStatisticsImpl statistics) {\n+        if (partsStats != null) {\n+            partsStats.compute(key, (k,v) -> {\n+                if (v == null)\n+                    v = new ConcurrentHashMap<>();\n+                ObjectPartitionStatisticsImpl oldPartStat = v.get(statistics.partId());\n+                if (oldPartStat == null)\n+                    v.put(statistics.partId(), statistics);\n+                else {\n+                    ObjectPartitionStatisticsImpl combinedStats = add(oldPartStat, statistics);\n+                    v.put(statistics.partId(), combinedStats);\n+                }\n+                return v;\n+            });\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public ObjectPartitionStatisticsImpl getLocalPartitionStatistics(StatsKey key, int partId) {\n+        if (partsStats != null) {\n+            Map<Integer, ObjectPartitionStatisticsImpl> objectPartStats = partsStats.get(key);\n+            return objectPartStats == null ? null : objectPartStats.get(partId);\n+        }\n+        return null;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void clearLocalPartitionStatistics(StatsKey key, int partId) {\n+        if (partsStats != null) {\n+            partsStats.computeIfPresent(key, (k, v) -> {\n+                v.remove(partId);\n+                return v.isEmpty() ? null : v;\n+            });\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void saveLocalStatistics(StatsKey key, ObjectStatisticsImpl statistics, boolean fullStat) {\n+        if (localStats != null) {\n+            if (fullStat)\n+                localStats.put(key, statistics);\n+            else {\n+                localStats.compute(key, (k, v) -> {\n+                    if (v == null)\n+                        return statistics;\n+                    return add(v, statistics);\n+                });\n+            }\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void cacheLocalStatistics(StatsKey key, Collection<ObjectPartitionStatisticsImpl> statistics) {", "originalCommit": "bd7b54c77f5706581c4af1f3f2e6cf5345ae2ff1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI1NjIyMw==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r521256223", "bodyText": "I think it is not a good idea to depend on the kernel context because it makes the system tightly coupling. All we need is a few boolean flags just to decide whether we need to process local and partional statistics or not.\nAlso let's cover this with unit tests", "author": "korlov42", "createdAt": "2020-11-11T10:19:13Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/IgniteStatisticsRepositoryImpl.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheUtils;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Statistics repository implementation.\n+ */\n+public class IgniteStatisticsRepositoryImpl implements IgniteStatisticsRepository {\n+    /** Logger. */\n+    private IgniteLogger log;\n+\n+    /** Kernal context. */\n+    private final GridKernalContext ctx;\n+\n+    /** Table->Partition->Partition Statistics map, populated only on server nodes without persistence enabled. */\n+    private final Map<StatsKey, Map<Integer, ObjectPartitionStatisticsImpl>> partsStats;\n+\n+    /** Local (for current node) object statistics. */\n+    private final Map<StatsKey, ObjectStatisticsImpl> localStats;\n+\n+    /** Global (for whole cluster) object statistics. */\n+    private final Map<StatsKey, ObjectStatisticsImpl> globalStats = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param ctx Kernal context.\n+     */\n+    public IgniteStatisticsRepositoryImpl(GridKernalContext ctx) {", "originalCommit": "bd7b54c77f5706581c4af1f3f2e6cf5345ae2ff1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI1NzQwNQ==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r521257405", "bodyText": "is it a valid case where someone tries to save partition statistics on client node?\nalso let's invert condition", "author": "korlov42", "createdAt": "2020-11-11T10:21:11Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/IgniteStatisticsRepositoryImpl.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.processors.cache.GridCacheUtils;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Statistics repository implementation.\n+ */\n+public class IgniteStatisticsRepositoryImpl implements IgniteStatisticsRepository {\n+    /** Logger. */\n+    private IgniteLogger log;\n+\n+    /** Kernal context. */\n+    private final GridKernalContext ctx;\n+\n+    /** Table->Partition->Partition Statistics map, populated only on server nodes without persistence enabled. */\n+    private final Map<StatsKey, Map<Integer, ObjectPartitionStatisticsImpl>> partsStats;\n+\n+    /** Local (for current node) object statistics. */\n+    private final Map<StatsKey, ObjectStatisticsImpl> localStats;\n+\n+    /** Global (for whole cluster) object statistics. */\n+    private final Map<StatsKey, ObjectStatisticsImpl> globalStats = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param ctx Kernal context.\n+     */\n+    public IgniteStatisticsRepositoryImpl(GridKernalContext ctx) {\n+        this.ctx = ctx;\n+\n+        if (ctx.config().isClientMode() || ctx.isDaemon()) {\n+            // Cache only global statistics, no store\n+            partsStats = null;\n+            localStats = null;\n+        } else {\n+            // Persistence store\n+            partsStats = GridCacheUtils.isPersistenceEnabled(ctx.config()) ? null : new ConcurrentHashMap<>();\n+\n+            localStats = new ConcurrentHashMap<>();\n+        }\n+        log = ctx.log(IgniteStatisticsRepositoryImpl.class);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void saveLocalPartitionsStatistics(StatsKey key,\n+                                                        Collection<ObjectPartitionStatisticsImpl> statistics,\n+                                                        boolean fullStat) {\n+        if (partsStats != null) {", "originalCommit": "bd7b54c77f5706581c4af1f3f2e6cf5345ae2ff1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI5NjQ2NQ==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r521296465", "bodyText": "annotation should be on a separate line", "author": "korlov42", "createdAt": "2020-11-11T11:34:38Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/stat/BasicValueDistributionTableStatisticsUsageTest.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.cache.CacheMode;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import static org.apache.ignite.cache.CacheMode.PARTITIONED;\n+import static org.apache.ignite.cache.CacheMode.REPLICATED;\n+\n+/**\n+ * Basic tests of value distribution statistics usage.\n+ */\n+@RunWith(Parameterized.class)\n+public class BasicValueDistributionTableStatisticsUsageTest extends TableStatisticsAbstractTest {\n+    /** */\n+    @Parameterized.Parameter(0)\n+    public CacheMode cacheMode;\n+\n+    /**\n+     * @return Test parameters.\n+     */\n+    @Parameterized.Parameters(name = \"cacheMode={0}\")\n+    public static Collection parameters() {\n+        return Arrays.asList(new Object[][] {\n+                { REPLICATED },\n+                { PARTITIONED },\n+        });\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void beforeTestsStarted() throws Exception {\n+        Ignite node = startGridsMultiThreaded(2);\n+\n+        node.getOrCreateCache(DEFAULT_CACHE_NAME);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void beforeTest() throws Exception {\n+        runSql(\"DROP TABLE IF EXISTS digital_distribution\");\n+\n+        runSql(\"CREATE TABLE digital_distribution (ID INT PRIMARY KEY, col_a int, col_b int, col_c int, col_d int) \" +\n+                \"WITH \\\"TEMPLATE=\" + cacheMode + \"\\\"\");\n+\n+        runSql(\"CREATE INDEX digital_distribution_col_a ON digital_distribution(col_a)\");\n+        runSql(\"CREATE INDEX digital_distribution_col_b ON digital_distribution(col_b)\");\n+        runSql(\"CREATE INDEX digital_distribution_col_c ON digital_distribution(col_c)\");\n+        runSql(\"CREATE INDEX digital_distribution_col_d ON digital_distribution(col_d)\");\n+\n+        for (int i = 0; i < 100; i++) {\n+            String sql = String.format(\"INSERT INTO digital_distribution(id, col_a, col_b, col_c, col_d)\" +\n+                    \" VALUES(%d,%d, %d, 1, null)\", i, i, i + 200);\n+            runSql(sql);\n+        }\n+        runSql(\"INSERT INTO digital_distribution(id, col_a, col_b, col_c) VALUES(101, null, 301, null)\");\n+\n+        runSql(\"DROP TABLE IF EXISTS empty_distribution\");\n+\n+        runSql(\"CREATE TABLE empty_distribution (ID INT PRIMARY KEY, col_a int) \" +\n+                \"WITH \\\"TEMPLATE=\" + cacheMode + \"\\\"\");\n+\n+        runSql(\"CREATE INDEX empty_distribution_col_a ON empty_distribution(col_a)\");\n+\n+        runSql(\"DROP TABLE IF EXISTS empty_distribution_no_stat\");\n+\n+        runSql(\"CREATE TABLE empty_distribution_no_stat (ID INT PRIMARY KEY, col_a int) \" +\n+                \"WITH \\\"TEMPLATE=\" + cacheMode + \"\\\"\");\n+\n+        runSql(\"CREATE INDEX empty_distribution_no_stat_col_a ON empty_distribution_no_stat(col_a)\");\n+\n+        updateStatistics(\"digital_distribution\", \"empty_distribution\");\n+    }\n+\n+    /**\n+     * Select with two conditions with border higher than all values in one of them and check that\n+     * that column index will be used.\n+     */\n+    @Test public void selectOverhightBorder() {", "originalCommit": "bd7b54c77f5706581c4af1f3f2e6cf5345ae2ff1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTMwNDk3Mw==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r521304973", "bodyText": "we don't need a separate field for this", "author": "korlov42", "createdAt": "2020-11-11T11:51:42Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/opt/H2IndexCostedBase.java", "diffHunk": "@@ -16,30 +16,51 @@\n \n package org.apache.ignite.internal.processors.query.h2.opt;\n \n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.math.MathContext;\n import java.util.ArrayList;\n import java.util.Arrays;\n+\n import org.apache.ignite.IgniteLogger;\n import org.apache.ignite.IgniteSystemProperties;\n+import org.apache.ignite.internal.processors.query.stat.ColumnStatistics;\n+import org.apache.ignite.internal.processors.query.stat.ObjectStatisticsImpl;\n import org.apache.ignite.internal.util.typedef.F;\n import org.apache.ignite.internal.util.typedef.internal.LT;\n import org.gridgain.internal.h2.command.dml.AllColumnsForPlan;\n import org.gridgain.internal.h2.engine.Constants;\n+import org.gridgain.internal.h2.engine.Session;\n+import org.gridgain.internal.h2.expression.Expression;\n+import org.gridgain.internal.h2.expression.condition.Comparison;\n import org.gridgain.internal.h2.index.BaseIndex;\n import org.gridgain.internal.h2.index.IndexCondition;\n import org.gridgain.internal.h2.index.IndexType;\n import org.gridgain.internal.h2.result.SortOrder;\n import org.gridgain.internal.h2.table.Column;\n import org.gridgain.internal.h2.table.IndexColumn;\n import org.gridgain.internal.h2.table.TableFilter;\n+import org.gridgain.internal.h2.value.Value;\n+import org.jetbrains.annotations.Nullable;\n \n /**\n  * Index base.\n  */\n public abstract class H2IndexCostedBase extends BaseIndex {\n-    /** Const function. */\n+    /**\n+     * Const function.\n+     */\n     private final CostFunction constFunc;\n \n-    /** Logger. */\n+    /** Table to calculate costs by. */\n+    private final GridH2Table tbl;\n+\n+    /** Cost function object. */\n+    private final CostFunctionLast cfl;", "originalCommit": "bd7b54c77f5706581c4af1f3f2e6cf5345ae2ff1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTMwNzIwMA==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r521307200", "bodyText": "unrelated changes", "author": "korlov42", "createdAt": "2020-11-11T11:56:10Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/opt/H2IndexCostedBase.java", "diffHunk": "@@ -473,9 +501,9 @@ else if (needsToReadFromScanIndex)\n     /**\n      * Re-implement {@link BaseIndex#getCostRangeIndex} to suppor  compatibility with versions 8.7.6 and older.\n      */\n-    private final long getCostRangeIndex_8_7_6(int[] masks, long rowCount,\n-        TableFilter[] filters, int filter, SortOrder sortOrder,\n-        boolean isScanIndex, AllColumnsForPlan allColumnsSet) {\n+    private final long getCostRangeIndex_8_7_6(Session ses, int[] masks, long rowCount,\n+                                               TableFilter[] filters, int filter, SortOrder sortOrder,", "originalCommit": "bd7b54c77f5706581c4af1f3f2e6cf5345ae2ff1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTMxODU4NA==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r521318584", "bodyText": "Please consider the follow case: min is 0, max is 100, and minStat=maxStat=50", "author": "korlov42", "createdAt": "2020-11-11T12:18:43Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/opt/H2IndexCostedBase.java", "diffHunk": "@@ -641,22 +665,625 @@ else if (needsToReadFromScanIndex)\n          * Cost function.\n          * See more: {@link BaseIndex#getCostRangeIndex}.\n          */\n-        long getCostRangeIndex(int[] masks, long rowCount,\n-            TableFilter[] filters, int filter, SortOrder sortOrder,\n-            boolean isScanIndex, AllColumnsForPlan allColumnsSet);\n+        long getCostRangeIndex(Session ses, int[] masks, long rowCount,\n+                               TableFilter[] filters, int filter, SortOrder sortOrder,\n+                               boolean isScanIndex, AllColumnsForPlan allColumnsSet);\n     }\n \n     /**\n      *\n      */\n     private enum CostFunctionType {\n-        /** Last. */\n+        /**\n+         * Last.\n+         */\n         LAST,\n \n-        /** Compatible with ver. 8.7.12. */\n+        /**\n+         * Compatible with ver. 8.7.28\n+         */\n+        COMPATIBLE_8_7_28,\n+\n+        /**\n+         * Compatible with ver. 8.7.12.\n+         */\n         COMPATIBLE_8_7_12,\n \n-        /** Compatible with ver. 8.7.6. */\n+        /**\n+         * Compatible with ver. 8.7.6.\n+         */\n         COMPATIBLE_8_7_6\n     }\n+\n+    /**\n+     * Cost function implementation.\n+     */\n+    private final class CostFunctionLast implements CostFunction {\n+        /**\n+         * Math context to use in estimations calculations.\n+         */\n+        private final MathContext MATH_CONTEXT = MathContext.DECIMAL64;\n+\n+        /**\n+         * Selectivity for closed range queries, in percent.\n+         */\n+        private final int RANGE_CLOSE_SELECTIVITY = 25;\n+\n+        /**\n+         * Selectivity for open range queries, in percent.\n+         */\n+        private final int RANGE_OPEN_SELECTIVITY = 33;\n+\n+        /**\n+         * Row cost calculation.\n+         *\n+         * @param ses Session.\n+         * @param filter Table filter.\n+         * @param masks Masks array.\n+         * @param rowCount Total rows count.\n+         * @param locTblStats Local table statistics.\n+         * @return Row cost.\n+         */\n+        private long rowCost(Session ses, TableFilter filter, int[] masks, long rowCount,\n+                             ObjectStatisticsImpl locTblStats) {\n+            int totalCardinality = 0;\n+\n+            long rowsCost = rowCount;\n+\n+            if (masks != null) {\n+                int i = 0, len = columns.length;\n+\n+                while (i < len) {\n+                    Column column = columns[i++];\n+                    ColumnStatistics colStats = getColumnStatistics(locTblStats, column);\n+\n+                    int index = column.getColumnId();\n+                    int mask = masks[index];\n+\n+                    if (isByteFlag(mask, IndexCondition.EQUALITY)) {\n+                        if (i == len && getIndexType().isUnique()) {\n+                            rowsCost = 3;\n+\n+                            break;\n+                        }\n+                        // Estimate by is null\n+                        Value equalValue = getEqualValue(ses, column, filter);\n+                        Boolean equalNull = (equalValue == null) ? null : equalValue.getValueType() == Value.NULL;\n+                        rowCount = getColumnSize(colStats, rowCount, equalNull);\n+\n+                        if (colStats != null && equalNull == Boolean.TRUE) {\n+                            rowsCost = Math.min(5 + Math.max(rowsCost * colStats.nulls() / 100, 1), rowsCost -\n+                                    (i > 0 ? 1 : 0));\n+                            continue;\n+                        }\n+                        if (colStats != null && equalNull == Boolean.FALSE)\n+                            rowsCost = rowsCost * (100 - colStats.nulls()) / 100;\n+\n+                        int cardinality = getColumnCardinality(colStats, column);\n+\n+                        totalCardinality = 100 - ((100 - totalCardinality) * (100 - cardinality) / 100);\n+\n+                        long distinctRows = Math.round((double) rowCount * totalCardinality / 100);\n+\n+                        if (distinctRows <= 0)\n+                            distinctRows = 1;\n+\n+                        rowsCost = Math.min(5 + Math.max(rowsCost / distinctRows, 1), rowsCost - (i > 0 ? 1 : 0));\n+                    }\n+                    else if (isByteFlag(mask, IndexCondition.RANGE)\n+                            || isByteFlag(mask, IndexCondition.START)\n+                            || isByteFlag(mask, IndexCondition.END)) {\n+                        Value min = getStartValue(ses, column, filter);\n+                        Value max = getEndValue(ses, column, filter);\n+                        int percent = estimatePercent(colStats, min, max);\n+\n+                        rowsCost = Math.min(5 + rowsCost * percent / 100, rowsCost - (i > 0 ? 1 : 0));\n+\n+                        break;\n+                    }\n+                    else if (isNullFilter(ses, column, filter)) {\n+                        if (colStats != null)\n+                            rowsCost = Math.min(5 + Math.max(rowsCost * colStats.nulls() / 100, 1), rowsCost -\n+                                    (i > 0 ? 1 : 0));\n+                    }\n+                    else if (isNotNullFilter(ses, column, filter)) {\n+                        if (colStats != null)\n+                            rowsCost = Math.min(5 + Math.max(rowsCost * (100 - colStats.nulls()) / 100, 1), rowsCost -\n+                                    (i > 0 ? 1 : 0));\n+                    }\n+                    else\n+                        break;\n+                }\n+            }\n+            return rowsCost;\n+        }\n+\n+        /**\n+         * Try to get column cardinality from statistics, if there is no such - fall back to H2 column selectivity.\n+         *\n+         * @param colStats Column statistics.\n+         * @param column Column.\n+         * @return Column cardinality in percents.\n+         */\n+        private int getColumnCardinality(@Nullable ColumnStatistics colStats, Column column) {\n+            return (colStats == null) ? column.getSelectivity() : colStats.cardinality();\n+        }\n+\n+        /**\n+         * Get total number of values in column.\n+         *\n+         * @param colStats Column statistics.\n+         * @param rowCount Total row count in table.\n+         * @param nulls if {@code true} - try to estimate only nulls count,\n+         *              if {@code false} - try to estimate only non null count,\n+         *              if {@code null} - try to estimate total count of values.\n+         * @return Column value count.\n+         */\n+        private long getColumnSize(@Nullable ColumnStatistics colStats, long rowCount, Boolean nulls) {\n+            if (colStats == null)\n+                return rowCount;\n+            else if (nulls == null)\n+                return colStats.total();\n+            else if (nulls)\n+                return colStats.total() * colStats.nulls() / 100;\n+            else\n+                return colStats.total() * (100 - colStats.nulls()) / 100;\n+        }\n+\n+        /**\n+         * Get constant value if there are clause with equal condition for specified column.\n+         *\n+         * @param ses Session.\n+         * @param column Column to get value by.\n+         * @param filter Table filter.\n+         * @return \"Equal\" value or {@code null} if there are no equal clause with constant expression.\n+         */\n+        private Value getEqualValue(Session ses, Column column, TableFilter filter) {\n+            Value maxValue = null;\n+            for (IndexCondition cond : filter.getIndexConditions()) {\n+                if (!column.equals(cond.getColumn()))\n+                    continue;\n+\n+                if (isByteFlag(cond.getCompareType(), Comparison.EQUAL) && cond.isEvaluatable()) {\n+\n+                    Expression expr = cond.getExpression();\n+                    if (expr != null && expr.isConstant()) {\n+                        Value curVal = cond.getCurrentValue(ses);\n+                        if (null == maxValue || (curVal != null || filter.getTable().compareValues(curVal, maxValue) < 0))\n+                            maxValue = curVal;\n+                    }\n+                }\n+            }\n+            return maxValue;\n+        }\n+\n+        /**\n+         * Get \"start\" value - constant for \"bigger\" or \"bigger or equals\" clause.\n+         *\n+         * @param ses Session.\n+         * @param column Column to get value by.\n+         * @param filter Table filter.\n+         * @return \"Start\" value or {@code null} if there are no such clause with constant expression.\n+         */\n+        private Value getStartValue(Session ses, Column column, TableFilter filter) {\n+            if (filter == null)\n+                return null;\n+            Value maxValue = null;\n+            for (IndexCondition cond : filter.getIndexConditions()) {\n+                if (!column.equals(cond.getColumn()))\n+                    continue;\n+\n+                if ((isByteFlag(cond.getCompareType(), Comparison.BIGGER)\n+                        || isByteFlag(cond.getCompareType(), Comparison.BIGGER_EQUAL))\n+                        && cond.isEvaluatable()) {\n+\n+                    Expression expr = cond.getExpression();\n+                    if (expr != null && expr.isConstant()) {\n+                        Value curVal = cond.getCurrentValue(ses);\n+                        if (null == maxValue || (curVal != null || filter.getTable().compareValues(curVal, maxValue) < 0))\n+                            maxValue = curVal;\n+                    }\n+                }\n+            }\n+            return maxValue;\n+        }\n+\n+        /**\n+         * Get \"end\" value - constant for \"smaller\" or \"smaller or equal\" clause.\n+         *\n+         * @param ses Session.\n+         * @param column Column to get value by.\n+         * @param filter Table filter.\n+         * @return \"End\" value of {@code null} if there are no such clause with constant expression.\n+         */\n+        private Value getEndValue(Session ses, Column column, TableFilter filter) {\n+            if (filter == null)\n+                return null;\n+            Value minValue = null;\n+            for (IndexCondition cond : filter.getIndexConditions()) {\n+                if (!column.equals(cond.getColumn()))\n+                    continue;\n+\n+                if ((isByteFlag(cond.getCompareType(), Comparison.SMALLER)\n+                        || isByteFlag(cond.getCompareType(), Comparison.SMALLER_EQUAL))\n+                        && cond.isEvaluatable()) {\n+                    Expression expr = cond.getExpression();\n+                    if (expr != null && expr.isConstant()) {\n+                        Value curVal = cond.getCurrentValue(ses);\n+                        if (null == minValue || (curVal != null || filter.getTable().compareValues(minValue, curVal) < 0))\n+                            minValue = curVal;\n+                    }\n+                }\n+            }\n+            return minValue;\n+        }\n+\n+        /**\n+         * Check if specified filter compare specified column to not null.\n+         *\n+         * @param ses Session to resolve values.\n+         * @param column Column to check.\n+         * @param filter Table filter.\n+         * @return {@code true} if column value should be null, {@code falce} otherwise (or if it not sure).\n+         */\n+        private boolean isNotNullFilter(Session ses, Column column, TableFilter filter) {\n+            // TODO: check not null expression (TableFilter contains only fullCondition without getter to check it)\n+            return false;\n+        }\n+\n+        /**\n+         * Check if specified filter compare specified column to null.\n+         *\n+         * @param ses Session to resolve values.\n+         * @param column Column to check.\n+         * @param filter Table filter.\n+         * @return {@code true} if column value should be null, {@code falce} otherwise (or if it not sure).\n+         */\n+        private boolean isNullFilter(Session ses, Column column, TableFilter filter) {\n+            if (filter == null)\n+                return false;\n+            for (IndexCondition cond : filter.getIndexConditions()) {\n+                if (column.equals(cond.getColumn()))\n+                    continue;\n+\n+                if (isByteFlag(cond.getCompareType(), Comparison.SPATIAL_INTERSECTS) && cond.isEvaluatable()) {\n+                    Expression expr = cond.getExpression();\n+\n+                    if (expr != null && expr.isConstant()) {\n+                        Value curVal = cond.getCurrentValue(ses);\n+\n+                        if (curVal != null && curVal.getValueType() == Value.NULL)\n+                            return true;\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+\n+        /**\n+         * Test if value contains all masks bits.\n+         *\n+         * @param value Value to test.\n+         * @param mask Mask to test by.\n+         * @return {@code true} if value contains all necessary bits, {@code false} otherwise.\n+         */\n+        private boolean isByteFlag(int value, int mask) {\n+            return (value & mask) == mask;\n+        }\n+\n+        /**\n+         * Estimate percent of selected rows by specified min/max conditions (of total rows, with nulls).\n+         *\n+         * @param colStat Column statistics to use, if exists.\n+         * @param min The lower border.\n+         * @param max The higher border.\n+         * @return Percent of total rows, selected with specified conditions (0-100).\n+         */\n+        private int estimatePercent(ColumnStatistics colStat, Value min, Value max) {\n+            if (colStat == null || colStat.min() == null || colStat.max() == null)\n+                // Fall back to previous behaviour without statistics, even without min/max testing\n+                return estimatePercentFallback(min, max);\n+\n+            BigDecimal minValue = (min == null) ? null : getComparableValue(min);\n+            BigDecimal maxValue = (max == null) ? null : getComparableValue(max);\n+\n+            if (minValue == null && maxValue == null)\n+                return estimatePercentFallback(min, max);\n+\n+            BigDecimal minStat = getComparableValue(colStat.min());\n+            BigDecimal maxStat = getComparableValue(colStat.max());\n+\n+            if (minStat == null || maxStat == null)\n+                return estimatePercentFallback(min, max);\n+\n+            BigDecimal start = (minValue == null || minValue.compareTo(minStat) < 0) ? minStat : minValue;\n+            BigDecimal end = (maxValue == null || maxValue.compareTo(maxStat) > 0) ? maxStat : maxValue;\n+\n+            BigDecimal actual = end.subtract(start);\n+\n+            if (actual.signum() < 0)\n+                return 0;\n+\n+            BigDecimal total = maxStat.subtract(minStat);\n+\n+            if (total.signum() < 0)\n+                return estimatePercentFallback(min, max);\n+\n+            // If one select from column with exactly one (same for all rows) value - all rows will be selected if\n+            // the border is equal to that single value\n+            if (total.signum() == 0)\n+                return (minStat.equals(minValue)) ? 100 : 0;", "originalCommit": "bd7b54c77f5706581c4af1f3f2e6cf5345ae2ff1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTMyNTM2OQ==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r521325369", "bodyText": "missed @Override", "author": "korlov42", "createdAt": "2020-11-11T12:31:24Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/opt/H2IndexCostedBase.java", "diffHunk": "@@ -641,22 +665,625 @@ else if (needsToReadFromScanIndex)\n          * Cost function.\n          * See more: {@link BaseIndex#getCostRangeIndex}.\n          */\n-        long getCostRangeIndex(int[] masks, long rowCount,\n-            TableFilter[] filters, int filter, SortOrder sortOrder,\n-            boolean isScanIndex, AllColumnsForPlan allColumnsSet);\n+        long getCostRangeIndex(Session ses, int[] masks, long rowCount,\n+                               TableFilter[] filters, int filter, SortOrder sortOrder,\n+                               boolean isScanIndex, AllColumnsForPlan allColumnsSet);\n     }\n \n     /**\n      *\n      */\n     private enum CostFunctionType {\n-        /** Last. */\n+        /**\n+         * Last.\n+         */\n         LAST,\n \n-        /** Compatible with ver. 8.7.12. */\n+        /**\n+         * Compatible with ver. 8.7.28\n+         */\n+        COMPATIBLE_8_7_28,\n+\n+        /**\n+         * Compatible with ver. 8.7.12.\n+         */\n         COMPATIBLE_8_7_12,\n \n-        /** Compatible with ver. 8.7.6. */\n+        /**\n+         * Compatible with ver. 8.7.6.\n+         */\n         COMPATIBLE_8_7_6\n     }\n+\n+    /**\n+     * Cost function implementation.\n+     */\n+    private final class CostFunctionLast implements CostFunction {\n+        /**\n+         * Math context to use in estimations calculations.\n+         */\n+        private final MathContext MATH_CONTEXT = MathContext.DECIMAL64;\n+\n+        /**\n+         * Selectivity for closed range queries, in percent.\n+         */\n+        private final int RANGE_CLOSE_SELECTIVITY = 25;\n+\n+        /**\n+         * Selectivity for open range queries, in percent.\n+         */\n+        private final int RANGE_OPEN_SELECTIVITY = 33;\n+\n+        /**\n+         * Row cost calculation.\n+         *\n+         * @param ses Session.\n+         * @param filter Table filter.\n+         * @param masks Masks array.\n+         * @param rowCount Total rows count.\n+         * @param locTblStats Local table statistics.\n+         * @return Row cost.\n+         */\n+        private long rowCost(Session ses, TableFilter filter, int[] masks, long rowCount,\n+                             ObjectStatisticsImpl locTblStats) {\n+            int totalCardinality = 0;\n+\n+            long rowsCost = rowCount;\n+\n+            if (masks != null) {\n+                int i = 0, len = columns.length;\n+\n+                while (i < len) {\n+                    Column column = columns[i++];\n+                    ColumnStatistics colStats = getColumnStatistics(locTblStats, column);\n+\n+                    int index = column.getColumnId();\n+                    int mask = masks[index];\n+\n+                    if (isByteFlag(mask, IndexCondition.EQUALITY)) {\n+                        if (i == len && getIndexType().isUnique()) {\n+                            rowsCost = 3;\n+\n+                            break;\n+                        }\n+                        // Estimate by is null\n+                        Value equalValue = getEqualValue(ses, column, filter);\n+                        Boolean equalNull = (equalValue == null) ? null : equalValue.getValueType() == Value.NULL;\n+                        rowCount = getColumnSize(colStats, rowCount, equalNull);\n+\n+                        if (colStats != null && equalNull == Boolean.TRUE) {\n+                            rowsCost = Math.min(5 + Math.max(rowsCost * colStats.nulls() / 100, 1), rowsCost -\n+                                    (i > 0 ? 1 : 0));\n+                            continue;\n+                        }\n+                        if (colStats != null && equalNull == Boolean.FALSE)\n+                            rowsCost = rowsCost * (100 - colStats.nulls()) / 100;\n+\n+                        int cardinality = getColumnCardinality(colStats, column);\n+\n+                        totalCardinality = 100 - ((100 - totalCardinality) * (100 - cardinality) / 100);\n+\n+                        long distinctRows = Math.round((double) rowCount * totalCardinality / 100);\n+\n+                        if (distinctRows <= 0)\n+                            distinctRows = 1;\n+\n+                        rowsCost = Math.min(5 + Math.max(rowsCost / distinctRows, 1), rowsCost - (i > 0 ? 1 : 0));\n+                    }\n+                    else if (isByteFlag(mask, IndexCondition.RANGE)\n+                            || isByteFlag(mask, IndexCondition.START)\n+                            || isByteFlag(mask, IndexCondition.END)) {\n+                        Value min = getStartValue(ses, column, filter);\n+                        Value max = getEndValue(ses, column, filter);\n+                        int percent = estimatePercent(colStats, min, max);\n+\n+                        rowsCost = Math.min(5 + rowsCost * percent / 100, rowsCost - (i > 0 ? 1 : 0));\n+\n+                        break;\n+                    }\n+                    else if (isNullFilter(ses, column, filter)) {\n+                        if (colStats != null)\n+                            rowsCost = Math.min(5 + Math.max(rowsCost * colStats.nulls() / 100, 1), rowsCost -\n+                                    (i > 0 ? 1 : 0));\n+                    }\n+                    else if (isNotNullFilter(ses, column, filter)) {\n+                        if (colStats != null)\n+                            rowsCost = Math.min(5 + Math.max(rowsCost * (100 - colStats.nulls()) / 100, 1), rowsCost -\n+                                    (i > 0 ? 1 : 0));\n+                    }\n+                    else\n+                        break;\n+                }\n+            }\n+            return rowsCost;\n+        }\n+\n+        /**\n+         * Try to get column cardinality from statistics, if there is no such - fall back to H2 column selectivity.\n+         *\n+         * @param colStats Column statistics.\n+         * @param column Column.\n+         * @return Column cardinality in percents.\n+         */\n+        private int getColumnCardinality(@Nullable ColumnStatistics colStats, Column column) {\n+            return (colStats == null) ? column.getSelectivity() : colStats.cardinality();\n+        }\n+\n+        /**\n+         * Get total number of values in column.\n+         *\n+         * @param colStats Column statistics.\n+         * @param rowCount Total row count in table.\n+         * @param nulls if {@code true} - try to estimate only nulls count,\n+         *              if {@code false} - try to estimate only non null count,\n+         *              if {@code null} - try to estimate total count of values.\n+         * @return Column value count.\n+         */\n+        private long getColumnSize(@Nullable ColumnStatistics colStats, long rowCount, Boolean nulls) {\n+            if (colStats == null)\n+                return rowCount;\n+            else if (nulls == null)\n+                return colStats.total();\n+            else if (nulls)\n+                return colStats.total() * colStats.nulls() / 100;\n+            else\n+                return colStats.total() * (100 - colStats.nulls()) / 100;\n+        }\n+\n+        /**\n+         * Get constant value if there are clause with equal condition for specified column.\n+         *\n+         * @param ses Session.\n+         * @param column Column to get value by.\n+         * @param filter Table filter.\n+         * @return \"Equal\" value or {@code null} if there are no equal clause with constant expression.\n+         */\n+        private Value getEqualValue(Session ses, Column column, TableFilter filter) {\n+            Value maxValue = null;\n+            for (IndexCondition cond : filter.getIndexConditions()) {\n+                if (!column.equals(cond.getColumn()))\n+                    continue;\n+\n+                if (isByteFlag(cond.getCompareType(), Comparison.EQUAL) && cond.isEvaluatable()) {\n+\n+                    Expression expr = cond.getExpression();\n+                    if (expr != null && expr.isConstant()) {\n+                        Value curVal = cond.getCurrentValue(ses);\n+                        if (null == maxValue || (curVal != null || filter.getTable().compareValues(curVal, maxValue) < 0))\n+                            maxValue = curVal;\n+                    }\n+                }\n+            }\n+            return maxValue;\n+        }\n+\n+        /**\n+         * Get \"start\" value - constant for \"bigger\" or \"bigger or equals\" clause.\n+         *\n+         * @param ses Session.\n+         * @param column Column to get value by.\n+         * @param filter Table filter.\n+         * @return \"Start\" value or {@code null} if there are no such clause with constant expression.\n+         */\n+        private Value getStartValue(Session ses, Column column, TableFilter filter) {\n+            if (filter == null)\n+                return null;\n+            Value maxValue = null;\n+            for (IndexCondition cond : filter.getIndexConditions()) {\n+                if (!column.equals(cond.getColumn()))\n+                    continue;\n+\n+                if ((isByteFlag(cond.getCompareType(), Comparison.BIGGER)\n+                        || isByteFlag(cond.getCompareType(), Comparison.BIGGER_EQUAL))\n+                        && cond.isEvaluatable()) {\n+\n+                    Expression expr = cond.getExpression();\n+                    if (expr != null && expr.isConstant()) {\n+                        Value curVal = cond.getCurrentValue(ses);\n+                        if (null == maxValue || (curVal != null || filter.getTable().compareValues(curVal, maxValue) < 0))\n+                            maxValue = curVal;\n+                    }\n+                }\n+            }\n+            return maxValue;\n+        }\n+\n+        /**\n+         * Get \"end\" value - constant for \"smaller\" or \"smaller or equal\" clause.\n+         *\n+         * @param ses Session.\n+         * @param column Column to get value by.\n+         * @param filter Table filter.\n+         * @return \"End\" value of {@code null} if there are no such clause with constant expression.\n+         */\n+        private Value getEndValue(Session ses, Column column, TableFilter filter) {\n+            if (filter == null)\n+                return null;\n+            Value minValue = null;\n+            for (IndexCondition cond : filter.getIndexConditions()) {\n+                if (!column.equals(cond.getColumn()))\n+                    continue;\n+\n+                if ((isByteFlag(cond.getCompareType(), Comparison.SMALLER)\n+                        || isByteFlag(cond.getCompareType(), Comparison.SMALLER_EQUAL))\n+                        && cond.isEvaluatable()) {\n+                    Expression expr = cond.getExpression();\n+                    if (expr != null && expr.isConstant()) {\n+                        Value curVal = cond.getCurrentValue(ses);\n+                        if (null == minValue || (curVal != null || filter.getTable().compareValues(minValue, curVal) < 0))\n+                            minValue = curVal;\n+                    }\n+                }\n+            }\n+            return minValue;\n+        }\n+\n+        /**\n+         * Check if specified filter compare specified column to not null.\n+         *\n+         * @param ses Session to resolve values.\n+         * @param column Column to check.\n+         * @param filter Table filter.\n+         * @return {@code true} if column value should be null, {@code falce} otherwise (or if it not sure).\n+         */\n+        private boolean isNotNullFilter(Session ses, Column column, TableFilter filter) {\n+            // TODO: check not null expression (TableFilter contains only fullCondition without getter to check it)\n+            return false;\n+        }\n+\n+        /**\n+         * Check if specified filter compare specified column to null.\n+         *\n+         * @param ses Session to resolve values.\n+         * @param column Column to check.\n+         * @param filter Table filter.\n+         * @return {@code true} if column value should be null, {@code falce} otherwise (or if it not sure).\n+         */\n+        private boolean isNullFilter(Session ses, Column column, TableFilter filter) {\n+            if (filter == null)\n+                return false;\n+            for (IndexCondition cond : filter.getIndexConditions()) {\n+                if (column.equals(cond.getColumn()))\n+                    continue;\n+\n+                if (isByteFlag(cond.getCompareType(), Comparison.SPATIAL_INTERSECTS) && cond.isEvaluatable()) {\n+                    Expression expr = cond.getExpression();\n+\n+                    if (expr != null && expr.isConstant()) {\n+                        Value curVal = cond.getCurrentValue(ses);\n+\n+                        if (curVal != null && curVal.getValueType() == Value.NULL)\n+                            return true;\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+\n+        /**\n+         * Test if value contains all masks bits.\n+         *\n+         * @param value Value to test.\n+         * @param mask Mask to test by.\n+         * @return {@code true} if value contains all necessary bits, {@code false} otherwise.\n+         */\n+        private boolean isByteFlag(int value, int mask) {\n+            return (value & mask) == mask;\n+        }\n+\n+        /**\n+         * Estimate percent of selected rows by specified min/max conditions (of total rows, with nulls).\n+         *\n+         * @param colStat Column statistics to use, if exists.\n+         * @param min The lower border.\n+         * @param max The higher border.\n+         * @return Percent of total rows, selected with specified conditions (0-100).\n+         */\n+        private int estimatePercent(ColumnStatistics colStat, Value min, Value max) {\n+            if (colStat == null || colStat.min() == null || colStat.max() == null)\n+                // Fall back to previous behaviour without statistics, even without min/max testing\n+                return estimatePercentFallback(min, max);\n+\n+            BigDecimal minValue = (min == null) ? null : getComparableValue(min);\n+            BigDecimal maxValue = (max == null) ? null : getComparableValue(max);\n+\n+            if (minValue == null && maxValue == null)\n+                return estimatePercentFallback(min, max);\n+\n+            BigDecimal minStat = getComparableValue(colStat.min());\n+            BigDecimal maxStat = getComparableValue(colStat.max());\n+\n+            if (minStat == null || maxStat == null)\n+                return estimatePercentFallback(min, max);\n+\n+            BigDecimal start = (minValue == null || minValue.compareTo(minStat) < 0) ? minStat : minValue;\n+            BigDecimal end = (maxValue == null || maxValue.compareTo(maxStat) > 0) ? maxStat : maxValue;\n+\n+            BigDecimal actual = end.subtract(start);\n+\n+            if (actual.signum() < 0)\n+                return 0;\n+\n+            BigDecimal total = maxStat.subtract(minStat);\n+\n+            if (total.signum() < 0)\n+                return estimatePercentFallback(min, max);\n+\n+            // If one select from column with exactly one (same for all rows) value - all rows will be selected if\n+            // the border is equal to that single value\n+            if (total.signum() == 0)\n+                return (minStat.equals(minValue)) ? 100 : 0;\n+\n+            // 1) actual range divided by total range to get simple piece of table (selecting values part, 0-1)\n+            // 2) taking into account nulls by multiplying by percent of non null values: (100 - null)/100\n+            // 3) but we need result in percent, so instead of multiplying it by 100 just remove division by 100 from second step\n+            int result = actual.multiply(BigDecimal.valueOf(100 - colStat.nulls())).divide(total, MATH_CONTEXT).intValue();\n+            return result > 100 ? 100 : result;\n+        }\n+\n+        /**\n+         * Fallback percent estimation.\n+         *\n+         * @param min Min border.\n+         * @param max Max border.\n+         * @return Percent estimation of returning rows.\n+         */\n+        private int estimatePercentFallback(Value min, Value max) {\n+            return (min == null || max == null) ? RANGE_OPEN_SELECTIVITY : RANGE_CLOSE_SELECTIVITY;\n+        }\n+\n+        /**\n+         * Convert specified value into comparable type: BigDecimal,\n+         *\n+         * @param value Value to convert to comparable form.\n+         * @return Comparable form of value.\n+         */\n+        private BigDecimal getComparableValue(Value value) {\n+            switch (value.getValueType()) {\n+                case Value.NULL:\n+                    throw new IllegalArgumentException(\"Can't compare null values\");\n+\n+                case Value.BOOLEAN:\n+                    return new BigDecimal(value.getBoolean() ? 1 : 0);\n+\n+                case Value.BYTE:\n+                    return new BigDecimal(value.getByte());\n+\n+                case Value.SHORT:\n+                    return new BigDecimal(value.getShort());\n+\n+                case Value.INT:\n+                    return new BigDecimal(value.getInt());\n+\n+                case Value.LONG:\n+                    return new BigDecimal(value.getLong());\n+\n+                case Value.DECIMAL:\n+                    return value.getBigDecimal();\n+\n+                case Value.DOUBLE:\n+                    return new BigDecimal(value.getDouble());\n+\n+                case Value.FLOAT:\n+                    return new BigDecimal(value.getFloat());\n+\n+                case Value.DATE:\n+                    return new BigDecimal(value.getDate().getTime());\n+\n+                case Value.TIME:\n+                    return new BigDecimal(value.getTime().getTime());\n+\n+                case Value.TIMESTAMP:\n+                    return new BigDecimal(value.getTimestamp().getTime());\n+\n+                case Value.BYTES:\n+                    BigInteger bigInteger = new BigInteger(1, value.getBytes());\n+                    return new BigDecimal(bigInteger);\n+\n+                case Value.STRING:\n+                case Value.STRING_FIXED:\n+                case Value.STRING_IGNORECASE:\n+                case Value.ROW: // Intentionally converts Value.ROW to GridH2Array to preserve compatibility\n+                case Value.ARRAY:\n+                case Value.JAVA_OBJECT:\n+                case Value.GEOMETRY:\n+                    return null;\n+\n+                case Value.UUID:\n+                    BigInteger bigInt = new BigInteger(1, value.getBytes());\n+                    return new BigDecimal(bigInt);\n+\n+                default:\n+                    throw new IllegalStateException(\"Unsupported H2 type: \" + value.getType());\n+            }\n+        }\n+\n+        /**\n+         * Get column statistics.\n+         *\n+         * @param locTblStats Whole table statistics, can be {@code null}.\n+         * @param column Column to get statistics by.\n+         * @return Column statistics or {@code null}.\n+         */\n+        private ColumnStatistics getColumnStatistics(@Nullable ObjectStatisticsImpl locTblStats, Column column) {\n+            return (locTblStats == null) ? null : locTblStats.columnStatistics(column.getName());\n+        }\n+\n+        /**\n+         * Estimate sorting cost.\n+         *\n+         * @param rowCount Total rows count.\n+         * @param filters Filters array.\n+         * @param filter Column filter index.\n+         * @param sortOrder Sort order.\n+         * @param isScanIndex Flag if current index is a scan index.\n+         * @return Sorting cost.\n+         */\n+        private long sortingCost(\n+                long rowCount,\n+                TableFilter[] filters,\n+                int filter,\n+                SortOrder sortOrder,\n+                boolean isScanIndex\n+        ) {\n+            if (sortOrder == null)\n+                return 0;\n+\n+            long sortingCost = 100 + rowCount / 10;\n+\n+            if (!isScanIndex) {\n+                boolean sortOrderMatches = true;\n+                int coveringCount = 0;\n+                int[] sortTypes = sortOrder.getSortTypes();\n+\n+                TableFilter tableFilter = filters == null ? null : filters[filter];\n+\n+                for (int i = 0, len = sortTypes.length; i < len; i++) {\n+                    if (i >= indexColumns.length) {\n+                        // We can still use this index if we are sorting by more\n+                        // than it's columns, it's just that the coveringCount\n+                        // is lower than with an index that contains\n+                        // more of the order by columns.\n+                        break;\n+                    }\n+\n+                    Column col = sortOrder.getColumn(i, tableFilter);\n+\n+                    if (col == null) {\n+                        sortOrderMatches = false;\n+\n+                        break;\n+                    }\n+\n+                    IndexColumn indexCol = indexColumns[i];\n+\n+                    if (!col.equals(indexCol.column)) {\n+                        sortOrderMatches = false;\n+\n+                        break;\n+                    }\n+\n+                    int sortType = sortTypes[i];\n+\n+                    if (sortType != indexCol.sortType) {\n+                        sortOrderMatches = false;\n+\n+                        break;\n+                    }\n+\n+                    coveringCount++;\n+                }\n+\n+                if (sortOrderMatches)\n+                    // \"coveringCount\" makes sure that when we have two\n+                    // or more covering indexes, we choose the one\n+                    // that covers more.\n+                    sortingCost = 100 - coveringCount;\n+            }\n+            return sortingCost;\n+        }\n+\n+        /**\n+         * Get cost range.\n+         *\n+         * @param ses Session.\n+         * @param masks Condition masks.\n+         * @param rowCount Total row count.\n+         * @param filters Filters array.\n+         * @param filter Filter array index.\n+         * @param sortOrder Sort order.\n+         * @param isScanIndex Flag if current index is a scan index.\n+         * @param allColumnsSet All columns to select.\n+         * @return The cost.\n+         */\n+        public long getCostRangeIndex(Session ses, int[] masks, long rowCount, TableFilter[] filters, int filter,", "originalCommit": "bd7b54c77f5706581c4af1f3f2e6cf5345ae2ff1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "82e123964988ef0134daeb8ece4059e96173cee8", "url": "https://github.com/gridgain/gridgain/commit/82e123964988ef0134daeb8ece4059e96173cee8", "message": "GG-18652: fix cost function, minor change some signatures, codestyle fixes and some unit tests for StatisticsCollector and StatisticsRepository.", "committedDate": "2020-11-18T06:03:41Z", "type": "commit"}, {"oid": "b47533bdad6d667c155786f3f5610be6028253f7", "url": "https://github.com/gridgain/gridgain/commit/b47533bdad6d667c155786f3f5610be6028253f7", "message": "GG-18652: one more test", "committedDate": "2020-11-18T13:09:10Z", "type": "commit"}, {"oid": "3dbbbe0ef0d1ce53324e9ba5876c82a0888d04db", "url": "https://github.com/gridgain/gridgain/commit/3dbbbe0ef0d1ce53324e9ba5876c82a0888d04db", "message": "Merge remote-tracking branch 'gridgain-ce/master' into gg-18652", "committedDate": "2020-11-18T13:14:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjYzODMyNQ==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r526638325", "bodyText": "commented code", "author": "korlov42", "createdAt": "2020-11-19T07:11:52Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/opt/H2IndexCostedBase.java", "diffHunk": "@@ -62,15 +82,14 @@ protected H2IndexCostedBase(GridH2Table tbl, String name, IndexColumn[] cols, In\n                 IgniteSystemProperties.getString(\n                     IgniteSystemProperties.IGNITE_INDEX_COST_FUNCTION,\n                     CostFunctionType.LAST.name()));\n-        }\n-        catch (IllegalArgumentException e) {\n+        } catch (IllegalArgumentException e) {\n             LT.warn(log, \"Invalid cost function: \"\n                 + IgniteSystemProperties.getString(IgniteSystemProperties.IGNITE_INDEX_COST_FUNCTION)\n                 + \", the LAST cost function is used. Available functions: \" + Arrays.toString(CostFunctionType.values()));\n \n             costFuncType = CostFunctionType.LAST;\n         }\n-\n+        //costFuncType = CostFunctionType.COMPATIBLE_8_7_28;", "originalCommit": "3dbbbe0ef0d1ce53324e9ba5876c82a0888d04db", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9f18dcd2e5482f721b175305e9915ab7b1f3d36c", "url": "https://github.com/gridgain/gridgain/commit/9f18dcd2e5482f721b175305e9915ab7b1f3d36c", "message": "GG-18652: remove commented code", "committedDate": "2020-11-19T09:02:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU4NDc1NQ==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508584755", "bodyText": "Is it possible to postpone statistics update for this partition and proceed with others instead of blocking a thread.", "author": "AMashenkov", "createdAt": "2020-10-20T15:00:08Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/IgniteStatisticsManagerImpl.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.ignite.IgniteAuthenticationException;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.processors.cache.distributed.dht.topology.GridDhtLocalPartition;\n+import org.apache.ignite.internal.processors.cache.persistence.CacheDataRow;\n+import org.apache.ignite.internal.processors.cache.query.QueryTable;\n+import org.apache.ignite.internal.processors.query.GridQueryTypeDescriptor;\n+import org.apache.ignite.internal.processors.query.IgniteStatisticsRepositoryImpl;\n+import org.apache.ignite.internal.processors.query.h2.SchemaManager;\n+import org.apache.ignite.internal.processors.query.h2.opt.GridH2RowDescriptor;\n+import org.apache.ignite.internal.processors.query.h2.opt.GridH2Table;\n+import org.apache.ignite.internal.processors.query.h2.opt.H2Row;\n+import org.gridgain.internal.h2.table.Column;\n+\n+import static org.apache.ignite.internal.processors.cache.distributed.dht.topology.GridDhtPartitionState.MOVING;\n+import static org.apache.ignite.internal.processors.cache.distributed.dht.topology.GridDhtPartitionState.OWNING;\n+\n+public class IgniteStatisticsManagerImpl implements IgniteStatisticsManager {\n+\n+    /** Logger. */\n+    private IgniteLogger log;\n+\n+    private final GridKernalContext ctx;\n+\n+    private final SchemaManager schemaMgr;\n+\n+    private final IgniteStatisticsRepository statsRepos;\n+\n+    public IgniteStatisticsManagerImpl(GridKernalContext ctx, SchemaManager schemaMgr) {\n+        this.ctx = ctx;\n+        this.schemaMgr = schemaMgr;\n+\n+        log = ctx.log(IgniteStatisticsManagerImpl.class);\n+        statsRepos = new IgniteStatisticsRepositoryImpl(ctx);\n+    }\n+\n+    public IgniteStatisticsRepository statisticsRepository() {\n+        return statsRepos;\n+    }\n+\n+    @Override public ObjectStatistics getLocalStatistics(String schemaName, String objName) {\n+        return statsRepos.getLocalStatistics(new StatsKey(schemaName, objName));\n+    }\n+\n+    @Override public void clearObjectStatistics(String schemaName, String objName, String... colNames) {\n+        StatsKey key = new StatsKey(schemaName, objName);\n+        statsRepos.clearLocalPartitionsStatistics(key, colNames);\n+        statsRepos.clearLocalStatistics(key, colNames);\n+        statsRepos.clearGlobalStatistics(key, colNames);\n+    }\n+\n+    /**\n+     * Filter columns by specified names.\n+     *\n+     * @param columns columns to filter.\n+     * @param colNames names.\n+     * @return column with specified names.\n+     */\n+    private Column[] filterColumns(Column[] columns, String... colNames) {\n+        if (colNames == null || colNames.length == 0) {\n+            return columns;\n+        }\n+        List<Column> resultList = new ArrayList<>(colNames.length);\n+\n+        for (String colName : colNames)\n+            for (Column col : columns)\n+\n+                if (colName.equals(col.getName())) {\n+                    resultList.add(col);\n+                    break;\n+                }\n+\n+        return resultList.toArray(new Column[resultList.size()]);\n+    }\n+\n+    @Override public void collectObjectStatistics(String schemaName, String objName, String... colNames)\n+            throws IgniteCheckedException {\n+        GridH2Table tbl = schemaMgr.dataTable(schemaName, objName);\n+        if (tbl == null)\n+            throw new IgniteAuthenticationException(String.format(\"Can't find table %s.%s\", schemaName, objName));\n+\n+        if (log.isDebugEnabled())\n+            log.debug(String.format(\"Starting statistics collection by %s.%s object\", schemaName, objName));\n+\n+        Column[] selectedColumns;\n+        boolean fullStat;\n+        if (colNames == null || colNames.length == 0) {\n+            fullStat = true;\n+            selectedColumns = tbl.getColumns();\n+        } else {\n+            fullStat = false;\n+            selectedColumns = filterColumns(tbl.getColumns(), colNames);\n+        }\n+\n+        Collection<ObjectPartitionStatisticsImpl> partsStats = collectPartitionStatistics(tbl, selectedColumns);\n+        StatsKey key = new StatsKey(tbl.identifier().schema(), tbl.identifier().table());\n+        statsRepos.saveLocalPartitionsStatistics(key, partsStats, fullStat);\n+\n+        ObjectStatisticsImpl tblStats = aggregateLocalStatistics(tbl, selectedColumns, partsStats);\n+        statsRepos.saveLocalStatistics(key, tblStats, fullStat);\n+        if (log.isDebugEnabled())\n+            log.debug(String.format(\"Statistics collection by %s.%s object is finished.\", schemaName, objName));\n+    }\n+\n+    private Collection<ObjectPartitionStatisticsImpl> collectPartitionStatistics(GridH2Table tbl, Column[] selectedColumns)\n+            throws IgniteCheckedException {\n+        List<ObjectPartitionStatisticsImpl> tblPartStats = new ArrayList<>();\n+        GridH2RowDescriptor desc = tbl.rowDescriptor();\n+        String tblName = tbl.getName();\n+\n+        for (GridDhtLocalPartition locPart : tbl.cacheContext().topology().localPartitions()) {\n+            final boolean reserved = locPart.reserve();\n+\n+            try {\n+                if (!reserved || (locPart.state() != OWNING && locPart.state() != MOVING)\n+                        || !locPart.primary(ctx.discovery().topologyVersionEx()))\n+                    continue;\n+\n+                if (locPart.state() == MOVING)\n+                    tbl.cacheContext().preloader().syncFuture().get();", "originalCommit": "71b5964ecf232e018207af5caf69767ad3d11fa8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU4NTQ0NA==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508585444", "bodyText": "Let's add a check \"if (log.isInfoEnabled())\"", "author": "AMashenkov", "createdAt": "2020-10-20T15:01:00Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/IgniteStatisticsManagerImpl.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.ignite.IgniteAuthenticationException;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.processors.cache.distributed.dht.topology.GridDhtLocalPartition;\n+import org.apache.ignite.internal.processors.cache.persistence.CacheDataRow;\n+import org.apache.ignite.internal.processors.cache.query.QueryTable;\n+import org.apache.ignite.internal.processors.query.GridQueryTypeDescriptor;\n+import org.apache.ignite.internal.processors.query.IgniteStatisticsRepositoryImpl;\n+import org.apache.ignite.internal.processors.query.h2.SchemaManager;\n+import org.apache.ignite.internal.processors.query.h2.opt.GridH2RowDescriptor;\n+import org.apache.ignite.internal.processors.query.h2.opt.GridH2Table;\n+import org.apache.ignite.internal.processors.query.h2.opt.H2Row;\n+import org.gridgain.internal.h2.table.Column;\n+\n+import static org.apache.ignite.internal.processors.cache.distributed.dht.topology.GridDhtPartitionState.MOVING;\n+import static org.apache.ignite.internal.processors.cache.distributed.dht.topology.GridDhtPartitionState.OWNING;\n+\n+public class IgniteStatisticsManagerImpl implements IgniteStatisticsManager {\n+\n+    /** Logger. */\n+    private IgniteLogger log;\n+\n+    private final GridKernalContext ctx;\n+\n+    private final SchemaManager schemaMgr;\n+\n+    private final IgniteStatisticsRepository statsRepos;\n+\n+    public IgniteStatisticsManagerImpl(GridKernalContext ctx, SchemaManager schemaMgr) {\n+        this.ctx = ctx;\n+        this.schemaMgr = schemaMgr;\n+\n+        log = ctx.log(IgniteStatisticsManagerImpl.class);\n+        statsRepos = new IgniteStatisticsRepositoryImpl(ctx);\n+    }\n+\n+    public IgniteStatisticsRepository statisticsRepository() {\n+        return statsRepos;\n+    }\n+\n+    @Override public ObjectStatistics getLocalStatistics(String schemaName, String objName) {\n+        return statsRepos.getLocalStatistics(new StatsKey(schemaName, objName));\n+    }\n+\n+    @Override public void clearObjectStatistics(String schemaName, String objName, String... colNames) {\n+        StatsKey key = new StatsKey(schemaName, objName);\n+        statsRepos.clearLocalPartitionsStatistics(key, colNames);\n+        statsRepos.clearLocalStatistics(key, colNames);\n+        statsRepos.clearGlobalStatistics(key, colNames);\n+    }\n+\n+    /**\n+     * Filter columns by specified names.\n+     *\n+     * @param columns columns to filter.\n+     * @param colNames names.\n+     * @return column with specified names.\n+     */\n+    private Column[] filterColumns(Column[] columns, String... colNames) {\n+        if (colNames == null || colNames.length == 0) {\n+            return columns;\n+        }\n+        List<Column> resultList = new ArrayList<>(colNames.length);\n+\n+        for (String colName : colNames)\n+            for (Column col : columns)\n+\n+                if (colName.equals(col.getName())) {\n+                    resultList.add(col);\n+                    break;\n+                }\n+\n+        return resultList.toArray(new Column[resultList.size()]);\n+    }\n+\n+    @Override public void collectObjectStatistics(String schemaName, String objName, String... colNames)\n+            throws IgniteCheckedException {\n+        GridH2Table tbl = schemaMgr.dataTable(schemaName, objName);\n+        if (tbl == null)\n+            throw new IgniteAuthenticationException(String.format(\"Can't find table %s.%s\", schemaName, objName));\n+\n+        if (log.isDebugEnabled())\n+            log.debug(String.format(\"Starting statistics collection by %s.%s object\", schemaName, objName));\n+\n+        Column[] selectedColumns;\n+        boolean fullStat;\n+        if (colNames == null || colNames.length == 0) {\n+            fullStat = true;\n+            selectedColumns = tbl.getColumns();\n+        } else {\n+            fullStat = false;\n+            selectedColumns = filterColumns(tbl.getColumns(), colNames);\n+        }\n+\n+        Collection<ObjectPartitionStatisticsImpl> partsStats = collectPartitionStatistics(tbl, selectedColumns);\n+        StatsKey key = new StatsKey(tbl.identifier().schema(), tbl.identifier().table());\n+        statsRepos.saveLocalPartitionsStatistics(key, partsStats, fullStat);\n+\n+        ObjectStatisticsImpl tblStats = aggregateLocalStatistics(tbl, selectedColumns, partsStats);\n+        statsRepos.saveLocalStatistics(key, tblStats, fullStat);\n+        if (log.isDebugEnabled())\n+            log.debug(String.format(\"Statistics collection by %s.%s object is finished.\", schemaName, objName));\n+    }\n+\n+    private Collection<ObjectPartitionStatisticsImpl> collectPartitionStatistics(GridH2Table tbl, Column[] selectedColumns)\n+            throws IgniteCheckedException {\n+        List<ObjectPartitionStatisticsImpl> tblPartStats = new ArrayList<>();\n+        GridH2RowDescriptor desc = tbl.rowDescriptor();\n+        String tblName = tbl.getName();\n+\n+        for (GridDhtLocalPartition locPart : tbl.cacheContext().topology().localPartitions()) {\n+            final boolean reserved = locPart.reserve();\n+\n+            try {\n+                if (!reserved || (locPart.state() != OWNING && locPart.state() != MOVING)\n+                        || !locPart.primary(ctx.discovery().topologyVersionEx()))\n+                    continue;\n+\n+                if (locPart.state() == MOVING)\n+                    tbl.cacheContext().preloader().syncFuture().get();\n+\n+                long rowsCnt = 0;\n+\n+                List<ColumnStatisticsCollector> colStatsCollectors = new ArrayList<>(selectedColumns.length);\n+\n+                for (Column col : selectedColumns)\n+                    colStatsCollectors.add(new ColumnStatisticsCollector(col, tbl::compareValues));\n+\n+                for (CacheDataRow row : tbl.cacheContext().offheap().cachePartitionIterator(tbl.cacheId(), locPart.id(),\n+                        null, true)) {\n+                    GridQueryTypeDescriptor typeDesc = ctx.query().typeByValue(tbl.cacheName(),\n+                            tbl.cacheContext().cacheObjectContext(), row.key(), row.value(), false);\n+                    if (!tblName.equals(typeDesc.tableName()))\n+                        continue;\n+\n+                    rowsCnt++;\n+\n+                    H2Row row0 = desc.createRow(row);\n+\n+                    for (ColumnStatisticsCollector colStat : colStatsCollectors)\n+                        colStat.add(row0.getValue(colStat.col().getColumnId()));\n+\n+                }\n+\n+                Map<String, ColumnStatistics> colStats = colStatsCollectors.stream().collect(Collectors.toMap(\n+                        csc -> csc.col().getName(), csc -> csc.finish()\n+                ));\n+\n+                tblPartStats.add(new ObjectPartitionStatisticsImpl(locPart.id(), true, rowsCnt, locPart.updateCounter(),\n+                        colStats));\n+            }\n+            finally {\n+                if (reserved)\n+                    locPart.release();\n+            }\n+        }\n+\n+        return tblPartStats;\n+    }\n+\n+    public ObjectStatisticsImpl aggregateLocalStatistics(StatsKey key, Collection<ObjectPartitionStatisticsImpl> tblPartStats) {\n+        // For now there can be only tables\n+        GridH2Table table = schemaMgr.dataTable(key.schema(), key.obj());\n+\n+        if (table == null) {\n+            // remove all loaded statistics.\n+            log.info(\"Removing statistics for object \" + key + \" cause table doesn't exists.\");", "originalCommit": "71b5964ecf232e018207af5caf69767ad3d11fa8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU4NTYzNg==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508585636", "bodyText": "Javadoc.", "author": "AMashenkov", "createdAt": "2020-10-20T15:01:16Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/IgniteStatisticsManagerImpl.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.ignite.IgniteAuthenticationException;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.processors.cache.distributed.dht.topology.GridDhtLocalPartition;\n+import org.apache.ignite.internal.processors.cache.persistence.CacheDataRow;\n+import org.apache.ignite.internal.processors.cache.query.QueryTable;\n+import org.apache.ignite.internal.processors.query.GridQueryTypeDescriptor;\n+import org.apache.ignite.internal.processors.query.IgniteStatisticsRepositoryImpl;\n+import org.apache.ignite.internal.processors.query.h2.SchemaManager;\n+import org.apache.ignite.internal.processors.query.h2.opt.GridH2RowDescriptor;\n+import org.apache.ignite.internal.processors.query.h2.opt.GridH2Table;\n+import org.apache.ignite.internal.processors.query.h2.opt.H2Row;\n+import org.gridgain.internal.h2.table.Column;\n+\n+import static org.apache.ignite.internal.processors.cache.distributed.dht.topology.GridDhtPartitionState.MOVING;\n+import static org.apache.ignite.internal.processors.cache.distributed.dht.topology.GridDhtPartitionState.OWNING;\n+\n+public class IgniteStatisticsManagerImpl implements IgniteStatisticsManager {\n+\n+    /** Logger. */\n+    private IgniteLogger log;\n+\n+    private final GridKernalContext ctx;\n+\n+    private final SchemaManager schemaMgr;\n+\n+    private final IgniteStatisticsRepository statsRepos;\n+\n+    public IgniteStatisticsManagerImpl(GridKernalContext ctx, SchemaManager schemaMgr) {\n+        this.ctx = ctx;\n+        this.schemaMgr = schemaMgr;\n+\n+        log = ctx.log(IgniteStatisticsManagerImpl.class);\n+        statsRepos = new IgniteStatisticsRepositoryImpl(ctx);\n+    }\n+\n+    public IgniteStatisticsRepository statisticsRepository() {\n+        return statsRepos;\n+    }\n+\n+    @Override public ObjectStatistics getLocalStatistics(String schemaName, String objName) {\n+        return statsRepos.getLocalStatistics(new StatsKey(schemaName, objName));\n+    }\n+\n+    @Override public void clearObjectStatistics(String schemaName, String objName, String... colNames) {\n+        StatsKey key = new StatsKey(schemaName, objName);\n+        statsRepos.clearLocalPartitionsStatistics(key, colNames);\n+        statsRepos.clearLocalStatistics(key, colNames);\n+        statsRepos.clearGlobalStatistics(key, colNames);\n+    }\n+\n+    /**\n+     * Filter columns by specified names.\n+     *\n+     * @param columns columns to filter.\n+     * @param colNames names.\n+     * @return column with specified names.\n+     */\n+    private Column[] filterColumns(Column[] columns, String... colNames) {\n+        if (colNames == null || colNames.length == 0) {\n+            return columns;\n+        }\n+        List<Column> resultList = new ArrayList<>(colNames.length);\n+\n+        for (String colName : colNames)\n+            for (Column col : columns)\n+\n+                if (colName.equals(col.getName())) {\n+                    resultList.add(col);\n+                    break;\n+                }\n+\n+        return resultList.toArray(new Column[resultList.size()]);\n+    }\n+\n+    @Override public void collectObjectStatistics(String schemaName, String objName, String... colNames)\n+            throws IgniteCheckedException {\n+        GridH2Table tbl = schemaMgr.dataTable(schemaName, objName);\n+        if (tbl == null)\n+            throw new IgniteAuthenticationException(String.format(\"Can't find table %s.%s\", schemaName, objName));\n+\n+        if (log.isDebugEnabled())\n+            log.debug(String.format(\"Starting statistics collection by %s.%s object\", schemaName, objName));\n+\n+        Column[] selectedColumns;\n+        boolean fullStat;\n+        if (colNames == null || colNames.length == 0) {\n+            fullStat = true;\n+            selectedColumns = tbl.getColumns();\n+        } else {\n+            fullStat = false;\n+            selectedColumns = filterColumns(tbl.getColumns(), colNames);\n+        }\n+\n+        Collection<ObjectPartitionStatisticsImpl> partsStats = collectPartitionStatistics(tbl, selectedColumns);\n+        StatsKey key = new StatsKey(tbl.identifier().schema(), tbl.identifier().table());\n+        statsRepos.saveLocalPartitionsStatistics(key, partsStats, fullStat);\n+\n+        ObjectStatisticsImpl tblStats = aggregateLocalStatistics(tbl, selectedColumns, partsStats);\n+        statsRepos.saveLocalStatistics(key, tblStats, fullStat);\n+        if (log.isDebugEnabled())\n+            log.debug(String.format(\"Statistics collection by %s.%s object is finished.\", schemaName, objName));\n+    }\n+\n+    private Collection<ObjectPartitionStatisticsImpl> collectPartitionStatistics(GridH2Table tbl, Column[] selectedColumns)\n+            throws IgniteCheckedException {\n+        List<ObjectPartitionStatisticsImpl> tblPartStats = new ArrayList<>();\n+        GridH2RowDescriptor desc = tbl.rowDescriptor();\n+        String tblName = tbl.getName();\n+\n+        for (GridDhtLocalPartition locPart : tbl.cacheContext().topology().localPartitions()) {\n+            final boolean reserved = locPart.reserve();\n+\n+            try {\n+                if (!reserved || (locPart.state() != OWNING && locPart.state() != MOVING)\n+                        || !locPart.primary(ctx.discovery().topologyVersionEx()))\n+                    continue;\n+\n+                if (locPart.state() == MOVING)\n+                    tbl.cacheContext().preloader().syncFuture().get();\n+\n+                long rowsCnt = 0;\n+\n+                List<ColumnStatisticsCollector> colStatsCollectors = new ArrayList<>(selectedColumns.length);\n+\n+                for (Column col : selectedColumns)\n+                    colStatsCollectors.add(new ColumnStatisticsCollector(col, tbl::compareValues));\n+\n+                for (CacheDataRow row : tbl.cacheContext().offheap().cachePartitionIterator(tbl.cacheId(), locPart.id(),\n+                        null, true)) {\n+                    GridQueryTypeDescriptor typeDesc = ctx.query().typeByValue(tbl.cacheName(),\n+                            tbl.cacheContext().cacheObjectContext(), row.key(), row.value(), false);\n+                    if (!tblName.equals(typeDesc.tableName()))\n+                        continue;\n+\n+                    rowsCnt++;\n+\n+                    H2Row row0 = desc.createRow(row);\n+\n+                    for (ColumnStatisticsCollector colStat : colStatsCollectors)\n+                        colStat.add(row0.getValue(colStat.col().getColumnId()));\n+\n+                }\n+\n+                Map<String, ColumnStatistics> colStats = colStatsCollectors.stream().collect(Collectors.toMap(\n+                        csc -> csc.col().getName(), csc -> csc.finish()\n+                ));\n+\n+                tblPartStats.add(new ObjectPartitionStatisticsImpl(locPart.id(), true, rowsCnt, locPart.updateCounter(),\n+                        colStats));\n+            }\n+            finally {\n+                if (reserved)\n+                    locPart.release();\n+            }\n+        }\n+\n+        return tblPartStats;\n+    }\n+\n+    public ObjectStatisticsImpl aggregateLocalStatistics(StatsKey key, Collection<ObjectPartitionStatisticsImpl> tblPartStats) {", "originalCommit": "71b5964ecf232e018207af5caf69767ad3d11fa8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU4NTc5OA==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508585798", "bodyText": "Javadoc.", "author": "AMashenkov", "createdAt": "2020-10-20T15:01:27Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/IgniteStatisticsManagerImpl.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.ignite.IgniteAuthenticationException;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.processors.cache.distributed.dht.topology.GridDhtLocalPartition;\n+import org.apache.ignite.internal.processors.cache.persistence.CacheDataRow;\n+import org.apache.ignite.internal.processors.cache.query.QueryTable;\n+import org.apache.ignite.internal.processors.query.GridQueryTypeDescriptor;\n+import org.apache.ignite.internal.processors.query.IgniteStatisticsRepositoryImpl;\n+import org.apache.ignite.internal.processors.query.h2.SchemaManager;\n+import org.apache.ignite.internal.processors.query.h2.opt.GridH2RowDescriptor;\n+import org.apache.ignite.internal.processors.query.h2.opt.GridH2Table;\n+import org.apache.ignite.internal.processors.query.h2.opt.H2Row;\n+import org.gridgain.internal.h2.table.Column;\n+\n+import static org.apache.ignite.internal.processors.cache.distributed.dht.topology.GridDhtPartitionState.MOVING;\n+import static org.apache.ignite.internal.processors.cache.distributed.dht.topology.GridDhtPartitionState.OWNING;\n+\n+public class IgniteStatisticsManagerImpl implements IgniteStatisticsManager {\n+\n+    /** Logger. */\n+    private IgniteLogger log;\n+\n+    private final GridKernalContext ctx;\n+\n+    private final SchemaManager schemaMgr;\n+\n+    private final IgniteStatisticsRepository statsRepos;\n+\n+    public IgniteStatisticsManagerImpl(GridKernalContext ctx, SchemaManager schemaMgr) {\n+        this.ctx = ctx;\n+        this.schemaMgr = schemaMgr;\n+\n+        log = ctx.log(IgniteStatisticsManagerImpl.class);\n+        statsRepos = new IgniteStatisticsRepositoryImpl(ctx);\n+    }\n+\n+    public IgniteStatisticsRepository statisticsRepository() {\n+        return statsRepos;\n+    }\n+\n+    @Override public ObjectStatistics getLocalStatistics(String schemaName, String objName) {\n+        return statsRepos.getLocalStatistics(new StatsKey(schemaName, objName));\n+    }\n+\n+    @Override public void clearObjectStatistics(String schemaName, String objName, String... colNames) {\n+        StatsKey key = new StatsKey(schemaName, objName);\n+        statsRepos.clearLocalPartitionsStatistics(key, colNames);\n+        statsRepos.clearLocalStatistics(key, colNames);\n+        statsRepos.clearGlobalStatistics(key, colNames);\n+    }\n+\n+    /**\n+     * Filter columns by specified names.\n+     *\n+     * @param columns columns to filter.\n+     * @param colNames names.\n+     * @return column with specified names.\n+     */\n+    private Column[] filterColumns(Column[] columns, String... colNames) {\n+        if (colNames == null || colNames.length == 0) {\n+            return columns;\n+        }\n+        List<Column> resultList = new ArrayList<>(colNames.length);\n+\n+        for (String colName : colNames)\n+            for (Column col : columns)\n+\n+                if (colName.equals(col.getName())) {\n+                    resultList.add(col);\n+                    break;\n+                }\n+\n+        return resultList.toArray(new Column[resultList.size()]);\n+    }\n+\n+    @Override public void collectObjectStatistics(String schemaName, String objName, String... colNames)\n+            throws IgniteCheckedException {\n+        GridH2Table tbl = schemaMgr.dataTable(schemaName, objName);\n+        if (tbl == null)\n+            throw new IgniteAuthenticationException(String.format(\"Can't find table %s.%s\", schemaName, objName));\n+\n+        if (log.isDebugEnabled())\n+            log.debug(String.format(\"Starting statistics collection by %s.%s object\", schemaName, objName));\n+\n+        Column[] selectedColumns;\n+        boolean fullStat;\n+        if (colNames == null || colNames.length == 0) {\n+            fullStat = true;\n+            selectedColumns = tbl.getColumns();\n+        } else {\n+            fullStat = false;\n+            selectedColumns = filterColumns(tbl.getColumns(), colNames);\n+        }\n+\n+        Collection<ObjectPartitionStatisticsImpl> partsStats = collectPartitionStatistics(tbl, selectedColumns);\n+        StatsKey key = new StatsKey(tbl.identifier().schema(), tbl.identifier().table());\n+        statsRepos.saveLocalPartitionsStatistics(key, partsStats, fullStat);\n+\n+        ObjectStatisticsImpl tblStats = aggregateLocalStatistics(tbl, selectedColumns, partsStats);\n+        statsRepos.saveLocalStatistics(key, tblStats, fullStat);\n+        if (log.isDebugEnabled())\n+            log.debug(String.format(\"Statistics collection by %s.%s object is finished.\", schemaName, objName));\n+    }\n+\n+    private Collection<ObjectPartitionStatisticsImpl> collectPartitionStatistics(GridH2Table tbl, Column[] selectedColumns)\n+            throws IgniteCheckedException {\n+        List<ObjectPartitionStatisticsImpl> tblPartStats = new ArrayList<>();\n+        GridH2RowDescriptor desc = tbl.rowDescriptor();\n+        String tblName = tbl.getName();\n+\n+        for (GridDhtLocalPartition locPart : tbl.cacheContext().topology().localPartitions()) {\n+            final boolean reserved = locPart.reserve();\n+\n+            try {\n+                if (!reserved || (locPart.state() != OWNING && locPart.state() != MOVING)\n+                        || !locPart.primary(ctx.discovery().topologyVersionEx()))\n+                    continue;\n+\n+                if (locPart.state() == MOVING)\n+                    tbl.cacheContext().preloader().syncFuture().get();\n+\n+                long rowsCnt = 0;\n+\n+                List<ColumnStatisticsCollector> colStatsCollectors = new ArrayList<>(selectedColumns.length);\n+\n+                for (Column col : selectedColumns)\n+                    colStatsCollectors.add(new ColumnStatisticsCollector(col, tbl::compareValues));\n+\n+                for (CacheDataRow row : tbl.cacheContext().offheap().cachePartitionIterator(tbl.cacheId(), locPart.id(),\n+                        null, true)) {\n+                    GridQueryTypeDescriptor typeDesc = ctx.query().typeByValue(tbl.cacheName(),\n+                            tbl.cacheContext().cacheObjectContext(), row.key(), row.value(), false);\n+                    if (!tblName.equals(typeDesc.tableName()))\n+                        continue;\n+\n+                    rowsCnt++;\n+\n+                    H2Row row0 = desc.createRow(row);\n+\n+                    for (ColumnStatisticsCollector colStat : colStatsCollectors)\n+                        colStat.add(row0.getValue(colStat.col().getColumnId()));\n+\n+                }\n+\n+                Map<String, ColumnStatistics> colStats = colStatsCollectors.stream().collect(Collectors.toMap(\n+                        csc -> csc.col().getName(), csc -> csc.finish()\n+                ));\n+\n+                tblPartStats.add(new ObjectPartitionStatisticsImpl(locPart.id(), true, rowsCnt, locPart.updateCounter(),\n+                        colStats));\n+            }\n+            finally {\n+                if (reserved)\n+                    locPart.release();\n+            }\n+        }\n+\n+        return tblPartStats;\n+    }\n+\n+    public ObjectStatisticsImpl aggregateLocalStatistics(StatsKey key, Collection<ObjectPartitionStatisticsImpl> tblPartStats) {\n+        // For now there can be only tables\n+        GridH2Table table = schemaMgr.dataTable(key.schema(), key.obj());\n+\n+        if (table == null) {\n+            // remove all loaded statistics.\n+            log.info(\"Removing statistics for object \" + key + \" cause table doesn't exists.\");\n+            statsRepos.clearLocalPartitionsStatistics(key);\n+        }\n+        return aggregateLocalStatistics(table, table.getColumns(), tblPartStats);\n+    }\n+\n+    private ObjectStatisticsImpl aggregateLocalStatistics(GridH2Table tbl, Column[] selectedColumns,", "originalCommit": "71b5964ecf232e018207af5caf69767ad3d11fa8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU5MzA3Ng==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508593076", "bodyText": "Seems, it could be simplified.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (Column col : selectedColumns)\n          \n          \n            \n                        colPartStats.put(col, new ArrayList<>());\n          \n          \n            \n            \n          \n          \n            \n                    QueryTable tblId = tbl.identifier();\n          \n          \n            \n            \n          \n          \n            \n                    for (ObjectPartitionStatisticsImpl partStat : tblPartStats) {\n          \n          \n            \n                        for (Column col : selectedColumns) {\n          \n          \n            \n                            ColumnStatistics colPartStat = partStat.columnStatistics(col.getName());\n          \n          \n            \n                            if (colPartStat != null) {\n          \n          \n            \n                                colPartStats.compute(col, (k, v) -> {\n          \n          \n            \n                                    v.add(colPartStat);\n          \n          \n            \n                                    return v;\n          \n          \n            \n                                });\n          \n          \n            \n                            }\n          \n          \n            \n                        }\n          \n          \n            \n                        rowCnt += partStat.rowCount();\n          \n          \n            \n                    }\n          \n          \n            \n                    QueryTable tblId = tbl.identifier();\n          \n          \n            \n                    \n          \n          \n            \n                    for (Column col : selectedColumns) {\n          \n          \n            \n                        List colPartStatList = new ArrayList<>()\n          \n          \n            \n                       \n          \n          \n            \n                        colPartStats.put(col, colPartStatList);\n          \n          \n            \n                        \n          \n          \n            \n                        for (ObjectPartitionStatisticsImpl partStat : tblPartStats) {\n          \n          \n            \n                            ColumnStatistics colPartStat = partStat.columnStatistics(col.getName());\n          \n          \n            \n                            \n          \n          \n            \n                            if (colPartStat != null)\n          \n          \n            \n                                colPartStatList.add(colPartStat);\n          \n          \n            \n                                \n          \n          \n            \n                            rowCnt += partStat.rowCount();\n          \n          \n            \n                        }           \n          \n          \n            \n                    }", "author": "AMashenkov", "createdAt": "2020-10-20T15:10:36Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/IgniteStatisticsManagerImpl.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.ignite.IgniteAuthenticationException;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.processors.cache.distributed.dht.topology.GridDhtLocalPartition;\n+import org.apache.ignite.internal.processors.cache.persistence.CacheDataRow;\n+import org.apache.ignite.internal.processors.cache.query.QueryTable;\n+import org.apache.ignite.internal.processors.query.GridQueryTypeDescriptor;\n+import org.apache.ignite.internal.processors.query.IgniteStatisticsRepositoryImpl;\n+import org.apache.ignite.internal.processors.query.h2.SchemaManager;\n+import org.apache.ignite.internal.processors.query.h2.opt.GridH2RowDescriptor;\n+import org.apache.ignite.internal.processors.query.h2.opt.GridH2Table;\n+import org.apache.ignite.internal.processors.query.h2.opt.H2Row;\n+import org.gridgain.internal.h2.table.Column;\n+\n+import static org.apache.ignite.internal.processors.cache.distributed.dht.topology.GridDhtPartitionState.MOVING;\n+import static org.apache.ignite.internal.processors.cache.distributed.dht.topology.GridDhtPartitionState.OWNING;\n+\n+public class IgniteStatisticsManagerImpl implements IgniteStatisticsManager {\n+\n+    /** Logger. */\n+    private IgniteLogger log;\n+\n+    private final GridKernalContext ctx;\n+\n+    private final SchemaManager schemaMgr;\n+\n+    private final IgniteStatisticsRepository statsRepos;\n+\n+    public IgniteStatisticsManagerImpl(GridKernalContext ctx, SchemaManager schemaMgr) {\n+        this.ctx = ctx;\n+        this.schemaMgr = schemaMgr;\n+\n+        log = ctx.log(IgniteStatisticsManagerImpl.class);\n+        statsRepos = new IgniteStatisticsRepositoryImpl(ctx);\n+    }\n+\n+    public IgniteStatisticsRepository statisticsRepository() {\n+        return statsRepos;\n+    }\n+\n+    @Override public ObjectStatistics getLocalStatistics(String schemaName, String objName) {\n+        return statsRepos.getLocalStatistics(new StatsKey(schemaName, objName));\n+    }\n+\n+    @Override public void clearObjectStatistics(String schemaName, String objName, String... colNames) {\n+        StatsKey key = new StatsKey(schemaName, objName);\n+        statsRepos.clearLocalPartitionsStatistics(key, colNames);\n+        statsRepos.clearLocalStatistics(key, colNames);\n+        statsRepos.clearGlobalStatistics(key, colNames);\n+    }\n+\n+    /**\n+     * Filter columns by specified names.\n+     *\n+     * @param columns columns to filter.\n+     * @param colNames names.\n+     * @return column with specified names.\n+     */\n+    private Column[] filterColumns(Column[] columns, String... colNames) {\n+        if (colNames == null || colNames.length == 0) {\n+            return columns;\n+        }\n+        List<Column> resultList = new ArrayList<>(colNames.length);\n+\n+        for (String colName : colNames)\n+            for (Column col : columns)\n+\n+                if (colName.equals(col.getName())) {\n+                    resultList.add(col);\n+                    break;\n+                }\n+\n+        return resultList.toArray(new Column[resultList.size()]);\n+    }\n+\n+    @Override public void collectObjectStatistics(String schemaName, String objName, String... colNames)\n+            throws IgniteCheckedException {\n+        GridH2Table tbl = schemaMgr.dataTable(schemaName, objName);\n+        if (tbl == null)\n+            throw new IgniteAuthenticationException(String.format(\"Can't find table %s.%s\", schemaName, objName));\n+\n+        if (log.isDebugEnabled())\n+            log.debug(String.format(\"Starting statistics collection by %s.%s object\", schemaName, objName));\n+\n+        Column[] selectedColumns;\n+        boolean fullStat;\n+        if (colNames == null || colNames.length == 0) {\n+            fullStat = true;\n+            selectedColumns = tbl.getColumns();\n+        } else {\n+            fullStat = false;\n+            selectedColumns = filterColumns(tbl.getColumns(), colNames);\n+        }\n+\n+        Collection<ObjectPartitionStatisticsImpl> partsStats = collectPartitionStatistics(tbl, selectedColumns);\n+        StatsKey key = new StatsKey(tbl.identifier().schema(), tbl.identifier().table());\n+        statsRepos.saveLocalPartitionsStatistics(key, partsStats, fullStat);\n+\n+        ObjectStatisticsImpl tblStats = aggregateLocalStatistics(tbl, selectedColumns, partsStats);\n+        statsRepos.saveLocalStatistics(key, tblStats, fullStat);\n+        if (log.isDebugEnabled())\n+            log.debug(String.format(\"Statistics collection by %s.%s object is finished.\", schemaName, objName));\n+    }\n+\n+    private Collection<ObjectPartitionStatisticsImpl> collectPartitionStatistics(GridH2Table tbl, Column[] selectedColumns)\n+            throws IgniteCheckedException {\n+        List<ObjectPartitionStatisticsImpl> tblPartStats = new ArrayList<>();\n+        GridH2RowDescriptor desc = tbl.rowDescriptor();\n+        String tblName = tbl.getName();\n+\n+        for (GridDhtLocalPartition locPart : tbl.cacheContext().topology().localPartitions()) {\n+            final boolean reserved = locPart.reserve();\n+\n+            try {\n+                if (!reserved || (locPart.state() != OWNING && locPart.state() != MOVING)\n+                        || !locPart.primary(ctx.discovery().topologyVersionEx()))\n+                    continue;\n+\n+                if (locPart.state() == MOVING)\n+                    tbl.cacheContext().preloader().syncFuture().get();\n+\n+                long rowsCnt = 0;\n+\n+                List<ColumnStatisticsCollector> colStatsCollectors = new ArrayList<>(selectedColumns.length);\n+\n+                for (Column col : selectedColumns)\n+                    colStatsCollectors.add(new ColumnStatisticsCollector(col, tbl::compareValues));\n+\n+                for (CacheDataRow row : tbl.cacheContext().offheap().cachePartitionIterator(tbl.cacheId(), locPart.id(),\n+                        null, true)) {\n+                    GridQueryTypeDescriptor typeDesc = ctx.query().typeByValue(tbl.cacheName(),\n+                            tbl.cacheContext().cacheObjectContext(), row.key(), row.value(), false);\n+                    if (!tblName.equals(typeDesc.tableName()))\n+                        continue;\n+\n+                    rowsCnt++;\n+\n+                    H2Row row0 = desc.createRow(row);\n+\n+                    for (ColumnStatisticsCollector colStat : colStatsCollectors)\n+                        colStat.add(row0.getValue(colStat.col().getColumnId()));\n+\n+                }\n+\n+                Map<String, ColumnStatistics> colStats = colStatsCollectors.stream().collect(Collectors.toMap(\n+                        csc -> csc.col().getName(), csc -> csc.finish()\n+                ));\n+\n+                tblPartStats.add(new ObjectPartitionStatisticsImpl(locPart.id(), true, rowsCnt, locPart.updateCounter(),\n+                        colStats));\n+            }\n+            finally {\n+                if (reserved)\n+                    locPart.release();\n+            }\n+        }\n+\n+        return tblPartStats;\n+    }\n+\n+    public ObjectStatisticsImpl aggregateLocalStatistics(StatsKey key, Collection<ObjectPartitionStatisticsImpl> tblPartStats) {\n+        // For now there can be only tables\n+        GridH2Table table = schemaMgr.dataTable(key.schema(), key.obj());\n+\n+        if (table == null) {\n+            // remove all loaded statistics.\n+            log.info(\"Removing statistics for object \" + key + \" cause table doesn't exists.\");\n+            statsRepos.clearLocalPartitionsStatistics(key);\n+        }\n+        return aggregateLocalStatistics(table, table.getColumns(), tblPartStats);\n+    }\n+\n+    private ObjectStatisticsImpl aggregateLocalStatistics(GridH2Table tbl, Column[] selectedColumns,\n+                                                          Collection<ObjectPartitionStatisticsImpl> tblPartStats) {\n+\n+        Map<Column, List<ColumnStatistics>> colPartStats = new HashMap<>(selectedColumns.length);\n+        long rowCnt = 0;\n+        for (Column col : selectedColumns)\n+            colPartStats.put(col, new ArrayList<>());\n+\n+        QueryTable tblId = tbl.identifier();\n+\n+        for (ObjectPartitionStatisticsImpl partStat : tblPartStats) {\n+            for (Column col : selectedColumns) {\n+                ColumnStatistics colPartStat = partStat.columnStatistics(col.getName());\n+                if (colPartStat != null) {\n+                    colPartStats.compute(col, (k, v) -> {\n+                        v.add(colPartStat);\n+                        return v;\n+                    });\n+                }\n+            }\n+            rowCnt += partStat.rowCount();\n+        }", "originalCommit": "71b5964ecf232e018207af5caf69767ad3d11fa8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU5NTQzNQ==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508595435", "bodyText": "Seems, this can be merged with the loop above.", "author": "AMashenkov", "createdAt": "2020-10-20T15:13:37Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/IgniteStatisticsManagerImpl.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.ignite.IgniteAuthenticationException;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.processors.cache.distributed.dht.topology.GridDhtLocalPartition;\n+import org.apache.ignite.internal.processors.cache.persistence.CacheDataRow;\n+import org.apache.ignite.internal.processors.cache.query.QueryTable;\n+import org.apache.ignite.internal.processors.query.GridQueryTypeDescriptor;\n+import org.apache.ignite.internal.processors.query.IgniteStatisticsRepositoryImpl;\n+import org.apache.ignite.internal.processors.query.h2.SchemaManager;\n+import org.apache.ignite.internal.processors.query.h2.opt.GridH2RowDescriptor;\n+import org.apache.ignite.internal.processors.query.h2.opt.GridH2Table;\n+import org.apache.ignite.internal.processors.query.h2.opt.H2Row;\n+import org.gridgain.internal.h2.table.Column;\n+\n+import static org.apache.ignite.internal.processors.cache.distributed.dht.topology.GridDhtPartitionState.MOVING;\n+import static org.apache.ignite.internal.processors.cache.distributed.dht.topology.GridDhtPartitionState.OWNING;\n+\n+public class IgniteStatisticsManagerImpl implements IgniteStatisticsManager {\n+\n+    /** Logger. */\n+    private IgniteLogger log;\n+\n+    private final GridKernalContext ctx;\n+\n+    private final SchemaManager schemaMgr;\n+\n+    private final IgniteStatisticsRepository statsRepos;\n+\n+    public IgniteStatisticsManagerImpl(GridKernalContext ctx, SchemaManager schemaMgr) {\n+        this.ctx = ctx;\n+        this.schemaMgr = schemaMgr;\n+\n+        log = ctx.log(IgniteStatisticsManagerImpl.class);\n+        statsRepos = new IgniteStatisticsRepositoryImpl(ctx);\n+    }\n+\n+    public IgniteStatisticsRepository statisticsRepository() {\n+        return statsRepos;\n+    }\n+\n+    @Override public ObjectStatistics getLocalStatistics(String schemaName, String objName) {\n+        return statsRepos.getLocalStatistics(new StatsKey(schemaName, objName));\n+    }\n+\n+    @Override public void clearObjectStatistics(String schemaName, String objName, String... colNames) {\n+        StatsKey key = new StatsKey(schemaName, objName);\n+        statsRepos.clearLocalPartitionsStatistics(key, colNames);\n+        statsRepos.clearLocalStatistics(key, colNames);\n+        statsRepos.clearGlobalStatistics(key, colNames);\n+    }\n+\n+    /**\n+     * Filter columns by specified names.\n+     *\n+     * @param columns columns to filter.\n+     * @param colNames names.\n+     * @return column with specified names.\n+     */\n+    private Column[] filterColumns(Column[] columns, String... colNames) {\n+        if (colNames == null || colNames.length == 0) {\n+            return columns;\n+        }\n+        List<Column> resultList = new ArrayList<>(colNames.length);\n+\n+        for (String colName : colNames)\n+            for (Column col : columns)\n+\n+                if (colName.equals(col.getName())) {\n+                    resultList.add(col);\n+                    break;\n+                }\n+\n+        return resultList.toArray(new Column[resultList.size()]);\n+    }\n+\n+    @Override public void collectObjectStatistics(String schemaName, String objName, String... colNames)\n+            throws IgniteCheckedException {\n+        GridH2Table tbl = schemaMgr.dataTable(schemaName, objName);\n+        if (tbl == null)\n+            throw new IgniteAuthenticationException(String.format(\"Can't find table %s.%s\", schemaName, objName));\n+\n+        if (log.isDebugEnabled())\n+            log.debug(String.format(\"Starting statistics collection by %s.%s object\", schemaName, objName));\n+\n+        Column[] selectedColumns;\n+        boolean fullStat;\n+        if (colNames == null || colNames.length == 0) {\n+            fullStat = true;\n+            selectedColumns = tbl.getColumns();\n+        } else {\n+            fullStat = false;\n+            selectedColumns = filterColumns(tbl.getColumns(), colNames);\n+        }\n+\n+        Collection<ObjectPartitionStatisticsImpl> partsStats = collectPartitionStatistics(tbl, selectedColumns);\n+        StatsKey key = new StatsKey(tbl.identifier().schema(), tbl.identifier().table());\n+        statsRepos.saveLocalPartitionsStatistics(key, partsStats, fullStat);\n+\n+        ObjectStatisticsImpl tblStats = aggregateLocalStatistics(tbl, selectedColumns, partsStats);\n+        statsRepos.saveLocalStatistics(key, tblStats, fullStat);\n+        if (log.isDebugEnabled())\n+            log.debug(String.format(\"Statistics collection by %s.%s object is finished.\", schemaName, objName));\n+    }\n+\n+    private Collection<ObjectPartitionStatisticsImpl> collectPartitionStatistics(GridH2Table tbl, Column[] selectedColumns)\n+            throws IgniteCheckedException {\n+        List<ObjectPartitionStatisticsImpl> tblPartStats = new ArrayList<>();\n+        GridH2RowDescriptor desc = tbl.rowDescriptor();\n+        String tblName = tbl.getName();\n+\n+        for (GridDhtLocalPartition locPart : tbl.cacheContext().topology().localPartitions()) {\n+            final boolean reserved = locPart.reserve();\n+\n+            try {\n+                if (!reserved || (locPart.state() != OWNING && locPart.state() != MOVING)\n+                        || !locPart.primary(ctx.discovery().topologyVersionEx()))\n+                    continue;\n+\n+                if (locPart.state() == MOVING)\n+                    tbl.cacheContext().preloader().syncFuture().get();\n+\n+                long rowsCnt = 0;\n+\n+                List<ColumnStatisticsCollector> colStatsCollectors = new ArrayList<>(selectedColumns.length);\n+\n+                for (Column col : selectedColumns)\n+                    colStatsCollectors.add(new ColumnStatisticsCollector(col, tbl::compareValues));\n+\n+                for (CacheDataRow row : tbl.cacheContext().offheap().cachePartitionIterator(tbl.cacheId(), locPart.id(),\n+                        null, true)) {\n+                    GridQueryTypeDescriptor typeDesc = ctx.query().typeByValue(tbl.cacheName(),\n+                            tbl.cacheContext().cacheObjectContext(), row.key(), row.value(), false);\n+                    if (!tblName.equals(typeDesc.tableName()))\n+                        continue;\n+\n+                    rowsCnt++;\n+\n+                    H2Row row0 = desc.createRow(row);\n+\n+                    for (ColumnStatisticsCollector colStat : colStatsCollectors)\n+                        colStat.add(row0.getValue(colStat.col().getColumnId()));\n+\n+                }\n+\n+                Map<String, ColumnStatistics> colStats = colStatsCollectors.stream().collect(Collectors.toMap(\n+                        csc -> csc.col().getName(), csc -> csc.finish()\n+                ));\n+\n+                tblPartStats.add(new ObjectPartitionStatisticsImpl(locPart.id(), true, rowsCnt, locPart.updateCounter(),\n+                        colStats));\n+            }\n+            finally {\n+                if (reserved)\n+                    locPart.release();\n+            }\n+        }\n+\n+        return tblPartStats;\n+    }\n+\n+    public ObjectStatisticsImpl aggregateLocalStatistics(StatsKey key, Collection<ObjectPartitionStatisticsImpl> tblPartStats) {\n+        // For now there can be only tables\n+        GridH2Table table = schemaMgr.dataTable(key.schema(), key.obj());\n+\n+        if (table == null) {\n+            // remove all loaded statistics.\n+            log.info(\"Removing statistics for object \" + key + \" cause table doesn't exists.\");\n+            statsRepos.clearLocalPartitionsStatistics(key);\n+        }\n+        return aggregateLocalStatistics(table, table.getColumns(), tblPartStats);\n+    }\n+\n+    private ObjectStatisticsImpl aggregateLocalStatistics(GridH2Table tbl, Column[] selectedColumns,\n+                                                          Collection<ObjectPartitionStatisticsImpl> tblPartStats) {\n+\n+        Map<Column, List<ColumnStatistics>> colPartStats = new HashMap<>(selectedColumns.length);\n+        long rowCnt = 0;\n+        for (Column col : selectedColumns)\n+            colPartStats.put(col, new ArrayList<>());\n+\n+        QueryTable tblId = tbl.identifier();\n+\n+        for (ObjectPartitionStatisticsImpl partStat : tblPartStats) {\n+            for (Column col : selectedColumns) {\n+                ColumnStatistics colPartStat = partStat.columnStatistics(col.getName());\n+                if (colPartStat != null) {\n+                    colPartStats.compute(col, (k, v) -> {\n+                        v.add(colPartStat);\n+                        return v;\n+                    });\n+                }\n+            }\n+            rowCnt += partStat.rowCount();\n+        }\n+\n+        Map<String, ColumnStatistics> colStats = new HashMap<>(selectedColumns.length);\n+        for (Column col : selectedColumns) {\n+            ColumnStatistics stat = ColumnStatisticsCollector.aggregate(tbl::compareValues, colPartStats.get(col));\n+            colStats.put(col.getName(), stat);\n+        }", "originalCommit": "71b5964ecf232e018207af5caf69767ad3d11fa8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU5NjIwNQ==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508596205", "bodyText": "Braces are not needed here.\nCan be replaced with F.isEmpty()", "author": "AMashenkov", "createdAt": "2020-10-20T15:14:41Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/IgniteStatisticsManagerImpl.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.ignite.IgniteAuthenticationException;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.processors.cache.distributed.dht.topology.GridDhtLocalPartition;\n+import org.apache.ignite.internal.processors.cache.persistence.CacheDataRow;\n+import org.apache.ignite.internal.processors.cache.query.QueryTable;\n+import org.apache.ignite.internal.processors.query.GridQueryTypeDescriptor;\n+import org.apache.ignite.internal.processors.query.IgniteStatisticsRepositoryImpl;\n+import org.apache.ignite.internal.processors.query.h2.SchemaManager;\n+import org.apache.ignite.internal.processors.query.h2.opt.GridH2RowDescriptor;\n+import org.apache.ignite.internal.processors.query.h2.opt.GridH2Table;\n+import org.apache.ignite.internal.processors.query.h2.opt.H2Row;\n+import org.gridgain.internal.h2.table.Column;\n+\n+import static org.apache.ignite.internal.processors.cache.distributed.dht.topology.GridDhtPartitionState.MOVING;\n+import static org.apache.ignite.internal.processors.cache.distributed.dht.topology.GridDhtPartitionState.OWNING;\n+\n+public class IgniteStatisticsManagerImpl implements IgniteStatisticsManager {\n+\n+    /** Logger. */\n+    private IgniteLogger log;\n+\n+    private final GridKernalContext ctx;\n+\n+    private final SchemaManager schemaMgr;\n+\n+    private final IgniteStatisticsRepository statsRepos;\n+\n+    public IgniteStatisticsManagerImpl(GridKernalContext ctx, SchemaManager schemaMgr) {\n+        this.ctx = ctx;\n+        this.schemaMgr = schemaMgr;\n+\n+        log = ctx.log(IgniteStatisticsManagerImpl.class);\n+        statsRepos = new IgniteStatisticsRepositoryImpl(ctx);\n+    }\n+\n+    public IgniteStatisticsRepository statisticsRepository() {\n+        return statsRepos;\n+    }\n+\n+    @Override public ObjectStatistics getLocalStatistics(String schemaName, String objName) {\n+        return statsRepos.getLocalStatistics(new StatsKey(schemaName, objName));\n+    }\n+\n+    @Override public void clearObjectStatistics(String schemaName, String objName, String... colNames) {\n+        StatsKey key = new StatsKey(schemaName, objName);\n+        statsRepos.clearLocalPartitionsStatistics(key, colNames);\n+        statsRepos.clearLocalStatistics(key, colNames);\n+        statsRepos.clearGlobalStatistics(key, colNames);\n+    }\n+\n+    /**\n+     * Filter columns by specified names.\n+     *\n+     * @param columns columns to filter.\n+     * @param colNames names.\n+     * @return column with specified names.\n+     */\n+    private Column[] filterColumns(Column[] columns, String... colNames) {\n+        if (colNames == null || colNames.length == 0) {", "originalCommit": "71b5964ecf232e018207af5caf69767ad3d11fa8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU5NjQ1Mg==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508596452", "bodyText": "javadoc", "author": "AMashenkov", "createdAt": "2020-10-20T15:14:59Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/IgniteStatisticsManagerImpl.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.ignite.IgniteAuthenticationException;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteLogger;\n+import org.apache.ignite.internal.GridKernalContext;\n+import org.apache.ignite.internal.processors.cache.distributed.dht.topology.GridDhtLocalPartition;\n+import org.apache.ignite.internal.processors.cache.persistence.CacheDataRow;\n+import org.apache.ignite.internal.processors.cache.query.QueryTable;\n+import org.apache.ignite.internal.processors.query.GridQueryTypeDescriptor;\n+import org.apache.ignite.internal.processors.query.IgniteStatisticsRepositoryImpl;\n+import org.apache.ignite.internal.processors.query.h2.SchemaManager;\n+import org.apache.ignite.internal.processors.query.h2.opt.GridH2RowDescriptor;\n+import org.apache.ignite.internal.processors.query.h2.opt.GridH2Table;\n+import org.apache.ignite.internal.processors.query.h2.opt.H2Row;\n+import org.gridgain.internal.h2.table.Column;\n+\n+import static org.apache.ignite.internal.processors.cache.distributed.dht.topology.GridDhtPartitionState.MOVING;\n+import static org.apache.ignite.internal.processors.cache.distributed.dht.topology.GridDhtPartitionState.OWNING;\n+\n+public class IgniteStatisticsManagerImpl implements IgniteStatisticsManager {\n+\n+    /** Logger. */\n+    private IgniteLogger log;\n+\n+    private final GridKernalContext ctx;\n+\n+    private final SchemaManager schemaMgr;\n+\n+    private final IgniteStatisticsRepository statsRepos;\n+\n+    public IgniteStatisticsManagerImpl(GridKernalContext ctx, SchemaManager schemaMgr) {\n+        this.ctx = ctx;\n+        this.schemaMgr = schemaMgr;\n+\n+        log = ctx.log(IgniteStatisticsManagerImpl.class);\n+        statsRepos = new IgniteStatisticsRepositoryImpl(ctx);\n+    }\n+\n+    public IgniteStatisticsRepository statisticsRepository() {\n+        return statsRepos;\n+    }\n+\n+    @Override public ObjectStatistics getLocalStatistics(String schemaName, String objName) {\n+        return statsRepos.getLocalStatistics(new StatsKey(schemaName, objName));\n+    }\n+\n+    @Override public void clearObjectStatistics(String schemaName, String objName, String... colNames) {\n+        StatsKey key = new StatsKey(schemaName, objName);\n+        statsRepos.clearLocalPartitionsStatistics(key, colNames);\n+        statsRepos.clearLocalStatistics(key, colNames);\n+        statsRepos.clearGlobalStatistics(key, colNames);\n+    }\n+\n+    /**\n+     * Filter columns by specified names.\n+     *\n+     * @param columns columns to filter.\n+     * @param colNames names.\n+     * @return column with specified names.\n+     */\n+    private Column[] filterColumns(Column[] columns, String... colNames) {\n+        if (colNames == null || colNames.length == 0) {\n+            return columns;\n+        }\n+        List<Column> resultList = new ArrayList<>(colNames.length);\n+\n+        for (String colName : colNames)\n+            for (Column col : columns)\n+\n+                if (colName.equals(col.getName())) {\n+                    resultList.add(col);\n+                    break;\n+                }\n+\n+        return resultList.toArray(new Column[resultList.size()]);\n+    }\n+\n+    @Override public void collectObjectStatistics(String schemaName, String objName, String... colNames)\n+            throws IgniteCheckedException {\n+        GridH2Table tbl = schemaMgr.dataTable(schemaName, objName);\n+        if (tbl == null)\n+            throw new IgniteAuthenticationException(String.format(\"Can't find table %s.%s\", schemaName, objName));\n+\n+        if (log.isDebugEnabled())\n+            log.debug(String.format(\"Starting statistics collection by %s.%s object\", schemaName, objName));\n+\n+        Column[] selectedColumns;\n+        boolean fullStat;\n+        if (colNames == null || colNames.length == 0) {\n+            fullStat = true;\n+            selectedColumns = tbl.getColumns();\n+        } else {\n+            fullStat = false;\n+            selectedColumns = filterColumns(tbl.getColumns(), colNames);\n+        }\n+\n+        Collection<ObjectPartitionStatisticsImpl> partsStats = collectPartitionStatistics(tbl, selectedColumns);\n+        StatsKey key = new StatsKey(tbl.identifier().schema(), tbl.identifier().table());\n+        statsRepos.saveLocalPartitionsStatistics(key, partsStats, fullStat);\n+\n+        ObjectStatisticsImpl tblStats = aggregateLocalStatistics(tbl, selectedColumns, partsStats);\n+        statsRepos.saveLocalStatistics(key, tblStats, fullStat);\n+        if (log.isDebugEnabled())\n+            log.debug(String.format(\"Statistics collection by %s.%s object is finished.\", schemaName, objName));\n+    }\n+\n+    private Collection<ObjectPartitionStatisticsImpl> collectPartitionStatistics(GridH2Table tbl, Column[] selectedColumns)", "originalCommit": "71b5964ecf232e018207af5caf69767ad3d11fa8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU5OTg4OQ==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508599889", "bodyText": "Seems, there is nothing to do if 'selectedColumns' is empty.\nIs it make sense to either exit method in this case or add an assertion that array is NOT empty.", "author": "AMashenkov", "createdAt": "2020-10-20T15:19:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU5NjQ1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODYwNTUwMQ==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508605501", "bodyText": "Let's rename to smth meaningful, to e.g \"columnStatistics()\"", "author": "AMashenkov", "createdAt": "2020-10-20T15:24:25Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/ColumnStatisticsCollector.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import java.math.BigInteger;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Comparator;\n+import java.util.List;\n+\n+import org.apache.ignite.internal.processors.query.stat.hll.HLL;\n+import org.gridgain.internal.h2.table.Column;\n+import org.gridgain.internal.h2.value.Value;\n+\n+/**\n+ * Collector to compute statistic by single column.\n+ */\n+public class ColumnStatisticsCollector {\n+\n+    /** */\n+    private final Column col;\n+\n+    /** Hyper Log Log structure */\n+    private final HLL hll = buildHll();\n+\n+    /** Minimum value. */\n+    private Value min = null;\n+\n+    /** Maximum value. */\n+    private Value max = null;\n+\n+    /** Total vals in column. */\n+    private long total = 0;\n+\n+    /** Total size of all non nulls values (in bytes).*/\n+    private long size = 0;\n+\n+    /** Temporary byte buffer just to avoid unnecessary object creation. */\n+    private ByteBuffer bb;\n+\n+    /** Column value comparator. */\n+    private final Comparator<Value> comp;\n+\n+    /** Null values counter. */\n+    private long nullsCnt;\n+\n+    /** Hasher. */\n+    private final Hasher hash = new Hasher();\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param col column to collect statistics by.\n+     * @param comp column values comparator.\n+     */\n+    public ColumnStatisticsCollector(Column col, Comparator<Value> comp) {\n+        this.col = col;\n+        this.comp = comp;\n+    }\n+\n+    /**\n+     * Try to fix unexpected behaviour of base Value class.\n+     *\n+     * @param value value to convert\n+     * @return byte array\n+     */\n+    private byte[] getBytes(Value value) {\n+        switch (value.getValueType()) {\n+            case Value.STRING:\n+                String strValue = value.getString();\n+                return strValue.getBytes(StandardCharsets.UTF_8);\n+            case Value.BOOLEAN:\n+                return value.getBoolean() ? new byte[]{1} : new byte[]{0};\n+            case Value.DECIMAL:\n+            case Value.DOUBLE:\n+            case Value.FLOAT:\n+                return value.getBigDecimal().unscaledValue().toByteArray();\n+            case Value.TIME:\n+                return BigInteger.valueOf(value.getTime().getTime()).toByteArray();\n+            case Value.DATE:\n+                return BigInteger.valueOf(value.getDate().getTime()).toByteArray();\n+            case Value.TIMESTAMP:\n+                return BigInteger.valueOf(value.getTimestamp().getTime()).toByteArray();\n+            default:\n+                return value.getBytes();\n+        }\n+    }\n+\n+    public void add(Value val) {\n+        total++;\n+\n+        if (isNull(val)) {\n+            nullsCnt++;\n+\n+            return;\n+        }\n+\n+        byte bytes[] = getBytes(val);\n+        size += bytes.length;\n+\n+        hll.addRaw(hash.fastHash(bytes));\n+\n+        if (null == min || comp.compare(val, min) < 0)\n+            min = val;\n+\n+        if (null == max || comp.compare(val, max) > 0)\n+            max = val;\n+    }\n+\n+    private boolean isNull(Value v) {\n+        return v == null || v.getType().getValueType() == Value.NULL;\n+    }\n+\n+    /**\n+     * Get total column statistics.\n+     *\n+     * @return aggregated column statistics.\n+     */\n+    public ColumnStatistics finish() {", "originalCommit": "71b5964ecf232e018207af5caf69767ad3d11fa8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODYzOTE0Mw==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508639143", "bodyText": "Let's refactor this.\nLet's move certain statistic logic from main flow to separate classes. This can be achieved with having separate collector-object for every trivial statistics and construct required hierarchy with these collector-objects in construction phase.\nThen make current object just a container for collection of abstract collector-objects and push data to container in next phase.\nThen implement result interpreter (actually factory method\\object for ColumnStatistics).\nThis approach will make further adding new or changing existed statistics straightforward.", "author": "AMashenkov", "createdAt": "2020-10-20T15:52:40Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/ColumnStatisticsCollector.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import java.math.BigInteger;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Comparator;\n+import java.util.List;\n+\n+import org.apache.ignite.internal.processors.query.stat.hll.HLL;\n+import org.gridgain.internal.h2.table.Column;\n+import org.gridgain.internal.h2.value.Value;\n+\n+/**\n+ * Collector to compute statistic by single column.\n+ */\n+public class ColumnStatisticsCollector {", "originalCommit": "71b5964ecf232e018207af5caf69767ad3d11fa8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc0MTI2Ng==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508741266", "bodyText": "Javadoc", "author": "AMashenkov", "createdAt": "2020-10-20T18:18:40Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/IgniteH2Indexing.java", "diffHunk": "@@ -3371,4 +3378,8 @@ public DistributedSqlConfiguration distributedConfiguration() {\n \n         return map;\n     }\n+\n+    @Override public IgniteStatisticsManager statsManager() {", "originalCommit": "6e542dba4c81179ed1a8fab253f3a1fb85c02eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc0MTk5Nw==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508741997", "bodyText": "License first, then package", "author": "AMashenkov", "createdAt": "2020-10-20T18:19:34Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/hll/HLLType.java", "diffHunk": "@@ -0,0 +1,29 @@\n+package org.apache.ignite.internal.processors.query.stat.hll;", "originalCommit": "6e542dba4c81179ed1a8fab253f3a1fb85c02eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc0MjI4NQ==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508742285", "bodyText": "License first, then package.", "author": "AMashenkov", "createdAt": "2020-10-20T18:19:58Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/hll/serialization/BigEndianAscendingWordDeserializer.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.apache.ignite.internal.processors.query.stat.hll.serialization;", "originalCommit": "6e542dba4c81179ed1a8fab253f3a1fb85c02eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc0Mjc5OA==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508742798", "bodyText": "New line\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            }\n          \n          \n            \n            }", "author": "AMashenkov", "createdAt": "2020-10-20T18:20:48Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/hll/serialization/BigEndianAscendingWordDeserializer.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.apache.ignite.internal.processors.query.stat.hll.serialization;\n+\n+/*\n+ * Copyright 2013 Aggregate Knowledge, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+/**\n+ * A corresponding deserializer for {@link BigEndianAscendingWordSerializer}.\n+ *\n+ * @author timon\n+ */\n+public class BigEndianAscendingWordDeserializer implements IWordDeserializer {\n+    // The number of bits per byte.\n+    private static final int BITS_PER_BYTE = 8;\n+\n+    // long mask for the maximum value stored in a byte\n+    private static final long BYTE_MASK = (1L << BITS_PER_BYTE) - 1L;\n+\n+    // ************************************************************************\n+    // The length in bits of the words to be read.\n+    private final int wordLength;\n+\n+    // The byte array to which the words are serialized.\n+    private final byte[] bytes;\n+\n+    // The number of leading padding bytes in 'bytes' to be ignored.\n+    private final int bytePadding;\n+\n+    // The number of words that the byte array contains.\n+    private final int wordCount;\n+\n+    // The current read state.\n+    private int currentWordIndex;\n+\n+    // ========================================================================\n+    /**\n+     * @param wordLength the length in bits of the words to be deserialized. Must\n+     *        be less than or equal to 64 and greater than or equal to 1.\n+     * @param bytePadding the number of leading bytes that pad the serialized words.\n+     *        Must be greater than or equal to zero.\n+     * @param bytes the byte array containing the serialized words. Cannot be\n+     *        <code>null</code>.\n+     */\n+    public BigEndianAscendingWordDeserializer(final int wordLength, final int bytePadding, final byte[] bytes) {\n+        if((wordLength < 1) || (wordLength > 64)) {\n+            throw new IllegalArgumentException(\"Word length must be >= 1 and <= 64. (was: \" + wordLength + \")\");\n+        }\n+\n+        if(bytePadding < 0) {\n+            throw new IllegalArgumentException(\"Byte padding must be >= zero. (was: \" + bytePadding + \")\");\n+        }\n+\n+        this.wordLength = wordLength;\n+        this.bytes = bytes;\n+        this.bytePadding = bytePadding;\n+\n+        final int dataBytes = (bytes.length - bytePadding);\n+        final long dataBits = (dataBytes * BITS_PER_BYTE);\n+\n+        this.wordCount = (int)(dataBits/wordLength);\n+\n+        currentWordIndex = 0;\n+    }\n+\n+    // ========================================================================\n+    /* (non-Javadoc)\n+     * @see net.agkn.hll.serialization.IWordDeserializer#readWord()\n+     */\n+    @Override\n+    public long readWord() {\n+        final long word = readWord(currentWordIndex);\n+        currentWordIndex++;\n+\n+        return word;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    /**\n+     * Reads the word at the specified sequence position (zero-indexed).\n+     *\n+     * @param  position the zero-indexed position of the word to be read. This\n+     *         must be greater than or equal to zero.\n+     * @return the value of the serialized word at the specified position.\n+     */\n+    private long readWord(final int position) {\n+        if(position < 0) {\n+            throw new ArrayIndexOutOfBoundsException(position);\n+        }\n+\n+        // First bit of the word\n+        final long firstBitIndex = (position * wordLength);\n+        final int firstByteIndex = (bytePadding + (int)(firstBitIndex / BITS_PER_BYTE));\n+        final int firstByteSkipBits = (int)(firstBitIndex % BITS_PER_BYTE);\n+\n+        // Last bit of the word\n+        final long lastBitIndex = (firstBitIndex + wordLength - 1);\n+        final int lastByteIndex = (bytePadding + (int)(lastBitIndex / BITS_PER_BYTE));\n+        final int lastByteBitsToConsume;\n+\n+        final int bitsAfterByteBoundary = (int)((lastBitIndex + 1) % BITS_PER_BYTE);\n+        // If the word terminates at the end of the last byte, consume the whole\n+        // last byte.\n+        if(bitsAfterByteBoundary == 0) {\n+            lastByteBitsToConsume = BITS_PER_BYTE;\n+        } else {\n+            // Otherwise, only consume what is necessary.\n+            lastByteBitsToConsume = bitsAfterByteBoundary;\n+        }\n+\n+        if(lastByteIndex >= bytes.length) {\n+            throw new ArrayIndexOutOfBoundsException(\"Word out of bounds of backing array.\");\n+        }\n+\n+        // Accumulator\n+        long value = 0;\n+\n+        // --------------------------------------------------------------------\n+        // First byte\n+        final int bitsRemainingInFirstByte = (BITS_PER_BYTE - firstByteSkipBits);\n+        final int bitsToConsumeInFirstByte = Math.min(bitsRemainingInFirstByte, wordLength);\n+        long firstByte = (long)bytes[firstByteIndex];\n+\n+        // Mask off the bits to skip in the first byte.\n+        final long firstByteMask = ((1L << bitsRemainingInFirstByte) - 1L);\n+        firstByte &= firstByteMask;\n+        // Right-align relevant bits of first byte.\n+        firstByte >>>= (bitsRemainingInFirstByte - bitsToConsumeInFirstByte);\n+\n+        value |= firstByte;\n+\n+        // If the first byte contains the whole word, short-circuit.\n+        if(firstByteIndex == lastByteIndex) {\n+            return value;\n+        }\n+\n+        // --------------------------------------------------------------------\n+        // Middle bytes\n+        final int middleByteCount = (lastByteIndex - firstByteIndex - 1);\n+        for(int i=0; i<middleByteCount; i++) {\n+            final long middleByte = (bytes[firstByteIndex + i + 1] & BYTE_MASK);\n+            // Push middle byte onto accumulator.\n+            value <<= BITS_PER_BYTE;\n+            value |= middleByte;\n+        }\n+\n+        // --------------------------------------------------------------------\n+        // Last byte\n+        long lastByte = (bytes[lastByteIndex] & BYTE_MASK);\n+        lastByte >>= (BITS_PER_BYTE - lastByteBitsToConsume);\n+        value <<= lastByteBitsToConsume;\n+        value |= lastByte;\n+        return value;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see net.agkn.hll.serialization.IWordDeserializer#totalWordCount()\n+     */\n+    @Override\n+    public int totalWordCount() {\n+        return wordCount;\n+    }\n+}", "originalCommit": "6e542dba4c81179ed1a8fab253f3a1fb85c02eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc0MzI4OQ==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508743289", "bodyText": "Javadoc. Annotation on same line.", "author": "AMashenkov", "createdAt": "2020-10-20T18:21:36Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/hll/serialization/BigEndianAscendingWordSerializer.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Copyright 2013 Aggregate Knowledge, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat.hll.serialization;\n+\n+/**\n+ * A serializer that writes a sequence of fixed bit-width 'words' to a byte array.\n+ * Bitwise OR is used to write words into bytes, so a low bit in a word is also\n+ * a low bit in a byte. However, a high byte in a word is written at a lower index\n+ * in the array than a low byte in a word. The first word is written at the lowest\n+ * array index. Each serializer is one time use and returns its backing byte\n+ * array.<p/>\n+ *\n+ * This encoding was chosen so that when reading bytes as octets in the typical\n+ * first-octet-is-the-high-nibble fashion, an octet-to-binary conversion\n+ * would yield a high-to-low, left-to-right view of the \"short words\".<p/>\n+ *\n+ * Example:<p/>\n+ *\n+ * Say short words are 5 bits wide. Our word sequence is the values\n+ * <code>[31, 1, 5]</code>. In big-endian binary format, the values are\n+ * <code>[0b11111, 0b00001, 0b00101]</code>. We use 15 of 16 bits in two bytes\n+ * and pad the last (lowest) bit of the last byte with a zero:\n+ *\n+ * <code>\n+ *  [0b11111000, 0b01001010] = [0xF8, 0x4A]\n+ * </code>.\n+ *\n+ * @author timon\n+ */\n+public class BigEndianAscendingWordSerializer implements IWordSerializer {\n+    // The number of bits per byte.\n+    private static final int BITS_PER_BYTE = 8;\n+\n+    // ************************************************************************\n+    // The length in bits of the words to be written.\n+    private final int wordLength;\n+    // The number of words to be written.\n+    private final int wordCount;\n+\n+    // The byte array to which the words are serialized.\n+    private final byte[] bytes;\n+\n+    // ------------------------------------------------------------------------\n+    // Write state\n+    // Number of bits that remain writable in the current byte.\n+    private int bitsLeftInByte;\n+    // Index of byte currently being written to.\n+    private int byteIndex;\n+    // Number of words written.\n+    private int wordsWritten;\n+\n+    // ========================================================================\n+    /**\n+     * @param wordLength the length in bits of the words to be serialized. Must\n+     *        be greater than or equal to 1 and less than or equal to 64.\n+     * @param wordCount the number of words to be serialized. Must be greater than\n+     *        or equal to zero.\n+     * @param bytePadding the number of leading bytes that should pad the\n+     *        serialized words. Must be greater than or equal to zero.\n+     */\n+    public BigEndianAscendingWordSerializer(final int wordLength, final int wordCount, final int bytePadding) {\n+        if((wordLength < 1) || (wordLength > 64)) {\n+            throw new IllegalArgumentException(\"Word length must be >= 1 and <= 64. (was: \" + wordLength + \")\");\n+        }\n+        if(wordCount < 0) {\n+            throw new IllegalArgumentException(\"Word count must be >= 0. (was: \" + wordCount + \")\");\n+        }\n+        if(bytePadding < 0) {\n+            throw new IllegalArgumentException(\"Byte padding must be must be >= 0. (was: \" + bytePadding + \")\");\n+        }\n+\n+        this.wordLength = wordLength;\n+        this.wordCount = wordCount;\n+\n+        final long bitsRequired = (wordLength * wordCount);\n+        final boolean leftoverBits = ((bitsRequired % BITS_PER_BYTE) != 0);\n+        final int bytesRequired = (int)(bitsRequired / BITS_PER_BYTE) + (leftoverBits ? 1 : 0) + bytePadding;\n+        bytes = new byte[bytesRequired];\n+\n+        bitsLeftInByte = BITS_PER_BYTE;\n+        byteIndex = bytePadding;\n+        wordsWritten = 0;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see net.agkn.hll.serialization.IWordSerializer#writeWord(long)\n+     * @throws RuntimeException if the number of words written is greater than the\n+     *         <code>wordCount</code> parameter in the constructor.\n+     */\n+    @Override\n+    public void writeWord(final long word) {", "originalCommit": "6e542dba4c81179ed1a8fab253f3a1fb85c02eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc0MzYyNg==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508743626", "bodyText": "new line\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            }\n          \n          \n            \n            }", "author": "AMashenkov", "createdAt": "2020-10-20T18:22:10Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/hll/serialization/IHLLMetadata.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright 2013 Aggregate Knowledge, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat.hll.serialization;\n+\n+import org.apache.ignite.internal.processors.query.stat.hll.HLLType;\n+\n+/**\n+ * The metadata and parameters associated with a HLL.\n+ */\n+public interface IHLLMetadata {\n+    /**\n+     * @return the schema version of the HLL. This will never be <code>null</code>.\n+     */\n+    int schemaVersion();\n+\n+    /**\n+     * @return the type of the HLL. This will never be <code>null</code>.\n+     */\n+    HLLType HLLType();\n+\n+    /**\n+     * @return the log-base-2 of the register count parameter of the HLL. This\n+     *         will always be greater than or equal to 4 and less than or equal\n+     *         to 31.\n+     */\n+    int registerCountLog2();\n+\n+    /**\n+     * @return the register width parameter of the HLL. This will always be\n+     *         greater than or equal to 1 and less than or equal to 8.\n+     */\n+    int registerWidth();\n+\n+    /**\n+     * @return the log-base-2 of the explicit cutoff cardinality. This will always\n+     *         be greater than or equal to zero and less than 31, per the specification.\n+     */\n+    int log2ExplicitCutoff();\n+\n+    /**\n+     * @return <code>true</code> if the {@link HLLType#EXPLICIT} representation\n+     *         has been disabled. <code>false</code> otherwise.\n+     */\n+    boolean explicitOff();\n+\n+    /**\n+     * @return <code>true</code> if the {@link HLLType#EXPLICIT} representation\n+     *         cutoff cardinality is set to be automatically chosen,\n+     *         <code>false</code> otherwise.\n+     */\n+    boolean explicitAuto();\n+\n+    /**\n+     * @return <code>true</code> if the {@link HLLType#SPARSE} representation\n+     *         is enabled.\n+     */\n+    boolean sparseEnabled();\n+}", "originalCommit": "6e542dba4c81179ed1a8fab253f3a1fb85c02eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc0NDIzMw==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508744233", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            }\n          \n          \n            \n            }", "author": "AMashenkov", "createdAt": "2020-10-20T18:23:14Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/hll/serialization/IWordDeserializer.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright 2013 Aggregate Knowledge, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat.hll.serialization;\n+\n+/**\n+ * Reads 'words' of a fixed width, in sequence, from a byte array.\n+ *\n+ * @author timon\n+ */\n+public interface IWordDeserializer {\n+    /**\n+     * @return the next word in the sequence. Should not be called more than\n+     * {@link #totalWordCount()} times.\n+     */\n+    long readWord();\n+\n+    /**\n+     * Returns the number of words that could be encoded in the sequence.<p/>\n+     *\n+     * NOTE:  the sequence that was encoded may be shorter than the value this\n+     *        method returns due to padding issues within bytes. This guarantees\n+     *        only an upper bound on the number of times {@link #readWord()}\n+     *        can be called.\n+     *\n+     * @return the maximum number of words that could be read from the sequence.\n+     */\n+    int totalWordCount();\n+}", "originalCommit": "6e542dba4c81179ed1a8fab253f3a1fb85c02eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc0NDczNw==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508744737", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            package org.apache.ignite.internal.processors.query.stat.hll;\n          \n          \n            \n            \n          \n          \n            \n            /*\n          \n          \n            \n             * Copyright 2013 Aggregate Knowledge, Inc.\n          \n          \n            \n             *\n          \n          \n            \n             * Licensed under the Apache License, Version 2.0 (the \"License\");\n          \n          \n            \n             * you may not use this file except in compliance with the License.\n          \n          \n            \n             * You may obtain a copy of the License at\n          \n          \n            \n             *\n          \n          \n            \n             *     http://www.apache.org/licenses/LICENSE-2.0\n          \n          \n            \n             *\n          \n          \n            \n             * Unless required by applicable law or agreed to in writing, software\n          \n          \n            \n             * distributed under the License is distributed on an \"AS IS\" BASIS,\n          \n          \n            \n             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n          \n          \n            \n             * See the License for the specific language governing permissions and\n          \n          \n            \n             * limitations under the License.\n          \n          \n            \n             */\n          \n          \n            \n            /*\n          \n          \n            \n             * Copyright 2013 Aggregate Knowledge, Inc.\n          \n          \n            \n             *\n          \n          \n            \n             * Licensed under the Apache License, Version 2.0 (the \"License\");\n          \n          \n            \n             * you may not use this file except in compliance with the License.\n          \n          \n            \n             * You may obtain a copy of the License at\n          \n          \n            \n             *\n          \n          \n            \n             *     http://www.apache.org/licenses/LICENSE-2.0\n          \n          \n            \n             *\n          \n          \n            \n             * Unless required by applicable law or agreed to in writing, software\n          \n          \n            \n             * distributed under the License is distributed on an \"AS IS\" BASIS,\n          \n          \n            \n             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n          \n          \n            \n             * See the License for the specific language governing permissions and\n          \n          \n            \n             * limitations under the License.\n          \n          \n            \n             */\n          \n          \n            \n             package org.apache.ignite.internal.processors.query.stat.hll;", "author": "AMashenkov", "createdAt": "2020-10-20T18:24:04Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/hll/HLLType.java", "diffHunk": "@@ -0,0 +1,29 @@\n+package org.apache.ignite.internal.processors.query.stat.hll;\n+\n+/*\n+ * Copyright 2013 Aggregate Knowledge, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */", "originalCommit": "6e542dba4c81179ed1a8fab253f3a1fb85c02eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc0NTM1MA==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508745350", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            package org.apache.ignite.internal.processors.query.stat.hll.serialization;\n          \n          \n            \n            \n          \n          \n            \n            /*\n          \n          \n            \n             * Copyright 2013 Aggregate Knowledge, Inc.\n          \n          \n            \n             *\n          \n          \n            \n             * Licensed under the Apache License, Version 2.0 (the \"License\");\n          \n          \n            \n             * you may not use this file except in compliance with the License.\n          \n          \n            \n             * You may obtain a copy of the License at\n          \n          \n            \n             *\n          \n          \n            \n             *     http://www.apache.org/licenses/LICENSE-2.0\n          \n          \n            \n             *\n          \n          \n            \n             * Unless required by applicable law or agreed to in writing, software\n          \n          \n            \n             * distributed under the License is distributed on an \"AS IS\" BASIS,\n          \n          \n            \n             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n          \n          \n            \n             * See the License for the specific language governing permissions and\n          \n          \n            \n             * limitations under the License.\n          \n          \n            \n             */\n          \n          \n            \n            /*\n          \n          \n            \n             * Copyright 2013 Aggregate Knowledge, Inc.\n          \n          \n            \n             *\n          \n          \n            \n             * Licensed under the Apache License, Version 2.0 (the \"License\");\n          \n          \n            \n             * you may not use this file except in compliance with the License.\n          \n          \n            \n             * You may obtain a copy of the License at\n          \n          \n            \n             *\n          \n          \n            \n             *     http://www.apache.org/licenses/LICENSE-2.0\n          \n          \n            \n             *\n          \n          \n            \n             * Unless required by applicable law or agreed to in writing, software\n          \n          \n            \n             * distributed under the License is distributed on an \"AS IS\" BASIS,\n          \n          \n            \n             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n          \n          \n            \n             * See the License for the specific language governing permissions and\n          \n          \n            \n             * limitations under the License.\n          \n          \n            \n             */\n          \n          \n            \n             package org.apache.ignite.internal.processors.query.stat.hll.serialization;", "author": "AMashenkov", "createdAt": "2020-10-20T18:25:05Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/hll/serialization/BigEndianAscendingWordDeserializer.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.apache.ignite.internal.processors.query.stat.hll.serialization;\n+\n+/*\n+ * Copyright 2013 Aggregate Knowledge, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */", "originalCommit": "6e542dba4c81179ed1a8fab253f3a1fb85c02eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc0NTYwOA==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508745608", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            }\n          \n          \n            \n            }", "author": "AMashenkov", "createdAt": "2020-10-20T18:25:29Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/hll/serialization/IWordSerializer.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright 2013 Aggregate Knowledge, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat.hll.serialization;\n+\n+/**\n+ * Writes 'words' of fixed width, in sequence, to a byte array.\n+ *\n+ * @author timon\n+ */\n+public interface IWordSerializer {\n+    /**\n+     * Writes the word to the backing array.\n+     *\n+     * @param  word the word to write.\n+     */\n+    void writeWord(final long word);\n+\n+    /**\n+     * Returns the backing array of <code>byte</code>s that contain the serialized\n+     * words.\n+     * @return the serialized words as a <code>byte[]</code>.\n+     */\n+    byte[] getBytes();\n+}", "originalCommit": "6e542dba4c81179ed1a8fab253f3a1fb85c02eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc0NjAwNw==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508746007", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            }\n          \n          \n            \n            }", "author": "AMashenkov", "createdAt": "2020-10-20T18:26:02Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/hll/util/BitUtil.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2013 Aggregate Knowledge, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat.hll.util;\n+\n+/**\n+ * A collection of bit utilities.\n+ *\n+ * @author rgrzywinski\n+ */\n+public class BitUtil {\n+    /**\n+     * The set of least-significant bits for a given <code>byte</code>.  <code>-1</code>\n+     * is used if no bits are set (so as to not be confused with \"index of zero\"\n+     * meaning that the least significant bit is the 0th (1st) bit).\n+     *\n+     * @see #leastSignificantBit(long)\n+     */\n+    private static final int[] LEAST_SIGNIFICANT_BIT = {\n+            -1, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,\n+            4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,\n+            5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,\n+            4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,\n+            6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,\n+            4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,\n+            5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,\n+            4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,\n+            7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,\n+            4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,\n+            5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,\n+            4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,\n+            6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,\n+            4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,\n+            5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,\n+            4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0\n+    };\n+\n+    /**\n+     * Computes the least-significant bit of the specified <code>long</code>\n+     * that is set to <code>1</code>. Zero-indexed.\n+     *\n+     * @param  value the <code>long</code> whose least-significant bit is desired.\n+     * @return the least-significant bit of the specified <code>long</code>.\n+     *         <code>-1</code> is returned if there are no bits set.\n+     */\n+    // REF:  http://stackoverflow.com/questions/757059/position-of-least-significant-bit-that-is-set\n+    // REF:  http://www-graphics.stanford.edu/~seander/bithacks.html\n+    public static int leastSignificantBit(final long value) {\n+        if(value == 0L) return -1/*by contract*/;\n+        if((value & 0xFFL) != 0) return LEAST_SIGNIFICANT_BIT[(int)( (value >>>  0) & 0xFF)] +  0;\n+        if((value & 0xFFFFL) != 0) return LEAST_SIGNIFICANT_BIT[(int)( (value >>>  8) & 0xFF)] +  8;\n+        if((value & 0xFFFFFFL) != 0) return LEAST_SIGNIFICANT_BIT[(int)( (value >>> 16) & 0xFF)] + 16;\n+        if((value & 0xFFFFFFFFL) != 0) return LEAST_SIGNIFICANT_BIT[(int)( (value >>> 24) & 0xFF)] + 24;\n+        if((value & 0xFFFFFFFFFFL) != 0) return LEAST_SIGNIFICANT_BIT[(int)( (value >>> 32) & 0xFF)] + 32;\n+        if((value & 0xFFFFFFFFFFFFL) != 0) return LEAST_SIGNIFICANT_BIT[(int)( (value >>> 40) & 0xFF)] + 40;\n+        if((value & 0xFFFFFFFFFFFFFFL) != 0) return LEAST_SIGNIFICANT_BIT[(int)( (value >>> 48) & 0xFF)] + 48;\n+        return LEAST_SIGNIFICANT_BIT[(int)( (value >>> 56) & 0xFFL)] + 56;\n+    }\n+\n+    public static void main(String[] args) {\n+        System.out.println(\"dsaf\");\n+    }\n+}", "originalCommit": "6e542dba4c81179ed1a8fab253f3a1fb85c02eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc0NjE5MA==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508746190", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            }\n          \n          \n            \n            }", "author": "AMashenkov", "createdAt": "2020-10-20T18:26:19Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/hll/util/BitVector.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * Copyright 2013 Aggregate Knowledge, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat.hll.util;\n+\n+import org.apache.ignite.internal.processors.query.stat.hll.serialization.IWordSerializer;\n+\n+/**\n+ * A vector (array) of bits that is accessed in units (\"registers\") of <code>width</code>\n+ * bits which are stored as 64bit \"words\" (<code>long</code>s).  In this context\n+ * a register is at most 64bits.\n+ *\n+ * @author rgrzywinski\n+ */\n+public class BitVector implements Cloneable {\n+    // NOTE:  in this context, a word is 64bits\n+\n+    // rather than doing division to determine how a bit index fits into 64bit\n+    // words (i.e. longs), bit shifting is used\n+    private static final int LOG2_BITS_PER_WORD = 6/*=>64bits*/;\n+    private static final int BITS_PER_WORD = 1 << LOG2_BITS_PER_WORD;\n+    private static final int BITS_PER_WORD_MASK = BITS_PER_WORD - 1;\n+\n+    // ditto from above but for bytes (for output)\n+    private static final int LOG2_BITS_PER_BYTE = 3/*=>8bits*/;\n+    public static final int BITS_PER_BYTE = 1 << LOG2_BITS_PER_BYTE;\n+\n+    // ========================================================================\n+    public static final int BYTES_PER_WORD = 8/*8 bytes in a long*/;\n+\n+    // ************************************************************************\n+    // 64bit words\n+    private final long[] words;\n+    public final long[] words() { return words; }\n+    public final int wordCount() { return words.length; }\n+    public final int byteCount() { return wordCount() * BYTES_PER_WORD; }\n+\n+    // the width of a register in bits (this cannot be more than 64 (the word size))\n+    private final int registerWidth;\n+    public final int registerWidth() { return registerWidth; }\n+\n+    private final long count;\n+\n+    // ------------------------------------------------------------------------\n+    private final long registerMask;\n+\n+    // ========================================================================\n+    /**\n+     * @param  width the width of each register.  This cannot be negative or\n+     *         zero or greater than 63 (the signed word size).\n+     * @param  count the number of registers.  This cannot be negative or zero\n+     */\n+    public BitVector(final int width, final long count) {\n+        // ceil((width * count)/BITS_PER_WORD)\n+        this.words = new long[(int)(((width * count) + BITS_PER_WORD_MASK) >>> LOG2_BITS_PER_WORD)];\n+        this.registerWidth = width;\n+        this.count = count;\n+\n+        this.registerMask = (1L << width) - 1;\n+    }\n+\n+    // ========================================================================\n+    /**\n+     * @param  registerIndex the index of the register whose value is to be\n+     *         retrieved.  This cannot be negative.\n+     * @return the value at the specified register index\n+     * @see #setRegister(long, long)\n+     * @see #setMaxRegister(long, long)\n+     */\n+    // NOTE:  if this changes then setMaxRegister() must change\n+    public long getRegister(final long registerIndex) {\n+        final long bitIndex = registerIndex * registerWidth;\n+        final int firstWordIndex = (int)(bitIndex >>> LOG2_BITS_PER_WORD)/*aka (bitIndex / BITS_PER_WORD)*/;\n+        final int secondWordIndex = (int)((bitIndex + registerWidth - 1) >>> LOG2_BITS_PER_WORD)/*see above*/;\n+        final int bitRemainder = (int)(bitIndex & BITS_PER_WORD_MASK)/*aka (bitIndex % BITS_PER_WORD)*/;\n+\n+        if(firstWordIndex == secondWordIndex)\n+            return ((words[firstWordIndex] >>> bitRemainder) & registerMask);\n+        /* else -- register spans words */\n+        return (words[firstWordIndex] >>> bitRemainder)/*no need to mask since at top of word*/\n+                | (words[secondWordIndex] << (BITS_PER_WORD - bitRemainder)) & registerMask;\n+    }\n+\n+    /**\n+     * @param registerIndex the index of the register whose value is to be set.\n+     *        This cannot be negative\n+     * @param value the value to set in the register\n+     * @see #getRegister(long)\n+     * @see #setMaxRegister(long, long)\n+     */\n+    // NOTE:  if this changes then setMaxRegister() must change\n+    public void setRegister(final long registerIndex, final long value) {\n+        final long bitIndex = registerIndex * registerWidth;\n+        final int firstWordIndex = (int)(bitIndex >>> LOG2_BITS_PER_WORD)/*aka (bitIndex / BITS_PER_WORD)*/;\n+        final int secondWordIndex = (int)((bitIndex + registerWidth - 1) >>> LOG2_BITS_PER_WORD)/*see above*/;\n+        final int bitRemainder = (int)(bitIndex & BITS_PER_WORD_MASK)/*aka (bitIndex % BITS_PER_WORD)*/;\n+\n+        final long words[] = this.words/*for convenience/performance*/;\n+        if(firstWordIndex == secondWordIndex) {\n+            // clear then set\n+            words[firstWordIndex] &= ~(registerMask << bitRemainder);\n+            words[firstWordIndex] |= (value << bitRemainder);\n+        } else {/*register spans words*/\n+            // clear then set each partial word\n+            words[firstWordIndex] &= (1L << bitRemainder) - 1;\n+            words[firstWordIndex] |= (value << bitRemainder);\n+\n+            words[secondWordIndex] &= ~(registerMask >>> (BITS_PER_WORD - bitRemainder));\n+            words[secondWordIndex] |= (value >>> (BITS_PER_WORD - bitRemainder));\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    /**\n+     * @return a <code>LongIterator</code> for iterating starting at the register\n+     *         with index zero. This will never be <code>null</code>.\n+     */\n+    public org.apache.ignite.internal.processors.query.stat.hll.util.LongIterator registerIterator() {\n+        LongIterator longIterator = new LongIterator() {\n+            final int registerWidth = BitVector.this.registerWidth;\n+            final long[] words = BitVector.this.words;\n+            final long registerMask = BitVector.this.registerMask;\n+\n+            // register setup\n+            long registerIndex = 0;\n+            int wordIndex = 0;\n+            int remainingWordBits = BITS_PER_WORD;\n+            long word = words[wordIndex];\n+\n+            @Override\n+            public long next() {\n+                long register;\n+                if (remainingWordBits >= registerWidth) {\n+                    register = word & registerMask;\n+\n+                    // shift to the next register\n+                    word >>>= registerWidth;\n+                    remainingWordBits -= registerWidth;\n+                } else { /*insufficient bits remaining in current word*/\n+                    wordIndex++/*move to the next word*/;\n+\n+                    register = (word | (words[wordIndex] << remainingWordBits)) & registerMask;\n+\n+                    // shift to the next partial register (word)\n+                    word = words[wordIndex] >>> (registerWidth - remainingWordBits);\n+                    remainingWordBits += BITS_PER_WORD - registerWidth;\n+                }\n+                registerIndex++;\n+                return register;\n+            }\n+\n+            @Override\n+            public boolean hasNext() {\n+                return registerIndex < count;\n+            }\n+        };\n+        return longIterator;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // composite accessors\n+    /**\n+     * Sets the value of the specified index register if and only if the specified\n+     * value is greater than the current value in the register.  This is equivalent\n+     * to but much more performant than:<p/>\n+     *\n+     * <pre>vector.setRegister(index, Math.max(vector.getRegister(index), value));</pre>\n+     *\n+     * @param  registerIndex the index of the register whose value is to be set.\n+     *         This cannot be negative\n+     * @param  value the value to set in the register if and only if this value\n+     *         is greater than the current value in the register\n+     * @return <code>true</code> if and only if the specified value is greater\n+     *         than or equal to the current register value.  <code>false</code>\n+     *         otherwise.\n+     * @see #getRegister(long)\n+     * @see #setRegister(long, long)\n+     * @see java.lang.Math#max(long, long)\n+     */\n+    // NOTE:  if this changes then setRegister() must change\n+    public boolean setMaxRegister(final long registerIndex, final long value) {\n+        final long bitIndex = registerIndex * registerWidth;\n+        final int firstWordIndex = (int)(bitIndex >>> LOG2_BITS_PER_WORD)/*aka (bitIndex / BITS_PER_WORD)*/;\n+        final int secondWordIndex = (int)((bitIndex + registerWidth - 1) >>> LOG2_BITS_PER_WORD)/*see above*/;\n+        final int bitRemainder = (int)(bitIndex & BITS_PER_WORD_MASK)/*aka (bitIndex % BITS_PER_WORD)*/;\n+\n+        // NOTE:  matches getRegister()\n+        final long registerValue;\n+        final long words[] = this.words/*for convenience/performance*/;\n+        if(firstWordIndex == secondWordIndex)\n+            registerValue = ((words[firstWordIndex] >>> bitRemainder) & registerMask);\n+        else /*register spans words*/\n+            registerValue = (words[firstWordIndex] >>> bitRemainder)/*no need to mask since at top of word*/\n+                    | (words[secondWordIndex] << (BITS_PER_WORD - bitRemainder)) & registerMask;\n+\n+        // determine which is the larger and update as necessary\n+        if(value > registerValue) {\n+            // NOTE:  matches setRegister()\n+            if(firstWordIndex == secondWordIndex) {\n+                // clear then set\n+                words[firstWordIndex] &= ~(registerMask << bitRemainder);\n+                words[firstWordIndex] |= (value << bitRemainder);\n+            } else {/*register spans words*/\n+                // clear then set each partial word\n+                words[firstWordIndex] &= (1L << bitRemainder) - 1;\n+                words[firstWordIndex] |= (value << bitRemainder);\n+\n+                words[secondWordIndex] &= ~(registerMask >>> (BITS_PER_WORD - bitRemainder));\n+                words[secondWordIndex] |= (value >>> (BITS_PER_WORD - bitRemainder));\n+            }\n+        } /* else -- the register value is greater (or equal) so nothing needs to be done */\n+\n+        return (value >= registerValue);\n+    }\n+\n+    // ========================================================================\n+    /**\n+     * Fills this bit vector with the specified bit value.  This can be used to\n+     * clear the vector by specifying <code>0</code>.\n+     *\n+     * @param  value the value to set all bits to (only the lowest bit is used)\n+     */\n+    public void fill(final long value) {\n+        for(long i=0; i<count; i++) {\n+            setRegister(i, value);\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    /**\n+     * Serializes the registers of the vector using the specified serializer.\n+     *\n+     * @param serializer the serializer to use. This cannot be <code>null</code>.\n+     */\n+    public void getRegisterContents(final IWordSerializer serializer) {\n+        for(final LongIterator iter = registerIterator(); iter.hasNext();) {\n+            serializer.writeWord(iter.next());\n+        }\n+    }\n+\n+    /**\n+     * Creates a deep copy of this vector.\n+     *\n+     * @see java.lang.Object#clone()\n+     */\n+    @Override\n+    public BitVector clone() {\n+        final BitVector copy = new BitVector(registerWidth, count);\n+        System.arraycopy(words, 0, copy.words, 0, words.length);\n+        return copy;\n+    }\n+}", "originalCommit": "6e542dba4c81179ed1a8fab253f3a1fb85c02eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc0NjQzMA==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508746430", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            }\n          \n          \n            \n            }", "author": "AMashenkov", "createdAt": "2020-10-20T18:26:46Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/hll/util/LongIterator.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * Copyright 2013 Aggregate Knowledge, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat.hll.util;\n+\n+\n+/**\n+ * A <code>long</code>-based iterator.  This is not <i>is-a</i> {@link java.util.Iterator}\n+ * to prevent autoboxing between <code>Long</code> and <code>long</code>.\n+ *\n+ * @author rgrzywinski\n+ */\n+public interface LongIterator {\n+    /**\n+     * @return <code>true</code> if and only if there are more elements to\n+     *         iterate over.  <code>false</code> otherwise.\n+     */\n+    boolean hasNext();\n+\n+    /**\n+     * @return the next <code>long</code> in the collection.\n+     */\n+    long next();\n+}", "originalCommit": "6e542dba4c81179ed1a8fab253f3a1fb85c02eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc0NjU5MA==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508746590", "bodyText": "Suggested change", "author": "AMashenkov", "createdAt": "2020-10-20T18:26:59Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/hll/util/LongIterator.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * Copyright 2013 Aggregate Knowledge, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat.hll.util;\n+\n+", "originalCommit": "6e542dba4c81179ed1a8fab253f3a1fb85c02eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc0Njc1Mw==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508746753", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            }\n          \n          \n            \n            }", "author": "AMashenkov", "createdAt": "2020-10-20T18:27:15Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/hll/util/NumberUtil.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright 2013 Aggregate Knowledge, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat.hll.util;\n+\n+/**\n+ * A collection of utilities to work with numbers.\n+ *\n+ * @author rgrzywinski\n+ */\n+public class NumberUtil {\n+    // loge(2) (log-base e of 2)\n+    public static final double LOGE_2 = 0.6931471805599453;\n+\n+    // ************************************************************************\n+    /**\n+     * Computes the <code>log2</code> (log-base-two) of the specified value.\n+     *\n+     * @param  value the <code>double</code> for which the <code>log2</code> is\n+     *         desired.\n+     * @return the <code>log2</code> of the specified value\n+     */\n+    public static double log2(final double value) {\n+        // REF:  http://en.wikipedia.org/wiki/Logarithmic_scale (conversion of bases)\n+        return Math.log(value) / LOGE_2;\n+    }\n+\n+    // ========================================================================\n+    // the hex characters\n+    private static final char[] HEX = { '0', '1', '2', '3', '4', '5', '6', '7',\n+            '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };\n+\n+    // ------------------------------------------------------------------------\n+    /**\n+     * Converts the specified array of <code>byte</code>s into a string of\n+     * hex characters (low <code>byte</code> first).\n+     *\n+     * @param  bytes the array of <code>byte</code>s that are to be converted.\n+     *         This cannot be <code>null</code> though it may be empty.\n+     * @param  offset the offset in <code>bytes</code> at which the bytes will\n+     *         be taken.  This cannot be negative and must be less than\n+     *         <code>bytes.length - 1</code>.\n+     * @param  count the number of bytes to be retrieved from the specified array.\n+     *         This cannot be negative.  If greater than <code>bytes.length - offset</code>\n+     *         then that value is used.\n+     * @return a string of at most <code>count</code> characters that represents\n+     *         the specified byte array in hex.  This will never be <code>null</code>\n+     *         though it may be empty if <code>bytes</code> is empty or <code>count</code>\n+     *         is zero.\n+     * @throws IllegalArgumentException if <code>offset</code> is greater than\n+     *         or equal to <code>bytes.length</code>.\n+     * @see #fromHex(String, int, int)\n+     */\n+    public static String toHex(final byte[] bytes, final int offset, final int count) {\n+        if(offset >= bytes.length) throw new IllegalArgumentException(\"Offset is greater than the length (\" + offset + \" >= \" + bytes.length + \").\")/*by contract*/;\n+        final int byteCount = Math.min( (bytes.length - offset), count);\n+        final int upperBound = byteCount + offset;\n+\n+        final char[] chars = new char[byteCount * 2/*two chars per byte*/];\n+        int charIndex = 0;\n+        for(int i=offset; i<upperBound; i++) {\n+            final byte value = bytes[i];\n+            chars[charIndex++] = HEX[(value >>> 4) & 0x0F];\n+            chars[charIndex++] = HEX[value & 0x0F];\n+        }\n+\n+        return new String(chars);\n+    }\n+\n+    /**\n+     * Converts the specified array of hex characters into an array of <code>byte</code>s\n+     * (low <code>byte</code> first).\n+     *\n+     * @param  string the string of hex characters to be converted into <code>byte</code>s.\n+     *         This cannot be <code>null</code> though it may be blank.\n+     * @param  offset the offset in the string at which the characters will be\n+     *         taken.  This cannot be negative and must be less than <code>string.length() - 1</code>.\n+     * @param  count the number of characters to be retrieved from the specified\n+     *         string.  This cannot be negative and must be divisible by two\n+     *         (since there are two characters per <code>byte</code>).\n+     * @return the array of <code>byte</code>s that were converted from the\n+     *         specified string (in the specified range).  This will never be\n+     *         <code>null</code> though it may be empty if <code>string</code>\n+     *         is empty or <code>count</code> is zero.\n+     * @throws IllegalArgumentException if <code>offset</code> is greater than\n+     *         or equal to <code>string.length()</code> or if <code>count</code>\n+     *         is not divisible by two.\n+     * @see #toHex(byte[], int, int)\n+     */\n+    public static byte[] fromHex(final String string, final int offset, final int count) {\n+        if(offset >= string.length()) throw new IllegalArgumentException(\"Offset is greater than the length (\" + offset + \" >= \" + string.length() + \").\")/*by contract*/;\n+        if( (count & 0x01) != 0) throw new IllegalArgumentException(\"Count is not divisible by two (\" + count + \").\")/*by contract*/;\n+        final int charCount = Math.min((string.length() - offset), count);\n+        final int upperBound = offset + charCount;\n+\n+        final byte[] bytes = new byte[charCount >>> 1/*aka /2*/];\n+        int byteIndex = 0/*beginning*/;\n+        for(int i=offset; i<upperBound; i+=2) {\n+            bytes[byteIndex++] = (byte)(( (digit(string.charAt(i)) << 4)\n+                    | digit(string.charAt(i + 1))) & 0xFF);\n+        }\n+\n+        return bytes;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    /**\n+     * @param  character a hex character to be converted to a <code>byte</code>.\n+     *         This cannot be a character other than [a-fA-F0-9].\n+     * @return the value of the specified character.  This will be a value <code>0</code>\n+     *         through <code>15</code>.\n+     * @throws IllegalArgumentException if the specified character is not in\n+     *         [a-fA-F0-9]\n+     */\n+    private static final int digit(final char character) {\n+        switch(character) {\n+            case '0':\n+                return 0;\n+            case '1':\n+                return 1;\n+            case '2':\n+                return 2;\n+            case '3':\n+                return 3;\n+            case '4':\n+                return 4;\n+            case '5':\n+                return 5;\n+            case '6':\n+                return 6;\n+            case '7':\n+                return 7;\n+            case '8':\n+                return 8;\n+            case '9':\n+                return 9;\n+            case 'a':\n+            case 'A':\n+                return 10;\n+            case 'b':\n+            case 'B':\n+                return 11;\n+            case 'c':\n+            case 'C':\n+                return 12;\n+            case 'd':\n+            case 'D':\n+                return 13;\n+            case 'e':\n+            case 'E':\n+                return 14;\n+            case 'f':\n+            case 'F':\n+                return 15;\n+\n+            default:\n+                throw new IllegalArgumentException(\"Character is not in [a-fA-F0-9] ('\" + character + \"').\");\n+        }\n+    }\n+}", "originalCommit": "6e542dba4c81179ed1a8fab253f3a1fb85c02eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc0NzE4OA==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508747188", "bodyText": "Javadoc", "author": "AMashenkov", "createdAt": "2020-10-20T18:27:58Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/stat/HasherSelfTest.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+\n+public class HasherSelfTest extends GridCommonAbstractTest {", "originalCommit": "6e542dba4c81179ed1a8fab253f3a1fb85c02eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc0NzM1MQ==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508747351", "bodyText": "Javadoc", "author": "AMashenkov", "createdAt": "2020-10-20T18:28:15Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/stat/StatisticCollectionTest.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import org.apache.ignite.Ignite;\n+import org.junit.Test;\n+\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.TimeZone;\n+import java.util.UUID;\n+\n+/**\n+ * Tests to check statistics collection by different types and distributions.\n+ */\n+public class StatisticCollectionTest extends TableStatisticsAbstractTest {\n+\n+    private static final String TYPES[] = new String[]{\"BOOLEAN\", \"INT\", \"TINYINT\", \"SMALLINT\",\"BIGINT\",", "originalCommit": "6e542dba4c81179ed1a8fab253f3a1fb85c02eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc0ODE3NA==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508748174", "bodyText": "Javadocs", "author": "AMashenkov", "createdAt": "2020-10-20T18:29:42Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/stat/ValueDistributionTableStatisticsUsageTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.cache.CacheMode;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import static org.apache.ignite.cache.CacheMode.PARTITIONED;\n+import static org.apache.ignite.cache.CacheMode.REPLICATED;\n+\n+/**\n+ * Test cases to ensure that proper index is chosen by H2 optimizer when value distribution statistics is collected.\n+ */\n+@RunWith(Parameterized.class)\n+public class ValueDistributionTableStatisticsUsageTest extends TableStatisticsAbstractTest {\n+    /** */\n+    @Parameterized.Parameter(0)\n+    public CacheMode cacheMode;\n+\n+    /**\n+     * @return Test parameters.\n+     */\n+    @Parameterized.Parameters(name = \"cacheMode={0}\")\n+    public static Collection parameters() {\n+        return Arrays.asList(new Object[][] {\n+                { REPLICATED },\n+                { PARTITIONED },\n+        });\n+    }\n+\n+    @Override protected void beforeTestsStarted() throws Exception {\n+        Ignite node = startGridsMultiThreaded(2);\n+\n+        node.getOrCreateCache(DEFAULT_CACHE_NAME);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void beforeTest() throws Exception {\n+        runSql(\"DROP TABLE IF EXISTS sized\");\n+\n+        runSql(\"CREATE TABLE sized (ID INT PRIMARY KEY, small VARCHAR, small_nulls VARCHAR,\" +\n+                \" big VARCHAR, big_nulls VARCHAR) WITH \\\"TEMPLATE=\" + cacheMode + \"\\\"\");\n+\n+        runSql(\"CREATE INDEX sized_small ON sized(small)\");\n+        runSql(\"CREATE INDEX sized_small_nulls ON sized(small_nulls)\");\n+        runSql(\"CREATE INDEX sized_big ON sized(big)\");\n+        runSql(\"CREATE INDEX sized_big_nulls ON sized(big_nulls)\");\n+\n+        String bigValue = \"someBigLongValueWithTheSameTextAtFirst\";\n+        String smallNulls, bigNulls;\n+        int valAdd;\n+        for (int i = 0; i < BIG_SIZE; i++) {\n+            if ((i & 1) == 0) {\n+                smallNulls = \"null\";\n+                bigNulls = null;\n+                valAdd = 0;\n+            } else {\n+                smallNulls = String.format(\"'small%d'\", i);\n+                bigNulls = String.format(\"'%s%d'\", bigValue, i);\n+                valAdd = 1;\n+            }\n+            String sql = String.format(\"INSERT INTO sized(id, small, small_nulls, big, big_nulls)\" +\n+                    \" VALUES(%d,'small%d', %s, '%s%d', %s)\", i, i + valAdd, smallNulls, bigValue, i + valAdd, bigNulls);\n+            runSql(sql);\n+        }\n+        runSql(\"INSERT INTO sized(id, small, big) VALUES(\" + BIG_SIZE + \", null, null)\");\n+        updateStatistics(\"sized\");\n+    }\n+\n+    @Test", "originalCommit": "6e542dba4c81179ed1a8fab253f3a1fb85c02eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc0ODQzOQ==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508748439", "bodyText": "Javadoc", "author": "AMashenkov", "createdAt": "2020-10-20T18:30:06Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/stat/hll/FullHLLTest.java", "diffHunk": "@@ -0,0 +1,417 @@\n+/*\n+ * Copyright 2013 Aggregate Knowledge, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat.hll;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+import org.apache.ignite.internal.processors.query.stat.hll.serialization.ISchemaVersion;\n+import org.apache.ignite.internal.processors.query.stat.hll.serialization.SerializationUtil;\n+import org.apache.ignite.internal.processors.query.stat.hll.util.BitVector;\n+import org.apache.ignite.internal.processors.query.stat.hll.util.HLLUtil;\n+import org.apache.ignite.internal.processors.query.stat.hll.util.LongIterator;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.junit.Test;\n+\n+import java.util.Random;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Tests {@link HLL} of type {@link HLLType#FULL}.\n+ *\n+ * @author rgrzywinski\n+ * @author timon\n+ */\n+public class FullHLLTest {\n+    /**\n+     * Smoke test for {@link HLL#cardinality(int)} and the proper use of the\n+     * small range correction.\n+     */\n+    @Test\n+    public void smallRangeSmokeTest() {\n+        final int log2m = 11;\n+        final int m = (1 << log2m);\n+        final int regwidth = 5;\n+\n+        // only one register set\n+        {\n+            final HLL hll = new HLL(log2m, regwidth, 128/*explicitThreshold, arbitrary, unused*/, 256/*sparseThreshold, arbitrary, unused*/, HLLType.FULL);\n+            hll.addRaw(ProbabilisticTestUtil.constructHLLValue(log2m, 0/*ix*/, 1/*val*/));\n+\n+            final long cardinality = hll.cardinality();\n+\n+            // Trivially true that small correction conditions hold: one register\n+            // set implies zeroes exist, and estimator trivially smaller than 5m/2.\n+            // Small range correction: m * log(m/V)\n+            final long expected = (long)Math.ceil(m * Math.log((double)m / (m - 1)/*# of zeroes*/));\n+            assertEquals(cardinality, expected);\n+        }\n+\n+        // all but one register set\n+        {\n+            final HLL hll = new HLL(log2m, regwidth, 128/*explicitThreshold, arbitrary, unused*/, 256/*sparseThreshold, arbitrary, unused*/, HLLType.FULL);\n+            for(int i=0; i<(m - 1); i++) {\n+                hll.addRaw(ProbabilisticTestUtil.constructHLLValue(log2m, i/*ix*/, 1/*val*/));\n+            }\n+\n+            // Trivially true that small correction conditions hold: all but\n+            // one register set implies a zero exists, and estimator trivially\n+            // smaller than 5m/2 since it's alpha / ((m-1)/2)\n+            final long cardinality = hll.cardinality();\n+\n+            // Small range correction: m * log(m/V)\n+            final long expected = (long)Math.ceil(m * Math.log((double)m / 1/*# of zeroes*/));\n+            assertEquals(cardinality, expected);\n+        }\n+    }\n+\n+    /**\n+     * Smoke test for {@link HLL#cardinality()} and the proper use of the\n+     * uncorrected estimator\n+     */\n+    @Test\n+    public void normalRangeSmokeTest() {\n+        final int log2m = 11;\n+        final int regwidth = 5;\n+        // regwidth = 5, so hash space is\n+        // log2m + (2^5 - 1 - 1), so L = log2m + 30\n+        final int l = log2m + 30;\n+        final int m = (1 << log2m);\n+        final HLL hll = new HLL(log2m, regwidth, 128/*explicitThreshold, arbitrary, unused*/, 256/*sparseThreshold, arbitrary, unused*/, HLLType.FULL);\n+\n+        // all registers at 'medium' value\n+        {\n+            final int registerValue = 7/*chosen to ensure neither correction kicks in*/;\n+            for(int i=0; i<m; i++) {\n+                hll.addRaw(ProbabilisticTestUtil.constructHLLValue(log2m, i, registerValue));\n+            }\n+\n+            final long cardinality = hll.cardinality();\n+\n+\n+            // Simplified estimator when all registers take same value: alpha / (m/2^val)\n+            final double estimator = HLLUtil.alphaMSquared(m)/((double)m/Math.pow(2, registerValue));\n+\n+            // Assert conditions for uncorrected range\n+            assertTrue(estimator <= Math.pow(2, l)/30);\n+            assertTrue(estimator > (5 * m /(double)2));\n+\n+            final long expected = (long)Math.ceil(estimator);\n+            assertEquals(cardinality, expected);\n+        }\n+    }\n+\n+    /**\n+     * Smoke test for {@link HLL#cardinality()} and the proper use of the large\n+     * range correction.\n+     */\n+    @Test\n+    public void largeRangeSmokeTest() {\n+        final int log2m = 12;\n+        final int regwidth = 5;\n+        // regwidth = 5, so hash space is\n+        // log2m + (2^5 - 1 - 1), so L = log2m + 30\n+        final int l = log2m + 30;\n+        final int m = (1 << log2m);\n+        final HLL hll = new HLL(log2m, regwidth, 128/*explicitThreshold, arbitrary, unused*/, 256/*sparseThreshold, arbitrary, unused*/, HLLType.FULL);\n+\n+        {\n+            final int registerValue = 31/*chosen to ensure large correction kicks in*/;\n+            for(int i=0; i<m; i++) {\n+                hll.addRaw(ProbabilisticTestUtil.constructHLLValue(log2m, i, registerValue));\n+            }\n+\n+            final long cardinality = hll.cardinality();\n+\n+\n+            // Simplified estimator when all registers take same value: alpha / (m/2^val)\n+            final double estimator = HLLUtil.alphaMSquared(m)/((double)m/Math.pow(2, registerValue));\n+\n+            // Assert conditions for large range\n+\n+            assertTrue(estimator > Math.pow(2,l)/30);\n+\n+            // Large range correction: -2^L * log(1 - E/2^L)\n+            final long expected = (long)Math.ceil(-1.0 * Math.pow(2, l) * Math.log(1.0 - estimator/Math.pow(2, l)));\n+            assertEquals(cardinality, expected);\n+        }\n+    }\n+\n+    // ========================================================================\n+    /**\n+     * Tests the bounds on a register's value for a given raw input value.\n+     */\n+    @Test\n+    public void registerValueTest() {\n+        final int log2m = 4/*small enough to make testing easy (addRaw() shifts by one byte)*/;\n+\n+        // register width 4 (the minimum size)\n+        { // scoped locally for sanity\n+            final int regwidth = 4;\n+            final HLL hll = new HLL(log2m, regwidth, 128/*explicitThreshold, arbitrary, unused*/, 256/*sparseThreshold, arbitrary, unused*/, HLLType.FULL);\n+            final BitVector bitVector = GridTestUtils.getFieldValue(hll, \"probabilisticStorage\");//(BitVector)getInternalState(hll, \"probabilisticStorage\")/*for testing convenience*/;\n+\n+            // lower-bounds of the register\n+            hll.addRaw(0x000000000000001L/*'j'=1*/);\n+            assertEquals(bitVector.getRegister(1/*'j'*/), 0);\n+\n+            hll.addRaw(0x0000000000000012L/*'j'=2*/);\n+            assertEquals(bitVector.getRegister(2/*'j'*/), 1);\n+\n+            hll.addRaw(0x0000000000000023L/*'j'=3*/);\n+            assertEquals(bitVector.getRegister(3/*'j'*/), 2);\n+\n+            hll.addRaw(0x0000000000000044L/*'j'=4*/);\n+            assertEquals(bitVector.getRegister(4/*'j'*/), 3);\n+\n+            hll.addRaw(0x0000000000000085L/*'j'=5*/);\n+            assertEquals(bitVector.getRegister(5/*'j'*/), 4);\n+\n+            // upper-bounds of the register\n+            // NOTE:  bear in mind that BitVector itself does ensure that\n+            //        overflow of a register is prevented\n+            hll.addRaw(0x0000000000010006L/*'j'=6*/);\n+            assertEquals(bitVector.getRegister(6/*'j'*/), 13);\n+\n+            hll.addRaw(0x0000000000020007L/*'j'=7*/);\n+            assertEquals(bitVector.getRegister(7/*'j'*/), 14);\n+\n+            hll.addRaw(0x0000000000040008L/*'j'=8*/);\n+            assertEquals(bitVector.getRegister(8/*'j'*/), 15);\n+\n+            hll.addRaw(0x0000000000080009L/*'j'=9*/);\n+            assertEquals(bitVector.getRegister(9/*'j'*/), 15/*overflow*/);\n+\n+            // sanity checks to ensure that no other bits above the lowest-set\n+            // bit matters\n+            // NOTE:  same as case 'j = 6' above\n+            hll.addRaw(0x000000000003000AL/*'j'=10*/);\n+            assertEquals(bitVector.getRegister(10/*'j'*/), 13);\n+\n+            hll.addRaw(0x000000000011000BL/*'j'=11*/);\n+            assertEquals(bitVector.getRegister(11/*'j'*/), 13);\n+        }\n+\n+        // register width 5\n+        { // scoped locally for sanity\n+            final int regwidth = 5;\n+            final HLL hll = new HLL(log2m, regwidth, 128/*explicitThreshold, arbitrary, unused*/, 256/*sparseThreshold, arbitrary, unused*/, HLLType.FULL);\n+            final BitVector bitVector = GridTestUtils.getFieldValue(hll, \"probabilisticStorage\");\n+\n+            // lower-bounds of the register\n+            hll.addRaw(0x0000000000000001L/*'j'=1*/);\n+            assertEquals(bitVector.getRegister(1/*'j'*/), 0);\n+\n+            hll.addRaw(0x0000000000000012L/*'j'=2*/);\n+            assertEquals(bitVector.getRegister(2/*'j'*/), 1);\n+\n+            hll.addRaw(0x0000000000000023L/*'j'=3*/);\n+            assertEquals(bitVector.getRegister(3/*'j'*/), 2);\n+\n+            hll.addRaw(0x0000000000000044L/*'j'=4*/);\n+            assertEquals(bitVector.getRegister(4/*'j'*/), 3);\n+\n+            hll.addRaw(0x0000000000000085L/*'j'=5*/);\n+            assertEquals(bitVector.getRegister(5/*'j'*/), 4);\n+\n+            // upper-bounds of the register\n+            // NOTE:  bear in mind that BitVector itself does ensure that\n+            //        overflow of a register is prevented\n+            hll.addRaw(0x0000000100000006L/*'j'=6*/);\n+            assertEquals(bitVector.getRegister(6/*'j'*/), 29);\n+\n+            hll.addRaw(0x0000000200000007L/*'j'=7*/);\n+            assertEquals(bitVector.getRegister(7/*'j'*/), 30);\n+\n+            hll.addRaw(0x0000000400000008L/*'j'=8*/);\n+            assertEquals(bitVector.getRegister(8/*'j'*/), 31);\n+\n+            hll.addRaw(0x0000000800000009L/*'j'=9*/);\n+            assertEquals(bitVector.getRegister(9/*'j'*/), 31/*overflow*/);\n+        }\n+    }\n+\n+    // ========================================================================\n+    /**\n+     * Tests {@link HLL#clear()}.\n+     */\n+    @Test\n+    public void clearTest() {\n+        final int regwidth = 5;\n+        final int log2m = 4/*16 registers per counter*/;\n+        final int m = 1 << log2m;\n+\n+        final HLL hll = new HLL(log2m, regwidth, 128/*explicitThreshold, arbitrary, unused*/, 256/*sparseThreshold, arbitrary, unused*/, HLLType.FULL);\n+        final BitVector bitVector = GridTestUtils.getFieldValue(hll, \"probabilisticStorage\")/*for testing convenience*/;\n+        for(int i=0; i<m; i++)\n+            bitVector.setRegister(i, i);\n+\n+        hll.clear();\n+        for(int i=0; i<m; i++){\n+            assertEquals(bitVector.getRegister(i), 0L/*default value of register*/);\n+        }\n+    }\n+\n+    // ========================================================================\n+    // Serialization\n+    /**\n+     * Tests {@link HLL#toBytes(ISchemaVersion)} and {@link HLL#fromBytes(byte[])}.\n+     */\n+    @Test\n+    public void toFromBytesTest() {\n+        final int log2m = 11/*arbitrary*/;\n+        final int regwidth = 5;\n+\n+        final ISchemaVersion schemaVersion = SerializationUtil.DEFAULT_SCHEMA_VERSION;\n+        final HLLType type = HLLType.FULL;\n+        final int padding = schemaVersion.paddingBytes(type);\n+        final int dataByteCount = ProbabilisticTestUtil.getRequiredBytes(regwidth, (1 << log2m)/*aka 2^log2m = m*/);\n+        final int expectedByteCount = padding + dataByteCount;\n+\n+        {// Should work on an empty element\n+            final HLL hll = new HLL(log2m, regwidth, 128/*explicitThreshold, arbitrary, unused*/, 256/*sparseThreshold, arbitrary, unused*/, HLLType.FULL);\n+            final byte[] bytes = hll.toBytes(schemaVersion);\n+\n+            // assert output length is correct\n+            assertEquals(bytes.length, expectedByteCount);\n+\n+            final HLL inHLL = HLL.fromBytes(bytes);\n+\n+            // assert register values correct\n+            assertElementsEqual(hll, inHLL);\n+        }\n+        {// Should work on a partially filled element\n+            final HLL hll = new HLL(log2m, regwidth, 128/*explicitThreshold, arbitrary, unused*/, 256/*sparseThreshold, arbitrary, unused*/, HLLType.FULL);\n+\n+            for(int i=0; i<3; i++) {\n+                final long rawValue = ProbabilisticTestUtil.constructHLLValue(log2m, i, (i+9));\n+                hll.addRaw(rawValue);\n+            }\n+\n+            final byte[] bytes = hll.toBytes(schemaVersion);\n+\n+            // assert output length is correct\n+            assertEquals(bytes.length, expectedByteCount);\n+\n+            final HLL inHLL = HLL.fromBytes(bytes);\n+\n+            // assert register values correct\n+            assertElementsEqual(hll, inHLL);\n+        }\n+        {// Should work on a full set\n+            final HLL hll = new HLL(log2m, regwidth, 128/*explicitThreshold, arbitrary, unused*/, 256/*sparseThreshold, arbitrary, unused*/, HLLType.FULL);\n+\n+            for(int i=0; i<(1 << log2m)/*aka 2^log2m*/; i++) {\n+                final long rawValue = ProbabilisticTestUtil.constructHLLValue(log2m, i, (i % 9) + 1);\n+                hll.addRaw(rawValue);\n+            }\n+\n+            final byte[] bytes = hll.toBytes(schemaVersion);\n+\n+            // assert output length is correct\n+            assertEquals(bytes.length, expectedByteCount);\n+\n+            final HLL inHLL = HLL.fromBytes(bytes);\n+\n+            // assert register values correct\n+            assertElementsEqual(hll, inHLL);\n+        }\n+    }\n+\n+    @Test", "originalCommit": "6e542dba4c81179ed1a8fab253f3a1fb85c02eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc0ODc3MQ==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508748771", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            }\n          \n          \n            \n            }", "author": "AMashenkov", "createdAt": "2020-10-20T18:30:39Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/query/stat/StatisticCollectionTest.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import org.apache.ignite.Ignite;\n+import org.junit.Test;\n+\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.TimeZone;\n+import java.util.UUID;\n+\n+/**\n+ * Tests to check statistics collection by different types and distributions.\n+ */\n+public class StatisticCollectionTest extends TableStatisticsAbstractTest {\n+\n+    private static final String TYPES[] = new String[]{\"BOOLEAN\", \"INT\", \"TINYINT\", \"SMALLINT\",\"BIGINT\",\n+            \"DECIMAL\", \"DOUBLE\",\"REAL\",\"TIME\",\"DATE\",\"TIMESTAMP\",\"VARCHAR\",\"CHAR\",\"UUID\",\"BINARY\",\"GEOMETRY\"};\n+\n+    /** */\n+    private static final String START_DATE = \"1970.01.01 12:00:00 UTC\";\n+\n+    /** */\n+    private static final long TIMESTART;\n+\n+    /** */\n+    private static final SimpleDateFormat TIME_FORMATTER = new SimpleDateFormat(\"HH:mm:ss\");\n+\n+    /** */\n+    private static final SimpleDateFormat DATE_FORMATTER = new SimpleDateFormat(\"yyyy-MM-dd\");\n+\n+    /** */\n+    private static final SimpleDateFormat TIMESTAMP_FORMATTER = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n+\n+    static {\n+        TimeZone tz = TimeZone.getTimeZone(\"UTC\");\n+        SimpleDateFormat SDF = new SimpleDateFormat(\"yyyy.MM.dd HH:mm:ss z\");\n+        SDF.setTimeZone(tz);\n+        Calendar cal = Calendar.getInstance();\n+        try {\n+            cal.setTime(SDF.parse(START_DATE));\n+        } catch (ParseException e) {\n+            // No-op.\n+        }\n+        TIMESTART = cal.getTimeInMillis();\n+\n+        TIME_FORMATTER.setTimeZone(tz);\n+        DATE_FORMATTER.setTimeZone(tz);\n+        TIMESTAMP_FORMATTER.setTimeZone(tz);\n+    }\n+\n+    @Override protected void beforeTestsStarted() throws Exception {\n+        Ignite node = startGridsMultiThreaded(1);\n+\n+        node.getOrCreateCache(DEFAULT_CACHE_NAME);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void beforeTest() throws Exception {\n+        runSql(\"DROP TABLE IF EXISTS dtypes\");\n+\n+        StringBuilder create = new StringBuilder(\"CREATE TABLE dtypes (ID INT PRIMARY KEY, col_index int, col_no_index int\");\n+        for (String type : TYPES)\n+            create.append(\", col_\").append(type).append(\" \").append(type);\n+\n+        create.append(\")\");\n+\n+        runSql(create.toString());\n+\n+        runSql(\"CREATE INDEX dtypes_col_index ON dtypes(col_index)\");\n+        for (String type : TYPES)\n+            runSql(String.format(\"CREATE INDEX dtypes_%s ON dtypes(col_%s)\", type, type));\n+\n+        for (int i = 1; i < SMALL_SIZE; i++)\n+            runSql(insert(i));\n+\n+        for (int i = 0; i > -SMALL_SIZE / 2; i--)\n+            runSql(insertNulls(i));\n+\n+        updateStatistics(\"dtypes\");\n+    }\n+\n+    private String insertNulls(long counter) {\n+        return String.format(\"INSERT INTO dtypes(id) values (%d)\", counter);\n+    }\n+\n+    private String insert(long counter) {\n+        StringBuilder insert = new StringBuilder(\"INSERT INTO dtypes(id, col_index, col_no_index\");\n+\n+        for (int i = 0; i < TYPES.length; i++)\n+            insert.append(\", col_\").append(TYPES[i]);\n+\n+        insert.append(\") VALUES (\")\n+                .append(counter).append(\", \")\n+                .append(counter).append(\", \")\n+                .append(counter);\n+\n+        for (int i = 0; i < TYPES.length; i++)\n+            insert.append(\", \").append(getVal(TYPES[i], counter));\n+\n+        insert.append(\")\");\n+        return insert.toString();\n+    }\n+\n+    private String getVal(String type, long counter) {\n+\n+        switch (type) {\n+            case \"BOOLEAN\":\n+                return ((counter & 1) == 0) ? \"False\" : \"True\";\n+\n+            case \"INT\":\n+                return String.valueOf(counter % 2147483648L);\n+\n+            case \"TINYINT\":\n+                return String.valueOf(counter % 128);\n+\n+            case \"SMALLINT\":\n+                return String.valueOf(counter % 32768);\n+\n+            case \"BIGINT\":\n+                return String.valueOf(counter);\n+\n+            case \"DECIMAL\":\n+            case \"DOUBLE\":\n+            case \"REAL\":\n+                return String.valueOf((double)counter / 100);\n+\n+            case \"TIME\":\n+                Calendar timeCalendar = Calendar.getInstance();\n+                timeCalendar.setTimeInMillis(TIMESTART);\n+                timeCalendar.add(Calendar.SECOND, (int)counter);\n+                return \"'\" + TIME_FORMATTER.format(timeCalendar.getTime()) + \"'\";\n+\n+            case \"DATE\":\n+                Calendar dateCalendar = Calendar.getInstance();\n+                dateCalendar.setTimeInMillis(TIMESTART);\n+                dateCalendar.add(Calendar.DATE, (int)counter);\n+                return \"'\" + DATE_FORMATTER.format(dateCalendar.getTime()) + \"'\";\n+\n+            case \"TIMESTAMP\":\n+                Calendar timestampCalendar = Calendar.getInstance();\n+                timestampCalendar.setTimeInMillis(TIMESTART);\n+                timestampCalendar.add(Calendar.SECOND, (int)counter);\n+                return \"'\" + TIMESTAMP_FORMATTER.format(timestampCalendar.getTime()) + \"'\";\n+\n+            case \"VARCHAR\":\n+                return \"'varchar\" + counter + \"'\";\n+\n+            case \"CHAR\":\n+                return \"'\" + (char)((int)'A' + counter % 32) + \"'\";\n+\n+            case \"UUID\":\n+                return \"'\" + new UUID(0L, counter) + \"'\";\n+\n+            case \"BINARY\":\n+                return String.valueOf(counter);\n+\n+            case \"GEOMETRY\":\n+                return \"null\";\n+\n+            default:\n+                throw new IllegalArgumentException();\n+        }\n+    }\n+\n+    /**\n+     * Run set of tests to select from specified column specified value.\n+     *\n+     * @param name type name\n+     * @param comparator >, <, =, is...\n+     * @param value value\n+     */\n+    private void doColumnTests(String name, String comparator, String value) {\n+        String[][] noHints = new String[1][];\n+\n+        String[][] hints = new String[1][];\n+        hints[0] = new String[]{\"DTYPES_\" + name};\n+\n+        String[][] wrongHints = new String[1][];\n+        wrongHints[0] = new String[]{\"DTYPES_COL_INDEX\"};\n+\n+        String isNullSql = String.format(\"select * from dtypes i1 where col_%s is null\", name);;\n+\n+        checkOptimalPlanChosenForDifferentIndexes(grid(0), new String[]{\"DTYPES_\" + name}, isNullSql, noHints);\n+\n+        checkOptimalPlanChosenForDifferentIndexes(grid(0), new String[]{\"DTYPES_\" + name}, isNullSql, hints);\n+\n+        checkOptimalPlanChosenForDifferentIndexes(grid(0), new String[]{}, isNullSql, wrongHints);\n+\n+        // TODO implement is not null check when optimizer will able to properly handle such condition\n+\n+        String sql = String.format(\"select * from dtypes i1 where col_%s %s %s\", name, comparator, value);\n+\n+        checkOptimalPlanChosenForDifferentIndexes(grid(0), new String[]{\"DTYPES_\" + name}, sql, noHints);\n+\n+        checkOptimalPlanChosenForDifferentIndexes(grid(0), new String[]{\"DTYPES_\" + name}, sql, hints);\n+\n+        checkOptimalPlanChosenForDifferentIndexes(grid(0), new String[]{}, sql, wrongHints);\n+\n+        String sqlMoreCond = sql + \" and col_no_index = 213\";\n+        checkOptimalPlanChosenForDifferentIndexes(grid(0), new String[]{\"DTYPES_\" + name}, sqlMoreCond, noHints);\n+\n+        checkOptimalPlanChosenForDifferentIndexes(grid(0), new String[]{\"DTYPES_\" + name}, sqlMoreCond, hints);\n+\n+        checkOptimalPlanChosenForDifferentIndexes(grid(0), new String[]{}, sqlMoreCond, wrongHints);\n+\n+        String descSql = sql + String.format(\" order by col_%s desc\", name);\n+        checkOptimalPlanChosenForDifferentIndexes(grid(0), new String[]{\"DTYPES_\" + name}, descSql, noHints);\n+\n+        checkOptimalPlanChosenForDifferentIndexes(grid(0), new String[]{\"DTYPES_\" + name}, descSql, hints);\n+\n+        checkOptimalPlanChosenForDifferentIndexes(grid(0), new String[]{}, descSql, wrongHints);\n+\n+        String descNoIndexSql = sql + \" order by col_no_index desc\";\n+\n+        checkOptimalPlanChosenForDifferentIndexes(grid(0), new String[]{\"DTYPES_\" + name}, descNoIndexSql, noHints);\n+\n+        checkOptimalPlanChosenForDifferentIndexes(grid(0), new String[]{\"DTYPES_\" + name}, descNoIndexSql, hints);\n+    }\n+\n+    /**\n+     * Test that optimizer will use boolean column index.\n+     */\n+    @Test\n+    public void compareSelectWithBooleanConditions() {\n+        doColumnTests(\"BOOLEAN\", \"=\", \"true\");\n+    }\n+\n+    /**\n+     * Test that optimizer will use int column index.\n+     */\n+    @Test\n+    public void compareSelectWithIntConditions() {\n+        doColumnTests(\"INT\", \"<\", \"-10\");\n+        doColumnTests(\"INT\", \"<\", \"10\");\n+        doColumnTests(\"INT\", \"<=\", \"2\");\n+        doColumnTests(\"INT\", \"=\", \"1\");\n+        doColumnTests(\"INT\", \">=\", \"100\");\n+        doColumnTests(\"INT\", \">\", \"90\");\n+        doColumnTests(\"INT\", \">\", \"190\");\n+    }\n+\n+    /**\n+     * Test that optimizer will use tinyint column index.\n+     */\n+    @Test\n+    public void compareSelectWithTinyintConditions() {\n+        doColumnTests(\"TINYINT\", \"<\", \"-10\");\n+        doColumnTests(\"TINYINT\", \"<\", \"10\");\n+        doColumnTests(\"TINYINT\", \"<=\", \"10\");\n+        doColumnTests(\"TINYINT\", \"=\", \"1\");\n+        doColumnTests(\"TINYINT\", \">=\", \"100\");\n+        doColumnTests(\"TINYINT\", \">\", \"99\");\n+        doColumnTests(\"TINYINT\", \">\", \"110\");\n+    }\n+\n+    /**\n+     * Test that optimizer will use small integer column index.\n+     */\n+    @Test\n+    public void compareSelectWithSmallintConditions() {\n+        doColumnTests(\"SMALLINT\", \"<\", \"-10\");\n+        doColumnTests(\"SMALLINT\", \"<\", \"10\");\n+        doColumnTests(\"SMALLINT\", \"<=\", \"10\");\n+        doColumnTests(\"SMALLINT\", \"=\", \"1\");\n+        doColumnTests(\"SMALLINT\", \">=\", \"100\");\n+        doColumnTests(\"SMALLINT\", \">\", \"90\");\n+        doColumnTests(\"SMALLINT\", \">\", \"190\");\n+    }\n+\n+    /**\n+     * Test that optimizer will use big integer column index.\n+     */\n+    @Test\n+    public void compareSelectWithBigintConditions() {\n+        doColumnTests(\"BIGINT\", \"<\", \"-10\");\n+        doColumnTests(\"BIGINT\", \"<\", \"10\");\n+        doColumnTests(\"BIGINT\", \"<=\", \"10\");\n+        doColumnTests(\"BIGINT\", \"=\", \"1\");\n+        doColumnTests(\"BIGINT\", \">=\", \"100\");\n+        doColumnTests(\"BIGINT\", \">\", \"99\");\n+        doColumnTests(\"BIGINT\", \">\", \"199\");\n+    }\n+\n+    /**\n+     * Test that optimizer will use decimal column index.\n+     */\n+    @Test\n+    public void compareSelectWithDecimalConditions() {\n+        doColumnTests(\"DECIMAL\", \"<\", \"-10\");\n+        doColumnTests(\"DECIMAL\", \"<\", \"0.2\");\n+        doColumnTests(\"DECIMAL\", \"<=\", \"0.1\");\n+        doColumnTests(\"DECIMAL\", \"=\", \"1\");\n+        doColumnTests(\"DECIMAL\", \">=\", \"0.8\");\n+        doColumnTests(\"DECIMAL\", \">=\", \"100\");\n+    }\n+\n+    /**\n+     * Test that optimizer will use double column index.\n+     */\n+    @Test\n+    public void compareSelectWithDoubleConditions() {\n+        doColumnTests(\"DOUBLE\", \"<\", \"-10\");\n+        doColumnTests(\"DOUBLE\", \"<\", \"0.2\");\n+        doColumnTests(\"DOUBLE\", \"<=\", \"0.2\");\n+        doColumnTests(\"DOUBLE\", \"=\", \"1\");\n+        doColumnTests(\"DOUBLE\", \">=\", \"0.8\");\n+        doColumnTests(\"DOUBLE\", \">\", \"0.9\");\n+        doColumnTests(\"DOUBLE\", \">=\", \"100\");\n+    }\n+\n+    /**\n+     * Test that optimizer will use real column index.\n+     */\n+    @Test\n+    public void compareSelectWithRealConditions() {\n+        doColumnTests(\"REAL\", \"<\", \"-10\");\n+        doColumnTests(\"REAL\", \"<\", \"0.2\");\n+        doColumnTests(\"REAL\", \"<=\", \"0.22\");\n+        doColumnTests(\"REAL\", \"=\", \"1\");\n+        doColumnTests(\"REAL\", \">=\", \"0.8\");\n+        doColumnTests(\"REAL\", \">\", \"0.9\");\n+        doColumnTests(\"REAL\", \">=\", \"100\");\n+    }\n+\n+    /**\n+     * Test that optimizer will use time column index.\n+     */\n+    @Test\n+    public void compareSelectWithTimeConditions() {\n+        doColumnTests(\"TIME\", \"<\", \"'11:00:02'\");\n+        doColumnTests(\"TIME\", \"<\", \"'12:00:02'\");\n+        doColumnTests(\"TIME\", \"<=\", \"'12:00:02'\");\n+        doColumnTests(\"TIME\", \"=\", \"'12:00:00'\");\n+        doColumnTests(\"TIME\", \">=\", \"'12:01:00'\");\n+        doColumnTests(\"TIME\", \">=\", \"'13:00:00'\");\n+    }\n+\n+    /**\n+     * Test that optimizer will use date column index.\n+     */\n+    @Test\n+    public void compareSelectWithDateConditions() {\n+        doColumnTests(\"DATE\", \"<\", \"'1969-01-03'\");\n+        doColumnTests(\"DATE\", \"<\", \"'1970-01-03'\");\n+        doColumnTests(\"DATE\", \"<=\", \"'1970-01-02'\");\n+        doColumnTests(\"DATE\", \"=\", \"'1970-01-02'\");\n+        doColumnTests(\"DATE\", \">=\", \"'1970-03-03'\");\n+        doColumnTests(\"DATE\", \">=\", \"'1970-09-03'\");\n+    }\n+\n+    /**\n+     * Test that optimizer will use timestamp column index.\n+     */\n+    @Test\n+    public void compareSelectWithTimestampConditions() {\n+        doColumnTests(\"TIMESTAMP\", \"<\", \"'1970-01-01 11:00:09'\");\n+        doColumnTests(\"TIMESTAMP\", \"<\", \"'1970-01-01 12:00:09'\");\n+        doColumnTests(\"TIMESTAMP\", \"<=\", \"'1970-01-01 12:00:02'\");\n+        doColumnTests(\"TIMESTAMP\", \"=\", \"'1970-01-01 12:00:59'\");\n+        doColumnTests(\"TIMESTAMP\", \">=\", \"'1970-01-01 12:01:23'\");\n+        doColumnTests(\"TIMESTAMP\", \">=\", \"'1970-01-01 12:08:23'\");\n+    }\n+\n+    /**\n+     * Test that optimizer will use varchar column index.\n+     */\n+    @Test\n+    public void compareSelectWithVarcharConditions() {\n+        doColumnTests(\"VARCHAR\", \"<\", \"'a'\");\n+        doColumnTests(\"VARCHAR\", \"<\", \"'varchar2'\");\n+        doColumnTests(\"VARCHAR\", \"<\", \"'varchar1'\");\n+        doColumnTests(\"VARCHAR\", \"=\", \"'test+string'\");\n+        doColumnTests(\"VARCHAR\", \">=\", \"'varchar99'\");\n+        doColumnTests(\"VARCHAR\", \">\", \"'varchar99'\");\n+        doColumnTests(\"VARCHAR\", \">\", \"'varchar199'\");\n+        doColumnTests(\"VARCHAR\", \">\", \"'varchar1'\");\n+    }\n+\n+    /**\n+     * Test that optimizer will use char column index.\n+     */\n+    @Test\n+    public void compareSelectWithCharConditions() {\n+        doColumnTests(\"CHAR\", \"<\", \"'8'\");\n+        doColumnTests(\"CHAR\", \"<\", \"'B'\");\n+        doColumnTests(\"CHAR\", \"<=\", \"'C'\");\n+        doColumnTests(\"CHAR\", \"=\", \"'D'\");\n+        doColumnTests(\"CHAR\", \">=\", \"'W'\");\n+        doColumnTests(\"CHAR\", \">\", \"'Z'\");\n+        doColumnTests(\"CHAR\", \">\", \"'z'\");\n+    }\n+\n+    /**\n+     * Test that optimizer will use uuid column index.\n+     */\n+    @Test\n+    public void compareSelectWithUuidConditions() {\n+        doColumnTests(\"UUID\", \"<=\", \"'00000000-0000-0000-0000-000000000003'\");\n+        doColumnTests(\"UUID\", \"<=\", \"'00000000-0000-0000-0000-000000000001'\");\n+        doColumnTests(\"UUID\", \"=\", \"'00000000-0000-0000-0000-000000000002'\");\n+        doColumnTests(\"UUID\", \">=\", \"'00000000-0000-0000-0000-000000000089'\");\n+        doColumnTests(\"UUID\", \">=\", \"'00000000-0000-0000-0000-000000000099'\");\n+        doColumnTests(\"UUID\", \">\", \"'c1707d92-f1ad-11ea-adc1-0242ac120002'\");\n+    }\n+\n+    /**\n+     * Test that optimizer will use binary column index.\n+     */\n+    @Test\n+    public void compareSelectWithBinaryConditions() {\n+        doColumnTests(\"BINARY\", \"<\", \"12\");\n+        doColumnTests(\"BINARY\", \"<=\", \"13\");\n+        doColumnTests(\"BINARY\", \"=\", \"13\");\n+        doColumnTests(\"BINARY\", \">=\", \"85\");\n+        doColumnTests(\"BINARY\", \">\", \"95\");\n+        doColumnTests(\"BINARY\", \">=\", \"1242452143213\");\n+    }\n+}", "originalCommit": "6e542dba4c81179ed1a8fab253f3a1fb85c02eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc0OTQ4Mw==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508749483", "bodyText": "Actually, it is Murmur3 algorithm as it is said in LICENSE file above.", "author": "AMashenkov", "createdAt": "2020-10-20T18:31:53Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/Hasher.java", "diffHunk": "@@ -0,0 +1,231 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+\n+/**\n+ * Implement Murmur8_128 hash function for byte arrays.", "originalCommit": "6e542dba4c81179ed1a8fab253f3a1fb85c02eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc1NDU5OA==", "url": "https://github.com/gridgain/gridgain/pull/1495#discussion_r508754598", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            }\n          \n          \n            \n            }", "author": "AMashenkov", "createdAt": "2020-10-20T18:39:29Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/stat/Hasher.java", "diffHunk": "@@ -0,0 +1,231 @@\n+/*\n+ * Copyright 2020 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.ignite.internal.processors.query.stat;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+\n+/**\n+ * Implement Murmur8_128 hash function for byte arrays.\n+ */\n+public class Hasher {\n+    /** */\n+    private static final int SEED = 123456;\n+\n+    /** */\n+    private static final int CHUNK_SIZE = 16;\n+\n+    /** */\n+    private static final long C1 = 0x87c37b91114253d5L;\n+\n+    /** */\n+    private static final long C2 = 0x4cf5ad432745937fL;\n+\n+    /** */\n+    private long h1;\n+\n+    /** */\n+    private long h2;\n+\n+    /** */\n+    private int length;\n+\n+    /**\n+     * Calculate hash by specified byte array.\n+     *\n+     * @param arr array to calculate hash by.\n+     * @return hash value.\n+     */\n+    public long fastHash(byte[] arr) {\n+        return fastHash(arr, 0, arr.length);\n+    }\n+\n+    /**\n+     * Calculate hash by specified part of byte array.\n+     *\n+     * @param arr array to calculate hash by.\n+     * @param off offset.\n+     * @param len length.\n+     * @return hash value.\n+     */\n+    public long fastHash(byte[] arr, int off, int len) {\n+        h1 = SEED;\n+        h2 = SEED;\n+        length = 0;\n+\n+        ByteBuffer bb = ByteBuffer.wrap(arr, off, len).order(ByteOrder.LITTLE_ENDIAN);\n+        while (bb.remaining() >= CHUNK_SIZE) {\n+            process(bb);\n+        }\n+        if (bb.remaining() > 0)\n+            processRemaining(bb);\n+\n+        return makeHash();\n+    }\n+\n+    /**\n+     * Mix two long numbers.\n+     *\n+     * @param k1 the first number.\n+     * @param k2 the second number.\n+     */\n+    private void bmix64(long k1, long k2) {\n+        h1 ^= mixK1(k1);\n+\n+        h1 = Long.rotateLeft(h1, 27);\n+        h1 += h2;\n+        h1 = h1 * 5 + 0x52dce729;\n+\n+        h2 ^= mixK2(k2);\n+\n+        h2 = Long.rotateLeft(h2, 31);\n+        h2 += h1;\n+        h2 = h2 * 5 + 0x38495ab5;\n+    }\n+\n+    /**\n+     * Process byte buffer to calculate hash by.\n+     *\n+     * @param bb buffer to process.\n+     */\n+    private void process(ByteBuffer bb) {\n+        long k1 = bb.getLong();\n+        long k2 = bb.getLong();\n+        bmix64(k1, k2);\n+        length += CHUNK_SIZE;\n+    }\n+\n+    /**\n+     * Get int.\n+     *\n+     * @param val byte value\n+     * @return int value\n+     */\n+    private static int toInt(byte val) {\n+        return val & 0xFF;\n+    }\n+\n+    /**\n+     * Process remaining bytes from byte buffer.\n+     *\n+     * @param bb byte buffer to finish processing.\n+     */\n+    private void processRemaining(ByteBuffer bb) {\n+        long k1 = 0;\n+        long k2 = 0;\n+        length += bb.remaining();\n+        switch (bb.remaining()) {\n+            case 15:\n+                k2 ^= (long) toInt(bb.get(14)) << 48; // fall through\n+            case 14:\n+                k2 ^= (long) toInt(bb.get(13)) << 40; // fall through\n+            case 13:\n+                k2 ^= (long) toInt(bb.get(12)) << 32; // fall through\n+            case 12:\n+                k2 ^= (long) toInt(bb.get(11)) << 24; // fall through\n+            case 11:\n+                k2 ^= (long) toInt(bb.get(10)) << 16; // fall through\n+            case 10:\n+                k2 ^= (long) toInt(bb.get(9)) << 8; // fall through\n+            case 9:\n+                k2 ^= (long) toInt(bb.get(8)); // fall through\n+            case 8:\n+                k1 ^= bb.getLong();\n+                break;\n+            case 7:\n+                k1 ^= (long) toInt(bb.get(6)) << 48; // fall through\n+            case 6:\n+                k1 ^= (long) toInt(bb.get(5)) << 40; // fall through\n+            case 5:\n+                k1 ^= (long) toInt(bb.get(4)) << 32; // fall through\n+            case 4:\n+                k1 ^= (long) toInt(bb.get(3)) << 24; // fall through\n+            case 3:\n+                k1 ^= (long) toInt(bb.get(2)) << 16; // fall through\n+            case 2:\n+                k1 ^= (long) toInt(bb.get(1)) << 8; // fall through\n+            case 1:\n+                k1 ^= (long) toInt(bb.get(0));\n+                break;\n+            default:\n+                throw new AssertionError(\"Should never get here.\");\n+        }\n+        h1 ^= mixK1(k1);\n+        h2 ^= mixK2(k2);\n+    }\n+\n+    /**\n+     * Make hash from internal state.\n+     *\n+     * @return long hash value.\n+     */\n+    private long makeHash() {\n+        h1 ^= length;\n+        h2 ^= length;\n+\n+        h1 += h2;\n+        h2 += h1;\n+\n+        h1 = fmix64(h1);\n+        h2 = fmix64(h2);\n+\n+        h1 += h2;\n+        h2 += h1;\n+\n+        return h1;\n+    }\n+\n+    /**\n+     * Mix long value to prepare internal state for hash generation.\n+     *\n+     * @param k long value.\n+     * @return hashed one.\n+     */\n+    private static long fmix64(long k) {\n+        k ^= k >>> 33;\n+        k *= 0xff51afd7ed558ccdL;\n+        k ^= k >>> 33;\n+        k *= 0xc4ceb9fe1a85ec53L;\n+        k ^= k >>> 33;\n+        return k;\n+    }\n+\n+    /**\n+     * Mix value to update internal state h1.\n+     *\n+     * @param k1 value to mix.\n+     * @return new h1 value.\n+     */\n+    private static long mixK1(long k1) {\n+        k1 *= C1;\n+        k1 = Long.rotateLeft(k1, 31);\n+        k1 *= C2;\n+        return k1;\n+    }\n+\n+    /**\n+     * Mix value to update internal state h2.\n+     *\n+     * @param k2 value to mix.\n+     * @return new h2 value.\n+     */\n+    private static long mixK2(long k2) {\n+        k2 *= C2;\n+        k2 = Long.rotateLeft(k2, 33);\n+        k2 *= C1;\n+        return k2;\n+    }\n+}", "originalCommit": "6e542dba4c81179ed1a8fab253f3a1fb85c02eb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}