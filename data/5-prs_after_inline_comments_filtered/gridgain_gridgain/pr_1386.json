{"pr_number": 1386, "pr_title": "GG-30549 Extend query generator with ability to generate single-table queries", "pr_createdAt": "2020-08-24T16:25:57Z", "pr_url": "https://github.com/gridgain/gridgain/pull/1386", "timeline": [{"oid": "d5cfb643b31af7726d3eee48b6d9a1ef5bc2878b", "url": "https://github.com/gridgain/gridgain/commit/d5cfb643b31af7726d3eee48b6d9a1ef5bc2878b", "message": "GG-30549 Extend query generator with ability to generate single-table queries", "committedDate": "2020-08-24T16:24:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI4OTU2NQ==", "url": "https://github.com/gridgain/gridgain/pull/1386#discussion_r477289565", "bodyText": "2..12", "author": "Berkof", "createdAt": "2020-08-26T13:13:52Z", "path": "modules/compatibility/src/test/java/org/apache/ignite/compatibility/sql/randomsql/RandomQuerySupplier.java", "diffHunk": "@@ -248,13 +320,51 @@ private ColumnRef rndNumericColumn(TableRef tbl) {\n     }\n \n     /**\n-     * Returns {@code true} with probability that calculated\n-     * as {@code 1/r} where {@code r} - provided ratio.\n-     *\n-     * @param r Ratio.\n-     * @return {@code true} with desired probability.\n+     * Classic dice with 6 sides.\n      */\n-    private boolean rndWithRatio(int r) {\n-        return rnd.nextInt(r) == 0;\n+    private static class Dice {\n+        /** */\n+        private static final int SIDES_COUNT = 6;\n+\n+        /** */\n+        private final Random rnd;\n+\n+        /**\n+         * @param rnd Random.\n+         */\n+        public Dice(Random rnd) {\n+            this.rnd = rnd;\n+        }\n+\n+        /**\n+         * Roll this dice one times.\n+         *\n+         * @return Random value within interval [1..6].\n+         */\n+        public int roll() {\n+            return 1 + rnd.nextInt(SIDES_COUNT);\n+        }\n+\n+        /**\n+         * Roll this dice twice.\n+         *\n+         * @return Random value within interval [1..12].", "originalCommit": "d5cfb643b31af7726d3eee48b6d9a1ef5bc2878b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI4OTcyNQ==", "url": "https://github.com/gridgain/gridgain/pull/1386#discussion_r477289725", "bodyText": "N..N*6", "author": "Berkof", "createdAt": "2020-08-26T13:14:07Z", "path": "modules/compatibility/src/test/java/org/apache/ignite/compatibility/sql/randomsql/RandomQuerySupplier.java", "diffHunk": "@@ -248,13 +320,51 @@ private ColumnRef rndNumericColumn(TableRef tbl) {\n     }\n \n     /**\n-     * Returns {@code true} with probability that calculated\n-     * as {@code 1/r} where {@code r} - provided ratio.\n-     *\n-     * @param r Ratio.\n-     * @return {@code true} with desired probability.\n+     * Classic dice with 6 sides.\n      */\n-    private boolean rndWithRatio(int r) {\n-        return rnd.nextInt(r) == 0;\n+    private static class Dice {\n+        /** */\n+        private static final int SIDES_COUNT = 6;\n+\n+        /** */\n+        private final Random rnd;\n+\n+        /**\n+         * @param rnd Random.\n+         */\n+        public Dice(Random rnd) {\n+            this.rnd = rnd;\n+        }\n+\n+        /**\n+         * Roll this dice one times.\n+         *\n+         * @return Random value within interval [1..6].\n+         */\n+        public int roll() {\n+            return 1 + rnd.nextInt(SIDES_COUNT);\n+        }\n+\n+        /**\n+         * Roll this dice twice.\n+         *\n+         * @return Random value within interval [1..12].\n+         */\n+        public int rollTwice() {\n+            return rollNTimes(2);\n+        }\n+\n+        /**\n+         * Roll this dice {@code N} times.\n+         *\n+         * @param n Amount of time to roll dice. Should be greater than 0.\n+         * @return Random value within interval [1..N*6].", "originalCommit": "d5cfb643b31af7726d3eee48b6d9a1ef5bc2878b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI5ODA3Nw==", "url": "https://github.com/gridgain/gridgain/pull/1386#discussion_r477298077", "bodyText": "can we require more than 6 tables (with duplicates) from schema with only 3 table?", "author": "Berkof", "createdAt": "2020-08-26T13:26:03Z", "path": "modules/compatibility/src/test/java/org/apache/ignite/compatibility/sql/randomsql/RandomQuerySupplier.java", "diffHunk": "@@ -80,151 +92,211 @@ public RandomQuerySupplier(Schema schema, int seed) {\n     }\n \n     /**\n-     * Pick up to 4 random tables from provided schema. Some tables in\n-     * result list may appear twice.\n+     * Generates random SELECT expression.\n      *\n-     * @param schema Schema.\n-     * @return List of random tables from schema (perhaps with duplicates).\n+     * @param rndQryCtx Context of randomised query.\n+     * @return Ast representing SELECT expression.\n      */\n-    private List<TableRef> rndTables(Schema schema) {\n-        int tblCnt = 1;\n+    private Select rndSelect(RandomisedQueryContext rndQryCtx) {\n+        return dice.roll() <= 3\n+            ? rndSingleTableSelect(rndQryCtx)\n+            : rndMultiTableSelect(rndQryCtx);\n+    }\n \n-        for (int i = 0; i < 3; i++) {\n-            if (rndWithRatio(2))\n-                tblCnt++;\n-        }\n+    /**\n+     * Generates random SELECT expression from several tables.\n+     *\n+     * @param rndQryCtx Context of randomised query.\n+     * @return Ast representing SELECT expression.\n+     */\n+    private Select rndMultiTableSelect(RandomisedQueryContext rndQryCtx) {\n+        pickRndTables(rndQryCtx, 2 + rnd.nextInt(3), true);\n \n-        List<Table> tbls = new ArrayList<>(schema.tables());\n+        assert rndQryCtx.scopeTables().size() > 1;\n \n-        tbls.addAll(schema.tables()); // add all tables again to get duplicates\n+        Ast from;\n+        Ast where = null;\n \n-        Collections.shuffle(tbls, rnd);\n+        boolean tblList = dice.roll() <= 3;\n+        from = tblList ? new TableList(rndQryCtx.scopeTables()) : rndQryCtx.scopeTables().get(0);\n \n-        List<TableRef> res = new ArrayList<>(tblCnt);\n+        List<TableRef> connScope = new ArrayList<>(rndQryCtx.scopeTables().size());\n \n-        for (Table tbl : tbls.subList(0, tblCnt)) {\n-            String alias = String.valueOf(tbl.name().toLowerCase().charAt(0)) + aliasIdGen.incrementAndGet();\n+        // scope of tables that should be connected to each other\n+        connScope.add(rndQryCtx.scopeTables().get(0));\n \n-            res.add(new TableRef(tbl, alias));\n+        for (int i = 1; i < rndQryCtx.scopeTables().size(); i++) {\n+            TableRef anotherTbl = rndQryCtx.scopeTables().get(i);\n+\n+            Ast cond = new BiCondition(\n+                pickRndItem(pickRndItem(connScope).cols(), NUMERICAL_COLUMN_FILTER),\n+                pickRndItem(anotherTbl.cols(), NUMERICAL_COLUMN_FILTER),\n+                Operator.EQUALS\n+            );\n+\n+            connScope.add(anotherTbl); // add a table to the connection scope AFTER we created the condition\n+\n+            if (tblList)\n+                where = where != null ? new BiCondition(where, cond, Operator.AND) : cond;\n+            else\n+                from = new InnerJoin(from, anotherTbl, cond);\n         }\n \n-        return res;\n+        if (!tblList)\n+            where = new Const(\"TRUE\");\n+\n+        return new Select(rndColList(rndQryCtx))\n+            .from(from)\n+            .where(new BiCondition(where, rndQueryFilter(rndQryCtx), Operator.AND));\n     }\n \n     /**\n-     * Generates random WHERE expression for provided tables.\n+     * Generates random column list.\n      *\n      * @param rndQryCtx Context of randomised query.\n-     * @return Ast representing WHERE expression.\n+     * @return Ast representing column list.\n      */\n-    private Ast rndWhereClause(RandomisedQueryContext rndQryCtx) {\n-        List<TableRef> tbls = rndQryCtx.scopeTables();\n-\n-        assert !tbls.isEmpty();\n-\n-        List<TableRef> tbls0 = new ArrayList<>(tbls);\n-\n-        Ast cond;\n-\n-        if (rndWithRatio(4))\n-            cond = new Const(\"TRUE\");\n-        else {\n-            TableRef tbl = tbls0.get(rnd.nextInt(tbls0.size()));\n+    private Ast[] rndColList(RandomisedQueryContext rndQryCtx) {\n+        Ast[] cols = EMPTY_AST_ARR;\n \n-            Ast rightOp;\n-            if (rndWithRatio(5))\n-                rightOp = new Const(Integer.toString(rnd.nextInt(100)));\n-            else {\n-                rightOp = new Const(\"?\");\n+        if (dice.roll() == 1)\n+            return cols; // select * from...\n \n-                rndQryCtx.addQueryParam(rnd.nextInt(100));\n-            }\n+        List<ColumnRef> cols0 = new ArrayList<>();\n \n-            cond = new BiCondition(\n-                rndNumericColumn(tbl),\n-                rightOp,\n-                Operator.EQUALS\n-            );\n-        }\n+        rndQryCtx.scopeTables().forEach(t -> cols0.addAll(t.cols()));\n \n-        // all tables connected one by one with an AND expression\n-        while (tbls0.size() >= 2) {\n-            TableRef left = tbls0.remove(0);\n-            TableRef right = tbls0.get(0);\n+        Collections.shuffle(cols0, rnd);\n \n-            cond = new BiCondition(\n-                cond,\n-                new BiCondition(rndNumericColumn(left), rndNumericColumn(right), Operator.EQUALS),\n-                Operator.AND\n-            );\n-        }\n+        cols = cols0.subList(0, 1 + rnd.nextInt(2)).toArray(cols);\n \n-        return cond;\n+        return cols;\n     }\n \n     /**\n-     * Generates random SELECT expression.\n+     * Generates random SELECT expression from single tables.\n      *\n      * @param rndQryCtx Context of randomised query.\n      * @return Ast representing SELECT expression.\n      */\n-    private Select rndSelect(RandomisedQueryContext rndQryCtx) {\n-        Ast from = rndFrom(rndQryCtx);\n-        Ast where = from instanceof TableList ? rndWhereClause(rndQryCtx) : new Const(\"TRUE\");\n+    private Select rndSingleTableSelect(RandomisedQueryContext rndQryCtx) {\n+        pickRndTables(rndQryCtx, 1);\n \n-        return new Select().from(from).where(where);\n+        assert rndQryCtx.scopeTables().size() == 1;\n+\n+        return new Select(rndColList(rndQryCtx))\n+            .from(new TableList(rndQryCtx.scopeTables()))\n+            .where(rndQueryFilter(rndQryCtx));\n     }\n \n     /**\n-     * Generates random FROM expression.\n+     * Generates random query filter.\n      *\n      * @param rndQryCtx Context of randomised query.\n-     * @return Ast representing FROM expression.\n+     * @return Ast representing query filter.\n      */\n-    private Ast rndFrom(RandomisedQueryContext rndQryCtx) {\n-        List<TableRef> tbls = rndTables(rndQryCtx.schema());\n+    private Ast rndQueryFilter(RandomisedQueryContext rndQryCtx) {\n+        List<TableRef> scopeTbls = rndQryCtx.scopeTables();\n+\n+        Ast cond1 = rndTableFilter(rndQryCtx, scopeTbls.get(rnd.nextInt(scopeTbls.size())));\n \n-        assert !F.isEmpty(tbls);\n+        if (dice.roll() <= 2)\n+            return cond1;\n \n-        if (tbls.size() == 1 || rndWithRatio(5)) {\n-            tbls.forEach(rndQryCtx::addScopeTable);\n+        Ast cond2 = rndTableFilter(rndQryCtx, scopeTbls.get(rnd.nextInt(scopeTbls.size())));\n \n-            return new TableList(tbls);\n+        return new BiCondition(cond1, cond2, dice.roll() <= 2 ? Operator.AND : Operator.OR);\n+    }\n+\n+    /**\n+     * Generates random filter for specified table.\n+     *\n+     * @param rndQryCtx Context of randomised query.\n+     * @param tbl Table that requires filter.\n+     * @return Ast representing table filter.\n+     */\n+    private Ast rndTableFilter(RandomisedQueryContext rndQryCtx, TableRef tbl) {\n+        Ast rigthOp;\n+        if (dice.roll() == 1)\n+            rigthOp = new Const(Integer.toString(rnd.nextInt(100)));\n+        else {\n+            rigthOp = new Const(\"?\");\n+\n+            rndQryCtx.addQueryParam(rnd.nextInt(100));\n         }\n \n-        TableRef leftTbl = tbls.get(0);\n+        return new BiCondition(\n+            rndNumericColumn(tbl),\n+            rigthOp,\n+            Operator.EQUALS\n+        );\n+    }\n \n-        Ast from = leftTbl;\n+    /**\n+     * Picks N random table from the schema and adds them to the scope.\n+     *\n+     * @param rndQryCtx Random query context.\n+     * @param tblCnt Tables count.\n+     */\n+    private void pickRndTables(RandomisedQueryContext rndQryCtx, int tblCnt) {\n+        pickRndTables(rndQryCtx, tblCnt, false);\n+    }\n \n-        rndQryCtx.addScopeTable(leftTbl);\n+    /**\n+     * Picks N random table from the schema and adds them to the scope.\n+     *\n+     * @param rndQryCtx Random query context.\n+     * @param tblCnt Tables count.\n+     * @param allowDublicates Whether to allow dublicates or not.\n+     */\n+    private void pickRndTables(RandomisedQueryContext rndQryCtx, int tblCnt, boolean allowDublicates) {\n+        List<Table> tbls = new ArrayList<>(schema.tables());\n \n-        for (int i = 1; i < tbls.size(); i++) {\n-            TableRef rightTbl = tbls.get(i);\n+        if (allowDublicates)\n+            tbls.addAll(schema.tables()); // add all tables again to get duplicates\n \n-            from = new InnerJoin(from, rightTbl,\n-                new BiCondition(rndNumericColumn(rndScopeTable(rndQryCtx)), rndNumericColumn(rightTbl), Operator.EQUALS));\n+        Collections.shuffle(tbls, rnd);\n \n-            rndQryCtx.addScopeTable(rightTbl); // add a table to the scope AFTER we created the join condition\n-        }\n+        for (Table tbl : tbls.subList(0, tblCnt)) {", "originalCommit": "d5cfb643b31af7726d3eee48b6d9a1ef5bc2878b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM2ODI4Mw==", "url": "https://github.com/gridgain/gridgain/pull/1386#discussion_r477368283", "bodyText": "yes, we can. So I've add handling for this case, thx", "author": "korlov42", "createdAt": "2020-08-26T14:58:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI5ODA3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI5OTkxMg==", "url": "https://github.com/gridgain/gridgain/pull/1386#discussion_r477299912", "bodyText": "meet specified condition?", "author": "Berkof", "createdAt": "2020-08-26T13:28:37Z", "path": "modules/compatibility/src/test/java/org/apache/ignite/compatibility/sql/randomsql/RandomQuerySupplier.java", "diffHunk": "@@ -80,151 +92,211 @@ public RandomQuerySupplier(Schema schema, int seed) {\n     }\n \n     /**\n-     * Pick up to 4 random tables from provided schema. Some tables in\n-     * result list may appear twice.\n+     * Generates random SELECT expression.\n      *\n-     * @param schema Schema.\n-     * @return List of random tables from schema (perhaps with duplicates).\n+     * @param rndQryCtx Context of randomised query.\n+     * @return Ast representing SELECT expression.\n      */\n-    private List<TableRef> rndTables(Schema schema) {\n-        int tblCnt = 1;\n+    private Select rndSelect(RandomisedQueryContext rndQryCtx) {\n+        return dice.roll() <= 3\n+            ? rndSingleTableSelect(rndQryCtx)\n+            : rndMultiTableSelect(rndQryCtx);\n+    }\n \n-        for (int i = 0; i < 3; i++) {\n-            if (rndWithRatio(2))\n-                tblCnt++;\n-        }\n+    /**\n+     * Generates random SELECT expression from several tables.\n+     *\n+     * @param rndQryCtx Context of randomised query.\n+     * @return Ast representing SELECT expression.\n+     */\n+    private Select rndMultiTableSelect(RandomisedQueryContext rndQryCtx) {\n+        pickRndTables(rndQryCtx, 2 + rnd.nextInt(3), true);\n \n-        List<Table> tbls = new ArrayList<>(schema.tables());\n+        assert rndQryCtx.scopeTables().size() > 1;\n \n-        tbls.addAll(schema.tables()); // add all tables again to get duplicates\n+        Ast from;\n+        Ast where = null;\n \n-        Collections.shuffle(tbls, rnd);\n+        boolean tblList = dice.roll() <= 3;\n+        from = tblList ? new TableList(rndQryCtx.scopeTables()) : rndQryCtx.scopeTables().get(0);\n \n-        List<TableRef> res = new ArrayList<>(tblCnt);\n+        List<TableRef> connScope = new ArrayList<>(rndQryCtx.scopeTables().size());\n \n-        for (Table tbl : tbls.subList(0, tblCnt)) {\n-            String alias = String.valueOf(tbl.name().toLowerCase().charAt(0)) + aliasIdGen.incrementAndGet();\n+        // scope of tables that should be connected to each other\n+        connScope.add(rndQryCtx.scopeTables().get(0));\n \n-            res.add(new TableRef(tbl, alias));\n+        for (int i = 1; i < rndQryCtx.scopeTables().size(); i++) {\n+            TableRef anotherTbl = rndQryCtx.scopeTables().get(i);\n+\n+            Ast cond = new BiCondition(\n+                pickRndItem(pickRndItem(connScope).cols(), NUMERICAL_COLUMN_FILTER),\n+                pickRndItem(anotherTbl.cols(), NUMERICAL_COLUMN_FILTER),\n+                Operator.EQUALS\n+            );\n+\n+            connScope.add(anotherTbl); // add a table to the connection scope AFTER we created the condition\n+\n+            if (tblList)\n+                where = where != null ? new BiCondition(where, cond, Operator.AND) : cond;\n+            else\n+                from = new InnerJoin(from, anotherTbl, cond);\n         }\n \n-        return res;\n+        if (!tblList)\n+            where = new Const(\"TRUE\");\n+\n+        return new Select(rndColList(rndQryCtx))\n+            .from(from)\n+            .where(new BiCondition(where, rndQueryFilter(rndQryCtx), Operator.AND));\n     }\n \n     /**\n-     * Generates random WHERE expression for provided tables.\n+     * Generates random column list.\n      *\n      * @param rndQryCtx Context of randomised query.\n-     * @return Ast representing WHERE expression.\n+     * @return Ast representing column list.\n      */\n-    private Ast rndWhereClause(RandomisedQueryContext rndQryCtx) {\n-        List<TableRef> tbls = rndQryCtx.scopeTables();\n-\n-        assert !tbls.isEmpty();\n-\n-        List<TableRef> tbls0 = new ArrayList<>(tbls);\n-\n-        Ast cond;\n-\n-        if (rndWithRatio(4))\n-            cond = new Const(\"TRUE\");\n-        else {\n-            TableRef tbl = tbls0.get(rnd.nextInt(tbls0.size()));\n+    private Ast[] rndColList(RandomisedQueryContext rndQryCtx) {\n+        Ast[] cols = EMPTY_AST_ARR;\n \n-            Ast rightOp;\n-            if (rndWithRatio(5))\n-                rightOp = new Const(Integer.toString(rnd.nextInt(100)));\n-            else {\n-                rightOp = new Const(\"?\");\n+        if (dice.roll() == 1)\n+            return cols; // select * from...\n \n-                rndQryCtx.addQueryParam(rnd.nextInt(100));\n-            }\n+        List<ColumnRef> cols0 = new ArrayList<>();\n \n-            cond = new BiCondition(\n-                rndNumericColumn(tbl),\n-                rightOp,\n-                Operator.EQUALS\n-            );\n-        }\n+        rndQryCtx.scopeTables().forEach(t -> cols0.addAll(t.cols()));\n \n-        // all tables connected one by one with an AND expression\n-        while (tbls0.size() >= 2) {\n-            TableRef left = tbls0.remove(0);\n-            TableRef right = tbls0.get(0);\n+        Collections.shuffle(cols0, rnd);\n \n-            cond = new BiCondition(\n-                cond,\n-                new BiCondition(rndNumericColumn(left), rndNumericColumn(right), Operator.EQUALS),\n-                Operator.AND\n-            );\n-        }\n+        cols = cols0.subList(0, 1 + rnd.nextInt(2)).toArray(cols);\n \n-        return cond;\n+        return cols;\n     }\n \n     /**\n-     * Generates random SELECT expression.\n+     * Generates random SELECT expression from single tables.\n      *\n      * @param rndQryCtx Context of randomised query.\n      * @return Ast representing SELECT expression.\n      */\n-    private Select rndSelect(RandomisedQueryContext rndQryCtx) {\n-        Ast from = rndFrom(rndQryCtx);\n-        Ast where = from instanceof TableList ? rndWhereClause(rndQryCtx) : new Const(\"TRUE\");\n+    private Select rndSingleTableSelect(RandomisedQueryContext rndQryCtx) {\n+        pickRndTables(rndQryCtx, 1);\n \n-        return new Select().from(from).where(where);\n+        assert rndQryCtx.scopeTables().size() == 1;\n+\n+        return new Select(rndColList(rndQryCtx))\n+            .from(new TableList(rndQryCtx.scopeTables()))\n+            .where(rndQueryFilter(rndQryCtx));\n     }\n \n     /**\n-     * Generates random FROM expression.\n+     * Generates random query filter.\n      *\n      * @param rndQryCtx Context of randomised query.\n-     * @return Ast representing FROM expression.\n+     * @return Ast representing query filter.\n      */\n-    private Ast rndFrom(RandomisedQueryContext rndQryCtx) {\n-        List<TableRef> tbls = rndTables(rndQryCtx.schema());\n+    private Ast rndQueryFilter(RandomisedQueryContext rndQryCtx) {\n+        List<TableRef> scopeTbls = rndQryCtx.scopeTables();\n+\n+        Ast cond1 = rndTableFilter(rndQryCtx, scopeTbls.get(rnd.nextInt(scopeTbls.size())));\n \n-        assert !F.isEmpty(tbls);\n+        if (dice.roll() <= 2)\n+            return cond1;\n \n-        if (tbls.size() == 1 || rndWithRatio(5)) {\n-            tbls.forEach(rndQryCtx::addScopeTable);\n+        Ast cond2 = rndTableFilter(rndQryCtx, scopeTbls.get(rnd.nextInt(scopeTbls.size())));\n \n-            return new TableList(tbls);\n+        return new BiCondition(cond1, cond2, dice.roll() <= 2 ? Operator.AND : Operator.OR);\n+    }\n+\n+    /**\n+     * Generates random filter for specified table.\n+     *\n+     * @param rndQryCtx Context of randomised query.\n+     * @param tbl Table that requires filter.\n+     * @return Ast representing table filter.\n+     */\n+    private Ast rndTableFilter(RandomisedQueryContext rndQryCtx, TableRef tbl) {\n+        Ast rigthOp;\n+        if (dice.roll() == 1)\n+            rigthOp = new Const(Integer.toString(rnd.nextInt(100)));\n+        else {\n+            rigthOp = new Const(\"?\");\n+\n+            rndQryCtx.addQueryParam(rnd.nextInt(100));\n         }\n \n-        TableRef leftTbl = tbls.get(0);\n+        return new BiCondition(\n+            rndNumericColumn(tbl),\n+            rigthOp,\n+            Operator.EQUALS\n+        );\n+    }\n \n-        Ast from = leftTbl;\n+    /**\n+     * Picks N random table from the schema and adds them to the scope.\n+     *\n+     * @param rndQryCtx Random query context.\n+     * @param tblCnt Tables count.\n+     */\n+    private void pickRndTables(RandomisedQueryContext rndQryCtx, int tblCnt) {\n+        pickRndTables(rndQryCtx, tblCnt, false);\n+    }\n \n-        rndQryCtx.addScopeTable(leftTbl);\n+    /**\n+     * Picks N random table from the schema and adds them to the scope.\n+     *\n+     * @param rndQryCtx Random query context.\n+     * @param tblCnt Tables count.\n+     * @param allowDublicates Whether to allow dublicates or not.\n+     */\n+    private void pickRndTables(RandomisedQueryContext rndQryCtx, int tblCnt, boolean allowDublicates) {\n+        List<Table> tbls = new ArrayList<>(schema.tables());\n \n-        for (int i = 1; i < tbls.size(); i++) {\n-            TableRef rightTbl = tbls.get(i);\n+        if (allowDublicates)\n+            tbls.addAll(schema.tables()); // add all tables again to get duplicates\n \n-            from = new InnerJoin(from, rightTbl,\n-                new BiCondition(rndNumericColumn(rndScopeTable(rndQryCtx)), rndNumericColumn(rightTbl), Operator.EQUALS));\n+        Collections.shuffle(tbls, rnd);\n \n-            rndQryCtx.addScopeTable(rightTbl); // add a table to the scope AFTER we created the join condition\n-        }\n+        for (Table tbl : tbls.subList(0, tblCnt)) {\n+            String alias = String.valueOf(tbl.name().toLowerCase().charAt(0)) + aliasIdGen.incrementAndGet();\n \n-        return from;\n+            rndQryCtx.addScopeTable(new TableRef(tbl, alias));\n+        }\n     }\n \n     /**\n-     * Returns random table which was used in FROM expression.\n+     * Picks random item from provided collection that met specified condition.", "originalCommit": "d5cfb643b31af7726d3eee48b6d9a1ef5bc2878b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI1OTY3MQ==", "url": "https://github.com/gridgain/gridgain/pull/1386#discussion_r478259671", "bodyText": "yes, of course", "author": "korlov42", "createdAt": "2020-08-27T08:49:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI5OTkxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzMxMjAwOA==", "url": "https://github.com/gridgain/gridgain/pull/1386#discussion_r477312008", "bodyText": "Why we use local schema instead of rndQryCtx.schema? And why we need same schema in RandomisedQueryContext if we never use it?\nIt hard to track which schema is preferable in different situations and I hope we can remove one or comment the difference.", "author": "Berkof", "createdAt": "2020-08-26T13:45:14Z", "path": "modules/compatibility/src/test/java/org/apache/ignite/compatibility/sql/randomsql/RandomQuerySupplier.java", "diffHunk": "@@ -80,151 +92,211 @@ public RandomQuerySupplier(Schema schema, int seed) {\n     }\n \n     /**\n-     * Pick up to 4 random tables from provided schema. Some tables in\n-     * result list may appear twice.\n+     * Generates random SELECT expression.\n      *\n-     * @param schema Schema.\n-     * @return List of random tables from schema (perhaps with duplicates).\n+     * @param rndQryCtx Context of randomised query.\n+     * @return Ast representing SELECT expression.\n      */\n-    private List<TableRef> rndTables(Schema schema) {\n-        int tblCnt = 1;\n+    private Select rndSelect(RandomisedQueryContext rndQryCtx) {\n+        return dice.roll() <= 3\n+            ? rndSingleTableSelect(rndQryCtx)\n+            : rndMultiTableSelect(rndQryCtx);\n+    }\n \n-        for (int i = 0; i < 3; i++) {\n-            if (rndWithRatio(2))\n-                tblCnt++;\n-        }\n+    /**\n+     * Generates random SELECT expression from several tables.\n+     *\n+     * @param rndQryCtx Context of randomised query.\n+     * @return Ast representing SELECT expression.\n+     */\n+    private Select rndMultiTableSelect(RandomisedQueryContext rndQryCtx) {\n+        pickRndTables(rndQryCtx, 2 + rnd.nextInt(3), true);\n \n-        List<Table> tbls = new ArrayList<>(schema.tables());\n+        assert rndQryCtx.scopeTables().size() > 1;\n \n-        tbls.addAll(schema.tables()); // add all tables again to get duplicates\n+        Ast from;\n+        Ast where = null;\n \n-        Collections.shuffle(tbls, rnd);\n+        boolean tblList = dice.roll() <= 3;\n+        from = tblList ? new TableList(rndQryCtx.scopeTables()) : rndQryCtx.scopeTables().get(0);\n \n-        List<TableRef> res = new ArrayList<>(tblCnt);\n+        List<TableRef> connScope = new ArrayList<>(rndQryCtx.scopeTables().size());\n \n-        for (Table tbl : tbls.subList(0, tblCnt)) {\n-            String alias = String.valueOf(tbl.name().toLowerCase().charAt(0)) + aliasIdGen.incrementAndGet();\n+        // scope of tables that should be connected to each other\n+        connScope.add(rndQryCtx.scopeTables().get(0));\n \n-            res.add(new TableRef(tbl, alias));\n+        for (int i = 1; i < rndQryCtx.scopeTables().size(); i++) {\n+            TableRef anotherTbl = rndQryCtx.scopeTables().get(i);\n+\n+            Ast cond = new BiCondition(\n+                pickRndItem(pickRndItem(connScope).cols(), NUMERICAL_COLUMN_FILTER),\n+                pickRndItem(anotherTbl.cols(), NUMERICAL_COLUMN_FILTER),\n+                Operator.EQUALS\n+            );\n+\n+            connScope.add(anotherTbl); // add a table to the connection scope AFTER we created the condition\n+\n+            if (tblList)\n+                where = where != null ? new BiCondition(where, cond, Operator.AND) : cond;\n+            else\n+                from = new InnerJoin(from, anotherTbl, cond);\n         }\n \n-        return res;\n+        if (!tblList)\n+            where = new Const(\"TRUE\");\n+\n+        return new Select(rndColList(rndQryCtx))\n+            .from(from)\n+            .where(new BiCondition(where, rndQueryFilter(rndQryCtx), Operator.AND));\n     }\n \n     /**\n-     * Generates random WHERE expression for provided tables.\n+     * Generates random column list.\n      *\n      * @param rndQryCtx Context of randomised query.\n-     * @return Ast representing WHERE expression.\n+     * @return Ast representing column list.\n      */\n-    private Ast rndWhereClause(RandomisedQueryContext rndQryCtx) {\n-        List<TableRef> tbls = rndQryCtx.scopeTables();\n-\n-        assert !tbls.isEmpty();\n-\n-        List<TableRef> tbls0 = new ArrayList<>(tbls);\n-\n-        Ast cond;\n-\n-        if (rndWithRatio(4))\n-            cond = new Const(\"TRUE\");\n-        else {\n-            TableRef tbl = tbls0.get(rnd.nextInt(tbls0.size()));\n+    private Ast[] rndColList(RandomisedQueryContext rndQryCtx) {\n+        Ast[] cols = EMPTY_AST_ARR;\n \n-            Ast rightOp;\n-            if (rndWithRatio(5))\n-                rightOp = new Const(Integer.toString(rnd.nextInt(100)));\n-            else {\n-                rightOp = new Const(\"?\");\n+        if (dice.roll() == 1)\n+            return cols; // select * from...\n \n-                rndQryCtx.addQueryParam(rnd.nextInt(100));\n-            }\n+        List<ColumnRef> cols0 = new ArrayList<>();\n \n-            cond = new BiCondition(\n-                rndNumericColumn(tbl),\n-                rightOp,\n-                Operator.EQUALS\n-            );\n-        }\n+        rndQryCtx.scopeTables().forEach(t -> cols0.addAll(t.cols()));\n \n-        // all tables connected one by one with an AND expression\n-        while (tbls0.size() >= 2) {\n-            TableRef left = tbls0.remove(0);\n-            TableRef right = tbls0.get(0);\n+        Collections.shuffle(cols0, rnd);\n \n-            cond = new BiCondition(\n-                cond,\n-                new BiCondition(rndNumericColumn(left), rndNumericColumn(right), Operator.EQUALS),\n-                Operator.AND\n-            );\n-        }\n+        cols = cols0.subList(0, 1 + rnd.nextInt(2)).toArray(cols);\n \n-        return cond;\n+        return cols;\n     }\n \n     /**\n-     * Generates random SELECT expression.\n+     * Generates random SELECT expression from single tables.\n      *\n      * @param rndQryCtx Context of randomised query.\n      * @return Ast representing SELECT expression.\n      */\n-    private Select rndSelect(RandomisedQueryContext rndQryCtx) {\n-        Ast from = rndFrom(rndQryCtx);\n-        Ast where = from instanceof TableList ? rndWhereClause(rndQryCtx) : new Const(\"TRUE\");\n+    private Select rndSingleTableSelect(RandomisedQueryContext rndQryCtx) {\n+        pickRndTables(rndQryCtx, 1);\n \n-        return new Select().from(from).where(where);\n+        assert rndQryCtx.scopeTables().size() == 1;\n+\n+        return new Select(rndColList(rndQryCtx))\n+            .from(new TableList(rndQryCtx.scopeTables()))\n+            .where(rndQueryFilter(rndQryCtx));\n     }\n \n     /**\n-     * Generates random FROM expression.\n+     * Generates random query filter.\n      *\n      * @param rndQryCtx Context of randomised query.\n-     * @return Ast representing FROM expression.\n+     * @return Ast representing query filter.\n      */\n-    private Ast rndFrom(RandomisedQueryContext rndQryCtx) {\n-        List<TableRef> tbls = rndTables(rndQryCtx.schema());\n+    private Ast rndQueryFilter(RandomisedQueryContext rndQryCtx) {\n+        List<TableRef> scopeTbls = rndQryCtx.scopeTables();\n+\n+        Ast cond1 = rndTableFilter(rndQryCtx, scopeTbls.get(rnd.nextInt(scopeTbls.size())));\n \n-        assert !F.isEmpty(tbls);\n+        if (dice.roll() <= 2)\n+            return cond1;\n \n-        if (tbls.size() == 1 || rndWithRatio(5)) {\n-            tbls.forEach(rndQryCtx::addScopeTable);\n+        Ast cond2 = rndTableFilter(rndQryCtx, scopeTbls.get(rnd.nextInt(scopeTbls.size())));\n \n-            return new TableList(tbls);\n+        return new BiCondition(cond1, cond2, dice.roll() <= 2 ? Operator.AND : Operator.OR);\n+    }\n+\n+    /**\n+     * Generates random filter for specified table.\n+     *\n+     * @param rndQryCtx Context of randomised query.\n+     * @param tbl Table that requires filter.\n+     * @return Ast representing table filter.\n+     */\n+    private Ast rndTableFilter(RandomisedQueryContext rndQryCtx, TableRef tbl) {\n+        Ast rigthOp;\n+        if (dice.roll() == 1)\n+            rigthOp = new Const(Integer.toString(rnd.nextInt(100)));\n+        else {\n+            rigthOp = new Const(\"?\");\n+\n+            rndQryCtx.addQueryParam(rnd.nextInt(100));\n         }\n \n-        TableRef leftTbl = tbls.get(0);\n+        return new BiCondition(\n+            rndNumericColumn(tbl),\n+            rigthOp,\n+            Operator.EQUALS\n+        );\n+    }\n \n-        Ast from = leftTbl;\n+    /**\n+     * Picks N random table from the schema and adds them to the scope.\n+     *\n+     * @param rndQryCtx Random query context.\n+     * @param tblCnt Tables count.\n+     */\n+    private void pickRndTables(RandomisedQueryContext rndQryCtx, int tblCnt) {\n+        pickRndTables(rndQryCtx, tblCnt, false);\n+    }\n \n-        rndQryCtx.addScopeTable(leftTbl);\n+    /**\n+     * Picks N random table from the schema and adds them to the scope.\n+     *\n+     * @param rndQryCtx Random query context.\n+     * @param tblCnt Tables count.\n+     * @param allowDublicates Whether to allow dublicates or not.\n+     */\n+    private void pickRndTables(RandomisedQueryContext rndQryCtx, int tblCnt, boolean allowDublicates) {\n+        List<Table> tbls = new ArrayList<>(schema.tables());", "originalCommit": "d5cfb643b31af7726d3eee48b6d9a1ef5bc2878b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM3MTQxMg==", "url": "https://github.com/gridgain/gridgain/pull/1386#discussion_r477371412", "bodyText": "schema should be part of RandomQuerySupplier only. So I've remove obsolete field inside RandomisedQueryContext", "author": "korlov42", "createdAt": "2020-08-26T15:02:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzMxMjAwOA=="}], "type": "inlineReview"}, {"oid": "e1245d67a12afed11a5385d243539fc5b34d5db2", "url": "https://github.com/gridgain/gridgain/commit/e1245d67a12afed11a5385d243539fc5b34d5db2", "message": "fixes after review + additional tests", "committedDate": "2020-08-27T08:47:46Z", "type": "commit"}, {"oid": "113a10f003dd493130d207a07103fa57f862792f", "url": "https://github.com/gridgain/gridgain/commit/113a10f003dd493130d207a07103fa57f862792f", "message": "misspell", "committedDate": "2020-08-27T08:49:25Z", "type": "commit"}, {"oid": "48802cebb0843d3082ecda04ea3d9bfbe0bb3f8a", "url": "https://github.com/gridgain/gridgain/commit/48802cebb0843d3082ecda04ea3d9bfbe0bb3f8a", "message": "unused imports", "committedDate": "2020-08-27T09:09:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzMxNTA4Nw==", "url": "https://github.com/gridgain/gridgain/pull/1386#discussion_r477315087", "bodyText": "magic numbers", "author": "Berkof", "createdAt": "2020-08-26T13:49:11Z", "path": "modules/compatibility/src/test/java/org/apache/ignite/compatibility/sql/randomsql/RandomQuerySupplier.java", "diffHunk": "@@ -80,151 +92,211 @@ public RandomQuerySupplier(Schema schema, int seed) {\n     }\n \n     /**\n-     * Pick up to 4 random tables from provided schema. Some tables in\n-     * result list may appear twice.\n+     * Generates random SELECT expression.\n      *\n-     * @param schema Schema.\n-     * @return List of random tables from schema (perhaps with duplicates).\n+     * @param rndQryCtx Context of randomised query.\n+     * @return Ast representing SELECT expression.\n      */\n-    private List<TableRef> rndTables(Schema schema) {\n-        int tblCnt = 1;\n+    private Select rndSelect(RandomisedQueryContext rndQryCtx) {\n+        return dice.roll() <= 3\n+            ? rndSingleTableSelect(rndQryCtx)\n+            : rndMultiTableSelect(rndQryCtx);\n+    }\n \n-        for (int i = 0; i < 3; i++) {\n-            if (rndWithRatio(2))\n-                tblCnt++;\n-        }\n+    /**\n+     * Generates random SELECT expression from several tables.\n+     *\n+     * @param rndQryCtx Context of randomised query.\n+     * @return Ast representing SELECT expression.\n+     */\n+    private Select rndMultiTableSelect(RandomisedQueryContext rndQryCtx) {\n+        pickRndTables(rndQryCtx, 2 + rnd.nextInt(3), true);", "originalCommit": "d5cfb643b31af7726d3eee48b6d9a1ef5bc2878b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM0ODExMA==", "url": "https://github.com/gridgain/gridgain/pull/1386#discussion_r478348110", "bodyText": "I added a comment to shed a light on these numbers", "author": "korlov42", "createdAt": "2020-08-27T11:32:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzMxNTA4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI4MzAwMQ==", "url": "https://github.com/gridgain/gridgain/pull/1386#discussion_r478283001", "bodyText": "Lead to unexpected behaviour when called with nulls, for example assertThat(5, inRange(null, 10) should return True (for me)... Can we check arguments here or annotate its with @NotNull  ?", "author": "Berkof", "createdAt": "2020-08-27T09:29:01Z", "path": "modules/core/src/test/java/org/apache/ignite/testframework/GridTestUtils.java", "diffHunk": "@@ -2587,6 +2589,20 @@ public static long sleep_and_can_fail() {\n         }\n     }\n \n+    /**\n+     * @param lowerBound Lower bound.\n+     * @param upperBound Upper bound.\n+     */\n+    public static <T extends Comparable<? super T>> Matcher<T> inRange(T lowerBound, T upperBound) {\n+        return new CustomMatcher<T>(\"should be in range [\" + lowerBound + \", \" + upperBound + \"]\") {\n+            @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+            @Override public boolean matches(Object item) {\n+                return lowerBound != null && upperBound != null && item instanceof Comparable", "originalCommit": "48802cebb0843d3082ecda04ea3d9bfbe0bb3f8a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM0ODQ2Ng==", "url": "https://github.com/gridgain/gridgain/pull/1386#discussion_r478348466", "bodyText": "Added not null check. BTW we don't use @NotNull annotation in the project", "author": "korlov42", "createdAt": "2020-08-27T11:33:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI4MzAwMQ=="}], "type": "inlineReview"}, {"oid": "273a2f7b835dd1090ba6879447236d4e174ff516", "url": "https://github.com/gridgain/gridgain/commit/273a2f7b835dd1090ba6879447236d4e174ff516", "message": "minors", "committedDate": "2020-08-27T11:15:51Z", "type": "commit"}]}