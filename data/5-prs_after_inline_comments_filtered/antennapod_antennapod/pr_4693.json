{"pr_number": 4693, "pr_title": "Added new cleanup option: when not favorited", "pr_createdAt": "2020-11-16T10:33:39Z", "pr_url": "https://github.com/AntennaPod/AntennaPod/pull/4693", "timeline": [{"oid": "6fd3fa2e98a6bd0cdae01ab1b3919d9e8f4dd957", "url": "https://github.com/AntennaPod/AntennaPod/commit/6fd3fa2e98a6bd0cdae01ab1b3919d9e8f4dd957", "message": "Added new cleanup option: when not favorited\n\nThis is another way of solving #2077.\n\nThe root issue is that queued episodes are never auto-deleted\ncurrently which means that if you automatically add episodes to the\nqueue you will eventually end up with AntennaPod refusing to auto\ndownload more episodes because the cache is full and it can't make\nspace.\n\nThis option will only refuse to delete favorited items. Otherwise it\nwill simply delete the oldest episodes.", "committedDate": "2020-11-17T09:10:30Z", "type": "forcePushed"}, {"oid": "fd2d89de331caa6f831a6ad9220ed60be32562e0", "url": "https://github.com/AntennaPod/AntennaPod/commit/fd2d89de331caa6f831a6ad9220ed60be32562e0", "message": "Added new cleanup option: when not favorited\n\nThis is another way of solving #2077.\n\nThe root issue is that queued episodes are never auto-deleted\ncurrently which means that if you automatically add episodes to the\nqueue you will eventually end up with AntennaPod refusing to auto\ndownload more episodes because the cache is full and it can't make\nspace.\n\nThis option will only refuse to delete favorited items. Otherwise it\nwill simply delete the oldest episodes.", "committedDate": "2020-11-17T09:12:39Z", "type": "forcePushed"}, {"oid": "668cba7b57900e0e5b81703a760c395b9d005fd7", "url": "https://github.com/AntennaPod/AntennaPod/commit/668cba7b57900e0e5b81703a760c395b9d005fd7", "message": "Added new cleanup option: when not favorited\n\nThis is another way of solving #2077.\n\nThe root issue is that queued episodes are never auto-deleted\ncurrently which means that if you automatically add episodes to the\nqueue you will eventually end up with AntennaPod refusing to auto\ndownload more episodes because the cache is full and it can't make\nspace.\n\nThis option will only refuse to delete favorited items. Otherwise it\nwill simply delete the oldest episodes.", "committedDate": "2020-11-25T08:40:50Z", "type": "forcePushed"}, {"oid": "a57687080dbd9fb963ca72143ac4f5212e9261bb", "url": "https://github.com/AntennaPod/AntennaPod/commit/a57687080dbd9fb963ca72143ac4f5212e9261bb", "message": "Added new cleanup option: when not favorited\n\nThis is another way of solving #2077.\n\nThe root issue is that queued episodes are never auto-deleted\ncurrently which means that if you automatically add episodes to the\nqueue you will eventually end up with AntennaPod refusing to auto\ndownload more episodes because the cache is full and it can't make\nspace.\n\nThis option will only refuse to delete favorited items. Otherwise it\nwill simply delete the oldest episodes.", "committedDate": "2020-11-25T08:50:02Z", "type": "forcePushed"}, {"oid": "ec764a9ff7b6824ba2ac9a7d35fd050abdc6f9bb", "url": "https://github.com/AntennaPod/AntennaPod/commit/ec764a9ff7b6824ba2ac9a7d35fd050abdc6f9bb", "message": "Added new cleanup option: when not favorited\n\nThis is another way of solving #2077.\n\nThe root issue is that queued episodes are never auto-deleted\ncurrently which means that if you automatically add episodes to the\nqueue you will eventually end up with AntennaPod refusing to auto\ndownload more episodes because the cache is full and it can't make\nspace.\n\nThis option will only refuse to delete favorited items. Otherwise it\nwill simply delete the oldest episodes.", "committedDate": "2020-11-25T08:53:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU1NTA3NQ==", "url": "https://github.com/AntennaPod/AntennaPod/pull/4693#discussion_r570555075", "bodyText": "Could you please rebase the PR and migrate this to Roboelectric? See #4820 for details.", "author": "ByteHamster", "createdAt": "2021-02-04T21:27:52Z", "path": "app/src/androidTest/java/de/test/antennapod/storage/ExceptFavoriteCleanupAlgorithmTest.java", "diffHunk": "@@ -0,0 +1,91 @@\n+package de.test.antennapod.storage;\n+\n+import androidx.test.filters.SmallTest;\n+\n+import org.junit.Test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import de.danoeh.antennapod.core.feed.Feed;\n+import de.danoeh.antennapod.core.feed.FeedItem;\n+import de.danoeh.antennapod.core.preferences.UserPreferences;\n+import de.danoeh.antennapod.core.storage.DBTasks;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Tests that the APFavoriteCleanupAlgorithm is working correctly.\n+ */\n+@SmallTest", "originalCommit": "ec764a9ff7b6824ba2ac9a7d35fd050abdc6f9bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU1ODc3Mw==", "url": "https://github.com/AntennaPod/AntennaPod/pull/4693#discussion_r570558773", "bodyText": "I think this might lead to problems when both do not have a date and then some time passes during the algorithm. (something like Comparison method violates its general contract). So for consistency, I would just use the IDs as tie breaker.", "author": "ByteHamster", "createdAt": "2021-02-04T21:34:36Z", "path": "core/src/main/java/de/danoeh/antennapod/core/storage/ExceptFavoriteCleanupAlgorithm.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package de.danoeh.antennapod.core.storage;\n+\n+import android.content.Context;\n+import android.util.Log;\n+\n+import androidx.annotation.NonNull;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.ExecutionException;\n+\n+import de.danoeh.antennapod.core.feed.FeedItem;\n+\n+/**\n+ * A cleanup algorithm that removes any item that isn't a favorite but only if space is needed.\n+ */\n+public class ExceptFavoriteCleanupAlgorithm extends EpisodeCleanupAlgorithm {\n+\n+    private static final String TAG = \"ExceptFavCleanupAlgo\";\n+\n+    /**\n+     * The maximum number of episodes that could be cleaned up.\n+     *\n+     * @return the number of episodes that *could* be cleaned up, if needed\n+     */\n+    public int getReclaimableItems() {\n+        return getCandidates().size();\n+    }\n+\n+    @Override\n+    public int performCleanup(Context context, int numberOfEpisodesToDelete) {\n+        List<FeedItem> candidates = getCandidates();\n+        List<FeedItem> delete;\n+\n+        // in the absence of better data, we'll sort by item publication date\n+        Collections.sort(candidates, (lhs, rhs) -> {\n+            Date l = lhs.getPubDate();\n+            Date r = rhs.getPubDate();\n+\n+            if (l == null) {\n+                l = new Date();", "originalCommit": "ec764a9ff7b6824ba2ac9a7d35fd050abdc6f9bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "08edd151f9bc01873128fa97c948841b65b6455c", "url": "https://github.com/AntennaPod/AntennaPod/commit/08edd151f9bc01873128fa97c948841b65b6455c", "message": "Added new cleanup option: when not favorited\n\nThis is another way of solving #2077.\n\nThe root issue is that queued episodes are never auto-deleted\ncurrently which means that if you automatically add episodes to the\nqueue you will eventually end up with AntennaPod refusing to auto\ndownload more episodes because the cache is full and it can't make\nspace.\n\nThis option will only refuse to delete favorited items. Otherwise it\nwill simply delete the oldest episodes.", "committedDate": "2021-02-05T10:15:22Z", "type": "commit"}, {"oid": "08edd151f9bc01873128fa97c948841b65b6455c", "url": "https://github.com/AntennaPod/AntennaPod/commit/08edd151f9bc01873128fa97c948841b65b6455c", "message": "Added new cleanup option: when not favorited\n\nThis is another way of solving #2077.\n\nThe root issue is that queued episodes are never auto-deleted\ncurrently which means that if you automatically add episodes to the\nqueue you will eventually end up with AntennaPod refusing to auto\ndownload more episodes because the cache is full and it can't make\nspace.\n\nThis option will only refuse to delete favorited items. Otherwise it\nwill simply delete the oldest episodes.", "committedDate": "2021-02-05T10:15:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTAwMzk2NQ==", "url": "https://github.com/AntennaPod/AntennaPod/pull/4693#discussion_r571003965", "bodyText": "This is the same as writing return 0; here. I don't really understand what this is for, to be honest...\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return getNumEpisodesToCleanup(0);\n          \n          \n            \n                    return 0;", "author": "ByteHamster", "createdAt": "2021-02-05T14:27:27Z", "path": "core/src/main/java/de/danoeh/antennapod/core/storage/ExceptFavoriteCleanupAlgorithm.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package de.danoeh.antennapod.core.storage;\n+\n+import android.content.Context;\n+import android.util.Log;\n+\n+import androidx.annotation.NonNull;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.ExecutionException;\n+\n+import de.danoeh.antennapod.core.feed.FeedItem;\n+\n+/**\n+ * A cleanup algorithm that removes any item that isn't a favorite but only if space is needed.\n+ */\n+public class ExceptFavoriteCleanupAlgorithm extends EpisodeCleanupAlgorithm {\n+\n+    private static final String TAG = \"ExceptFavCleanupAlgo\";\n+\n+    /**\n+     * The maximum number of episodes that could be cleaned up.\n+     *\n+     * @return the number of episodes that *could* be cleaned up, if needed\n+     */\n+    public int getReclaimableItems() {\n+        return getCandidates().size();\n+    }\n+\n+    @Override\n+    public int performCleanup(Context context, int numberOfEpisodesToDelete) {\n+        List<FeedItem> candidates = getCandidates();\n+        List<FeedItem> delete;\n+\n+        // in the absence of better data, we'll sort by item publication date\n+        Collections.sort(candidates, (lhs, rhs) -> {\n+            Date l = lhs.getPubDate();\n+            Date r = rhs.getPubDate();\n+\n+            if (l != null && r != null) {\n+                return l.compareTo(r);\n+            } else {\n+                // No date - compare by id which should be always incremented\n+                return Long.compare(lhs.getId(), rhs.getId());\n+            }\n+        });\n+\n+        if (candidates.size() > numberOfEpisodesToDelete) {\n+            delete = candidates.subList(0, numberOfEpisodesToDelete);\n+        } else {\n+            delete = candidates;\n+        }\n+\n+        for (FeedItem item : delete) {\n+            try {\n+                DBWriter.deleteFeedMediaOfItem(context, item.getMedia().getId()).get();\n+            } catch (InterruptedException | ExecutionException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+\n+        int counter = delete.size();\n+\n+\n+        Log.i(TAG, String.format(Locale.US,\n+                \"Auto-delete deleted %d episodes (%d requested)\", counter,\n+                numberOfEpisodesToDelete));\n+\n+        return counter;\n+    }\n+\n+    @NonNull\n+    private List<FeedItem> getCandidates() {\n+        List<FeedItem> candidates = new ArrayList<>();\n+        List<FeedItem> downloadedItems = DBReader.getDownloadedItems();\n+        for (FeedItem item : downloadedItems) {\n+            if (item.hasMedia()\n+                    && item.getMedia().isDownloaded()\n+                    && !item.isTagged(FeedItem.TAG_FAVORITE)) {\n+                candidates.add(item);\n+            }\n+        }\n+        return candidates;\n+    }\n+\n+    @Override\n+    public int getDefaultCleanupParameter() {\n+        return getNumEpisodesToCleanup(0);", "originalCommit": "08edd151f9bc01873128fa97c948841b65b6455c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTAwNDYxOA==", "url": "https://github.com/AntennaPod/AntennaPod/pull/4693#discussion_r571004618", "bodyText": "Please remove the newlines\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    int counter = delete.size();\n          \n          \n            \n            \n          \n          \n            \n            \n          \n          \n            \n                    Log.i(TAG, String.format(Locale.US,\n          \n          \n            \n                    int counter = delete.size();\n          \n          \n            \n                    Log.i(TAG, String.format(Locale.US,", "author": "ByteHamster", "createdAt": "2021-02-05T14:28:15Z", "path": "core/src/main/java/de/danoeh/antennapod/core/storage/ExceptFavoriteCleanupAlgorithm.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package de.danoeh.antennapod.core.storage;\n+\n+import android.content.Context;\n+import android.util.Log;\n+\n+import androidx.annotation.NonNull;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.ExecutionException;\n+\n+import de.danoeh.antennapod.core.feed.FeedItem;\n+\n+/**\n+ * A cleanup algorithm that removes any item that isn't a favorite but only if space is needed.\n+ */\n+public class ExceptFavoriteCleanupAlgorithm extends EpisodeCleanupAlgorithm {\n+\n+    private static final String TAG = \"ExceptFavCleanupAlgo\";\n+\n+    /**\n+     * The maximum number of episodes that could be cleaned up.\n+     *\n+     * @return the number of episodes that *could* be cleaned up, if needed\n+     */\n+    public int getReclaimableItems() {\n+        return getCandidates().size();\n+    }\n+\n+    @Override\n+    public int performCleanup(Context context, int numberOfEpisodesToDelete) {\n+        List<FeedItem> candidates = getCandidates();\n+        List<FeedItem> delete;\n+\n+        // in the absence of better data, we'll sort by item publication date\n+        Collections.sort(candidates, (lhs, rhs) -> {\n+            Date l = lhs.getPubDate();\n+            Date r = rhs.getPubDate();\n+\n+            if (l != null && r != null) {\n+                return l.compareTo(r);\n+            } else {\n+                // No date - compare by id which should be always incremented\n+                return Long.compare(lhs.getId(), rhs.getId());\n+            }\n+        });\n+\n+        if (candidates.size() > numberOfEpisodesToDelete) {\n+            delete = candidates.subList(0, numberOfEpisodesToDelete);\n+        } else {\n+            delete = candidates;\n+        }\n+\n+        for (FeedItem item : delete) {\n+            try {\n+                DBWriter.deleteFeedMediaOfItem(context, item.getMedia().getId()).get();\n+            } catch (InterruptedException | ExecutionException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+\n+        int counter = delete.size();\n+\n+\n+        Log.i(TAG, String.format(Locale.US,", "originalCommit": "08edd151f9bc01873128fa97c948841b65b6455c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3a9e1fc2dd1cb80a568bdcc05e4cdd31ca1c4ca3", "url": "https://github.com/AntennaPod/AntennaPod/commit/3a9e1fc2dd1cb80a568bdcc05e4cdd31ca1c4ca3", "message": "Applied code review suggestions\n\nCo-authored-by: ByteHamster <ByteHamster@users.noreply.github.com>", "committedDate": "2021-02-06T14:54:25Z", "type": "commit"}, {"oid": "ae8759869dad5feb134aa4d5d598d9e58ee2287a", "url": "https://github.com/AntennaPod/AntennaPod/commit/ae8759869dad5feb134aa4d5d598d9e58ee2287a", "message": "Fixed default number of items to clean up\n\nNot sure why this worked before TBH - but default value should\nnaturally be to reduce to desired cache size.\n\nProbably makes no difference in actual use - but it is how the tests\nare constructed.", "committedDate": "2021-02-06T20:43:34Z", "type": "commit"}]}