{"pr_number": 1070, "pr_title": "Task 1209", "pr_createdAt": "2020-05-13T17:44:13Z", "pr_url": "https://github.com/Taskana/taskana/pull/1070", "timeline": [{"oid": "d7e585a0df0eb8235ccab6523b05fbf1deba91e4", "url": "https://github.com/Taskana/taskana/commit/d7e585a0df0eb8235ccab6523b05fbf1deba91e4", "message": "TSK-1209: refactored package structure", "committedDate": "2020-05-14T11:06:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA2NjA2NQ==", "url": "https://github.com/Taskana/taskana/pull/1070#discussion_r425066065", "bodyText": "Please use an autowired constructor ;)", "author": "mustaphazorgati", "createdAt": "2020-05-14T11:29:23Z", "path": "rest/taskana-rest-spring/src/main/java/pro/taskana/rest/common/AccessIdController.java", "diffHunk": "@@ -26,8 +26,13 @@\n public class AccessIdController {\n \n   private static final Logger LOGGER = LoggerFactory.getLogger(AccessIdController.class);\n+  private static final String EXIT_FROM_VALIDATE_ACCESS_IDS\n+      = \"Exit from validateAccessIds(), returning {}\";\n+  private static final String EXIT_FROM_GET_GROUP_BY_ACCESS_ID\n+      = \"Exit from getGroupsByAccessId(), returning {}\";\n   private static LdapCache ldapCache;\n-  @Autowired LdapClient ldapClient;\n+  @Autowired\n+  LdapClient ldapClient;", "originalCommit": "d7e585a0df0eb8235ccab6523b05fbf1deba91e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA2NjU2NQ==", "url": "https://github.com/Taskana/taskana/pull/1070#discussion_r425066565", "bodyText": "why did you remove the null check?", "author": "mustaphazorgati", "createdAt": "2020-05-14T11:30:15Z", "path": "rest/taskana-rest-spring/src/main/java/pro/taskana/rest/common/TaskanaErrorData.java", "diffHunk": "@@ -25,7 +25,7 @@\n     this.exception = ex.getClass().getName();\n     this.message = ex.getMessage();\n     this.path = req.getDescription(false);\n-    if (this.path != null && this.path.startsWith(\"uri=\")) {\n+    if (this.path.startsWith(\"uri=\")) {", "originalCommit": "d7e585a0df0eb8235ccab6523b05fbf1deba91e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcxNzk5Nw==", "url": "https://github.com/Taskana/taskana/pull/1070#discussion_r425717997", "bodyText": "According to the IntelliJ and Sonarcloud the method getDescription never returns null and != null is thereby always true.", "author": "krozzus", "createdAt": "2020-05-15T10:42:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA2NjU2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA2Njc0OA==", "url": "https://github.com/Taskana/taskana/pull/1070#discussion_r425066748", "bodyText": "What's wrong with the name LOGGER?", "author": "mustaphazorgati", "createdAt": "2020-05-14T11:30:41Z", "path": "rest/taskana-rest-spring/src/main/java/pro/taskana/rest/common/TaskanaRestExceptionHandler.java", "diffHunk": "@@ -37,7 +37,8 @@\n @ControllerAdvice\n public class TaskanaRestExceptionHandler extends ResponseEntityExceptionHandler {\n \n-  private static final Logger LOGGER = LoggerFactory.getLogger(TaskanaRestExceptionHandler.class);\n+  private static final Logger REST_EXCEPTION_HANDLER_LOGGER = LoggerFactory.getLogger(", "originalCommit": "d7e585a0df0eb8235ccab6523b05fbf1deba91e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcyNTMwNA==", "url": "https://github.com/Taskana/taskana/pull/1070#discussion_r425725304", "bodyText": "This is a suggestion by sonarcloud to prevent a mixup with the field of the superclass.", "author": "krozzus", "createdAt": "2020-05-15T10:58:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA2Njc0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA2NzA3NQ==", "url": "https://github.com/Taskana/taskana/pull/1070#discussion_r425067075", "bodyText": "This is an artifact for taskana-history, right?", "author": "mustaphazorgati", "createdAt": "2020-05-14T11:31:15Z", "path": "rest/taskana-rest-spring/src/main/java/pro/taskana/rest/common/models/PagedResources.java", "diffHunk": "@@ -61,8 +61,8 @@ public PagedResources(Collection<T> content, PageMetadata metadata, Iterable<Lin\n   @JsonProperty(\"page\")\n   public PageMetadata getMetadata() {\n     if (Objects.isNull(metadata)) {\n-      Collection<T> content = getContent();\n-      return new PageMetadata(content.size(), 0, content.size());\n+      Collection<T> contentCollection = getContent();\n+      return new PageMetadata(contentCollection.size(), 0, contentCollection.size());\n     }\n     return metadata;\n   }", "originalCommit": "d7e585a0df0eb8235ccab6523b05fbf1deba91e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcyNTU0OA==", "url": "https://github.com/Taskana/taskana/pull/1070#discussion_r425725548", "bodyText": "This is a suggestion by sonarcloud to make sure the field with the same name isn't hidden.", "author": "krozzus", "createdAt": "2020-05-15T10:58:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA2NzA3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA2NzM2OA==", "url": "https://github.com/Taskana/taskana/pull/1070#discussion_r425067368", "bodyText": "Can you please add the @Autowired annotation here?", "author": "mustaphazorgati", "createdAt": "2020-05-14T11:31:49Z", "path": "rest/taskana-rest-spring/src/main/java/pro/taskana/rest/monitor/MonitorController.java", "diffHunk": "@@ -30,9 +31,9 @@\n \n   private static final Logger LOGGER = LoggerFactory.getLogger(MonitorController.class);\n \n-  private MonitorService monitorService;\n+  private final MonitorService monitorService;\n \n-  private ReportRepresentationModelAssembler reportRepresentationModelAssembler;\n+  private final ReportRepresentationModelAssembler reportRepresentationModelAssembler;\n \n   MonitorController(", "originalCommit": "d7e585a0df0eb8235ccab6523b05fbf1deba91e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3NTY0Mg==", "url": "https://github.com/Taskana/taskana/pull/1070#discussion_r425075642", "bodyText": "Can you please further simplify this:\nan inverse as a variable name is not clean.\n\nrename the variable to authenticated\nreplace noneMatch with anymatch\ninvert predicate", "author": "mustaphazorgati", "createdAt": "2020-05-14T11:48:16Z", "path": "rest/taskana-rest-spring/src/main/java/pro/taskana/rest/workbasket/WorkbasketDefinitionController.java", "diffHunk": "@@ -159,10 +160,8 @@\n       boolean noWrongAuth =\n           definition.getAuthorizations().stream()\n               .noneMatch(\n-                  access -> {\n-                    return (!access.getWorkbasketId().equals(importedWb.getId()))\n-                        || (!access.getWorkbasketKey().equals(importedWb.getKey()));\n-                  });\n+                  access -> (!access.getWorkbasketId().equals(importedWb.getId()))\n+                                || (!access.getWorkbasketKey().equals(importedWb.getKey())));\n       if (!noWrongAuth) {", "originalCommit": "d7e585a0df0eb8235ccab6523b05fbf1deba91e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3NzYxOQ==", "url": "https://github.com/Taskana/taskana/pull/1070#discussion_r425077619", "bodyText": "The error message below has to be adjusted too then :)", "author": "mustaphazorgati", "createdAt": "2020-05-14T11:51:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3NTY0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3Nzg2NQ==", "url": "https://github.com/Taskana/taskana/pull/1070#discussion_r425077865", "bodyText": "why did you make this constructor public?", "author": "mustaphazorgati", "createdAt": "2020-05-14T11:52:29Z", "path": "rest/taskana-rest-spring/src/main/java/pro/taskana/rest/workbasket/models/WorkbasketRepresentationModel.java", "diffHunk": "@@ -13,7 +13,7 @@\n   private String modified; // ISO-8601\n \n   @SuppressWarnings(\"unused\") //Mandatory for Jackson\n-  protected WorkbasketRepresentationModel() {\n+  public WorkbasketRepresentationModel() {", "originalCommit": "d7e585a0df0eb8235ccab6523b05fbf1deba91e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3ODUwNA==", "url": "https://github.com/Taskana/taskana/pull/1070#discussion_r425078504", "bodyText": "Please use an autowired constructor", "author": "mustaphazorgati", "createdAt": "2020-05-14T11:53:47Z", "path": "rest/taskana-rest-spring/src/test/java/pro/taskana/rest/monitor/models/ReportRepresentationModelTest.java", "diffHunk": "@@ -22,12 +22,16 @@\n import pro.taskana.monitor.api.reports.header.TimeIntervalColumnHeader;\n import pro.taskana.monitor.api.reports.item.DetailedMonitorQueryItem;\n import pro.taskana.monitor.api.reports.item.MonitorQueryItem;\n+import pro.taskana.rest.monitor.assembler.ReportRepresentationModelAssembler;\n \n-/** Test for {@link ReportRepresentationModelAssembler}. */\n+/**\n+ * Test for {@link ReportRepresentationModelAssembler}.\n+ */\n @TaskanaSpringBootTest\n class ReportRepresentationModelTest {\n \n-  @Autowired private ReportRepresentationModelAssembler reportRepresentationModelAssembler;\n+  @Autowired\n+  private ReportRepresentationModelAssembler reportRepresentationModelAssembler;", "originalCommit": "d7e585a0df0eb8235ccab6523b05fbf1deba91e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3OTA1Mw==", "url": "https://github.com/Taskana/taskana/pull/1070#discussion_r425079053", "bodyText": "What changed here? Why is the diff so huge?", "author": "mustaphazorgati", "createdAt": "2020-05-14T11:54:54Z", "path": "rest/taskana-rest-spring/src/test/java/pro/taskana/rest/workbasket/WorkbasketDefinitionControllerIntTest.java", "diffHunk": "@@ -1,289 +1,290 @@\n-package pro.taskana.rest;\r\n-\r\n-import static java.nio.charset.StandardCharsets.UTF_8;\r\n-import static org.assertj.core.api.Assertions.assertThat;\r\n-import static org.assertj.core.api.Assertions.assertThatThrownBy;\r\n-import static org.assertj.core.api.Assertions.fail;\r\n-\r\n-import com.fasterxml.jackson.core.JsonProcessingException;\r\n-import com.fasterxml.jackson.databind.ObjectMapper;\r\n-import java.io.File;\r\n-import java.io.FileOutputStream;\r\n-import java.io.IOException;\r\n-import java.io.OutputStreamWriter;\r\n-import java.util.Arrays;\r\n-import java.util.Collections;\r\n-import java.util.HashSet;\r\n-import java.util.List;\r\n-import java.util.stream.Collectors;\r\n-import javax.sql.DataSource;\r\n-import org.assertj.core.api.ThrowableAssert.ThrowingCallable;\r\n-import org.junit.jupiter.api.BeforeAll;\r\n-import org.junit.jupiter.api.BeforeEach;\r\n-import org.junit.jupiter.api.Test;\r\n-import org.springframework.beans.factory.annotation.Autowired;\r\n-import org.springframework.beans.factory.annotation.Value;\r\n-import org.springframework.core.ParameterizedTypeReference;\r\n-import org.springframework.core.io.FileSystemResource;\r\n-import org.springframework.http.HttpEntity;\r\n-import org.springframework.http.HttpHeaders;\r\n-import org.springframework.http.HttpMethod;\r\n-import org.springframework.http.HttpStatus;\r\n-import org.springframework.http.MediaType;\r\n-import org.springframework.http.ResponseEntity;\r\n-import org.springframework.util.LinkedMultiValueMap;\r\n-import org.springframework.util.MultiValueMap;\r\n-import org.springframework.web.client.HttpClientErrorException;\r\n-import org.springframework.web.client.RestTemplate;\r\n-\r\n-import pro.taskana.RestHelper;\r\n-import pro.taskana.TaskanaSpringBootTest;\r\n-import pro.taskana.rest.resource.WorkbasketDefinitionRepresentationModel;\r\n-import pro.taskana.sampledata.SampleDataGenerator;\r\n-\r\n-/** Integration tests for WorkbasketDefinitionController. */\r\n-@TaskanaSpringBootTest\r\n-class WorkbasketDefinitionControllerIntTest {\r\n-\r\n-  private static RestTemplate template;\r\n-\r\n-  @Value(\"${taskana.schemaName:TASKANA}\")\r\n-  String schemaName;\r\n-\r\n-  ObjectMapper objMapper = new ObjectMapper();\r\n-\r\n-  @Autowired RestHelper restHelper;\r\n-\r\n-  @Autowired private DataSource dataSource;\r\n-\r\n-  @BeforeAll\r\n-  static void init() {\r\n-    template = RestHelper.TEMPLATE;\r\n-  }\r\n-\r\n-  @BeforeEach\r\n-  void resetDb() {\r\n-    SampleDataGenerator sampleDataGenerator = new SampleDataGenerator(dataSource, schemaName);\r\n-    sampleDataGenerator.generateSampleData();\r\n-  }\r\n-\r\n-  @Test\r\n-  void testExportWorkbasketFromDomain() {\r\n-    ResponseEntity<List<WorkbasketDefinitionRepresentationModel>> response =\r\n-        executeExportRequestForDomain(\"DOMAIN_A\");\r\n-\r\n-    assertThat(response.getBody()).isNotNull();\r\n-    assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);\r\n-    assertThat(response.getBody().get(0))\r\n-        .isInstanceOf(WorkbasketDefinitionRepresentationModel.class);\r\n-\r\n-    boolean allAuthorizationsAreEmpty = true;\r\n-    boolean allDistributionTargetsAreEmpty = true;\r\n-    for (WorkbasketDefinitionRepresentationModel workbasketDefinition : response.getBody()) {\r\n-      if (allAuthorizationsAreEmpty && !workbasketDefinition.getAuthorizations().isEmpty()) {\r\n-        allAuthorizationsAreEmpty = false;\r\n-      }\r\n-      if (allDistributionTargetsAreEmpty\r\n-          && !workbasketDefinition.getDistributionTargets().isEmpty()) {\r\n-        allDistributionTargetsAreEmpty = false;\r\n-      }\r\n-      if (!allAuthorizationsAreEmpty && !allDistributionTargetsAreEmpty) {\r\n-        break;\r\n-      }\r\n-    }\r\n-    assertThat(allDistributionTargetsAreEmpty).isFalse();\r\n-    assertThat(allAuthorizationsAreEmpty).isFalse();\r\n-  }\r\n-\r\n-  @Test\r\n-  void testExportWorkbasketsFromWrongDomain() {\r\n-    ResponseEntity<List<WorkbasketDefinitionRepresentationModel>> response =\r\n-        executeExportRequestForDomain(\"wrongDomain\");\r\n-    assertThat(response.getBody()).isEmpty();\r\n-  }\r\n-\r\n-  @Test\r\n-  void testImportEveryWorkbasketFromDomainA() throws IOException {\r\n-    List<WorkbasketDefinitionRepresentationModel> wbList =\r\n-        executeExportRequestForDomain(\"DOMAIN_A\").getBody();\r\n-    for (WorkbasketDefinitionRepresentationModel w : wbList) {\r\n-      expectStatusWhenExecutingImportRequestOfWorkbaskets(HttpStatus.NO_CONTENT, w);\r\n-    }\r\n-  }\r\n-\r\n-  @Test\r\n-  void testImportWorkbasketWithoutDistributionTargets() throws IOException {\r\n-    WorkbasketDefinitionRepresentationModel w =\r\n-        executeExportRequestForDomain(\"DOMAIN_A\").getBody().get(0);\r\n-    w.setDistributionTargets(new HashSet<>());\r\n-\r\n-    this.expectStatusWhenExecutingImportRequestOfWorkbaskets(HttpStatus.NO_CONTENT, w);\r\n-\r\n-    w.getWorkbasket().setKey(\"newKey\");\r\n-    w.getAuthorizations().forEach(authorization -> authorization.setWorkbasketKey(\"newKey\"));\r\n-    expectStatusWhenExecutingImportRequestOfWorkbaskets(HttpStatus.NO_CONTENT, w);\r\n-  }\r\n-\r\n-  @Test\r\n-  void testImportWorkbasketWithDistributionTargetsInImportFile() throws IOException {\r\n-    List<WorkbasketDefinitionRepresentationModel> wbList =\r\n-        executeExportRequestForDomain(\"DOMAIN_A\").getBody();\r\n-\r\n-    WorkbasketDefinitionRepresentationModel w = wbList.get(0);\r\n-    w.setDistributionTargets(new HashSet<>());\r\n-    String letMeBeYourDistributionTarget = w.getWorkbasket().getWorkbasketId();\r\n-    WorkbasketDefinitionRepresentationModel w2 = wbList.get(1);\r\n-    w2.setDistributionTargets(Collections.singleton(letMeBeYourDistributionTarget));\r\n-    expectStatusWhenExecutingImportRequestOfWorkbaskets(HttpStatus.NO_CONTENT, w, w2);\r\n-\r\n-    this.changeWorkbasketIdOrKey(w, \"fancyNewId\", null);\r\n-    w2.setDistributionTargets(Collections.singleton(\"fancyNewId\"));\r\n-    expectStatusWhenExecutingImportRequestOfWorkbaskets(HttpStatus.NO_CONTENT, w, w2);\r\n-\r\n-    this.changeWorkbasketIdOrKey(w, null, \"nowImANewWB\");\r\n-    expectStatusWhenExecutingImportRequestOfWorkbaskets(HttpStatus.NO_CONTENT, w, w2);\r\n-\r\n-    this.changeWorkbasketIdOrKey(w2, null, \"nowImAlsoANewWB\");\r\n-    expectStatusWhenExecutingImportRequestOfWorkbaskets(HttpStatus.NO_CONTENT, w, w2);\r\n-  }\r\n-\r\n-  @Test\r\n-  void testImportWorkbasketWithDistributionTargetsInSystem() throws IOException {\r\n-    List<WorkbasketDefinitionRepresentationModel> wbList =\r\n-        executeExportRequestForDomain(\"DOMAIN_A\").getBody();\r\n-\r\n-    wbList.removeIf(definition -> definition.getDistributionTargets().isEmpty());\r\n-    WorkbasketDefinitionRepresentationModel w = wbList.get(0);\r\n-    expectStatusWhenExecutingImportRequestOfWorkbaskets(HttpStatus.NO_CONTENT, w);\r\n-\r\n-    changeWorkbasketIdOrKey(w, null, \"new\");\r\n-    expectStatusWhenExecutingImportRequestOfWorkbaskets(HttpStatus.NO_CONTENT, w);\r\n-  }\r\n-\r\n-  @Test\r\n-  void testImportWorkbasketWithDistributionTargetsNotInSystem() throws IOException {\r\n-    List<WorkbasketDefinitionRepresentationModel> wbList =\r\n-        executeExportRequestForDomain(\"DOMAIN_A\").getBody();\r\n-\r\n-    WorkbasketDefinitionRepresentationModel w = wbList.get(0);\r\n-    w.setDistributionTargets(Collections.singleton(\"invalidWorkbasketId\"));\r\n-    try {\r\n-      expectStatusWhenExecutingImportRequestOfWorkbaskets(HttpStatus.BAD_REQUEST, w);\r\n-      fail(\"Expected http-Status 400\");\r\n-    } catch (HttpClientErrorException e) {\r\n-      assertThat(e.getStatusCode()).isEqualTo(HttpStatus.BAD_REQUEST);\r\n-    }\r\n-\r\n-    w.getWorkbasket().setKey(\"anotherNewKey\");\r\n-    try {\r\n-      expectStatusWhenExecutingImportRequestOfWorkbaskets(HttpStatus.BAD_REQUEST, w);\r\n-      fail(\"Expected http-Status 400\");\r\n-    } catch (HttpClientErrorException e) {\r\n-      assertThat(e.getStatusCode()).isEqualTo(HttpStatus.BAD_REQUEST);\r\n-    }\r\n-  }\r\n-\r\n-  @Test\r\n-  void testFailOnImportDuplicates() throws IOException {\r\n-    WorkbasketDefinitionRepresentationModel w =\r\n-        executeExportRequestForDomain(\"DOMAIN_A\").getBody().get(0);\r\n-    try {\r\n-      expectStatusWhenExecutingImportRequestOfWorkbaskets(HttpStatus.CONFLICT, w, w);\r\n-      fail(\"Expected http-Status 409\");\r\n-    } catch (HttpClientErrorException e) {\r\n-      assertThat(e.getStatusCode()).isEqualTo(HttpStatus.CONFLICT);\r\n-    }\r\n-  }\r\n-\r\n-  @Test\r\n-  void testNoErrorWhenImportWithSameIdButDifferentKeyAndDomain() throws IOException {\r\n-    List<WorkbasketDefinitionRepresentationModel> wbList =\r\n-        executeExportRequestForDomain(\"DOMAIN_A\").getBody();\r\n-\r\n-    WorkbasketDefinitionRepresentationModel w = wbList.get(0);\r\n-    WorkbasketDefinitionRepresentationModel differentLogicalId = wbList.get(1);\r\n-    this.changeWorkbasketIdOrKey(differentLogicalId, w.getWorkbasket().getWorkbasketId(), null);\r\n-\r\n-    // breaks the logic but not the script- should we really allow this case?\r\n-    WorkbasketDefinitionRepresentationModel theDestroyer = wbList.get(2);\r\n-    theDestroyer.setDistributionTargets(\r\n-        Collections.singleton(differentLogicalId.getWorkbasket().getWorkbasketId()));\r\n-\r\n-    expectStatusWhenExecutingImportRequestOfWorkbaskets(\r\n-        HttpStatus.NO_CONTENT, w, differentLogicalId, theDestroyer);\r\n-  }\r\n-\r\n-  @Test\r\n-  void testErrorWhenImportWithSameAccessIdAndWorkbasket() {\r\n-    WorkbasketDefinitionRepresentationModel w =\r\n-        executeExportRequestForDomain(\"DOMAIN_A\").getBody().get(0);\r\n-\r\n-    String w1String = workbasketToString(w);\r\n-    w.getWorkbasket().setKey(\"new Key for this WB\");\r\n-    String w2String = workbasketToString(w);\r\n-    ThrowingCallable httpCall =\r\n-        () -> {\r\n-          expectStatusWhenExecutingImportRequestOfWorkbaskets(\r\n-              HttpStatus.CONFLICT, Arrays.asList(w1String, w2String));\r\n-        };\r\n-    assertThatThrownBy(httpCall).isInstanceOf(HttpClientErrorException.class);\r\n-  }\r\n-\r\n-  private void changeWorkbasketIdOrKey(\r\n-      WorkbasketDefinitionRepresentationModel w, String newId, String newKey) {\r\n-    if (newId != null && !newId.isEmpty()) {\r\n-      w.getWorkbasket().setWorkbasketId(newId);\r\n-      w.getAuthorizations().forEach(auth -> auth.setWorkbasketId(newId));\r\n-    }\r\n-    if (newKey != null && !newKey.isEmpty()) {\r\n-      w.getWorkbasket().setKey(newKey);\r\n-      w.getAuthorizations().forEach(auth -> auth.setWorkbasketKey(newKey));\r\n-    }\r\n-  }\r\n-\r\n-  private ResponseEntity<List<WorkbasketDefinitionRepresentationModel>>\r\n-      executeExportRequestForDomain(String domain) {\r\n-    return template.exchange(\r\n-        restHelper.toUrl(Mapping.URL_WORKBASKETDEFIITIONS) + \"?domain=\" + domain,\r\n-        HttpMethod.GET,\r\n-        restHelper.defaultRequest(),\r\n-        new ParameterizedTypeReference<List<WorkbasketDefinitionRepresentationModel>>() {});\r\n-  }\r\n-\r\n-  private void expectStatusWhenExecutingImportRequestOfWorkbaskets(\r\n-      HttpStatus expectedStatus, WorkbasketDefinitionRepresentationModel... workbaskets)\r\n-      throws IOException {\r\n-    List<String> workbasketStrings =\r\n-        Arrays.stream(workbaskets).map(this::workbasketToString).collect(Collectors.toList());\r\n-    expectStatusWhenExecutingImportRequestOfWorkbaskets(expectedStatus, workbasketStrings);\r\n-  }\r\n-\r\n-  private void expectStatusWhenExecutingImportRequestOfWorkbaskets(\r\n-      HttpStatus expectedStatus, List<String> workbasketStrings) throws IOException {\r\n-    File tmpFile = File.createTempFile(\"test\", \".tmp\");\r\n-    OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(tmpFile), UTF_8);\r\n-    writer.write(workbasketStrings.toString());\r\n-    writer.close();\r\n-\r\n-    MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();\r\n-    HttpHeaders headers = restHelper.getHeaders();\r\n-    headers.setContentType(MediaType.MULTIPART_FORM_DATA);\r\n-    body.add(\"file\", new FileSystemResource(tmpFile));\r\n-\r\n-    HttpEntity<MultiValueMap<String, Object>> requestEntity = new HttpEntity<>(body, headers);\r\n-    String serverUrl = restHelper.toUrl(Mapping.URL_WORKBASKETDEFIITIONS);\r\n-\r\n-    ResponseEntity<Void> responseImport =\r\n-        template.postForEntity(serverUrl, requestEntity, Void.class);\r\n-    assertThat(responseImport.getStatusCode()).isEqualTo(expectedStatus);\r\n-  }\r\n-\r\n-  private String workbasketToString(\r\n-      WorkbasketDefinitionRepresentationModel workbasketDefinitionRepresentationModel) {\r\n-    try {\r\n-      return objMapper.writeValueAsString(workbasketDefinitionRepresentationModel);\r\n-    } catch (JsonProcessingException e) {\r\n-      return \"\";\r\n-    }\r\n-  }\r\n-}\r\n+package pro.taskana.rest.workbasket;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.assertj.core.api.Assertions.fail;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.sql.DataSource;\n+import org.assertj.core.api.ThrowableAssert.ThrowingCallable;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.core.io.FileSystemResource;\n+import org.springframework.http.HttpEntity;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.MediaType;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.util.LinkedMultiValueMap;\n+import org.springframework.util.MultiValueMap;\n+import org.springframework.web.client.HttpClientErrorException;\n+import org.springframework.web.client.RestTemplate;\n+\n+import pro.taskana.RestHelper;\n+import pro.taskana.TaskanaSpringBootTest;\n+import pro.taskana.rest.common.Mapping;\n+import pro.taskana.rest.workbasket.models.WorkbasketDefinitionRepresentationModel;\n+import pro.taskana.sampledata.SampleDataGenerator;\n+\n+/** Integration tests for WorkbasketDefinitionController. */\n+@TaskanaSpringBootTest\n+class WorkbasketDefinitionControllerIntTest {\n+\n+  private static RestTemplate template;\n+\n+  @Value(\"${taskana.schemaName:TASKANA}\")\n+  String schemaName;\n+\n+  ObjectMapper objMapper = new ObjectMapper();\n+\n+  @Autowired RestHelper restHelper;\n+\n+  @Autowired private DataSource dataSource;\n+\n+  @BeforeAll\n+  static void init() {\n+    template = RestHelper.TEMPLATE;\n+  }\n+\n+  @BeforeEach\n+  void resetDb() {\n+    SampleDataGenerator sampleDataGenerator = new SampleDataGenerator(dataSource, schemaName);\n+    sampleDataGenerator.generateSampleData();\n+  }\n+\n+  @Test\n+  void testExportWorkbasketFromDomain() {\n+    ResponseEntity<List<WorkbasketDefinitionRepresentationModel>> response =\n+        executeExportRequestForDomain(\"DOMAIN_A\");\n+\n+    assertThat(response.getBody()).isNotNull();\n+    assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);\n+    assertThat(response.getBody().get(0))\n+        .isInstanceOf(WorkbasketDefinitionRepresentationModel.class);\n+\n+    boolean allAuthorizationsAreEmpty = true;\n+    boolean allDistributionTargetsAreEmpty = true;\n+    for (WorkbasketDefinitionRepresentationModel workbasketDefinition : response.getBody()) {\n+      if (allAuthorizationsAreEmpty && !workbasketDefinition.getAuthorizations().isEmpty()) {\n+        allAuthorizationsAreEmpty = false;\n+      }\n+      if (allDistributionTargetsAreEmpty\n+          && !workbasketDefinition.getDistributionTargets().isEmpty()) {\n+        allDistributionTargetsAreEmpty = false;\n+      }\n+      if (!allAuthorizationsAreEmpty && !allDistributionTargetsAreEmpty) {\n+        break;\n+      }\n+    }\n+    assertThat(allDistributionTargetsAreEmpty).isFalse();\n+    assertThat(allAuthorizationsAreEmpty).isFalse();\n+  }\n+\n+  @Test\n+  void testExportWorkbasketsFromWrongDomain() {\n+    ResponseEntity<List<WorkbasketDefinitionRepresentationModel>> response =\n+        executeExportRequestForDomain(\"wrongDomain\");\n+    assertThat(response.getBody()).isEmpty();\n+  }\n+\n+  @Test\n+  void testImportEveryWorkbasketFromDomainA() throws IOException {\n+    List<WorkbasketDefinitionRepresentationModel> wbList =\n+        executeExportRequestForDomain(\"DOMAIN_A\").getBody();\n+    for (WorkbasketDefinitionRepresentationModel w : wbList) {\n+      expectStatusWhenExecutingImportRequestOfWorkbaskets(HttpStatus.NO_CONTENT, w);\n+    }\n+  }\n+\n+  @Test\n+  void testImportWorkbasketWithoutDistributionTargets() throws IOException {\n+    WorkbasketDefinitionRepresentationModel w =\n+        executeExportRequestForDomain(\"DOMAIN_A\").getBody().get(0);\n+    w.setDistributionTargets(new HashSet<>());\n+\n+    this.expectStatusWhenExecutingImportRequestOfWorkbaskets(HttpStatus.NO_CONTENT, w);\n+\n+    w.getWorkbasket().setKey(\"newKey\");\n+    w.getAuthorizations().forEach(authorization -> authorization.setWorkbasketKey(\"newKey\"));\n+    expectStatusWhenExecutingImportRequestOfWorkbaskets(HttpStatus.NO_CONTENT, w);\n+  }\n+\n+  @Test\n+  void testImportWorkbasketWithDistributionTargetsInImportFile() throws IOException {\n+    List<WorkbasketDefinitionRepresentationModel> wbList =\n+        executeExportRequestForDomain(\"DOMAIN_A\").getBody();\n+\n+    WorkbasketDefinitionRepresentationModel w = wbList.get(0);\n+    w.setDistributionTargets(new HashSet<>());\n+    String letMeBeYourDistributionTarget = w.getWorkbasket().getWorkbasketId();\n+    WorkbasketDefinitionRepresentationModel w2 = wbList.get(1);\n+    w2.setDistributionTargets(Collections.singleton(letMeBeYourDistributionTarget));\n+    expectStatusWhenExecutingImportRequestOfWorkbaskets(HttpStatus.NO_CONTENT, w, w2);\n+\n+    this.changeWorkbasketIdOrKey(w, \"fancyNewId\", null);\n+    w2.setDistributionTargets(Collections.singleton(\"fancyNewId\"));\n+    expectStatusWhenExecutingImportRequestOfWorkbaskets(HttpStatus.NO_CONTENT, w, w2);\n+\n+    this.changeWorkbasketIdOrKey(w, null, \"nowImANewWB\");\n+    expectStatusWhenExecutingImportRequestOfWorkbaskets(HttpStatus.NO_CONTENT, w, w2);\n+\n+    this.changeWorkbasketIdOrKey(w2, null, \"nowImAlsoANewWB\");\n+    expectStatusWhenExecutingImportRequestOfWorkbaskets(HttpStatus.NO_CONTENT, w, w2);\n+  }\n+\n+  @Test\n+  void testImportWorkbasketWithDistributionTargetsInSystem() throws IOException {\n+    List<WorkbasketDefinitionRepresentationModel> wbList =\n+        executeExportRequestForDomain(\"DOMAIN_A\").getBody();\n+\n+    wbList.removeIf(definition -> definition.getDistributionTargets().isEmpty());\n+    WorkbasketDefinitionRepresentationModel w = wbList.get(0);\n+    expectStatusWhenExecutingImportRequestOfWorkbaskets(HttpStatus.NO_CONTENT, w);\n+\n+    changeWorkbasketIdOrKey(w, null, \"new\");\n+    expectStatusWhenExecutingImportRequestOfWorkbaskets(HttpStatus.NO_CONTENT, w);\n+  }\n+\n+  @Test\n+  void testImportWorkbasketWithDistributionTargetsNotInSystem() throws IOException {\n+    List<WorkbasketDefinitionRepresentationModel> wbList =\n+        executeExportRequestForDomain(\"DOMAIN_A\").getBody();\n+\n+    WorkbasketDefinitionRepresentationModel w = wbList.get(0);\n+    w.setDistributionTargets(Collections.singleton(\"invalidWorkbasketId\"));\n+    try {\n+      expectStatusWhenExecutingImportRequestOfWorkbaskets(HttpStatus.BAD_REQUEST, w);\n+      fail(\"Expected http-Status 400\");\n+    } catch (HttpClientErrorException e) {\n+      assertThat(e.getStatusCode()).isEqualTo(HttpStatus.BAD_REQUEST);\n+    }\n+\n+    w.getWorkbasket().setKey(\"anotherNewKey\");\n+    try {\n+      expectStatusWhenExecutingImportRequestOfWorkbaskets(HttpStatus.BAD_REQUEST, w);\n+      fail(\"Expected http-Status 400\");\n+    } catch (HttpClientErrorException e) {\n+      assertThat(e.getStatusCode()).isEqualTo(HttpStatus.BAD_REQUEST);\n+    }\n+  }\n+\n+  @Test\n+  void testFailOnImportDuplicates() throws IOException {\n+    WorkbasketDefinitionRepresentationModel w =\n+        executeExportRequestForDomain(\"DOMAIN_A\").getBody().get(0);\n+    try {\n+      expectStatusWhenExecutingImportRequestOfWorkbaskets(HttpStatus.CONFLICT, w, w);\n+      fail(\"Expected http-Status 409\");\n+    } catch (HttpClientErrorException e) {\n+      assertThat(e.getStatusCode()).isEqualTo(HttpStatus.CONFLICT);\n+    }\n+  }\n+\n+  @Test\n+  void testNoErrorWhenImportWithSameIdButDifferentKeyAndDomain() throws IOException {\n+    List<WorkbasketDefinitionRepresentationModel> wbList =\n+        executeExportRequestForDomain(\"DOMAIN_A\").getBody();\n+\n+    WorkbasketDefinitionRepresentationModel w = wbList.get(0);\n+    WorkbasketDefinitionRepresentationModel differentLogicalId = wbList.get(1);\n+    this.changeWorkbasketIdOrKey(differentLogicalId, w.getWorkbasket().getWorkbasketId(), null);\n+\n+    // breaks the logic but not the script- should we really allow this case?\n+    WorkbasketDefinitionRepresentationModel theDestroyer = wbList.get(2);\n+    theDestroyer.setDistributionTargets(\n+        Collections.singleton(differentLogicalId.getWorkbasket().getWorkbasketId()));\n+\n+    expectStatusWhenExecutingImportRequestOfWorkbaskets(\n+        HttpStatus.NO_CONTENT, w, differentLogicalId, theDestroyer);\n+  }\n+\n+  @Test\n+  void testErrorWhenImportWithSameAccessIdAndWorkbasket() {\n+    WorkbasketDefinitionRepresentationModel w =\n+        executeExportRequestForDomain(\"DOMAIN_A\").getBody().get(0);\n+\n+    String w1String = workbasketToString(w);\n+    w.getWorkbasket().setKey(\"new Key for this WB\");\n+    String w2String = workbasketToString(w);\n+    ThrowingCallable httpCall =\n+        () -> {\n+          expectStatusWhenExecutingImportRequestOfWorkbaskets(\n+              HttpStatus.CONFLICT, Arrays.asList(w1String, w2String));\n+        };\n+    assertThatThrownBy(httpCall).isInstanceOf(HttpClientErrorException.class);\n+  }\n+\n+  private void changeWorkbasketIdOrKey(\n+      WorkbasketDefinitionRepresentationModel w, String newId, String newKey) {\n+    if (newId != null && !newId.isEmpty()) {\n+      w.getWorkbasket().setWorkbasketId(newId);\n+      w.getAuthorizations().forEach(auth -> auth.setWorkbasketId(newId));\n+    }\n+    if (newKey != null && !newKey.isEmpty()) {\n+      w.getWorkbasket().setKey(newKey);\n+      w.getAuthorizations().forEach(auth -> auth.setWorkbasketKey(newKey));\n+    }\n+  }\n+\n+  private ResponseEntity<List<WorkbasketDefinitionRepresentationModel>>\n+      executeExportRequestForDomain(String domain) {\n+    return template.exchange(\n+        restHelper.toUrl(Mapping.URL_WORKBASKETDEFIITIONS) + \"?domain=\" + domain,\n+        HttpMethod.GET,\n+        restHelper.defaultRequest(),\n+        new ParameterizedTypeReference<List<WorkbasketDefinitionRepresentationModel>>() {});\n+  }\n+\n+  private void expectStatusWhenExecutingImportRequestOfWorkbaskets(\n+      HttpStatus expectedStatus, WorkbasketDefinitionRepresentationModel... workbaskets)\n+      throws IOException {\n+    List<String> workbasketStrings =\n+        Arrays.stream(workbaskets).map(this::workbasketToString).collect(Collectors.toList());\n+    expectStatusWhenExecutingImportRequestOfWorkbaskets(expectedStatus, workbasketStrings);\n+  }\n+\n+  private void expectStatusWhenExecutingImportRequestOfWorkbaskets(\n+      HttpStatus expectedStatus, List<String> workbasketStrings) throws IOException {\n+    File tmpFile = File.createTempFile(\"test\", \".tmp\");\n+    OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(tmpFile), UTF_8);\n+    writer.write(workbasketStrings.toString());\n+    writer.close();\n+\n+    MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();\n+    HttpHeaders headers = restHelper.getHeaders();\n+    headers.setContentType(MediaType.MULTIPART_FORM_DATA);\n+    body.add(\"file\", new FileSystemResource(tmpFile));\n+\n+    HttpEntity<MultiValueMap<String, Object>> requestEntity = new HttpEntity<>(body, headers);\n+    String serverUrl = restHelper.toUrl(Mapping.URL_WORKBASKETDEFIITIONS);\n+\n+    ResponseEntity<Void> responseImport =\n+        template.postForEntity(serverUrl, requestEntity, Void.class);\n+    assertThat(responseImport.getStatusCode()).isEqualTo(expectedStatus);\n+  }\n+\n+  private String workbasketToString(\n+      WorkbasketDefinitionRepresentationModel workbasketDefinitionRepresentationModel) {\n+    try {\n+      return objMapper.writeValueAsString(workbasketDefinitionRepresentationModel);\n+    } catch (JsonProcessingException e) {\n+      return \"\";\n+    }\n+  }\n+}", "originalCommit": "d7e585a0df0eb8235ccab6523b05fbf1deba91e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7c97ad3130a5e6cc5ad23f8dc4e545d49eb45ad3", "url": "https://github.com/Taskana/taskana/commit/7c97ad3130a5e6cc5ad23f8dc4e545d49eb45ad3", "message": "TSK-1209: refactored package structure", "committedDate": "2020-05-15T15:39:51Z", "type": "forcePushed"}, {"oid": "f10f0595b4c78a754a63e08ce638fc347fb6f869", "url": "https://github.com/Taskana/taskana/commit/f10f0595b4c78a754a63e08ce638fc347fb6f869", "message": "TSK-1209: refactored package structure", "committedDate": "2020-05-17T23:30:04Z", "type": "forcePushed"}, {"oid": "59e5fe62a1a643f006136e7a446dcb855bbf169e", "url": "https://github.com/Taskana/taskana/commit/59e5fe62a1a643f006136e7a446dcb855bbf169e", "message": "TSK-1209: refactored package structure", "committedDate": "2020-05-18T12:46:49Z", "type": "forcePushed"}, {"oid": "65e4058fbd0af01d58dcceb643d8d0aea023b4f4", "url": "https://github.com/Taskana/taskana/commit/65e4058fbd0af01d58dcceb643d8d0aea023b4f4", "message": "TSK-1209: refactored package structure", "committedDate": "2020-05-18T14:45:25Z", "type": "forcePushed"}, {"oid": "a3dafcc4bf9deb680bb3133bc0e10dd72100021e", "url": "https://github.com/Taskana/taskana/commit/a3dafcc4bf9deb680bb3133bc0e10dd72100021e", "message": "TSK-1209: refactored package structure", "committedDate": "2020-05-19T08:36:15Z", "type": "forcePushed"}, {"oid": "bc361d824c225a95beee93d6719d2d1b4b35d437", "url": "https://github.com/Taskana/taskana/commit/bc361d824c225a95beee93d6719d2d1b4b35d437", "message": "TSK-1209: refactored package structure", "committedDate": "2020-05-19T10:37:57Z", "type": "forcePushed"}, {"oid": "20d862e5bf26524a9e7d70ae1291e038e6ee287b", "url": "https://github.com/Taskana/taskana/commit/20d862e5bf26524a9e7d70ae1291e038e6ee287b", "message": "TSK-1209: refactored package structure", "committedDate": "2020-05-19T12:28:02Z", "type": "forcePushed"}, {"oid": "f41a9e269071dbfc95a8f5e392c09a0809db5d57", "url": "https://github.com/Taskana/taskana/commit/f41a9e269071dbfc95a8f5e392c09a0809db5d57", "message": "TSK-1209: refactored package structure", "committedDate": "2020-05-19T12:40:14Z", "type": "forcePushed"}, {"oid": "61372d190f3a604bea222b5272e94d3e72c11135", "url": "https://github.com/Taskana/taskana/commit/61372d190f3a604bea222b5272e94d3e72c11135", "message": "TSK-1209: refactored package structure", "committedDate": "2020-05-19T13:12:02Z", "type": "forcePushed"}, {"oid": "61372d190f3a604bea222b5272e94d3e72c11135", "url": "https://github.com/Taskana/taskana/commit/61372d190f3a604bea222b5272e94d3e72c11135", "message": "TSK-1209: refactored package structure", "committedDate": "2020-05-19T13:12:02Z", "type": "commit"}, {"oid": "a163d65028c340e79ef5885daad9454929a04cc5", "url": "https://github.com/Taskana/taskana/commit/a163d65028c340e79ef5885daad9454929a04cc5", "message": "TASK-1209: remember to squash this", "committedDate": "2020-05-20T13:42:16Z", "type": "forcePushed"}, {"oid": "a163d65028c340e79ef5885daad9454929a04cc5", "url": "https://github.com/Taskana/taskana/commit/a163d65028c340e79ef5885daad9454929a04cc5", "message": "TASK-1209: remember to squash this", "committedDate": "2020-05-20T13:42:16Z", "type": "commit"}]}