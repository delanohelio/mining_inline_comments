{"pr_number": 1004, "pr_title": "Add Amx bidder", "pr_createdAt": "2020-11-12T13:44:16Z", "pr_url": "https://github.com/prebid/prebid-server-java/pull/1004", "timeline": [{"oid": "1dbdf9f498fae46afac8caa6d565bb0320e82292", "url": "https://github.com/prebid/prebid-server-java/commit/1dbdf9f498fae46afac8caa6d565bb0320e82292", "message": "Add Amx bidder.", "committedDate": "2020-11-12T13:43:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAwODIyMQ==", "url": "https://github.com/prebid/prebid-server-java/pull/1004#discussion_r526008221", "bodyText": "It is too expensive to create request-builder twice here.\nPls think how we can optimize.", "author": "rpanchyk", "createdAt": "2020-11-18T11:18:27Z", "path": "src/main/java/org/prebid/server/bidder/amx/AmxBidder.java", "diffHunk": "@@ -0,0 +1,264 @@\n+package org.prebid.server.bidder.amx;\n+\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.iab.openrtb.request.App;\n+import com.iab.openrtb.request.BidRequest;\n+import com.iab.openrtb.request.Imp;\n+import com.iab.openrtb.request.Publisher;\n+import com.iab.openrtb.request.Site;\n+import com.iab.openrtb.response.Bid;\n+import com.iab.openrtb.response.BidResponse;\n+import com.iab.openrtb.response.SeatBid;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.vertx.core.MultiMap;\n+import io.vertx.core.http.HttpMethod;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.prebid.server.bidder.Bidder;\n+import org.prebid.server.bidder.amx.model.AmxBidExt;\n+import org.prebid.server.bidder.model.BidderBid;\n+import org.prebid.server.bidder.model.BidderError;\n+import org.prebid.server.bidder.model.HttpCall;\n+import org.prebid.server.bidder.model.HttpRequest;\n+import org.prebid.server.bidder.model.Result;\n+import org.prebid.server.exception.PreBidException;\n+import org.prebid.server.json.DecodeException;\n+import org.prebid.server.json.JacksonMapper;\n+import org.prebid.server.proto.openrtb.ext.ExtPrebid;\n+import org.prebid.server.proto.openrtb.ext.request.amx.ExtImpAmx;\n+import org.prebid.server.proto.openrtb.ext.response.BidType;\n+import org.prebid.server.util.HttpUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * AMX {@link Bidder} implementation.\n+ */\n+public class AmxBidder implements Bidder<BidRequest> {\n+\n+    private static final TypeReference<ExtPrebid<?, ExtImpAmx>> AMX_EXT_TYPE_REFERENCE =\n+            new TypeReference<ExtPrebid<?, ExtImpAmx>>() {\n+            };\n+\n+    private static final String ADAPTER_VERSION = \"pbs1.0\";\n+    private static final String VERSION_PARAM = \"v\";\n+    private static final String VAST_SEARCH_POINT = \"</Impression>\";\n+    private static final String VAST_IMPRESSION_FORMAT = \"<Impression><![CDATA[%s]]></Impression>\";\n+\n+    private final String endpointUrl;\n+    private final JacksonMapper mapper;\n+\n+    public AmxBidder(String endpointUrl, JacksonMapper mapper) {\n+        this.mapper = Objects.requireNonNull(mapper);\n+        this.endpointUrl = new URIBuilder()\n+                .setPath(HttpUtil.validateUrl(Objects.requireNonNull(endpointUrl)))\n+                .addParameter(VERSION_PARAM, ADAPTER_VERSION)\n+                .toString();\n+    }\n+\n+    @Override\n+    public Result<List<HttpRequest<BidRequest>>> makeHttpRequests(BidRequest request) {\n+        final List<Imp> modifiedImps = new ArrayList<>();\n+        final List<BidderError> errors = new ArrayList<>();\n+        String publisherId = null;\n+        for (Imp imp : request.getImp()) {\n+            try {\n+                final ExtImpAmx extImpAmx = parseImpExt(imp);\n+                final String tagId = extImpAmx.getTagId();\n+                if (StringUtils.isNotBlank(tagId)) {\n+                    publisherId = tagId;\n+                }\n+\n+                final String adUnitId = extImpAmx.getAdUnitId();\n+                if (StringUtils.isNotBlank(adUnitId)) {\n+                    modifiedImps.add(imp.toBuilder().tagid(adUnitId).build());\n+                }\n+            } catch (PreBidException e) {\n+                errors.add(BidderError.badInput(e.getMessage()));\n+            }\n+        }\n+\n+        final BidRequest outgoingRequest = createOutgoingRequest(request, publisherId, modifiedImps);\n+\n+        return Result.of(Collections.singletonList(\n+                HttpRequest.<BidRequest>builder()\n+                        .method(HttpMethod.POST)\n+                        .uri(endpointUrl)\n+                        .headers(headers())\n+                        .payload(outgoingRequest)\n+                        .body(mapper.encode(outgoingRequest))\n+                        .build()), errors);\n+    }\n+\n+    private ExtImpAmx parseImpExt(Imp imp) {\n+        try {\n+            return mapper.mapper().convertValue(imp.getExt(), AMX_EXT_TYPE_REFERENCE).getBidder();\n+        } catch (IllegalArgumentException e) {\n+            throw new PreBidException(e.getMessage());\n+        }\n+    }\n+\n+    private BidRequest createOutgoingRequest(BidRequest request, String publisherId, List<Imp> imps) {\n+        return updateRequestIfPublisherIdPresent(request, publisherId).toBuilder()", "originalCommit": "1dbdf9f498fae46afac8caa6d565bb0320e82292", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAwOTIxNw==", "url": "https://github.com/prebid/prebid-server-java/pull/1004#discussion_r526009217", "bodyText": "It is ok to use org.prebid.server.util.HttpUtil#headers instead.", "author": "rpanchyk", "createdAt": "2020-11-18T11:20:04Z", "path": "src/main/java/org/prebid/server/bidder/amx/AmxBidder.java", "diffHunk": "@@ -0,0 +1,264 @@\n+package org.prebid.server.bidder.amx;\n+\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.iab.openrtb.request.App;\n+import com.iab.openrtb.request.BidRequest;\n+import com.iab.openrtb.request.Imp;\n+import com.iab.openrtb.request.Publisher;\n+import com.iab.openrtb.request.Site;\n+import com.iab.openrtb.response.Bid;\n+import com.iab.openrtb.response.BidResponse;\n+import com.iab.openrtb.response.SeatBid;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.vertx.core.MultiMap;\n+import io.vertx.core.http.HttpMethod;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.prebid.server.bidder.Bidder;\n+import org.prebid.server.bidder.amx.model.AmxBidExt;\n+import org.prebid.server.bidder.model.BidderBid;\n+import org.prebid.server.bidder.model.BidderError;\n+import org.prebid.server.bidder.model.HttpCall;\n+import org.prebid.server.bidder.model.HttpRequest;\n+import org.prebid.server.bidder.model.Result;\n+import org.prebid.server.exception.PreBidException;\n+import org.prebid.server.json.DecodeException;\n+import org.prebid.server.json.JacksonMapper;\n+import org.prebid.server.proto.openrtb.ext.ExtPrebid;\n+import org.prebid.server.proto.openrtb.ext.request.amx.ExtImpAmx;\n+import org.prebid.server.proto.openrtb.ext.response.BidType;\n+import org.prebid.server.util.HttpUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * AMX {@link Bidder} implementation.\n+ */\n+public class AmxBidder implements Bidder<BidRequest> {\n+\n+    private static final TypeReference<ExtPrebid<?, ExtImpAmx>> AMX_EXT_TYPE_REFERENCE =\n+            new TypeReference<ExtPrebid<?, ExtImpAmx>>() {\n+            };\n+\n+    private static final String ADAPTER_VERSION = \"pbs1.0\";\n+    private static final String VERSION_PARAM = \"v\";\n+    private static final String VAST_SEARCH_POINT = \"</Impression>\";\n+    private static final String VAST_IMPRESSION_FORMAT = \"<Impression><![CDATA[%s]]></Impression>\";\n+\n+    private final String endpointUrl;\n+    private final JacksonMapper mapper;\n+\n+    public AmxBidder(String endpointUrl, JacksonMapper mapper) {\n+        this.mapper = Objects.requireNonNull(mapper);\n+        this.endpointUrl = new URIBuilder()\n+                .setPath(HttpUtil.validateUrl(Objects.requireNonNull(endpointUrl)))\n+                .addParameter(VERSION_PARAM, ADAPTER_VERSION)\n+                .toString();\n+    }\n+\n+    @Override\n+    public Result<List<HttpRequest<BidRequest>>> makeHttpRequests(BidRequest request) {\n+        final List<Imp> modifiedImps = new ArrayList<>();\n+        final List<BidderError> errors = new ArrayList<>();\n+        String publisherId = null;\n+        for (Imp imp : request.getImp()) {\n+            try {\n+                final ExtImpAmx extImpAmx = parseImpExt(imp);\n+                final String tagId = extImpAmx.getTagId();\n+                if (StringUtils.isNotBlank(tagId)) {\n+                    publisherId = tagId;\n+                }\n+\n+                final String adUnitId = extImpAmx.getAdUnitId();\n+                if (StringUtils.isNotBlank(adUnitId)) {\n+                    modifiedImps.add(imp.toBuilder().tagid(adUnitId).build());\n+                }\n+            } catch (PreBidException e) {\n+                errors.add(BidderError.badInput(e.getMessage()));\n+            }\n+        }\n+\n+        final BidRequest outgoingRequest = createOutgoingRequest(request, publisherId, modifiedImps);\n+\n+        return Result.of(Collections.singletonList(\n+                HttpRequest.<BidRequest>builder()\n+                        .method(HttpMethod.POST)\n+                        .uri(endpointUrl)\n+                        .headers(headers())\n+                        .payload(outgoingRequest)\n+                        .body(mapper.encode(outgoingRequest))\n+                        .build()), errors);\n+    }\n+\n+    private ExtImpAmx parseImpExt(Imp imp) {\n+        try {\n+            return mapper.mapper().convertValue(imp.getExt(), AMX_EXT_TYPE_REFERENCE).getBidder();\n+        } catch (IllegalArgumentException e) {\n+            throw new PreBidException(e.getMessage());\n+        }\n+    }\n+\n+    private BidRequest createOutgoingRequest(BidRequest request, String publisherId, List<Imp> imps) {\n+        return updateRequestIfPublisherIdPresent(request, publisherId).toBuilder()\n+                .imp(imps)\n+                .build();\n+    }\n+\n+    private BidRequest updateRequestIfPublisherIdPresent(BidRequest request, String publisherId) {\n+        return StringUtils.isBlank(publisherId)\n+                ? request\n+                : updateRequestWithPublisherId(request, publisherId);\n+    }\n+\n+    private BidRequest updateRequestWithPublisherId(BidRequest request, String publisherId) {\n+        final BidRequest.BidRequestBuilder modifiedRequest = request.toBuilder();\n+\n+        final App app = request.getApp();\n+        if (app != null) {\n+            modifiedRequest\n+                    .app(app.toBuilder()\n+                            .publisher(resolvePublisher(app.getPublisher(), publisherId))\n+                            .build());\n+        }\n+\n+        final Site site = request.getSite();\n+        if (site != null) {\n+            modifiedRequest\n+                    .site(site.toBuilder()\n+                            .publisher(resolvePublisher(site.getPublisher(), publisherId))\n+                            .build());\n+        }\n+\n+        return modifiedRequest.build();\n+    }\n+\n+    private Publisher resolvePublisher(Publisher publisher, String publisherId) {\n+        return publisher != null\n+                ? publisher.toBuilder().id(publisherId).build()\n+                : Publisher.builder().id(publisherId).build();\n+    }\n+\n+    private MultiMap headers() {", "originalCommit": "1dbdf9f498fae46afac8caa6d565bb0320e82292", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAxMTI1MQ==", "url": "https://github.com/prebid/prebid-server-java/pull/1004#discussion_r526011251", "bodyText": "Where this exception will be thrown?", "author": "rpanchyk", "createdAt": "2020-11-18T11:23:31Z", "path": "src/main/java/org/prebid/server/bidder/amx/AmxBidder.java", "diffHunk": "@@ -0,0 +1,264 @@\n+package org.prebid.server.bidder.amx;\n+\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.iab.openrtb.request.App;\n+import com.iab.openrtb.request.BidRequest;\n+import com.iab.openrtb.request.Imp;\n+import com.iab.openrtb.request.Publisher;\n+import com.iab.openrtb.request.Site;\n+import com.iab.openrtb.response.Bid;\n+import com.iab.openrtb.response.BidResponse;\n+import com.iab.openrtb.response.SeatBid;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.vertx.core.MultiMap;\n+import io.vertx.core.http.HttpMethod;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.prebid.server.bidder.Bidder;\n+import org.prebid.server.bidder.amx.model.AmxBidExt;\n+import org.prebid.server.bidder.model.BidderBid;\n+import org.prebid.server.bidder.model.BidderError;\n+import org.prebid.server.bidder.model.HttpCall;\n+import org.prebid.server.bidder.model.HttpRequest;\n+import org.prebid.server.bidder.model.Result;\n+import org.prebid.server.exception.PreBidException;\n+import org.prebid.server.json.DecodeException;\n+import org.prebid.server.json.JacksonMapper;\n+import org.prebid.server.proto.openrtb.ext.ExtPrebid;\n+import org.prebid.server.proto.openrtb.ext.request.amx.ExtImpAmx;\n+import org.prebid.server.proto.openrtb.ext.response.BidType;\n+import org.prebid.server.util.HttpUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * AMX {@link Bidder} implementation.\n+ */\n+public class AmxBidder implements Bidder<BidRequest> {\n+\n+    private static final TypeReference<ExtPrebid<?, ExtImpAmx>> AMX_EXT_TYPE_REFERENCE =\n+            new TypeReference<ExtPrebid<?, ExtImpAmx>>() {\n+            };\n+\n+    private static final String ADAPTER_VERSION = \"pbs1.0\";\n+    private static final String VERSION_PARAM = \"v\";\n+    private static final String VAST_SEARCH_POINT = \"</Impression>\";\n+    private static final String VAST_IMPRESSION_FORMAT = \"<Impression><![CDATA[%s]]></Impression>\";\n+\n+    private final String endpointUrl;\n+    private final JacksonMapper mapper;\n+\n+    public AmxBidder(String endpointUrl, JacksonMapper mapper) {\n+        this.mapper = Objects.requireNonNull(mapper);\n+        this.endpointUrl = new URIBuilder()\n+                .setPath(HttpUtil.validateUrl(Objects.requireNonNull(endpointUrl)))\n+                .addParameter(VERSION_PARAM, ADAPTER_VERSION)\n+                .toString();\n+    }\n+\n+    @Override\n+    public Result<List<HttpRequest<BidRequest>>> makeHttpRequests(BidRequest request) {\n+        final List<Imp> modifiedImps = new ArrayList<>();\n+        final List<BidderError> errors = new ArrayList<>();\n+        String publisherId = null;\n+        for (Imp imp : request.getImp()) {\n+            try {\n+                final ExtImpAmx extImpAmx = parseImpExt(imp);\n+                final String tagId = extImpAmx.getTagId();\n+                if (StringUtils.isNotBlank(tagId)) {\n+                    publisherId = tagId;\n+                }\n+\n+                final String adUnitId = extImpAmx.getAdUnitId();\n+                if (StringUtils.isNotBlank(adUnitId)) {\n+                    modifiedImps.add(imp.toBuilder().tagid(adUnitId).build());\n+                }\n+            } catch (PreBidException e) {\n+                errors.add(BidderError.badInput(e.getMessage()));\n+            }\n+        }\n+\n+        final BidRequest outgoingRequest = createOutgoingRequest(request, publisherId, modifiedImps);\n+\n+        return Result.of(Collections.singletonList(\n+                HttpRequest.<BidRequest>builder()\n+                        .method(HttpMethod.POST)\n+                        .uri(endpointUrl)\n+                        .headers(headers())\n+                        .payload(outgoingRequest)\n+                        .body(mapper.encode(outgoingRequest))\n+                        .build()), errors);\n+    }\n+\n+    private ExtImpAmx parseImpExt(Imp imp) {\n+        try {\n+            return mapper.mapper().convertValue(imp.getExt(), AMX_EXT_TYPE_REFERENCE).getBidder();\n+        } catch (IllegalArgumentException e) {\n+            throw new PreBidException(e.getMessage());\n+        }\n+    }\n+\n+    private BidRequest createOutgoingRequest(BidRequest request, String publisherId, List<Imp> imps) {\n+        return updateRequestIfPublisherIdPresent(request, publisherId).toBuilder()\n+                .imp(imps)\n+                .build();\n+    }\n+\n+    private BidRequest updateRequestIfPublisherIdPresent(BidRequest request, String publisherId) {\n+        return StringUtils.isBlank(publisherId)\n+                ? request\n+                : updateRequestWithPublisherId(request, publisherId);\n+    }\n+\n+    private BidRequest updateRequestWithPublisherId(BidRequest request, String publisherId) {\n+        final BidRequest.BidRequestBuilder modifiedRequest = request.toBuilder();\n+\n+        final App app = request.getApp();\n+        if (app != null) {\n+            modifiedRequest\n+                    .app(app.toBuilder()\n+                            .publisher(resolvePublisher(app.getPublisher(), publisherId))\n+                            .build());\n+        }\n+\n+        final Site site = request.getSite();\n+        if (site != null) {\n+            modifiedRequest\n+                    .site(site.toBuilder()\n+                            .publisher(resolvePublisher(site.getPublisher(), publisherId))\n+                            .build());\n+        }\n+\n+        return modifiedRequest.build();\n+    }\n+\n+    private Publisher resolvePublisher(Publisher publisher, String publisherId) {\n+        return publisher != null\n+                ? publisher.toBuilder().id(publisherId).build()\n+                : Publisher.builder().id(publisherId).build();\n+    }\n+\n+    private MultiMap headers() {\n+        return MultiMap.caseInsensitiveMultiMap()\n+                .add(HttpUtil.CONTENT_TYPE_HEADER, HttpUtil.APPLICATION_JSON_CONTENT_TYPE);\n+    }\n+\n+    @Override\n+    public Result<List<BidderBid>> makeBids(HttpCall<BidRequest> httpCall, BidRequest bidRequest) {\n+        final int statusCode = httpCall.getResponse().getStatusCode();\n+        if (statusCode == HttpResponseStatus.NO_CONTENT.code()) {\n+            return Result.empty();\n+        }\n+\n+        try {\n+            final BidResponse bidResponse = mapper.decodeValue(httpCall.getResponse().getBody(), BidResponse.class);\n+            final List<BidderError> errors = new ArrayList<>();\n+            return Result.of(extractBids(bidResponse, errors), Collections.emptyList());\n+        } catch (DecodeException | PreBidException e) {\n+            return Result.emptyWithError(BidderError.badServerResponse(e.getMessage()));\n+        }\n+    }\n+\n+    private List<BidderBid> extractBids(BidResponse bidResponse, List<BidderError> errors) {\n+        if (bidResponse == null || bidResponse.getSeatbid() == null) {\n+            return Collections.emptyList();\n+        }\n+        return bidsFromResponse(bidResponse, errors);\n+    }\n+\n+    private List<BidderBid> bidsFromResponse(BidResponse bidResponse, List<BidderError> errors) {\n+        return bidResponse.getSeatbid().stream()\n+                .map(SeatBid::getBid)\n+                .filter(Objects::nonNull)\n+                .flatMap(Collection::stream)\n+                .filter(Objects::nonNull)\n+                .map(bid -> createBidderBid(bid, bidResponse.getCur(), errors))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private BidderBid createBidderBid(Bid bid, String cur, List<BidderError> errors) {\n+        AmxBidExt amxBidExt = null;\n+        try {\n+            amxBidExt = parseBidderExt(bid.getExt());\n+        } catch (PreBidException e) {\n+            errors.add(BidderError.badInput(e.getMessage()));\n+        }\n+\n+        final BidType bidType = getMediaType(amxBidExt);\n+\n+        return BidderBid.of(bidType == BidType.video ? updateVideoBid(bid, amxBidExt) : bid, bidType, cur);\n+    }\n+\n+    private AmxBidExt parseBidderExt(ObjectNode ext) {\n+        if (ext == null || StringUtils.isBlank(ext.toPrettyString())) {\n+            return AmxBidExt.of(null, null);\n+        }\n+\n+        try {\n+            return mapper.mapper().convertValue(ext, AmxBidExt.class);\n+        } catch (IllegalArgumentException e) {\n+            throw new PreBidException(e.getMessage(), e);\n+        }\n+    }\n+\n+    private static BidType getMediaType(AmxBidExt bidExt) {\n+        return StringUtils.isNotBlank(bidExt.getStartDelay())\n+                ? BidType.video\n+                : BidType.banner;\n+    }\n+\n+    private static Bid updateVideoBid(Bid bid, AmxBidExt bidExt) {\n+\n+        return bid.toBuilder()\n+                .nurl(\"\")\n+                .adm(updateAdm(bidExt, bid.getNurl(), bid.getAdm(), bid.getId()))\n+                .build();\n+    }\n+\n+    private static void validateAdm(String adm, String bidId) {\n+        if (StringUtils.isBlank(adm)) {\n+            throw new PreBidException(String.format(\"Adm should not be blank in bidder: %s\", bidId));", "originalCommit": "1dbdf9f498fae46afac8caa6d565bb0320e82292", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAxMTg3NA==", "url": "https://github.com/prebid/prebid-server-java/pull/1004#discussion_r526011874", "bodyText": "Pls call this method early, current method should make only updating.", "author": "rpanchyk", "createdAt": "2020-11-18T11:24:31Z", "path": "src/main/java/org/prebid/server/bidder/amx/AmxBidder.java", "diffHunk": "@@ -0,0 +1,264 @@\n+package org.prebid.server.bidder.amx;\n+\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.iab.openrtb.request.App;\n+import com.iab.openrtb.request.BidRequest;\n+import com.iab.openrtb.request.Imp;\n+import com.iab.openrtb.request.Publisher;\n+import com.iab.openrtb.request.Site;\n+import com.iab.openrtb.response.Bid;\n+import com.iab.openrtb.response.BidResponse;\n+import com.iab.openrtb.response.SeatBid;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.vertx.core.MultiMap;\n+import io.vertx.core.http.HttpMethod;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.client.utils.URIBuilder;\n+import org.prebid.server.bidder.Bidder;\n+import org.prebid.server.bidder.amx.model.AmxBidExt;\n+import org.prebid.server.bidder.model.BidderBid;\n+import org.prebid.server.bidder.model.BidderError;\n+import org.prebid.server.bidder.model.HttpCall;\n+import org.prebid.server.bidder.model.HttpRequest;\n+import org.prebid.server.bidder.model.Result;\n+import org.prebid.server.exception.PreBidException;\n+import org.prebid.server.json.DecodeException;\n+import org.prebid.server.json.JacksonMapper;\n+import org.prebid.server.proto.openrtb.ext.ExtPrebid;\n+import org.prebid.server.proto.openrtb.ext.request.amx.ExtImpAmx;\n+import org.prebid.server.proto.openrtb.ext.response.BidType;\n+import org.prebid.server.util.HttpUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * AMX {@link Bidder} implementation.\n+ */\n+public class AmxBidder implements Bidder<BidRequest> {\n+\n+    private static final TypeReference<ExtPrebid<?, ExtImpAmx>> AMX_EXT_TYPE_REFERENCE =\n+            new TypeReference<ExtPrebid<?, ExtImpAmx>>() {\n+            };\n+\n+    private static final String ADAPTER_VERSION = \"pbs1.0\";\n+    private static final String VERSION_PARAM = \"v\";\n+    private static final String VAST_SEARCH_POINT = \"</Impression>\";\n+    private static final String VAST_IMPRESSION_FORMAT = \"<Impression><![CDATA[%s]]></Impression>\";\n+\n+    private final String endpointUrl;\n+    private final JacksonMapper mapper;\n+\n+    public AmxBidder(String endpointUrl, JacksonMapper mapper) {\n+        this.mapper = Objects.requireNonNull(mapper);\n+        this.endpointUrl = new URIBuilder()\n+                .setPath(HttpUtil.validateUrl(Objects.requireNonNull(endpointUrl)))\n+                .addParameter(VERSION_PARAM, ADAPTER_VERSION)\n+                .toString();\n+    }\n+\n+    @Override\n+    public Result<List<HttpRequest<BidRequest>>> makeHttpRequests(BidRequest request) {\n+        final List<Imp> modifiedImps = new ArrayList<>();\n+        final List<BidderError> errors = new ArrayList<>();\n+        String publisherId = null;\n+        for (Imp imp : request.getImp()) {\n+            try {\n+                final ExtImpAmx extImpAmx = parseImpExt(imp);\n+                final String tagId = extImpAmx.getTagId();\n+                if (StringUtils.isNotBlank(tagId)) {\n+                    publisherId = tagId;\n+                }\n+\n+                final String adUnitId = extImpAmx.getAdUnitId();\n+                if (StringUtils.isNotBlank(adUnitId)) {\n+                    modifiedImps.add(imp.toBuilder().tagid(adUnitId).build());\n+                }\n+            } catch (PreBidException e) {\n+                errors.add(BidderError.badInput(e.getMessage()));\n+            }\n+        }\n+\n+        final BidRequest outgoingRequest = createOutgoingRequest(request, publisherId, modifiedImps);\n+\n+        return Result.of(Collections.singletonList(\n+                HttpRequest.<BidRequest>builder()\n+                        .method(HttpMethod.POST)\n+                        .uri(endpointUrl)\n+                        .headers(headers())\n+                        .payload(outgoingRequest)\n+                        .body(mapper.encode(outgoingRequest))\n+                        .build()), errors);\n+    }\n+\n+    private ExtImpAmx parseImpExt(Imp imp) {\n+        try {\n+            return mapper.mapper().convertValue(imp.getExt(), AMX_EXT_TYPE_REFERENCE).getBidder();\n+        } catch (IllegalArgumentException e) {\n+            throw new PreBidException(e.getMessage());\n+        }\n+    }\n+\n+    private BidRequest createOutgoingRequest(BidRequest request, String publisherId, List<Imp> imps) {\n+        return updateRequestIfPublisherIdPresent(request, publisherId).toBuilder()\n+                .imp(imps)\n+                .build();\n+    }\n+\n+    private BidRequest updateRequestIfPublisherIdPresent(BidRequest request, String publisherId) {\n+        return StringUtils.isBlank(publisherId)\n+                ? request\n+                : updateRequestWithPublisherId(request, publisherId);\n+    }\n+\n+    private BidRequest updateRequestWithPublisherId(BidRequest request, String publisherId) {\n+        final BidRequest.BidRequestBuilder modifiedRequest = request.toBuilder();\n+\n+        final App app = request.getApp();\n+        if (app != null) {\n+            modifiedRequest\n+                    .app(app.toBuilder()\n+                            .publisher(resolvePublisher(app.getPublisher(), publisherId))\n+                            .build());\n+        }\n+\n+        final Site site = request.getSite();\n+        if (site != null) {\n+            modifiedRequest\n+                    .site(site.toBuilder()\n+                            .publisher(resolvePublisher(site.getPublisher(), publisherId))\n+                            .build());\n+        }\n+\n+        return modifiedRequest.build();\n+    }\n+\n+    private Publisher resolvePublisher(Publisher publisher, String publisherId) {\n+        return publisher != null\n+                ? publisher.toBuilder().id(publisherId).build()\n+                : Publisher.builder().id(publisherId).build();\n+    }\n+\n+    private MultiMap headers() {\n+        return MultiMap.caseInsensitiveMultiMap()\n+                .add(HttpUtil.CONTENT_TYPE_HEADER, HttpUtil.APPLICATION_JSON_CONTENT_TYPE);\n+    }\n+\n+    @Override\n+    public Result<List<BidderBid>> makeBids(HttpCall<BidRequest> httpCall, BidRequest bidRequest) {\n+        final int statusCode = httpCall.getResponse().getStatusCode();\n+        if (statusCode == HttpResponseStatus.NO_CONTENT.code()) {\n+            return Result.empty();\n+        }\n+\n+        try {\n+            final BidResponse bidResponse = mapper.decodeValue(httpCall.getResponse().getBody(), BidResponse.class);\n+            final List<BidderError> errors = new ArrayList<>();\n+            return Result.of(extractBids(bidResponse, errors), Collections.emptyList());\n+        } catch (DecodeException | PreBidException e) {\n+            return Result.emptyWithError(BidderError.badServerResponse(e.getMessage()));\n+        }\n+    }\n+\n+    private List<BidderBid> extractBids(BidResponse bidResponse, List<BidderError> errors) {\n+        if (bidResponse == null || bidResponse.getSeatbid() == null) {\n+            return Collections.emptyList();\n+        }\n+        return bidsFromResponse(bidResponse, errors);\n+    }\n+\n+    private List<BidderBid> bidsFromResponse(BidResponse bidResponse, List<BidderError> errors) {\n+        return bidResponse.getSeatbid().stream()\n+                .map(SeatBid::getBid)\n+                .filter(Objects::nonNull)\n+                .flatMap(Collection::stream)\n+                .filter(Objects::nonNull)\n+                .map(bid -> createBidderBid(bid, bidResponse.getCur(), errors))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private BidderBid createBidderBid(Bid bid, String cur, List<BidderError> errors) {\n+        AmxBidExt amxBidExt = null;\n+        try {\n+            amxBidExt = parseBidderExt(bid.getExt());\n+        } catch (PreBidException e) {\n+            errors.add(BidderError.badInput(e.getMessage()));\n+        }\n+\n+        final BidType bidType = getMediaType(amxBidExt);\n+\n+        return BidderBid.of(bidType == BidType.video ? updateVideoBid(bid, amxBidExt) : bid, bidType, cur);\n+    }\n+\n+    private AmxBidExt parseBidderExt(ObjectNode ext) {\n+        if (ext == null || StringUtils.isBlank(ext.toPrettyString())) {\n+            return AmxBidExt.of(null, null);\n+        }\n+\n+        try {\n+            return mapper.mapper().convertValue(ext, AmxBidExt.class);\n+        } catch (IllegalArgumentException e) {\n+            throw new PreBidException(e.getMessage(), e);\n+        }\n+    }\n+\n+    private static BidType getMediaType(AmxBidExt bidExt) {\n+        return StringUtils.isNotBlank(bidExt.getStartDelay())\n+                ? BidType.video\n+                : BidType.banner;\n+    }\n+\n+    private static Bid updateVideoBid(Bid bid, AmxBidExt bidExt) {\n+\n+        return bid.toBuilder()\n+                .nurl(\"\")\n+                .adm(updateAdm(bidExt, bid.getNurl(), bid.getAdm(), bid.getId()))\n+                .build();\n+    }\n+\n+    private static void validateAdm(String adm, String bidId) {\n+        if (StringUtils.isBlank(adm)) {\n+            throw new PreBidException(String.format(\"Adm should not be blank in bidder: %s\", bidId));\n+        }\n+\n+        if (!adm.contains(VAST_SEARCH_POINT)) {\n+            throw new PreBidException(String.format(\"Adm should contain vast search point in bidder: %s\", bidId));\n+        }\n+    }\n+\n+    private static String updateAdm(AmxBidExt bidExt, String nurl, String adm, String bidId) {\n+        final StringBuilder updatedAdm = new StringBuilder();\n+        validateAdm(adm, bidId);", "originalCommit": "1dbdf9f498fae46afac8caa6d565bb0320e82292", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAxNTQ3Nw==", "url": "https://github.com/prebid/prebid-server-java/pull/1004#discussion_r526015477", "bodyText": "Don't think we really want to add additional logic for field representing in POJO models.\nLet's keep it as simple as possible.\nIn any case bidder's implementation should care.", "author": "rpanchyk", "createdAt": "2020-11-18T11:30:33Z", "path": "src/main/java/org/prebid/server/proto/openrtb/ext/request/amx/ExtImpAmx.java", "diffHunk": "@@ -0,0 +1,19 @@\n+package org.prebid.server.proto.openrtb.ext.request.amx;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import lombok.AllArgsConstructor;\n+import lombok.Value;\n+\n+@AllArgsConstructor(staticName = \"of\")\n+@Value\n+public class ExtImpAmx {\n+\n+    @JsonProperty(\"tagId\")\n+    @JsonInclude(JsonInclude.Include.NON_EMPTY)", "originalCommit": "1dbdf9f498fae46afac8caa6d565bb0320e82292", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7589065f2c80dd1aa9b80acafacc7325e91fd6e3", "url": "https://github.com/prebid/prebid-server-java/commit/7589065f2c80dd1aa9b80acafacc7325e91fd6e3", "message": "Fixes after review", "committedDate": "2020-11-18T12:18:35Z", "type": "commit"}, {"oid": "53eba69478523c694816f5f3ffc95f807298c431", "url": "https://github.com/prebid/prebid-server-java/commit/53eba69478523c694816f5f3ffc95f807298c431", "message": "Merge branch 'master' into amx_bidder/add", "committedDate": "2020-11-18T13:10:45Z", "type": "commit"}, {"oid": "4a7ec99e47ea73c8e29e87d9bcd33a9aad15275a", "url": "https://github.com/prebid/prebid-server-java/commit/4a7ec99e47ea73c8e29e87d9bcd33a9aad15275a", "message": "Fixes after review", "committedDate": "2020-11-18T14:29:20Z", "type": "commit"}]}