{"pr_number": 583, "pr_title": "Add Applogy bidder", "pr_createdAt": "2020-01-13T11:50:39Z", "pr_url": "https://github.com/prebid/prebid-server-java/pull/583", "timeline": [{"oid": "28e283ac3fa8219b714828e537405536ad4c4c69", "url": "https://github.com/prebid/prebid-server-java/commit/28e283ac3fa8219b714828e537405536ad4c4c69", "message": "Add Applogy bidder\n\n-Develop Bidder implementation\n-Writing Test", "committedDate": "2020-01-13T09:49:45Z", "type": "commit"}, {"oid": "c5a09970fcd38883d3e6939b87341da9eda8dd46", "url": "https://github.com/prebid/prebid-server-java/commit/c5a09970fcd38883d3e6939b87341da9eda8dd46", "message": "Add Applogy bidder\n\n-Fix configuration\n-Tests added", "committedDate": "2020-01-13T11:42:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjEzODM2Ng==", "url": "https://github.com/prebid/prebid-server-java/pull/583#discussion_r366138366", "bodyText": "Please move the class constant above instance field endpointUrl to match the project style.", "author": "RossGoncharuk", "createdAt": "2020-01-14T03:30:59Z", "path": "src/main/java/org/prebid/server/bidder/applogy/ApplogyBidder.java", "diffHunk": "@@ -0,0 +1,171 @@\n+package org.prebid.server.bidder.applogy;\n+\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.iab.openrtb.request.Banner;\n+import com.iab.openrtb.request.BidRequest;\n+import com.iab.openrtb.request.Format;\n+import com.iab.openrtb.request.Imp;\n+import com.iab.openrtb.response.BidResponse;\n+import com.iab.openrtb.response.SeatBid;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.vertx.core.MultiMap;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.json.DecodeException;\n+import io.vertx.core.json.Json;\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.prebid.server.bidder.Bidder;\n+import org.prebid.server.bidder.model.BidderBid;\n+import org.prebid.server.bidder.model.BidderError;\n+import org.prebid.server.bidder.model.HttpCall;\n+import org.prebid.server.bidder.model.HttpRequest;\n+import org.prebid.server.bidder.model.Result;\n+import org.prebid.server.exception.PreBidException;\n+import org.prebid.server.proto.openrtb.ext.request.applogy.ExtImpApplogy;\n+import org.prebid.server.proto.openrtb.ext.response.BidType;\n+import org.prebid.server.util.HttpUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class ApplogyBidder implements Bidder<BidRequest> {\n+\n+    private final String endpointUrl;\n+\n+    private static final String DEFAULT_BID_CURRENCY = \"USD\";", "originalCommit": "c5a09970fcd38883d3e6939b87341da9eda8dd46", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjE0MDcyMg==", "url": "https://github.com/prebid/prebid-server-java/pull/583#discussion_r366140722", "bodyText": "I'm sorry, but you got it all wrong.\nCheck the GO PR - they basically create HttpRequest<> in the loop of impressions i.e. they create a separate request for each impression - while you return a singletonList - it should be a list of HttpRequest<BidRequest>, where each BidRequest contains only one impression.\nThe same goes for parsing Impression Extension - you need to do it in the same loop, as the extension's field token is used for request url - so each request would use the token from each impression.\nIn general, this is quite a standard case when bidder creates multiple requests from one request (usually a request per impression). For example - check UnrulyBidder implementation - it's almost the same idea.", "author": "RossGoncharuk", "createdAt": "2020-01-14T03:45:24Z", "path": "src/main/java/org/prebid/server/bidder/applogy/ApplogyBidder.java", "diffHunk": "@@ -0,0 +1,171 @@\n+package org.prebid.server.bidder.applogy;\n+\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.iab.openrtb.request.Banner;\n+import com.iab.openrtb.request.BidRequest;\n+import com.iab.openrtb.request.Format;\n+import com.iab.openrtb.request.Imp;\n+import com.iab.openrtb.response.BidResponse;\n+import com.iab.openrtb.response.SeatBid;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.vertx.core.MultiMap;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.json.DecodeException;\n+import io.vertx.core.json.Json;\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.prebid.server.bidder.Bidder;\n+import org.prebid.server.bidder.model.BidderBid;\n+import org.prebid.server.bidder.model.BidderError;\n+import org.prebid.server.bidder.model.HttpCall;\n+import org.prebid.server.bidder.model.HttpRequest;\n+import org.prebid.server.bidder.model.Result;\n+import org.prebid.server.exception.PreBidException;\n+import org.prebid.server.proto.openrtb.ext.request.applogy.ExtImpApplogy;\n+import org.prebid.server.proto.openrtb.ext.response.BidType;\n+import org.prebid.server.util.HttpUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class ApplogyBidder implements Bidder<BidRequest> {\n+\n+    private final String endpointUrl;\n+\n+    private static final String DEFAULT_BID_CURRENCY = \"USD\";\n+\n+    public ApplogyBidder(String endpointUrl) {\n+        this.endpointUrl = HttpUtil.validateUrl(Objects.requireNonNull(endpointUrl));\n+    }\n+\n+    @Override\n+    public Result<List<HttpRequest<BidRequest>>> makeHttpRequests(BidRequest request) {\n+        final List<BidderError> errors = new ArrayList<>();\n+        final List<Imp> validImps = new ArrayList<>();\n+        for (Imp imp : request.getImp()) {\n+            if (imp.getBanner() == null && imp.getVideo() == null && imp.getXNative() == null) {\n+                errors.add(BidderError.badInput(\n+                        String.format(\"Applogy only supports banner, video and native media types. Ignoring imp id=%s\",\n+                                imp.getId())));\n+                continue;\n+            }\n+            validImps.add(processImp(imp));", "originalCommit": "c5a09970fcd38883d3e6939b87341da9eda8dd46", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjE0MTE0MQ==", "url": "https://github.com/prebid/prebid-server-java/pull/583#discussion_r366141141", "bodyText": "This should be done in the loop of impressions for each impression, not just the first one. Also, you can pass imp.getExt() i.e. ObjectNode object, instead of whole Imp object - you only need one field from it - so pass the data you need.", "author": "RossGoncharuk", "createdAt": "2020-01-14T03:47:44Z", "path": "src/main/java/org/prebid/server/bidder/applogy/ApplogyBidder.java", "diffHunk": "@@ -0,0 +1,171 @@\n+package org.prebid.server.bidder.applogy;\n+\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.iab.openrtb.request.Banner;\n+import com.iab.openrtb.request.BidRequest;\n+import com.iab.openrtb.request.Format;\n+import com.iab.openrtb.request.Imp;\n+import com.iab.openrtb.response.BidResponse;\n+import com.iab.openrtb.response.SeatBid;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.vertx.core.MultiMap;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.json.DecodeException;\n+import io.vertx.core.json.Json;\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.prebid.server.bidder.Bidder;\n+import org.prebid.server.bidder.model.BidderBid;\n+import org.prebid.server.bidder.model.BidderError;\n+import org.prebid.server.bidder.model.HttpCall;\n+import org.prebid.server.bidder.model.HttpRequest;\n+import org.prebid.server.bidder.model.Result;\n+import org.prebid.server.exception.PreBidException;\n+import org.prebid.server.proto.openrtb.ext.request.applogy.ExtImpApplogy;\n+import org.prebid.server.proto.openrtb.ext.response.BidType;\n+import org.prebid.server.util.HttpUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class ApplogyBidder implements Bidder<BidRequest> {\n+\n+    private final String endpointUrl;\n+\n+    private static final String DEFAULT_BID_CURRENCY = \"USD\";\n+\n+    public ApplogyBidder(String endpointUrl) {\n+        this.endpointUrl = HttpUtil.validateUrl(Objects.requireNonNull(endpointUrl));\n+    }\n+\n+    @Override\n+    public Result<List<HttpRequest<BidRequest>>> makeHttpRequests(BidRequest request) {\n+        final List<BidderError> errors = new ArrayList<>();\n+        final List<Imp> validImps = new ArrayList<>();\n+        for (Imp imp : request.getImp()) {\n+            if (imp.getBanner() == null && imp.getVideo() == null && imp.getXNative() == null) {\n+                errors.add(BidderError.badInput(\n+                        String.format(\"Applogy only supports banner, video and native media types. Ignoring imp id=%s\",\n+                                imp.getId())));\n+                continue;\n+            }\n+            validImps.add(processImp(imp));\n+        }\n+\n+        if (validImps.isEmpty()) {\n+            errors.add(BidderError.badInput(\"No valid impressions in the bid request\"));\n+            return Result.of(Collections.emptyList(), errors);\n+        }\n+\n+        final ExtImpApplogy firstImpExt;\n+        try {\n+            firstImpExt = parseAndValidateImpExt(validImps.get(0));", "originalCommit": "c5a09970fcd38883d3e6939b87341da9eda8dd46", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjE0MzAxMg==", "url": "https://github.com/prebid/prebid-server-java/pull/583#discussion_r366143012", "bodyText": "I've said it before, but just in case - this also should be done for each impression - it could be within the same loop (like LifestreetBidder) or map List<BidRequest> to List<HttpRequest<BidRequest>> in stream after loop (like UnrulyBidder`). Hope you get the point.", "author": "RossGoncharuk", "createdAt": "2020-01-14T03:57:56Z", "path": "src/main/java/org/prebid/server/bidder/applogy/ApplogyBidder.java", "diffHunk": "@@ -0,0 +1,171 @@\n+package org.prebid.server.bidder.applogy;\n+\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.iab.openrtb.request.Banner;\n+import com.iab.openrtb.request.BidRequest;\n+import com.iab.openrtb.request.Format;\n+import com.iab.openrtb.request.Imp;\n+import com.iab.openrtb.response.BidResponse;\n+import com.iab.openrtb.response.SeatBid;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.vertx.core.MultiMap;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.json.DecodeException;\n+import io.vertx.core.json.Json;\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.prebid.server.bidder.Bidder;\n+import org.prebid.server.bidder.model.BidderBid;\n+import org.prebid.server.bidder.model.BidderError;\n+import org.prebid.server.bidder.model.HttpCall;\n+import org.prebid.server.bidder.model.HttpRequest;\n+import org.prebid.server.bidder.model.Result;\n+import org.prebid.server.exception.PreBidException;\n+import org.prebid.server.proto.openrtb.ext.request.applogy.ExtImpApplogy;\n+import org.prebid.server.proto.openrtb.ext.response.BidType;\n+import org.prebid.server.util.HttpUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class ApplogyBidder implements Bidder<BidRequest> {\n+\n+    private final String endpointUrl;\n+\n+    private static final String DEFAULT_BID_CURRENCY = \"USD\";\n+\n+    public ApplogyBidder(String endpointUrl) {\n+        this.endpointUrl = HttpUtil.validateUrl(Objects.requireNonNull(endpointUrl));\n+    }\n+\n+    @Override\n+    public Result<List<HttpRequest<BidRequest>>> makeHttpRequests(BidRequest request) {\n+        final List<BidderError> errors = new ArrayList<>();\n+        final List<Imp> validImps = new ArrayList<>();\n+        for (Imp imp : request.getImp()) {\n+            if (imp.getBanner() == null && imp.getVideo() == null && imp.getXNative() == null) {\n+                errors.add(BidderError.badInput(\n+                        String.format(\"Applogy only supports banner, video and native media types. Ignoring imp id=%s\",\n+                                imp.getId())));\n+                continue;\n+            }\n+            validImps.add(processImp(imp));\n+        }\n+\n+        if (validImps.isEmpty()) {\n+            errors.add(BidderError.badInput(\"No valid impressions in the bid request\"));\n+            return Result.of(Collections.emptyList(), errors);\n+        }\n+\n+        final ExtImpApplogy firstImpExt;\n+        try {\n+            firstImpExt = parseAndValidateImpExt(validImps.get(0));\n+        } catch (PreBidException e) {\n+            return Result.emptyWithError(BidderError.badInput(e.getMessage()));\n+        }\n+\n+        final BidRequest outgoingRequest = request.toBuilder().imp(validImps).build();\n+        final String body = Json.encode(outgoingRequest);\n+        final String requestUrl = endpointUrl + \"/\" + firstImpExt.getToken();", "originalCommit": "c5a09970fcd38883d3e6939b87341da9eda8dd46", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjE0MzE0NA==", "url": "https://github.com/prebid/prebid-server-java/pull/583#discussion_r366143144", "bodyText": "No point to create a method that just calls another method - simply call HttpUtil.headers() directly.", "author": "RossGoncharuk", "createdAt": "2020-01-14T03:58:34Z", "path": "src/main/java/org/prebid/server/bidder/applogy/ApplogyBidder.java", "diffHunk": "@@ -0,0 +1,171 @@\n+package org.prebid.server.bidder.applogy;\n+\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.iab.openrtb.request.Banner;\n+import com.iab.openrtb.request.BidRequest;\n+import com.iab.openrtb.request.Format;\n+import com.iab.openrtb.request.Imp;\n+import com.iab.openrtb.response.BidResponse;\n+import com.iab.openrtb.response.SeatBid;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.vertx.core.MultiMap;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.json.DecodeException;\n+import io.vertx.core.json.Json;\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.prebid.server.bidder.Bidder;\n+import org.prebid.server.bidder.model.BidderBid;\n+import org.prebid.server.bidder.model.BidderError;\n+import org.prebid.server.bidder.model.HttpCall;\n+import org.prebid.server.bidder.model.HttpRequest;\n+import org.prebid.server.bidder.model.Result;\n+import org.prebid.server.exception.PreBidException;\n+import org.prebid.server.proto.openrtb.ext.request.applogy.ExtImpApplogy;\n+import org.prebid.server.proto.openrtb.ext.response.BidType;\n+import org.prebid.server.util.HttpUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class ApplogyBidder implements Bidder<BidRequest> {\n+\n+    private final String endpointUrl;\n+\n+    private static final String DEFAULT_BID_CURRENCY = \"USD\";\n+\n+    public ApplogyBidder(String endpointUrl) {\n+        this.endpointUrl = HttpUtil.validateUrl(Objects.requireNonNull(endpointUrl));\n+    }\n+\n+    @Override\n+    public Result<List<HttpRequest<BidRequest>>> makeHttpRequests(BidRequest request) {\n+        final List<BidderError> errors = new ArrayList<>();\n+        final List<Imp> validImps = new ArrayList<>();\n+        for (Imp imp : request.getImp()) {\n+            if (imp.getBanner() == null && imp.getVideo() == null && imp.getXNative() == null) {\n+                errors.add(BidderError.badInput(\n+                        String.format(\"Applogy only supports banner, video and native media types. Ignoring imp id=%s\",\n+                                imp.getId())));\n+                continue;\n+            }\n+            validImps.add(processImp(imp));\n+        }\n+\n+        if (validImps.isEmpty()) {\n+            errors.add(BidderError.badInput(\"No valid impressions in the bid request\"));\n+            return Result.of(Collections.emptyList(), errors);\n+        }\n+\n+        final ExtImpApplogy firstImpExt;\n+        try {\n+            firstImpExt = parseAndValidateImpExt(validImps.get(0));\n+        } catch (PreBidException e) {\n+            return Result.emptyWithError(BidderError.badInput(e.getMessage()));\n+        }\n+\n+        final BidRequest outgoingRequest = request.toBuilder().imp(validImps).build();\n+        final String body = Json.encode(outgoingRequest);\n+        final String requestUrl = endpointUrl + \"/\" + firstImpExt.getToken();\n+        final MultiMap headers = resolveHeaders();\n+\n+        return Result.of(Collections.singletonList(\n+                HttpRequest.<BidRequest>builder()\n+                        .method(HttpMethod.POST)\n+                        .uri(requestUrl)\n+                        .headers(headers)\n+                        .payload(outgoingRequest)\n+                        .body(body)\n+                        .build()),\n+                errors);\n+    }\n+\n+    private MultiMap resolveHeaders() {\n+        return HttpUtil.headers();", "originalCommit": "c5a09970fcd38883d3e6939b87341da9eda8dd46", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjUwNTI4OQ==", "url": "https://github.com/prebid/prebid-server-java/pull/583#discussion_r366505289", "bodyText": "Please address this comment", "author": "RossGoncharuk", "createdAt": "2020-01-14T18:37:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjE0MzE0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjE0MzUwMg==", "url": "https://github.com/prebid/prebid-server-java/pull/583#discussion_r366143502", "bodyText": "As I've previously noted - pass only ObjectNode ext from imp.getExt(). You don't need other imp fields here.", "author": "RossGoncharuk", "createdAt": "2020-01-14T04:00:30Z", "path": "src/main/java/org/prebid/server/bidder/applogy/ApplogyBidder.java", "diffHunk": "@@ -0,0 +1,171 @@\n+package org.prebid.server.bidder.applogy;\n+\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.iab.openrtb.request.Banner;\n+import com.iab.openrtb.request.BidRequest;\n+import com.iab.openrtb.request.Format;\n+import com.iab.openrtb.request.Imp;\n+import com.iab.openrtb.response.BidResponse;\n+import com.iab.openrtb.response.SeatBid;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.vertx.core.MultiMap;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.json.DecodeException;\n+import io.vertx.core.json.Json;\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.prebid.server.bidder.Bidder;\n+import org.prebid.server.bidder.model.BidderBid;\n+import org.prebid.server.bidder.model.BidderError;\n+import org.prebid.server.bidder.model.HttpCall;\n+import org.prebid.server.bidder.model.HttpRequest;\n+import org.prebid.server.bidder.model.Result;\n+import org.prebid.server.exception.PreBidException;\n+import org.prebid.server.proto.openrtb.ext.request.applogy.ExtImpApplogy;\n+import org.prebid.server.proto.openrtb.ext.response.BidType;\n+import org.prebid.server.util.HttpUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class ApplogyBidder implements Bidder<BidRequest> {\n+\n+    private final String endpointUrl;\n+\n+    private static final String DEFAULT_BID_CURRENCY = \"USD\";\n+\n+    public ApplogyBidder(String endpointUrl) {\n+        this.endpointUrl = HttpUtil.validateUrl(Objects.requireNonNull(endpointUrl));\n+    }\n+\n+    @Override\n+    public Result<List<HttpRequest<BidRequest>>> makeHttpRequests(BidRequest request) {\n+        final List<BidderError> errors = new ArrayList<>();\n+        final List<Imp> validImps = new ArrayList<>();\n+        for (Imp imp : request.getImp()) {\n+            if (imp.getBanner() == null && imp.getVideo() == null && imp.getXNative() == null) {\n+                errors.add(BidderError.badInput(\n+                        String.format(\"Applogy only supports banner, video and native media types. Ignoring imp id=%s\",\n+                                imp.getId())));\n+                continue;\n+            }\n+            validImps.add(processImp(imp));\n+        }\n+\n+        if (validImps.isEmpty()) {\n+            errors.add(BidderError.badInput(\"No valid impressions in the bid request\"));\n+            return Result.of(Collections.emptyList(), errors);\n+        }\n+\n+        final ExtImpApplogy firstImpExt;\n+        try {\n+            firstImpExt = parseAndValidateImpExt(validImps.get(0));\n+        } catch (PreBidException e) {\n+            return Result.emptyWithError(BidderError.badInput(e.getMessage()));\n+        }\n+\n+        final BidRequest outgoingRequest = request.toBuilder().imp(validImps).build();\n+        final String body = Json.encode(outgoingRequest);\n+        final String requestUrl = endpointUrl + \"/\" + firstImpExt.getToken();\n+        final MultiMap headers = resolveHeaders();\n+\n+        return Result.of(Collections.singletonList(\n+                HttpRequest.<BidRequest>builder()\n+                        .method(HttpMethod.POST)\n+                        .uri(requestUrl)\n+                        .headers(headers)\n+                        .payload(outgoingRequest)\n+                        .body(body)\n+                        .build()),\n+                errors);\n+    }\n+\n+    private MultiMap resolveHeaders() {\n+        return HttpUtil.headers();\n+    }\n+\n+    private ExtImpApplogy parseAndValidateImpExt(Imp imp) {", "originalCommit": "c5a09970fcd38883d3e6939b87341da9eda8dd46", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjUwNTE5OA==", "url": "https://github.com/prebid/prebid-server-java/pull/583#discussion_r366505198", "bodyText": "Please address this comment.", "author": "RossGoncharuk", "createdAt": "2020-01-14T18:37:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjE0MzUwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjE0NDE4MA==", "url": "https://github.com/prebid/prebid-server-java/pull/583#discussion_r366144180", "bodyText": "In go they also have a == 0 check for banner Width and Height, and it should be a || (OR) condition, not AND.\nRemove CollectionUtils.isNotEmpty(banner.getFormat()) condition from here. We should check if they ARE empty before getting the first Format, and if they ARE empty - throw the exception - just like they have it in GO.", "author": "RossGoncharuk", "createdAt": "2020-01-14T04:04:30Z", "path": "src/main/java/org/prebid/server/bidder/applogy/ApplogyBidder.java", "diffHunk": "@@ -0,0 +1,171 @@\n+package org.prebid.server.bidder.applogy;\n+\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.iab.openrtb.request.Banner;\n+import com.iab.openrtb.request.BidRequest;\n+import com.iab.openrtb.request.Format;\n+import com.iab.openrtb.request.Imp;\n+import com.iab.openrtb.response.BidResponse;\n+import com.iab.openrtb.response.SeatBid;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.vertx.core.MultiMap;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.json.DecodeException;\n+import io.vertx.core.json.Json;\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.prebid.server.bidder.Bidder;\n+import org.prebid.server.bidder.model.BidderBid;\n+import org.prebid.server.bidder.model.BidderError;\n+import org.prebid.server.bidder.model.HttpCall;\n+import org.prebid.server.bidder.model.HttpRequest;\n+import org.prebid.server.bidder.model.Result;\n+import org.prebid.server.exception.PreBidException;\n+import org.prebid.server.proto.openrtb.ext.request.applogy.ExtImpApplogy;\n+import org.prebid.server.proto.openrtb.ext.response.BidType;\n+import org.prebid.server.util.HttpUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class ApplogyBidder implements Bidder<BidRequest> {\n+\n+    private final String endpointUrl;\n+\n+    private static final String DEFAULT_BID_CURRENCY = \"USD\";\n+\n+    public ApplogyBidder(String endpointUrl) {\n+        this.endpointUrl = HttpUtil.validateUrl(Objects.requireNonNull(endpointUrl));\n+    }\n+\n+    @Override\n+    public Result<List<HttpRequest<BidRequest>>> makeHttpRequests(BidRequest request) {\n+        final List<BidderError> errors = new ArrayList<>();\n+        final List<Imp> validImps = new ArrayList<>();\n+        for (Imp imp : request.getImp()) {\n+            if (imp.getBanner() == null && imp.getVideo() == null && imp.getXNative() == null) {\n+                errors.add(BidderError.badInput(\n+                        String.format(\"Applogy only supports banner, video and native media types. Ignoring imp id=%s\",\n+                                imp.getId())));\n+                continue;\n+            }\n+            validImps.add(processImp(imp));\n+        }\n+\n+        if (validImps.isEmpty()) {\n+            errors.add(BidderError.badInput(\"No valid impressions in the bid request\"));\n+            return Result.of(Collections.emptyList(), errors);\n+        }\n+\n+        final ExtImpApplogy firstImpExt;\n+        try {\n+            firstImpExt = parseAndValidateImpExt(validImps.get(0));\n+        } catch (PreBidException e) {\n+            return Result.emptyWithError(BidderError.badInput(e.getMessage()));\n+        }\n+\n+        final BidRequest outgoingRequest = request.toBuilder().imp(validImps).build();\n+        final String body = Json.encode(outgoingRequest);\n+        final String requestUrl = endpointUrl + \"/\" + firstImpExt.getToken();\n+        final MultiMap headers = resolveHeaders();\n+\n+        return Result.of(Collections.singletonList(\n+                HttpRequest.<BidRequest>builder()\n+                        .method(HttpMethod.POST)\n+                        .uri(requestUrl)\n+                        .headers(headers)\n+                        .payload(outgoingRequest)\n+                        .body(body)\n+                        .build()),\n+                errors);\n+    }\n+\n+    private MultiMap resolveHeaders() {\n+        return HttpUtil.headers();\n+    }\n+\n+    private ExtImpApplogy parseAndValidateImpExt(Imp imp) {\n+        final ExtImpApplogy extImpApplogy;\n+        try {\n+            extImpApplogy = Json.mapper.convertValue(imp.getExt().get(\"bidder\"), ExtImpApplogy.class);\n+        } catch (IllegalArgumentException e) {\n+            throw new PreBidException(e.getMessage(), e);\n+        }\n+\n+        if (StringUtils.isBlank(extImpApplogy.getToken())) {\n+            throw new PreBidException(\"token is empty\");\n+        }\n+        return extImpApplogy;\n+    }\n+\n+    private Imp processImp(Imp imp) {\n+        Banner banner = imp.getBanner();\n+        if (banner != null) {\n+            if (banner.getH() == null && banner.getW() == null && CollectionUtils.isNotEmpty(banner.getFormat())) {", "originalCommit": "c5a09970fcd38883d3e6939b87341da9eda8dd46", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjE0Njg3OQ==", "url": "https://github.com/prebid/prebid-server-java/pull/583#discussion_r366146879", "bodyText": "No need for else if when you have a return in previous condition. You can just keep 3 if statements, since each of them exits the method when true.\nAlso, you should throw/add an error when no bid type matched, just like they do in GO, and skip that bid. Check how I and @DGarbar did it in this PR - https://github.com/rubicon-project/prebid-server-java/pull/553/files in KubientBidder line 90 and 101, and check my second comment to his PR.\nBasically, you need to pass an errors list and add an error to it whenever bid type was not matched, while returning a null instead of BidderBid object, so you can then filter these nulls out.", "author": "RossGoncharuk", "createdAt": "2020-01-14T04:22:12Z", "path": "src/main/java/org/prebid/server/bidder/applogy/ApplogyBidder.java", "diffHunk": "@@ -0,0 +1,171 @@\n+package org.prebid.server.bidder.applogy;\n+\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.iab.openrtb.request.Banner;\n+import com.iab.openrtb.request.BidRequest;\n+import com.iab.openrtb.request.Format;\n+import com.iab.openrtb.request.Imp;\n+import com.iab.openrtb.response.BidResponse;\n+import com.iab.openrtb.response.SeatBid;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.vertx.core.MultiMap;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.json.DecodeException;\n+import io.vertx.core.json.Json;\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.prebid.server.bidder.Bidder;\n+import org.prebid.server.bidder.model.BidderBid;\n+import org.prebid.server.bidder.model.BidderError;\n+import org.prebid.server.bidder.model.HttpCall;\n+import org.prebid.server.bidder.model.HttpRequest;\n+import org.prebid.server.bidder.model.Result;\n+import org.prebid.server.exception.PreBidException;\n+import org.prebid.server.proto.openrtb.ext.request.applogy.ExtImpApplogy;\n+import org.prebid.server.proto.openrtb.ext.response.BidType;\n+import org.prebid.server.util.HttpUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class ApplogyBidder implements Bidder<BidRequest> {\n+\n+    private final String endpointUrl;\n+\n+    private static final String DEFAULT_BID_CURRENCY = \"USD\";\n+\n+    public ApplogyBidder(String endpointUrl) {\n+        this.endpointUrl = HttpUtil.validateUrl(Objects.requireNonNull(endpointUrl));\n+    }\n+\n+    @Override\n+    public Result<List<HttpRequest<BidRequest>>> makeHttpRequests(BidRequest request) {\n+        final List<BidderError> errors = new ArrayList<>();\n+        final List<Imp> validImps = new ArrayList<>();\n+        for (Imp imp : request.getImp()) {\n+            if (imp.getBanner() == null && imp.getVideo() == null && imp.getXNative() == null) {\n+                errors.add(BidderError.badInput(\n+                        String.format(\"Applogy only supports banner, video and native media types. Ignoring imp id=%s\",\n+                                imp.getId())));\n+                continue;\n+            }\n+            validImps.add(processImp(imp));\n+        }\n+\n+        if (validImps.isEmpty()) {\n+            errors.add(BidderError.badInput(\"No valid impressions in the bid request\"));\n+            return Result.of(Collections.emptyList(), errors);\n+        }\n+\n+        final ExtImpApplogy firstImpExt;\n+        try {\n+            firstImpExt = parseAndValidateImpExt(validImps.get(0));\n+        } catch (PreBidException e) {\n+            return Result.emptyWithError(BidderError.badInput(e.getMessage()));\n+        }\n+\n+        final BidRequest outgoingRequest = request.toBuilder().imp(validImps).build();\n+        final String body = Json.encode(outgoingRequest);\n+        final String requestUrl = endpointUrl + \"/\" + firstImpExt.getToken();\n+        final MultiMap headers = resolveHeaders();\n+\n+        return Result.of(Collections.singletonList(\n+                HttpRequest.<BidRequest>builder()\n+                        .method(HttpMethod.POST)\n+                        .uri(requestUrl)\n+                        .headers(headers)\n+                        .payload(outgoingRequest)\n+                        .body(body)\n+                        .build()),\n+                errors);\n+    }\n+\n+    private MultiMap resolveHeaders() {\n+        return HttpUtil.headers();\n+    }\n+\n+    private ExtImpApplogy parseAndValidateImpExt(Imp imp) {\n+        final ExtImpApplogy extImpApplogy;\n+        try {\n+            extImpApplogy = Json.mapper.convertValue(imp.getExt().get(\"bidder\"), ExtImpApplogy.class);\n+        } catch (IllegalArgumentException e) {\n+            throw new PreBidException(e.getMessage(), e);\n+        }\n+\n+        if (StringUtils.isBlank(extImpApplogy.getToken())) {\n+            throw new PreBidException(\"token is empty\");\n+        }\n+        return extImpApplogy;\n+    }\n+\n+    private Imp processImp(Imp imp) {\n+        Banner banner = imp.getBanner();\n+        if (banner != null) {\n+            if (banner.getH() == null && banner.getW() == null && CollectionUtils.isNotEmpty(banner.getFormat())) {\n+                final Format firstFormat = banner.getFormat().get(0);\n+                final Banner modifiedBanner = banner.toBuilder()\n+                        .h(firstFormat.getH())\n+                        .w(firstFormat.getW())\n+                        .build();\n+                return imp.toBuilder().banner(modifiedBanner).build();\n+            }\n+        }\n+        return imp;\n+    }\n+\n+    @Override\n+    public Result<List<BidderBid>> makeBids(HttpCall<BidRequest> httpCall, BidRequest bidRequest) {\n+        if (httpCall.getResponse().getStatusCode() == HttpResponseStatus.NO_CONTENT.code()) {\n+            return Result.of(Collections.emptyList(), Collections.emptyList());\n+        }\n+        try {\n+            final BidResponse bidResponse = Json.decodeValue(httpCall.getResponse().getBody(), BidResponse.class);\n+            return Result.of(extractBids(httpCall.getRequest().getPayload(), bidResponse), Collections.emptyList());\n+\n+        } catch (DecodeException e) {\n+            return Result.emptyWithError(BidderError.badServerResponse(\"failed to decode json\"));\n+        }\n+    }\n+\n+    private static List<BidderBid> extractBids(BidRequest bidRequest, BidResponse bidResponse) {\n+        if (bidResponse == null || bidResponse.getSeatbid() == null) {\n+            return Collections.emptyList();\n+        }\n+        return bidsFromResponse(bidRequest, bidResponse);\n+    }\n+\n+    private static List<BidderBid> bidsFromResponse(BidRequest bidRequest, BidResponse bidResponse) {\n+        final Map<String, BidType> requestImpIdToBidType = bidRequest.getImp().stream()\n+                .collect(Collectors.toMap(Imp::getId, ApplogyBidder::getBidType));\n+\n+        return bidResponse.getSeatbid().stream()\n+                .filter(Objects::nonNull)\n+                .map(SeatBid::getBid)\n+                .filter(Objects::nonNull)\n+                .flatMap(Collection::stream)\n+                .map(bid -> BidderBid.of(bid,\n+                        requestImpIdToBidType.getOrDefault(bid.getImpid(), BidType.banner), DEFAULT_BID_CURRENCY))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private static BidType getBidType(Imp imp) {\n+        if (imp.getVideo() != null) {\n+            return BidType.video;\n+        } else if (imp.getXNative() != null) {", "originalCommit": "c5a09970fcd38883d3e6939b87341da9eda8dd46", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjE0OTE1NQ==", "url": "https://github.com/prebid/prebid-server-java/pull/583#discussion_r366149155", "bodyText": "This is not necessary, just have a method that iterates through bidrequest.imp and checks imp.getId().equals(bid.getIpid()) and then applies the getBidType to resolve type.\nAlso, check the comments to getBidType below.", "author": "RossGoncharuk", "createdAt": "2020-01-14T04:35:45Z", "path": "src/main/java/org/prebid/server/bidder/applogy/ApplogyBidder.java", "diffHunk": "@@ -0,0 +1,171 @@\n+package org.prebid.server.bidder.applogy;\n+\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.iab.openrtb.request.Banner;\n+import com.iab.openrtb.request.BidRequest;\n+import com.iab.openrtb.request.Format;\n+import com.iab.openrtb.request.Imp;\n+import com.iab.openrtb.response.BidResponse;\n+import com.iab.openrtb.response.SeatBid;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.vertx.core.MultiMap;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.json.DecodeException;\n+import io.vertx.core.json.Json;\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.prebid.server.bidder.Bidder;\n+import org.prebid.server.bidder.model.BidderBid;\n+import org.prebid.server.bidder.model.BidderError;\n+import org.prebid.server.bidder.model.HttpCall;\n+import org.prebid.server.bidder.model.HttpRequest;\n+import org.prebid.server.bidder.model.Result;\n+import org.prebid.server.exception.PreBidException;\n+import org.prebid.server.proto.openrtb.ext.request.applogy.ExtImpApplogy;\n+import org.prebid.server.proto.openrtb.ext.response.BidType;\n+import org.prebid.server.util.HttpUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class ApplogyBidder implements Bidder<BidRequest> {\n+\n+    private final String endpointUrl;\n+\n+    private static final String DEFAULT_BID_CURRENCY = \"USD\";\n+\n+    public ApplogyBidder(String endpointUrl) {\n+        this.endpointUrl = HttpUtil.validateUrl(Objects.requireNonNull(endpointUrl));\n+    }\n+\n+    @Override\n+    public Result<List<HttpRequest<BidRequest>>> makeHttpRequests(BidRequest request) {\n+        final List<BidderError> errors = new ArrayList<>();\n+        final List<Imp> validImps = new ArrayList<>();\n+        for (Imp imp : request.getImp()) {\n+            if (imp.getBanner() == null && imp.getVideo() == null && imp.getXNative() == null) {\n+                errors.add(BidderError.badInput(\n+                        String.format(\"Applogy only supports banner, video and native media types. Ignoring imp id=%s\",\n+                                imp.getId())));\n+                continue;\n+            }\n+            validImps.add(processImp(imp));\n+        }\n+\n+        if (validImps.isEmpty()) {\n+            errors.add(BidderError.badInput(\"No valid impressions in the bid request\"));\n+            return Result.of(Collections.emptyList(), errors);\n+        }\n+\n+        final ExtImpApplogy firstImpExt;\n+        try {\n+            firstImpExt = parseAndValidateImpExt(validImps.get(0));\n+        } catch (PreBidException e) {\n+            return Result.emptyWithError(BidderError.badInput(e.getMessage()));\n+        }\n+\n+        final BidRequest outgoingRequest = request.toBuilder().imp(validImps).build();\n+        final String body = Json.encode(outgoingRequest);\n+        final String requestUrl = endpointUrl + \"/\" + firstImpExt.getToken();\n+        final MultiMap headers = resolveHeaders();\n+\n+        return Result.of(Collections.singletonList(\n+                HttpRequest.<BidRequest>builder()\n+                        .method(HttpMethod.POST)\n+                        .uri(requestUrl)\n+                        .headers(headers)\n+                        .payload(outgoingRequest)\n+                        .body(body)\n+                        .build()),\n+                errors);\n+    }\n+\n+    private MultiMap resolveHeaders() {\n+        return HttpUtil.headers();\n+    }\n+\n+    private ExtImpApplogy parseAndValidateImpExt(Imp imp) {\n+        final ExtImpApplogy extImpApplogy;\n+        try {\n+            extImpApplogy = Json.mapper.convertValue(imp.getExt().get(\"bidder\"), ExtImpApplogy.class);\n+        } catch (IllegalArgumentException e) {\n+            throw new PreBidException(e.getMessage(), e);\n+        }\n+\n+        if (StringUtils.isBlank(extImpApplogy.getToken())) {\n+            throw new PreBidException(\"token is empty\");\n+        }\n+        return extImpApplogy;\n+    }\n+\n+    private Imp processImp(Imp imp) {\n+        Banner banner = imp.getBanner();\n+        if (banner != null) {\n+            if (banner.getH() == null && banner.getW() == null && CollectionUtils.isNotEmpty(banner.getFormat())) {\n+                final Format firstFormat = banner.getFormat().get(0);\n+                final Banner modifiedBanner = banner.toBuilder()\n+                        .h(firstFormat.getH())\n+                        .w(firstFormat.getW())\n+                        .build();\n+                return imp.toBuilder().banner(modifiedBanner).build();\n+            }\n+        }\n+        return imp;\n+    }\n+\n+    @Override\n+    public Result<List<BidderBid>> makeBids(HttpCall<BidRequest> httpCall, BidRequest bidRequest) {\n+        if (httpCall.getResponse().getStatusCode() == HttpResponseStatus.NO_CONTENT.code()) {\n+            return Result.of(Collections.emptyList(), Collections.emptyList());\n+        }\n+        try {\n+            final BidResponse bidResponse = Json.decodeValue(httpCall.getResponse().getBody(), BidResponse.class);\n+            return Result.of(extractBids(httpCall.getRequest().getPayload(), bidResponse), Collections.emptyList());\n+\n+        } catch (DecodeException e) {\n+            return Result.emptyWithError(BidderError.badServerResponse(\"failed to decode json\"));\n+        }\n+    }\n+\n+    private static List<BidderBid> extractBids(BidRequest bidRequest, BidResponse bidResponse) {\n+        if (bidResponse == null || bidResponse.getSeatbid() == null) {\n+            return Collections.emptyList();\n+        }\n+        return bidsFromResponse(bidRequest, bidResponse);\n+    }\n+\n+    private static List<BidderBid> bidsFromResponse(BidRequest bidRequest, BidResponse bidResponse) {\n+        final Map<String, BidType> requestImpIdToBidType = bidRequest.getImp().stream()\n+                .collect(Collectors.toMap(Imp::getId, ApplogyBidder::getBidType));", "originalCommit": "c5a09970fcd38883d3e6939b87341da9eda8dd46", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjE0OTYxMA==", "url": "https://github.com/prebid/prebid-server-java/pull/583#discussion_r366149610", "bodyText": "This is incorrect, since they throw error when bid imp id was not matched to imp id, which makes using a map unnecessary.\nCheck other getBidType or resolveBidType methods in other bidders, as well as check my comments to your getBidType method below.", "author": "RossGoncharuk", "createdAt": "2020-01-14T04:38:01Z", "path": "src/main/java/org/prebid/server/bidder/applogy/ApplogyBidder.java", "diffHunk": "@@ -0,0 +1,171 @@\n+package org.prebid.server.bidder.applogy;\n+\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.iab.openrtb.request.Banner;\n+import com.iab.openrtb.request.BidRequest;\n+import com.iab.openrtb.request.Format;\n+import com.iab.openrtb.request.Imp;\n+import com.iab.openrtb.response.BidResponse;\n+import com.iab.openrtb.response.SeatBid;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.vertx.core.MultiMap;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.json.DecodeException;\n+import io.vertx.core.json.Json;\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.prebid.server.bidder.Bidder;\n+import org.prebid.server.bidder.model.BidderBid;\n+import org.prebid.server.bidder.model.BidderError;\n+import org.prebid.server.bidder.model.HttpCall;\n+import org.prebid.server.bidder.model.HttpRequest;\n+import org.prebid.server.bidder.model.Result;\n+import org.prebid.server.exception.PreBidException;\n+import org.prebid.server.proto.openrtb.ext.request.applogy.ExtImpApplogy;\n+import org.prebid.server.proto.openrtb.ext.response.BidType;\n+import org.prebid.server.util.HttpUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class ApplogyBidder implements Bidder<BidRequest> {\n+\n+    private final String endpointUrl;\n+\n+    private static final String DEFAULT_BID_CURRENCY = \"USD\";\n+\n+    public ApplogyBidder(String endpointUrl) {\n+        this.endpointUrl = HttpUtil.validateUrl(Objects.requireNonNull(endpointUrl));\n+    }\n+\n+    @Override\n+    public Result<List<HttpRequest<BidRequest>>> makeHttpRequests(BidRequest request) {\n+        final List<BidderError> errors = new ArrayList<>();\n+        final List<Imp> validImps = new ArrayList<>();\n+        for (Imp imp : request.getImp()) {\n+            if (imp.getBanner() == null && imp.getVideo() == null && imp.getXNative() == null) {\n+                errors.add(BidderError.badInput(\n+                        String.format(\"Applogy only supports banner, video and native media types. Ignoring imp id=%s\",\n+                                imp.getId())));\n+                continue;\n+            }\n+            validImps.add(processImp(imp));\n+        }\n+\n+        if (validImps.isEmpty()) {\n+            errors.add(BidderError.badInput(\"No valid impressions in the bid request\"));\n+            return Result.of(Collections.emptyList(), errors);\n+        }\n+\n+        final ExtImpApplogy firstImpExt;\n+        try {\n+            firstImpExt = parseAndValidateImpExt(validImps.get(0));\n+        } catch (PreBidException e) {\n+            return Result.emptyWithError(BidderError.badInput(e.getMessage()));\n+        }\n+\n+        final BidRequest outgoingRequest = request.toBuilder().imp(validImps).build();\n+        final String body = Json.encode(outgoingRequest);\n+        final String requestUrl = endpointUrl + \"/\" + firstImpExt.getToken();\n+        final MultiMap headers = resolveHeaders();\n+\n+        return Result.of(Collections.singletonList(\n+                HttpRequest.<BidRequest>builder()\n+                        .method(HttpMethod.POST)\n+                        .uri(requestUrl)\n+                        .headers(headers)\n+                        .payload(outgoingRequest)\n+                        .body(body)\n+                        .build()),\n+                errors);\n+    }\n+\n+    private MultiMap resolveHeaders() {\n+        return HttpUtil.headers();\n+    }\n+\n+    private ExtImpApplogy parseAndValidateImpExt(Imp imp) {\n+        final ExtImpApplogy extImpApplogy;\n+        try {\n+            extImpApplogy = Json.mapper.convertValue(imp.getExt().get(\"bidder\"), ExtImpApplogy.class);\n+        } catch (IllegalArgumentException e) {\n+            throw new PreBidException(e.getMessage(), e);\n+        }\n+\n+        if (StringUtils.isBlank(extImpApplogy.getToken())) {\n+            throw new PreBidException(\"token is empty\");\n+        }\n+        return extImpApplogy;\n+    }\n+\n+    private Imp processImp(Imp imp) {\n+        Banner banner = imp.getBanner();\n+        if (banner != null) {\n+            if (banner.getH() == null && banner.getW() == null && CollectionUtils.isNotEmpty(banner.getFormat())) {\n+                final Format firstFormat = banner.getFormat().get(0);\n+                final Banner modifiedBanner = banner.toBuilder()\n+                        .h(firstFormat.getH())\n+                        .w(firstFormat.getW())\n+                        .build();\n+                return imp.toBuilder().banner(modifiedBanner).build();\n+            }\n+        }\n+        return imp;\n+    }\n+\n+    @Override\n+    public Result<List<BidderBid>> makeBids(HttpCall<BidRequest> httpCall, BidRequest bidRequest) {\n+        if (httpCall.getResponse().getStatusCode() == HttpResponseStatus.NO_CONTENT.code()) {\n+            return Result.of(Collections.emptyList(), Collections.emptyList());\n+        }\n+        try {\n+            final BidResponse bidResponse = Json.decodeValue(httpCall.getResponse().getBody(), BidResponse.class);\n+            return Result.of(extractBids(httpCall.getRequest().getPayload(), bidResponse), Collections.emptyList());\n+\n+        } catch (DecodeException e) {\n+            return Result.emptyWithError(BidderError.badServerResponse(\"failed to decode json\"));\n+        }\n+    }\n+\n+    private static List<BidderBid> extractBids(BidRequest bidRequest, BidResponse bidResponse) {\n+        if (bidResponse == null || bidResponse.getSeatbid() == null) {\n+            return Collections.emptyList();\n+        }\n+        return bidsFromResponse(bidRequest, bidResponse);\n+    }\n+\n+    private static List<BidderBid> bidsFromResponse(BidRequest bidRequest, BidResponse bidResponse) {\n+        final Map<String, BidType> requestImpIdToBidType = bidRequest.getImp().stream()\n+                .collect(Collectors.toMap(Imp::getId, ApplogyBidder::getBidType));\n+\n+        return bidResponse.getSeatbid().stream()\n+                .filter(Objects::nonNull)\n+                .map(SeatBid::getBid)\n+                .filter(Objects::nonNull)\n+                .flatMap(Collection::stream)\n+                .map(bid -> BidderBid.of(bid,\n+                        requestImpIdToBidType.getOrDefault(bid.getImpid(), BidType.banner), DEFAULT_BID_CURRENCY))", "originalCommit": "c5a09970fcd38883d3e6939b87341da9eda8dd46", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjE0OTk5Nw==", "url": "https://github.com/prebid/prebid-server-java/pull/583#discussion_r366149997", "bodyText": "It is quite annoying, but our project requires all .java files (except test files, but better have one there as well) to end up with an empty line.\nPlease be sure to have an empty line in all java files you add.", "author": "RossGoncharuk", "createdAt": "2020-01-14T04:39:55Z", "path": "src/main/java/org/prebid/server/bidder/applogy/ApplogyBidder.java", "diffHunk": "@@ -0,0 +1,171 @@\n+package org.prebid.server.bidder.applogy;\n+\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.iab.openrtb.request.Banner;\n+import com.iab.openrtb.request.BidRequest;\n+import com.iab.openrtb.request.Format;\n+import com.iab.openrtb.request.Imp;\n+import com.iab.openrtb.response.BidResponse;\n+import com.iab.openrtb.response.SeatBid;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.vertx.core.MultiMap;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.json.DecodeException;\n+import io.vertx.core.json.Json;\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.prebid.server.bidder.Bidder;\n+import org.prebid.server.bidder.model.BidderBid;\n+import org.prebid.server.bidder.model.BidderError;\n+import org.prebid.server.bidder.model.HttpCall;\n+import org.prebid.server.bidder.model.HttpRequest;\n+import org.prebid.server.bidder.model.Result;\n+import org.prebid.server.exception.PreBidException;\n+import org.prebid.server.proto.openrtb.ext.request.applogy.ExtImpApplogy;\n+import org.prebid.server.proto.openrtb.ext.response.BidType;\n+import org.prebid.server.util.HttpUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class ApplogyBidder implements Bidder<BidRequest> {\n+\n+    private final String endpointUrl;\n+\n+    private static final String DEFAULT_BID_CURRENCY = \"USD\";\n+\n+    public ApplogyBidder(String endpointUrl) {\n+        this.endpointUrl = HttpUtil.validateUrl(Objects.requireNonNull(endpointUrl));\n+    }\n+\n+    @Override\n+    public Result<List<HttpRequest<BidRequest>>> makeHttpRequests(BidRequest request) {\n+        final List<BidderError> errors = new ArrayList<>();\n+        final List<Imp> validImps = new ArrayList<>();\n+        for (Imp imp : request.getImp()) {\n+            if (imp.getBanner() == null && imp.getVideo() == null && imp.getXNative() == null) {\n+                errors.add(BidderError.badInput(\n+                        String.format(\"Applogy only supports banner, video and native media types. Ignoring imp id=%s\",\n+                                imp.getId())));\n+                continue;\n+            }\n+            validImps.add(processImp(imp));\n+        }\n+\n+        if (validImps.isEmpty()) {\n+            errors.add(BidderError.badInput(\"No valid impressions in the bid request\"));\n+            return Result.of(Collections.emptyList(), errors);\n+        }\n+\n+        final ExtImpApplogy firstImpExt;\n+        try {\n+            firstImpExt = parseAndValidateImpExt(validImps.get(0));\n+        } catch (PreBidException e) {\n+            return Result.emptyWithError(BidderError.badInput(e.getMessage()));\n+        }\n+\n+        final BidRequest outgoingRequest = request.toBuilder().imp(validImps).build();\n+        final String body = Json.encode(outgoingRequest);\n+        final String requestUrl = endpointUrl + \"/\" + firstImpExt.getToken();\n+        final MultiMap headers = resolveHeaders();\n+\n+        return Result.of(Collections.singletonList(\n+                HttpRequest.<BidRequest>builder()\n+                        .method(HttpMethod.POST)\n+                        .uri(requestUrl)\n+                        .headers(headers)\n+                        .payload(outgoingRequest)\n+                        .body(body)\n+                        .build()),\n+                errors);\n+    }\n+\n+    private MultiMap resolveHeaders() {\n+        return HttpUtil.headers();\n+    }\n+\n+    private ExtImpApplogy parseAndValidateImpExt(Imp imp) {\n+        final ExtImpApplogy extImpApplogy;\n+        try {\n+            extImpApplogy = Json.mapper.convertValue(imp.getExt().get(\"bidder\"), ExtImpApplogy.class);\n+        } catch (IllegalArgumentException e) {\n+            throw new PreBidException(e.getMessage(), e);\n+        }\n+\n+        if (StringUtils.isBlank(extImpApplogy.getToken())) {\n+            throw new PreBidException(\"token is empty\");\n+        }\n+        return extImpApplogy;\n+    }\n+\n+    private Imp processImp(Imp imp) {\n+        Banner banner = imp.getBanner();\n+        if (banner != null) {\n+            if (banner.getH() == null && banner.getW() == null && CollectionUtils.isNotEmpty(banner.getFormat())) {\n+                final Format firstFormat = banner.getFormat().get(0);\n+                final Banner modifiedBanner = banner.toBuilder()\n+                        .h(firstFormat.getH())\n+                        .w(firstFormat.getW())\n+                        .build();\n+                return imp.toBuilder().banner(modifiedBanner).build();\n+            }\n+        }\n+        return imp;\n+    }\n+\n+    @Override\n+    public Result<List<BidderBid>> makeBids(HttpCall<BidRequest> httpCall, BidRequest bidRequest) {\n+        if (httpCall.getResponse().getStatusCode() == HttpResponseStatus.NO_CONTENT.code()) {\n+            return Result.of(Collections.emptyList(), Collections.emptyList());\n+        }\n+        try {\n+            final BidResponse bidResponse = Json.decodeValue(httpCall.getResponse().getBody(), BidResponse.class);\n+            return Result.of(extractBids(httpCall.getRequest().getPayload(), bidResponse), Collections.emptyList());\n+\n+        } catch (DecodeException e) {\n+            return Result.emptyWithError(BidderError.badServerResponse(\"failed to decode json\"));\n+        }\n+    }\n+\n+    private static List<BidderBid> extractBids(BidRequest bidRequest, BidResponse bidResponse) {\n+        if (bidResponse == null || bidResponse.getSeatbid() == null) {\n+            return Collections.emptyList();\n+        }\n+        return bidsFromResponse(bidRequest, bidResponse);\n+    }\n+\n+    private static List<BidderBid> bidsFromResponse(BidRequest bidRequest, BidResponse bidResponse) {\n+        final Map<String, BidType> requestImpIdToBidType = bidRequest.getImp().stream()\n+                .collect(Collectors.toMap(Imp::getId, ApplogyBidder::getBidType));\n+\n+        return bidResponse.getSeatbid().stream()\n+                .filter(Objects::nonNull)\n+                .map(SeatBid::getBid)\n+                .filter(Objects::nonNull)\n+                .flatMap(Collection::stream)\n+                .map(bid -> BidderBid.of(bid,\n+                        requestImpIdToBidType.getOrDefault(bid.getImpid(), BidType.banner), DEFAULT_BID_CURRENCY))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private static BidType getBidType(Imp imp) {\n+        if (imp.getVideo() != null) {\n+            return BidType.video;\n+        } else if (imp.getXNative() != null) {\n+            return BidType.xNative;\n+        } else {\n+            return BidType.banner;\n+\n+        }\n+    }\n+\n+    @Override\n+    public Map<String, String> extractTargeting(ObjectNode ext) {\n+        return Collections.emptyMap();\n+    }\n+}", "originalCommit": "c5a09970fcd38883d3e6939b87341da9eda8dd46", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjE1MDExNg==", "url": "https://github.com/prebid/prebid-server-java/pull/583#discussion_r366150116", "bodyText": "This annotation is redundant since the json field name can be resolved from variable name. Please remove it,", "author": "RossGoncharuk", "createdAt": "2020-01-14T04:40:40Z", "path": "src/main/java/org/prebid/server/proto/openrtb/ext/request/applogy/ExtImpApplogy.java", "diffHunk": "@@ -0,0 +1,13 @@\n+package org.prebid.server.proto.openrtb.ext.request.applogy;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import lombok.AllArgsConstructor;\n+import lombok.Value;\n+\n+@AllArgsConstructor(staticName = \"of\")\n+@Value\n+public class ExtImpApplogy {\n+\n+    @JsonProperty(\"token\")", "originalCommit": "c5a09970fcd38883d3e6939b87341da9eda8dd46", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjE1MDYyMA==", "url": "https://github.com/prebid/prebid-server-java/pull/583#discussion_r366150620", "bodyText": "How the changes to Rubicon bidder are related to adding a new bidder? Please roll back this change and make a separate PR if this is not mistake and changes are required.", "author": "RossGoncharuk", "createdAt": "2020-01-14T04:43:43Z", "path": "src/main/java/org/prebid/server/proto/openrtb/ext/request/rubicon/ExtImpRubicon.java", "diffHunk": "@@ -32,4 +32,7 @@\n     RubiconVideoParams video;\n \n     String pchain;\n+\n+    @JsonProperty(\"is_rewarded_inventory\")", "originalCommit": "c5a09970fcd38883d3e6939b87341da9eda8dd46", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjE1MDczNA==", "url": "https://github.com/prebid/prebid-server-java/pull/583#discussion_r366150734", "bodyText": "Same as above - we are adding Applogy bidder, so why are we modifying Rubicon bidder?", "author": "RossGoncharuk", "createdAt": "2020-01-14T04:44:19Z", "path": "src/main/java/org/prebid/server/proto/openrtb/ext/request/rubicon/RubiconVideoParams.java", "diffHunk": "@@ -21,4 +21,6 @@\n     Integer skip;\n \n     Integer skipdelay;\n+", "originalCommit": "c5a09970fcd38883d3e6939b87341da9eda8dd46", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjUxMDYwMw==", "url": "https://github.com/prebid/prebid-server-java/pull/583#discussion_r366510603", "bodyText": "Please exclude any changes to Rubicon-related files.", "author": "RossGoncharuk", "createdAt": "2020-01-14T18:48:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjE1MDczNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjE1MDc0OQ==", "url": "https://github.com/prebid/prebid-server-java/pull/583#discussion_r366150749", "bodyText": "Same as above", "author": "RossGoncharuk", "createdAt": "2020-01-14T04:44:29Z", "path": "src/main/java/org/prebid/server/proto/openrtb/ext/request/rubicon/VideoType.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package org.prebid.server.proto.openrtb.ext.request.rubicon;\n+\n+public enum VideoType {", "originalCommit": "c5a09970fcd38883d3e6939b87341da9eda8dd46", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "92ce591c4bd02f4a261016f18b3958b411bf69cd", "url": "https://github.com/prebid/prebid-server-java/commit/92ce591c4bd02f4a261016f18b3958b411bf69cd", "message": "Applogy Bidder\n\n-Bidder fixed\n-tests fixed\n-configuration fixed", "committedDate": "2020-01-14T11:10:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjUwNTAwOQ==", "url": "https://github.com/prebid/prebid-server-java/pull/583#discussion_r366505009", "bodyText": "You should've left the CollectionUtils.isEmpty(), because what if we do have a list of Formats but it is empty?", "author": "RossGoncharuk", "createdAt": "2020-01-14T18:36:49Z", "path": "src/main/java/org/prebid/server/bidder/applogy/ApplogyBidder.java", "diffHunk": "@@ -0,0 +1,190 @@\n+package org.prebid.server.bidder.applogy;\n+\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.iab.openrtb.request.Banner;\n+import com.iab.openrtb.request.BidRequest;\n+import com.iab.openrtb.request.Format;\n+import com.iab.openrtb.request.Imp;\n+import com.iab.openrtb.response.Bid;\n+import com.iab.openrtb.response.BidResponse;\n+import com.iab.openrtb.response.SeatBid;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.vertx.core.MultiMap;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.json.DecodeException;\n+import io.vertx.core.json.Json;\n+import org.apache.commons.lang3.StringUtils;\n+import org.prebid.server.bidder.Bidder;\n+import org.prebid.server.bidder.model.BidderBid;\n+import org.prebid.server.bidder.model.BidderError;\n+import org.prebid.server.bidder.model.HttpCall;\n+import org.prebid.server.bidder.model.HttpRequest;\n+import org.prebid.server.bidder.model.Result;\n+import org.prebid.server.exception.PreBidException;\n+import org.prebid.server.proto.openrtb.ext.ExtPrebid;\n+import org.prebid.server.proto.openrtb.ext.request.applogy.ExtImpApplogy;\n+import org.prebid.server.proto.openrtb.ext.response.BidType;\n+import org.prebid.server.util.HttpUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class ApplogyBidder implements Bidder<BidRequest> {\n+    private static final TypeReference<ExtPrebid<?, ExtImpApplogy>> APPLOGY_EXT_TYPE_REFERENCE =\n+            new TypeReference<ExtPrebid<?, ExtImpApplogy>>() {\n+            };\n+\n+    private static final String DEFAULT_BID_CURRENCY = \"USD\";\n+\n+    private final String endpointUrl;\n+\n+    public ApplogyBidder(String endpointUrl) {\n+        this.endpointUrl = HttpUtil.validateUrl(Objects.requireNonNull(endpointUrl));\n+    }\n+\n+    @Override\n+    public Result<List<HttpRequest<BidRequest>>> makeHttpRequests(BidRequest request) {\n+        final List<BidderError> errors = new ArrayList<>();\n+        final List<HttpRequest<BidRequest>> result = new ArrayList<>();\n+\n+        for (Imp imp : request.getImp()) {\n+            try {\n+                final ExtImpApplogy extImpApplogy = parseAndValidateImpExt(imp);\n+                final Imp processImp = processImp(imp);\n+                final String url = endpointUrl + \"/\" + extImpApplogy.getToken();\n+                result.add(createSingleRequest(processImp, request, url));\n+            } catch (PreBidException e) {\n+                errors.add(BidderError.badInput(e.getMessage()));\n+            }\n+        }\n+\n+        return Result.of(result, errors);\n+    }\n+\n+    private HttpRequest<BidRequest> createSingleRequest(Imp imp, BidRequest request, String url) {\n+        final BidRequest outgoingRequest = request.toBuilder().imp(Collections.singletonList(imp)).build();\n+\n+        final String body = Json.encode(outgoingRequest);\n+\n+        return HttpRequest.<BidRequest>builder()\n+                .method(HttpMethod.POST)\n+                .uri(url)\n+                .headers(resolveHeaders())\n+                .body(body)\n+                .payload(outgoingRequest)\n+                .build();\n+    }\n+\n+    private MultiMap resolveHeaders() {\n+        return HttpUtil.headers();\n+    }\n+\n+    private ExtImpApplogy parseAndValidateImpExt(Imp imp) {\n+        final ExtImpApplogy extImpApplogy;\n+        try {\n+            extImpApplogy = Json.mapper.convertValue(imp.getExt(), APPLOGY_EXT_TYPE_REFERENCE)\n+                    .getBidder();\n+        } catch (IllegalArgumentException e) {\n+            throw new PreBidException(e.getMessage());\n+        }\n+\n+        if (extImpApplogy == null) {\n+            throw new PreBidException(\"impression extensions required\");\n+        }\n+\n+        if (StringUtils.isBlank(extImpApplogy.getToken())) {\n+            throw new PreBidException(\"token is empty\");\n+        }\n+        return extImpApplogy;\n+    }\n+\n+    private Imp processImp(Imp imp) {\n+        if (imp.getBanner() == null && imp.getVideo() == null && imp.getXNative() == null) {\n+            throw new PreBidException(\"Applogy only supports banner, video or native ads\");\n+        }\n+\n+        Banner banner = imp.getBanner();\n+        if (banner != null) {\n+            if (banner.getH() == null || banner.getW() == null || banner.getH() == 0 || banner.getW() == 0) {\n+                if (banner.getFormat() == null) {", "originalCommit": "92ce591c4bd02f4a261016f18b3958b411bf69cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjUwNzUyMA==", "url": "https://github.com/prebid/prebid-server-java/pull/583#discussion_r366507520", "bodyText": "No need to add a custom message, just use the one from caught exception - e.getMessage().", "author": "RossGoncharuk", "createdAt": "2020-01-14T18:42:01Z", "path": "src/main/java/org/prebid/server/bidder/applogy/ApplogyBidder.java", "diffHunk": "@@ -0,0 +1,190 @@\n+package org.prebid.server.bidder.applogy;\n+\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.iab.openrtb.request.Banner;\n+import com.iab.openrtb.request.BidRequest;\n+import com.iab.openrtb.request.Format;\n+import com.iab.openrtb.request.Imp;\n+import com.iab.openrtb.response.Bid;\n+import com.iab.openrtb.response.BidResponse;\n+import com.iab.openrtb.response.SeatBid;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.vertx.core.MultiMap;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.json.DecodeException;\n+import io.vertx.core.json.Json;\n+import org.apache.commons.lang3.StringUtils;\n+import org.prebid.server.bidder.Bidder;\n+import org.prebid.server.bidder.model.BidderBid;\n+import org.prebid.server.bidder.model.BidderError;\n+import org.prebid.server.bidder.model.HttpCall;\n+import org.prebid.server.bidder.model.HttpRequest;\n+import org.prebid.server.bidder.model.Result;\n+import org.prebid.server.exception.PreBidException;\n+import org.prebid.server.proto.openrtb.ext.ExtPrebid;\n+import org.prebid.server.proto.openrtb.ext.request.applogy.ExtImpApplogy;\n+import org.prebid.server.proto.openrtb.ext.response.BidType;\n+import org.prebid.server.util.HttpUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class ApplogyBidder implements Bidder<BidRequest> {\n+    private static final TypeReference<ExtPrebid<?, ExtImpApplogy>> APPLOGY_EXT_TYPE_REFERENCE =\n+            new TypeReference<ExtPrebid<?, ExtImpApplogy>>() {\n+            };\n+\n+    private static final String DEFAULT_BID_CURRENCY = \"USD\";\n+\n+    private final String endpointUrl;\n+\n+    public ApplogyBidder(String endpointUrl) {\n+        this.endpointUrl = HttpUtil.validateUrl(Objects.requireNonNull(endpointUrl));\n+    }\n+\n+    @Override\n+    public Result<List<HttpRequest<BidRequest>>> makeHttpRequests(BidRequest request) {\n+        final List<BidderError> errors = new ArrayList<>();\n+        final List<HttpRequest<BidRequest>> result = new ArrayList<>();\n+\n+        for (Imp imp : request.getImp()) {\n+            try {\n+                final ExtImpApplogy extImpApplogy = parseAndValidateImpExt(imp);\n+                final Imp processImp = processImp(imp);\n+                final String url = endpointUrl + \"/\" + extImpApplogy.getToken();\n+                result.add(createSingleRequest(processImp, request, url));\n+            } catch (PreBidException e) {\n+                errors.add(BidderError.badInput(e.getMessage()));\n+            }\n+        }\n+\n+        return Result.of(result, errors);\n+    }\n+\n+    private HttpRequest<BidRequest> createSingleRequest(Imp imp, BidRequest request, String url) {\n+        final BidRequest outgoingRequest = request.toBuilder().imp(Collections.singletonList(imp)).build();\n+\n+        final String body = Json.encode(outgoingRequest);\n+\n+        return HttpRequest.<BidRequest>builder()\n+                .method(HttpMethod.POST)\n+                .uri(url)\n+                .headers(resolveHeaders())\n+                .body(body)\n+                .payload(outgoingRequest)\n+                .build();\n+    }\n+\n+    private MultiMap resolveHeaders() {\n+        return HttpUtil.headers();\n+    }\n+\n+    private ExtImpApplogy parseAndValidateImpExt(Imp imp) {\n+        final ExtImpApplogy extImpApplogy;\n+        try {\n+            extImpApplogy = Json.mapper.convertValue(imp.getExt(), APPLOGY_EXT_TYPE_REFERENCE)\n+                    .getBidder();\n+        } catch (IllegalArgumentException e) {\n+            throw new PreBidException(e.getMessage());\n+        }\n+\n+        if (extImpApplogy == null) {\n+            throw new PreBidException(\"impression extensions required\");\n+        }\n+\n+        if (StringUtils.isBlank(extImpApplogy.getToken())) {\n+            throw new PreBidException(\"token is empty\");\n+        }\n+        return extImpApplogy;\n+    }\n+\n+    private Imp processImp(Imp imp) {\n+        if (imp.getBanner() == null && imp.getVideo() == null && imp.getXNative() == null) {\n+            throw new PreBidException(\"Applogy only supports banner, video or native ads\");\n+        }\n+\n+        Banner banner = imp.getBanner();\n+        if (banner != null) {\n+            if (banner.getH() == null || banner.getW() == null || banner.getH() == 0 || banner.getW() == 0) {\n+                if (banner.getFormat() == null) {\n+                    throw new PreBidException(\"banner size information missing\");\n+                }\n+\n+                final Format firstFormat = banner.getFormat().get(0);\n+                final Banner modifiedBanner = banner.toBuilder()\n+                        .h(firstFormat.getH())\n+                        .w(firstFormat.getW())\n+                        .build();\n+                return imp.toBuilder().banner(modifiedBanner).build();\n+            }\n+        }\n+        return imp;\n+    }\n+\n+    @Override\n+    public Result<List<BidderBid>> makeBids(HttpCall<BidRequest> httpCall, BidRequest bidRequest) {\n+        if (httpCall.getResponse().getStatusCode() == HttpResponseStatus.NO_CONTENT.code()) {\n+            return Result.of(Collections.emptyList(), Collections.emptyList());\n+        }\n+\n+        try {\n+            final BidResponse bidResponse = Json.decodeValue(httpCall.getResponse().getBody(), BidResponse.class);\n+            return extractBids(httpCall.getRequest().getPayload(), bidResponse);\n+        } catch (DecodeException e) {\n+            return Result.emptyWithError(BidderError.badServerResponse(\"failed to decode json\"));", "originalCommit": "92ce591c4bd02f4a261016f18b3958b411bf69cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjUwODk1MA==", "url": "https://github.com/prebid/prebid-server-java/pull/583#discussion_r366508950", "bodyText": "Minor, but you don't need to pass whole bidRequest object when you need only a list of impressions from it - please change to bidFromResponse(bidRequest.getImp(), bid, errors) and method's param correspondingly.", "author": "RossGoncharuk", "createdAt": "2020-01-14T18:45:04Z", "path": "src/main/java/org/prebid/server/bidder/applogy/ApplogyBidder.java", "diffHunk": "@@ -0,0 +1,190 @@\n+package org.prebid.server.bidder.applogy;\n+\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.iab.openrtb.request.Banner;\n+import com.iab.openrtb.request.BidRequest;\n+import com.iab.openrtb.request.Format;\n+import com.iab.openrtb.request.Imp;\n+import com.iab.openrtb.response.Bid;\n+import com.iab.openrtb.response.BidResponse;\n+import com.iab.openrtb.response.SeatBid;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.vertx.core.MultiMap;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.json.DecodeException;\n+import io.vertx.core.json.Json;\n+import org.apache.commons.lang3.StringUtils;\n+import org.prebid.server.bidder.Bidder;\n+import org.prebid.server.bidder.model.BidderBid;\n+import org.prebid.server.bidder.model.BidderError;\n+import org.prebid.server.bidder.model.HttpCall;\n+import org.prebid.server.bidder.model.HttpRequest;\n+import org.prebid.server.bidder.model.Result;\n+import org.prebid.server.exception.PreBidException;\n+import org.prebid.server.proto.openrtb.ext.ExtPrebid;\n+import org.prebid.server.proto.openrtb.ext.request.applogy.ExtImpApplogy;\n+import org.prebid.server.proto.openrtb.ext.response.BidType;\n+import org.prebid.server.util.HttpUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class ApplogyBidder implements Bidder<BidRequest> {\n+    private static final TypeReference<ExtPrebid<?, ExtImpApplogy>> APPLOGY_EXT_TYPE_REFERENCE =\n+            new TypeReference<ExtPrebid<?, ExtImpApplogy>>() {\n+            };\n+\n+    private static final String DEFAULT_BID_CURRENCY = \"USD\";\n+\n+    private final String endpointUrl;\n+\n+    public ApplogyBidder(String endpointUrl) {\n+        this.endpointUrl = HttpUtil.validateUrl(Objects.requireNonNull(endpointUrl));\n+    }\n+\n+    @Override\n+    public Result<List<HttpRequest<BidRequest>>> makeHttpRequests(BidRequest request) {\n+        final List<BidderError> errors = new ArrayList<>();\n+        final List<HttpRequest<BidRequest>> result = new ArrayList<>();\n+\n+        for (Imp imp : request.getImp()) {\n+            try {\n+                final ExtImpApplogy extImpApplogy = parseAndValidateImpExt(imp);\n+                final Imp processImp = processImp(imp);\n+                final String url = endpointUrl + \"/\" + extImpApplogy.getToken();\n+                result.add(createSingleRequest(processImp, request, url));\n+            } catch (PreBidException e) {\n+                errors.add(BidderError.badInput(e.getMessage()));\n+            }\n+        }\n+\n+        return Result.of(result, errors);\n+    }\n+\n+    private HttpRequest<BidRequest> createSingleRequest(Imp imp, BidRequest request, String url) {\n+        final BidRequest outgoingRequest = request.toBuilder().imp(Collections.singletonList(imp)).build();\n+\n+        final String body = Json.encode(outgoingRequest);\n+\n+        return HttpRequest.<BidRequest>builder()\n+                .method(HttpMethod.POST)\n+                .uri(url)\n+                .headers(resolveHeaders())\n+                .body(body)\n+                .payload(outgoingRequest)\n+                .build();\n+    }\n+\n+    private MultiMap resolveHeaders() {\n+        return HttpUtil.headers();\n+    }\n+\n+    private ExtImpApplogy parseAndValidateImpExt(Imp imp) {\n+        final ExtImpApplogy extImpApplogy;\n+        try {\n+            extImpApplogy = Json.mapper.convertValue(imp.getExt(), APPLOGY_EXT_TYPE_REFERENCE)\n+                    .getBidder();\n+        } catch (IllegalArgumentException e) {\n+            throw new PreBidException(e.getMessage());\n+        }\n+\n+        if (extImpApplogy == null) {\n+            throw new PreBidException(\"impression extensions required\");\n+        }\n+\n+        if (StringUtils.isBlank(extImpApplogy.getToken())) {\n+            throw new PreBidException(\"token is empty\");\n+        }\n+        return extImpApplogy;\n+    }\n+\n+    private Imp processImp(Imp imp) {\n+        if (imp.getBanner() == null && imp.getVideo() == null && imp.getXNative() == null) {\n+            throw new PreBidException(\"Applogy only supports banner, video or native ads\");\n+        }\n+\n+        Banner banner = imp.getBanner();\n+        if (banner != null) {\n+            if (banner.getH() == null || banner.getW() == null || banner.getH() == 0 || banner.getW() == 0) {\n+                if (banner.getFormat() == null) {\n+                    throw new PreBidException(\"banner size information missing\");\n+                }\n+\n+                final Format firstFormat = banner.getFormat().get(0);\n+                final Banner modifiedBanner = banner.toBuilder()\n+                        .h(firstFormat.getH())\n+                        .w(firstFormat.getW())\n+                        .build();\n+                return imp.toBuilder().banner(modifiedBanner).build();\n+            }\n+        }\n+        return imp;\n+    }\n+\n+    @Override\n+    public Result<List<BidderBid>> makeBids(HttpCall<BidRequest> httpCall, BidRequest bidRequest) {\n+        if (httpCall.getResponse().getStatusCode() == HttpResponseStatus.NO_CONTENT.code()) {\n+            return Result.of(Collections.emptyList(), Collections.emptyList());\n+        }\n+\n+        try {\n+            final BidResponse bidResponse = Json.decodeValue(httpCall.getResponse().getBody(), BidResponse.class);\n+            return extractBids(httpCall.getRequest().getPayload(), bidResponse);\n+        } catch (DecodeException e) {\n+            return Result.emptyWithError(BidderError.badServerResponse(\"failed to decode json\"));\n+        }\n+    }\n+\n+    private static Result<List<BidderBid>> extractBids(BidRequest bidRequest, BidResponse bidResponse) {\n+        if (bidResponse == null || bidResponse.getSeatbid() == null) {\n+            return Result.of(Collections.emptyList(), Collections.emptyList());\n+        }\n+        final List<BidderError> errors = new ArrayList<>();\n+        final List<BidderBid> bidderBids = bidResponse.getSeatbid().stream()\n+                .filter(Objects::nonNull)\n+                .map(SeatBid::getBid)\n+                .filter(Objects::nonNull)\n+                .flatMap(Collection::stream)\n+                .map(bid -> bidFromResponse(bidRequest, bid, errors))", "originalCommit": "92ce591c4bd02f4a261016f18b3958b411bf69cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjUxMDEyNQ==", "url": "https://github.com/prebid/prebid-server-java/pull/583#discussion_r366510125", "bodyText": "You almost got it, except an empty line should be after class-closing brackets, not before it)\nJust an empty line after the last symbol (which is class-closing curly brackets).\nPlease check other files as well.", "author": "RossGoncharuk", "createdAt": "2020-01-14T18:47:29Z", "path": "src/main/java/org/prebid/server/bidder/applogy/ApplogyBidder.java", "diffHunk": "@@ -0,0 +1,190 @@\n+package org.prebid.server.bidder.applogy;\n+\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.iab.openrtb.request.Banner;\n+import com.iab.openrtb.request.BidRequest;\n+import com.iab.openrtb.request.Format;\n+import com.iab.openrtb.request.Imp;\n+import com.iab.openrtb.response.Bid;\n+import com.iab.openrtb.response.BidResponse;\n+import com.iab.openrtb.response.SeatBid;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.vertx.core.MultiMap;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.json.DecodeException;\n+import io.vertx.core.json.Json;\n+import org.apache.commons.lang3.StringUtils;\n+import org.prebid.server.bidder.Bidder;\n+import org.prebid.server.bidder.model.BidderBid;\n+import org.prebid.server.bidder.model.BidderError;\n+import org.prebid.server.bidder.model.HttpCall;\n+import org.prebid.server.bidder.model.HttpRequest;\n+import org.prebid.server.bidder.model.Result;\n+import org.prebid.server.exception.PreBidException;\n+import org.prebid.server.proto.openrtb.ext.ExtPrebid;\n+import org.prebid.server.proto.openrtb.ext.request.applogy.ExtImpApplogy;\n+import org.prebid.server.proto.openrtb.ext.response.BidType;\n+import org.prebid.server.util.HttpUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class ApplogyBidder implements Bidder<BidRequest> {\n+    private static final TypeReference<ExtPrebid<?, ExtImpApplogy>> APPLOGY_EXT_TYPE_REFERENCE =\n+            new TypeReference<ExtPrebid<?, ExtImpApplogy>>() {\n+            };\n+\n+    private static final String DEFAULT_BID_CURRENCY = \"USD\";\n+\n+    private final String endpointUrl;\n+\n+    public ApplogyBidder(String endpointUrl) {\n+        this.endpointUrl = HttpUtil.validateUrl(Objects.requireNonNull(endpointUrl));\n+    }\n+\n+    @Override\n+    public Result<List<HttpRequest<BidRequest>>> makeHttpRequests(BidRequest request) {\n+        final List<BidderError> errors = new ArrayList<>();\n+        final List<HttpRequest<BidRequest>> result = new ArrayList<>();\n+\n+        for (Imp imp : request.getImp()) {\n+            try {\n+                final ExtImpApplogy extImpApplogy = parseAndValidateImpExt(imp);\n+                final Imp processImp = processImp(imp);\n+                final String url = endpointUrl + \"/\" + extImpApplogy.getToken();\n+                result.add(createSingleRequest(processImp, request, url));\n+            } catch (PreBidException e) {\n+                errors.add(BidderError.badInput(e.getMessage()));\n+            }\n+        }\n+\n+        return Result.of(result, errors);\n+    }\n+\n+    private HttpRequest<BidRequest> createSingleRequest(Imp imp, BidRequest request, String url) {\n+        final BidRequest outgoingRequest = request.toBuilder().imp(Collections.singletonList(imp)).build();\n+\n+        final String body = Json.encode(outgoingRequest);\n+\n+        return HttpRequest.<BidRequest>builder()\n+                .method(HttpMethod.POST)\n+                .uri(url)\n+                .headers(resolveHeaders())\n+                .body(body)\n+                .payload(outgoingRequest)\n+                .build();\n+    }\n+\n+    private MultiMap resolveHeaders() {\n+        return HttpUtil.headers();\n+    }\n+\n+    private ExtImpApplogy parseAndValidateImpExt(Imp imp) {\n+        final ExtImpApplogy extImpApplogy;\n+        try {\n+            extImpApplogy = Json.mapper.convertValue(imp.getExt(), APPLOGY_EXT_TYPE_REFERENCE)\n+                    .getBidder();\n+        } catch (IllegalArgumentException e) {\n+            throw new PreBidException(e.getMessage());\n+        }\n+\n+        if (extImpApplogy == null) {\n+            throw new PreBidException(\"impression extensions required\");\n+        }\n+\n+        if (StringUtils.isBlank(extImpApplogy.getToken())) {\n+            throw new PreBidException(\"token is empty\");\n+        }\n+        return extImpApplogy;\n+    }\n+\n+    private Imp processImp(Imp imp) {\n+        if (imp.getBanner() == null && imp.getVideo() == null && imp.getXNative() == null) {\n+            throw new PreBidException(\"Applogy only supports banner, video or native ads\");\n+        }\n+\n+        Banner banner = imp.getBanner();\n+        if (banner != null) {\n+            if (banner.getH() == null || banner.getW() == null || banner.getH() == 0 || banner.getW() == 0) {\n+                if (banner.getFormat() == null) {\n+                    throw new PreBidException(\"banner size information missing\");\n+                }\n+\n+                final Format firstFormat = banner.getFormat().get(0);\n+                final Banner modifiedBanner = banner.toBuilder()\n+                        .h(firstFormat.getH())\n+                        .w(firstFormat.getW())\n+                        .build();\n+                return imp.toBuilder().banner(modifiedBanner).build();\n+            }\n+        }\n+        return imp;\n+    }\n+\n+    @Override\n+    public Result<List<BidderBid>> makeBids(HttpCall<BidRequest> httpCall, BidRequest bidRequest) {\n+        if (httpCall.getResponse().getStatusCode() == HttpResponseStatus.NO_CONTENT.code()) {\n+            return Result.of(Collections.emptyList(), Collections.emptyList());\n+        }\n+\n+        try {\n+            final BidResponse bidResponse = Json.decodeValue(httpCall.getResponse().getBody(), BidResponse.class);\n+            return extractBids(httpCall.getRequest().getPayload(), bidResponse);\n+        } catch (DecodeException e) {\n+            return Result.emptyWithError(BidderError.badServerResponse(\"failed to decode json\"));\n+        }\n+    }\n+\n+    private static Result<List<BidderBid>> extractBids(BidRequest bidRequest, BidResponse bidResponse) {\n+        if (bidResponse == null || bidResponse.getSeatbid() == null) {\n+            return Result.of(Collections.emptyList(), Collections.emptyList());\n+        }\n+        final List<BidderError> errors = new ArrayList<>();\n+        final List<BidderBid> bidderBids = bidResponse.getSeatbid().stream()\n+                .filter(Objects::nonNull)\n+                .map(SeatBid::getBid)\n+                .filter(Objects::nonNull)\n+                .flatMap(Collection::stream)\n+                .map(bid -> bidFromResponse(bidRequest, bid, errors))\n+                .filter(Objects::nonNull)\n+                .collect(Collectors.toList());\n+        return Result.of(bidderBids, errors);\n+    }\n+\n+    private static BidderBid bidFromResponse(BidRequest bidRequest, Bid bid, List<BidderError> errors) {\n+        try {\n+            final BidType bidType = getBidType(bid.getImpid(), bidRequest.getImp());\n+            return BidderBid.of(bid, bidType, DEFAULT_BID_CURRENCY);\n+        } catch (PreBidException e) {\n+            errors.add(BidderError.badInput(e.getMessage()));\n+            return null;\n+        }\n+    }\n+\n+    private static BidType getBidType(String impId, List<Imp> imps) {\n+        for (Imp imp : imps) {\n+            if (imp.getId().equals(impId)) {\n+                if (imp.getBanner() != null) {\n+                    return BidType.banner;\n+                } else if (imp.getVideo() != null) {\n+                    return BidType.video;\n+                } else if (imp.getXNative() != null) {\n+                    return BidType.xNative;\n+                }\n+            }\n+        }\n+        throw new PreBidException(String.format(\"Failed to find impression %s\", impId));\n+    }\n+\n+    @Override\n+    public Map<String, String> extractTargeting(ObjectNode ext) {\n+        return Collections.emptyMap();\n+    }\n+", "originalCommit": "92ce591c4bd02f4a261016f18b3958b411bf69cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjUxMDU2MQ==", "url": "https://github.com/prebid/prebid-server-java/pull/583#discussion_r366510561", "bodyText": "Please exclude any changes to Rubicon-related files.", "author": "RossGoncharuk", "createdAt": "2020-01-14T18:48:28Z", "path": "src/main/java/org/prebid/server/proto/openrtb/ext/request/rubicon/ExtImpRubicon.java", "diffHunk": "@@ -32,4 +32,5 @@\n     RubiconVideoParams video;\n \n     String pchain;\n+", "originalCommit": "92ce591c4bd02f4a261016f18b3958b411bf69cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIxNjA5OQ==", "url": "https://github.com/prebid/prebid-server-java/pull/583#discussion_r367216099", "bodyText": "Have you rolled back Rubicon files?", "author": "RossGoncharuk", "createdAt": "2020-01-16T03:32:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjUxMDU2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjUxMDk2MQ==", "url": "https://github.com/prebid/prebid-server-java/pull/583#discussion_r366510961", "bodyText": "An empty line should be added here as well. After the last symbol/class", "author": "RossGoncharuk", "createdAt": "2020-01-14T18:49:15Z", "path": "src/main/java/org/prebid/server/spring/config/bidder/ApplogyConfiguration.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package org.prebid.server.spring.config.bidder;\n+\n+import org.prebid.server.bidder.BidderDeps;\n+import org.prebid.server.bidder.applogy.ApplogyBidder;\n+import org.prebid.server.spring.config.bidder.model.BidderConfigurationProperties;\n+import org.prebid.server.spring.config.bidder.util.BidderDepsAssembler;\n+import org.prebid.server.spring.config.bidder.util.BidderInfoCreator;\n+import org.prebid.server.spring.config.bidder.util.UsersyncerCreator;\n+import org.prebid.server.spring.env.YamlPropertySourceFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.boot.context.properties.ConfigurationProperties;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.context.annotation.PropertySource;\n+\n+import javax.validation.constraints.NotBlank;\n+\n+@Configuration\n+@PropertySource(value = \"classpath:/bidder-config/applogy.yaml\", factory = YamlPropertySourceFactory.class)\n+public class ApplogyConfiguration {\n+\n+    private static final String BIDDER_NAME = \"applogy\";\n+\n+    @Value(\"${external-url}\")\n+    @NotBlank\n+    private String externalUrl;\n+\n+    @Autowired\n+    @Qualifier(\"applogyConfigurationProperties\")\n+    private BidderConfigurationProperties configProperties;\n+\n+    @Bean(\"applogyConfigurationProperties\")\n+    @ConfigurationProperties(\"adapters.applogy\")\n+    BidderConfigurationProperties configurationProperties() {\n+        return new BidderConfigurationProperties();\n+    }\n+\n+    @Bean\n+    BidderDeps applogyBidderDeps() {\n+        return BidderDepsAssembler.forBidder(BIDDER_NAME)\n+                .withConfig(configProperties)\n+                .bidderInfo(BidderInfoCreator.create(configProperties))\n+                .usersyncerCreator(UsersyncerCreator.create(configProperties.getUsersync(), externalUrl))\n+                .bidderCreator(() -> new ApplogyBidder(configProperties.getEndpoint()))\n+                .assemble();\n+    }\n+}", "originalCommit": "92ce591c4bd02f4a261016f18b3958b411bf69cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjUxMTkwOQ==", "url": "https://github.com/prebid/prebid-server-java/pull/583#discussion_r366511909", "bodyText": "Minor, but please add a space (empty line) between the class and the first class constant. Let's keep it clean and clear.", "author": "RossGoncharuk", "createdAt": "2020-01-14T18:51:10Z", "path": "src/main/java/org/prebid/server/bidder/applogy/ApplogyBidder.java", "diffHunk": "@@ -0,0 +1,190 @@\n+package org.prebid.server.bidder.applogy;\n+\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.iab.openrtb.request.Banner;\n+import com.iab.openrtb.request.BidRequest;\n+import com.iab.openrtb.request.Format;\n+import com.iab.openrtb.request.Imp;\n+import com.iab.openrtb.response.Bid;\n+import com.iab.openrtb.response.BidResponse;\n+import com.iab.openrtb.response.SeatBid;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.vertx.core.MultiMap;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.json.DecodeException;\n+import io.vertx.core.json.Json;\n+import org.apache.commons.lang3.StringUtils;\n+import org.prebid.server.bidder.Bidder;\n+import org.prebid.server.bidder.model.BidderBid;\n+import org.prebid.server.bidder.model.BidderError;\n+import org.prebid.server.bidder.model.HttpCall;\n+import org.prebid.server.bidder.model.HttpRequest;\n+import org.prebid.server.bidder.model.Result;\n+import org.prebid.server.exception.PreBidException;\n+import org.prebid.server.proto.openrtb.ext.ExtPrebid;\n+import org.prebid.server.proto.openrtb.ext.request.applogy.ExtImpApplogy;\n+import org.prebid.server.proto.openrtb.ext.response.BidType;\n+import org.prebid.server.util.HttpUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class ApplogyBidder implements Bidder<BidRequest> {\n+    private static final TypeReference<ExtPrebid<?, ExtImpApplogy>> APPLOGY_EXT_TYPE_REFERENCE =", "originalCommit": "92ce591c4bd02f4a261016f18b3958b411bf69cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjUxMjYxOQ==", "url": "https://github.com/prebid/prebid-server-java/pull/583#discussion_r366512619", "bodyText": "Although test files are not checked by project's checkstyle, please be sure to keep they in the same style and clean up whatever is unnecessary - in this case, please remove this extra empty line.", "author": "RossGoncharuk", "createdAt": "2020-01-14T18:52:29Z", "path": "src/test/java/org/prebid/server/bidder/applogy/ApplogyBidderTest.java", "diffHunk": "@@ -0,0 +1,293 @@\n+package org.prebid.server.bidder.applogy;\n+\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.iab.openrtb.request.Audio;\n+import com.iab.openrtb.request.Banner;\n+import com.iab.openrtb.request.BidRequest;\n+import com.iab.openrtb.request.Format;\n+import com.iab.openrtb.request.Imp;\n+import com.iab.openrtb.request.Video;\n+import com.iab.openrtb.response.Bid;\n+import com.iab.openrtb.response.BidResponse;\n+import com.iab.openrtb.response.SeatBid;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.prebid.server.VertxTest;\n+import org.prebid.server.bidder.model.BidderBid;\n+import org.prebid.server.bidder.model.BidderError;\n+import org.prebid.server.bidder.model.HttpCall;\n+import org.prebid.server.bidder.model.HttpRequest;\n+import org.prebid.server.bidder.model.HttpResponse;\n+import org.prebid.server.bidder.model.Result;\n+import org.prebid.server.proto.openrtb.ext.ExtPrebid;\n+import org.prebid.server.proto.openrtb.ext.request.applogy.ExtImpApplogy;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyMap;\n+import static java.util.Collections.singletonList;\n+import static java.util.function.Function.identity;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\n+import static org.assertj.core.api.Assertions.tuple;\n+import static org.prebid.server.proto.openrtb.ext.response.BidType.banner;\n+import static org.prebid.server.proto.openrtb.ext.response.BidType.video;\n+\n+public class ApplogyBidderTest extends VertxTest {\n+", "originalCommit": "92ce591c4bd02f4a261016f18b3958b411bf69cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjUxNDA3MA==", "url": "https://github.com/prebid/prebid-server-java/pull/583#discussion_r366514070", "bodyText": "Please remove these two empty lines and add one after last symbol/class", "author": "RossGoncharuk", "createdAt": "2020-01-14T18:55:26Z", "path": "src/test/java/org/prebid/server/bidder/applogy/ApplogyBidderTest.java", "diffHunk": "@@ -0,0 +1,293 @@\n+package org.prebid.server.bidder.applogy;\n+\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.iab.openrtb.request.Audio;\n+import com.iab.openrtb.request.Banner;\n+import com.iab.openrtb.request.BidRequest;\n+import com.iab.openrtb.request.Format;\n+import com.iab.openrtb.request.Imp;\n+import com.iab.openrtb.request.Video;\n+import com.iab.openrtb.response.Bid;\n+import com.iab.openrtb.response.BidResponse;\n+import com.iab.openrtb.response.SeatBid;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.prebid.server.VertxTest;\n+import org.prebid.server.bidder.model.BidderBid;\n+import org.prebid.server.bidder.model.BidderError;\n+import org.prebid.server.bidder.model.HttpCall;\n+import org.prebid.server.bidder.model.HttpRequest;\n+import org.prebid.server.bidder.model.HttpResponse;\n+import org.prebid.server.bidder.model.Result;\n+import org.prebid.server.proto.openrtb.ext.ExtPrebid;\n+import org.prebid.server.proto.openrtb.ext.request.applogy.ExtImpApplogy;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyMap;\n+import static java.util.Collections.singletonList;\n+import static java.util.function.Function.identity;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\n+import static org.assertj.core.api.Assertions.tuple;\n+import static org.prebid.server.proto.openrtb.ext.response.BidType.banner;\n+import static org.prebid.server.proto.openrtb.ext.response.BidType.video;\n+\n+public class ApplogyBidderTest extends VertxTest {\n+\n+\n+    private static final String ENDPOINT_URL = \"https://test.endpoint.com\";\n+\n+    private ApplogyBidder applogyBidder;\n+\n+    @Before\n+    public void setUp() {\n+        applogyBidder = new ApplogyBidder(ENDPOINT_URL);\n+    }\n+\n+    @Test\n+    public void creationShouldFailOnInvalidEndpointUrl() {\n+        assertThatIllegalArgumentException().isThrownBy(() -> new ApplogyBidder(\"invalid_url\"));\n+    }\n+\n+    @Test\n+    public void makeHttpRequestsShouldSkipEmptyTokens() {\n+        // given\n+        final BidRequest bidRequest = givenBidRequest(\n+                impBuilder -> impBuilder\n+                        .ext(mapper.valueToTree(ExtPrebid.of(null,\n+                                ExtImpApplogy.of(null)))));\n+\n+        // when\n+        final Result<List<HttpRequest<BidRequest>>> result = applogyBidder.makeHttpRequests(bidRequest);\n+\n+        // then\n+        assertThat(result.getErrors()).hasSize(1)\n+                .containsOnly(BidderError.badInput(\n+                        \"token is empty\"));\n+    }\n+\n+    @Test\n+    public void makeHttpRequestsShouldSkipInvalidImpressionAndAddError() {\n+        // given\n+        ExtPrebid<?, ExtImpApplogy> ext = ExtPrebid.of(null, ExtImpApplogy.of(\"token1\"));\n+        Imp imp = givenImp(\n+                impBuilder -> impBuilder\n+                        .banner(null)\n+                        .id(\"2\")\n+                        .ext(mapper.valueToTree(ext))\n+                        .banner(Banner.builder().w(300).h(400).build())\n+        );\n+        final BidRequest bidRequest = BidRequest.builder()\n+                .imp(asList(\n+                        imp,\n+                        givenImp(impBuilder -> impBuilder\n+                                .banner(null)\n+                                .id(\"2\")\n+                                .ext(mapper.valueToTree(ext))\n+                                .audio(Audio.builder().build()))))\n+                .build();\n+\n+        // when\n+        final Result<List<HttpRequest<BidRequest>>> result = applogyBidder.makeHttpRequests(bidRequest);\n+\n+        // then\n+        assertThat(result.getErrors()).hasSize(1)\n+                .containsOnly(BidderError.badInput(\n+                        \"Applogy only supports banner, video or native ads\"));\n+        assertThat(result.getValue()).hasSize(1)\n+                .extracting(httpRequest -> mapper.readValue(httpRequest.getBody(), BidRequest.class))\n+                .flatExtracting(BidRequest::getImp)\n+                .containsOnly(imp);\n+    }\n+\n+\n+    @Test\n+    public void makeBidsShouldReturnErrorWhenResponseBodyCouldNotBeParsed() {\n+        // given\n+        final HttpCall<BidRequest> httpCall = givenHttpCall(null, \"invalid\");\n+\n+        // when\n+        final Result<List<BidderBid>> result = applogyBidder.makeBids(httpCall, null);\n+\n+        // then\n+        assertThat(result.getErrors()).hasSize(1);\n+        assertThat(result.getErrors().get(0).getMessage()).startsWith(\"failed to decode json\");\n+        assertThat(result.getErrors().get(0).getType()).isEqualTo(BidderError.Type.bad_server_response);\n+        assertThat(result.getValue()).isEmpty();\n+    }\n+\n+    @Test\n+    public void makeBidsShouldReturnEmptyResultWhenResponseWithNoContent() {\n+        // given\n+        final HttpCall<BidRequest> httpCall = HttpCall\n+                .success(null, HttpResponse.of(204, null, null), null);\n+\n+        // when\n+        final Result<List<BidderBid>> result = applogyBidder.makeBids(httpCall, null);\n+\n+        // then\n+        assertThat(result.getErrors()).isEmpty();\n+        assertThat(result.getValue()).isEmpty();\n+    }\n+\n+\n+    @Test\n+    public void makeHttpRequestsShouldNotChangeBannerWidthAndHeightIfPresent() {\n+        // given\n+        final BidRequest bidRequest = givenBidRequest(\n+                impBuilder -> impBuilder\n+                        .banner(Banner.builder()\n+                                .format(singletonList(Format.builder().w(300).h(500).build()))\n+                                .w(200)\n+                                .h(150)\n+                                .build()));\n+\n+        // when\n+        final Result<List<HttpRequest<BidRequest>>> result = applogyBidder.makeHttpRequests(bidRequest);\n+\n+        // then\n+        assertThat(result.getErrors()).isEmpty();\n+        assertThat(result.getValue()).hasSize(1)\n+                .extracting(httpRequest -> mapper.readValue(httpRequest.getBody(), BidRequest.class))\n+                .flatExtracting(BidRequest::getImp)\n+                .extracting(Imp::getBanner)\n+                .extracting(Banner::getW, Banner::getH)\n+                .containsOnly(tuple(200, 150));\n+    }\n+\n+\n+    @Test\n+    public void makeHttpRequestsShouldSetBannerWidthAndHeightFromFirstFormatIfEmpty() {\n+        // given\n+        final BidRequest bidRequest = givenBidRequest(\n+                impBuilder -> impBuilder\n+                        .banner(Banner.builder()\n+                                .format(Arrays.asList(Format.builder().w(300).h(500).build(),\n+                                        Format.builder().w(450).h(150).build()))\n+                                .build()));\n+\n+        // when\n+        final Result<List<HttpRequest<BidRequest>>> result = applogyBidder.makeHttpRequests(bidRequest);\n+\n+        // then\n+        assertThat(result.getErrors()).isEmpty();\n+        assertThat(result.getValue()).hasSize(1)\n+                .extracting(httpRequest -> mapper.readValue(httpRequest.getBody(), BidRequest.class))\n+                .flatExtracting(BidRequest::getImp)\n+                .extracting(Imp::getBanner)\n+                .extracting(Banner::getW, Banner::getH)\n+                .containsOnly(tuple(300, 500));\n+    }\n+\n+\n+    @Test\n+    public void makeBidsShouldReturnErrorIfResponseBodyCouldNotBeParsed() {\n+        // given\n+        final HttpCall<BidRequest> httpCall = givenHttpCall(null, \"invalid\");\n+\n+        // when\n+        final Result<List<BidderBid>> result = applogyBidder.makeBids(httpCall, null);\n+\n+        // then\n+        assertThat(result.getErrors()).hasSize(1);\n+        assertThat(result.getErrors().get(0).getMessage()).startsWith(\"failed to decode json\");\n+        assertThat(result.getErrors().get(0).getType()).isEqualTo(BidderError.Type.bad_server_response);\n+        assertThat(result.getValue()).isEmpty();\n+    }\n+\n+    @Test\n+    public void makeBidsShouldReturnEmptyListIfBidResponseIsNull() throws JsonProcessingException {\n+        // given\n+        final HttpCall<BidRequest> httpCall = givenHttpCall(null,\n+                mapper.writeValueAsString(null));\n+\n+        // when\n+        final Result<List<BidderBid>> result = applogyBidder.makeBids(httpCall, null);\n+\n+        // then\n+        assertThat(result.getErrors()).isEmpty();\n+        assertThat(result.getValue()).isEmpty();\n+    }\n+\n+    @Test\n+    public void makeBidsShouldReturnEmptyListIfBidResponseSeatBidIsNull() throws JsonProcessingException {\n+        // given\n+        final HttpCall<BidRequest> httpCall = givenHttpCall(null,\n+                mapper.writeValueAsString(BidResponse.builder().build()));\n+\n+        // when\n+        final Result<List<BidderBid>> result = applogyBidder.makeBids(httpCall, null);\n+\n+        // then\n+        assertThat(result.getErrors()).isEmpty();\n+        assertThat(result.getValue()).isEmpty();\n+    }\n+\n+    @Test\n+    public void makeBidsShouldReturnVideoBidIfVideoIsPresentInRequestImp() throws JsonProcessingException {\n+        // given\n+        final HttpCall<BidRequest> httpCall = givenHttpCall(\n+                BidRequest.builder()\n+                        .imp(singletonList(Imp.builder().id(\"123\").video(Video.builder().build()).build()))\n+                        .build(),\n+                mapper.writeValueAsString(\n+                        givenBidResponse(bidBuilder -> bidBuilder.impid(\"123\"))));\n+\n+        // when\n+        final Result<List<BidderBid>> result = applogyBidder.makeBids(httpCall, null);\n+\n+        // then\n+        assertThat(result.getErrors()).isEmpty();\n+        assertThat(result.getValue())\n+                .containsOnly(BidderBid.of(Bid.builder().impid(\"123\").build(), video, \"USD\"));\n+    }\n+\n+    @Test\n+    public void extractTargetingShouldReturnEmptyMap() {\n+        assertThat(applogyBidder.extractTargeting(mapper.createObjectNode())).isEqualTo(emptyMap());\n+    }\n+\n+    private static BidRequest givenBidRequest(\n+            Function<BidRequest.BidRequestBuilder, BidRequest.BidRequestBuilder> bidRequestCustomizer,\n+            Function<Imp.ImpBuilder, Imp.ImpBuilder> impCustomizer) {\n+\n+        return bidRequestCustomizer.apply(BidRequest.builder()\n+                .imp(singletonList(givenImp(impCustomizer))))\n+                .build();\n+    }\n+\n+    private static BidRequest givenBidRequest(Function<Imp.ImpBuilder, Imp.ImpBuilder> impCustomizer) {\n+        return givenBidRequest(identity(), impCustomizer);\n+    }\n+\n+    private static Imp givenImp(Function<Imp.ImpBuilder, Imp.ImpBuilder> impCustomizer) {\n+        return impCustomizer.apply(Imp.builder()\n+                .id(\"123\")\n+                .banner(Banner.builder().id(\"banner_id\").build())\n+                .ext(mapper.valueToTree(ExtPrebid.of(null,\n+                        ExtImpApplogy.of(\"token\")))))\n+                .build();\n+    }\n+\n+    private static BidResponse givenBidResponse(Function<Bid.BidBuilder, Bid.BidBuilder> bidCustomizer) {\n+        return BidResponse.builder()\n+                .seatbid(singletonList(SeatBid.builder()\n+                        .bid(singletonList(bidCustomizer.apply(Bid.builder()).build()))\n+                        .build()))\n+                .build();\n+    }\n+\n+    private static HttpCall<BidRequest> givenHttpCall(BidRequest bidRequest, String body) {\n+        return HttpCall.success(\n+                HttpRequest.<BidRequest>builder().payload(bidRequest).build(),\n+                HttpResponse.of(200, null, body),\n+                null);\n+    }\n+", "originalCommit": "92ce591c4bd02f4a261016f18b3958b411bf69cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjUxNjA2NA==", "url": "https://github.com/prebid/prebid-server-java/pull/583#discussion_r366516064", "bodyText": "No need to jump to next line, in this case it would be better to keep ExtImpApplogy.of(\"token\") param in the same line as null param.\nNote - sometimes IDE can add parameters' names which would move the code and look like it is larger then it actually is. You should ignore such cases and always check the length only for the actual code, excluding the \"tips\".\nPlease check all similar cases here in tests. Thanks!", "author": "RossGoncharuk", "createdAt": "2020-01-14T18:59:31Z", "path": "src/test/java/org/prebid/server/bidder/applogy/ApplogyBidderTest.java", "diffHunk": "@@ -0,0 +1,293 @@\n+package org.prebid.server.bidder.applogy;\n+\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.iab.openrtb.request.Audio;\n+import com.iab.openrtb.request.Banner;\n+import com.iab.openrtb.request.BidRequest;\n+import com.iab.openrtb.request.Format;\n+import com.iab.openrtb.request.Imp;\n+import com.iab.openrtb.request.Video;\n+import com.iab.openrtb.response.Bid;\n+import com.iab.openrtb.response.BidResponse;\n+import com.iab.openrtb.response.SeatBid;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.prebid.server.VertxTest;\n+import org.prebid.server.bidder.model.BidderBid;\n+import org.prebid.server.bidder.model.BidderError;\n+import org.prebid.server.bidder.model.HttpCall;\n+import org.prebid.server.bidder.model.HttpRequest;\n+import org.prebid.server.bidder.model.HttpResponse;\n+import org.prebid.server.bidder.model.Result;\n+import org.prebid.server.proto.openrtb.ext.ExtPrebid;\n+import org.prebid.server.proto.openrtb.ext.request.applogy.ExtImpApplogy;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyMap;\n+import static java.util.Collections.singletonList;\n+import static java.util.function.Function.identity;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\n+import static org.assertj.core.api.Assertions.tuple;\n+import static org.prebid.server.proto.openrtb.ext.response.BidType.banner;\n+import static org.prebid.server.proto.openrtb.ext.response.BidType.video;\n+\n+public class ApplogyBidderTest extends VertxTest {\n+\n+\n+    private static final String ENDPOINT_URL = \"https://test.endpoint.com\";\n+\n+    private ApplogyBidder applogyBidder;\n+\n+    @Before\n+    public void setUp() {\n+        applogyBidder = new ApplogyBidder(ENDPOINT_URL);\n+    }\n+\n+    @Test\n+    public void creationShouldFailOnInvalidEndpointUrl() {\n+        assertThatIllegalArgumentException().isThrownBy(() -> new ApplogyBidder(\"invalid_url\"));\n+    }\n+\n+    @Test\n+    public void makeHttpRequestsShouldSkipEmptyTokens() {\n+        // given\n+        final BidRequest bidRequest = givenBidRequest(\n+                impBuilder -> impBuilder\n+                        .ext(mapper.valueToTree(ExtPrebid.of(null,\n+                                ExtImpApplogy.of(null)))));\n+\n+        // when\n+        final Result<List<HttpRequest<BidRequest>>> result = applogyBidder.makeHttpRequests(bidRequest);\n+\n+        // then\n+        assertThat(result.getErrors()).hasSize(1)\n+                .containsOnly(BidderError.badInput(\n+                        \"token is empty\"));\n+    }\n+\n+    @Test\n+    public void makeHttpRequestsShouldSkipInvalidImpressionAndAddError() {\n+        // given\n+        ExtPrebid<?, ExtImpApplogy> ext = ExtPrebid.of(null, ExtImpApplogy.of(\"token1\"));\n+        Imp imp = givenImp(\n+                impBuilder -> impBuilder\n+                        .banner(null)\n+                        .id(\"2\")\n+                        .ext(mapper.valueToTree(ext))\n+                        .banner(Banner.builder().w(300).h(400).build())\n+        );\n+        final BidRequest bidRequest = BidRequest.builder()\n+                .imp(asList(\n+                        imp,\n+                        givenImp(impBuilder -> impBuilder\n+                                .banner(null)\n+                                .id(\"2\")\n+                                .ext(mapper.valueToTree(ext))\n+                                .audio(Audio.builder().build()))))\n+                .build();\n+\n+        // when\n+        final Result<List<HttpRequest<BidRequest>>> result = applogyBidder.makeHttpRequests(bidRequest);\n+\n+        // then\n+        assertThat(result.getErrors()).hasSize(1)\n+                .containsOnly(BidderError.badInput(\n+                        \"Applogy only supports banner, video or native ads\"));\n+        assertThat(result.getValue()).hasSize(1)\n+                .extracting(httpRequest -> mapper.readValue(httpRequest.getBody(), BidRequest.class))\n+                .flatExtracting(BidRequest::getImp)\n+                .containsOnly(imp);\n+    }\n+\n+\n+    @Test\n+    public void makeBidsShouldReturnErrorWhenResponseBodyCouldNotBeParsed() {\n+        // given\n+        final HttpCall<BidRequest> httpCall = givenHttpCall(null, \"invalid\");\n+\n+        // when\n+        final Result<List<BidderBid>> result = applogyBidder.makeBids(httpCall, null);\n+\n+        // then\n+        assertThat(result.getErrors()).hasSize(1);\n+        assertThat(result.getErrors().get(0).getMessage()).startsWith(\"failed to decode json\");\n+        assertThat(result.getErrors().get(0).getType()).isEqualTo(BidderError.Type.bad_server_response);\n+        assertThat(result.getValue()).isEmpty();\n+    }\n+\n+    @Test\n+    public void makeBidsShouldReturnEmptyResultWhenResponseWithNoContent() {\n+        // given\n+        final HttpCall<BidRequest> httpCall = HttpCall\n+                .success(null, HttpResponse.of(204, null, null), null);\n+\n+        // when\n+        final Result<List<BidderBid>> result = applogyBidder.makeBids(httpCall, null);\n+\n+        // then\n+        assertThat(result.getErrors()).isEmpty();\n+        assertThat(result.getValue()).isEmpty();\n+    }\n+\n+\n+    @Test\n+    public void makeHttpRequestsShouldNotChangeBannerWidthAndHeightIfPresent() {\n+        // given\n+        final BidRequest bidRequest = givenBidRequest(\n+                impBuilder -> impBuilder\n+                        .banner(Banner.builder()\n+                                .format(singletonList(Format.builder().w(300).h(500).build()))\n+                                .w(200)\n+                                .h(150)\n+                                .build()));\n+\n+        // when\n+        final Result<List<HttpRequest<BidRequest>>> result = applogyBidder.makeHttpRequests(bidRequest);\n+\n+        // then\n+        assertThat(result.getErrors()).isEmpty();\n+        assertThat(result.getValue()).hasSize(1)\n+                .extracting(httpRequest -> mapper.readValue(httpRequest.getBody(), BidRequest.class))\n+                .flatExtracting(BidRequest::getImp)\n+                .extracting(Imp::getBanner)\n+                .extracting(Banner::getW, Banner::getH)\n+                .containsOnly(tuple(200, 150));\n+    }\n+\n+\n+    @Test\n+    public void makeHttpRequestsShouldSetBannerWidthAndHeightFromFirstFormatIfEmpty() {\n+        // given\n+        final BidRequest bidRequest = givenBidRequest(\n+                impBuilder -> impBuilder\n+                        .banner(Banner.builder()\n+                                .format(Arrays.asList(Format.builder().w(300).h(500).build(),\n+                                        Format.builder().w(450).h(150).build()))\n+                                .build()));\n+\n+        // when\n+        final Result<List<HttpRequest<BidRequest>>> result = applogyBidder.makeHttpRequests(bidRequest);\n+\n+        // then\n+        assertThat(result.getErrors()).isEmpty();\n+        assertThat(result.getValue()).hasSize(1)\n+                .extracting(httpRequest -> mapper.readValue(httpRequest.getBody(), BidRequest.class))\n+                .flatExtracting(BidRequest::getImp)\n+                .extracting(Imp::getBanner)\n+                .extracting(Banner::getW, Banner::getH)\n+                .containsOnly(tuple(300, 500));\n+    }\n+\n+\n+    @Test\n+    public void makeBidsShouldReturnErrorIfResponseBodyCouldNotBeParsed() {\n+        // given\n+        final HttpCall<BidRequest> httpCall = givenHttpCall(null, \"invalid\");\n+\n+        // when\n+        final Result<List<BidderBid>> result = applogyBidder.makeBids(httpCall, null);\n+\n+        // then\n+        assertThat(result.getErrors()).hasSize(1);\n+        assertThat(result.getErrors().get(0).getMessage()).startsWith(\"failed to decode json\");\n+        assertThat(result.getErrors().get(0).getType()).isEqualTo(BidderError.Type.bad_server_response);\n+        assertThat(result.getValue()).isEmpty();\n+    }\n+\n+    @Test\n+    public void makeBidsShouldReturnEmptyListIfBidResponseIsNull() throws JsonProcessingException {\n+        // given\n+        final HttpCall<BidRequest> httpCall = givenHttpCall(null,\n+                mapper.writeValueAsString(null));\n+\n+        // when\n+        final Result<List<BidderBid>> result = applogyBidder.makeBids(httpCall, null);\n+\n+        // then\n+        assertThat(result.getErrors()).isEmpty();\n+        assertThat(result.getValue()).isEmpty();\n+    }\n+\n+    @Test\n+    public void makeBidsShouldReturnEmptyListIfBidResponseSeatBidIsNull() throws JsonProcessingException {\n+        // given\n+        final HttpCall<BidRequest> httpCall = givenHttpCall(null,\n+                mapper.writeValueAsString(BidResponse.builder().build()));\n+\n+        // when\n+        final Result<List<BidderBid>> result = applogyBidder.makeBids(httpCall, null);\n+\n+        // then\n+        assertThat(result.getErrors()).isEmpty();\n+        assertThat(result.getValue()).isEmpty();\n+    }\n+\n+    @Test\n+    public void makeBidsShouldReturnVideoBidIfVideoIsPresentInRequestImp() throws JsonProcessingException {\n+        // given\n+        final HttpCall<BidRequest> httpCall = givenHttpCall(\n+                BidRequest.builder()\n+                        .imp(singletonList(Imp.builder().id(\"123\").video(Video.builder().build()).build()))\n+                        .build(),\n+                mapper.writeValueAsString(\n+                        givenBidResponse(bidBuilder -> bidBuilder.impid(\"123\"))));\n+\n+        // when\n+        final Result<List<BidderBid>> result = applogyBidder.makeBids(httpCall, null);\n+\n+        // then\n+        assertThat(result.getErrors()).isEmpty();\n+        assertThat(result.getValue())\n+                .containsOnly(BidderBid.of(Bid.builder().impid(\"123\").build(), video, \"USD\"));\n+    }\n+\n+    @Test\n+    public void extractTargetingShouldReturnEmptyMap() {\n+        assertThat(applogyBidder.extractTargeting(mapper.createObjectNode())).isEqualTo(emptyMap());\n+    }\n+\n+    private static BidRequest givenBidRequest(\n+            Function<BidRequest.BidRequestBuilder, BidRequest.BidRequestBuilder> bidRequestCustomizer,\n+            Function<Imp.ImpBuilder, Imp.ImpBuilder> impCustomizer) {\n+\n+        return bidRequestCustomizer.apply(BidRequest.builder()\n+                .imp(singletonList(givenImp(impCustomizer))))\n+                .build();\n+    }\n+\n+    private static BidRequest givenBidRequest(Function<Imp.ImpBuilder, Imp.ImpBuilder> impCustomizer) {\n+        return givenBidRequest(identity(), impCustomizer);\n+    }\n+\n+    private static Imp givenImp(Function<Imp.ImpBuilder, Imp.ImpBuilder> impCustomizer) {\n+        return impCustomizer.apply(Imp.builder()\n+                .id(\"123\")\n+                .banner(Banner.builder().id(\"banner_id\").build())\n+                .ext(mapper.valueToTree(ExtPrebid.of(null,\n+                        ExtImpApplogy.of(\"token\")))))", "originalCommit": "92ce591c4bd02f4a261016f18b3958b411bf69cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjUxNzk0NA==", "url": "https://github.com/prebid/prebid-server-java/pull/583#discussion_r366517944", "bodyText": "The general approach (at least the one I use) is to either include all error cases first (as they appear in the method's flow) and then check all normal cases or go by methods flow combining error and regular cases. The first one is better and this is what we are using.\nSo here, please add a test case when there's an error while converting impression extension - check test named makeHttpRequestsShouldReturnErrorIfImpExtCouldNotBeParsed in other bidders' tests.\nThe key is to have all cases of possible inputs and resulting outputs covered to ensure all bidder aspects work as expected.", "author": "RossGoncharuk", "createdAt": "2020-01-14T19:03:38Z", "path": "src/test/java/org/prebid/server/bidder/applogy/ApplogyBidderTest.java", "diffHunk": "@@ -0,0 +1,293 @@\n+package org.prebid.server.bidder.applogy;\n+\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.iab.openrtb.request.Audio;\n+import com.iab.openrtb.request.Banner;\n+import com.iab.openrtb.request.BidRequest;\n+import com.iab.openrtb.request.Format;\n+import com.iab.openrtb.request.Imp;\n+import com.iab.openrtb.request.Video;\n+import com.iab.openrtb.response.Bid;\n+import com.iab.openrtb.response.BidResponse;\n+import com.iab.openrtb.response.SeatBid;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.prebid.server.VertxTest;\n+import org.prebid.server.bidder.model.BidderBid;\n+import org.prebid.server.bidder.model.BidderError;\n+import org.prebid.server.bidder.model.HttpCall;\n+import org.prebid.server.bidder.model.HttpRequest;\n+import org.prebid.server.bidder.model.HttpResponse;\n+import org.prebid.server.bidder.model.Result;\n+import org.prebid.server.proto.openrtb.ext.ExtPrebid;\n+import org.prebid.server.proto.openrtb.ext.request.applogy.ExtImpApplogy;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyMap;\n+import static java.util.Collections.singletonList;\n+import static java.util.function.Function.identity;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\n+import static org.assertj.core.api.Assertions.tuple;\n+import static org.prebid.server.proto.openrtb.ext.response.BidType.banner;\n+import static org.prebid.server.proto.openrtb.ext.response.BidType.video;\n+\n+public class ApplogyBidderTest extends VertxTest {\n+\n+\n+    private static final String ENDPOINT_URL = \"https://test.endpoint.com\";\n+\n+    private ApplogyBidder applogyBidder;\n+\n+    @Before\n+    public void setUp() {\n+        applogyBidder = new ApplogyBidder(ENDPOINT_URL);\n+    }\n+\n+    @Test\n+    public void creationShouldFailOnInvalidEndpointUrl() {\n+        assertThatIllegalArgumentException().isThrownBy(() -> new ApplogyBidder(\"invalid_url\"));\n+    }\n+", "originalCommit": "92ce591c4bd02f4a261016f18b3958b411bf69cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjUxOTMwOQ==", "url": "https://github.com/prebid/prebid-server-java/pull/583#discussion_r366519309", "bodyText": "No need to switch to next line, stay in one line where it is possible and doesn't harm code readability. Check other cases.", "author": "RossGoncharuk", "createdAt": "2020-01-14T19:06:44Z", "path": "src/test/java/org/prebid/server/bidder/applogy/ApplogyBidderTest.java", "diffHunk": "@@ -0,0 +1,293 @@\n+package org.prebid.server.bidder.applogy;\n+\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.iab.openrtb.request.Audio;\n+import com.iab.openrtb.request.Banner;\n+import com.iab.openrtb.request.BidRequest;\n+import com.iab.openrtb.request.Format;\n+import com.iab.openrtb.request.Imp;\n+import com.iab.openrtb.request.Video;\n+import com.iab.openrtb.response.Bid;\n+import com.iab.openrtb.response.BidResponse;\n+import com.iab.openrtb.response.SeatBid;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.prebid.server.VertxTest;\n+import org.prebid.server.bidder.model.BidderBid;\n+import org.prebid.server.bidder.model.BidderError;\n+import org.prebid.server.bidder.model.HttpCall;\n+import org.prebid.server.bidder.model.HttpRequest;\n+import org.prebid.server.bidder.model.HttpResponse;\n+import org.prebid.server.bidder.model.Result;\n+import org.prebid.server.proto.openrtb.ext.ExtPrebid;\n+import org.prebid.server.proto.openrtb.ext.request.applogy.ExtImpApplogy;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyMap;\n+import static java.util.Collections.singletonList;\n+import static java.util.function.Function.identity;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\n+import static org.assertj.core.api.Assertions.tuple;\n+import static org.prebid.server.proto.openrtb.ext.response.BidType.banner;\n+import static org.prebid.server.proto.openrtb.ext.response.BidType.video;\n+\n+public class ApplogyBidderTest extends VertxTest {\n+\n+\n+    private static final String ENDPOINT_URL = \"https://test.endpoint.com\";\n+\n+    private ApplogyBidder applogyBidder;\n+\n+    @Before\n+    public void setUp() {\n+        applogyBidder = new ApplogyBidder(ENDPOINT_URL);\n+    }\n+\n+    @Test\n+    public void creationShouldFailOnInvalidEndpointUrl() {\n+        assertThatIllegalArgumentException().isThrownBy(() -> new ApplogyBidder(\"invalid_url\"));\n+    }\n+\n+    @Test\n+    public void makeHttpRequestsShouldSkipEmptyTokens() {\n+        // given\n+        final BidRequest bidRequest = givenBidRequest(\n+                impBuilder -> impBuilder\n+                        .ext(mapper.valueToTree(ExtPrebid.of(null,\n+                                ExtImpApplogy.of(null)))));\n+\n+        // when\n+        final Result<List<HttpRequest<BidRequest>>> result = applogyBidder.makeHttpRequests(bidRequest);\n+\n+        // then\n+        assertThat(result.getErrors()).hasSize(1)\n+                .containsOnly(BidderError.badInput(\n+                        \"token is empty\"));", "originalCommit": "92ce591c4bd02f4a261016f18b3958b411bf69cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjUyMDI1Nw==", "url": "https://github.com/prebid/prebid-server-java/pull/583#discussion_r366520257", "bodyText": "This should be placed after all makeHttpRequests method cases. Please ensure the correct tests order.", "author": "RossGoncharuk", "createdAt": "2020-01-14T19:08:46Z", "path": "src/test/java/org/prebid/server/bidder/applogy/ApplogyBidderTest.java", "diffHunk": "@@ -0,0 +1,293 @@\n+package org.prebid.server.bidder.applogy;\n+\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.iab.openrtb.request.Audio;\n+import com.iab.openrtb.request.Banner;\n+import com.iab.openrtb.request.BidRequest;\n+import com.iab.openrtb.request.Format;\n+import com.iab.openrtb.request.Imp;\n+import com.iab.openrtb.request.Video;\n+import com.iab.openrtb.response.Bid;\n+import com.iab.openrtb.response.BidResponse;\n+import com.iab.openrtb.response.SeatBid;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.prebid.server.VertxTest;\n+import org.prebid.server.bidder.model.BidderBid;\n+import org.prebid.server.bidder.model.BidderError;\n+import org.prebid.server.bidder.model.HttpCall;\n+import org.prebid.server.bidder.model.HttpRequest;\n+import org.prebid.server.bidder.model.HttpResponse;\n+import org.prebid.server.bidder.model.Result;\n+import org.prebid.server.proto.openrtb.ext.ExtPrebid;\n+import org.prebid.server.proto.openrtb.ext.request.applogy.ExtImpApplogy;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyMap;\n+import static java.util.Collections.singletonList;\n+import static java.util.function.Function.identity;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\n+import static org.assertj.core.api.Assertions.tuple;\n+import static org.prebid.server.proto.openrtb.ext.response.BidType.banner;\n+import static org.prebid.server.proto.openrtb.ext.response.BidType.video;\n+\n+public class ApplogyBidderTest extends VertxTest {\n+\n+\n+    private static final String ENDPOINT_URL = \"https://test.endpoint.com\";\n+\n+    private ApplogyBidder applogyBidder;\n+\n+    @Before\n+    public void setUp() {\n+        applogyBidder = new ApplogyBidder(ENDPOINT_URL);\n+    }\n+\n+    @Test\n+    public void creationShouldFailOnInvalidEndpointUrl() {\n+        assertThatIllegalArgumentException().isThrownBy(() -> new ApplogyBidder(\"invalid_url\"));\n+    }\n+\n+    @Test\n+    public void makeHttpRequestsShouldSkipEmptyTokens() {\n+        // given\n+        final BidRequest bidRequest = givenBidRequest(\n+                impBuilder -> impBuilder\n+                        .ext(mapper.valueToTree(ExtPrebid.of(null,\n+                                ExtImpApplogy.of(null)))));\n+\n+        // when\n+        final Result<List<HttpRequest<BidRequest>>> result = applogyBidder.makeHttpRequests(bidRequest);\n+\n+        // then\n+        assertThat(result.getErrors()).hasSize(1)\n+                .containsOnly(BidderError.badInput(\n+                        \"token is empty\"));\n+    }\n+\n+    @Test\n+    public void makeHttpRequestsShouldSkipInvalidImpressionAndAddError() {\n+        // given\n+        ExtPrebid<?, ExtImpApplogy> ext = ExtPrebid.of(null, ExtImpApplogy.of(\"token1\"));\n+        Imp imp = givenImp(\n+                impBuilder -> impBuilder\n+                        .banner(null)\n+                        .id(\"2\")\n+                        .ext(mapper.valueToTree(ext))\n+                        .banner(Banner.builder().w(300).h(400).build())\n+        );\n+        final BidRequest bidRequest = BidRequest.builder()\n+                .imp(asList(\n+                        imp,\n+                        givenImp(impBuilder -> impBuilder\n+                                .banner(null)\n+                                .id(\"2\")\n+                                .ext(mapper.valueToTree(ext))\n+                                .audio(Audio.builder().build()))))\n+                .build();\n+\n+        // when\n+        final Result<List<HttpRequest<BidRequest>>> result = applogyBidder.makeHttpRequests(bidRequest);\n+\n+        // then\n+        assertThat(result.getErrors()).hasSize(1)\n+                .containsOnly(BidderError.badInput(\n+                        \"Applogy only supports banner, video or native ads\"));\n+        assertThat(result.getValue()).hasSize(1)\n+                .extracting(httpRequest -> mapper.readValue(httpRequest.getBody(), BidRequest.class))\n+                .flatExtracting(BidRequest::getImp)\n+                .containsOnly(imp);\n+    }\n+\n+\n+    @Test\n+    public void makeBidsShouldReturnErrorWhenResponseBodyCouldNotBeParsed() {", "originalCommit": "92ce591c4bd02f4a261016f18b3958b411bf69cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjUyMDk4Nw==", "url": "https://github.com/prebid/prebid-server-java/pull/583#discussion_r366520987", "bodyText": "Duplicate of one you have above. Remove the one above as it is not placed where it should.", "author": "RossGoncharuk", "createdAt": "2020-01-14T19:10:18Z", "path": "src/test/java/org/prebid/server/bidder/applogy/ApplogyBidderTest.java", "diffHunk": "@@ -0,0 +1,293 @@\n+package org.prebid.server.bidder.applogy;\n+\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.iab.openrtb.request.Audio;\n+import com.iab.openrtb.request.Banner;\n+import com.iab.openrtb.request.BidRequest;\n+import com.iab.openrtb.request.Format;\n+import com.iab.openrtb.request.Imp;\n+import com.iab.openrtb.request.Video;\n+import com.iab.openrtb.response.Bid;\n+import com.iab.openrtb.response.BidResponse;\n+import com.iab.openrtb.response.SeatBid;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.prebid.server.VertxTest;\n+import org.prebid.server.bidder.model.BidderBid;\n+import org.prebid.server.bidder.model.BidderError;\n+import org.prebid.server.bidder.model.HttpCall;\n+import org.prebid.server.bidder.model.HttpRequest;\n+import org.prebid.server.bidder.model.HttpResponse;\n+import org.prebid.server.bidder.model.Result;\n+import org.prebid.server.proto.openrtb.ext.ExtPrebid;\n+import org.prebid.server.proto.openrtb.ext.request.applogy.ExtImpApplogy;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyMap;\n+import static java.util.Collections.singletonList;\n+import static java.util.function.Function.identity;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\n+import static org.assertj.core.api.Assertions.tuple;\n+import static org.prebid.server.proto.openrtb.ext.response.BidType.banner;\n+import static org.prebid.server.proto.openrtb.ext.response.BidType.video;\n+\n+public class ApplogyBidderTest extends VertxTest {\n+\n+\n+    private static final String ENDPOINT_URL = \"https://test.endpoint.com\";\n+\n+    private ApplogyBidder applogyBidder;\n+\n+    @Before\n+    public void setUp() {\n+        applogyBidder = new ApplogyBidder(ENDPOINT_URL);\n+    }\n+\n+    @Test\n+    public void creationShouldFailOnInvalidEndpointUrl() {\n+        assertThatIllegalArgumentException().isThrownBy(() -> new ApplogyBidder(\"invalid_url\"));\n+    }\n+\n+    @Test\n+    public void makeHttpRequestsShouldSkipEmptyTokens() {\n+        // given\n+        final BidRequest bidRequest = givenBidRequest(\n+                impBuilder -> impBuilder\n+                        .ext(mapper.valueToTree(ExtPrebid.of(null,\n+                                ExtImpApplogy.of(null)))));\n+\n+        // when\n+        final Result<List<HttpRequest<BidRequest>>> result = applogyBidder.makeHttpRequests(bidRequest);\n+\n+        // then\n+        assertThat(result.getErrors()).hasSize(1)\n+                .containsOnly(BidderError.badInput(\n+                        \"token is empty\"));\n+    }\n+\n+    @Test\n+    public void makeHttpRequestsShouldSkipInvalidImpressionAndAddError() {\n+        // given\n+        ExtPrebid<?, ExtImpApplogy> ext = ExtPrebid.of(null, ExtImpApplogy.of(\"token1\"));\n+        Imp imp = givenImp(\n+                impBuilder -> impBuilder\n+                        .banner(null)\n+                        .id(\"2\")\n+                        .ext(mapper.valueToTree(ext))\n+                        .banner(Banner.builder().w(300).h(400).build())\n+        );\n+        final BidRequest bidRequest = BidRequest.builder()\n+                .imp(asList(\n+                        imp,\n+                        givenImp(impBuilder -> impBuilder\n+                                .banner(null)\n+                                .id(\"2\")\n+                                .ext(mapper.valueToTree(ext))\n+                                .audio(Audio.builder().build()))))\n+                .build();\n+\n+        // when\n+        final Result<List<HttpRequest<BidRequest>>> result = applogyBidder.makeHttpRequests(bidRequest);\n+\n+        // then\n+        assertThat(result.getErrors()).hasSize(1)\n+                .containsOnly(BidderError.badInput(\n+                        \"Applogy only supports banner, video or native ads\"));\n+        assertThat(result.getValue()).hasSize(1)\n+                .extracting(httpRequest -> mapper.readValue(httpRequest.getBody(), BidRequest.class))\n+                .flatExtracting(BidRequest::getImp)\n+                .containsOnly(imp);\n+    }\n+\n+\n+    @Test\n+    public void makeBidsShouldReturnErrorWhenResponseBodyCouldNotBeParsed() {\n+        // given\n+        final HttpCall<BidRequest> httpCall = givenHttpCall(null, \"invalid\");\n+\n+        // when\n+        final Result<List<BidderBid>> result = applogyBidder.makeBids(httpCall, null);\n+\n+        // then\n+        assertThat(result.getErrors()).hasSize(1);\n+        assertThat(result.getErrors().get(0).getMessage()).startsWith(\"failed to decode json\");\n+        assertThat(result.getErrors().get(0).getType()).isEqualTo(BidderError.Type.bad_server_response);\n+        assertThat(result.getValue()).isEmpty();\n+    }\n+\n+    @Test\n+    public void makeBidsShouldReturnEmptyResultWhenResponseWithNoContent() {\n+        // given\n+        final HttpCall<BidRequest> httpCall = HttpCall\n+                .success(null, HttpResponse.of(204, null, null), null);\n+\n+        // when\n+        final Result<List<BidderBid>> result = applogyBidder.makeBids(httpCall, null);\n+\n+        // then\n+        assertThat(result.getErrors()).isEmpty();\n+        assertThat(result.getValue()).isEmpty();\n+    }\n+\n+\n+    @Test\n+    public void makeHttpRequestsShouldNotChangeBannerWidthAndHeightIfPresent() {\n+        // given\n+        final BidRequest bidRequest = givenBidRequest(\n+                impBuilder -> impBuilder\n+                        .banner(Banner.builder()\n+                                .format(singletonList(Format.builder().w(300).h(500).build()))\n+                                .w(200)\n+                                .h(150)\n+                                .build()));\n+\n+        // when\n+        final Result<List<HttpRequest<BidRequest>>> result = applogyBidder.makeHttpRequests(bidRequest);\n+\n+        // then\n+        assertThat(result.getErrors()).isEmpty();\n+        assertThat(result.getValue()).hasSize(1)\n+                .extracting(httpRequest -> mapper.readValue(httpRequest.getBody(), BidRequest.class))\n+                .flatExtracting(BidRequest::getImp)\n+                .extracting(Imp::getBanner)\n+                .extracting(Banner::getW, Banner::getH)\n+                .containsOnly(tuple(200, 150));\n+    }\n+\n+\n+    @Test\n+    public void makeHttpRequestsShouldSetBannerWidthAndHeightFromFirstFormatIfEmpty() {\n+        // given\n+        final BidRequest bidRequest = givenBidRequest(\n+                impBuilder -> impBuilder\n+                        .banner(Banner.builder()\n+                                .format(Arrays.asList(Format.builder().w(300).h(500).build(),\n+                                        Format.builder().w(450).h(150).build()))\n+                                .build()));\n+\n+        // when\n+        final Result<List<HttpRequest<BidRequest>>> result = applogyBidder.makeHttpRequests(bidRequest);\n+\n+        // then\n+        assertThat(result.getErrors()).isEmpty();\n+        assertThat(result.getValue()).hasSize(1)\n+                .extracting(httpRequest -> mapper.readValue(httpRequest.getBody(), BidRequest.class))\n+                .flatExtracting(BidRequest::getImp)\n+                .extracting(Imp::getBanner)\n+                .extracting(Banner::getW, Banner::getH)\n+                .containsOnly(tuple(300, 500));\n+    }\n+\n+\n+    @Test\n+    public void makeBidsShouldReturnErrorIfResponseBodyCouldNotBeParsed() {", "originalCommit": "92ce591c4bd02f4a261016f18b3958b411bf69cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjUyMTU4Ng==", "url": "https://github.com/prebid/prebid-server-java/pull/583#discussion_r366521586", "bodyText": "Move test case down to where makeBids are located in accordance to the method's flow.", "author": "RossGoncharuk", "createdAt": "2020-01-14T19:11:35Z", "path": "src/test/java/org/prebid/server/bidder/applogy/ApplogyBidderTest.java", "diffHunk": "@@ -0,0 +1,293 @@\n+package org.prebid.server.bidder.applogy;\n+\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.iab.openrtb.request.Audio;\n+import com.iab.openrtb.request.Banner;\n+import com.iab.openrtb.request.BidRequest;\n+import com.iab.openrtb.request.Format;\n+import com.iab.openrtb.request.Imp;\n+import com.iab.openrtb.request.Video;\n+import com.iab.openrtb.response.Bid;\n+import com.iab.openrtb.response.BidResponse;\n+import com.iab.openrtb.response.SeatBid;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.prebid.server.VertxTest;\n+import org.prebid.server.bidder.model.BidderBid;\n+import org.prebid.server.bidder.model.BidderError;\n+import org.prebid.server.bidder.model.HttpCall;\n+import org.prebid.server.bidder.model.HttpRequest;\n+import org.prebid.server.bidder.model.HttpResponse;\n+import org.prebid.server.bidder.model.Result;\n+import org.prebid.server.proto.openrtb.ext.ExtPrebid;\n+import org.prebid.server.proto.openrtb.ext.request.applogy.ExtImpApplogy;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyMap;\n+import static java.util.Collections.singletonList;\n+import static java.util.function.Function.identity;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\n+import static org.assertj.core.api.Assertions.tuple;\n+import static org.prebid.server.proto.openrtb.ext.response.BidType.banner;\n+import static org.prebid.server.proto.openrtb.ext.response.BidType.video;\n+\n+public class ApplogyBidderTest extends VertxTest {\n+\n+\n+    private static final String ENDPOINT_URL = \"https://test.endpoint.com\";\n+\n+    private ApplogyBidder applogyBidder;\n+\n+    @Before\n+    public void setUp() {\n+        applogyBidder = new ApplogyBidder(ENDPOINT_URL);\n+    }\n+\n+    @Test\n+    public void creationShouldFailOnInvalidEndpointUrl() {\n+        assertThatIllegalArgumentException().isThrownBy(() -> new ApplogyBidder(\"invalid_url\"));\n+    }\n+\n+    @Test\n+    public void makeHttpRequestsShouldSkipEmptyTokens() {\n+        // given\n+        final BidRequest bidRequest = givenBidRequest(\n+                impBuilder -> impBuilder\n+                        .ext(mapper.valueToTree(ExtPrebid.of(null,\n+                                ExtImpApplogy.of(null)))));\n+\n+        // when\n+        final Result<List<HttpRequest<BidRequest>>> result = applogyBidder.makeHttpRequests(bidRequest);\n+\n+        // then\n+        assertThat(result.getErrors()).hasSize(1)\n+                .containsOnly(BidderError.badInput(\n+                        \"token is empty\"));\n+    }\n+\n+    @Test\n+    public void makeHttpRequestsShouldSkipInvalidImpressionAndAddError() {\n+        // given\n+        ExtPrebid<?, ExtImpApplogy> ext = ExtPrebid.of(null, ExtImpApplogy.of(\"token1\"));\n+        Imp imp = givenImp(\n+                impBuilder -> impBuilder\n+                        .banner(null)\n+                        .id(\"2\")\n+                        .ext(mapper.valueToTree(ext))\n+                        .banner(Banner.builder().w(300).h(400).build())\n+        );\n+        final BidRequest bidRequest = BidRequest.builder()\n+                .imp(asList(\n+                        imp,\n+                        givenImp(impBuilder -> impBuilder\n+                                .banner(null)\n+                                .id(\"2\")\n+                                .ext(mapper.valueToTree(ext))\n+                                .audio(Audio.builder().build()))))\n+                .build();\n+\n+        // when\n+        final Result<List<HttpRequest<BidRequest>>> result = applogyBidder.makeHttpRequests(bidRequest);\n+\n+        // then\n+        assertThat(result.getErrors()).hasSize(1)\n+                .containsOnly(BidderError.badInput(\n+                        \"Applogy only supports banner, video or native ads\"));\n+        assertThat(result.getValue()).hasSize(1)\n+                .extracting(httpRequest -> mapper.readValue(httpRequest.getBody(), BidRequest.class))\n+                .flatExtracting(BidRequest::getImp)\n+                .containsOnly(imp);\n+    }\n+\n+\n+    @Test\n+    public void makeBidsShouldReturnErrorWhenResponseBodyCouldNotBeParsed() {\n+        // given\n+        final HttpCall<BidRequest> httpCall = givenHttpCall(null, \"invalid\");\n+\n+        // when\n+        final Result<List<BidderBid>> result = applogyBidder.makeBids(httpCall, null);\n+\n+        // then\n+        assertThat(result.getErrors()).hasSize(1);\n+        assertThat(result.getErrors().get(0).getMessage()).startsWith(\"failed to decode json\");\n+        assertThat(result.getErrors().get(0).getType()).isEqualTo(BidderError.Type.bad_server_response);\n+        assertThat(result.getValue()).isEmpty();\n+    }\n+\n+    @Test\n+    public void makeBidsShouldReturnEmptyResultWhenResponseWithNoContent() {", "originalCommit": "92ce591c4bd02f4a261016f18b3958b411bf69cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjUyMjYyMQ==", "url": "https://github.com/prebid/prebid-server-java/pull/583#discussion_r366522621", "bodyText": "Please add a case when banner doesn't have Width or Height and doesn't have the formats (imp.getFormat() == null) as well as when formats are empty ((imp.getFormat().size() == 0).\nWe need to check that \"banner size information missing\" exception is thrown as expected.", "author": "RossGoncharuk", "createdAt": "2020-01-14T19:13:48Z", "path": "src/test/java/org/prebid/server/bidder/applogy/ApplogyBidderTest.java", "diffHunk": "@@ -0,0 +1,293 @@\n+package org.prebid.server.bidder.applogy;\n+\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.iab.openrtb.request.Audio;\n+import com.iab.openrtb.request.Banner;\n+import com.iab.openrtb.request.BidRequest;\n+import com.iab.openrtb.request.Format;\n+import com.iab.openrtb.request.Imp;\n+import com.iab.openrtb.request.Video;\n+import com.iab.openrtb.response.Bid;\n+import com.iab.openrtb.response.BidResponse;\n+import com.iab.openrtb.response.SeatBid;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.prebid.server.VertxTest;\n+import org.prebid.server.bidder.model.BidderBid;\n+import org.prebid.server.bidder.model.BidderError;\n+import org.prebid.server.bidder.model.HttpCall;\n+import org.prebid.server.bidder.model.HttpRequest;\n+import org.prebid.server.bidder.model.HttpResponse;\n+import org.prebid.server.bidder.model.Result;\n+import org.prebid.server.proto.openrtb.ext.ExtPrebid;\n+import org.prebid.server.proto.openrtb.ext.request.applogy.ExtImpApplogy;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyMap;\n+import static java.util.Collections.singletonList;\n+import static java.util.function.Function.identity;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\n+import static org.assertj.core.api.Assertions.tuple;\n+import static org.prebid.server.proto.openrtb.ext.response.BidType.banner;\n+import static org.prebid.server.proto.openrtb.ext.response.BidType.video;\n+\n+public class ApplogyBidderTest extends VertxTest {\n+\n+\n+    private static final String ENDPOINT_URL = \"https://test.endpoint.com\";\n+\n+    private ApplogyBidder applogyBidder;\n+\n+    @Before\n+    public void setUp() {\n+        applogyBidder = new ApplogyBidder(ENDPOINT_URL);\n+    }\n+\n+    @Test\n+    public void creationShouldFailOnInvalidEndpointUrl() {\n+        assertThatIllegalArgumentException().isThrownBy(() -> new ApplogyBidder(\"invalid_url\"));\n+    }\n+\n+    @Test\n+    public void makeHttpRequestsShouldSkipEmptyTokens() {\n+        // given\n+        final BidRequest bidRequest = givenBidRequest(\n+                impBuilder -> impBuilder\n+                        .ext(mapper.valueToTree(ExtPrebid.of(null,\n+                                ExtImpApplogy.of(null)))));\n+\n+        // when\n+        final Result<List<HttpRequest<BidRequest>>> result = applogyBidder.makeHttpRequests(bidRequest);\n+\n+        // then\n+        assertThat(result.getErrors()).hasSize(1)\n+                .containsOnly(BidderError.badInput(\n+                        \"token is empty\"));\n+    }\n+\n+    @Test\n+    public void makeHttpRequestsShouldSkipInvalidImpressionAndAddError() {\n+        // given\n+        ExtPrebid<?, ExtImpApplogy> ext = ExtPrebid.of(null, ExtImpApplogy.of(\"token1\"));\n+        Imp imp = givenImp(\n+                impBuilder -> impBuilder\n+                        .banner(null)\n+                        .id(\"2\")\n+                        .ext(mapper.valueToTree(ext))\n+                        .banner(Banner.builder().w(300).h(400).build())\n+        );\n+        final BidRequest bidRequest = BidRequest.builder()\n+                .imp(asList(\n+                        imp,\n+                        givenImp(impBuilder -> impBuilder\n+                                .banner(null)\n+                                .id(\"2\")\n+                                .ext(mapper.valueToTree(ext))\n+                                .audio(Audio.builder().build()))))\n+                .build();\n+\n+        // when\n+        final Result<List<HttpRequest<BidRequest>>> result = applogyBidder.makeHttpRequests(bidRequest);\n+\n+        // then\n+        assertThat(result.getErrors()).hasSize(1)\n+                .containsOnly(BidderError.badInput(\n+                        \"Applogy only supports banner, video or native ads\"));\n+        assertThat(result.getValue()).hasSize(1)\n+                .extracting(httpRequest -> mapper.readValue(httpRequest.getBody(), BidRequest.class))\n+                .flatExtracting(BidRequest::getImp)\n+                .containsOnly(imp);\n+    }\n+", "originalCommit": "92ce591c4bd02f4a261016f18b3958b411bf69cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjUyMzYwMg==", "url": "https://github.com/prebid/prebid-server-java/pull/583#discussion_r366523602", "bodyText": "Please add a test case to ensure the httpRequest URI being formed correctly by using the token from bidRequest's impression.", "author": "RossGoncharuk", "createdAt": "2020-01-14T19:15:54Z", "path": "src/test/java/org/prebid/server/bidder/applogy/ApplogyBidderTest.java", "diffHunk": "@@ -0,0 +1,293 @@\n+package org.prebid.server.bidder.applogy;\n+\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.iab.openrtb.request.Audio;\n+import com.iab.openrtb.request.Banner;\n+import com.iab.openrtb.request.BidRequest;\n+import com.iab.openrtb.request.Format;\n+import com.iab.openrtb.request.Imp;\n+import com.iab.openrtb.request.Video;\n+import com.iab.openrtb.response.Bid;\n+import com.iab.openrtb.response.BidResponse;\n+import com.iab.openrtb.response.SeatBid;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.prebid.server.VertxTest;\n+import org.prebid.server.bidder.model.BidderBid;\n+import org.prebid.server.bidder.model.BidderError;\n+import org.prebid.server.bidder.model.HttpCall;\n+import org.prebid.server.bidder.model.HttpRequest;\n+import org.prebid.server.bidder.model.HttpResponse;\n+import org.prebid.server.bidder.model.Result;\n+import org.prebid.server.proto.openrtb.ext.ExtPrebid;\n+import org.prebid.server.proto.openrtb.ext.request.applogy.ExtImpApplogy;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyMap;\n+import static java.util.Collections.singletonList;\n+import static java.util.function.Function.identity;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\n+import static org.assertj.core.api.Assertions.tuple;\n+import static org.prebid.server.proto.openrtb.ext.response.BidType.banner;\n+import static org.prebid.server.proto.openrtb.ext.response.BidType.video;\n+\n+public class ApplogyBidderTest extends VertxTest {\n+\n+\n+    private static final String ENDPOINT_URL = \"https://test.endpoint.com\";\n+\n+    private ApplogyBidder applogyBidder;\n+\n+    @Before\n+    public void setUp() {\n+        applogyBidder = new ApplogyBidder(ENDPOINT_URL);\n+    }\n+\n+    @Test\n+    public void creationShouldFailOnInvalidEndpointUrl() {\n+        assertThatIllegalArgumentException().isThrownBy(() -> new ApplogyBidder(\"invalid_url\"));\n+    }\n+\n+    @Test\n+    public void makeHttpRequestsShouldSkipEmptyTokens() {\n+        // given\n+        final BidRequest bidRequest = givenBidRequest(\n+                impBuilder -> impBuilder\n+                        .ext(mapper.valueToTree(ExtPrebid.of(null,\n+                                ExtImpApplogy.of(null)))));\n+\n+        // when\n+        final Result<List<HttpRequest<BidRequest>>> result = applogyBidder.makeHttpRequests(bidRequest);\n+\n+        // then\n+        assertThat(result.getErrors()).hasSize(1)\n+                .containsOnly(BidderError.badInput(\n+                        \"token is empty\"));\n+    }\n+\n+    @Test\n+    public void makeHttpRequestsShouldSkipInvalidImpressionAndAddError() {\n+        // given\n+        ExtPrebid<?, ExtImpApplogy> ext = ExtPrebid.of(null, ExtImpApplogy.of(\"token1\"));\n+        Imp imp = givenImp(\n+                impBuilder -> impBuilder\n+                        .banner(null)\n+                        .id(\"2\")\n+                        .ext(mapper.valueToTree(ext))\n+                        .banner(Banner.builder().w(300).h(400).build())\n+        );\n+        final BidRequest bidRequest = BidRequest.builder()\n+                .imp(asList(\n+                        imp,\n+                        givenImp(impBuilder -> impBuilder\n+                                .banner(null)\n+                                .id(\"2\")\n+                                .ext(mapper.valueToTree(ext))\n+                                .audio(Audio.builder().build()))))\n+                .build();\n+\n+        // when\n+        final Result<List<HttpRequest<BidRequest>>> result = applogyBidder.makeHttpRequests(bidRequest);\n+\n+        // then\n+        assertThat(result.getErrors()).hasSize(1)\n+                .containsOnly(BidderError.badInput(\n+                        \"Applogy only supports banner, video or native ads\"));\n+        assertThat(result.getValue()).hasSize(1)\n+                .extracting(httpRequest -> mapper.readValue(httpRequest.getBody(), BidRequest.class))\n+                .flatExtracting(BidRequest::getImp)\n+                .containsOnly(imp);\n+    }\n+\n+\n+    @Test\n+    public void makeBidsShouldReturnErrorWhenResponseBodyCouldNotBeParsed() {\n+        // given\n+        final HttpCall<BidRequest> httpCall = givenHttpCall(null, \"invalid\");\n+\n+        // when\n+        final Result<List<BidderBid>> result = applogyBidder.makeBids(httpCall, null);\n+\n+        // then\n+        assertThat(result.getErrors()).hasSize(1);\n+        assertThat(result.getErrors().get(0).getMessage()).startsWith(\"failed to decode json\");\n+        assertThat(result.getErrors().get(0).getType()).isEqualTo(BidderError.Type.bad_server_response);\n+        assertThat(result.getValue()).isEmpty();\n+    }\n+\n+    @Test\n+    public void makeBidsShouldReturnEmptyResultWhenResponseWithNoContent() {\n+        // given\n+        final HttpCall<BidRequest> httpCall = HttpCall\n+                .success(null, HttpResponse.of(204, null, null), null);\n+\n+        // when\n+        final Result<List<BidderBid>> result = applogyBidder.makeBids(httpCall, null);\n+\n+        // then\n+        assertThat(result.getErrors()).isEmpty();\n+        assertThat(result.getValue()).isEmpty();\n+    }\n+\n+\n+    @Test\n+    public void makeHttpRequestsShouldNotChangeBannerWidthAndHeightIfPresent() {\n+        // given\n+        final BidRequest bidRequest = givenBidRequest(\n+                impBuilder -> impBuilder\n+                        .banner(Banner.builder()\n+                                .format(singletonList(Format.builder().w(300).h(500).build()))\n+                                .w(200)\n+                                .h(150)\n+                                .build()));\n+\n+        // when\n+        final Result<List<HttpRequest<BidRequest>>> result = applogyBidder.makeHttpRequests(bidRequest);\n+\n+        // then\n+        assertThat(result.getErrors()).isEmpty();\n+        assertThat(result.getValue()).hasSize(1)\n+                .extracting(httpRequest -> mapper.readValue(httpRequest.getBody(), BidRequest.class))\n+                .flatExtracting(BidRequest::getImp)\n+                .extracting(Imp::getBanner)\n+                .extracting(Banner::getW, Banner::getH)\n+                .containsOnly(tuple(200, 150));\n+    }\n+\n+\n+    @Test\n+    public void makeHttpRequestsShouldSetBannerWidthAndHeightFromFirstFormatIfEmpty() {\n+        // given\n+        final BidRequest bidRequest = givenBidRequest(\n+                impBuilder -> impBuilder\n+                        .banner(Banner.builder()\n+                                .format(Arrays.asList(Format.builder().w(300).h(500).build(),\n+                                        Format.builder().w(450).h(150).build()))\n+                                .build()));\n+\n+        // when\n+        final Result<List<HttpRequest<BidRequest>>> result = applogyBidder.makeHttpRequests(bidRequest);\n+\n+        // then\n+        assertThat(result.getErrors()).isEmpty();\n+        assertThat(result.getValue()).hasSize(1)\n+                .extracting(httpRequest -> mapper.readValue(httpRequest.getBody(), BidRequest.class))\n+                .flatExtracting(BidRequest::getImp)\n+                .extracting(Imp::getBanner)\n+                .extracting(Banner::getW, Banner::getH)\n+                .containsOnly(tuple(300, 500));\n+    }\n+", "originalCommit": "92ce591c4bd02f4a261016f18b3958b411bf69cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjUyNDMwMA==", "url": "https://github.com/prebid/prebid-server-java/pull/583#discussion_r366524300", "bodyText": "Please add other cases like makeBidsShouldReturnVideoBidIfVideoIsPresentInRequestImp for cases when we have a Banner and Native to ensure that the bid type is resolved correctly.", "author": "RossGoncharuk", "createdAt": "2020-01-14T19:17:32Z", "path": "src/test/java/org/prebid/server/bidder/applogy/ApplogyBidderTest.java", "diffHunk": "@@ -0,0 +1,293 @@\n+package org.prebid.server.bidder.applogy;\n+\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.iab.openrtb.request.Audio;\n+import com.iab.openrtb.request.Banner;\n+import com.iab.openrtb.request.BidRequest;\n+import com.iab.openrtb.request.Format;\n+import com.iab.openrtb.request.Imp;\n+import com.iab.openrtb.request.Video;\n+import com.iab.openrtb.response.Bid;\n+import com.iab.openrtb.response.BidResponse;\n+import com.iab.openrtb.response.SeatBid;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.prebid.server.VertxTest;\n+import org.prebid.server.bidder.model.BidderBid;\n+import org.prebid.server.bidder.model.BidderError;\n+import org.prebid.server.bidder.model.HttpCall;\n+import org.prebid.server.bidder.model.HttpRequest;\n+import org.prebid.server.bidder.model.HttpResponse;\n+import org.prebid.server.bidder.model.Result;\n+import org.prebid.server.proto.openrtb.ext.ExtPrebid;\n+import org.prebid.server.proto.openrtb.ext.request.applogy.ExtImpApplogy;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyMap;\n+import static java.util.Collections.singletonList;\n+import static java.util.function.Function.identity;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\n+import static org.assertj.core.api.Assertions.tuple;\n+import static org.prebid.server.proto.openrtb.ext.response.BidType.banner;\n+import static org.prebid.server.proto.openrtb.ext.response.BidType.video;\n+\n+public class ApplogyBidderTest extends VertxTest {\n+\n+\n+    private static final String ENDPOINT_URL = \"https://test.endpoint.com\";\n+\n+    private ApplogyBidder applogyBidder;\n+\n+    @Before\n+    public void setUp() {\n+        applogyBidder = new ApplogyBidder(ENDPOINT_URL);\n+    }\n+\n+    @Test\n+    public void creationShouldFailOnInvalidEndpointUrl() {\n+        assertThatIllegalArgumentException().isThrownBy(() -> new ApplogyBidder(\"invalid_url\"));\n+    }\n+\n+    @Test\n+    public void makeHttpRequestsShouldSkipEmptyTokens() {\n+        // given\n+        final BidRequest bidRequest = givenBidRequest(\n+                impBuilder -> impBuilder\n+                        .ext(mapper.valueToTree(ExtPrebid.of(null,\n+                                ExtImpApplogy.of(null)))));\n+\n+        // when\n+        final Result<List<HttpRequest<BidRequest>>> result = applogyBidder.makeHttpRequests(bidRequest);\n+\n+        // then\n+        assertThat(result.getErrors()).hasSize(1)\n+                .containsOnly(BidderError.badInput(\n+                        \"token is empty\"));\n+    }\n+\n+    @Test\n+    public void makeHttpRequestsShouldSkipInvalidImpressionAndAddError() {\n+        // given\n+        ExtPrebid<?, ExtImpApplogy> ext = ExtPrebid.of(null, ExtImpApplogy.of(\"token1\"));\n+        Imp imp = givenImp(\n+                impBuilder -> impBuilder\n+                        .banner(null)\n+                        .id(\"2\")\n+                        .ext(mapper.valueToTree(ext))\n+                        .banner(Banner.builder().w(300).h(400).build())\n+        );\n+        final BidRequest bidRequest = BidRequest.builder()\n+                .imp(asList(\n+                        imp,\n+                        givenImp(impBuilder -> impBuilder\n+                                .banner(null)\n+                                .id(\"2\")\n+                                .ext(mapper.valueToTree(ext))\n+                                .audio(Audio.builder().build()))))\n+                .build();\n+\n+        // when\n+        final Result<List<HttpRequest<BidRequest>>> result = applogyBidder.makeHttpRequests(bidRequest);\n+\n+        // then\n+        assertThat(result.getErrors()).hasSize(1)\n+                .containsOnly(BidderError.badInput(\n+                        \"Applogy only supports banner, video or native ads\"));\n+        assertThat(result.getValue()).hasSize(1)\n+                .extracting(httpRequest -> mapper.readValue(httpRequest.getBody(), BidRequest.class))\n+                .flatExtracting(BidRequest::getImp)\n+                .containsOnly(imp);\n+    }\n+\n+\n+    @Test\n+    public void makeBidsShouldReturnErrorWhenResponseBodyCouldNotBeParsed() {\n+        // given\n+        final HttpCall<BidRequest> httpCall = givenHttpCall(null, \"invalid\");\n+\n+        // when\n+        final Result<List<BidderBid>> result = applogyBidder.makeBids(httpCall, null);\n+\n+        // then\n+        assertThat(result.getErrors()).hasSize(1);\n+        assertThat(result.getErrors().get(0).getMessage()).startsWith(\"failed to decode json\");\n+        assertThat(result.getErrors().get(0).getType()).isEqualTo(BidderError.Type.bad_server_response);\n+        assertThat(result.getValue()).isEmpty();\n+    }\n+\n+    @Test\n+    public void makeBidsShouldReturnEmptyResultWhenResponseWithNoContent() {\n+        // given\n+        final HttpCall<BidRequest> httpCall = HttpCall\n+                .success(null, HttpResponse.of(204, null, null), null);\n+\n+        // when\n+        final Result<List<BidderBid>> result = applogyBidder.makeBids(httpCall, null);\n+\n+        // then\n+        assertThat(result.getErrors()).isEmpty();\n+        assertThat(result.getValue()).isEmpty();\n+    }\n+\n+\n+    @Test\n+    public void makeHttpRequestsShouldNotChangeBannerWidthAndHeightIfPresent() {\n+        // given\n+        final BidRequest bidRequest = givenBidRequest(\n+                impBuilder -> impBuilder\n+                        .banner(Banner.builder()\n+                                .format(singletonList(Format.builder().w(300).h(500).build()))\n+                                .w(200)\n+                                .h(150)\n+                                .build()));\n+\n+        // when\n+        final Result<List<HttpRequest<BidRequest>>> result = applogyBidder.makeHttpRequests(bidRequest);\n+\n+        // then\n+        assertThat(result.getErrors()).isEmpty();\n+        assertThat(result.getValue()).hasSize(1)\n+                .extracting(httpRequest -> mapper.readValue(httpRequest.getBody(), BidRequest.class))\n+                .flatExtracting(BidRequest::getImp)\n+                .extracting(Imp::getBanner)\n+                .extracting(Banner::getW, Banner::getH)\n+                .containsOnly(tuple(200, 150));\n+    }\n+\n+\n+    @Test\n+    public void makeHttpRequestsShouldSetBannerWidthAndHeightFromFirstFormatIfEmpty() {\n+        // given\n+        final BidRequest bidRequest = givenBidRequest(\n+                impBuilder -> impBuilder\n+                        .banner(Banner.builder()\n+                                .format(Arrays.asList(Format.builder().w(300).h(500).build(),\n+                                        Format.builder().w(450).h(150).build()))\n+                                .build()));\n+\n+        // when\n+        final Result<List<HttpRequest<BidRequest>>> result = applogyBidder.makeHttpRequests(bidRequest);\n+\n+        // then\n+        assertThat(result.getErrors()).isEmpty();\n+        assertThat(result.getValue()).hasSize(1)\n+                .extracting(httpRequest -> mapper.readValue(httpRequest.getBody(), BidRequest.class))\n+                .flatExtracting(BidRequest::getImp)\n+                .extracting(Imp::getBanner)\n+                .extracting(Banner::getW, Banner::getH)\n+                .containsOnly(tuple(300, 500));\n+    }\n+\n+\n+    @Test\n+    public void makeBidsShouldReturnErrorIfResponseBodyCouldNotBeParsed() {\n+        // given\n+        final HttpCall<BidRequest> httpCall = givenHttpCall(null, \"invalid\");\n+\n+        // when\n+        final Result<List<BidderBid>> result = applogyBidder.makeBids(httpCall, null);\n+\n+        // then\n+        assertThat(result.getErrors()).hasSize(1);\n+        assertThat(result.getErrors().get(0).getMessage()).startsWith(\"failed to decode json\");\n+        assertThat(result.getErrors().get(0).getType()).isEqualTo(BidderError.Type.bad_server_response);\n+        assertThat(result.getValue()).isEmpty();\n+    }\n+\n+    @Test\n+    public void makeBidsShouldReturnEmptyListIfBidResponseIsNull() throws JsonProcessingException {\n+        // given\n+        final HttpCall<BidRequest> httpCall = givenHttpCall(null,\n+                mapper.writeValueAsString(null));\n+\n+        // when\n+        final Result<List<BidderBid>> result = applogyBidder.makeBids(httpCall, null);\n+\n+        // then\n+        assertThat(result.getErrors()).isEmpty();\n+        assertThat(result.getValue()).isEmpty();\n+    }\n+\n+    @Test\n+    public void makeBidsShouldReturnEmptyListIfBidResponseSeatBidIsNull() throws JsonProcessingException {\n+        // given\n+        final HttpCall<BidRequest> httpCall = givenHttpCall(null,\n+                mapper.writeValueAsString(BidResponse.builder().build()));\n+\n+        // when\n+        final Result<List<BidderBid>> result = applogyBidder.makeBids(httpCall, null);\n+\n+        // then\n+        assertThat(result.getErrors()).isEmpty();\n+        assertThat(result.getValue()).isEmpty();\n+    }\n+\n+    @Test\n+    public void makeBidsShouldReturnVideoBidIfVideoIsPresentInRequestImp() throws JsonProcessingException {\n+        // given\n+        final HttpCall<BidRequest> httpCall = givenHttpCall(\n+                BidRequest.builder()\n+                        .imp(singletonList(Imp.builder().id(\"123\").video(Video.builder().build()).build()))\n+                        .build(),\n+                mapper.writeValueAsString(\n+                        givenBidResponse(bidBuilder -> bidBuilder.impid(\"123\"))));\n+\n+        // when\n+        final Result<List<BidderBid>> result = applogyBidder.makeBids(httpCall, null);\n+\n+        // then\n+        assertThat(result.getErrors()).isEmpty();\n+        assertThat(result.getValue())\n+                .containsOnly(BidderBid.of(Bid.builder().impid(\"123\").build(), video, \"USD\"));\n+    }\n+", "originalCommit": "92ce591c4bd02f4a261016f18b3958b411bf69cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjUyNDk4OA==", "url": "https://github.com/prebid/prebid-server-java/pull/583#discussion_r366524988", "bodyText": "Please add a test case for an error \"Failed to find impression %s\", impId when imp.id and bid.impid were not matched.", "author": "RossGoncharuk", "createdAt": "2020-01-14T19:18:52Z", "path": "src/test/java/org/prebid/server/bidder/applogy/ApplogyBidderTest.java", "diffHunk": "@@ -0,0 +1,293 @@\n+package org.prebid.server.bidder.applogy;\n+\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.iab.openrtb.request.Audio;\n+import com.iab.openrtb.request.Banner;\n+import com.iab.openrtb.request.BidRequest;\n+import com.iab.openrtb.request.Format;\n+import com.iab.openrtb.request.Imp;\n+import com.iab.openrtb.request.Video;\n+import com.iab.openrtb.response.Bid;\n+import com.iab.openrtb.response.BidResponse;\n+import com.iab.openrtb.response.SeatBid;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.prebid.server.VertxTest;\n+import org.prebid.server.bidder.model.BidderBid;\n+import org.prebid.server.bidder.model.BidderError;\n+import org.prebid.server.bidder.model.HttpCall;\n+import org.prebid.server.bidder.model.HttpRequest;\n+import org.prebid.server.bidder.model.HttpResponse;\n+import org.prebid.server.bidder.model.Result;\n+import org.prebid.server.proto.openrtb.ext.ExtPrebid;\n+import org.prebid.server.proto.openrtb.ext.request.applogy.ExtImpApplogy;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyMap;\n+import static java.util.Collections.singletonList;\n+import static java.util.function.Function.identity;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\n+import static org.assertj.core.api.Assertions.tuple;\n+import static org.prebid.server.proto.openrtb.ext.response.BidType.banner;\n+import static org.prebid.server.proto.openrtb.ext.response.BidType.video;\n+\n+public class ApplogyBidderTest extends VertxTest {\n+\n+\n+    private static final String ENDPOINT_URL = \"https://test.endpoint.com\";\n+\n+    private ApplogyBidder applogyBidder;\n+\n+    @Before\n+    public void setUp() {\n+        applogyBidder = new ApplogyBidder(ENDPOINT_URL);\n+    }\n+\n+    @Test\n+    public void creationShouldFailOnInvalidEndpointUrl() {\n+        assertThatIllegalArgumentException().isThrownBy(() -> new ApplogyBidder(\"invalid_url\"));\n+    }\n+\n+    @Test\n+    public void makeHttpRequestsShouldSkipEmptyTokens() {\n+        // given\n+        final BidRequest bidRequest = givenBidRequest(\n+                impBuilder -> impBuilder\n+                        .ext(mapper.valueToTree(ExtPrebid.of(null,\n+                                ExtImpApplogy.of(null)))));\n+\n+        // when\n+        final Result<List<HttpRequest<BidRequest>>> result = applogyBidder.makeHttpRequests(bidRequest);\n+\n+        // then\n+        assertThat(result.getErrors()).hasSize(1)\n+                .containsOnly(BidderError.badInput(\n+                        \"token is empty\"));\n+    }\n+\n+    @Test\n+    public void makeHttpRequestsShouldSkipInvalidImpressionAndAddError() {\n+        // given\n+        ExtPrebid<?, ExtImpApplogy> ext = ExtPrebid.of(null, ExtImpApplogy.of(\"token1\"));\n+        Imp imp = givenImp(\n+                impBuilder -> impBuilder\n+                        .banner(null)\n+                        .id(\"2\")\n+                        .ext(mapper.valueToTree(ext))\n+                        .banner(Banner.builder().w(300).h(400).build())\n+        );\n+        final BidRequest bidRequest = BidRequest.builder()\n+                .imp(asList(\n+                        imp,\n+                        givenImp(impBuilder -> impBuilder\n+                                .banner(null)\n+                                .id(\"2\")\n+                                .ext(mapper.valueToTree(ext))\n+                                .audio(Audio.builder().build()))))\n+                .build();\n+\n+        // when\n+        final Result<List<HttpRequest<BidRequest>>> result = applogyBidder.makeHttpRequests(bidRequest);\n+\n+        // then\n+        assertThat(result.getErrors()).hasSize(1)\n+                .containsOnly(BidderError.badInput(\n+                        \"Applogy only supports banner, video or native ads\"));\n+        assertThat(result.getValue()).hasSize(1)\n+                .extracting(httpRequest -> mapper.readValue(httpRequest.getBody(), BidRequest.class))\n+                .flatExtracting(BidRequest::getImp)\n+                .containsOnly(imp);\n+    }\n+\n+\n+    @Test\n+    public void makeBidsShouldReturnErrorWhenResponseBodyCouldNotBeParsed() {\n+        // given\n+        final HttpCall<BidRequest> httpCall = givenHttpCall(null, \"invalid\");\n+\n+        // when\n+        final Result<List<BidderBid>> result = applogyBidder.makeBids(httpCall, null);\n+\n+        // then\n+        assertThat(result.getErrors()).hasSize(1);\n+        assertThat(result.getErrors().get(0).getMessage()).startsWith(\"failed to decode json\");\n+        assertThat(result.getErrors().get(0).getType()).isEqualTo(BidderError.Type.bad_server_response);\n+        assertThat(result.getValue()).isEmpty();\n+    }\n+\n+    @Test\n+    public void makeBidsShouldReturnEmptyResultWhenResponseWithNoContent() {\n+        // given\n+        final HttpCall<BidRequest> httpCall = HttpCall\n+                .success(null, HttpResponse.of(204, null, null), null);\n+\n+        // when\n+        final Result<List<BidderBid>> result = applogyBidder.makeBids(httpCall, null);\n+\n+        // then\n+        assertThat(result.getErrors()).isEmpty();\n+        assertThat(result.getValue()).isEmpty();\n+    }\n+\n+\n+    @Test\n+    public void makeHttpRequestsShouldNotChangeBannerWidthAndHeightIfPresent() {\n+        // given\n+        final BidRequest bidRequest = givenBidRequest(\n+                impBuilder -> impBuilder\n+                        .banner(Banner.builder()\n+                                .format(singletonList(Format.builder().w(300).h(500).build()))\n+                                .w(200)\n+                                .h(150)\n+                                .build()));\n+\n+        // when\n+        final Result<List<HttpRequest<BidRequest>>> result = applogyBidder.makeHttpRequests(bidRequest);\n+\n+        // then\n+        assertThat(result.getErrors()).isEmpty();\n+        assertThat(result.getValue()).hasSize(1)\n+                .extracting(httpRequest -> mapper.readValue(httpRequest.getBody(), BidRequest.class))\n+                .flatExtracting(BidRequest::getImp)\n+                .extracting(Imp::getBanner)\n+                .extracting(Banner::getW, Banner::getH)\n+                .containsOnly(tuple(200, 150));\n+    }\n+\n+\n+    @Test\n+    public void makeHttpRequestsShouldSetBannerWidthAndHeightFromFirstFormatIfEmpty() {\n+        // given\n+        final BidRequest bidRequest = givenBidRequest(\n+                impBuilder -> impBuilder\n+                        .banner(Banner.builder()\n+                                .format(Arrays.asList(Format.builder().w(300).h(500).build(),\n+                                        Format.builder().w(450).h(150).build()))\n+                                .build()));\n+\n+        // when\n+        final Result<List<HttpRequest<BidRequest>>> result = applogyBidder.makeHttpRequests(bidRequest);\n+\n+        // then\n+        assertThat(result.getErrors()).isEmpty();\n+        assertThat(result.getValue()).hasSize(1)\n+                .extracting(httpRequest -> mapper.readValue(httpRequest.getBody(), BidRequest.class))\n+                .flatExtracting(BidRequest::getImp)\n+                .extracting(Imp::getBanner)\n+                .extracting(Banner::getW, Banner::getH)\n+                .containsOnly(tuple(300, 500));\n+    }\n+\n+\n+    @Test\n+    public void makeBidsShouldReturnErrorIfResponseBodyCouldNotBeParsed() {\n+        // given\n+        final HttpCall<BidRequest> httpCall = givenHttpCall(null, \"invalid\");\n+\n+        // when\n+        final Result<List<BidderBid>> result = applogyBidder.makeBids(httpCall, null);\n+\n+        // then\n+        assertThat(result.getErrors()).hasSize(1);\n+        assertThat(result.getErrors().get(0).getMessage()).startsWith(\"failed to decode json\");\n+        assertThat(result.getErrors().get(0).getType()).isEqualTo(BidderError.Type.bad_server_response);\n+        assertThat(result.getValue()).isEmpty();\n+    }\n+\n+    @Test\n+    public void makeBidsShouldReturnEmptyListIfBidResponseIsNull() throws JsonProcessingException {\n+        // given\n+        final HttpCall<BidRequest> httpCall = givenHttpCall(null,\n+                mapper.writeValueAsString(null));\n+\n+        // when\n+        final Result<List<BidderBid>> result = applogyBidder.makeBids(httpCall, null);\n+\n+        // then\n+        assertThat(result.getErrors()).isEmpty();\n+        assertThat(result.getValue()).isEmpty();\n+    }\n+\n+    @Test\n+    public void makeBidsShouldReturnEmptyListIfBidResponseSeatBidIsNull() throws JsonProcessingException {\n+        // given\n+        final HttpCall<BidRequest> httpCall = givenHttpCall(null,\n+                mapper.writeValueAsString(BidResponse.builder().build()));\n+\n+        // when\n+        final Result<List<BidderBid>> result = applogyBidder.makeBids(httpCall, null);\n+\n+        // then\n+        assertThat(result.getErrors()).isEmpty();\n+        assertThat(result.getValue()).isEmpty();\n+    }\n+", "originalCommit": "92ce591c4bd02f4a261016f18b3958b411bf69cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjUyNjMxNg==", "url": "https://github.com/prebid/prebid-server-java/pull/583#discussion_r366526316", "bodyText": "Please add an empty line here to separate stubs for better code clarity and remove an extra empty line below, after expected response. Thanks!", "author": "RossGoncharuk", "createdAt": "2020-01-14T19:21:31Z", "path": "src/test/java/org/prebid/server/it/ApplogyTest.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package org.prebid.server.it;\n+\n+import io.restassured.response.Response;\n+import org.json.JSONException;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.skyscreamer.jsonassert.JSONAssert;\n+import org.skyscreamer.jsonassert.JSONCompareMode;\n+import org.springframework.test.context.junit4.SpringRunner;\n+\n+import java.io.IOException;\n+\n+import static com.github.tomakehurst.wiremock.client.WireMock.aResponse;\n+import static com.github.tomakehurst.wiremock.client.WireMock.equalTo;\n+import static com.github.tomakehurst.wiremock.client.WireMock.equalToJson;\n+import static com.github.tomakehurst.wiremock.client.WireMock.post;\n+import static com.github.tomakehurst.wiremock.client.WireMock.urlPathEqualTo;\n+import static io.restassured.RestAssured.given;\n+import static java.util.Collections.singletonList;\n+\n+@RunWith(SpringRunner.class)\n+public class ApplogyTest extends IntegrationTest {\n+\n+    @Test\n+    public void openrtb2AuctionShouldRespondWithBidsFromApplogy() throws IOException, JSONException {\n+        // given\n+        // Applogy bid response for imp 001\n+        wireMockRule.stubFor(post(urlPathEqualTo(\"/applogy-exchange/1234\"))\n+                .withHeader(\"Accept\", equalTo(\"application/json\"))\n+                .withHeader(\"Content-Type\", equalTo(\"application/json;charset=UTF-8\"))\n+                .withRequestBody(equalToJson(jsonFrom(\"openrtb2/applogy/test-applogy-bid-request-1.json\")))\n+                .willReturn(aResponse().withBody(jsonFrom(\"openrtb2/applogy/test-applogy-bid-response-1.json\"))));\n+        // Applogy bid response for imp 002", "originalCommit": "92ce591c4bd02f4a261016f18b3958b411bf69cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2d605a2ec7917e07849fb08cf514f35dfe9b0971", "url": "https://github.com/prebid/prebid-server-java/commit/2d605a2ec7917e07849fb08cf514f35dfe9b0971", "message": "Rubicon Bidder\n\n-code cleanup", "committedDate": "2020-01-14T20:15:15Z", "type": "commit"}, {"oid": "eaddc417147ef8a8b55d4dea3d15479704deec04", "url": "https://github.com/prebid/prebid-server-java/commit/eaddc417147ef8a8b55d4dea3d15479704deec04", "message": "Rubicon Bidder\n\n-code cleanup\n-tests improve", "committedDate": "2020-01-15T08:12:57Z", "type": "commit"}, {"oid": "64f3753344d28b5a047e20c637a8a72d270c178b", "url": "https://github.com/prebid/prebid-server-java/commit/64f3753344d28b5a047e20c637a8a72d270c178b", "message": "Rubicon Bidder\n\n-code fix", "committedDate": "2020-01-15T08:15:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIxNTMxNA==", "url": "https://github.com/prebid/prebid-server-java/pull/583#discussion_r367215314", "bodyText": "Please check the CollectionUtils.isEmpty() method. It is a null safe check of whether the given collection is empty, meaning that you don't need to check is passed collection is not null - that check is inside, otherwise you would just call banner.getFormat().isEmpty() after null check (which what that utility method does).\nJust leave CollectionUtils.isEmpty(banner.getFormat()) for the if condition.", "author": "RossGoncharuk", "createdAt": "2020-01-16T03:27:52Z", "path": "src/main/java/org/prebid/server/bidder/applogy/ApplogyBidder.java", "diffHunk": "@@ -112,7 +90,7 @@ private Imp processImp(Imp imp) {\n         Banner banner = imp.getBanner();\n         if (banner != null) {\n             if (banner.getH() == null || banner.getW() == null || banner.getH() == 0 || banner.getW() == 0) {\n-                if (banner.getFormat() == null) {\n+                if (banner.getFormat() == null || CollectionUtils.isEmpty(banner.getFormat())) {", "originalCommit": "64f3753344d28b5a047e20c637a8a72d270c178b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "19ed0f6327221a66bbae2ff18da01db0d7550d36", "url": "https://github.com/prebid/prebid-server-java/commit/19ed0f6327221a66bbae2ff18da01db0d7550d36", "message": "Rubicon Bidder Code cleanup", "committedDate": "2020-01-16T06:59:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUwMTk5OQ==", "url": "https://github.com/prebid/prebid-server-java/pull/583#discussion_r367501999", "bodyText": "Can it be final?", "author": "rpanchyk", "createdAt": "2020-01-16T15:59:36Z", "path": "src/main/java/org/prebid/server/bidder/applogy/ApplogyBidder.java", "diffHunk": "@@ -0,0 +1,192 @@\n+package org.prebid.server.bidder.applogy;\n+\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.iab.openrtb.request.Banner;\n+import com.iab.openrtb.request.BidRequest;\n+import com.iab.openrtb.request.Format;\n+import com.iab.openrtb.request.Imp;\n+import com.iab.openrtb.response.Bid;\n+import com.iab.openrtb.response.BidResponse;\n+import com.iab.openrtb.response.SeatBid;\n+import io.netty.handler.codec.http.HttpResponseStatus;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.json.DecodeException;\n+import io.vertx.core.json.Json;\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.prebid.server.bidder.Bidder;\n+import org.prebid.server.bidder.model.BidderBid;\n+import org.prebid.server.bidder.model.BidderError;\n+import org.prebid.server.bidder.model.HttpCall;\n+import org.prebid.server.bidder.model.HttpRequest;\n+import org.prebid.server.bidder.model.Result;\n+import org.prebid.server.exception.PreBidException;\n+import org.prebid.server.proto.openrtb.ext.ExtPrebid;\n+import org.prebid.server.proto.openrtb.ext.request.applogy.ExtImpApplogy;\n+import org.prebid.server.proto.openrtb.ext.response.BidType;\n+import org.prebid.server.util.HttpUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class ApplogyBidder implements Bidder<BidRequest> {\n+\n+    private static final TypeReference<ExtPrebid<?, ExtImpApplogy>> APPLOGY_EXT_TYPE_REFERENCE =\n+            new TypeReference<ExtPrebid<?, ExtImpApplogy>>() {\n+            };\n+\n+    private static final String DEFAULT_BID_CURRENCY = \"USD\";\n+\n+    private final String endpointUrl;\n+\n+    public ApplogyBidder(String endpointUrl) {\n+        this.endpointUrl = HttpUtil.validateUrl(Objects.requireNonNull(endpointUrl));\n+    }\n+\n+    @Override\n+    public Result<List<HttpRequest<BidRequest>>> makeHttpRequests(BidRequest request) {\n+        final List<BidderError> errors = new ArrayList<>();\n+        final List<HttpRequest<BidRequest>> result = new ArrayList<>();\n+\n+        for (Imp imp : request.getImp()) {\n+            try {\n+                final ExtImpApplogy extImpApplogy = parseAndValidateImpExt(imp);\n+                final Imp processImp = processImp(imp);\n+                final String url = endpointUrl + \"/\" + extImpApplogy.getToken();\n+                result.add(createSingleRequest(processImp, request, url));\n+            } catch (PreBidException e) {\n+                errors.add(BidderError.badInput(e.getMessage()));\n+            }\n+        }\n+\n+        return Result.of(result, errors);\n+    }\n+\n+    private HttpRequest<BidRequest> createSingleRequest(Imp imp, BidRequest request, String url) {\n+        final BidRequest outgoingRequest = request.toBuilder().imp(Collections.singletonList(imp)).build();\n+\n+        final String body = Json.encode(outgoingRequest);\n+\n+        return HttpRequest.<BidRequest>builder()\n+                .method(HttpMethod.POST)\n+                .uri(url)\n+                .headers(HttpUtil.headers())\n+                .body(body)\n+                .payload(outgoingRequest)\n+                .build();\n+    }\n+\n+    private Imp processImp(Imp imp) {\n+        if (imp.getBanner() == null && imp.getVideo() == null && imp.getXNative() == null) {\n+            throw new PreBidException(\"Applogy only supports banner, video or native ads\");\n+        }\n+\n+        Banner banner = imp.getBanner();", "originalCommit": "19ed0f6327221a66bbae2ff18da01db0d7550d36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUwNjgxOQ==", "url": "https://github.com/prebid/prebid-server-java/pull/583#discussion_r367506819", "bodyText": "Please, remove empty line before class-closing curly brace.", "author": "rpanchyk", "createdAt": "2020-01-16T16:07:11Z", "path": "src/main/java/org/prebid/server/proto/openrtb/ext/request/applogy/ExtImpApplogy.java", "diffHunk": "@@ -0,0 +1,12 @@\n+package org.prebid.server.proto.openrtb.ext.request.applogy;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Value;\n+\n+@AllArgsConstructor(staticName = \"of\")\n+@Value\n+public class ExtImpApplogy {\n+\n+    String token;\n+", "originalCommit": "19ed0f6327221a66bbae2ff18da01db0d7550d36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUwNjk5NA==", "url": "https://github.com/prebid/prebid-server-java/pull/583#discussion_r367506994", "bodyText": "Please, remove empty line before class-closing curly brace.", "author": "rpanchyk", "createdAt": "2020-01-16T16:07:30Z", "path": "src/main/java/org/prebid/server/proto/openrtb/ext/request/rubicon/ExtImpRubicon.java", "diffHunk": "@@ -32,4 +32,5 @@\n     RubiconVideoParams video;\n \n     String pchain;\n+", "originalCommit": "19ed0f6327221a66bbae2ff18da01db0d7550d36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUwNzE1OA==", "url": "https://github.com/prebid/prebid-server-java/pull/583#discussion_r367507158", "bodyText": "Please, remove empty line before class-closing curly brace.", "author": "rpanchyk", "createdAt": "2020-01-16T16:07:49Z", "path": "src/main/java/org/prebid/server/proto/openrtb/ext/request/rubicon/RubiconVideoParams.java", "diffHunk": "@@ -21,4 +21,5 @@\n     Integer skip;\n \n     Integer skipdelay;\n+", "originalCommit": "19ed0f6327221a66bbae2ff18da01db0d7550d36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1019f877788b942b494a053336e9745e6089408d", "url": "https://github.com/prebid/prebid-server-java/commit/1019f877788b942b494a053336e9745e6089408d", "message": "Minor code style fix", "committedDate": "2020-01-16T18:27:56Z", "type": "commit"}]}