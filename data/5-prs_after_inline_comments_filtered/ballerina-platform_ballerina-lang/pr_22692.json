{"pr_number": 22692, "pr_title": "Fix runtime error in optional field access", "pr_createdAt": "2020-04-16T19:13:49Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/22692", "timeline": [{"oid": "129576a43770f6619619b2c1c836639b5481d9b2", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/129576a43770f6619619b2c1c836639b5481d9b2", "message": "Fix error in optional field access", "committedDate": "2020-04-17T03:41:29Z", "type": "forcePushed"}, {"oid": "4f686147f125306f9e2d77e13a9acb95ded3dc37", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4f686147f125306f9e2d77e13a9acb95ded3dc37", "message": "Fix error in optional field access", "committedDate": "2020-04-17T08:24:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg4NDcxMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22692#discussion_r411884710", "bodyText": "To minimize the Java code we can intro in the test file\nfunction testFieldAccessInUnionType() {\n    testOptionalFieldAccessInUnionType1();\n    testOptionalFieldAccessInUnionType2();\n}\nand here just do\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Test\n          \n          \n            \n                public void testOptionalFieldAccessInUnionType1() {\n          \n          \n            \n                    BRunUtil.invoke(result, \"testOptionalFieldAccessInUnionType1\");\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                @Test\n          \n          \n            \n                public void testOptionalFieldAccessInUnionType2() {\n          \n          \n            \n                    BRunUtil.invoke(result, \"testOptionalFieldAccessInUnionType2\");\n          \n          \n            \n                }\n          \n          \n            \n                @Test\n          \n          \n            \n                public void testFieldAccessInUnionType() {\n          \n          \n            \n                    BRunUtil.invoke(result, \"testFieldAccessInUnionType\");\n          \n          \n            \n                }", "author": "MaryamZi", "createdAt": "2020-04-21T05:41:57Z", "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/expressions/access/OptionalFieldAccessTest.java", "diffHunk": "@@ -132,4 +132,14 @@ public void testOptionalFieldAccessOnInvocation(String function) {\n                 { \"testJsonOptionalFieldAccessOnInvocation\" }\n         };\n     }\n+\n+    @Test\n+    public void testOptionalFieldAccessInUnionType1() {\n+        BRunUtil.invoke(result, \"testOptionalFieldAccessInUnionType1\");\n+    }\n+\n+    @Test\n+    public void testOptionalFieldAccessInUnionType2() {\n+        BRunUtil.invoke(result, \"testOptionalFieldAccessInUnionType2\");\n+    }", "originalCommit": "4f686147f125306f9e2d77e13a9acb95ded3dc37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg5NTExMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22692#discussion_r411895110", "bodyText": "Shall we rename \n  \n    \n      ballerina-lang/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java\n    \n    \n         Line 4255\n      in\n      8b26828\n    \n    \n    \n    \n\n        \n          \n           private BType addNilForNillableIndexBasedAccess(BType actualType) { \n        \n    \n  \n\n and use that instead?", "author": "MaryamZi", "createdAt": "2020-04-21T06:06:42Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -4381,16 +4381,23 @@ private BType checkOptionalRecordFieldAccessExpr(BLangFieldBasedAccess fieldAcce\n \n         LinkedHashSet<BType> fieldTypeMembers = new LinkedHashSet<>();\n \n+        boolean nonMatchedRecordExists = false;\n+\n         for (BType memType : memberTypes) {\n             BType individualFieldType = checkOptionalRecordFieldAccessExpr(fieldAccessExpr, memType, fieldName);\n \n             if (individualFieldType == symTable.semanticError) {\n+                nonMatchedRecordExists = true;\n                 continue;\n             }\n \n             fieldTypeMembers.add(individualFieldType);\n         }\n \n+        if (nonMatchedRecordExists) {\n+            fieldTypeMembers.add(symTable.nilType);", "originalCommit": "4f686147f125306f9e2d77e13a9acb95ded3dc37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY5OTY4Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22692#discussion_r413699687", "bodyText": "Done", "author": "KavinduZoysa", "createdAt": "2020-04-23T10:27:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg5NTExMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg5Njc4Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22692#discussion_r411896782", "bodyText": "Can we work with a LinkedHashSet instead? We don't need the union type right?", "author": "MaryamZi", "createdAt": "2020-04-21T06:10:35Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5856,31 +5856,92 @@ private void handleSafeNavigation(BLangAccessExpression accessExpr, BType type,\n \n         BLangMatch matchStmt = ASTBuilderUtil.createMatchStatement(accessExpr.pos, accessExpr.expr, new ArrayList<>());\n \n+        boolean allRecords = false;\n+        BUnionType errorLiftedType = BUnionType.create(null, new LinkedHashSet<>());", "originalCommit": "4f686147f125306f9e2d77e13a9acb95ded3dc37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY5OTQ3OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22692#discussion_r413699479", "bodyText": "Done", "author": "KavinduZoysa", "createdAt": "2020-04-23T10:27:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg5Njc4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkwMDIzOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22692#discussion_r411900238", "bodyText": "IMO the method name does not say much about what the method actually does, and the variable name kinda implies the check returns if all the members are records, which from the impl. doesn't seem to be the case. Can we rename?", "author": "MaryamZi", "createdAt": "2020-04-21T06:18:16Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5856,31 +5856,92 @@ private void handleSafeNavigation(BLangAccessExpression accessExpr, BType type,\n \n         BLangMatch matchStmt = ASTBuilderUtil.createMatchStatement(accessExpr.pos, accessExpr.expr, new ArrayList<>());\n \n+        boolean allRecords = false;\n+        BUnionType errorLiftedType = BUnionType.create(null, new LinkedHashSet<>());\n+        if (accessExpr.expr.type.tag == TypeTags.UNION) {\n+            LinkedHashSet<BType> memTypes = new LinkedHashSet<>(((BUnionType) accessExpr.expr.type).getMemberTypes());\n+            errorLiftedType = BUnionType.create(null, memTypes);\n+            allRecords = checkForRecords(memTypes);", "originalCommit": "4f686147f125306f9e2d77e13a9acb95ded3dc37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkwMjE2NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22692#discussion_r411902165", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        successPattern = getSuccessPattern(accessExpr, tempResultVar,\n          \n          \n            \n                                accessExpr.errorSafeNavigation);\n          \n          \n            \n                        successPattern = getSuccessPattern(accessExpr, tempResultVar, accessExpr.errorSafeNavigation);", "author": "MaryamZi", "createdAt": "2020-04-21T06:22:07Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5856,31 +5856,92 @@ private void handleSafeNavigation(BLangAccessExpression accessExpr, BType type,\n \n         BLangMatch matchStmt = ASTBuilderUtil.createMatchStatement(accessExpr.pos, accessExpr.expr, new ArrayList<>());\n \n+        boolean allRecords = false;\n+        BUnionType errorLiftedType = BUnionType.create(null, new LinkedHashSet<>());\n+        if (accessExpr.expr.type.tag == TypeTags.UNION) {\n+            LinkedHashSet<BType> memTypes = new LinkedHashSet<>(((BUnionType) accessExpr.expr.type).getMemberTypes());\n+            errorLiftedType = BUnionType.create(null, memTypes);\n+            allRecords = checkForRecords(memTypes);\n+        }\n+\n         // Add pattern to lift nil\n         if (accessExpr.nilSafeNavigation) {\n             matchStmt.patternClauses.add(getMatchNullPattern(accessExpr, tempResultVar));\n             matchStmt.type = type;\n+            errorLiftedType.remove(symTable.nilType);\n         }\n \n         // Add pattern to lift error, only if the safe navigation is used\n         if (accessExpr.errorSafeNavigation) {\n             matchStmt.patternClauses.add(getMatchErrorPattern(accessExpr, tempResultVar));\n             matchStmt.type = type;\n             matchStmt.pos = accessExpr.pos;\n+            errorLiftedType.remove(symTable.errorType);\n+        }\n+\n+        BLangMatchTypedBindingPatternClause successPattern = null;\n+        Name field = getFieldName(accessExpr);\n+        if (field == Names.EMPTY) {\n+            successPattern = getSuccessPattern(accessExpr, tempResultVar,\n+                    accessExpr.errorSafeNavigation);", "originalCommit": "4f686147f125306f9e2d77e13a9acb95ded3dc37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkwNDY4OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22692#discussion_r411904688", "bodyText": "Do we need to do this? Can we not just iterate through the fields of the BRecordType and figure out if the field exists?\nsymResolver.resolveStructField could log errors right, even thought it may not atm?", "author": "MaryamZi", "createdAt": "2020-04-21T06:27:13Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5856,31 +5856,92 @@ private void handleSafeNavigation(BLangAccessExpression accessExpr, BType type,\n \n         BLangMatch matchStmt = ASTBuilderUtil.createMatchStatement(accessExpr.pos, accessExpr.expr, new ArrayList<>());\n \n+        boolean allRecords = false;\n+        BUnionType errorLiftedType = BUnionType.create(null, new LinkedHashSet<>());\n+        if (accessExpr.expr.type.tag == TypeTags.UNION) {\n+            LinkedHashSet<BType> memTypes = new LinkedHashSet<>(((BUnionType) accessExpr.expr.type).getMemberTypes());\n+            errorLiftedType = BUnionType.create(null, memTypes);\n+            allRecords = checkForRecords(memTypes);\n+        }\n+\n         // Add pattern to lift nil\n         if (accessExpr.nilSafeNavigation) {\n             matchStmt.patternClauses.add(getMatchNullPattern(accessExpr, tempResultVar));\n             matchStmt.type = type;\n+            errorLiftedType.remove(symTable.nilType);\n         }\n \n         // Add pattern to lift error, only if the safe navigation is used\n         if (accessExpr.errorSafeNavigation) {\n             matchStmt.patternClauses.add(getMatchErrorPattern(accessExpr, tempResultVar));\n             matchStmt.type = type;\n             matchStmt.pos = accessExpr.pos;\n+            errorLiftedType.remove(symTable.errorType);\n+        }\n+\n+        BLangMatchTypedBindingPatternClause successPattern = null;\n+        Name field = getFieldName(accessExpr);\n+        if (field == Names.EMPTY) {\n+            successPattern = getSuccessPattern(accessExpr, tempResultVar,\n+                    accessExpr.errorSafeNavigation);\n+            matchStmt.patternClauses.add(successPattern);\n+            pushToMatchStatementStack(matchStmt, accessExpr, successPattern);\n+            return;\n+        }\n \n+        if (allRecords) {\n+            for (BType memberType : errorLiftedType.getMemberTypes()) {\n+                BSymbol fieldSymbol = symResolver.resolveStructField(accessExpr.pos, this.env, field,\n+                        memberType.tsymbol);", "originalCommit": "4f686147f125306f9e2d77e13a9acb95ded3dc37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkwNDc4NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22692#discussion_r411904785", "bodyText": "@pubudu91 thoughts?", "author": "MaryamZi", "createdAt": "2020-04-21T06:27:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkwNDY4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkzNTE0Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22692#discussion_r411935146", "bodyText": "This would log an error if at least one record type doesn't have the field name given by field right?", "author": "pubudu91", "createdAt": "2020-04-21T07:21:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkwNDY4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTk1MzQ5Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22692#discussion_r411953492", "bodyText": "And yeah, we don't usually use this to lookup whether the a record has a field by the specified name.", "author": "pubudu91", "createdAt": "2020-04-21T07:48:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkwNDY4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTIzOTgyMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22692#discussion_r419239823", "bodyText": "Done", "author": "KavinduZoysa", "createdAt": "2020-05-04T06:51:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkwNDY4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkwNjI2Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22692#discussion_r411906267", "bodyText": "Shall we rename this to indicate it returns () on match all?", "author": "MaryamZi", "createdAt": "2020-04-21T06:30:18Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5939,6 +6000,25 @@ private BLangMatchTypedBindingPatternClause getMatchNullPattern(BLangExpression\n         return nullPattern;\n     }\n \n+    private BLangMatchStaticBindingPatternClause getMatchAllPattern(BLangExpression expr,", "originalCommit": "4f686147f125306f9e2d77e13a9acb95ded3dc37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkwNjM4Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22692#discussion_r411906387", "bodyText": "Variable name. :)", "author": "MaryamZi", "createdAt": "2020-04-21T06:30:30Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5939,6 +6000,25 @@ private BLangMatchTypedBindingPatternClause getMatchNullPattern(BLangExpression\n         return nullPattern;\n     }\n \n+    private BLangMatchStaticBindingPatternClause getMatchAllPattern(BLangExpression expr,\n+                                                                    BLangSimpleVariable tempResultVar) {\n+\n+        BLangVariableReference tempResultVarRef = ASTBuilderUtil.createVariableRef(expr.pos, tempResultVar.symbol);\n+        BLangAssignment assignmentStmt =\n+                ASTBuilderUtil.createAssignmentStmt(expr.pos, tempResultVarRef, createLiteral(expr.pos,\n+                        symTable.nilType, Names.NIL_VALUE), false);\n+        BLangBlockStmt patternBody = ASTBuilderUtil.createBlockStmt(expr.pos, Lists.of(assignmentStmt));\n+\n+        BLangMatchStaticBindingPatternClause c =", "originalCommit": "4f686147f125306f9e2d77e13a9acb95ded3dc37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkwOTUyNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22692#discussion_r411909524", "bodyText": "This seems to be duplicating quite a bit of code from getSuccessPattern. Can we try and refactor getSuccessPattern instead to handle the record scenario?", "author": "MaryamZi", "createdAt": "2020-04-21T06:36:21Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5987,6 +6067,62 @@ private BLangMatchTypedBindingPatternClause getSuccessPattern(BLangAccessExpress\n         return successPattern;\n     }\n \n+    private BLangMatchTypedBindingPatternClause getSuccessPatternRecordMatch(BType type,", "originalCommit": "4f686147f125306f9e2d77e13a9acb95ded3dc37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY5ODY5NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22692#discussion_r413698694", "bodyText": "Done", "author": "KavinduZoysa", "createdAt": "2020-04-23T10:25:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkwOTUyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTk0NTkzMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22692#discussion_r411945930", "bodyText": "What's this condition about?", "author": "pubudu91", "createdAt": "2020-04-21T07:37:25Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5856,31 +5856,92 @@ private void handleSafeNavigation(BLangAccessExpression accessExpr, BType type,\n \n         BLangMatch matchStmt = ASTBuilderUtil.createMatchStatement(accessExpr.pos, accessExpr.expr, new ArrayList<>());\n \n+        boolean allRecords = false;\n+        BUnionType errorLiftedType = BUnionType.create(null, new LinkedHashSet<>());\n+        if (accessExpr.expr.type.tag == TypeTags.UNION) {\n+            LinkedHashSet<BType> memTypes = new LinkedHashSet<>(((BUnionType) accessExpr.expr.type).getMemberTypes());\n+            errorLiftedType = BUnionType.create(null, memTypes);\n+            allRecords = checkForRecords(memTypes);\n+        }\n+\n         // Add pattern to lift nil\n         if (accessExpr.nilSafeNavigation) {\n             matchStmt.patternClauses.add(getMatchNullPattern(accessExpr, tempResultVar));\n             matchStmt.type = type;\n+            errorLiftedType.remove(symTable.nilType);\n         }\n \n         // Add pattern to lift error, only if the safe navigation is used\n         if (accessExpr.errorSafeNavigation) {\n             matchStmt.patternClauses.add(getMatchErrorPattern(accessExpr, tempResultVar));\n             matchStmt.type = type;\n             matchStmt.pos = accessExpr.pos;\n+            errorLiftedType.remove(symTable.errorType);\n+        }\n+\n+        BLangMatchTypedBindingPatternClause successPattern = null;\n+        Name field = getFieldName(accessExpr);\n+        if (field == Names.EMPTY) {\n+            successPattern = getSuccessPattern(accessExpr, tempResultVar,\n+                    accessExpr.errorSafeNavigation);\n+            matchStmt.patternClauses.add(successPattern);\n+            pushToMatchStatementStack(matchStmt, accessExpr, successPattern);\n+            return;\n+        }\n \n+        if (allRecords) {\n+            for (BType memberType : errorLiftedType.getMemberTypes()) {\n+                BSymbol fieldSymbol = symResolver.resolveStructField(accessExpr.pos, this.env, field,\n+                        memberType.tsymbol);\n+                if (fieldSymbol != symTable.notFoundSymbol) {\n+                    successPattern = getSuccessPatternRecordMatch(memberType, accessExpr, tempResultVar);\n+                    matchStmt.patternClauses.add(successPattern);\n+                }\n+            }\n+            matchStmt.patternClauses.add(getMatchAllPattern(accessExpr, tempResultVar));\n+            pushToMatchStatementStack(matchStmt, accessExpr, successPattern);\n+            return;\n         }\n \n         // Create the pattern for success scenario. i.e: not null and not error (if applicable).\n-        BLangMatchTypedBindingPatternClause successPattern =\n+        successPattern =\n                 getSuccessPattern(accessExpr, tempResultVar, accessExpr.errorSafeNavigation);\n         matchStmt.patternClauses.add(successPattern);\n+        pushToMatchStatementStack(matchStmt, accessExpr, successPattern);\n+    }\n+\n+    private void pushToMatchStatementStack(BLangMatch matchStmt, BLangAccessExpression accessExpr,\n+                                           BLangMatchTypedBindingPatternClause successPattern) {\n         this.matchStmtStack.push(matchStmt);\n         if (this.successPattern != null) {\n             this.successPattern.body = ASTBuilderUtil.createBlockStmt(accessExpr.pos, Lists.of(matchStmt));\n         }\n         this.successPattern = successPattern;\n     }\n \n+    private Name getFieldName(BLangAccessExpression accessExpr) {\n+        Name field = Names.EMPTY;\n+        if (accessExpr.getKind() == NodeKind.FIELD_BASED_ACCESS_EXPR) {\n+            field = new Name(((BLangFieldBasedAccess) accessExpr).field.value);\n+        } else if (accessExpr.getKind() == NodeKind.INDEX_BASED_ACCESS_EXPR) {\n+            BLangExpression indexBasedExpression = ((BLangIndexBasedAccess) accessExpr).indexExpr;\n+            if (indexBasedExpression.getKind() == NodeKind.LITERAL) {\n+                field = new Name(((BLangLiteral) indexBasedExpression).value.toString());\n+            }\n+        }\n+        return field;\n+    }\n+\n+    private boolean checkForRecords(LinkedHashSet<BType> memTypes) {\n+        for (BType memType : memTypes) {\n+            int typeTag = memType.tag;\n+            if (typeTag != TypeTags.RECORD && typeTag != TypeTags.ERROR && typeTag != TypeTags.NIL) {", "originalCommit": "4f686147f125306f9e2d77e13a9acb95ded3dc37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI4ODgzNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22692#discussion_r414288836", "bodyText": "This method check whether all types are records except error type and nil type.", "author": "KavinduZoysa", "createdAt": "2020-04-24T04:45:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTk0NTkzMA=="}], "type": "inlineReview"}, {"oid": "23e7d5270cebd94edddb8f7f02020f1b5ec5c0df", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/23e7d5270cebd94edddb8f7f02020f1b5ec5c0df", "message": "Fix suggested changes", "committedDate": "2020-04-21T08:20:36Z", "type": "forcePushed"}, {"oid": "1a058edadeb763ac6f8e6541531163a73dd96bdd", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1a058edadeb763ac6f8e6541531163a73dd96bdd", "message": "Fix error in optional field access", "committedDate": "2020-04-23T17:38:40Z", "type": "commit"}, {"oid": "56e73221aee3fff7fa317c2c94c5ab9411f0f399", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/56e73221aee3fff7fa317c2c94c5ab9411f0f399", "message": "Fix suggested changes", "committedDate": "2020-04-23T17:38:40Z", "type": "commit"}, {"oid": "7ba9be60dd3460dd5abe34cacbb1cd7ffa7eae2b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7ba9be60dd3460dd5abe34cacbb1cd7ffa7eae2b", "message": "Refactor tests", "committedDate": "2020-04-23T17:38:40Z", "type": "commit"}, {"oid": "d39f3d47c5f24b4e02fd3bc37839ffb0a06cf6d1", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d39f3d47c5f24b4e02fd3bc37839ffb0a06cf6d1", "message": "Refactor desugering", "committedDate": "2020-04-23T17:38:40Z", "type": "forcePushed"}, {"oid": "c11c154a47857501b654661381ae453f1809e9d0", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c11c154a47857501b654661381ae453f1809e9d0", "message": "Refactor desugering", "committedDate": "2020-04-23T17:58:43Z", "type": "commit"}, {"oid": "c11c154a47857501b654661381ae453f1809e9d0", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c11c154a47857501b654661381ae453f1809e9d0", "message": "Refactor desugering", "committedDate": "2020-04-23T17:58:43Z", "type": "forcePushed"}, {"oid": "2583b09a386bcb84f8d17b40d2eef175bb28cbdb", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2583b09a386bcb84f8d17b40d2eef175bb28cbdb", "message": "Find the existance of record field in another function", "committedDate": "2020-04-24T09:07:53Z", "type": "commit"}, {"oid": "2583b09a386bcb84f8d17b40d2eef175bb28cbdb", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2583b09a386bcb84f8d17b40d2eef175bb28cbdb", "message": "Find the existance of record field in another function", "committedDate": "2020-04-24T09:07:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDYyODE5NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22692#discussion_r424628194", "bodyText": "IMO isAllTypesAreRecordsInUnion still doesn't reflect the actual check. Can we rename?", "author": "MaryamZi", "createdAt": "2020-05-13T17:59:43Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5869,31 +5869,99 @@ private void handleSafeNavigation(BLangAccessExpression accessExpr, BType type,\n \n         BLangMatch matchStmt = ASTBuilderUtil.createMatchStatement(accessExpr.pos, accessExpr.expr, new ArrayList<>());\n \n+        boolean isAllTypesRecords = false;\n+        LinkedHashSet<BType> memTypes = new LinkedHashSet<>();\n+        if (accessExpr.expr.type.tag == TypeTags.UNION) {\n+            memTypes = new LinkedHashSet<>(((BUnionType) accessExpr.expr.type).getMemberTypes());\n+            isAllTypesRecords = isAllTypesAreRecordsInUnion(memTypes);", "originalCommit": "2583b09a386bcb84f8d17b40d2eef175bb28cbdb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDYzODA5NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22692#discussion_r424638095", "bodyText": "Why do we need a clone?", "author": "MaryamZi", "createdAt": "2020-05-13T18:16:20Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5969,25 +6057,36 @@ private BLangMatchTypedBindingPatternClause getSuccessPattern(BLangAccessExpress\n         BLangSimpleVariable successPatternVar = ASTBuilderUtil.createVariable(accessExpr.pos, successPatternVarName,\n                 type, null, successPatternSymbol);\n \n-        // Create x.foo, by replacing the varRef expr of the current expression, with the new temp var ref\n-        accessExpr.expr = ASTBuilderUtil.createVariableRef(accessExpr.pos, successPatternVar.symbol);\n-        accessExpr.errorSafeNavigation = false;\n-        accessExpr.nilSafeNavigation = false;\n+        BLangAccessExpression tempAccessExpr = nodeCloner.clone(accessExpr);", "originalCommit": "2583b09a386bcb84f8d17b40d2eef175bb28cbdb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}