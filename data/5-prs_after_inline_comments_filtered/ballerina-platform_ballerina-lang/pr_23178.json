{"pr_number": 23178, "pr_title": "Add query expression parsing", "pr_createdAt": "2020-05-12T11:38:19Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178", "timeline": [{"oid": "41f396b9549856f6b1be1f6dd34b174b0f824c0f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/41f396b9549856f6b1be1f6dd34b174b0f824c0f", "message": "Update syntax_tree_descriptor.json", "committedDate": "2020-05-05T09:34:18Z", "type": "commit"}, {"oid": "bee6d2ca5872c5c6434a891a0bef2041fa5266de", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bee6d2ca5872c5c6434a891a0bef2041fa5266de", "message": "Generate tree", "committedDate": "2020-05-05T09:39:30Z", "type": "commit"}, {"oid": "0f06ca6267fe9b9267463b30d50603234f9014e5", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0f06ca6267fe9b9267463b30d50603234f9014e5", "message": "Add query expression support", "committedDate": "2020-05-06T03:46:09Z", "type": "commit"}, {"oid": "5855abc13a03fcdc881be5abb1e8c5a0c1e5d95b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5855abc13a03fcdc881be5abb1e8c5a0c1e5d95b", "message": "Add syntax validation test cases", "committedDate": "2020-05-06T07:39:51Z", "type": "commit"}, {"oid": "68663480ddcd2a3b5efa1b3848a749af546f4b7d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/68663480ddcd2a3b5efa1b3848a749af546f4b7d", "message": "Refactor table constructor and query expression parsing", "committedDate": "2020-05-11T16:49:09Z", "type": "commit"}, {"oid": "16f16ad58f050c8fff5f2b0d626f8a3c1df58afa", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/16f16ad58f050c8fff5f2b0d626f8a3c1df58afa", "message": "Add error recovery", "committedDate": "2020-05-11T17:16:24Z", "type": "commit"}, {"oid": "3445e41399deff2540c0be629c06cd80cfbd45be", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3445e41399deff2540c0be629c06cd80cfbd45be", "message": "Add error recovery test cases", "committedDate": "2020-05-11T17:27:20Z", "type": "commit"}, {"oid": "ca091501ebb22f7b8b166902a5c13e3afef11eb4", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ca091501ebb22f7b8b166902a5c13e3afef11eb4", "message": "Fix check styles", "committedDate": "2020-05-11T17:45:37Z", "type": "commit"}, {"oid": "50ef8e3f7d0c4d861e575ed04a1544e1d5089ef2", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/50ef8e3f7d0c4d861e575ed04a1544e1d5089ef2", "message": "Add more test cases for query expression", "committedDate": "2020-05-12T05:37:52Z", "type": "commit"}, {"oid": "60fc594e277866e21e2094fc7ac41bfd8e76122a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/60fc594e277866e21e2094fc7ac41bfd8e76122a", "message": "Merge branch 'incremental-parser' of https://github.com/ballerina-platform/ballerina-lang into query-expr-support\n\n\u0001 Conflicts:\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/LexerTerminals.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/ParserRuleContext.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/tree/STNodeFactory.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/NodeFactory.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/NodeTransformer.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/NodeVisitor.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/SyntaxKind.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/TreeModifier.java\n\u0001\tcompiler/ballerina-parser/src/test/java/io/ballerinalang/compiler/parser/test/ParserTestUtils.java\n\u0001\tcompiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "committedDate": "2020-05-12T08:57:00Z", "type": "commit"}, {"oid": "3e897455d8085236a1bb3fa30c3ff5fd408b6c0a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3e897455d8085236a1bb3fa30c3ff5fd408b6c0a", "message": "Regenerate tree after merging", "committedDate": "2020-05-12T09:02:17Z", "type": "commit"}, {"oid": "a4249e56f01cdb4b5053444425a336689e281d90", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a4249e56f01cdb4b5053444425a336689e281d90", "message": "Initiate a context at the beginning of table constructor or query expr parsing", "committedDate": "2020-05-12T11:28:38Z", "type": "commit"}, {"oid": "ef17aa5d354e4a6398004a2e09cbfe5dfd57fe72", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ef17aa5d354e4a6398004a2e09cbfe5dfd57fe72", "message": "Fix spaces", "committedDate": "2020-05-12T12:29:38Z", "type": "commit"}, {"oid": "f14dc7b3bd5a199c5440606c5d20bcd8c32cd3af", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f14dc7b3bd5a199c5440606c5d20bcd8c32cd3af", "message": "Merge branch 'incremental-parser' of https://github.com/ballerina-platform/ballerina-lang into query-expr-support\n\n\u0001 Conflicts:\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/ParserRuleContext.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/tree/STNodeFactory.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/NodeFactory.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/NodeTransformer.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/NodeVisitor.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/TreeModifier.java\n\u0001\tcompiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "committedDate": "2020-05-12T13:03:05Z", "type": "commit"}, {"oid": "07f85694db33c10a31405ba99c452119dfa33520", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/07f85694db33c10a31405ba99c452119dfa33520", "message": "Regenerate tree after merging", "committedDate": "2020-05-12T13:33:36Z", "type": "commit"}, {"oid": "e36e0403c39213b5761bcd15bea21abc38e8c087", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e36e0403c39213b5761bcd15bea21abc38e8c087", "message": "Fix indentation", "committedDate": "2020-05-12T13:56:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0NjA4NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r424146084", "bodyText": "We can extract the content inside the while loop to a method. That method simply parse and returns a clause. We have done a similar thing in the parseFollowUpArg() method.", "author": "SupunS", "createdAt": "2020-05-13T03:00:33Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8185,4 +8166,295 @@ private boolean isEndOfTypeList(SyntaxKind nextTokenKind) {\n     private STNode parseTupleRestTypeDesc() {\n         return STNodeFactory.createEmptyNode();\n     }\n+\n+    /**\n+     * Parse table constructor or query expression.\n+     * <p>\n+     * <code>\n+     * table-constructor-or-query-expr := table-constructor-expr | query-expr\n+     * <br/>\n+     * table-constructor-expr := table [key-specifier] [ [row-list] ]\n+     * <br/>\n+     * query-expr := [query-construct-type] query-pipeline select-clause\n+     * <br/>\n+     * query-construct-type := table key-specifier | stream\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+\n+    private STNode parseTableConstructorOrQuery() {\n+        startContext(ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_EXPRESSION);\n+        return parseTableConstructorOrQuery(peek().kind);\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind) {\n+        STNode queryConstructType;\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                queryConstructType = STNodeFactory.createEmptyNode();\n+                return parseQueryExprRhs(queryConstructType);\n+            case STREAM_KEYWORD:\n+                queryConstructType = parseStreamKeyword();\n+                return parseQueryExprRhs(queryConstructType);\n+            case TABLE_KEYWORD:\n+                STNode tableKeyword = parseTableKeyword();\n+                STNode keySpecifier = STNodeFactory.createEmptyNode();\n+                return parseTableConstructorOrQuery(tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_START);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind);\n+        }\n+\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(STNode tableKeyword, STNode keySpecifier) {\n+        return parseTableConstructorOrQuery(peek().kind, tableKeyword, keySpecifier);\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind, STNode tableKeyword, STNode keySpecifier) {\n+        switch (nextTokenKind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            case KEY_KEYWORD:\n+                keySpecifier = parseKeySpecifier();\n+                return parseTableConstructorOrQueryRhs(peek().kind, tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_KEYWORD_RHS, tableKeyword, keySpecifier);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind, tableKeyword, keySpecifier);\n+        }\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(STNode tableKeyword, STNode keySpecifier) {\n+        return parseTableConstructorOrQueryRhs(peek().kind, tableKeyword, keySpecifier);\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(SyntaxKind nextTokenKind, STNode tableKeyword, STNode keySpecifier) {\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                return parseQueryExprRhs(parseQueryConstructType(tableKeyword, keySpecifier));\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_RHS,\n+                    tableKeyword, keySpecifier);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQueryRhs(solution.tokenKind, tableKeyword, keySpecifier);\n+        }\n+    }\n+\n+    /**\n+     * Parse query expression.\n+     * <code>query-expr-rhs := query-pipeline select-clause</code>\n+     *\n+     * @param queryConstructType queryConstructType that precedes this rhs\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryExprRhs(STNode queryConstructType) {\n+        switchContext(ParserRuleContext.QUERY_EXPRESSION);\n+        STNode queryPipeline = parseQueryPipeline();\n+        STNode selectClause = parseSelectClause();;\n+        endContext();\n+        return STNodeFactory.createQueryExpressionNode(queryConstructType, queryPipeline, selectClause);\n+    }\n+\n+    /**\n+     * Parse query construct type.\n+     * <p>\n+     * <code>query-construct-type := table key-specifier</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryConstructType(STNode tableKeyword, STNode keySpecifier) {\n+        return STNodeFactory.createQueryConstructTypeNode(tableKeyword, keySpecifier);\n+    }\n+\n+    /**\n+     * Parse query pipeline.\n+     * <p>\n+     * <code>\n+     * query-pipeline := from-clause intermediate-clause*\n+     * <br/>\n+     * intermediate-clause := from-clause | where-clause | let-clause\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryPipeline() {\n+        STNode fromClause = parseFromClause();\n+        List<STNode> clauses = new ArrayList<>();\n+        return parseQueryPipeline(fromClause, clauses);\n+    }\n+\n+    private STNode parseQueryPipeline(STNode fromClause, List<STNode> clauses) {\n+        return parseQueryPipeline(peek().kind, fromClause, clauses);\n+    }\n+    private STNode parseQueryPipeline(SyntaxKind nextTokenKind, STNode fromClause, List<STNode> clauses) {\n+        STNode clause;\n+\n+        while (true) {\n+            switch (nextTokenKind) {\n+                case FROM_KEYWORD:\n+                    clause = parseFromClause();\n+                    clauses.add(clause);\n+                    nextTokenKind = peek().kind;\n+                    continue;\n+                case WHERE_KEYWORD:\n+                    clause = parseWhereClause();\n+                    clauses.add(clause);\n+                    nextTokenKind = peek().kind;\n+                    continue;\n+                case LET_KEYWORD:\n+                    clause = parseLetClause();\n+                    clauses.add(clause);\n+                    nextTokenKind = peek().kind;\n+                    continue;\n+                case SELECT_KEYWORD:\n+                    break;\n+                default:\n+                    if (nextTokenKind == SyntaxKind.EOF_TOKEN) {\n+                        return parseQueryPipeline(SyntaxKind.SELECT_KEYWORD, fromClause, clauses);\n+                    }\n+\n+                    Solution solution = recover(peek(), ParserRuleContext.QUERY_EXPRESSION_RHS, fromClause, clauses);\n+\n+                    // If the parser recovered by inserting a token, then try to re-parse the same\n+                    // rule with the inserted token. This is done to pick the correct branch\n+                    // to continue the parsing.\n+                    if (solution.action == Action.REMOVE) {\n+                        return solution.recoveredNode;\n+                    }\n+\n+                    return parseQueryPipeline(solution.tokenKind, fromClause, clauses);\n+            }", "originalCommit": "e36e0403c39213b5761bcd15bea21abc38e8c087", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMyOTY5NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r424329695", "bodyText": "Suppose we extract this to a new new method say parseIntermediateClause. Then what should be return if Solution solution = recover(),  recovered a SELECT_KEYWORD? We can't pass select clause inside that method as it should be passed after the parseQueryPipeline", "author": "lochana-chathura", "createdAt": "2020-05-13T10:18:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0NjA4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzMzA4OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r424333088", "bodyText": "we can actually parse is as select-clause. caller can check the kind of the clause returned by this method and stop the loop, if its a select clause.", "author": "SupunS", "createdAt": "2020-05-13T10:24:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0NjA4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzNDEzMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r424334132", "bodyText": "+1", "author": "lochana-chathura", "createdAt": "2020-05-13T10:26:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0NjA4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM2OTMyNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r424369325", "bodyText": "private STNode parseQueryExprRhs(STNode queryConstructType) {\n        switchContext(ParserRuleContext.QUERY_EXPRESSION);\n        STNode fromClause = parseFromClause();\n\n        List<STNode> clauses = new ArrayList<>();\n        STNode clause = null;\n\n        while (!isEndOfIntermediateClause(peek().kind)) {\n            clause = parseIntermediateClause();\n            if (clause.kind == SyntaxKind.SELECT_CLAUSE) {\n                break;\n            }\n            clauses.add(clause);\n        }\n\n        if (clause == null || clause.kind != SyntaxKind.SELECT_CLAUSE) {\n            clause = parseSelectClause();\n        }\n        \n        STNode intermediateClauses = STNodeFactory.createNodeList(clauses);\n        STNode queryPipeline = STNodeFactory.createQueryPipelineNode(fromClause, intermediateClauses);\n        return STNodeFactory.createQueryExpressionNode(queryConstructType, queryPipeline, clause);\n    }", "author": "lochana-chathura", "createdAt": "2020-05-13T11:37:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0NjA4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM2OTU3Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r424369576", "bodyText": "private STNode parseQueryExprRhs(STNode queryConstructType) {\n        switchContext(ParserRuleContext.QUERY_EXPRESSION);\n        STNode fromClause = parseFromClause();\n\n        STNode clause;\n        STNode intermediateClauses;\n        STNode queryPipeline;\n\n        List<STNode> clauses = new ArrayList<>();\n        while (!isEndOfIntermediateClause(peek().kind)) {\n            clause = parseIntermediateClause();\n\n            if (clause.kind == SyntaxKind.SELECT_CLAUSE) {\n                intermediateClauses = STNodeFactory.createNodeList(clauses);\n                queryPipeline = STNodeFactory.createQueryPipelineNode(fromClause, intermediateClauses);\n                return STNodeFactory.createQueryExpressionNode(queryConstructType, queryPipeline, clause);\n            }\n            \n            clauses.add(clause);\n        }\n\n        clause = parseSelectClause();\n        intermediateClauses = STNodeFactory.createNodeList(clauses);\n        queryPipeline = STNodeFactory.createQueryPipelineNode(fromClause, intermediateClauses);\n        return STNodeFactory.createQueryExpressionNode(queryConstructType, queryPipeline, clause);\n    }", "author": "lochana-chathura", "createdAt": "2020-05-13T11:37:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0NjA4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM2OTc1Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r424369757", "bodyText": "two approaches. Any suggestion or improvement?", "author": "lochana-chathura", "createdAt": "2020-05-13T11:38:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0NjA4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0NzAwOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r424147009", "bodyText": "Extra semicolon", "author": "SupunS", "createdAt": "2020-05-13T03:04:21Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8185,4 +8166,295 @@ private boolean isEndOfTypeList(SyntaxKind nextTokenKind) {\n     private STNode parseTupleRestTypeDesc() {\n         return STNodeFactory.createEmptyNode();\n     }\n+\n+    /**\n+     * Parse table constructor or query expression.\n+     * <p>\n+     * <code>\n+     * table-constructor-or-query-expr := table-constructor-expr | query-expr\n+     * <br/>\n+     * table-constructor-expr := table [key-specifier] [ [row-list] ]\n+     * <br/>\n+     * query-expr := [query-construct-type] query-pipeline select-clause\n+     * <br/>\n+     * query-construct-type := table key-specifier | stream\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+\n+    private STNode parseTableConstructorOrQuery() {\n+        startContext(ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_EXPRESSION);\n+        return parseTableConstructorOrQuery(peek().kind);\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind) {\n+        STNode queryConstructType;\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                queryConstructType = STNodeFactory.createEmptyNode();\n+                return parseQueryExprRhs(queryConstructType);\n+            case STREAM_KEYWORD:\n+                queryConstructType = parseStreamKeyword();\n+                return parseQueryExprRhs(queryConstructType);\n+            case TABLE_KEYWORD:\n+                STNode tableKeyword = parseTableKeyword();\n+                STNode keySpecifier = STNodeFactory.createEmptyNode();\n+                return parseTableConstructorOrQuery(tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_START);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind);\n+        }\n+\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(STNode tableKeyword, STNode keySpecifier) {\n+        return parseTableConstructorOrQuery(peek().kind, tableKeyword, keySpecifier);\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind, STNode tableKeyword, STNode keySpecifier) {\n+        switch (nextTokenKind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            case KEY_KEYWORD:\n+                keySpecifier = parseKeySpecifier();\n+                return parseTableConstructorOrQueryRhs(peek().kind, tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_KEYWORD_RHS, tableKeyword, keySpecifier);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind, tableKeyword, keySpecifier);\n+        }\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(STNode tableKeyword, STNode keySpecifier) {\n+        return parseTableConstructorOrQueryRhs(peek().kind, tableKeyword, keySpecifier);\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(SyntaxKind nextTokenKind, STNode tableKeyword, STNode keySpecifier) {\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                return parseQueryExprRhs(parseQueryConstructType(tableKeyword, keySpecifier));\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_RHS,\n+                    tableKeyword, keySpecifier);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQueryRhs(solution.tokenKind, tableKeyword, keySpecifier);\n+        }\n+    }\n+\n+    /**\n+     * Parse query expression.\n+     * <code>query-expr-rhs := query-pipeline select-clause</code>\n+     *\n+     * @param queryConstructType queryConstructType that precedes this rhs\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryExprRhs(STNode queryConstructType) {\n+        switchContext(ParserRuleContext.QUERY_EXPRESSION);\n+        STNode queryPipeline = parseQueryPipeline();\n+        STNode selectClause = parseSelectClause();;", "originalCommit": "e36e0403c39213b5761bcd15bea21abc38e8c087", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0Nzc3NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r424147775", "bodyText": "This is a bit dangerous, as we may get stuck in an infinite loop. Better to do a while(!isEndOfExpression())", "author": "SupunS", "createdAt": "2020-05-13T03:07:47Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8185,4 +8166,295 @@ private boolean isEndOfTypeList(SyntaxKind nextTokenKind) {\n     private STNode parseTupleRestTypeDesc() {\n         return STNodeFactory.createEmptyNode();\n     }\n+\n+    /**\n+     * Parse table constructor or query expression.\n+     * <p>\n+     * <code>\n+     * table-constructor-or-query-expr := table-constructor-expr | query-expr\n+     * <br/>\n+     * table-constructor-expr := table [key-specifier] [ [row-list] ]\n+     * <br/>\n+     * query-expr := [query-construct-type] query-pipeline select-clause\n+     * <br/>\n+     * query-construct-type := table key-specifier | stream\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+\n+    private STNode parseTableConstructorOrQuery() {\n+        startContext(ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_EXPRESSION);\n+        return parseTableConstructorOrQuery(peek().kind);\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind) {\n+        STNode queryConstructType;\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                queryConstructType = STNodeFactory.createEmptyNode();\n+                return parseQueryExprRhs(queryConstructType);\n+            case STREAM_KEYWORD:\n+                queryConstructType = parseStreamKeyword();\n+                return parseQueryExprRhs(queryConstructType);\n+            case TABLE_KEYWORD:\n+                STNode tableKeyword = parseTableKeyword();\n+                STNode keySpecifier = STNodeFactory.createEmptyNode();\n+                return parseTableConstructorOrQuery(tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_START);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind);\n+        }\n+\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(STNode tableKeyword, STNode keySpecifier) {\n+        return parseTableConstructorOrQuery(peek().kind, tableKeyword, keySpecifier);\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind, STNode tableKeyword, STNode keySpecifier) {\n+        switch (nextTokenKind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            case KEY_KEYWORD:\n+                keySpecifier = parseKeySpecifier();\n+                return parseTableConstructorOrQueryRhs(peek().kind, tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_KEYWORD_RHS, tableKeyword, keySpecifier);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind, tableKeyword, keySpecifier);\n+        }\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(STNode tableKeyword, STNode keySpecifier) {\n+        return parseTableConstructorOrQueryRhs(peek().kind, tableKeyword, keySpecifier);\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(SyntaxKind nextTokenKind, STNode tableKeyword, STNode keySpecifier) {\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                return parseQueryExprRhs(parseQueryConstructType(tableKeyword, keySpecifier));\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_RHS,\n+                    tableKeyword, keySpecifier);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQueryRhs(solution.tokenKind, tableKeyword, keySpecifier);\n+        }\n+    }\n+\n+    /**\n+     * Parse query expression.\n+     * <code>query-expr-rhs := query-pipeline select-clause</code>\n+     *\n+     * @param queryConstructType queryConstructType that precedes this rhs\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryExprRhs(STNode queryConstructType) {\n+        switchContext(ParserRuleContext.QUERY_EXPRESSION);\n+        STNode queryPipeline = parseQueryPipeline();\n+        STNode selectClause = parseSelectClause();;\n+        endContext();\n+        return STNodeFactory.createQueryExpressionNode(queryConstructType, queryPipeline, selectClause);\n+    }\n+\n+    /**\n+     * Parse query construct type.\n+     * <p>\n+     * <code>query-construct-type := table key-specifier</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryConstructType(STNode tableKeyword, STNode keySpecifier) {\n+        return STNodeFactory.createQueryConstructTypeNode(tableKeyword, keySpecifier);\n+    }\n+\n+    /**\n+     * Parse query pipeline.\n+     * <p>\n+     * <code>\n+     * query-pipeline := from-clause intermediate-clause*\n+     * <br/>\n+     * intermediate-clause := from-clause | where-clause | let-clause\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryPipeline() {\n+        STNode fromClause = parseFromClause();\n+        List<STNode> clauses = new ArrayList<>();\n+        return parseQueryPipeline(fromClause, clauses);\n+    }\n+\n+    private STNode parseQueryPipeline(STNode fromClause, List<STNode> clauses) {\n+        return parseQueryPipeline(peek().kind, fromClause, clauses);\n+    }\n+    private STNode parseQueryPipeline(SyntaxKind nextTokenKind, STNode fromClause, List<STNode> clauses) {\n+        STNode clause;\n+\n+        while (true) {", "originalCommit": "e36e0403c39213b5761bcd15bea21abc38e8c087", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0ODE0Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r424148142", "bodyText": "We can see if there are more clauses after the select clause as well, and give an error.\nCan do the same thing as in parseQueryPipeline, but simply log and error.", "author": "SupunS", "createdAt": "2020-05-13T03:09:22Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8185,4 +8166,295 @@ private boolean isEndOfTypeList(SyntaxKind nextTokenKind) {\n     private STNode parseTupleRestTypeDesc() {\n         return STNodeFactory.createEmptyNode();\n     }\n+\n+    /**\n+     * Parse table constructor or query expression.\n+     * <p>\n+     * <code>\n+     * table-constructor-or-query-expr := table-constructor-expr | query-expr\n+     * <br/>\n+     * table-constructor-expr := table [key-specifier] [ [row-list] ]\n+     * <br/>\n+     * query-expr := [query-construct-type] query-pipeline select-clause\n+     * <br/>\n+     * query-construct-type := table key-specifier | stream\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+\n+    private STNode parseTableConstructorOrQuery() {\n+        startContext(ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_EXPRESSION);\n+        return parseTableConstructorOrQuery(peek().kind);\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind) {\n+        STNode queryConstructType;\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                queryConstructType = STNodeFactory.createEmptyNode();\n+                return parseQueryExprRhs(queryConstructType);\n+            case STREAM_KEYWORD:\n+                queryConstructType = parseStreamKeyword();\n+                return parseQueryExprRhs(queryConstructType);\n+            case TABLE_KEYWORD:\n+                STNode tableKeyword = parseTableKeyword();\n+                STNode keySpecifier = STNodeFactory.createEmptyNode();\n+                return parseTableConstructorOrQuery(tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_START);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind);\n+        }\n+\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(STNode tableKeyword, STNode keySpecifier) {\n+        return parseTableConstructorOrQuery(peek().kind, tableKeyword, keySpecifier);\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind, STNode tableKeyword, STNode keySpecifier) {\n+        switch (nextTokenKind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            case KEY_KEYWORD:\n+                keySpecifier = parseKeySpecifier();\n+                return parseTableConstructorOrQueryRhs(peek().kind, tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_KEYWORD_RHS, tableKeyword, keySpecifier);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind, tableKeyword, keySpecifier);\n+        }\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(STNode tableKeyword, STNode keySpecifier) {\n+        return parseTableConstructorOrQueryRhs(peek().kind, tableKeyword, keySpecifier);\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(SyntaxKind nextTokenKind, STNode tableKeyword, STNode keySpecifier) {\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                return parseQueryExprRhs(parseQueryConstructType(tableKeyword, keySpecifier));\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_RHS,\n+                    tableKeyword, keySpecifier);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQueryRhs(solution.tokenKind, tableKeyword, keySpecifier);\n+        }\n+    }\n+\n+    /**\n+     * Parse query expression.\n+     * <code>query-expr-rhs := query-pipeline select-clause</code>\n+     *\n+     * @param queryConstructType queryConstructType that precedes this rhs\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryExprRhs(STNode queryConstructType) {\n+        switchContext(ParserRuleContext.QUERY_EXPRESSION);\n+        STNode queryPipeline = parseQueryPipeline();\n+        STNode selectClause = parseSelectClause();;\n+        endContext();", "originalCommit": "e36e0403c39213b5761bcd15bea21abc38e8c087", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM5NDg2Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r424394867", "bodyText": "So this logic also go inside parseQueryExprRhs if we are to go ahead with one of above mentioned approaches?", "author": "lochana-chathura", "createdAt": "2020-05-13T12:24:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0ODE0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0OTEzMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r424149131", "bodyText": "We don't need to create an empty key-specifier and pass it.", "author": "SupunS", "createdAt": "2020-05-13T03:13:47Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8185,4 +8166,295 @@ private boolean isEndOfTypeList(SyntaxKind nextTokenKind) {\n     private STNode parseTupleRestTypeDesc() {\n         return STNodeFactory.createEmptyNode();\n     }\n+\n+    /**\n+     * Parse table constructor or query expression.\n+     * <p>\n+     * <code>\n+     * table-constructor-or-query-expr := table-constructor-expr | query-expr\n+     * <br/>\n+     * table-constructor-expr := table [key-specifier] [ [row-list] ]\n+     * <br/>\n+     * query-expr := [query-construct-type] query-pipeline select-clause\n+     * <br/>\n+     * query-construct-type := table key-specifier | stream\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+\n+    private STNode parseTableConstructorOrQuery() {\n+        startContext(ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_EXPRESSION);\n+        return parseTableConstructorOrQuery(peek().kind);\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind) {\n+        STNode queryConstructType;\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                queryConstructType = STNodeFactory.createEmptyNode();\n+                return parseQueryExprRhs(queryConstructType);\n+            case STREAM_KEYWORD:\n+                queryConstructType = parseStreamKeyword();\n+                return parseQueryExprRhs(queryConstructType);\n+            case TABLE_KEYWORD:\n+                STNode tableKeyword = parseTableKeyword();\n+                STNode keySpecifier = STNodeFactory.createEmptyNode();", "originalCommit": "e36e0403c39213b5761bcd15bea21abc38e8c087", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE1MDk1NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r424150954", "bodyText": "We can switch the context at the point where we give QUERY_EXPRESSION / TABLE_CONSTRUCTOR as the next rule.\nNot a big issue though, just thought it would be slightly clear for a reader.", "author": "SupunS", "createdAt": "2020-05-13T03:22:00Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -1454,6 +1495,15 @@ protected ParserRuleContext getNextRule(ParserRuleContext currentCtx, int nextLo\n                 break;\n         }\n \n+        switch (currentCtx) {\n+            case TABLE_CONSTRUCTOR:\n+            case QUERY_EXPRESSION:\n+                switchContext(currentCtx);", "originalCommit": "e36e0403c39213b5761bcd15bea21abc38e8c087", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzMDU1MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r424330550", "bodyText": "private static final ParserRuleContext[] TABLE_CONSTRUCTOR_OR_QUERY_START =\n            { ParserRuleContext.TABLE_KEYWORD, ParserRuleContext.STREAM_KEYWORD, ParserRuleContext.QUERY_EXPRESSION };\n\n    private static final ParserRuleContext[] TABLE_CONSTRUCTOR_OR_QUERY_RHS =\n            { ParserRuleContext.TABLE_CONSTRUCTOR, ParserRuleContext.QUERY_EXPRESSION };\n\nActually those two ctx are not called directly as the next rule. They are called inside above arrays ?", "author": "lochana-chathura", "createdAt": "2020-05-13T10:19:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE1MDk1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzMzY2NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r424333664", "bodyText": "ack. Then its OK to keep it.", "author": "SupunS", "createdAt": "2020-05-13T10:25:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE1MDk1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE1MzM3Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r424153372", "bodyText": "Can we end the context here, rather than in the respective child methods?\nSo that we can make sure the context is ended, no matter which branch it goes within the  parseTableConstructorOrQuery", "author": "SupunS", "createdAt": "2020-05-13T03:33:10Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8185,4 +8166,295 @@ private boolean isEndOfTypeList(SyntaxKind nextTokenKind) {\n     private STNode parseTupleRestTypeDesc() {\n         return STNodeFactory.createEmptyNode();\n     }\n+\n+    /**\n+     * Parse table constructor or query expression.\n+     * <p>\n+     * <code>\n+     * table-constructor-or-query-expr := table-constructor-expr | query-expr\n+     * <br/>\n+     * table-constructor-expr := table [key-specifier] [ [row-list] ]\n+     * <br/>\n+     * query-expr := [query-construct-type] query-pipeline select-clause\n+     * <br/>\n+     * query-construct-type := table key-specifier | stream\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+\n+    private STNode parseTableConstructorOrQuery() {\n+        startContext(ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_EXPRESSION);\n+        return parseTableConstructorOrQuery(peek().kind);", "originalCommit": "e36e0403c39213b5761bcd15bea21abc38e8c087", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM3MjIwMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r424372200", "bodyText": "You mean this change right?\nprivate STNode parseTableConstructorOrQuery() {\n        startContext(ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_EXPRESSION);\n        STNode tableOrQueryExpr = parseTableConstructorOrQuery(peek().kind);\n        endContext();\n        return tableOrQueryExpr;\n    }", "author": "lochana-chathura", "createdAt": "2020-05-13T11:43:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE1MzM3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM4ODU0Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r424388547", "bodyText": "yes.", "author": "SupunS", "createdAt": "2020-05-13T12:14:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE1MzM3Mg=="}], "type": "inlineReview"}, {"oid": "1ae65c6484ad858ff810bf06e971d8a9b03e6f44", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1ae65c6484ad858ff810bf06e971d8a9b03e6f44", "message": "Introduce a base node for all the clause nodes", "committedDate": "2020-05-13T05:47:13Z", "type": "commit"}, {"oid": "0fe294c6e60e074381ccc567322e1429382953dc", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0fe294c6e60e074381ccc567322e1429382953dc", "message": "Refactor query expression parsing", "committedDate": "2020-05-13T18:21:57Z", "type": "commit"}, {"oid": "4b66d60b6412e43b11239c4c01a5a9a7134d01cc", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4b66d60b6412e43b11239c4c01a5a9a7134d01cc", "message": "Allow extra clauses to be passed and report error", "committedDate": "2020-05-14T07:02:26Z", "type": "commit"}, {"oid": "6376f2c715ebd33642e5355c4e74194f9639912e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6376f2c715ebd33642e5355c4e74194f9639912e", "message": "Add test cases for extra clauses", "committedDate": "2020-05-14T07:02:58Z", "type": "commit"}, {"oid": "3cf9ccac5b4c1768e0e0f6f04fafcc2fbc5a04ff", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3cf9ccac5b4c1768e0e0f6f04fafcc2fbc5a04ff", "message": "Fix operator precedence for table constructor, query and let expressions", "committedDate": "2020-05-14T11:35:18Z", "type": "commit"}, {"oid": "a2e9f4d50266a1a9dd7821fbd44c03a0154387dd", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a2e9f4d50266a1a9dd7821fbd44c03a0154387dd", "message": "Add operator precedence test cases", "committedDate": "2020-05-14T11:35:57Z", "type": "commit"}, {"oid": "1e4d2433368bad4fae241d5824bed0951c14f878", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1e4d2433368bad4fae241d5824bed0951c14f878", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into query-expr-support\n\n\u0001 Conflicts:\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/LexerTerminals.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/ParserRuleContext.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/tree/STNodeFactory.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/NodeFactory.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/NodeTransformer.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/NodeVisitor.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/SyntaxKind.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/TreeModifier.java\n\u0001\tcompiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "committedDate": "2020-05-14T14:03:17Z", "type": "commit"}, {"oid": "66a343be2128fa6472169af7178fc8478cd2ca6f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/66a343be2128fa6472169af7178fc8478cd2ca6f", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into query-expr-support", "committedDate": "2020-05-14T14:41:13Z", "type": "commit"}, {"oid": "f5cab218deb30646b008a3509e91d1016af69551", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f5cab218deb30646b008a3509e91d1016af69551", "message": "Regenerate tree after merging and fix merging issues", "committedDate": "2020-05-14T14:57:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIwOTA0OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r425209049", "bodyText": "This was removed from table constructor tests as this is recovered as a query expression. Similar test case has been added under query expression test cases :)", "author": "lochana-chathura", "createdAt": "2020-05-14T15:05:01Z", "path": "compiler/ballerina-parser/src/test/java/io/ballerinalang/compiler/parser/test/syntax/expressions/TableConstructorTest.java", "diffHunk": "@@ -117,9 +117,4 @@ public void testTableWithExtraToken() {\n         test(\"table foo key() [{k1:v1}]\", \"table-constructor/table_constructor_assert_24.json\");\n         test(\"table foo [{k1:v1}]\", \"table-constructor/table_constructor_assert_25.json\");\n     }\n-\n-    @Test\n-    public void testTableWithTwoKeySpecifiersWithExtraTokenInBetween() {\n-        test(\"table key(a) foo key(b) []\", \"table-constructor/table_constructor_assert_26.json\");\n-    }", "originalCommit": "f5cab218deb30646b008a3509e91d1016af69551", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI0NzkzMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r425247930", "bodyText": "As a safety measure, we can check whether the solution.tokenKind is an endOfIntermediateClause, and return null if so. That way we can avoid going to recovery infinitely. Returning null from this method can be treated as the end of intermediate clauses.\nWe can do that as an improvement though. This is more than good enough for now.", "author": "SupunS", "createdAt": "2020-05-14T15:56:54Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8423,4 +8409,338 @@ private STNode parseParenthesisedTypeDesc() {\n         STNode closeParen = parseCloseParenthesis();\n         return STNodeFactory.createParenthesisedTypeDescriptorNode(openParen, typedesc, closeParen);\n     }\n+\n+    /**\n+     * Parse table constructor or query expression.\n+     * <p>\n+     * <code>\n+     * table-constructor-or-query-expr := table-constructor-expr | query-expr\n+     * <br/>\n+     * table-constructor-expr := table [key-specifier] [ [row-list] ]\n+     * <br/>\n+     * query-expr := [query-construct-type] query-pipeline select-clause\n+     * <br/>\n+     * query-construct-type := table key-specifier | stream\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+\n+    private STNode parseTableConstructorOrQuery(boolean isRhsExpr) {\n+        startContext(ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_EXPRESSION);\n+        STNode tableOrQueryExpr = parseTableConstructorOrQuery(peek().kind, isRhsExpr);\n+        endContext();\n+        return tableOrQueryExpr;\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind, boolean isRhsExpr) {\n+        STNode queryConstructType;\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                queryConstructType = STNodeFactory.createEmptyNode();\n+                return parseQueryExprRhs(queryConstructType, isRhsExpr);\n+            case STREAM_KEYWORD:\n+                queryConstructType = parseStreamKeyword();\n+                return parseQueryExprRhs(queryConstructType, isRhsExpr);\n+            case TABLE_KEYWORD:\n+                STNode tableKeyword = parseTableKeyword();\n+                return parseTableConstructorOrQuery(tableKeyword, isRhsExpr);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_START, isRhsExpr);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind, isRhsExpr);\n+        }\n+\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(STNode tableKeyword, boolean isRhsExpr) {\n+        return parseTableConstructorOrQuery(peek().kind, tableKeyword, isRhsExpr);\n+    }\n+\n+    private STNode parseTableConstructorOrQuery(SyntaxKind nextTokenKind, STNode tableKeyword, boolean isRhsExpr) {\n+        STNode keySpecifier;\n+        switch (nextTokenKind) {\n+            case OPEN_BRACKET_TOKEN:\n+                keySpecifier = STNodeFactory.createEmptyNode();\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            case KEY_KEYWORD:\n+                keySpecifier = parseKeySpecifier();\n+                return parseTableConstructorOrQueryRhs(tableKeyword, keySpecifier, isRhsExpr);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_KEYWORD_RHS, tableKeyword, isRhsExpr);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQuery(solution.tokenKind, tableKeyword, isRhsExpr);\n+        }\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(STNode tableKeyword, STNode keySpecifier, boolean isRhsExpr) {\n+        return parseTableConstructorOrQueryRhs(peek().kind, tableKeyword, keySpecifier, isRhsExpr);\n+    }\n+\n+    private STNode parseTableConstructorOrQueryRhs(SyntaxKind nextTokenKind, STNode tableKeyword, STNode keySpecifier,\n+                                                   boolean isRhsExpr) {\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                return parseQueryExprRhs(parseQueryConstructType(tableKeyword, keySpecifier), isRhsExpr);\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTableConstructorExprRhs(tableKeyword, keySpecifier);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TABLE_CONSTRUCTOR_OR_QUERY_RHS,\n+                        tableKeyword, keySpecifier, isRhsExpr);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseTableConstructorOrQueryRhs(solution.tokenKind, tableKeyword, keySpecifier, isRhsExpr);\n+        }\n+    }\n+\n+    /**\n+     * Parse query construct type.\n+     * <p>\n+     * <code>query-construct-type := table key-specifier</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryConstructType(STNode tableKeyword, STNode keySpecifier) {\n+        return STNodeFactory.createQueryConstructTypeNode(tableKeyword, keySpecifier);\n+    }\n+\n+    /**\n+     * Parse query expression.\n+     * <p>\n+     * <code>\n+     * query-expr-rhs := query-pipeline select-clause\n+     * <br/>\n+     * query-pipeline := from-clause intermediate-clause*\n+     * </code>\n+     *\n+     * @param queryConstructType queryConstructType that precedes this rhs\n+     * @return Parsed node\n+     */\n+    private STNode parseQueryExprRhs(STNode queryConstructType, boolean isRhsExpr) {\n+        switchContext(ParserRuleContext.QUERY_EXPRESSION);\n+        STNode fromClause = parseFromClause(isRhsExpr);\n+\n+        List<STNode> clauses = new ArrayList<>();\n+        boolean hasReachedSelectClause = false;\n+\n+        STNode intermediateClause;\n+        STNode selectClause = null;\n+\n+        while (!isEndOfIntermediateClause(peek().kind)) {\n+            intermediateClause = parseIntermediateClause(isRhsExpr);\n+\n+            if (!hasReachedSelectClause) {\n+                if (intermediateClause.kind == SyntaxKind.SELECT_CLAUSE) {\n+                    selectClause = intermediateClause;\n+                    hasReachedSelectClause = true;\n+                } else {\n+                    clauses.add(intermediateClause);\n+                }\n+            } else {\n+                // If there are more clauses after select clause they are ignored\n+                // TODO: In future we should store ignored nodes\n+                this.errorHandler.reportMissingTokenError(\"extra clauses after select clause\");\n+            }\n+        }\n+\n+        if (!hasReachedSelectClause) {\n+            selectClause = parseSelectClause(isRhsExpr);\n+        }\n+\n+        STNode intermediateClauses = STNodeFactory.createNodeList(clauses);\n+        STNode queryPipeline = STNodeFactory.createQueryPipelineNode(fromClause, intermediateClauses);\n+        return STNodeFactory.createQueryExpressionNode(queryConstructType, queryPipeline, selectClause);\n+    }\n+\n+    /**\n+     * Parse an intermediate clause.\n+     * <p>\n+     * <code>\n+     * intermediate-clause := from-clause | where-clause | let-clause\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseIntermediateClause(boolean isRhsExpr) {\n+        return parseIntermediateClause(peek().kind, isRhsExpr);\n+    }\n+\n+    private STNode parseIntermediateClause(SyntaxKind nextTokenKind, boolean isRhsExpr) {\n+        switch (nextTokenKind) {\n+            case FROM_KEYWORD:\n+                return parseFromClause(isRhsExpr);\n+            case WHERE_KEYWORD:\n+                return parseWhereClause(isRhsExpr);\n+            case LET_KEYWORD:\n+                return parseLetClause(isRhsExpr);\n+            case SELECT_KEYWORD:\n+                return parseSelectClause(isRhsExpr);\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.QUERY_EXPRESSION_RHS, isRhsExpr);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseIntermediateClause(solution.tokenKind, isRhsExpr);", "originalCommit": "f5cab218deb30646b008a3509e91d1016af69551", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI4NjY3MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r425286671", "bodyText": "It seems to be a trivial change in the code. Shall I make that change?", "author": "lochana-chathura", "createdAt": "2020-05-14T16:51:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI0NzkzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI1MTA3MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r425251070", "bodyText": "Do we need to add EXPRESSION_RHS as an option here?", "author": "SupunS", "createdAt": "2020-05-14T16:00:54Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -333,6 +333,15 @@\n     private static final ParserRuleContext[] NEW_KEYWORD_RHS =\n             { ParserRuleContext.TYPE_DESC_IN_NEW_EXPR, ParserRuleContext.EXPRESSION_RHS };\n \n+    private static final ParserRuleContext[] TABLE_CONSTRUCTOR_OR_QUERY_START =\n+            { ParserRuleContext.TABLE_KEYWORD, ParserRuleContext.STREAM_KEYWORD, ParserRuleContext.QUERY_EXPRESSION };\n+\n+    private static final ParserRuleContext[] TABLE_CONSTRUCTOR_OR_QUERY_RHS =\n+            { ParserRuleContext.TABLE_CONSTRUCTOR, ParserRuleContext.QUERY_EXPRESSION };\n+\n+    private static final ParserRuleContext[] QUERY_EXPRESSION_RHS =\n+            { ParserRuleContext.SELECT_CLAUSE, ParserRuleContext.WHERE_CLAUSE, ParserRuleContext.FROM_CLAUSE,\n+                    ParserRuleContext.LET_CLAUSE };", "originalCommit": "f5cab218deb30646b008a3509e91d1016af69551", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI4NjM3OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r425286379", "bodyText": "Do we? Then it will end up in an infinite loop right? QUERY_EXPRESSION_RHS is called as a next rule inside seekMatchInExpressionRhs and then QUERY_EXPRESSION_RHS again call seekMatchInExpressionRhs and go on?", "author": "lochana-chathura", "createdAt": "2020-05-14T16:51:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI1MTA3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUxNjg1Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r425516856", "bodyText": "I see. How does it match something like a semicolon at the end of the expr?\ne.g.:  ... where a > b ;", "author": "SupunS", "createdAt": "2020-05-15T01:29:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI1MTA3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUyMzM3NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23178#discussion_r425523375", "bodyText": "May be we could add something like END_OF_QUERY, then end the query-expr context inside it, and then go ahead for EXPRESSION_RHS?\nbtw, I am merging the PR anyway, since the rest of the changes looks fine.", "author": "SupunS", "createdAt": "2020-05-15T01:55:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI1MTA3MA=="}], "type": "inlineReview"}, {"oid": "3deac76c0f6c4db00a8e26cdff8da50634417b9a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3deac76c0f6c4db00a8e26cdff8da50634417b9a", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into query-expr-support\n\n\u0001 Conflicts:\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/LexerTerminals.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/ParserRuleContext.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/tree/STNodeFactory.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/NodeFactory.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/NodeTransformer.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/NodeVisitor.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/TreeModifier.java\n\u0001\tcompiler/ballerina-parser/src/test/java/io/ballerinalang/compiler/parser/test/ParserTestUtils.java\n\u0001\tcompiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "committedDate": "2020-05-14T16:23:07Z", "type": "commit"}, {"oid": "b88d4dc9d1d22a58d6921700671dd249e3a940d8", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b88d4dc9d1d22a58d6921700671dd249e3a940d8", "message": "Regenerate tree after merging", "committedDate": "2020-05-14T16:31:41Z", "type": "commit"}]}