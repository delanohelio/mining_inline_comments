{"pr_number": 25286, "pr_title": "Fix Refactor OpenAPI validator plugin", "pr_createdAt": "2020-08-14T11:42:04Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/25286", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjYzNjAyMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25286#discussion_r472636020", "bodyText": "Shall we remove this extra line?", "author": "suganyasuven", "createdAt": "2020-08-19T03:20:57Z", "path": "misc/openapi-ballerina/modules/openapi-validator/src/main/java/org/ballerinalang/openapi/validator/BTypeToJsonValidatorUtil.java", "diffHunk": "@@ -0,0 +1,785 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package org.ballerinalang.openapi.validator;\n+\n+import io.swagger.v3.oas.models.media.ArraySchema;\n+import io.swagger.v3.oas.models.media.ComposedSchema;\n+import io.swagger.v3.oas.models.media.ObjectSchema;\n+import io.swagger.v3.oas.models.media.Schema;\n+import org.ballerinalang.openapi.validator.error.MissingFieldInBallerinaType;\n+import org.ballerinalang.openapi.validator.error.MissingFieldInJsonSchema;\n+import org.ballerinalang.openapi.validator.error.OneOfTypeValidation;\n+import org.ballerinalang.openapi.validator.error.TypeMismatch;\n+import org.ballerinalang.openapi.validator.error.ValidationError;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BVarSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BAnyType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BArrayType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BField;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BRecordType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BUnionType;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+", "originalCommit": "f5204003eefc8157e9a754bc5f278e8664d67bef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjY0NzE1OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25286#discussion_r472647159", "bodyText": "Can we rename this variable? Check other places as well.", "author": "suganyasuven", "createdAt": "2020-08-19T03:39:30Z", "path": "misc/openapi-ballerina/modules/openapi-validator/src/main/java/org/ballerinalang/openapi/validator/BTypeToJsonValidatorUtil.java", "diffHunk": "@@ -0,0 +1,785 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package org.ballerinalang.openapi.validator;\n+\n+import io.swagger.v3.oas.models.media.ArraySchema;\n+import io.swagger.v3.oas.models.media.ComposedSchema;\n+import io.swagger.v3.oas.models.media.ObjectSchema;\n+import io.swagger.v3.oas.models.media.Schema;\n+import org.ballerinalang.openapi.validator.error.MissingFieldInBallerinaType;\n+import org.ballerinalang.openapi.validator.error.MissingFieldInJsonSchema;\n+import org.ballerinalang.openapi.validator.error.OneOfTypeValidation;\n+import org.ballerinalang.openapi.validator.error.TypeMismatch;\n+import org.ballerinalang.openapi.validator.error.ValidationError;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BVarSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BAnyType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BArrayType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BField;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BRecordType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BUnionType;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+\n+/**\n+ * This util class for validate the any given schema with BVarSymbol type.\n+ */\n+public  class BTypeToJsonValidatorUtil {\n+\n+    /**\n+     * Validate given schema with bVarSymbol.\n+     * @param schema        openAPi schema object\n+     * @param bVarSymbol    bVarSymbol with given parameter\n+     * @return  List of ValidationErrors\n+     * @throws OpenApiValidatorException    openApiException\n+     */\n+    public static List<ValidationError> validate(Schema<?> schema, BVarSymbol bVarSymbol)\n+            throws OpenApiValidatorException {\n+\n+        List<ValidationError> validationErrors = new ArrayList<>();\n+        boolean isExitType = false;\n+        BType resourceType;\n+        resourceType = bVarSymbol.getType();\n+        // Validate the BVarType against to schema\n+        if (schema != null) {\n+            if ((bVarSymbol.type instanceof BRecordType) || (schema instanceof ObjectSchema)) {\n+                Map<String, Schema> properties = schema.getProperties();\n+                if (schema instanceof ObjectSchema) {\n+                    properties = ((ObjectSchema) schema).getProperties();\n+                }\n+                // Check the Item type has array type\n+                BRecordType recordType = null;\n+                if (resourceType instanceof BArrayType) {\n+                    BArrayType bArrayTypeBVarSymbol = (BArrayType) resourceType;\n+                    if (bArrayTypeBVarSymbol.eType instanceof BRecordType) {\n+                        resourceType = bArrayTypeBVarSymbol.eType;\n+                        recordType = (BRecordType) resourceType;\n+                    }\n+                } else if (resourceType instanceof BRecordType) {\n+                    recordType = (BRecordType) resourceType;\n+                }\n+                // Validate errors in records\n+                List<ValidationError> recordValidationErrors = new ArrayList<>();\n+                if (recordType != null) {\n+                    validateRecord(recordValidationErrors, properties, recordType);\n+                    validationErrors.addAll(recordValidationErrors);\n+                }\n+                isExitType = true;\n+                //  Array type validation\n+            } else if (resourceType.getKind().typeName().equals(\"[]\") && schema.getType().equals(Constants.ARRAY)) {\n+                validateArray(schema, bVarSymbol, validationErrors, resourceType);\n+                isExitType = true;\n+\n+            } else if (resourceType.getKind().typeName().equals(Constants.STRING)\n+                    && schema.getType().equals(Constants.STRING)) {\n+                isExitType = true;\n+\n+            } else if (resourceType.getKind().typeName().equals(Constants.INT)\n+                    && schema.getType().equals(Constants.INTEGER)) {\n+                isExitType = true;\n+\n+            } else if (resourceType.getKind().typeName().equals(Constants.BOOLEAN)\n+                    && schema.getType().equals(Constants.BOOLEAN)) {\n+                isExitType = true;\n+\n+            } else if (resourceType.getKind().typeName().equals(Constants.DECIMAL)\n+                    && schema.getType().equals(Constants.NUMBER)) {\n+                isExitType = true;\n+\n+            } else if (resourceType instanceof BUnionType) {\n+                // Validate OneOf type data\n+                validateOneOfType(schema, bVarSymbol, validationErrors, isExitType, (BUnionType) resourceType);\n+                isExitType = true;\n+            }\n+        }\n+        if (!isExitType) {\n+            assert schema != null;\n+            TypeMismatch typeMismatch = new TypeMismatch(bVarSymbol.name.toString(),\n+                    convertTypeToEnum(resourceType.getKind().typeName()),\n+                    convertTypeToEnum(schema.getType()));\n+            validationErrors.add(typeMismatch);\n+        }\n+        return validationErrors;\n+    }\n+\n+    /**\n+     * Validate in oneOf type parameters.\n+     * @param schema            OneOf schema\n+     * @param bVarSymbol        bVarSymbol for parameter\n+     * @param validationErrors  list of ValidationErrors\n+     * @param isExitType        tag for tracking the availability of parameter\n+     * @param resourceType      validate resource type\n+     * @throws OpenApiValidatorException\n+     */\n+    private static void validateOneOfType(Schema<?> schema, BVarSymbol bVarSymbol,\n+                                          List<ValidationError> validationErrors, boolean isExitType,\n+                                          BUnionType resourceType) throws OpenApiValidatorException {\n+\n+        // Handle OneOf type\n+        if (schema instanceof ComposedSchema) {\n+            ComposedSchema composedSchema = (ComposedSchema) schema;\n+            if ((composedSchema.getOneOf() != null) && (resourceType.getMemberTypes() != null)) {\n+                List<Schema> oneOflist01 = composedSchema.getOneOf();\n+                Set<BType> memberList01 = new HashSet<>((resourceType.getMemberTypes()));\n+                List<BType> memberList = new ArrayList<>(memberList01);\n+                List<Schema> oneOflist = new ArrayList<>(oneOflist01);\n+\n+                //  Schema against to ballerina records\n+                isExitType = validateOneOfTypeResourceToOpenApi(bVarSymbol, validationErrors, isExitType, memberList,\n+                        oneOflist);\n+                if ((!(oneOflist.isEmpty())) && (memberList.isEmpty())) {\n+                    for (Schema oneOf : oneOflist) {\n+                        if (oneOf.getProperties() != null) {\n+                            Map<String, Schema> property = oneOf.getProperties();\n+                            List<ValidationError> validationErrorsOneOfSchema = new ArrayList<>();\n+                            for (Map.Entry<String, Schema> prop: property.entrySet()) {\n+\n+                                MissingFieldInBallerinaType missingFieldInBallerinaType =\n+                                        new MissingFieldInBallerinaType(prop.getKey(),\n+                                                convertTypeToEnum(prop.getValue().getType()));\n+\n+                                validationErrorsOneOfSchema.add(missingFieldInBallerinaType);\n+                            }\n+                            OneOfTypeValidation oneOfTypeValidation = new OneOfTypeValidation(\"OpenApi Schema\",\n+                                    Constants.Type.OBJECT, validationErrorsOneOfSchema);\n+                            validationErrors.add(oneOfTypeValidation);\n+                        }\n+                    }\n+                }\n+                //  Handle Record against the schema\n+                if (!(memberList.isEmpty())) {\n+                    validateOneOfTypeOpenApiToResource(bVarSymbol, validationErrors, isExitType, memberList, oneOflist);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Validate OneOfType openApi against resource parameter.\n+     * @param bVarSymbol            parameter bVarSymbol\n+     * @param validationErrors      list of ValidationErrors\n+     * @param isExitType            tag for track the availability of parameter\n+     * @param memberList            list of resources for validating\n+     * @param oneOflist             list of operations for validating\n+     * @throws OpenApiValidatorException\n+     */\n+    private static void validateOneOfTypeOpenApiToResource(BVarSymbol bVarSymbol,\n+                                                           List<ValidationError> validationErrors, boolean isExitType,\n+                                                           List<BType> memberList, List<Schema> oneOflist)\n+            throws OpenApiValidatorException {\n+\n+        List<ValidationError> validationErrorsBa =  new ArrayList<>();\n+        for (BType member: memberList) {\n+            //  Handle record type\n+            if (member instanceof BRecordType) {\n+                isExitType = true;\n+                validateOneOftypeRecord(validationErrors, oneOflist, validationErrorsBa, member);\n+                //  Handle primitive type\n+            } else if (!(member instanceof BAnyType)) {\n+                for (Schema schema2: oneOflist) {\n+                    isExitType = member.tsymbol.type.toString().\n+                                    equals(convertOpenAPITypeToBallerina(schema2.getType()));\n+                    if (isExitType) {\n+                        break;\n+                    }\n+                }\n+                if (!isExitType) {\n+                    TypeMismatch typeMismatch = new TypeMismatch(bVarSymbol.name.toString(), null,\n+                            convertTypeToEnum(member.getKind().typeName()));\n+                    validationErrors.add(typeMismatch);\n+                }\n+            } else {\n+                isExitType = true;\n+            }\n+        }\n+        //   Missing fields in ballerina errors checking\n+        if (!(validationErrorsBa.isEmpty())) {\n+            OneOfTypeValidation oneOfTypeValidation = new OneOfTypeValidation(\"Ballerina records\",\n+                            Constants.Type.RECORD, validationErrorsBa);\n+            validationErrors.add(oneOfTypeValidation);\n+        }\n+    }\n+\n+    /**\n+     * Validate record type oneOf parameters.\n+     * @param validationErrors      list for validation errors\n+     * @param oneOflist             list with operations for validating\n+     * @param validationErrorsBa    list for service side validation errors\n+     * @param member                BType for parameter\n+     * @throws OpenApiValidatorException\n+     */\n+    private static void validateOneOftypeRecord(List<ValidationError> validationErrors, List<Schema> oneOflist,\n+                                                List<ValidationError> validationErrorsBa, BType member)\n+            throws OpenApiValidatorException {\n+\n+        if ((!(oneOflist.isEmpty())) && member instanceof BRecordType) {\n+            Iterator<Schema> oneOfSchema = oneOflist.iterator();\n+            while (oneOfSchema.hasNext()) {\n+                Schema schema2 = oneOfSchema.next();", "originalCommit": "f5204003eefc8157e9a754bc5f278e8664d67bef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjY0OTY2Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25286#discussion_r472649666", "bodyText": "License header is missing.", "author": "suganyasuven", "createdAt": "2020-08-19T03:43:33Z", "path": "misc/openapi-ballerina/modules/openapi-validator/src/main/java/org/ballerinalang/openapi/validator/Filters.java", "diffHunk": "@@ -0,0 +1,56 @@\n+package org.ballerinalang.openapi.validator;", "originalCommit": "f5204003eefc8157e9a754bc5f278e8664d67bef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjY1MDE2Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25286#discussion_r472650166", "bodyText": "Shall we change the year to '2020' in the license header?", "author": "suganyasuven", "createdAt": "2020-08-19T03:44:24Z", "path": "misc/openapi-ballerina/modules/openapi-validator/src/main/java/org/ballerinalang/openapi/validator/MatchResourcewithOperationId.java", "diffHunk": "@@ -0,0 +1,534 @@\n+/*\n+ * Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.", "originalCommit": "f5204003eefc8157e9a754bc5f278e8664d67bef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjY1Mzg5NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25286#discussion_r472653895", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    if ((filters.getOperation().contains(operationMap.getValue().getOperationId())) ||\n          \n          \n            \n                                    if (filters.getOperation().contains(operationMap.getValue().getOperationId()) ||", "author": "suganyasuven", "createdAt": "2020-08-19T03:50:14Z", "path": "misc/openapi-ballerina/modules/openapi-validator/src/main/java/org/ballerinalang/openapi/validator/MatchResourcewithOperationId.java", "diffHunk": "@@ -0,0 +1,534 @@\n+/*\n+ * Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.openapi.validator;\n+\n+import io.swagger.v3.oas.models.OpenAPI;\n+import io.swagger.v3.oas.models.Operation;\n+import io.swagger.v3.oas.models.PathItem;\n+import org.ballerinalang.model.tree.AnnotationAttachmentNode;\n+import org.ballerinalang.model.tree.FunctionNode;\n+import org.ballerinalang.model.tree.ServiceNode;\n+import org.ballerinalang.openapi.validator.error.OpenapiServiceValidationError;\n+import org.ballerinalang.openapi.validator.error.ResourceValidationError;\n+import org.ballerinalang.util.diagnostic.Diagnostic;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangExpression;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangListConstructorExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangRecordLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangSimpleVarRef;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+/**\n+ * This for finding out the all the filtered operations are documented as services in the ballerina file and all the\n+ * ballerina services are documented in the contract yaml file.\n+ */\n+public class MatchResourcewithOperationId {\n+    /**\n+     * Filter all the operations according to the given filters.\n+     * @param openApi       OpenApi Object\n+     * @param filters       Filter Object\n+     * @return              List of OpenApiPathSummary\n+     */\n+    public static List<OpenAPIPathSummary> filterOpenapi(OpenAPI openApi,\n+                                                         Filters filters) {\n+\n+        boolean tagFilteringEnabled = filters.getTag().size() > 0;\n+        boolean operationFilteringEnabled = filters.getOperation().size() > 0;\n+        boolean excludeTagsFilteringEnabled = filters.getExcludeTag().size() > 0;\n+        boolean excludeOperationFilteringEnable = filters.getExcludeOperation().size() > 0;\n+\n+        List<OpenAPIPathSummary> openAPIPathSummaries = MatchResourcewithOperationId.summarizeOpenAPI(openApi);\n+        // Check based on the method and path filters\n+        Iterator<OpenAPIPathSummary> openAPIIter = openAPIPathSummaries.iterator();\n+        while (openAPIIter.hasNext()) {\n+            OpenAPIPathSummary openAPIPathSummary = openAPIIter.next();\n+            // If operation filtering available proceed.\n+            // Else if proceed to check exclude operation filter is enable\n+            // Else check tag filtering or excludeTag filtering enable.\n+            if (operationFilteringEnabled) {\n+                // If tag filtering available validate only the filtered operations grouped by given tags.\n+                // Else if exclude tag filtering available validate only the operations that are not include\n+                // exclude Tags.\n+                // Else proceed only to validate filtered operations.\n+                if (tagFilteringEnabled) {\n+                    Iterator<Map.Entry<String, Operation>> operations =\n+                            openAPIPathSummary.getOperations().entrySet().iterator();\n+                    while (operations.hasNext()) {\n+                        Map.Entry<String, Operation> operationMap = operations.next();\n+//                        Check operationId is null scenario.\n+                        if ((filters.getOperation().contains(operationMap.getValue().getOperationId())) ||", "originalCommit": "aa43cd0d05bf24efa178f88601f65de03465d24b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjY1NDM1MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25286#discussion_r472654350", "bodyText": "Can we rename the class name? IMO, we do not use imperative forms for naming classes. Better to refer to some documentations regarding naming conventions.", "author": "parkavi11", "createdAt": "2020-08-19T03:51:06Z", "path": "misc/openapi-ballerina/modules/openapi-validator/src/main/java/org/ballerinalang/openapi/validator/MatchResourcewithOperationId.java", "diffHunk": "@@ -0,0 +1,534 @@\n+/*", "originalCommit": "f5204003eefc8157e9a754bc5f278e8664d67bef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjY2MTY0Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25286#discussion_r472661643", "bodyText": "Can we remove that extra bracket?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                if ((!openAPIPathSummary.getAvailableOperations().isEmpty())) {\n          \n          \n            \n                                if (!openAPIPathSummary.getAvailableOperations().isEmpty()) {", "author": "parkavi11", "createdAt": "2020-08-19T04:02:58Z", "path": "misc/openapi-ballerina/modules/openapi-validator/src/main/java/org/ballerinalang/openapi/validator/MatchResourcewithOperationId.java", "diffHunk": "@@ -0,0 +1,534 @@\n+/*\n+ * Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.openapi.validator;\n+\n+import io.swagger.v3.oas.models.OpenAPI;\n+import io.swagger.v3.oas.models.Operation;\n+import io.swagger.v3.oas.models.PathItem;\n+import org.ballerinalang.model.tree.AnnotationAttachmentNode;\n+import org.ballerinalang.model.tree.FunctionNode;\n+import org.ballerinalang.model.tree.ServiceNode;\n+import org.ballerinalang.openapi.validator.error.OpenapiServiceValidationError;\n+import org.ballerinalang.openapi.validator.error.ResourceValidationError;\n+import org.ballerinalang.util.diagnostic.Diagnostic;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangExpression;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangListConstructorExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangRecordLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangSimpleVarRef;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+/**\n+ * This for finding out the all the filtered operations are documented as services in the ballerina file and all the\n+ * ballerina services are documented in the contract yaml file.\n+ */\n+public class MatchResourcewithOperationId {\n+    /**\n+     * Filter all the operations according to the given filters.\n+     * @param openApi       OpenApi Object\n+     * @param filters       Filter Object\n+     * @return              List of OpenApiPathSummary\n+     */\n+    public static List<OpenAPIPathSummary> filterOpenapi(OpenAPI openApi,\n+                                                         Filters filters) {\n+\n+        boolean tagFilteringEnabled = filters.getTag().size() > 0;\n+        boolean operationFilteringEnabled = filters.getOperation().size() > 0;\n+        boolean excludeTagsFilteringEnabled = filters.getExcludeTag().size() > 0;\n+        boolean excludeOperationFilteringEnable = filters.getExcludeOperation().size() > 0;\n+\n+        List<OpenAPIPathSummary> openAPIPathSummaries = MatchResourcewithOperationId.summarizeOpenAPI(openApi);\n+        // Check based on the method and path filters\n+        Iterator<OpenAPIPathSummary> openAPIIter = openAPIPathSummaries.iterator();\n+        while (openAPIIter.hasNext()) {\n+            OpenAPIPathSummary openAPIPathSummary = openAPIIter.next();\n+            // If operation filtering available proceed.\n+            // Else if proceed to check exclude operation filter is enable\n+            // Else check tag filtering or excludeTag filtering enable.\n+            if (operationFilteringEnabled) {\n+                // If tag filtering available validate only the filtered operations grouped by given tags.\n+                // Else if exclude tag filtering available validate only the operations that are not include\n+                // exclude Tags.\n+                // Else proceed only to validate filtered operations.\n+                if (tagFilteringEnabled) {\n+                    Iterator<Map.Entry<String, Operation>> operations =\n+                            openAPIPathSummary.getOperations().entrySet().iterator();\n+                    while (operations.hasNext()) {\n+                        Map.Entry<String, Operation> operationMap = operations.next();\n+//                        Check operationId is null scenario.\n+                        if ((filters.getOperation().contains(operationMap.getValue().getOperationId())) ||\n+                                operationMap.getValue().getOperationId() == null) {\n+//                                    Check tag is available if it is null then remove other wise else-if not include\n+//                                    tag then remove operations.\n+                            if (operationMap.getValue().getTags() == null) {\n+                                operations.remove();\n+                            } else if (Collections.disjoint(filters.getTag(), operationMap.getValue().getTags())) {\n+//                                        Remove operation\n+                                operations.remove();\n+                            }\n+                        } else {\n+                            operations.remove();\n+                        }\n+                    }\n+                } else if (excludeTagsFilteringEnabled) {\n+                    Iterator<Map.Entry<String, Operation>> operationIter =\n+                            openAPIPathSummary.getOperations().entrySet().iterator();\n+                    while (operationIter.hasNext()) {\n+                        Map.Entry<String, Operation> operationMap = operationIter.next();\n+                        if (filters.getOperation().contains(operationMap.getValue().getOperationId())) {\n+//                                    Check tag is available\n+                            if (operationMap.getValue().getTags() != null) {\n+                                if (!Collections.disjoint(filters.getExcludeTag(), operationMap.getValue().getTags())) {\n+                                    operationIter.remove();\n+                                }\n+                            }\n+                        } else {\n+                            operationIter.remove();\n+                        }\n+                    }\n+                } else {\n+                    Iterator<Map.Entry<String, Operation>> operationIter =\n+                            openAPIPathSummary.getOperations().entrySet().iterator();\n+                    while (operationIter.hasNext()) {\n+                        Map.Entry<String, Operation> operationMap = operationIter.next();\n+                        if (!filters.getOperation().contains(operationMap.getValue().getOperationId())) {\n+                            operationIter.remove();\n+                        }\n+                    }\n+                }\n+            } else if (excludeOperationFilteringEnable) {\n+                // If exclude tags filtering available validate only the filtered exclude operations grouped by\n+                // given exclude tags.\n+                // Else If tags filtering available validate only the operations that filtered by exclude\n+                // operations.\n+                // Else proceed only to validate filtered exclude operations.\n+                if (excludeTagsFilteringEnabled) {\n+                    Iterator<Map.Entry<String, Operation>> operationIter =\n+                            openAPIPathSummary.getOperations().entrySet().iterator();\n+                    while (operationIter.hasNext()) {\n+                        Map.Entry<String, Operation> operationMap = operationIter.next();\n+                        if (!filters.getExcludeOperation().contains(operationMap.getValue().getOperationId())) {\n+                            if (operationMap.getValue().getTags() != null) {\n+                                if (!Collections.disjoint(filters.getExcludeTag(), operationMap.getValue().getTags())) {\n+                                    operationIter.remove();\n+                                }\n+                            } else {\n+                                operationIter.remove();\n+                            }\n+                        } else {\n+                            operationIter.remove();\n+                        }\n+                    }\n+                } else if (tagFilteringEnabled) {\n+                    Iterator<Map.Entry<String, Operation>> operations =\n+                            openAPIPathSummary.getOperations().entrySet().iterator();\n+                    while (operations.hasNext()) {\n+                        Map.Entry<String, Operation> operationMap = operations.next();\n+                        if (!filters.getExcludeOperation().contains(operationMap.getValue().getOperationId())) {\n+//                                    Check tag is available if it is null and not included in list\n+//                                    then remove operations.\n+                            if (operationMap.getValue().getTags() == null) {\n+                                operations.remove();\n+                            } else if (Collections.disjoint(filters.getTag(), operationMap.getValue().getTags())) {\n+                                operations.remove();\n+                            }\n+                        } else {\n+                            operations.remove();\n+                        }\n+                    }\n+                } else {\n+                    Iterator<Map.Entry<String, Operation>> operationIter =\n+                            openAPIPathSummary.getOperations().entrySet().iterator();\n+                    while (operationIter.hasNext()) {\n+                        Map.Entry<String, Operation> operationMap = operationIter.next();\n+                        if (filters.getExcludeOperation().contains(operationMap.getValue().getOperationId())) {\n+                            operationIter.remove();\n+                        }\n+                    }\n+                }\n+                // If exclude tag filtering available proceed to validate all the operations grouped by tags which\n+                // are not included in list.\n+                // Else if validate the operations group by tag filtering\n+                // Else proceed without any filtering.\n+            } else {\n+                if (excludeTagsFilteringEnabled) {\n+                    Iterator<Map.Entry<String, Operation>> operations =\n+                            openAPIPathSummary.getOperations().entrySet().iterator();\n+                    while (operations.hasNext()) {\n+                        Map.Entry<String, Operation> operationMap = operations.next();\n+                        if (operationMap.getValue().getTags() == null) {\n+                            break;\n+                        } else if (!Collections.disjoint(filters.getExcludeTag(), operationMap.getValue().getTags())) {\n+                            operations.remove();\n+                        }\n+                    }\n+                } else if (tagFilteringEnabled) {\n+                    // If tag filtering available proceed to validate all the operations grouped by given tags.\n+                    // Else proceed only to validate filtered operations.\n+                    Iterator<Map.Entry<String, Operation>> operations =\n+                            openAPIPathSummary.getOperations().entrySet().iterator();\n+                    while (operations.hasNext()) {\n+                        Map.Entry<String, Operation> operationMap = operations.next();\n+                        if (operationMap.getValue().getTags() == null) {\n+                            operations.remove();\n+                        } else if (Collections.disjoint(filters.getTag(), operationMap.getValue().getTags())) {\n+                            operations.remove();\n+                        }\n+                    }\n+                }\n+            }\n+            if (openAPIPathSummary.getOperations().isEmpty()) {\n+                openAPIIter.remove();\n+            }\n+        }\n+        return openAPIPathSummaries;\n+    }\n+\n+    /**\n+     * Checking the available of resource function in openApi contract.\n+     * @param openAPI           openApi contract object\n+     * @param serviceNode       resource service node\n+     * @return                  validation Error list with ResourceValidationError type\n+     */\n+    public static List<ResourceValidationError> checkOperationIsAvailable(OpenAPI openAPI, ServiceNode serviceNode) {\n+        List<ResourceValidationError> resourceValidationErrorList = new ArrayList<>();\n+        List<ResourcePathSummary> resourcePathSummaries = summarizeResources(serviceNode);\n+        List<OpenAPIPathSummary> openAPISummaries = summarizeOpenAPI(openAPI);\n+//      Check given path with its methods has documented in OpenApi contract\n+        for (ResourcePathSummary resourcePathSummary: resourcePathSummaries) {\n+            Boolean isExit = false;\n+            String resourcePath = resourcePathSummary.getPath();\n+            Map<String, ResourceMethod> resourcePathMethods = resourcePathSummary.getMethods();\n+            for (OpenAPIPathSummary openAPIPathSummary : openAPISummaries) {\n+                String servicePath = openAPIPathSummary.getPath();\n+                List<String> servicePathOperations = openAPIPathSummary.getAvailableOperations();\n+                if (resourcePath.equals(servicePath)) {\n+                    isExit = true;\n+                    if ((!servicePathOperations.isEmpty()) && (!resourcePathMethods.isEmpty())) {\n+                        for (Map.Entry<String, ResourceMethod> entry : resourcePathMethods.entrySet()) {\n+                            Boolean isMethodExit = false;\n+                            for (String operation : servicePathOperations) {\n+                                if (entry.getKey().equals(operation)) {\n+                                    isMethodExit = true;\n+                                    break;\n+                                }\n+                            }\n+                            if (!isMethodExit) {\n+                                ResourceValidationError resourceValidationError =\n+                                        new ResourceValidationError(entry.getValue().getMethodPosition(),\n+                                                entry.getKey(), resourcePath);\n+                                resourceValidationErrorList.add(resourceValidationError);\n+                            }\n+                        }\n+                    }\n+                    break;\n+                }\n+            }\n+            if (!isExit) {\n+                ResourceValidationError resourceValidationError =\n+                        new ResourceValidationError(resourcePathSummary.getPathPosition(), null, resourcePath);\n+                resourceValidationErrorList.add(resourceValidationError);\n+            }\n+        }\n+        return resourceValidationErrorList;\n+    }\n+\n+    /**\n+     * Checking the documented services are available at the resource file.\n+     * @param openAPISummaries  openApi contract object\n+     * @param serviceNode       resource file service\n+     * @return                  validation error list type with OpenAPIServiceValidationError\n+     */\n+    public static List<OpenapiServiceValidationError> checkServiceAvailable(List<OpenAPIPathSummary> openAPISummaries,\n+                                                                            ServiceNode serviceNode) {\n+        List<OpenapiServiceValidationError> validationErrors = new ArrayList<>();\n+        List<ResourcePathSummary> resourcePathSummaries = summarizeResources(serviceNode);\n+//        check the contract paths are available at the resource\n+        for (OpenAPIPathSummary openAPIPathSummary: openAPISummaries) {\n+            Boolean isServiceExit = false;\n+            for (ResourcePathSummary resourcePathSummary: resourcePathSummaries) {\n+                if (openAPIPathSummary.getPath().equals(resourcePathSummary.getPath())) {\n+                    isServiceExit = true;\n+//                    check whether documented operations are available at resource file\n+                    if ((!openAPIPathSummary.getAvailableOperations().isEmpty())) {", "originalCommit": "aa43cd0d05bf24efa178f88601f65de03465d24b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjY2MTgwMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25286#discussion_r472661803", "bodyText": "Here for all condition checks, doing the same operations (operations.remove();). Can't we simplify this code block?", "author": "suganyasuven", "createdAt": "2020-08-19T04:03:15Z", "path": "misc/openapi-ballerina/modules/openapi-validator/src/main/java/org/ballerinalang/openapi/validator/MatchResourcewithOperationId.java", "diffHunk": "@@ -0,0 +1,534 @@\n+/*\n+ * Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.openapi.validator;\n+\n+import io.swagger.v3.oas.models.OpenAPI;\n+import io.swagger.v3.oas.models.Operation;\n+import io.swagger.v3.oas.models.PathItem;\n+import org.ballerinalang.model.tree.AnnotationAttachmentNode;\n+import org.ballerinalang.model.tree.FunctionNode;\n+import org.ballerinalang.model.tree.ServiceNode;\n+import org.ballerinalang.openapi.validator.error.OpenapiServiceValidationError;\n+import org.ballerinalang.openapi.validator.error.ResourceValidationError;\n+import org.ballerinalang.util.diagnostic.Diagnostic;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangExpression;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangListConstructorExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangRecordLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangSimpleVarRef;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+/**\n+ * This for finding out the all the filtered operations are documented as services in the ballerina file and all the\n+ * ballerina services are documented in the contract yaml file.\n+ */\n+public class MatchResourcewithOperationId {\n+    /**\n+     * Filter all the operations according to the given filters.\n+     * @param openApi       OpenApi Object\n+     * @param filters       Filter Object\n+     * @return              List of OpenApiPathSummary\n+     */\n+    public static List<OpenAPIPathSummary> filterOpenapi(OpenAPI openApi,\n+                                                         Filters filters) {\n+\n+        boolean tagFilteringEnabled = filters.getTag().size() > 0;\n+        boolean operationFilteringEnabled = filters.getOperation().size() > 0;\n+        boolean excludeTagsFilteringEnabled = filters.getExcludeTag().size() > 0;\n+        boolean excludeOperationFilteringEnable = filters.getExcludeOperation().size() > 0;\n+\n+        List<OpenAPIPathSummary> openAPIPathSummaries = MatchResourcewithOperationId.summarizeOpenAPI(openApi);\n+        // Check based on the method and path filters\n+        Iterator<OpenAPIPathSummary> openAPIIter = openAPIPathSummaries.iterator();\n+        while (openAPIIter.hasNext()) {\n+            OpenAPIPathSummary openAPIPathSummary = openAPIIter.next();\n+            // If operation filtering available proceed.\n+            // Else if proceed to check exclude operation filter is enable\n+            // Else check tag filtering or excludeTag filtering enable.\n+            if (operationFilteringEnabled) {\n+                // If tag filtering available validate only the filtered operations grouped by given tags.\n+                // Else if exclude tag filtering available validate only the operations that are not include\n+                // exclude Tags.\n+                // Else proceed only to validate filtered operations.\n+                if (tagFilteringEnabled) {\n+                    Iterator<Map.Entry<String, Operation>> operations =\n+                            openAPIPathSummary.getOperations().entrySet().iterator();\n+                    while (operations.hasNext()) {\n+                        Map.Entry<String, Operation> operationMap = operations.next();\n+//                        Check operationId is null scenario.\n+                        if ((filters.getOperation().contains(operationMap.getValue().getOperationId())) ||\n+                                operationMap.getValue().getOperationId() == null) {\n+//                                    Check tag is available if it is null then remove other wise else-if not include\n+//                                    tag then remove operations.\n+                            if (operationMap.getValue().getTags() == null) {\n+                                operations.remove();\n+                            } else if (Collections.disjoint(filters.getTag(), operationMap.getValue().getTags())) {\n+//                                        Remove operation\n+                                operations.remove();\n+                            }\n+                        } else {\n+                            operations.remove();\n+                        }", "originalCommit": "aa43cd0d05bf24efa178f88601f65de03465d24b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc2MjYxNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25286#discussion_r472762616", "bodyText": "Yes, of course, we can simplify this first two if conditions, but the main block can not be replaced because it contains different another case that we need to skip by checking. :)", "author": "lnash94", "createdAt": "2020-08-19T06:37:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjY2MTgwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjY2MjE1MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25286#discussion_r472662151", "bodyText": "Can we remove this extra line? Better to check other places too", "author": "parkavi11", "createdAt": "2020-08-19T04:03:55Z", "path": "misc/openapi-ballerina/modules/openapi-validator/src/main/java/org/ballerinalang/openapi/validator/MatchResourcewithOperationId.java", "diffHunk": "@@ -0,0 +1,534 @@\n+/*\n+ * Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.openapi.validator;\n+\n+import io.swagger.v3.oas.models.OpenAPI;\n+import io.swagger.v3.oas.models.Operation;\n+import io.swagger.v3.oas.models.PathItem;\n+import org.ballerinalang.model.tree.AnnotationAttachmentNode;\n+import org.ballerinalang.model.tree.FunctionNode;\n+import org.ballerinalang.model.tree.ServiceNode;\n+import org.ballerinalang.openapi.validator.error.OpenapiServiceValidationError;\n+import org.ballerinalang.openapi.validator.error.ResourceValidationError;\n+import org.ballerinalang.util.diagnostic.Diagnostic;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangExpression;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangListConstructorExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangRecordLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangSimpleVarRef;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+/**\n+ * This for finding out the all the filtered operations are documented as services in the ballerina file and all the\n+ * ballerina services are documented in the contract yaml file.\n+ */\n+public class MatchResourcewithOperationId {\n+    /**\n+     * Filter all the operations according to the given filters.\n+     * @param openApi       OpenApi Object\n+     * @param filters       Filter Object\n+     * @return              List of OpenApiPathSummary\n+     */\n+    public static List<OpenAPIPathSummary> filterOpenapi(OpenAPI openApi,\n+                                                         Filters filters) {\n+\n+        boolean tagFilteringEnabled = filters.getTag().size() > 0;\n+        boolean operationFilteringEnabled = filters.getOperation().size() > 0;\n+        boolean excludeTagsFilteringEnabled = filters.getExcludeTag().size() > 0;\n+        boolean excludeOperationFilteringEnable = filters.getExcludeOperation().size() > 0;\n+\n+        List<OpenAPIPathSummary> openAPIPathSummaries = MatchResourcewithOperationId.summarizeOpenAPI(openApi);\n+        // Check based on the method and path filters\n+        Iterator<OpenAPIPathSummary> openAPIIter = openAPIPathSummaries.iterator();\n+        while (openAPIIter.hasNext()) {\n+            OpenAPIPathSummary openAPIPathSummary = openAPIIter.next();\n+            // If operation filtering available proceed.\n+            // Else if proceed to check exclude operation filter is enable\n+            // Else check tag filtering or excludeTag filtering enable.\n+            if (operationFilteringEnabled) {\n+                // If tag filtering available validate only the filtered operations grouped by given tags.\n+                // Else if exclude tag filtering available validate only the operations that are not include\n+                // exclude Tags.\n+                // Else proceed only to validate filtered operations.\n+                if (tagFilteringEnabled) {\n+                    Iterator<Map.Entry<String, Operation>> operations =\n+                            openAPIPathSummary.getOperations().entrySet().iterator();\n+                    while (operations.hasNext()) {\n+                        Map.Entry<String, Operation> operationMap = operations.next();\n+//                        Check operationId is null scenario.\n+                        if ((filters.getOperation().contains(operationMap.getValue().getOperationId())) ||\n+                                operationMap.getValue().getOperationId() == null) {\n+//                                    Check tag is available if it is null then remove other wise else-if not include\n+//                                    tag then remove operations.\n+                            if (operationMap.getValue().getTags() == null) {\n+                                operations.remove();\n+                            } else if (Collections.disjoint(filters.getTag(), operationMap.getValue().getTags())) {\n+//                                        Remove operation\n+                                operations.remove();\n+                            }\n+                        } else {\n+                            operations.remove();\n+                        }\n+                    }\n+                } else if (excludeTagsFilteringEnabled) {\n+                    Iterator<Map.Entry<String, Operation>> operationIter =\n+                            openAPIPathSummary.getOperations().entrySet().iterator();\n+                    while (operationIter.hasNext()) {\n+                        Map.Entry<String, Operation> operationMap = operationIter.next();\n+                        if (filters.getOperation().contains(operationMap.getValue().getOperationId())) {\n+//                                    Check tag is available\n+                            if (operationMap.getValue().getTags() != null) {\n+                                if (!Collections.disjoint(filters.getExcludeTag(), operationMap.getValue().getTags())) {\n+                                    operationIter.remove();\n+                                }\n+                            }\n+                        } else {\n+                            operationIter.remove();\n+                        }\n+                    }\n+                } else {\n+                    Iterator<Map.Entry<String, Operation>> operationIter =\n+                            openAPIPathSummary.getOperations().entrySet().iterator();\n+                    while (operationIter.hasNext()) {\n+                        Map.Entry<String, Operation> operationMap = operationIter.next();\n+                        if (!filters.getOperation().contains(operationMap.getValue().getOperationId())) {\n+                            operationIter.remove();\n+                        }\n+                    }\n+                }\n+            } else if (excludeOperationFilteringEnable) {\n+                // If exclude tags filtering available validate only the filtered exclude operations grouped by\n+                // given exclude tags.\n+                // Else If tags filtering available validate only the operations that filtered by exclude\n+                // operations.\n+                // Else proceed only to validate filtered exclude operations.\n+                if (excludeTagsFilteringEnabled) {\n+                    Iterator<Map.Entry<String, Operation>> operationIter =\n+                            openAPIPathSummary.getOperations().entrySet().iterator();\n+                    while (operationIter.hasNext()) {\n+                        Map.Entry<String, Operation> operationMap = operationIter.next();\n+                        if (!filters.getExcludeOperation().contains(operationMap.getValue().getOperationId())) {\n+                            if (operationMap.getValue().getTags() != null) {\n+                                if (!Collections.disjoint(filters.getExcludeTag(), operationMap.getValue().getTags())) {\n+                                    operationIter.remove();\n+                                }\n+                            } else {\n+                                operationIter.remove();\n+                            }\n+                        } else {\n+                            operationIter.remove();\n+                        }\n+                    }\n+                } else if (tagFilteringEnabled) {\n+                    Iterator<Map.Entry<String, Operation>> operations =\n+                            openAPIPathSummary.getOperations().entrySet().iterator();\n+                    while (operations.hasNext()) {\n+                        Map.Entry<String, Operation> operationMap = operations.next();\n+                        if (!filters.getExcludeOperation().contains(operationMap.getValue().getOperationId())) {\n+//                                    Check tag is available if it is null and not included in list\n+//                                    then remove operations.\n+                            if (operationMap.getValue().getTags() == null) {\n+                                operations.remove();\n+                            } else if (Collections.disjoint(filters.getTag(), operationMap.getValue().getTags())) {\n+                                operations.remove();\n+                            }\n+                        } else {\n+                            operations.remove();\n+                        }\n+                    }\n+                } else {\n+                    Iterator<Map.Entry<String, Operation>> operationIter =\n+                            openAPIPathSummary.getOperations().entrySet().iterator();\n+                    while (operationIter.hasNext()) {\n+                        Map.Entry<String, Operation> operationMap = operationIter.next();\n+                        if (filters.getExcludeOperation().contains(operationMap.getValue().getOperationId())) {\n+                            operationIter.remove();\n+                        }\n+                    }\n+                }\n+                // If exclude tag filtering available proceed to validate all the operations grouped by tags which\n+                // are not included in list.\n+                // Else if validate the operations group by tag filtering\n+                // Else proceed without any filtering.\n+            } else {\n+                if (excludeTagsFilteringEnabled) {\n+                    Iterator<Map.Entry<String, Operation>> operations =\n+                            openAPIPathSummary.getOperations().entrySet().iterator();\n+                    while (operations.hasNext()) {\n+                        Map.Entry<String, Operation> operationMap = operations.next();\n+                        if (operationMap.getValue().getTags() == null) {\n+                            break;\n+                        } else if (!Collections.disjoint(filters.getExcludeTag(), operationMap.getValue().getTags())) {\n+                            operations.remove();\n+                        }\n+                    }\n+                } else if (tagFilteringEnabled) {\n+                    // If tag filtering available proceed to validate all the operations grouped by given tags.\n+                    // Else proceed only to validate filtered operations.\n+                    Iterator<Map.Entry<String, Operation>> operations =\n+                            openAPIPathSummary.getOperations().entrySet().iterator();\n+                    while (operations.hasNext()) {\n+                        Map.Entry<String, Operation> operationMap = operations.next();\n+                        if (operationMap.getValue().getTags() == null) {\n+                            operations.remove();\n+                        } else if (Collections.disjoint(filters.getTag(), operationMap.getValue().getTags())) {\n+                            operations.remove();\n+                        }\n+                    }\n+                }\n+            }\n+            if (openAPIPathSummary.getOperations().isEmpty()) {\n+                openAPIIter.remove();\n+            }\n+        }\n+        return openAPIPathSummaries;\n+    }\n+\n+    /**\n+     * Checking the available of resource function in openApi contract.\n+     * @param openAPI           openApi contract object\n+     * @param serviceNode       resource service node\n+     * @return                  validation Error list with ResourceValidationError type\n+     */\n+    public static List<ResourceValidationError> checkOperationIsAvailable(OpenAPI openAPI, ServiceNode serviceNode) {\n+        List<ResourceValidationError> resourceValidationErrorList = new ArrayList<>();\n+        List<ResourcePathSummary> resourcePathSummaries = summarizeResources(serviceNode);\n+        List<OpenAPIPathSummary> openAPISummaries = summarizeOpenAPI(openAPI);\n+//      Check given path with its methods has documented in OpenApi contract\n+        for (ResourcePathSummary resourcePathSummary: resourcePathSummaries) {\n+            Boolean isExit = false;\n+            String resourcePath = resourcePathSummary.getPath();\n+            Map<String, ResourceMethod> resourcePathMethods = resourcePathSummary.getMethods();\n+            for (OpenAPIPathSummary openAPIPathSummary : openAPISummaries) {\n+                String servicePath = openAPIPathSummary.getPath();\n+                List<String> servicePathOperations = openAPIPathSummary.getAvailableOperations();\n+                if (resourcePath.equals(servicePath)) {\n+                    isExit = true;\n+                    if ((!servicePathOperations.isEmpty()) && (!resourcePathMethods.isEmpty())) {\n+                        for (Map.Entry<String, ResourceMethod> entry : resourcePathMethods.entrySet()) {\n+                            Boolean isMethodExit = false;\n+                            for (String operation : servicePathOperations) {\n+                                if (entry.getKey().equals(operation)) {\n+                                    isMethodExit = true;\n+                                    break;\n+                                }\n+                            }\n+                            if (!isMethodExit) {\n+                                ResourceValidationError resourceValidationError =\n+                                        new ResourceValidationError(entry.getValue().getMethodPosition(),\n+                                                entry.getKey(), resourcePath);\n+                                resourceValidationErrorList.add(resourceValidationError);\n+                            }\n+                        }\n+                    }\n+                    break;\n+                }\n+            }\n+            if (!isExit) {\n+                ResourceValidationError resourceValidationError =\n+                        new ResourceValidationError(resourcePathSummary.getPathPosition(), null, resourcePath);\n+                resourceValidationErrorList.add(resourceValidationError);\n+            }\n+        }\n+        return resourceValidationErrorList;\n+    }\n+\n+    /**\n+     * Checking the documented services are available at the resource file.\n+     * @param openAPISummaries  openApi contract object\n+     * @param serviceNode       resource file service\n+     * @return                  validation error list type with OpenAPIServiceValidationError\n+     */\n+    public static List<OpenapiServiceValidationError> checkServiceAvailable(List<OpenAPIPathSummary> openAPISummaries,\n+                                                                            ServiceNode serviceNode) {\n+        List<OpenapiServiceValidationError> validationErrors = new ArrayList<>();\n+        List<ResourcePathSummary> resourcePathSummaries = summarizeResources(serviceNode);\n+//        check the contract paths are available at the resource\n+        for (OpenAPIPathSummary openAPIPathSummary: openAPISummaries) {\n+            Boolean isServiceExit = false;\n+            for (ResourcePathSummary resourcePathSummary: resourcePathSummaries) {\n+                if (openAPIPathSummary.getPath().equals(resourcePathSummary.getPath())) {\n+                    isServiceExit = true;\n+//                    check whether documented operations are available at resource file\n+                    if ((!openAPIPathSummary.getAvailableOperations().isEmpty())) {\n+                        for (String operation: openAPIPathSummary.getAvailableOperations()) {\n+                            Boolean isOperationExit = false;\n+                            if (!(resourcePathSummary.getMethods().isEmpty())) {\n+                                for (Map.Entry<String, ResourceMethod> method:\n+                                        resourcePathSummary.getMethods().entrySet()) {\n+                                    if (operation.equals(method.getKey())) {\n+                                        isOperationExit = true;\n+                                        break;\n+                                    }\n+                                }\n+                                if (!isOperationExit) {\n+                                    OpenapiServiceValidationError openapiServiceValidationError =\n+                                            new OpenapiServiceValidationError(serviceNode.getPosition(), operation,\n+                                                    openAPIPathSummary.getPath(),\n+                                                    openAPIPathSummary.getOperations().get(operation).getTags(),\n+                                                    openAPIPathSummary);\n+                                    validationErrors.add(openapiServiceValidationError);\n+                                }\n+                            }\n+                        }\n+                    }\n+                    break;\n+                }\n+            }\n+            if (!isServiceExit) {\n+                OpenapiServiceValidationError openapiServiceValidationError =\n+                        new OpenapiServiceValidationError(serviceNode.getPosition(),\n+                                null, openAPIPathSummary.getPath(), null, openAPIPathSummary);\n+                validationErrors.add(openapiServiceValidationError);\n+            }\n+        }\n+        return validationErrors;\n+    }\n+\n+    /**\n+     * Extract the details to be validated from the resource.\n+     * @param serviceNode         service node\n+     * @return List of ResourcePathSummary\n+     */\n+    public static List<ResourcePathSummary>  summarizeResources(ServiceNode serviceNode) {\n+        // Iterate resources available in a service and extract details to be validated.\n+        List<ResourcePathSummary> resourceSummaryList = new ArrayList<>();\n+        for (FunctionNode resource : serviceNode.getResources()) {\n+            AnnotationAttachmentNode annotation = null;\n+\n+            // Find the \"ResourceConfig\" annotation.\n+            for (AnnotationAttachmentNode ann : resource.getAnnotationAttachments()) {\n+", "originalCommit": "aa43cd0d05bf24efa178f88601f65de03465d24b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjY2NDYwMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25286#discussion_r472664601", "bodyText": "If we are doing the same operations for all places, Why we are having these checks separately? Please correct me, If I missed anything.", "author": "suganyasuven", "createdAt": "2020-08-19T04:08:01Z", "path": "misc/openapi-ballerina/modules/openapi-validator/src/main/java/org/ballerinalang/openapi/validator/MatchResourcewithOperationId.java", "diffHunk": "@@ -0,0 +1,534 @@\n+/*\n+ * Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.openapi.validator;\n+\n+import io.swagger.v3.oas.models.OpenAPI;\n+import io.swagger.v3.oas.models.Operation;\n+import io.swagger.v3.oas.models.PathItem;\n+import org.ballerinalang.model.tree.AnnotationAttachmentNode;\n+import org.ballerinalang.model.tree.FunctionNode;\n+import org.ballerinalang.model.tree.ServiceNode;\n+import org.ballerinalang.openapi.validator.error.OpenapiServiceValidationError;\n+import org.ballerinalang.openapi.validator.error.ResourceValidationError;\n+import org.ballerinalang.util.diagnostic.Diagnostic;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangExpression;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangListConstructorExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangRecordLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangSimpleVarRef;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+/**\n+ * This for finding out the all the filtered operations are documented as services in the ballerina file and all the\n+ * ballerina services are documented in the contract yaml file.\n+ */\n+public class MatchResourcewithOperationId {\n+    /**\n+     * Filter all the operations according to the given filters.\n+     * @param openApi       OpenApi Object\n+     * @param filters       Filter Object\n+     * @return              List of OpenApiPathSummary\n+     */\n+    public static List<OpenAPIPathSummary> filterOpenapi(OpenAPI openApi,\n+                                                         Filters filters) {\n+\n+        boolean tagFilteringEnabled = filters.getTag().size() > 0;\n+        boolean operationFilteringEnabled = filters.getOperation().size() > 0;\n+        boolean excludeTagsFilteringEnabled = filters.getExcludeTag().size() > 0;\n+        boolean excludeOperationFilteringEnable = filters.getExcludeOperation().size() > 0;\n+\n+        List<OpenAPIPathSummary> openAPIPathSummaries = MatchResourcewithOperationId.summarizeOpenAPI(openApi);\n+        // Check based on the method and path filters\n+        Iterator<OpenAPIPathSummary> openAPIIter = openAPIPathSummaries.iterator();\n+        while (openAPIIter.hasNext()) {\n+            OpenAPIPathSummary openAPIPathSummary = openAPIIter.next();\n+            // If operation filtering available proceed.\n+            // Else if proceed to check exclude operation filter is enable\n+            // Else check tag filtering or excludeTag filtering enable.\n+            if (operationFilteringEnabled) {\n+                // If tag filtering available validate only the filtered operations grouped by given tags.\n+                // Else if exclude tag filtering available validate only the operations that are not include\n+                // exclude Tags.\n+                // Else proceed only to validate filtered operations.\n+                if (tagFilteringEnabled) {\n+                    Iterator<Map.Entry<String, Operation>> operations =\n+                            openAPIPathSummary.getOperations().entrySet().iterator();\n+                    while (operations.hasNext()) {\n+                        Map.Entry<String, Operation> operationMap = operations.next();\n+//                        Check operationId is null scenario.\n+                        if ((filters.getOperation().contains(operationMap.getValue().getOperationId())) ||\n+                                operationMap.getValue().getOperationId() == null) {\n+//                                    Check tag is available if it is null then remove other wise else-if not include\n+//                                    tag then remove operations.\n+                            if (operationMap.getValue().getTags() == null) {\n+                                operations.remove();\n+                            } else if (Collections.disjoint(filters.getTag(), operationMap.getValue().getTags())) {\n+//                                        Remove operation\n+                                operations.remove();\n+                            }\n+                        } else {\n+                            operations.remove();\n+                        }\n+                    }\n+                } else if (excludeTagsFilteringEnabled) {\n+                    Iterator<Map.Entry<String, Operation>> operationIter =\n+                            openAPIPathSummary.getOperations().entrySet().iterator();\n+                    while (operationIter.hasNext()) {\n+                        Map.Entry<String, Operation> operationMap = operationIter.next();\n+                        if (filters.getOperation().contains(operationMap.getValue().getOperationId())) {\n+//                                    Check tag is available\n+                            if (operationMap.getValue().getTags() != null) {\n+                                if (!Collections.disjoint(filters.getExcludeTag(), operationMap.getValue().getTags())) {\n+                                    operationIter.remove();\n+                                }\n+                            }\n+                        } else {\n+                            operationIter.remove();\n+                        }\n+                    }\n+                } else {\n+                    Iterator<Map.Entry<String, Operation>> operationIter =\n+                            openAPIPathSummary.getOperations().entrySet().iterator();\n+                    while (operationIter.hasNext()) {\n+                        Map.Entry<String, Operation> operationMap = operationIter.next();\n+                        if (!filters.getOperation().contains(operationMap.getValue().getOperationId())) {\n+                            operationIter.remove();\n+                        }\n+                    }\n+                }\n+            } else if (excludeOperationFilteringEnable) {\n+                // If exclude tags filtering available validate only the filtered exclude operations grouped by\n+                // given exclude tags.\n+                // Else If tags filtering available validate only the operations that filtered by exclude\n+                // operations.\n+                // Else proceed only to validate filtered exclude operations.\n+                if (excludeTagsFilteringEnabled) {\n+                    Iterator<Map.Entry<String, Operation>> operationIter =\n+                            openAPIPathSummary.getOperations().entrySet().iterator();\n+                    while (operationIter.hasNext()) {\n+                        Map.Entry<String, Operation> operationMap = operationIter.next();\n+                        if (!filters.getExcludeOperation().contains(operationMap.getValue().getOperationId())) {\n+                            if (operationMap.getValue().getTags() != null) {\n+                                if (!Collections.disjoint(filters.getExcludeTag(), operationMap.getValue().getTags())) {\n+                                    operationIter.remove();\n+                                }\n+                            } else {\n+                                operationIter.remove();\n+                            }\n+                        } else {\n+                            operationIter.remove();\n+                        }\n+                    }\n+                } else if (tagFilteringEnabled) {\n+                    Iterator<Map.Entry<String, Operation>> operations =\n+                            openAPIPathSummary.getOperations().entrySet().iterator();\n+                    while (operations.hasNext()) {\n+                        Map.Entry<String, Operation> operationMap = operations.next();\n+                        if (!filters.getExcludeOperation().contains(operationMap.getValue().getOperationId())) {\n+//                                    Check tag is available if it is null and not included in list\n+//                                    then remove operations.\n+                            if (operationMap.getValue().getTags() == null) {\n+                                operations.remove();\n+                            } else if (Collections.disjoint(filters.getTag(), operationMap.getValue().getTags())) {\n+                                operations.remove();\n+                            }\n+                        } else {\n+                            operations.remove();\n+                        }\n+                    }\n+                } else {", "originalCommit": "aa43cd0d05bf24efa178f88601f65de03465d24b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjY2NTQxOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25286#discussion_r472665419", "bodyText": "Why this is commented? Don't we need to catch the exception here?", "author": "suganyasuven", "createdAt": "2020-08-19T04:09:23Z", "path": "misc/openapi-ballerina/modules/openapi-validator/src/main/java/org/ballerinalang/openapi/validator/OpenApiValidatorUtil.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.openapi.validator;\n+\n+import org.ballerinalang.compiler.CompilerPhase;\n+import org.ballerinalang.tool.BLauncherCmd;\n+import org.ballerinalang.tool.BLauncherException;\n+import org.wso2.ballerinalang.compiler.Compiler;\n+import org.wso2.ballerinalang.compiler.FileSystemProgramDirectory;\n+import org.wso2.ballerinalang.compiler.SourceDirectory;\n+import org.wso2.ballerinalang.compiler.tree.BLangPackage;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.CompilerOptions;\n+\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+import static org.ballerinalang.compiler.CompilerOptionName.COMPILER_PHASE;\n+import static org.ballerinalang.compiler.CompilerOptionName.EXPERIMENTAL_FEATURES_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.LOCK_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.OFFLINE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PRESERVE_WHITESPACE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PROJECT_DIR;\n+import static org.ballerinalang.compiler.CompilerOptionName.SKIP_TESTS;\n+import static org.ballerinalang.compiler.CompilerOptionName.TEST_ENABLED;\n+\n+/**\n+ * Util class for compilation and format execution for formatting CLI tool.\n+ */\n+public class OpenApiValidatorUtil {\n+    static final String CMD_NAME = \"build\";\n+    private static final PrintStream outStream = System.err;\n+    private static EmptyPrintStream emptyPrintStream;\n+\n+    /**\n+     * Execute formatter.\n+     * @param argList        argument list from the console\n+     * @param helpFlag       flag to get the help page\n+     * @param sourceRootPath execution path\n+     */\n+    public static void execute(List<String> argList, boolean helpFlag, Path sourceRootPath) throws BLauncherException {\n+        if (helpFlag) {\n+            String commandUsageInfo = BLauncherCmd.getCommandUsageInfo(CMD_NAME);\n+            outStream.println(commandUsageInfo);\n+            return;\n+        }\n+        String moduleName;\n+        String ballerinaFilePath;\n+\n+        try {\n+            // If parameters are available user has given either the module name or the ballerina file path.\n+            // Else user is in a ballerina project\n+            if (argList != null && argList.size() > 0) {\n+                // If the given param is a ballerina file path, this will compile the file.\n+                // Else the given param is a module name, this will compile the module.\n+                if (OpenApiValidatorUtil.isBalFile(argList.get(0))) {\n+                    ballerinaFilePath = argList.get(0);\n+                    Path filePath = Paths.get(ballerinaFilePath);\n+                    Path programDir = filePath.toAbsolutePath().getParent();\n+                    String fileName = filePath.toAbsolutePath().getFileName().toString();\n+\n+                    // Compile ballerina file.\n+                    BLangPackage bLangPackage = compileFile(programDir, fileName);\n+\n+                    // If there are compilation errors do not continue the process.\n+                    if (bLangPackage.diagCollector.hasErrors()) {\n+                        return;\n+                    }\n+\n+                } else {\n+                    moduleName = argList.get(0);\n+\n+                    BLangPackage bLangPackage = OpenApiValidatorUtil\n+                            .compileModule(sourceRootPath, getModuleName(moduleName));\n+\n+                    // If there are no compilation errors do not continue the process.\n+                    if (bLangPackage.diagCollector.hasErrors()) {\n+                        return;\n+                    }\n+                }\n+            }\n+        } catch (IOException | NullPointerException e) {\n+//            throw LauncherUtils.createLauncherException(Messages.getException());", "originalCommit": "aa43cd0d05bf24efa178f88601f65de03465d24b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjY2NzI0NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25286#discussion_r472667244", "bodyText": "Shall we use this constant BLANG_SOURCE_EXT inside ProjectDirConstants class?", "author": "suganyasuven", "createdAt": "2020-08-19T04:12:11Z", "path": "misc/openapi-ballerina/modules/openapi-validator/src/main/java/org/ballerinalang/openapi/validator/OpenApiValidatorUtil.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.openapi.validator;\n+\n+import org.ballerinalang.compiler.CompilerPhase;\n+import org.ballerinalang.tool.BLauncherCmd;\n+import org.ballerinalang.tool.BLauncherException;\n+import org.wso2.ballerinalang.compiler.Compiler;\n+import org.wso2.ballerinalang.compiler.FileSystemProgramDirectory;\n+import org.wso2.ballerinalang.compiler.SourceDirectory;\n+import org.wso2.ballerinalang.compiler.tree.BLangPackage;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.CompilerOptions;\n+\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+import static org.ballerinalang.compiler.CompilerOptionName.COMPILER_PHASE;\n+import static org.ballerinalang.compiler.CompilerOptionName.EXPERIMENTAL_FEATURES_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.LOCK_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.OFFLINE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PRESERVE_WHITESPACE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PROJECT_DIR;\n+import static org.ballerinalang.compiler.CompilerOptionName.SKIP_TESTS;\n+import static org.ballerinalang.compiler.CompilerOptionName.TEST_ENABLED;\n+\n+/**\n+ * Util class for compilation and format execution for formatting CLI tool.\n+ */\n+public class OpenApiValidatorUtil {\n+    static final String CMD_NAME = \"build\";\n+    private static final PrintStream outStream = System.err;\n+    private static EmptyPrintStream emptyPrintStream;\n+\n+    /**\n+     * Execute formatter.\n+     * @param argList        argument list from the console\n+     * @param helpFlag       flag to get the help page\n+     * @param sourceRootPath execution path\n+     */\n+    public static void execute(List<String> argList, boolean helpFlag, Path sourceRootPath) throws BLauncherException {\n+        if (helpFlag) {\n+            String commandUsageInfo = BLauncherCmd.getCommandUsageInfo(CMD_NAME);\n+            outStream.println(commandUsageInfo);\n+            return;\n+        }\n+        String moduleName;\n+        String ballerinaFilePath;\n+\n+        try {\n+            // If parameters are available user has given either the module name or the ballerina file path.\n+            // Else user is in a ballerina project\n+            if (argList != null && argList.size() > 0) {\n+                // If the given param is a ballerina file path, this will compile the file.\n+                // Else the given param is a module name, this will compile the module.\n+                if (OpenApiValidatorUtil.isBalFile(argList.get(0))) {\n+                    ballerinaFilePath = argList.get(0);\n+                    Path filePath = Paths.get(ballerinaFilePath);\n+                    Path programDir = filePath.toAbsolutePath().getParent();\n+                    String fileName = filePath.toAbsolutePath().getFileName().toString();\n+\n+                    // Compile ballerina file.\n+                    BLangPackage bLangPackage = compileFile(programDir, fileName);\n+\n+                    // If there are compilation errors do not continue the process.\n+                    if (bLangPackage.diagCollector.hasErrors()) {\n+                        return;\n+                    }\n+\n+                } else {\n+                    moduleName = argList.get(0);\n+\n+                    BLangPackage bLangPackage = OpenApiValidatorUtil\n+                            .compileModule(sourceRootPath, getModuleName(moduleName));\n+\n+                    // If there are no compilation errors do not continue the process.\n+                    if (bLangPackage.diagCollector.hasErrors()) {\n+                        return;\n+                    }\n+                }\n+            }\n+        } catch (IOException | NullPointerException e) {\n+//            throw LauncherUtils.createLauncherException(Messages.getException());\n+        }\n+    }\n+\n+    /**\n+     * Check whether the given file is a ballerina file.\n+     *\n+     * @param fileName file name to be check whether a ballerina file\n+     * @return {@link Boolean} true or false\n+     */\n+    private static boolean isBalFile(String fileName) {\n+        return fileName.endsWith(\".bal\");", "originalCommit": "aa43cd0d05bf24efa178f88601f65de03465d24b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjY3MzM0OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25286#discussion_r472673349", "bodyText": "Can't we merge these two methods using SourceType?", "author": "suganyasuven", "createdAt": "2020-08-19T04:21:59Z", "path": "misc/openapi-ballerina/modules/openapi-validator/src/main/java/org/ballerinalang/openapi/validator/OpenApiValidatorUtil.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.openapi.validator;\n+\n+import org.ballerinalang.compiler.CompilerPhase;\n+import org.ballerinalang.tool.BLauncherCmd;\n+import org.ballerinalang.tool.BLauncherException;\n+import org.wso2.ballerinalang.compiler.Compiler;\n+import org.wso2.ballerinalang.compiler.FileSystemProgramDirectory;\n+import org.wso2.ballerinalang.compiler.SourceDirectory;\n+import org.wso2.ballerinalang.compiler.tree.BLangPackage;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.CompilerOptions;\n+\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+import static org.ballerinalang.compiler.CompilerOptionName.COMPILER_PHASE;\n+import static org.ballerinalang.compiler.CompilerOptionName.EXPERIMENTAL_FEATURES_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.LOCK_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.OFFLINE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PRESERVE_WHITESPACE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PROJECT_DIR;\n+import static org.ballerinalang.compiler.CompilerOptionName.SKIP_TESTS;\n+import static org.ballerinalang.compiler.CompilerOptionName.TEST_ENABLED;\n+\n+/**\n+ * Util class for compilation and format execution for formatting CLI tool.\n+ */\n+public class OpenApiValidatorUtil {\n+    static final String CMD_NAME = \"build\";\n+    private static final PrintStream outStream = System.err;\n+    private static EmptyPrintStream emptyPrintStream;\n+\n+    /**\n+     * Execute formatter.\n+     * @param argList        argument list from the console\n+     * @param helpFlag       flag to get the help page\n+     * @param sourceRootPath execution path\n+     */\n+    public static void execute(List<String> argList, boolean helpFlag, Path sourceRootPath) throws BLauncherException {\n+        if (helpFlag) {\n+            String commandUsageInfo = BLauncherCmd.getCommandUsageInfo(CMD_NAME);\n+            outStream.println(commandUsageInfo);\n+            return;\n+        }\n+        String moduleName;\n+        String ballerinaFilePath;\n+\n+        try {\n+            // If parameters are available user has given either the module name or the ballerina file path.\n+            // Else user is in a ballerina project\n+            if (argList != null && argList.size() > 0) {\n+                // If the given param is a ballerina file path, this will compile the file.\n+                // Else the given param is a module name, this will compile the module.\n+                if (OpenApiValidatorUtil.isBalFile(argList.get(0))) {\n+                    ballerinaFilePath = argList.get(0);\n+                    Path filePath = Paths.get(ballerinaFilePath);\n+                    Path programDir = filePath.toAbsolutePath().getParent();\n+                    String fileName = filePath.toAbsolutePath().getFileName().toString();\n+\n+                    // Compile ballerina file.\n+                    BLangPackage bLangPackage = compileFile(programDir, fileName);\n+\n+                    // If there are compilation errors do not continue the process.\n+                    if (bLangPackage.diagCollector.hasErrors()) {\n+                        return;\n+                    }\n+\n+                } else {\n+                    moduleName = argList.get(0);\n+\n+                    BLangPackage bLangPackage = OpenApiValidatorUtil\n+                            .compileModule(sourceRootPath, getModuleName(moduleName));\n+\n+                    // If there are no compilation errors do not continue the process.\n+                    if (bLangPackage.diagCollector.hasErrors()) {\n+                        return;\n+                    }\n+                }\n+            }\n+        } catch (IOException | NullPointerException e) {\n+//            throw LauncherUtils.createLauncherException(Messages.getException());\n+        }\n+    }\n+\n+    /**\n+     * Check whether the given file is a ballerina file.\n+     *\n+     * @param fileName file name to be check whether a ballerina file\n+     * @return {@link Boolean} true or false\n+     */\n+    private static boolean isBalFile(String fileName) {\n+        return fileName.endsWith(\".bal\");\n+    }\n+\n+    /**\n+     * Compile only a ballerina module.\n+     *\n+     * @param sourceRoot source root\n+     * @param moduleName name of the module to be compiled\n+     * @return {@link BLangPackage} ballerina package\n+     */\n+    public static BLangPackage compileModule(Path sourceRoot, String moduleName) throws UnsupportedEncodingException {\n+        emptyPrintStream = new EmptyPrintStream();\n+        CompilerContext context = getCompilerContext(sourceRoot);\n+        Compiler compiler = Compiler.getInstance(context);\n+        // Set an EmptyPrintStream to hide unnecessary outputs from compiler.\n+        compiler.setOutStream(emptyPrintStream);\n+        return compiler.compile(moduleName);\n+    }\n+\n+    /**\n+     * Compile a ballerina file.\n+     *\n+     * @param sourceRoot  source root of the file\n+     * @param packageName package name of the file\n+     * @return {@link BLangPackage} ballerina package\n+     */\n+    public static BLangPackage compileFile(Path sourceRoot, String packageName) throws UnsupportedEncodingException {\n+        emptyPrintStream = new EmptyPrintStream();\n+        CompilerContext context = getCompilerContext(sourceRoot);\n+        // Set the SourceDirectory to process this compilation as a program directory.\n+        context.put(SourceDirectory.class, new FileSystemProgramDirectory(sourceRoot));\n+        Compiler compiler = Compiler.getInstance(context);\n+        // Set an EmptyPrintStream to hide unnecessary outputs from compiler.\n+        compiler.setOutStream(emptyPrintStream);\n+        return compiler.compile(packageName);\n+    }", "originalCommit": "aa43cd0d05bf24efa178f88601f65de03465d24b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjgzODMyNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25286#discussion_r472838325", "bodyText": "yes we can, I removed unused functions for test", "author": "lnash94", "createdAt": "2020-08-19T08:07:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjY3MzM0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjY3NTg1Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25286#discussion_r472675852", "bodyText": "Please add a line between these getters and setters.", "author": "suganyasuven", "createdAt": "2020-08-19T04:26:12Z", "path": "misc/openapi-ballerina/modules/openapi-validator/src/main/java/org/ballerinalang/openapi/validator/Filters.java", "diffHunk": "@@ -0,0 +1,56 @@\n+package org.ballerinalang.openapi.validator;\n+\n+import org.ballerinalang.util.diagnostic.Diagnostic;\n+\n+import java.util.List;\n+\n+/**\n+ * This for model the all tag, operations, excludeTags and excludeOperations filters.\n+ */\n+public class Filters {\n+    private List<String> tag;\n+    private List<String> excludeTag;\n+    private List<String> operation;\n+    private List<String> excludeOperation;\n+    private Diagnostic.Kind kind;\n+\n+    public Filters(List<String> tag, List<String> excludeTag, List<String> operation,\n+                   List<String> excludeOperation, Diagnostic.Kind kind) {\n+        this.tag = tag;\n+        this.excludeTag = excludeTag;\n+        this.operation = operation;\n+        this.excludeOperation = excludeOperation;\n+        this.kind = kind;\n+    }\n+\n+    public List<String> getTag() {\n+        return tag;\n+    }", "originalCommit": "aa43cd0d05bf24efa178f88601f65de03465d24b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjY3NjcxOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25286#discussion_r472676719", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Diagnostic.DiagnosticPosition getMethodPosition() {\n          \n          \n            \n                public Diagnostic.DiagnosticPosition getMethodPosition() {", "author": "suganyasuven", "createdAt": "2020-08-19T04:27:42Z", "path": "misc/openapi-ballerina/modules/openapi-validator/src/main/java/org/ballerinalang/openapi/validator/ResourceMethod.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.openapi.validator;\n+\n+import org.ballerinalang.model.tree.SimpleVariableNode;\n+import org.ballerinalang.util.diagnostic.Diagnostic;\n+import org.wso2.ballerinalang.compiler.tree.BLangSimpleVariable;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Class for containing the service details.\n+ */\n+public class ResourceMethod {\n+    private Diagnostic.DiagnosticPosition resourcePosition;\n+    private String method;\n+    private Diagnostic.DiagnosticPosition methodPosition;\n+    private Map<String, BLangSimpleVariable> parameters;\n+    private String body;\n+\n+    ResourceMethod() {\n+        this.method = null;\n+        this.methodPosition = null;\n+        this.resourcePosition = null;\n+        this.parameters = new HashMap<>();\n+        this.body = null;\n+    }\n+\n+    Diagnostic.DiagnosticPosition getMethodPosition() {", "originalCommit": "aa43cd0d05bf24efa178f88601f65de03465d24b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjY3Njg4Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25286#discussion_r472676887", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                void setMethodPosition(Diagnostic.DiagnosticPosition methodsPosition) {\n          \n          \n            \n                public void setMethodPosition(Diagnostic.DiagnosticPosition methodsPosition) {", "author": "suganyasuven", "createdAt": "2020-08-19T04:27:56Z", "path": "misc/openapi-ballerina/modules/openapi-validator/src/main/java/org/ballerinalang/openapi/validator/ResourceMethod.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.openapi.validator;\n+\n+import org.ballerinalang.model.tree.SimpleVariableNode;\n+import org.ballerinalang.util.diagnostic.Diagnostic;\n+import org.wso2.ballerinalang.compiler.tree.BLangSimpleVariable;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Class for containing the service details.\n+ */\n+public class ResourceMethod {\n+    private Diagnostic.DiagnosticPosition resourcePosition;\n+    private String method;\n+    private Diagnostic.DiagnosticPosition methodPosition;\n+    private Map<String, BLangSimpleVariable> parameters;\n+    private String body;\n+\n+    ResourceMethod() {\n+        this.method = null;\n+        this.methodPosition = null;\n+        this.resourcePosition = null;\n+        this.parameters = new HashMap<>();\n+        this.body = null;\n+    }\n+\n+    Diagnostic.DiagnosticPosition getMethodPosition() {\n+        return methodPosition;\n+    }\n+\n+    void setMethodPosition(Diagnostic.DiagnosticPosition methodsPosition) {", "originalCommit": "aa43cd0d05bf24efa178f88601f65de03465d24b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjY3ODc0NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25286#discussion_r472678745", "bodyText": "Add modifiers to the methods. Please check other places as well.", "author": "suganyasuven", "createdAt": "2020-08-19T04:30:57Z", "path": "misc/openapi-ballerina/modules/openapi-validator/src/main/java/org/ballerinalang/openapi/validator/ResourcePathSummary.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.openapi.validator;\n+\n+import org.ballerinalang.util.diagnostic.Diagnostic;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Summarized details of a Ballerina resource to be validated against OpenAPI document.\n+ */\n+public class ResourcePathSummary {\n+    private String path;\n+    private Diagnostic.DiagnosticPosition pathPosition;\n+    private Map<String, ResourceMethod> methods;\n+\n+    ResourcePathSummary() {\n+        this.methods = new HashMap<>();\n+        this.path = null;\n+        this.pathPosition = null;\n+    }\n+\n+    String getPath() {\n+        return path;\n+    }\n+\n+    void setPath(String path) {\n+        this.path = path;\n+    }\n+\n+    public Map<String, ResourceMethod> getMethods() {\n+        return methods;\n+    }\n+\n+    void addMethod(String method, ResourceMethod resourceMethod) {", "originalCommit": "aa43cd0d05bf24efa178f88601f65de03465d24b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjY4MTA4Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25286#discussion_r472681083", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if ((requestBody.getContent() != null) && !getOperationRequestBody(operation).isEmpty()) {\n          \n          \n            \n                    if (requestBody.getContent() != null && !getOperationRequestBody(operation).isEmpty()) {", "author": "suganyasuven", "createdAt": "2020-08-19T04:34:56Z", "path": "misc/openapi-ballerina/modules/openapi-validator/src/main/java/org/ballerinalang/openapi/validator/ResourceValidator.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.openapi.validator;\n+\n+import io.swagger.v3.oas.models.Operation;\n+import io.swagger.v3.oas.models.media.Content;\n+import io.swagger.v3.oas.models.media.MediaType;\n+import io.swagger.v3.oas.models.media.Schema;\n+import io.swagger.v3.oas.models.parameters.Parameter;\n+import io.swagger.v3.oas.models.parameters.PathParameter;\n+import io.swagger.v3.oas.models.parameters.QueryParameter;\n+import io.swagger.v3.oas.models.parameters.RequestBody;\n+import org.ballerinalang.openapi.validator.error.MissingFieldInBallerinaType;\n+import org.ballerinalang.openapi.validator.error.MissingFieldInJsonSchema;\n+import org.ballerinalang.openapi.validator.error.OneOfTypeValidation;\n+import org.ballerinalang.openapi.validator.error.TypeMismatch;\n+import org.ballerinalang.openapi.validator.error.ValidationError;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * This util is checking the availability of services and the operations in contract and ballerina file.\n+ */\n+public class ResourceValidator {\n+\n+    /**\n+     * Validate the missing fields in openapi operation according to resource service.\n+     * @param operation         openAPi operation\n+     * @param resourceMethod    validate resourceMethods\n+     * @return                  list of validationErrors\n+     * @throws OpenApiValidatorException\n+     */\n+    public static List<ValidationError> validateResourceAgainstOperation(Operation operation,\n+                                                                         ResourceMethod resourceMethod)\n+            throws OpenApiValidatorException {\n+\n+        List<ValidationError> validationErrors = new ArrayList<>();\n+        if (!resourceMethod.getParamNames().isEmpty()) {\n+            for (ResourceParameter resourceParameter: resourceMethod.getParamNames()) {\n+                Boolean isParameterExit = false;\n+                //  Handle the requestBody parameter\n+                if ((resourceMethod.getBody() != null) && (resourceMethod.getBody().equals(resourceParameter.getName()))\n+                        && (operation.getRequestBody() != null)) {\n+                        RequestBody requestBody = operation.getRequestBody();\n+                    isParameterExit =\n+                            validateRequestBodyResourceToOpenApi(operation, validationErrors, resourceParameter,\n+                                    isParameterExit, requestBody);\n+\n+                    //  Handle Path parameter\n+                } else if (operation.getParameters() != null) {\n+                    for (Parameter parameter : operation.getParameters()) {\n+                        if (resourceParameter.getName().equals(parameter.getName()) &&\n+                                (parameter.getSchema() != null)) {\n+                            isParameterExit = true;\n+                            List<ValidationError> validationErrorsResource =\n+                                    BTypeToJsonValidatorUtil.validate(parameter.getSchema(),\n+                                            resourceParameter.getParameter().symbol);\n+                            if (!validationErrorsResource.isEmpty()) {\n+                                validationErrors.addAll(validationErrorsResource);\n+                            }\n+                            break;\n+                        }\n+                    }\n+                }\n+                if (!isParameterExit) {\n+                    ValidationError validationError = new ValidationError(resourceParameter.getName(),\n+                            BTypeToJsonValidatorUtil.convertTypeToEnum(resourceParameter.getType()));\n+                    validationErrors.add(validationError);\n+                }\n+            }\n+        }\n+        return validationErrors;\n+    }\n+\n+    /**\n+     * Validate request Body parameters in resource against to openAPI.\n+     * @param operation             validate openApi operation\n+     * @param validationErrors      list of validationErrors\n+     * @param resourceParameter     validate resource parameter\n+     * @param isParameterExit       boolean tag for checking parameter is available\n+     * @param requestBody           requestBody type  operation parameter\n+     * @return  boolean value for indicating parameter is available\n+     * @throws OpenApiValidatorException\n+     */\n+    private static Boolean validateRequestBodyResourceToOpenApi(Operation operation,\n+                                                                List<ValidationError> validationErrors,\n+                                                                ResourceParameter resourceParameter,\n+                                                                Boolean isParameterExit, RequestBody requestBody)\n+            throws OpenApiValidatorException {\n+\n+        if ((requestBody.getContent() != null) && !getOperationRequestBody(operation).isEmpty()) {", "originalCommit": "aa43cd0d05bf24efa178f88601f65de03465d24b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc1MzM3NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25286#discussion_r472753374", "bodyText": "There is a small typo. traversNestedArray has to be traverseNestedArray. traverse is misspelled everywhere", "author": "parkavi11", "createdAt": "2020-08-19T06:25:10Z", "path": "misc/openapi-ballerina/modules/openapi-validator/src/main/java/org/ballerinalang/openapi/validator/BTypeToJsonValidatorUtil.java", "diffHunk": "@@ -0,0 +1,785 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package org.ballerinalang.openapi.validator;\n+\n+import io.swagger.v3.oas.models.media.ArraySchema;\n+import io.swagger.v3.oas.models.media.ComposedSchema;\n+import io.swagger.v3.oas.models.media.ObjectSchema;\n+import io.swagger.v3.oas.models.media.Schema;\n+import org.ballerinalang.openapi.validator.error.MissingFieldInBallerinaType;\n+import org.ballerinalang.openapi.validator.error.MissingFieldInJsonSchema;\n+import org.ballerinalang.openapi.validator.error.OneOfTypeValidation;\n+import org.ballerinalang.openapi.validator.error.TypeMismatch;\n+import org.ballerinalang.openapi.validator.error.ValidationError;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BVarSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BAnyType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BArrayType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BField;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BRecordType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BUnionType;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+\n+/**\n+ * This util class for validate the any given schema with BVarSymbol type.\n+ */\n+public  class BTypeToJsonValidatorUtil {\n+\n+    /**\n+     * Validate given schema with bVarSymbol.\n+     * @param schema        openAPi schema object\n+     * @param bVarSymbol    bVarSymbol with given parameter\n+     * @return  List of ValidationErrors\n+     * @throws OpenApiValidatorException    openApiException\n+     */\n+    public static List<ValidationError> validate(Schema<?> schema, BVarSymbol bVarSymbol)\n+            throws OpenApiValidatorException {\n+\n+        List<ValidationError> validationErrors = new ArrayList<>();\n+        boolean isExitType = false;\n+        BType resourceType;\n+        resourceType = bVarSymbol.getType();\n+        // Validate the BVarType against to schema\n+        if (schema != null) {\n+            if ((bVarSymbol.type instanceof BRecordType) || (schema instanceof ObjectSchema)) {\n+                Map<String, Schema> properties = schema.getProperties();\n+                if (schema instanceof ObjectSchema) {\n+                    properties = ((ObjectSchema) schema).getProperties();\n+                }\n+                // Check the Item type has array type\n+                BRecordType recordType = null;\n+                if (resourceType instanceof BArrayType) {\n+                    BArrayType bArrayTypeBVarSymbol = (BArrayType) resourceType;\n+                    if (bArrayTypeBVarSymbol.eType instanceof BRecordType) {\n+                        resourceType = bArrayTypeBVarSymbol.eType;\n+                        recordType = (BRecordType) resourceType;\n+                    }\n+                } else if (resourceType instanceof BRecordType) {\n+                    recordType = (BRecordType) resourceType;\n+                }\n+                // Validate errors in records\n+                List<ValidationError> recordValidationErrors = new ArrayList<>();\n+                if (recordType != null) {\n+                    validateRecord(recordValidationErrors, properties, recordType);\n+                    validationErrors.addAll(recordValidationErrors);\n+                }\n+                isExitType = true;\n+                //  Array type validation\n+            } else if (resourceType.getKind().typeName().equals(\"[]\") && schema.getType().equals(Constants.ARRAY)) {\n+                validateArray(schema, bVarSymbol, validationErrors, resourceType);\n+                isExitType = true;\n+\n+            } else if (resourceType.getKind().typeName().equals(Constants.STRING)\n+                    && schema.getType().equals(Constants.STRING)) {\n+                isExitType = true;\n+\n+            } else if (resourceType.getKind().typeName().equals(Constants.INT)\n+                    && schema.getType().equals(Constants.INTEGER)) {\n+                isExitType = true;\n+\n+            } else if (resourceType.getKind().typeName().equals(Constants.BOOLEAN)\n+                    && schema.getType().equals(Constants.BOOLEAN)) {\n+                isExitType = true;\n+\n+            } else if (resourceType.getKind().typeName().equals(Constants.DECIMAL)\n+                    && schema.getType().equals(Constants.NUMBER)) {\n+                isExitType = true;\n+\n+            } else if (resourceType instanceof BUnionType) {\n+                // Validate OneOf type data\n+                validateOneOfType(schema, bVarSymbol, validationErrors, isExitType, (BUnionType) resourceType);\n+                isExitType = true;\n+            }\n+        }\n+        if (!isExitType) {\n+            assert schema != null;\n+            TypeMismatch typeMismatch = new TypeMismatch(bVarSymbol.name.toString(),\n+                    convertTypeToEnum(resourceType.getKind().typeName()),\n+                    convertTypeToEnum(schema.getType()));\n+            validationErrors.add(typeMismatch);\n+        }\n+        return validationErrors;\n+    }\n+\n+    /**\n+     * Validate in oneOf type parameters.\n+     * @param schema            OneOf schema\n+     * @param bVarSymbol        bVarSymbol for parameter\n+     * @param validationErrors  list of ValidationErrors\n+     * @param isExitType        tag for tracking the availability of parameter\n+     * @param resourceType      validate resource type\n+     * @throws OpenApiValidatorException\n+     */\n+    private static void validateOneOfType(Schema<?> schema, BVarSymbol bVarSymbol,\n+                                          List<ValidationError> validationErrors, boolean isExitType,\n+                                          BUnionType resourceType) throws OpenApiValidatorException {\n+\n+        // Handle OneOf type\n+        if (schema instanceof ComposedSchema) {\n+            ComposedSchema composedSchema = (ComposedSchema) schema;\n+            if ((composedSchema.getOneOf() != null) && (resourceType.getMemberTypes() != null)) {\n+                List<Schema> oneOflist01 = composedSchema.getOneOf();\n+                Set<BType> memberList01 = new HashSet<>((resourceType.getMemberTypes()));\n+                List<BType> memberList = new ArrayList<>(memberList01);\n+                List<Schema> oneOflist = new ArrayList<>(oneOflist01);\n+\n+                //  Schema against to ballerina records\n+                isExitType = validateOneOfTypeResourceToOpenApi(bVarSymbol, validationErrors, isExitType, memberList,\n+                        oneOflist);\n+                if ((!(oneOflist.isEmpty())) && (memberList.isEmpty())) {\n+                    for (Schema oneOf : oneOflist) {\n+                        if (oneOf.getProperties() != null) {\n+                            Map<String, Schema> property = oneOf.getProperties();\n+                            List<ValidationError> validationErrorsOneOfSchema = new ArrayList<>();\n+                            for (Map.Entry<String, Schema> prop: property.entrySet()) {\n+\n+                                MissingFieldInBallerinaType missingFieldInBallerinaType =\n+                                        new MissingFieldInBallerinaType(prop.getKey(),\n+                                                convertTypeToEnum(prop.getValue().getType()));\n+\n+                                validationErrorsOneOfSchema.add(missingFieldInBallerinaType);\n+                            }\n+                            OneOfTypeValidation oneOfTypeValidation = new OneOfTypeValidation(\"OpenApi Schema\",\n+                                    Constants.Type.OBJECT, validationErrorsOneOfSchema);\n+                            validationErrors.add(oneOfTypeValidation);\n+                        }\n+                    }\n+                }\n+                //  Handle Record against the schema\n+                if (!(memberList.isEmpty())) {\n+                    validateOneOfTypeOpenApiToResource(bVarSymbol, validationErrors, isExitType, memberList, oneOflist);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Validate OneOfType openApi against resource parameter.\n+     * @param bVarSymbol            parameter bVarSymbol\n+     * @param validationErrors      list of ValidationErrors\n+     * @param isExitType            tag for track the availability of parameter\n+     * @param memberList            list of resources for validating\n+     * @param oneOflist             list of operations for validating\n+     * @throws OpenApiValidatorException\n+     */\n+    private static void validateOneOfTypeOpenApiToResource(BVarSymbol bVarSymbol,\n+                                                           List<ValidationError> validationErrors, boolean isExitType,\n+                                                           List<BType> memberList, List<Schema> oneOflist)\n+            throws OpenApiValidatorException {\n+\n+        List<ValidationError> validationErrorsBa =  new ArrayList<>();\n+        for (BType member: memberList) {\n+            //  Handle record type\n+            if (member instanceof BRecordType) {\n+                isExitType = true;\n+                validateOneOftypeRecord(validationErrors, oneOflist, validationErrorsBa, member);\n+                //  Handle primitive type\n+            } else if (!(member instanceof BAnyType)) {\n+                for (Schema schema2: oneOflist) {\n+                    isExitType = member.tsymbol.type.toString().\n+                                    equals(convertOpenAPITypeToBallerina(schema2.getType()));\n+                    if (isExitType) {\n+                        break;\n+                    }\n+                }\n+                if (!isExitType) {\n+                    TypeMismatch typeMismatch = new TypeMismatch(bVarSymbol.name.toString(), null,\n+                            convertTypeToEnum(member.getKind().typeName()));\n+                    validationErrors.add(typeMismatch);\n+                }\n+            } else {\n+                isExitType = true;\n+            }\n+        }\n+        //   Missing fields in ballerina errors checking\n+        if (!(validationErrorsBa.isEmpty())) {\n+            OneOfTypeValidation oneOfTypeValidation = new OneOfTypeValidation(\"Ballerina records\",\n+                            Constants.Type.RECORD, validationErrorsBa);\n+            validationErrors.add(oneOfTypeValidation);\n+        }\n+    }\n+\n+    /**\n+     * Validate record type oneOf parameters.\n+     * @param validationErrors      list for validation errors\n+     * @param oneOflist             list with operations for validating\n+     * @param validationErrorsBa    list for service side validation errors\n+     * @param member                BType for parameter\n+     * @throws OpenApiValidatorException\n+     */\n+    private static void validateOneOftypeRecord(List<ValidationError> validationErrors, List<Schema> oneOflist,\n+                                                List<ValidationError> validationErrorsBa, BType member)\n+            throws OpenApiValidatorException {\n+\n+        if ((!(oneOflist.isEmpty())) && member instanceof BRecordType) {\n+            Iterator<Schema> oneOfSchema = oneOflist.iterator();\n+            while (oneOfSchema.hasNext()) {\n+                Schema schema2 = oneOfSchema.next();\n+                if (schema2.getProperties() != null) {\n+                    validateRecord(validationErrorsBa, schema2.getProperties(), (BRecordType) member);\n+                }\n+                if (!(validationErrorsBa.isEmpty())) {\n+                    List<String> errorFields = new ArrayList<>();\n+                    List<ValidationError> errorValidation = new ArrayList<>();\n+                    for (ValidationError validationError: validationErrorsBa) {\n+                        if (validationError instanceof MissingFieldInJsonSchema) {\n+                            errorFields.add(validationError.getFieldName());\n+                            errorValidation.add(validationError);\n+                        }\n+                    }\n+                    List<String> recordFields = getRecordFields((BRecordType) member);\n+                    if (errorFields.containsAll(recordFields)) {\n+                        OneOfTypeValidation oneOfTypeValidation =\n+                                new OneOfTypeValidation(getRecordName(member.toString()),\n+                                        Constants.Type.RECORD, errorValidation);\n+                        validationErrors.add(oneOfTypeValidation);\n+                        validationErrorsBa.clear();\n+                        break;\n+                    }\n+                }\n+            }\n+        } else {\n+            List<ValidationError> validationErrorslist1 = new ArrayList<>();\n+            OneOfTypeValidation oneOfTypeValidation = new OneOfTypeValidation(getRecordName(member.toString())\n+                            , Constants.Type.RECORD, validationErrorslist1);\n+            validationErrors.add(oneOfTypeValidation);\n+        }\n+    }\n+\n+    /**\n+     * Validate OneOf type resource to openApi.\n+     * @param bVarSymbol            validate resource parameter BVarSymbol\n+     * @param validationErrors      list of ValidationErrors\n+     * @param isExitType            tag for check the parameter exit\n+     * @param memberList            list of resource parameters\n+     * @param oneOflist             list of operations parameters\n+     * @return\n+     * @throws OpenApiValidatorException\n+     */\n+    private static boolean validateOneOfTypeResourceToOpenApi(BVarSymbol bVarSymbol,\n+                                                              List<ValidationError> validationErrors,\n+                                                              boolean isExitType, List<BType> memberList,\n+                                                              List<Schema> oneOflist) throws OpenApiValidatorException {\n+\n+        Iterator<Schema> iterator = oneOflist.iterator();\n+        while (iterator.hasNext()) {\n+            List<ValidationError> misFieldBallerina = new ArrayList<>();\n+            Schema<?> schema1 = iterator.next();\n+            Iterator<BType> memberIterator = memberList.iterator();\n+            while (memberIterator.hasNext()) {\n+                isExitType = true;\n+                BType member = memberIterator.next();\n+                if (member instanceof BRecordType) {\n+                    //  Record validation\n+                    List<ValidationError> validationErrorListForRecords = new ArrayList<>();\n+                    validateRecord(validationErrorListForRecords, schema1.getProperties(),\n+                            (BRecordType) member);\n+                    if (validationErrorListForRecords.isEmpty()) {\n+                        misFieldBallerina.clear();\n+                        memberIterator.remove();\n+                        iterator.remove();\n+                        break;\n+                    } else {\n+                        //  Check the given error fields are same as the given schema fields\n+                        if (validationErrorListForRecords.stream().allMatch(item -> item instanceof TypeMismatch)) {\n+\n+                            OneOfTypeValidation oneOfTypeValidation =\n+                                    new OneOfTypeValidation(getRecordName(member.toString()),\n+                                            Constants.Type.RECORD, validationErrorListForRecords);\n+                            validationErrors.add(oneOfTypeValidation);\n+                            memberIterator.remove();\n+                            iterator.remove();\n+\n+                        } else if (validationErrorListForRecords.stream().allMatch(item -> item instanceof\n+                                MissingFieldInBallerinaType)) {\n+                            misFieldBallerina.addAll(validationErrorListForRecords);\n+                        }\n+                    }\n+                } else if (!(member instanceof BAnyType)) {\n+                    //  Handle primitive data type\n+                    isExitType = member.tsymbol.type.toString().\n+                            equals(convertOpenAPITypeToBallerina(schema1.getType()));\n+                    if (isExitType) {\n+                        break;\n+                    }\n+                } else {\n+                    memberIterator.remove();\n+                }\n+            }\n+            //  Handle Schema that not in ballerina resource\n+            if ((!misFieldBallerina.isEmpty()) && (misFieldBallerina.stream().\n+                    allMatch(item -> item instanceof MissingFieldInBallerinaType))) {\n+                    OneOfTypeValidation oneOfTypeValidation = new OneOfTypeValidation(\"Schema object\",\n+                                    Constants.Type.OBJECT, misFieldBallerina);\n+                    validationErrors.add(oneOfTypeValidation);\n+            }\n+            if (!isExitType) {\n+                TypeMismatch typeMismatch = new TypeMismatch(bVarSymbol.name.toString(),\n+                        convertTypeToEnum(schema1.getType()), null);\n+                validationErrors.add(typeMismatch);\n+            }\n+        }\n+        return isExitType;\n+    }\n+\n+    /**\n+     * Validate Array type data.\n+     * @param schema            schema to use validate\n+     * @param bVarSymbol        bVarSymbol for parameter to validate\n+     * @param validationErrors  list for validationErrors\n+     * @param resourceType      bType for parameter\n+     * @throws OpenApiValidatorException\n+     */\n+    private static void validateArray(Schema<?> schema, BVarSymbol bVarSymbol, List<ValidationError> validationErrors,\n+                                      BType resourceType) throws OpenApiValidatorException {\n+\n+        BArrayType bArrayType = null;\n+        ArraySchema arraySchema = new ArraySchema();\n+        if (schema instanceof ArraySchema) {\n+            arraySchema = (ArraySchema) schema;\n+        }\n+        if (resourceType instanceof BArrayType) {\n+            bArrayType = (BArrayType) resourceType;\n+        }\n+        BArrayType traversNestedArray = bArrayType;\n+        ArraySchema traversSchemaNestedArray = arraySchema;\n+        // Handle nested array type\n+        if (bArrayType != null) {\n+            BType bArrayTypeEtype = bArrayType.eType;\n+            Schema arraySchemaItems = arraySchema.getItems();\n+            if ((bArrayTypeEtype instanceof BArrayType) && (arraySchemaItems instanceof ArraySchema)) {\n+                traversNestedArray = (BArrayType) bArrayTypeEtype;\n+                traversSchemaNestedArray = (ArraySchema) arraySchemaItems;\n+\n+                while ((traversNestedArray.eType instanceof BArrayType) &&\n+                        (traversSchemaNestedArray.getItems() instanceof ArraySchema)) {\n+                    Schema<?> traversSchemaNestedArraySchemaType = traversSchemaNestedArray.getItems();\n+                    if (traversSchemaNestedArraySchemaType instanceof ArraySchema) {\n+                        traversSchemaNestedArray = (ArraySchema) traversSchemaNestedArraySchemaType;\n+                    }\n+                    BType traversNestedArrayBType = traversNestedArray.eType;\n+                    if (traversNestedArrayBType instanceof BArrayType) {\n+                        traversNestedArray = (BArrayType) traversNestedArrayBType;\n+                    }\n+                }\n+            }\n+            //   Handle record type array\n+            validateRecordTypeArray(bVarSymbol, validationErrors, traversNestedArray, traversSchemaNestedArray);\n+        }\n+    }\n+\n+    /**\n+     * Handle array item type with record type.\n+     * @param bVarSymbol                bVarSymbol for parameter\n+     * @param validationErrors          list with validation errors\n+     * @param traversNestedArray        BArrayType parameter\n+     * @param traversSchemaNestedArray  ArraySchema with openApi parameter\n+     * @throws OpenApiValidatorException\n+     */\n+    private static void validateRecordTypeArray(BVarSymbol bVarSymbol, List<ValidationError> validationErrors,\n+                                                BArrayType traversNestedArray, ArraySchema traversSchemaNestedArray)\n+            throws OpenApiValidatorException {\n+\n+        if ((traversNestedArray.eType instanceof BRecordType) && traversSchemaNestedArray.getItems() != null) {\n+            if ((traversNestedArray.eType.tsymbol.type instanceof BRecordType) &&\n+                    traversSchemaNestedArray.getItems() instanceof ObjectSchema) {\n+                Schema schema2 = traversSchemaNestedArray.getItems();\n+                List<ValidationError> nestedRecordValidation = BTypeToJsonValidatorUtil.validate(schema2, bVarSymbol);\n+                validationErrors.addAll(nestedRecordValidation);\n+            }\n+        } else if (!traversNestedArray.eType.tsymbol.toString().equals(BTypeToJsonValidatorUtil\n+                .convertOpenAPITypeToBallerina(traversSchemaNestedArray.getItems().getType()))) {\n+            TypeMismatch validationError = new TypeMismatch(bVarSymbol.name.getValue(),\n+                    convertTypeToEnum(traversSchemaNestedArray.getItems().getType()),\n+                    convertTypeToEnum(traversNestedArray.eType.tsymbol.toString()));\n+            validationErrors.add(validationError);\n+        }\n+    }\n+\n+    /**\n+     * Validation with BRecordType parameter with Object schema.\n+     *\n+     * @param validationErrors  contain the validation errors\n+     * @param properties        extract properties with object schema\n+     * @param recordType        recordType\n+     * @return ValidationError type List\n+     * @throws OpenApiValidatorException\n+     */\n+    private static List<ValidationError> validateRecord(List<ValidationError> validationErrors,\n+                                                        Map<String, Schema> properties,\n+                                                        BRecordType recordType) throws OpenApiValidatorException {\n+        //  BType record against the schema\n+        for (Map.Entry<String, BField> field : recordType.fields.entrySet()) {\n+            boolean isExist = false;\n+            for (Map.Entry<String, Schema> entry : properties.entrySet()) {\n+                if ((entry.getKey().equals(field.getValue().name.getValue())) && (entry.getValue().getType() != null)) {\n+                    isExist = true;\n+                    if (!field.getValue().getType().getKind().typeName()\n+                            .equals(BTypeToJsonValidatorUtil.convertOpenAPITypeToBallerina(entry.getValue()\n+                                    .getType()))) {\n+\n+                        TypeMismatch validationError = new TypeMismatch(field.getValue().name.getValue(),\n+                                convertTypeToEnum(entry.getValue().getType()),\n+                                convertTypeToEnum(field.getValue().getType().getKind().typeName()),\n+                                getRecordName(recordType.toString()));\n+\n+                        validationErrors.add(validationError);\n+\n+                    } else if (entry.getValue() instanceof ObjectSchema) {\n+                        //  Handle the nested record type\n+                        validateNestedRecord(validationErrors, recordType, field, entry);\n+                    } else {\n+                        //  Handle array type mismatching.\n+                        if (field.getValue().getType().getKind().typeName().equals(\"[]\")) {\n+                            BArrayType bArrayType = null;\n+                            Schema entrySchema = entry.getValue();\n+                            ArraySchema arraySchema = new ArraySchema();\n+                            if ((field.getValue().type instanceof BArrayType) && (entrySchema instanceof ArraySchema)) {\n+                                bArrayType = (BArrayType) field.getValue().type;\n+                                arraySchema = (ArraySchema) entrySchema;\n+                            }\n+                            if (bArrayType != null) {\n+                                BArrayType traversNestedArray = bArrayType;\n+                                ArraySchema traversSchemaNestedArray = arraySchema;\n+                                //  Handle nested array type\n+                                if ((bArrayType.eType instanceof BArrayType) &&\n+                                        (arraySchema.getItems() instanceof ArraySchema)) {\n+                                    Schema traversSchemaNestedArraySchemaType = arraySchema.getItems();\n+                                    traversNestedArray = (BArrayType) bArrayType.eType;\n+\n+                                    if (traversSchemaNestedArraySchemaType instanceof ArraySchema) {\n+                                        traversSchemaNestedArray = (ArraySchema) traversSchemaNestedArraySchemaType;\n+                                    }\n+                                    while ((traversNestedArray.eType instanceof BArrayType) &&\n+                                            (traversSchemaNestedArray.getItems() instanceof ArraySchema)) {\n+                                        Schema<?> traversSchemaNestedArraySchema = traversSchemaNestedArray.getItems();\n+                                        BType traversNestedArrayBtype = traversNestedArray.eType;\n+\n+                                        if ((traversSchemaNestedArraySchema instanceof ArraySchema) &&\n+                                                (traversNestedArrayBtype instanceof BArrayType)) {\n+                                            traversSchemaNestedArray = (ArraySchema) traversSchemaNestedArraySchema;\n+                                            traversNestedArray = (BArrayType) traversNestedArrayBtype;\n+                                        }\n+                                    }\n+                                }\n+                                //  Handle record type in item array\n+                                if ((traversNestedArray.eType instanceof BRecordType) &&", "originalCommit": "aa43cd0d05bf24efa178f88601f65de03465d24b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc5NzI3Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25286#discussion_r472797277", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    if ((param instanceof PathParameter) && (param.getName().equals(resourceParam.getName()))) {\n          \n          \n            \n                                    if (param instanceof PathParameter && param.getName().equals(resourceParam.getName())) {", "author": "suganyasuven", "createdAt": "2020-08-19T07:21:07Z", "path": "misc/openapi-ballerina/modules/openapi-validator/src/main/java/org/ballerinalang/openapi/validator/ResourceValidator.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.openapi.validator;\n+\n+import io.swagger.v3.oas.models.Operation;\n+import io.swagger.v3.oas.models.media.Content;\n+import io.swagger.v3.oas.models.media.MediaType;\n+import io.swagger.v3.oas.models.media.Schema;\n+import io.swagger.v3.oas.models.parameters.Parameter;\n+import io.swagger.v3.oas.models.parameters.PathParameter;\n+import io.swagger.v3.oas.models.parameters.QueryParameter;\n+import io.swagger.v3.oas.models.parameters.RequestBody;\n+import org.ballerinalang.openapi.validator.error.MissingFieldInBallerinaType;\n+import org.ballerinalang.openapi.validator.error.MissingFieldInJsonSchema;\n+import org.ballerinalang.openapi.validator.error.OneOfTypeValidation;\n+import org.ballerinalang.openapi.validator.error.TypeMismatch;\n+import org.ballerinalang.openapi.validator.error.ValidationError;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * This util is checking the availability of services and the operations in contract and ballerina file.\n+ */\n+public class ResourceValidator {\n+\n+    /**\n+     * Validate the missing fields in openapi operation according to resource service.\n+     * @param operation         openAPi operation\n+     * @param resourceMethod    validate resourceMethods\n+     * @return                  list of validationErrors\n+     * @throws OpenApiValidatorException\n+     */\n+    public static List<ValidationError> validateResourceAgainstOperation(Operation operation,\n+                                                                         ResourceMethod resourceMethod)\n+            throws OpenApiValidatorException {\n+\n+        List<ValidationError> validationErrors = new ArrayList<>();\n+        if (!resourceMethod.getParamNames().isEmpty()) {\n+            for (ResourceParameter resourceParameter: resourceMethod.getParamNames()) {\n+                Boolean isParameterExit = false;\n+                //  Handle the requestBody parameter\n+                if ((resourceMethod.getBody() != null) && (resourceMethod.getBody().equals(resourceParameter.getName()))\n+                        && (operation.getRequestBody() != null)) {\n+                        RequestBody requestBody = operation.getRequestBody();\n+                    isParameterExit =\n+                            validateRequestBodyResourceToOpenApi(operation, validationErrors, resourceParameter,\n+                                    isParameterExit, requestBody);\n+\n+                    //  Handle Path parameter\n+                } else if (operation.getParameters() != null) {\n+                    for (Parameter parameter : operation.getParameters()) {\n+                        if (resourceParameter.getName().equals(parameter.getName()) &&\n+                                (parameter.getSchema() != null)) {\n+                            isParameterExit = true;\n+                            List<ValidationError> validationErrorsResource =\n+                                    BTypeToJsonValidatorUtil.validate(parameter.getSchema(),\n+                                            resourceParameter.getParameter().symbol);\n+                            if (!validationErrorsResource.isEmpty()) {\n+                                validationErrors.addAll(validationErrorsResource);\n+                            }\n+                            break;\n+                        }\n+                    }\n+                }\n+                if (!isParameterExit) {\n+                    ValidationError validationError = new ValidationError(resourceParameter.getName(),\n+                            BTypeToJsonValidatorUtil.convertTypeToEnum(resourceParameter.getType()));\n+                    validationErrors.add(validationError);\n+                }\n+            }\n+        }\n+        return validationErrors;\n+    }\n+\n+    /**\n+     * Validate request Body parameters in resource against to openAPI.\n+     * @param operation             validate openApi operation\n+     * @param validationErrors      list of validationErrors\n+     * @param resourceParameter     validate resource parameter\n+     * @param isParameterExit       boolean tag for checking parameter is available\n+     * @param requestBody           requestBody type  operation parameter\n+     * @return  boolean value for indicating parameter is available\n+     * @throws OpenApiValidatorException\n+     */\n+    private static Boolean validateRequestBodyResourceToOpenApi(Operation operation,\n+                                                                List<ValidationError> validationErrors,\n+                                                                ResourceParameter resourceParameter,\n+                                                                Boolean isParameterExit, RequestBody requestBody)\n+            throws OpenApiValidatorException {\n+\n+        if ((requestBody.getContent() != null) && !getOperationRequestBody(operation).isEmpty()) {\n+            Map<String, Schema> requestBodySchemas = getOperationRequestBody(operation);\n+                for (Map.Entry<String, Schema> requestBodyOperation: requestBodySchemas.entrySet()) {\n+                    List<ValidationError> requestBValidationError  =\n+                            BTypeToJsonValidatorUtil.validate(requestBodyOperation.getValue(),\n+                                    resourceParameter.getParameter().symbol);\n+                    if (!requestBValidationError.isEmpty()) {\n+                        for (ValidationError validationError : requestBValidationError) {\n+                            if ((validationError instanceof TypeMismatch) ||\n+                                    (validationError instanceof MissingFieldInJsonSchema) ||\n+                                    (validationError instanceof OneOfTypeValidation)) {\n+                                validationErrors.add(validationError);\n+                            }\n+                        }\n+                    }\n+                    isParameterExit = true;\n+                    break;\n+                }\n+        }\n+        return isParameterExit;\n+    }\n+\n+    /**\n+     * Get the requestBody parameter from operation.\n+     * @param operation     openApi operation object\n+     * @return Map with parameters\n+     */\n+    public static Map<String, Schema> getOperationRequestBody(Operation operation) {\n+        Map<String, Schema> requestBodySchemas = new HashMap<>();\n+        Content content = operation.getRequestBody().getContent();\n+        for (Map.Entry<String, MediaType> mediaTypeEntry : content.entrySet()) {\n+            requestBodySchemas.put(mediaTypeEntry.getKey(), mediaTypeEntry.getValue().getSchema());\n+        }\n+        return requestBodySchemas;\n+    }\n+\n+    /**\n+     * Validate the missing fields in resource parameter according to given operation.\n+     * @param operation         openApi operation\n+     * @param resourceMethod    resource method object\n+     * @return                  list of ValidationErrors\n+     * @throws OpenApiValidatorException\n+     */\n+    public static List<ValidationError> validateOperationAgainstResource(Operation operation,\n+                                                                         ResourceMethod resourceMethod)\n+            throws OpenApiValidatorException {\n+        List<ValidationError> validationErrorList = new ArrayList<>();\n+        // Handle path , query parameters\n+        if (operation.getParameters() != null) {\n+            List<Parameter> operationParam = operation.getParameters();\n+            for (Parameter param : operationParam) {\n+                Boolean isOParamExit = false;\n+                // Temporary solution for skipping the query parameter, this if condition can be removed when openApi\n+                // tool available with query parameter\n+                if (param instanceof QueryParameter) {\n+                    isOParamExit = true;\n+                }\n+                if (!resourceMethod.getParamNames().isEmpty()) {\n+                    for (ResourceParameter resourceParam: resourceMethod.getParamNames()) {\n+                        //  Check whether it is path parameter\n+                        if ((param instanceof PathParameter) && (param.getName().equals(resourceParam.getName()))) {", "originalCommit": "aa43cd0d05bf24efa178f88601f65de03465d24b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fec0cdf1d11223e7da511bba79c537cb4b001889", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fec0cdf1d11223e7da511bba79c537cb4b001889", "message": "OpenApi Validator Refactor", "committedDate": "2020-08-21T03:53:20Z", "type": "commit"}, {"oid": "408044f5f59a8c3614e5914f49df9735ebef6521", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/408044f5f59a8c3614e5914f49df9735ebef6521", "message": "Change bRecord field iterator with map type", "committedDate": "2020-08-21T03:53:20Z", "type": "commit"}, {"oid": "1d06c9c7934ade26758c2f64e511282b2fd753f1", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1d06c9c7934ade26758c2f64e511282b2fd753f1", "message": "Remove OpenAPIComponentSummary.java", "committedDate": "2020-08-21T03:53:20Z", "type": "commit"}, {"oid": "2f154fe57018b973afdbe6f210b29424293ffa34", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2f154fe57018b973afdbe6f210b29424293ffa34", "message": "Add comments", "committedDate": "2020-08-21T03:53:20Z", "type": "commit"}, {"oid": "1abcf5e230f995c5c858e4377d828c1852810a29", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1abcf5e230f995c5c858e4377d828c1852810a29", "message": "Add new lines in bal files", "committedDate": "2020-08-21T03:53:20Z", "type": "commit"}, {"oid": "2300864f64eb157de1a764218ef9f07e9875a1d7", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2300864f64eb157de1a764218ef9f07e9875a1d7", "message": "Add test ServiceValidationTests", "committedDate": "2020-08-21T03:53:20Z", "type": "commit"}, {"oid": "9c9aeea36e8fb302cee93f1f7985a38023fbc46f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9c9aeea36e8fb302cee93f1f7985a38023fbc46f", "message": "Remove new lines", "committedDate": "2020-08-21T03:53:20Z", "type": "commit"}, {"oid": "2bdd45c2deca3ca1161bec64ed6693c72c941f3f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2bdd45c2deca3ca1161bec64ed6693c72c941f3f", "message": "Fix indentation issues in comments", "committedDate": "2020-08-21T03:53:20Z", "type": "commit"}, {"oid": "d392e02118c3f61f213bbf159bfc0c139d3d3ce9", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d392e02118c3f61f213bbf159bfc0c139d3d3ce9", "message": "Rename validateWhatMissingResource into validateResourceAgainstOperation", "committedDate": "2020-08-21T03:53:20Z", "type": "commit"}, {"oid": "1e6c9869918101993033f9c07e86f5f9663a437c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1e6c9869918101993033f9c07e86f5f9663a437c", "message": "Rename validateWhatMissingService into validateOperationAgainstResource", "committedDate": "2020-08-21T03:53:20Z", "type": "commit"}, {"oid": "4c0eb4d9ff5e00a092514748fa42a2cd13f78a44", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4c0eb4d9ff5e00a092514748fa42a2cd13f78a44", "message": "Refactor BTypeToJsonValidatorUtil.java file", "committedDate": "2020-08-21T03:53:20Z", "type": "commit"}, {"oid": "9d10325c8b4b6b1bd039536c074114ee5be5b670", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9d10325c8b4b6b1bd039536c074114ee5be5b670", "message": "Refactor ResourceValidator file", "committedDate": "2020-08-21T03:53:20Z", "type": "commit"}, {"oid": "6323c5b6e41bd3bc4372b89dff76bee7f05729e5", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6323c5b6e41bd3bc4372b89dff76bee7f05729e5", "message": "Refactor BTypeToJsonValidatorUtil file", "committedDate": "2020-08-21T03:53:21Z", "type": "commit"}, {"oid": "fdc87f12a476133b68a01b36ea9c692492611926", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fdc87f12a476133b68a01b36ea9c692492611926", "message": "Refactor ServiceValidator file", "committedDate": "2020-08-21T03:53:21Z", "type": "commit"}, {"oid": "8d2b0971a9b257bab604f5e87a41bb352f7096ed", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8d2b0971a9b257bab604f5e87a41bb352f7096ed", "message": "Refactor ServiceValidator file", "committedDate": "2020-08-21T03:53:21Z", "type": "commit"}, {"oid": "02ad251c897d453fcb44bf1a6c8bf9976889f5e8", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/02ad251c897d453fcb44bf1a6c8bf9976889f5e8", "message": "Add license at header", "committedDate": "2020-08-21T03:53:21Z", "type": "commit"}, {"oid": "27338e3dfc119e6de11ac15acbf718162c3a472e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/27338e3dfc119e6de11ac15acbf718162c3a472e", "message": "Fix checkStyle", "committedDate": "2020-08-21T03:53:21Z", "type": "commit"}, {"oid": "c87f77875efa56933a3c1cc01e85d3601e6db794", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c87f77875efa56933a3c1cc01e85d3601e6db794", "message": "Remove new line", "committedDate": "2020-08-21T03:53:21Z", "type": "commit"}, {"oid": "a9b35855ef7153a8cec3f892387a6bace0bd6dda", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a9b35855ef7153a8cec3f892387a6bace0bd6dda", "message": "Change variable names", "committedDate": "2020-08-21T03:53:21Z", "type": "commit"}, {"oid": "c6727b17ea6c9968f5b01c5522a40fc3ce09fa83", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c6727b17ea6c9968f5b01c5522a40fc3ce09fa83", "message": "Add licenses header", "committedDate": "2020-08-21T03:53:21Z", "type": "commit"}, {"oid": "22ff63b763778d8d03f41634bbdff2cf7a1974b7", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/22ff63b763778d8d03f41634bbdff2cf7a1974b7", "message": "Merge possible if conditions", "committedDate": "2020-08-21T03:53:21Z", "type": "commit"}, {"oid": "311020cbeebba5214c3b32212e9f78704d61812d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/311020cbeebba5214c3b32212e9f78704d61812d", "message": "Fix review suggestions", "committedDate": "2020-08-21T03:53:21Z", "type": "commit"}, {"oid": "81fdee4d8ddf809e25bc16e866cab9d585b7ec81", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/81fdee4d8ddf809e25bc16e866cab9d585b7ec81", "message": "Change class name MatchResourceWithOperationId into ResourceWithOperationId", "committedDate": "2020-08-21T03:53:21Z", "type": "commit"}, {"oid": "575a934c0b61af0bf35a5c6b7eef938dd1da71c0", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/575a934c0b61af0bf35a5c6b7eef938dd1da71c0", "message": "Fix review suggestions", "committedDate": "2020-08-21T03:53:21Z", "type": "commit"}, {"oid": "bdd50041ecffe2a3bb5c1804b938b2b91372825b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bdd50041ecffe2a3bb5c1804b938b2b91372825b", "message": "Fix review suggestions", "committedDate": "2020-08-21T03:53:21Z", "type": "commit"}, {"oid": "8fc82e9d7b8db67ef151f7138147a6a23f2e25a3", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8fc82e9d7b8db67ef151f7138147a6a23f2e25a3", "message": "Fix review suggestions", "committedDate": "2020-08-21T03:53:21Z", "type": "commit"}, {"oid": "28a38c3eb3888037a1d6a312553981ab2b60369f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/28a38c3eb3888037a1d6a312553981ab2b60369f", "message": "Fix review suggestions", "committedDate": "2020-08-21T03:53:21Z", "type": "commit"}, {"oid": "1be7119252c7d2932c095249a6018cd12f92b62d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1be7119252c7d2932c095249a6018cd12f92b62d", "message": "Fix review suggestions", "committedDate": "2020-08-21T03:53:22Z", "type": "commit"}, {"oid": "e6dcff87e68d3950e9e012ceda2c23491692dd43", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e6dcff87e68d3950e9e012ceda2c23491692dd43", "message": "Fix tests failure", "committedDate": "2020-08-21T03:53:22Z", "type": "commit"}, {"oid": "ee995fdef752c9a3013f00a4a3f968a492a6cef6", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ee995fdef752c9a3013f00a4a3f968a492a6cef6", "message": "Fix openapi language-server-core-tests fail", "committedDate": "2020-08-21T03:53:22Z", "type": "commit"}, {"oid": "ee995fdef752c9a3013f00a4a3f968a492a6cef6", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ee995fdef752c9a3013f00a4a3f968a492a6cef6", "message": "Fix openapi language-server-core-tests fail", "committedDate": "2020-08-21T03:53:22Z", "type": "forcePushed"}, {"oid": "c3228ccbda0fff1f17a6cb5b481c7d6fdc29fe2b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c3228ccbda0fff1f17a6cb5b481c7d6fdc29fe2b", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into swanlake_master", "committedDate": "2020-08-21T04:00:20Z", "type": "commit"}, {"oid": "a9c23c7d55ad3c1d6a35663d27a96816c3aaff08", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a9c23c7d55ad3c1d6a35663d27a96816c3aaff08", "message": "Remove unnecessary dependencies", "committedDate": "2020-08-28T04:38:51Z", "type": "commit"}, {"oid": "1039b2d4a3fc42b8ebaca5e521d4943ebc01da67", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1039b2d4a3fc42b8ebaca5e521d4943ebc01da67", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into swanlake_master", "committedDate": "2020-08-28T04:39:23Z", "type": "commit"}]}