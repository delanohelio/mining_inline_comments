{"pr_number": 24406, "pr_title": "Fix xml to json ballerina swl", "pr_createdAt": "2020-06-22T10:54:25Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/24406", "timeline": [{"oid": "bbe80fcfe19ff804952381c7fa01536f4d273f9b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bbe80fcfe19ff804952381c7fa01536f4d273f9b", "message": "Port XmlToJsonConverter to master branch from 1.2", "committedDate": "2020-06-22T06:06:22Z", "type": "commit"}, {"oid": "7c61e41decee30f8969f41878fd3e6ac9161e7b1", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7c61e41decee30f8969f41878fd3e6ac9161e7b1", "message": "Fix unit test due to xm namespace\n\ndifference between master and 1.2.x track", "committedDate": "2020-06-22T07:27:01Z", "type": "commit"}, {"oid": "20ef296c95e5e9fdca87fcda41d04b7614b76f2f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/20ef296c95e5e9fdca87fcda41d04b7614b76f2f", "message": "Fix checkstyle issues", "committedDate": "2020-06-22T11:37:19Z", "type": "commit"}, {"oid": "ce4f130cdd5e5b42e86da6f6cee30cade1e47ff4", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ce4f130cdd5e5b42e86da6f6cee30cade1e47ff4", "message": "Add test cases involving BString", "committedDate": "2020-06-23T04:19:48Z", "type": "commit"}, {"oid": "5a18edc2c108ad74bb2e831996766ae34580180f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5a18edc2c108ad74bb2e831996766ae34580180f", "message": "Improve xml element conversion\n\nwhen element doesn't have any children", "committedDate": "2020-07-06T09:23:37Z", "type": "commit"}, {"oid": "655f00c9576e041b18a3da09c3723347f2a3c9a2", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/655f00c9576e041b18a3da09c3723347f2a3c9a2", "message": "Uncomment tableToJsonTest", "committedDate": "2020-07-06T09:38:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDM1MzAyNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24406#discussion_r454353026", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return  XmlToJsonConverter.convertToJSON(xml, attributePrefix, preserveNamespaces);\n          \n          \n            \n                        return XmlToJsonConverter.convertToJSON(xml, attributePrefix, preserveNamespaces);", "author": "MaryamZi", "createdAt": "2020-07-14T13:24:30Z", "path": "stdlib/jsonutils/src/main/java/org/ballerinalang/stdlib/jsonutils/FromXML.java", "diffHunk": "@@ -41,7 +40,7 @@ public static Object fromXML(XMLValue xml, MapValue<?, ?> options) {\n             String attributePrefix = ((BString) options.get(StringUtils.fromString(OPTIONS_ATTRIBUTE_PREFIX)))\n                     .getValue();\n             boolean preserveNamespaces = ((Boolean) options.get(StringUtils.fromString(OPTIONS_PRESERVE_NS)));\n-            return XMLFactory.convertToJSON(xml, attributePrefix, preserveNamespaces);\n+            return  XmlToJsonConverter.convertToJSON(xml, attributePrefix, preserveNamespaces);", "originalCommit": "655f00c9576e041b18a3da09c3723347f2a3c9a2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDUxMzUxNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24406#discussion_r454513515", "bodyText": "Can't we continue to use the node type instead of the instanceof check?", "author": "MaryamZi", "createdAt": "2020-07-14T17:14:16Z", "path": "stdlib/jsonutils/src/main/java/org/ballerinalang/stdlib/jsonutils/XmlToJsonConverter.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.stdlib.jsonutils;\n+\n+import org.ballerinalang.jvm.JSONParser;\n+import org.ballerinalang.jvm.XMLNodeType;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BPackage;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeConstants;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.XMLItem;\n+import org.ballerinalang.jvm.values.XMLSequence;\n+import org.ballerinalang.jvm.values.XMLText;\n+import org.ballerinalang.jvm.values.XMLValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.jvm.values.api.BXML;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.namespace.QName;\n+\n+import static org.ballerinalang.jvm.StringUtils.fromString;\n+\n+/**\n+ * Convert Ballerina XML value into respective JSON value.\n+ * @since 1.2.5\n+ */\n+public class XmlToJsonConverter {\n+\n+    private static final String XML_NAMESPACE_PREFIX_FRAGMENT = \"xmlns:\";\n+\n+    private static final BType jsonMapType =\n+            new BMapType(TypeConstants.MAP_TNAME, BTypes.typeJSON, new BPackage(null, null, null));\n+    private static final String XMLNS = \"xmlns\";\n+\n+    /**\n+     * Converts given xml object to the corresponding JSON value.\n+     *\n+     * @param xml                XML object to get the corresponding json\n+     * @param attributePrefix    Prefix to use in attributes\n+     * @param preserveNamespaces preserve the namespaces when converting\n+     * @return JSON representation of the given xml object\n+     */\n+    public static Object convertToJSON(XMLValue xml, String attributePrefix, boolean preserveNamespaces) {\n+        if (xml instanceof XMLText) {", "originalCommit": "655f00c9576e041b18a3da09c3723347f2a3c9a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIwNjE2Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24406#discussion_r456206163", "bodyText": "I was trying to handle the null, xml processing instruction, xml comment in the last return.\nMaybe having a switch case will make my intension more clear, will update this", "author": "rdhananjaya", "createdAt": "2020-07-17T04:03:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDUxMzUxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgzMDE3OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24406#discussion_r457830179", "bodyText": "Changed to XMLNodeType and SpotBug doesn't like that, reverting back to instanceof.", "author": "rdhananjaya", "createdAt": "2020-07-21T04:33:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDUxMzUxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDUyNDQwMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24406#discussion_r454524402", "bodyText": "Missing a new line after the previous method.", "author": "MaryamZi", "createdAt": "2020-07-14T17:31:36Z", "path": "stdlib/jsonutils/src/main/java/org/ballerinalang/stdlib/jsonutils/XmlToJsonConverter.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.stdlib.jsonutils;\n+\n+import org.ballerinalang.jvm.JSONParser;\n+import org.ballerinalang.jvm.XMLNodeType;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BPackage;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeConstants;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.XMLItem;\n+import org.ballerinalang.jvm.values.XMLSequence;\n+import org.ballerinalang.jvm.values.XMLText;\n+import org.ballerinalang.jvm.values.XMLValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.jvm.values.api.BXML;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.namespace.QName;\n+\n+import static org.ballerinalang.jvm.StringUtils.fromString;\n+\n+/**\n+ * Convert Ballerina XML value into respective JSON value.\n+ * @since 1.2.5\n+ */\n+public class XmlToJsonConverter {\n+\n+    private static final String XML_NAMESPACE_PREFIX_FRAGMENT = \"xmlns:\";\n+\n+    private static final BType jsonMapType =\n+            new BMapType(TypeConstants.MAP_TNAME, BTypes.typeJSON, new BPackage(null, null, null));\n+    private static final String XMLNS = \"xmlns\";\n+\n+    /**\n+     * Converts given xml object to the corresponding JSON value.\n+     *\n+     * @param xml                XML object to get the corresponding json\n+     * @param attributePrefix    Prefix to use in attributes\n+     * @param preserveNamespaces preserve the namespaces when converting\n+     * @return JSON representation of the given xml object\n+     */\n+    public static Object convertToJSON(XMLValue xml, String attributePrefix, boolean preserveNamespaces) {\n+        if (xml instanceof XMLText) {\n+            return JSONParser.parse(\"\\\"\" + ((XMLText) xml).stringValue() + \"\\\"\");\n+        } else if (xml instanceof XMLItem) {\n+            return convertElement((XMLItem) xml, attributePrefix, preserveNamespaces);\n+        } else if (xml instanceof XMLSequence) {\n+            XMLSequence xmlSequence = (XMLSequence) xml;\n+            if (xmlSequence.isEmpty()) {\n+                return newJsonList();\n+            }\n+            Object seq = convertXMLSequence(xmlSequence, attributePrefix, preserveNamespaces);\n+            if (seq == null) {\n+                return newJsonList();\n+            }\n+            return seq;\n+        }\n+        return newJsonMap();\n+    }\n+    /**", "originalCommit": "655f00c9576e041b18a3da09c3723347f2a3c9a2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU3ODcwNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24406#discussion_r454578704", "bodyText": "Shall we leave one new line here.", "author": "MaryamZi", "createdAt": "2020-07-14T19:03:46Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/XMLFactory.java", "diffHunk": "@@ -790,12 +432,10 @@ public static OMElement stringToOM(String xmlFragment) throws XMLStreamException\n     private static OMElement stringToOM(OMFactory omFactory, String xmlFragment) throws XMLStreamException {\n         return xmlFragment != null\n                 ? OMXMLBuilderFactory\n-                        .createOMBuilder(omFactory, STAX_PARSER_CONFIGURATION, new StringReader(xmlFragment))\n-                        .getDocumentElement()\n+                .createOMBuilder(omFactory, STAX_PARSER_CONFIGURATION, new StringReader(xmlFragment))\n+                .getDocumentElement()\n                 : null;\n     }\n-", "originalCommit": "655f00c9576e041b18a3da09c3723347f2a3c9a2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU3ODg2OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24406#discussion_r454578869", "bodyText": "Shall we keep the indentation?", "author": "MaryamZi", "createdAt": "2020-07-14T19:04:05Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/XMLFactory.java", "diffHunk": "@@ -790,12 +432,10 @@ public static OMElement stringToOM(String xmlFragment) throws XMLStreamException\n     private static OMElement stringToOM(OMFactory omFactory, String xmlFragment) throws XMLStreamException {\n         return xmlFragment != null\n                 ? OMXMLBuilderFactory\n-                        .createOMBuilder(omFactory, STAX_PARSER_CONFIGURATION, new StringReader(xmlFragment))\n-                        .getDocumentElement()", "originalCommit": "655f00c9576e041b18a3da09c3723347f2a3c9a2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU4Mjg5NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24406#discussion_r454582894", "bodyText": "Can we use a constant for the JSON array type similar to the map?", "author": "MaryamZi", "createdAt": "2020-07-14T19:11:23Z", "path": "stdlib/jsonutils/src/main/java/org/ballerinalang/stdlib/jsonutils/XmlToJsonConverter.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.stdlib.jsonutils;\n+\n+import org.ballerinalang.jvm.JSONParser;\n+import org.ballerinalang.jvm.XMLNodeType;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BPackage;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeConstants;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.XMLItem;\n+import org.ballerinalang.jvm.values.XMLSequence;\n+import org.ballerinalang.jvm.values.XMLText;\n+import org.ballerinalang.jvm.values.XMLValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.jvm.values.api.BXML;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.namespace.QName;\n+\n+import static org.ballerinalang.jvm.StringUtils.fromString;\n+\n+/**\n+ * Convert Ballerina XML value into respective JSON value.\n+ * @since 1.2.5\n+ */\n+public class XmlToJsonConverter {\n+\n+    private static final String XML_NAMESPACE_PREFIX_FRAGMENT = \"xmlns:\";\n+\n+    private static final BType jsonMapType =\n+            new BMapType(TypeConstants.MAP_TNAME, BTypes.typeJSON, new BPackage(null, null, null));\n+    private static final String XMLNS = \"xmlns\";\n+\n+    /**\n+     * Converts given xml object to the corresponding JSON value.\n+     *\n+     * @param xml                XML object to get the corresponding json\n+     * @param attributePrefix    Prefix to use in attributes\n+     * @param preserveNamespaces preserve the namespaces when converting\n+     * @return JSON representation of the given xml object\n+     */\n+    public static Object convertToJSON(XMLValue xml, String attributePrefix, boolean preserveNamespaces) {\n+        if (xml instanceof XMLText) {\n+            return JSONParser.parse(\"\\\"\" + ((XMLText) xml).stringValue() + \"\\\"\");\n+        } else if (xml instanceof XMLItem) {\n+            return convertElement((XMLItem) xml, attributePrefix, preserveNamespaces);\n+        } else if (xml instanceof XMLSequence) {\n+            XMLSequence xmlSequence = (XMLSequence) xml;\n+            if (xmlSequence.isEmpty()) {\n+                return newJsonList();\n+            }\n+            Object seq = convertXMLSequence(xmlSequence, attributePrefix, preserveNamespaces);\n+            if (seq == null) {\n+                return newJsonList();\n+            }\n+            return seq;\n+        }\n+        return newJsonMap();\n+    }\n+    /**\n+     * Converts given xml object to the corresponding json.\n+     *\n+     * @param xmlItem XML element to traverse\n+     * @param attributePrefix Prefix to use in attributes\n+     * @param preserveNamespaces preserve the namespaces when converting\n+     * @return ObjectNode Json object node corresponding to the given xml element\n+     */\n+    private static Object convertElement(XMLItem xmlItem, String attributePrefix,\n+                                         boolean preserveNamespaces) {\n+        MapValueImpl<BString, Object> rootNode = newJsonMap();\n+        LinkedHashMap<String, String> attributeMap = collectAttributesAndNamespaces(xmlItem, preserveNamespaces);\n+        String keyValue = getElementKey(xmlItem, preserveNamespaces);\n+        Object children = convertXMLSequence(xmlItem.getChildrenSeq(), attributePrefix, preserveNamespaces);\n+\n+        if (attributeMap.isEmpty() && children == null) {\n+            putAsBStrings(rootNode, keyValue, \"\");\n+            return rootNode;\n+        }\n+        if (children != null) {\n+            putAsBStrings(rootNode, keyValue, children);\n+        }\n+        if (!attributeMap.isEmpty()) {\n+            addAttributes(rootNode, attributePrefix, attributeMap);\n+        }\n+        return rootNode;\n+    }\n+\n+    private static void addAttributes(MapValueImpl<BString, Object> rootNode, String attributePrefix,\n+                                      LinkedHashMap<String, String> attributeMap) {\n+        for (Map.Entry<String, String> entry : attributeMap.entrySet()) {\n+            putAsBStrings(rootNode, attributePrefix + entry.getKey(), entry.getValue());\n+        }\n+    }\n+\n+    private static void putAsBStrings(MapValueImpl<BString, Object> map, String key, String value) {\n+        map.put(fromString(key), fromString(value));\n+    }\n+\n+    private static void putAsBStrings(MapValueImpl<BString, Object> map, String key, Object value) {\n+        map.put(fromString(key), value);\n+    }\n+\n+    /**\n+     * Converts given xml sequence to the corresponding json.\n+     *\n+     * @param xmlSequence XML sequence to traverse\n+     * @param attributePrefix Prefix to use in attributes\n+     * @param preserveNamespaces preserve the namespaces when converting\n+     * @return JsonNode Json node corresponding to the given xml sequence\n+     */\n+    private static Object convertXMLSequence(XMLSequence xmlSequence, String attributePrefix,\n+                                             boolean preserveNamespaces) {\n+        List<BXML> sequence = xmlSequence.getChildrenList();\n+        if (sequence.isEmpty()) {\n+            return null;\n+        }\n+\n+        switch (calculateMatchingJsonTypeForSequence(sequence)) {\n+            case SAME_KEY:\n+                return convertSequenceWithSameNamedElements(attributePrefix, preserveNamespaces, sequence);\n+            case ELEMENT_ONLY:\n+                return convertSequenceWithOnlyElements(attributePrefix, preserveNamespaces, sequence);\n+            default:\n+                return convertHeterogeneousSequence(attributePrefix, preserveNamespaces, sequence);\n+        }\n+    }\n+\n+    private static Object convertHeterogeneousSequence(String attributePrefix, boolean preserveNamespaces,\n+                                                       List<BXML> sequence) {\n+        if (sequence.size() == 1) {\n+            return convertToJSON((XMLValue) sequence.get(0), attributePrefix, preserveNamespaces);\n+        }\n+\n+        ArrayList<Object> list = new ArrayList<>();\n+        for (BXML bxml : sequence) {\n+            if (isCommentOrPi(bxml)) {\n+                continue;\n+            }\n+            list.add(convertToJSON((XMLValue) bxml, attributePrefix, preserveNamespaces));\n+        }\n+\n+        if (list.isEmpty()) {\n+            return null;\n+        }\n+        return newJsonListFrom(list);\n+    }\n+\n+    private static Object convertSequenceWithOnlyElements(String attributePrefix, boolean preserveNamespaces,\n+                                                          List<BXML> sequence) {\n+        MapValueImpl<BString, Object> elementObj = newJsonMap();\n+        for (BXML bxml : sequence) {\n+            // Skip comments and PI items.\n+            if (isCommentOrPi(bxml)) {\n+                continue;\n+            }\n+            String elementName = getElementKey((XMLItem) bxml, preserveNamespaces);\n+            Object elemAsJson = convertElement((XMLItem) bxml, attributePrefix, preserveNamespaces);\n+            if (elemAsJson instanceof MapValueImpl) {\n+                @SuppressWarnings(\"unchecked\")\n+                MapValueImpl<BString, Object> mapVal = (MapValueImpl<BString, Object>) elemAsJson;\n+                if (mapVal.size() == 1) {\n+                    Object val = mapVal.get(fromString(elementName));\n+                    if (val != null) {\n+                        putAsBStrings(elementObj, elementName, val);\n+                        continue;\n+                    }\n+                }\n+            }\n+            putAsBStrings(elementObj, elementName, elemAsJson);\n+        }\n+        return elementObj;\n+    }\n+\n+    private static boolean isCommentOrPi(BXML bxml) {\n+        return bxml.getNodeType() == XMLNodeType.COMMENT || bxml.getNodeType() == XMLNodeType.PI;\n+    }\n+\n+    private static Object convertSequenceWithSameNamedElements(String attributePrefix, boolean preserveNamespaces,\n+                                                               List<BXML> sequence) {\n+        String elementName = null;\n+        for (BXML bxml : sequence) {\n+            if (bxml.getNodeType() == XMLNodeType.ELEMENT) {\n+                elementName = bxml.getElementName();\n+                break;\n+            }\n+        }\n+        MapValueImpl<BString, Object> listWrapper = newJsonMap();\n+        ArrayValueImpl arrayValue = convertChildrenToJsonList(sequence, attributePrefix, preserveNamespaces);\n+        putAsBStrings(listWrapper, elementName, arrayValue);\n+        return listWrapper;\n+    }\n+\n+    private static ArrayValueImpl convertChildrenToJsonList(List<BXML> sequence, String prefix,\n+                                                            boolean preserveNamespaces) {\n+        List<Object> list = new ArrayList<>();\n+        for (BXML child : sequence) {\n+            if (isCommentOrPi(child)) {\n+                continue;\n+            }\n+            if (child.getAttributesMap().isEmpty()) {\n+                list.add(convertToJSON((XMLValue) child.children(), prefix, preserveNamespaces));\n+            } else {\n+                list.add(convertElement((XMLItem) child, prefix, preserveNamespaces));\n+            }\n+        }\n+        return newJsonListFrom(list);\n+    }\n+\n+    private static SequenceConvertibility calculateMatchingJsonTypeForSequence(List<BXML> sequence) {\n+        Iterator<BXML> iterator = sequence.iterator();\n+        BXML next = iterator.next();\n+        if (next.getNodeType() == XMLNodeType.TEXT) {\n+            return SequenceConvertibility.LIST;\n+        }\n+        // Scan until first convertible item is found.\n+        while (iterator.hasNext() && (isCommentOrPi(next))) {\n+            next = iterator.next();\n+            if (next.getNodeType() == XMLNodeType.TEXT) {\n+                return SequenceConvertibility.LIST;\n+            }\n+        }\n+\n+        String firstElementName = next.getElementName();\n+        int i = 0;\n+        boolean sameElementName = true;\n+        for (; iterator.hasNext(); i++) {\n+            BXML val = iterator.next();\n+            if (val.getNodeType() == XMLNodeType.ELEMENT) {\n+                if (!((XMLItem) val).getElementName().equals(firstElementName)) {\n+                    sameElementName = false;\n+                }\n+            } else if (val.getNodeType() == XMLNodeType.TEXT) {\n+                return SequenceConvertibility.LIST;\n+            } else {\n+                i--; // we don't want `i` to count up for comments and PI items\n+            }\n+        }\n+        return (sameElementName && i > 0) ? SequenceConvertibility.SAME_KEY : SequenceConvertibility.ELEMENT_ONLY;\n+    }\n+\n+    private static ArrayValueImpl newJsonList() {\n+        return new ArrayValueImpl(new BArrayType(BTypes.typeJSON));", "originalCommit": "655f00c9576e041b18a3da09c3723347f2a3c9a2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU4NjE5Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24406#discussion_r454586196", "bodyText": "Isn't this always the same? Can't we use a constant?", "author": "MaryamZi", "createdAt": "2020-07-14T19:17:22Z", "path": "stdlib/jsonutils/src/main/java/org/ballerinalang/stdlib/jsonutils/XmlToJsonConverter.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.stdlib.jsonutils;\n+\n+import org.ballerinalang.jvm.JSONParser;\n+import org.ballerinalang.jvm.XMLNodeType;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BPackage;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeConstants;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.XMLItem;\n+import org.ballerinalang.jvm.values.XMLSequence;\n+import org.ballerinalang.jvm.values.XMLText;\n+import org.ballerinalang.jvm.values.XMLValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.jvm.values.api.BXML;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.namespace.QName;\n+\n+import static org.ballerinalang.jvm.StringUtils.fromString;\n+\n+/**\n+ * Convert Ballerina XML value into respective JSON value.\n+ * @since 1.2.5\n+ */\n+public class XmlToJsonConverter {\n+\n+    private static final String XML_NAMESPACE_PREFIX_FRAGMENT = \"xmlns:\";\n+\n+    private static final BType jsonMapType =\n+            new BMapType(TypeConstants.MAP_TNAME, BTypes.typeJSON, new BPackage(null, null, null));\n+    private static final String XMLNS = \"xmlns\";\n+\n+    /**\n+     * Converts given xml object to the corresponding JSON value.\n+     *\n+     * @param xml                XML object to get the corresponding json\n+     * @param attributePrefix    Prefix to use in attributes\n+     * @param preserveNamespaces preserve the namespaces when converting\n+     * @return JSON representation of the given xml object\n+     */\n+    public static Object convertToJSON(XMLValue xml, String attributePrefix, boolean preserveNamespaces) {\n+        if (xml instanceof XMLText) {\n+            return JSONParser.parse(\"\\\"\" + ((XMLText) xml).stringValue() + \"\\\"\");\n+        } else if (xml instanceof XMLItem) {\n+            return convertElement((XMLItem) xml, attributePrefix, preserveNamespaces);\n+        } else if (xml instanceof XMLSequence) {\n+            XMLSequence xmlSequence = (XMLSequence) xml;\n+            if (xmlSequence.isEmpty()) {\n+                return newJsonList();\n+            }\n+            Object seq = convertXMLSequence(xmlSequence, attributePrefix, preserveNamespaces);\n+            if (seq == null) {\n+                return newJsonList();\n+            }\n+            return seq;\n+        }\n+        return newJsonMap();\n+    }\n+    /**\n+     * Converts given xml object to the corresponding json.\n+     *\n+     * @param xmlItem XML element to traverse\n+     * @param attributePrefix Prefix to use in attributes\n+     * @param preserveNamespaces preserve the namespaces when converting\n+     * @return ObjectNode Json object node corresponding to the given xml element\n+     */\n+    private static Object convertElement(XMLItem xmlItem, String attributePrefix,\n+                                         boolean preserveNamespaces) {\n+        MapValueImpl<BString, Object> rootNode = newJsonMap();\n+        LinkedHashMap<String, String> attributeMap = collectAttributesAndNamespaces(xmlItem, preserveNamespaces);\n+        String keyValue = getElementKey(xmlItem, preserveNamespaces);\n+        Object children = convertXMLSequence(xmlItem.getChildrenSeq(), attributePrefix, preserveNamespaces);\n+\n+        if (attributeMap.isEmpty() && children == null) {\n+            putAsBStrings(rootNode, keyValue, \"\");\n+            return rootNode;\n+        }\n+        if (children != null) {\n+            putAsBStrings(rootNode, keyValue, children);\n+        }\n+        if (!attributeMap.isEmpty()) {\n+            addAttributes(rootNode, attributePrefix, attributeMap);\n+        }\n+        return rootNode;\n+    }\n+\n+    private static void addAttributes(MapValueImpl<BString, Object> rootNode, String attributePrefix,\n+                                      LinkedHashMap<String, String> attributeMap) {\n+        for (Map.Entry<String, String> entry : attributeMap.entrySet()) {\n+            putAsBStrings(rootNode, attributePrefix + entry.getKey(), entry.getValue());\n+        }\n+    }\n+\n+    private static void putAsBStrings(MapValueImpl<BString, Object> map, String key, String value) {\n+        map.put(fromString(key), fromString(value));\n+    }\n+\n+    private static void putAsBStrings(MapValueImpl<BString, Object> map, String key, Object value) {\n+        map.put(fromString(key), value);\n+    }\n+\n+    /**\n+     * Converts given xml sequence to the corresponding json.\n+     *\n+     * @param xmlSequence XML sequence to traverse\n+     * @param attributePrefix Prefix to use in attributes\n+     * @param preserveNamespaces preserve the namespaces when converting\n+     * @return JsonNode Json node corresponding to the given xml sequence\n+     */\n+    private static Object convertXMLSequence(XMLSequence xmlSequence, String attributePrefix,\n+                                             boolean preserveNamespaces) {\n+        List<BXML> sequence = xmlSequence.getChildrenList();\n+        if (sequence.isEmpty()) {\n+            return null;\n+        }\n+\n+        switch (calculateMatchingJsonTypeForSequence(sequence)) {\n+            case SAME_KEY:\n+                return convertSequenceWithSameNamedElements(attributePrefix, preserveNamespaces, sequence);\n+            case ELEMENT_ONLY:\n+                return convertSequenceWithOnlyElements(attributePrefix, preserveNamespaces, sequence);\n+            default:\n+                return convertHeterogeneousSequence(attributePrefix, preserveNamespaces, sequence);\n+        }\n+    }\n+\n+    private static Object convertHeterogeneousSequence(String attributePrefix, boolean preserveNamespaces,\n+                                                       List<BXML> sequence) {\n+        if (sequence.size() == 1) {\n+            return convertToJSON((XMLValue) sequence.get(0), attributePrefix, preserveNamespaces);\n+        }\n+\n+        ArrayList<Object> list = new ArrayList<>();\n+        for (BXML bxml : sequence) {\n+            if (isCommentOrPi(bxml)) {\n+                continue;\n+            }\n+            list.add(convertToJSON((XMLValue) bxml, attributePrefix, preserveNamespaces));\n+        }\n+\n+        if (list.isEmpty()) {\n+            return null;\n+        }\n+        return newJsonListFrom(list);\n+    }\n+\n+    private static Object convertSequenceWithOnlyElements(String attributePrefix, boolean preserveNamespaces,\n+                                                          List<BXML> sequence) {\n+        MapValueImpl<BString, Object> elementObj = newJsonMap();\n+        for (BXML bxml : sequence) {\n+            // Skip comments and PI items.\n+            if (isCommentOrPi(bxml)) {\n+                continue;\n+            }\n+            String elementName = getElementKey((XMLItem) bxml, preserveNamespaces);\n+            Object elemAsJson = convertElement((XMLItem) bxml, attributePrefix, preserveNamespaces);\n+            if (elemAsJson instanceof MapValueImpl) {\n+                @SuppressWarnings(\"unchecked\")\n+                MapValueImpl<BString, Object> mapVal = (MapValueImpl<BString, Object>) elemAsJson;\n+                if (mapVal.size() == 1) {\n+                    Object val = mapVal.get(fromString(elementName));\n+                    if (val != null) {\n+                        putAsBStrings(elementObj, elementName, val);\n+                        continue;\n+                    }\n+                }\n+            }\n+            putAsBStrings(elementObj, elementName, elemAsJson);\n+        }\n+        return elementObj;\n+    }\n+\n+    private static boolean isCommentOrPi(BXML bxml) {\n+        return bxml.getNodeType() == XMLNodeType.COMMENT || bxml.getNodeType() == XMLNodeType.PI;\n+    }\n+\n+    private static Object convertSequenceWithSameNamedElements(String attributePrefix, boolean preserveNamespaces,\n+                                                               List<BXML> sequence) {\n+        String elementName = null;\n+        for (BXML bxml : sequence) {\n+            if (bxml.getNodeType() == XMLNodeType.ELEMENT) {\n+                elementName = bxml.getElementName();\n+                break;\n+            }\n+        }\n+        MapValueImpl<BString, Object> listWrapper = newJsonMap();\n+        ArrayValueImpl arrayValue = convertChildrenToJsonList(sequence, attributePrefix, preserveNamespaces);\n+        putAsBStrings(listWrapper, elementName, arrayValue);\n+        return listWrapper;\n+    }\n+\n+    private static ArrayValueImpl convertChildrenToJsonList(List<BXML> sequence, String prefix,\n+                                                            boolean preserveNamespaces) {\n+        List<Object> list = new ArrayList<>();\n+        for (BXML child : sequence) {\n+            if (isCommentOrPi(child)) {\n+                continue;\n+            }\n+            if (child.getAttributesMap().isEmpty()) {\n+                list.add(convertToJSON((XMLValue) child.children(), prefix, preserveNamespaces));\n+            } else {\n+                list.add(convertElement((XMLItem) child, prefix, preserveNamespaces));\n+            }\n+        }\n+        return newJsonListFrom(list);\n+    }\n+\n+    private static SequenceConvertibility calculateMatchingJsonTypeForSequence(List<BXML> sequence) {\n+        Iterator<BXML> iterator = sequence.iterator();\n+        BXML next = iterator.next();\n+        if (next.getNodeType() == XMLNodeType.TEXT) {\n+            return SequenceConvertibility.LIST;\n+        }\n+        // Scan until first convertible item is found.\n+        while (iterator.hasNext() && (isCommentOrPi(next))) {\n+            next = iterator.next();\n+            if (next.getNodeType() == XMLNodeType.TEXT) {\n+                return SequenceConvertibility.LIST;\n+            }\n+        }\n+\n+        String firstElementName = next.getElementName();\n+        int i = 0;\n+        boolean sameElementName = true;\n+        for (; iterator.hasNext(); i++) {\n+            BXML val = iterator.next();\n+            if (val.getNodeType() == XMLNodeType.ELEMENT) {\n+                if (!((XMLItem) val).getElementName().equals(firstElementName)) {\n+                    sameElementName = false;\n+                }\n+            } else if (val.getNodeType() == XMLNodeType.TEXT) {\n+                return SequenceConvertibility.LIST;\n+            } else {\n+                i--; // we don't want `i` to count up for comments and PI items\n+            }\n+        }\n+        return (sameElementName && i > 0) ? SequenceConvertibility.SAME_KEY : SequenceConvertibility.ELEMENT_ONLY;\n+    }\n+\n+    private static ArrayValueImpl newJsonList() {\n+        return new ArrayValueImpl(new BArrayType(BTypes.typeJSON));\n+    }\n+\n+    public static ArrayValueImpl newJsonListFrom(List<Object> items) {\n+        return new ArrayValueImpl(items.toArray(), new BArrayType(BTypes.typeJSON));\n+    }\n+\n+    private static MapValueImpl<BString, Object> newJsonMap() {\n+        return new MapValueImpl<>(jsonMapType);\n+    }\n+\n+    /**\n+     * Extract attributes and namespaces from the XML element.\n+     *\n+     * @param element XML element to extract attributes and namespaces\n+     * @param preserveNamespaces should namespace attribute be preserved\n+     */\n+    private static LinkedHashMap<String, String> collectAttributesAndNamespaces(XMLItem element,\n+                                                                                boolean preserveNamespaces) {\n+        int nsPrefixBeginIndex = XMLItem.XMLNS_URL_PREFIX.length();", "originalCommit": "655f00c9576e041b18a3da09c3723347f2a3c9a2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU4ODA0Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24406#discussion_r454588042", "bodyText": "Shall we change this to something like\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (entry.getKey().getValue().startsWith(XMLItem.XMLNS_URL_PREFIX)) {\n          \n          \n            \n                            String prefix = entry.getKey().getValue().substring(nsPrefixBeginIndex);\n          \n          \n            \n                            String ns = entry.getValue().getValue();\n          \n          \n            \n                            nsPrefixMap.put(ns, prefix);\n          \n          \n            \n                            if (preserveNamespaces) {\n          \n          \n            \n                                if (prefix.equals(XMLNS)) {\n          \n          \n            \n                                    attributeMap.put(prefix, ns);\n          \n          \n            \n                                } else {\n          \n          \n            \n                                    attributeMap.put(XML_NAMESPACE_PREFIX_FRAGMENT + prefix, ns);\n          \n          \n            \n                                }\n          \n          \n            \n                            }\n          \n          \n            \n                        }\n          \n          \n            \n                        if (!entry.getKey().getValue().startsWith(XMLItem.XMLNS_URL_PREFIX)) {\n          \n          \n            \n                            continue;\n          \n          \n            \n                       }\n          \n          \n            \n                       String prefix = entry.getKey().getValue().substring(nsPrefixBeginIndex);\n          \n          \n            \n                       String ns = entry.getValue().getValue();\n          \n          \n            \n                       nsPrefixMap.put(ns, prefix);\n          \n          \n            \n                       if (preserveNamespaces) {\n          \n          \n            \n                           if (prefix.equals(XMLNS)) {\n          \n          \n            \n                               attributeMap.put(prefix, ns);\n          \n          \n            \n                           } else {\n          \n          \n            \n                               attributeMap.put(XML_NAMESPACE_PREFIX_FRAGMENT + prefix, ns);\n          \n          \n            \n                           }\n          \n          \n            \n                        }", "author": "MaryamZi", "createdAt": "2020-07-14T19:20:39Z", "path": "stdlib/jsonutils/src/main/java/org/ballerinalang/stdlib/jsonutils/XmlToJsonConverter.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.stdlib.jsonutils;\n+\n+import org.ballerinalang.jvm.JSONParser;\n+import org.ballerinalang.jvm.XMLNodeType;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BPackage;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeConstants;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.XMLItem;\n+import org.ballerinalang.jvm.values.XMLSequence;\n+import org.ballerinalang.jvm.values.XMLText;\n+import org.ballerinalang.jvm.values.XMLValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.jvm.values.api.BXML;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.namespace.QName;\n+\n+import static org.ballerinalang.jvm.StringUtils.fromString;\n+\n+/**\n+ * Convert Ballerina XML value into respective JSON value.\n+ * @since 1.2.5\n+ */\n+public class XmlToJsonConverter {\n+\n+    private static final String XML_NAMESPACE_PREFIX_FRAGMENT = \"xmlns:\";\n+\n+    private static final BType jsonMapType =\n+            new BMapType(TypeConstants.MAP_TNAME, BTypes.typeJSON, new BPackage(null, null, null));\n+    private static final String XMLNS = \"xmlns\";\n+\n+    /**\n+     * Converts given xml object to the corresponding JSON value.\n+     *\n+     * @param xml                XML object to get the corresponding json\n+     * @param attributePrefix    Prefix to use in attributes\n+     * @param preserveNamespaces preserve the namespaces when converting\n+     * @return JSON representation of the given xml object\n+     */\n+    public static Object convertToJSON(XMLValue xml, String attributePrefix, boolean preserveNamespaces) {\n+        if (xml instanceof XMLText) {\n+            return JSONParser.parse(\"\\\"\" + ((XMLText) xml).stringValue() + \"\\\"\");\n+        } else if (xml instanceof XMLItem) {\n+            return convertElement((XMLItem) xml, attributePrefix, preserveNamespaces);\n+        } else if (xml instanceof XMLSequence) {\n+            XMLSequence xmlSequence = (XMLSequence) xml;\n+            if (xmlSequence.isEmpty()) {\n+                return newJsonList();\n+            }\n+            Object seq = convertXMLSequence(xmlSequence, attributePrefix, preserveNamespaces);\n+            if (seq == null) {\n+                return newJsonList();\n+            }\n+            return seq;\n+        }\n+        return newJsonMap();\n+    }\n+    /**\n+     * Converts given xml object to the corresponding json.\n+     *\n+     * @param xmlItem XML element to traverse\n+     * @param attributePrefix Prefix to use in attributes\n+     * @param preserveNamespaces preserve the namespaces when converting\n+     * @return ObjectNode Json object node corresponding to the given xml element\n+     */\n+    private static Object convertElement(XMLItem xmlItem, String attributePrefix,\n+                                         boolean preserveNamespaces) {\n+        MapValueImpl<BString, Object> rootNode = newJsonMap();\n+        LinkedHashMap<String, String> attributeMap = collectAttributesAndNamespaces(xmlItem, preserveNamespaces);\n+        String keyValue = getElementKey(xmlItem, preserveNamespaces);\n+        Object children = convertXMLSequence(xmlItem.getChildrenSeq(), attributePrefix, preserveNamespaces);\n+\n+        if (attributeMap.isEmpty() && children == null) {\n+            putAsBStrings(rootNode, keyValue, \"\");\n+            return rootNode;\n+        }\n+        if (children != null) {\n+            putAsBStrings(rootNode, keyValue, children);\n+        }\n+        if (!attributeMap.isEmpty()) {\n+            addAttributes(rootNode, attributePrefix, attributeMap);\n+        }\n+        return rootNode;\n+    }\n+\n+    private static void addAttributes(MapValueImpl<BString, Object> rootNode, String attributePrefix,\n+                                      LinkedHashMap<String, String> attributeMap) {\n+        for (Map.Entry<String, String> entry : attributeMap.entrySet()) {\n+            putAsBStrings(rootNode, attributePrefix + entry.getKey(), entry.getValue());\n+        }\n+    }\n+\n+    private static void putAsBStrings(MapValueImpl<BString, Object> map, String key, String value) {\n+        map.put(fromString(key), fromString(value));\n+    }\n+\n+    private static void putAsBStrings(MapValueImpl<BString, Object> map, String key, Object value) {\n+        map.put(fromString(key), value);\n+    }\n+\n+    /**\n+     * Converts given xml sequence to the corresponding json.\n+     *\n+     * @param xmlSequence XML sequence to traverse\n+     * @param attributePrefix Prefix to use in attributes\n+     * @param preserveNamespaces preserve the namespaces when converting\n+     * @return JsonNode Json node corresponding to the given xml sequence\n+     */\n+    private static Object convertXMLSequence(XMLSequence xmlSequence, String attributePrefix,\n+                                             boolean preserveNamespaces) {\n+        List<BXML> sequence = xmlSequence.getChildrenList();\n+        if (sequence.isEmpty()) {\n+            return null;\n+        }\n+\n+        switch (calculateMatchingJsonTypeForSequence(sequence)) {\n+            case SAME_KEY:\n+                return convertSequenceWithSameNamedElements(attributePrefix, preserveNamespaces, sequence);\n+            case ELEMENT_ONLY:\n+                return convertSequenceWithOnlyElements(attributePrefix, preserveNamespaces, sequence);\n+            default:\n+                return convertHeterogeneousSequence(attributePrefix, preserveNamespaces, sequence);\n+        }\n+    }\n+\n+    private static Object convertHeterogeneousSequence(String attributePrefix, boolean preserveNamespaces,\n+                                                       List<BXML> sequence) {\n+        if (sequence.size() == 1) {\n+            return convertToJSON((XMLValue) sequence.get(0), attributePrefix, preserveNamespaces);\n+        }\n+\n+        ArrayList<Object> list = new ArrayList<>();\n+        for (BXML bxml : sequence) {\n+            if (isCommentOrPi(bxml)) {\n+                continue;\n+            }\n+            list.add(convertToJSON((XMLValue) bxml, attributePrefix, preserveNamespaces));\n+        }\n+\n+        if (list.isEmpty()) {\n+            return null;\n+        }\n+        return newJsonListFrom(list);\n+    }\n+\n+    private static Object convertSequenceWithOnlyElements(String attributePrefix, boolean preserveNamespaces,\n+                                                          List<BXML> sequence) {\n+        MapValueImpl<BString, Object> elementObj = newJsonMap();\n+        for (BXML bxml : sequence) {\n+            // Skip comments and PI items.\n+            if (isCommentOrPi(bxml)) {\n+                continue;\n+            }\n+            String elementName = getElementKey((XMLItem) bxml, preserveNamespaces);\n+            Object elemAsJson = convertElement((XMLItem) bxml, attributePrefix, preserveNamespaces);\n+            if (elemAsJson instanceof MapValueImpl) {\n+                @SuppressWarnings(\"unchecked\")\n+                MapValueImpl<BString, Object> mapVal = (MapValueImpl<BString, Object>) elemAsJson;\n+                if (mapVal.size() == 1) {\n+                    Object val = mapVal.get(fromString(elementName));\n+                    if (val != null) {\n+                        putAsBStrings(elementObj, elementName, val);\n+                        continue;\n+                    }\n+                }\n+            }\n+            putAsBStrings(elementObj, elementName, elemAsJson);\n+        }\n+        return elementObj;\n+    }\n+\n+    private static boolean isCommentOrPi(BXML bxml) {\n+        return bxml.getNodeType() == XMLNodeType.COMMENT || bxml.getNodeType() == XMLNodeType.PI;\n+    }\n+\n+    private static Object convertSequenceWithSameNamedElements(String attributePrefix, boolean preserveNamespaces,\n+                                                               List<BXML> sequence) {\n+        String elementName = null;\n+        for (BXML bxml : sequence) {\n+            if (bxml.getNodeType() == XMLNodeType.ELEMENT) {\n+                elementName = bxml.getElementName();\n+                break;\n+            }\n+        }\n+        MapValueImpl<BString, Object> listWrapper = newJsonMap();\n+        ArrayValueImpl arrayValue = convertChildrenToJsonList(sequence, attributePrefix, preserveNamespaces);\n+        putAsBStrings(listWrapper, elementName, arrayValue);\n+        return listWrapper;\n+    }\n+\n+    private static ArrayValueImpl convertChildrenToJsonList(List<BXML> sequence, String prefix,\n+                                                            boolean preserveNamespaces) {\n+        List<Object> list = new ArrayList<>();\n+        for (BXML child : sequence) {\n+            if (isCommentOrPi(child)) {\n+                continue;\n+            }\n+            if (child.getAttributesMap().isEmpty()) {\n+                list.add(convertToJSON((XMLValue) child.children(), prefix, preserveNamespaces));\n+            } else {\n+                list.add(convertElement((XMLItem) child, prefix, preserveNamespaces));\n+            }\n+        }\n+        return newJsonListFrom(list);\n+    }\n+\n+    private static SequenceConvertibility calculateMatchingJsonTypeForSequence(List<BXML> sequence) {\n+        Iterator<BXML> iterator = sequence.iterator();\n+        BXML next = iterator.next();\n+        if (next.getNodeType() == XMLNodeType.TEXT) {\n+            return SequenceConvertibility.LIST;\n+        }\n+        // Scan until first convertible item is found.\n+        while (iterator.hasNext() && (isCommentOrPi(next))) {\n+            next = iterator.next();\n+            if (next.getNodeType() == XMLNodeType.TEXT) {\n+                return SequenceConvertibility.LIST;\n+            }\n+        }\n+\n+        String firstElementName = next.getElementName();\n+        int i = 0;\n+        boolean sameElementName = true;\n+        for (; iterator.hasNext(); i++) {\n+            BXML val = iterator.next();\n+            if (val.getNodeType() == XMLNodeType.ELEMENT) {\n+                if (!((XMLItem) val).getElementName().equals(firstElementName)) {\n+                    sameElementName = false;\n+                }\n+            } else if (val.getNodeType() == XMLNodeType.TEXT) {\n+                return SequenceConvertibility.LIST;\n+            } else {\n+                i--; // we don't want `i` to count up for comments and PI items\n+            }\n+        }\n+        return (sameElementName && i > 0) ? SequenceConvertibility.SAME_KEY : SequenceConvertibility.ELEMENT_ONLY;\n+    }\n+\n+    private static ArrayValueImpl newJsonList() {\n+        return new ArrayValueImpl(new BArrayType(BTypes.typeJSON));\n+    }\n+\n+    public static ArrayValueImpl newJsonListFrom(List<Object> items) {\n+        return new ArrayValueImpl(items.toArray(), new BArrayType(BTypes.typeJSON));\n+    }\n+\n+    private static MapValueImpl<BString, Object> newJsonMap() {\n+        return new MapValueImpl<>(jsonMapType);\n+    }\n+\n+    /**\n+     * Extract attributes and namespaces from the XML element.\n+     *\n+     * @param element XML element to extract attributes and namespaces\n+     * @param preserveNamespaces should namespace attribute be preserved\n+     */\n+    private static LinkedHashMap<String, String> collectAttributesAndNamespaces(XMLItem element,\n+                                                                                boolean preserveNamespaces) {\n+        int nsPrefixBeginIndex = XMLItem.XMLNS_URL_PREFIX.length();\n+        LinkedHashMap<String, String> attributeMap = new LinkedHashMap<>();\n+        Map<String, String> nsPrefixMap = new HashMap<>();\n+        for (Map.Entry<BString, BString> entry : element.getAttributesMap().entrySet()) {\n+            if (entry.getKey().getValue().startsWith(XMLItem.XMLNS_URL_PREFIX)) {\n+                String prefix = entry.getKey().getValue().substring(nsPrefixBeginIndex);\n+                String ns = entry.getValue().getValue();\n+                nsPrefixMap.put(ns, prefix);\n+                if (preserveNamespaces) {\n+                    if (prefix.equals(XMLNS)) {\n+                        attributeMap.put(prefix, ns);\n+                    } else {\n+                        attributeMap.put(XML_NAMESPACE_PREFIX_FRAGMENT + prefix, ns);\n+                    }\n+                }\n+            }", "originalCommit": "655f00c9576e041b18a3da09c3723347f2a3c9a2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "38111e5314ee4f400e749a41b98a507a50132116", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/38111e5314ee4f400e749a41b98a507a50132116", "message": "Refactor and apply review suggestions", "committedDate": "2020-07-21T04:17:32Z", "type": "forcePushed"}, {"oid": "97a429a4045b65a05ab12eb0cb9cd82aa12385c1", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/97a429a4045b65a05ab12eb0cb9cd82aa12385c1", "message": "Refactor and apply review suggestions", "committedDate": "2020-07-21T04:29:24Z", "type": "commit"}, {"oid": "97a429a4045b65a05ab12eb0cb9cd82aa12385c1", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/97a429a4045b65a05ab12eb0cb9cd82aa12385c1", "message": "Refactor and apply review suggestions", "committedDate": "2020-07-21T04:29:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY3NTMxMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24406#discussion_r460675310", "bodyText": "Can we not assert these in Ballerina itself?", "author": "MaryamZi", "createdAt": "2020-07-27T06:37:05Z", "path": "stdlib/jsonutils/src/test/java/org/ballerinalang/stdlib/jsonutils/JsonUtilsTest.java", "diffHunk": "@@ -64,30 +68,161 @@ public void testFromTableFunction() {\n         Assert.assertNotNull(returns[0]);\n         Assert.assertEquals(returns[0].stringValue(),\n                 \"[{\\\"id\\\":1, \\\"age\\\":30, \\\"salary\\\":300.5, \\\"name\\\":\\\"Mary\\\", \\\"married\\\":true}, \" +\n-                    \"{\\\"id\\\":2, \\\"age\\\":20, \\\"salary\\\":300.5, \\\"name\\\":\\\"John\\\", \\\"married\\\":true}]\");\n+                        \"{\\\"id\\\":2, \\\"age\\\":20, \\\"salary\\\":300.5, \\\"name\\\":\\\"John\\\", \\\"married\\\":true}]\");\n+    }\n+\n+    @Test\n+    public void testComplexXMLElementToJson() {\n+        BValue[] jsonStr = BRunUtil.invoke(result, \"testComplexXMLElementToJson\");\n+        Assert.assertEquals(jsonStr[0].stringValue(),\n+                \"{\\\"Invoice\\\":[\\\"\\\\n        \\\", {\\\"PurchesedItems\\\":[\\\"\\\\n            \\\", \" +\n+                        \"{\\\"PLine\\\":{\\\"ItemCode\\\":{\\\"ItemCode\\\":\\\"223345\\\", \\\"@xmlns\\\":\\\"example.com\\\"}, \" +\n+                        \"\\\"Count\\\":{\\\"Count\\\":\\\"10\\\", \\\"@xmlns\\\":\\\"example.com\\\"}}, \\\"@xmlns\\\":\\\"example.com\\\"},\" +\n+                        \" \\\"\\\\n            \\\", \" +\n+                        \"{\\\"PLine\\\":{\\\"ItemCode\\\":{\\\"ItemCode\\\":\\\"223300\\\", \\\"@xmlns\\\":\\\"example.com\\\"}, \" +\n+                        \"\\\"Count\\\":{\\\"Count\\\":\\\"7\\\", \\\"@xmlns\\\":\\\"example.com\\\"}}, \\\"@xmlns\\\":\\\"example.com\\\"}, \" +\n+                        \"\\\"\\\\n            \\\", \" +\n+                        \"{\\\"PLine\\\":{\\\"ItemCode\\\":{\\\"ItemCode\\\":\\\"200777\\\", \\\"@xmlns\\\":\\\"example.com\\\", \" +\n+                        \"\\\"@discount\\\":\\\"22%\\\"}, \\\"Count\\\":{\\\"Count\\\":\\\"7\\\", \\\"@xmlns\\\":\\\"example.com\\\"}}, \" +\n+                        \"\\\"@xmlns\\\":\\\"example.com\\\"}, \\\"\\\\n        \\\"], \\\"@xmlns\\\":\\\"example.com\\\"}, \" +\n+                        \"\\\"\\\\n        \\\", \" +\n+                        \"{\\\"Address\\\":[\\\"\\\\n            \\\", {\\\"StreetAddress\\\":\\\"20, Palm grove, Colombo 3\\\"}, \" +\n+                        \"\\\"\\\\n            \\\", \" +\n+                        \"{\\\"City\\\":\\\"Colombo\\\"}, \\\"\\\\n            \\\", {\\\"Zip\\\":\\\"00300\\\"}, \\\"\\\\n            \\\", \" +\n+                        \"{\\\"Country\\\":\\\"LK\\\"}, \\\"\\\\n        \\\"], \\\"@xmlns\\\":\\\"\\\"}, \\\"\\\\n    \\\"], \" +\n+                        \"\\\"@xmlns\\\":\\\"example.com\\\", \\\"@xmlns:ns\\\":\\\"ns.com\\\", \\\"@attr\\\":\\\"attr-val\\\", \" +\n+                        \"\\\"@ns:attr\\\":\\\"ns-attr-val\\\"}\");\n+    }\n+\n+    @Test\n+    public void testComplexXMLElementToJsonNoPreserveNS() {\n+        BValue[] jsonStr = BRunUtil.invoke(result, \"testComplexXMLElementToJsonNoPreserveNS\");\n+        Assert.assertEquals(jsonStr[0].stringValue(),\n+                \"{\\\"Invoice\\\":[\\\"\\\\n        \\\", {\\\"PurchesedItems\\\":[\\\"\\\\n            \\\", \" +\n+                        \"{\\\"PLine\\\":{\\\"ItemCode\\\":\\\"223345\\\", \\\"Count\\\":\\\"10\\\"}}, \\\"\\\\n            \\\", \" +\n+                        \"{\\\"PLine\\\":{\\\"ItemCode\\\":\\\"223300\\\", \\\"Count\\\":\\\"7\\\"}}, \\\"\\\\n            \\\", \" +\n+                        \"{\\\"PLine\\\":{\\\"ItemCode\\\":{\\\"ItemCode\\\":\\\"200777\\\", \\\"@discount\\\":\\\"22%\\\"}, \" +\n+                        \"\\\"Count\\\":\\\"7\\\"}}, \\\"\\\\n        \\\"]}, \\\"\\\\n        \\\", {\\\"Address\\\":[\\\"\\\\n            \\\", \" +\n+                        \"{\\\"StreetAddress\\\":\\\"20, Palm grove, Colombo 3\\\"}, \\\"\\\\n            \\\", \" +\n+                        \"{\\\"City\\\":\\\"Colombo\\\"}, \\\"\\\\n            \\\", {\\\"Zip\\\":\\\"00300\\\"}, \\\"\\\\n            \\\", \" +\n+                        \"{\\\"Country\\\":\\\"LK\\\"}, \\\"\\\\n        \\\"]}, \\\"\\\\n    \\\"], \" +\n+                        \"\\\"@ns\\\":\\\"ns.com\\\", \\\"@attr\\\":\\\"ns-attr-val\\\"}\");\n+    }\n+\n+    @Test\n+    public void testSequenceOfSameElementNamedItems() {\n+        convertChildrenToJsonAndAssert(\"<root><hello>1</hello><hello>2</hello></root>\",\n+                \"{\\\"hello\\\":[\\\"1\\\", \\\"2\\\"]}\");\n+    }\n+\n+    @Test\n+    public void testSequenceOfDifferentElementNamedItems() {\n+        convertChildrenToJsonAndAssert(\"<root><hello-0>1</hello-0><hello-1>2</hello-1></root>\",\n+                \"{\\\"hello-0\\\":\\\"1\\\", \\\"hello-1\\\":\\\"2\\\"}\");\n+    }\n+\n+    @Test\n+    public void testElementWithDifferentNamedChildrenElementItems() {\n+        convertToJsonAndAssert(\"<root><hello-0>1</hello-0><hello-1>2</hello-1></root>\",\n+                \"{\\\"root\\\":{\\\"hello-0\\\":\\\"1\\\", \\\"hello-1\\\":\\\"2\\\"}}\");\n+    }\n+\n+    @Test\n+    public void testElementWithSameNamedChildrenElementItems() {\n+        convertToJsonAndAssert(\"<root><hello>1</hello><hello>2</hello></root>\",\n+                \"{\\\"root\\\":{\\\"hello\\\":[\\\"1\\\", \\\"2\\\"]}}\");\n+    }\n+\n+    @Test\n+    public void testElementWithSameNamedChildrenElementItemsWithNonConvertible() {\n+        convertToJsonAndAssert(\"<root><hello>1</hello><!--cmnt--><hello>2</hello></root>\",\n+                \"{\\\"root\\\":{\\\"hello\\\":[\\\"1\\\", \\\"2\\\"]}}\");\n+    }\n+\n+    @Test\n+    public void testElementWithSameNamedChildrenElementItemsWithNonConvertibleBegin() {\n+        convertToJsonAndAssert(\"<root><!--cmnt--><hello>1</hello><hello>2</hello></root>\",\n+                \"{\\\"root\\\":{\\\"hello\\\":[\\\"1\\\", \\\"2\\\"]}}\");\n+    }\n+\n+    @Test\n+    public void testElementWithSameNamedChildrenElementItemsWithNonConvertibleEnd() {\n+        convertToJsonAndAssert(\"<root><hello>1</hello><hello>2</hello><!--cmnt--></root>\",\n+                \"{\\\"root\\\":{\\\"hello\\\":[\\\"1\\\", \\\"2\\\"]}}\");\n+    }\n+\n+    @Test\n+    public void testElementWithSameNamedEmptyChildren() {\n+        convertToJsonAndAssert(\"<root><hello attr0=\\\"hello\\\"></hello><hello></hello></root>\",\n+                \"{\\\"root\\\":{\\\"hello\\\":[{\\\"@attr0\\\":\\\"hello\\\"}, []]}}\");\n+    }\n+\n+\n+    @Test\n+    public void testComplexXMLtoJson() {\n+        convertToJsonAndAssert(\n+                \"<Invoice xmlns=\\\"example.com\\\" attr=\\\"attr-val\\\" xmlns:ns=\\\"ns.com\\\" ns:attr=\\\"ns-attr-val\\\">\\n\" +\n+                        \"        <PurchesedItems>\\n\" +\n+                        \"            <PLine><ItemCode>223345</ItemCode><Count>10</Count></PLine>\\n\" +\n+                        \"            <PLine><ItemCode>223300</ItemCode><Count>7</Count></PLine>\\n\" +\n+                        \"            <PLine><ItemCode discount=\\\"22%\\\">200777</ItemCode><Count>7</Count></PLine>\\n\" +\n+                        \"        </PurchesedItems>\\n\" +\n+                        \"        <Address xmlns=\\\"\\\">\\n\" +\n+                        \"            <StreetAddress>20, Palm grove, Colombo 3</StreetAddress>\\n\" +\n+                        \"            <City>Colombo</City>\\n\" +\n+                        \"            <Zip>00300</Zip>\\n\" +\n+                        \"            <Country>LK</Country>\\n\" +\n+                        \"        </Address>\\n\" +\n+                        \"    </Invoice>\",\n+                \"{\\\"Invoice\\\":{\\\"Invoice\\\":[\\\"\\\\n        \\\", {\\\"PurchesedItems\\\":[\\\"\\\\n            \\\", \" +\n+                        \"{\\\"PLine\\\":{\\\"ItemCode\\\":{\\\"ItemCode\\\":\\\"223345\\\", \\\"@xmlns\\\":\\\"example.com\\\"}, \" +\n+                        \"\\\"Count\\\":{\\\"Count\\\":\\\"10\\\", \\\"@xmlns\\\":\\\"example.com\\\"}}, \\\"@xmlns\\\":\\\"example.com\\\"}, \" +\n+                        \"\\\"\\\\n            \\\", \" +\n+                        \"{\\\"PLine\\\":{\\\"ItemCode\\\":{\\\"ItemCode\\\":\\\"223300\\\", \\\"@xmlns\\\":\\\"example.com\\\"}, \" +\n+                        \"\\\"Count\\\":{\\\"Count\\\":\\\"7\\\", \\\"@xmlns\\\":\\\"example.com\\\"}}, \\\"@xmlns\\\":\\\"example.com\\\"}, \" +\n+                        \"\\\"\\\\n            \\\", \" +\n+                        \"{\\\"PLine\\\":{\\\"ItemCode\\\":{\\\"ItemCode\\\":\\\"200777\\\", \\\"@xmlns\\\":\\\"example.com\\\", \" +\n+                        \"\\\"@discount\\\":\\\"22%\\\"}, \\\"Count\\\":{\\\"Count\\\":\\\"7\\\", \\\"@xmlns\\\":\\\"example.com\\\"}}, \" +\n+                        \"\\\"@xmlns\\\":\\\"example.com\\\"}, \\\"\\\\n        \\\"], \\\"@xmlns\\\":\\\"example.com\\\"}, \" +\n+                        \"\\\"\\\\n        \\\", \" +\n+                        \"{\\\"Address\\\":[\\\"\\\\n            \\\", \" +\n+                        \"{\\\"StreetAddress\\\":\\\"20, Palm grove, Colombo 3\\\"}, \\\"\\\\n            \\\", \" +\n+                        \"{\\\"City\\\":\\\"Colombo\\\"}, \\\"\\\\n            \\\", {\\\"Zip\\\":\\\"00300\\\"}, \\\"\\\\n            \\\", \" +\n+                        \"{\\\"Country\\\":\\\"LK\\\"}, \\\"\\\\n        \\\"], \\\"@xmlns\\\":\\\"\\\"}, \\\"\\\\n    \\\"], \" +\n+                        \"\\\"@xmlns\\\":\\\"example.com\\\", \\\"@attr\\\":\\\"attr-val\\\", \\\"@ns:attr\\\":\\\"ns-attr-val\\\", \" +\n+                        \"\\\"@xmlns:ns\\\":\\\"ns.com\\\"}}\");\n     }\n \n     @Test\n-    public void testFromTableFunction2() {\n-        BValue[] returns = BRunUtil.invoke(result, \"testFromTable2\");\n+    public void testUsingConvertedJsonValue() {\n+        BValue[] res = BRunUtil.invoke(result, \"testUsingConvertedJsonValue\");\n+        Assert.assertEquals(res[0].stringValue(), \"BCD:ZZZ\");\n+    }\n+\n+    @Test\n+    public void testXmlToJsonToPInfo() {\n+        BValue[] res = BRunUtil.invoke(result, \"testXmlToJsonToPInfo\");\n+        Assert.assertEquals(res[0].stringValue(), \"{name:\\\"Jane\\\", age:\\\"33\\\", gender:\\\"not-specified\\\"}\");\n+    }\n+\n+    @Test\n+    public void testXMLWithEmptyChildren() {\n+        BValue[] returns = BRunUtil.invoke(result, \"testXMLWithEmptyChildren\");\n         Assert.assertNotNull(returns[0]);\n-        Assert.assertEquals(returns[0].stringValue(),\n-                \"[{\\\"id\\\":1, \\\"name\\\":\\\"Mary\\\", \\\"salary\\\":300.5, \\\"permanent\\\":true, \" +\n-                        \"\\\"dependents\\\":[\\\"Mike\\\", \\\"Rachel\\\"], \" +\n-                        \"\\\"contact\\\":{\" +\n-                            \"\\\"phone\\\":[445566, 778877], \" +\n-                            \"\\\"address\\\":{\\\"number\\\":34, \\\"street\\\":\\\"Straford\\\"}, \" +\n-                        \"\\\"emergency\\\":\\\"Stephen\\\"}}, \" +\n-                        \"{\\\"id\\\":2, \\\"name\\\":\\\"John\\\", \\\"salary\\\":200.5, \\\"permanent\\\":false, \" +\n-                        \"\\\"dependents\\\":[\\\"Kyle\\\"],\" +\n-                        \" \\\"contact\\\":{\" +\n-                            \"\\\"phone\\\":[6060606, 556644], \\\"address\\\":{\\\"number\\\":10, \\\"street\\\":\\\"Oxford\\\"}, \" +\n-                        \"\\\"emergency\\\":\\\"Elizabeth\\\"}}, \" +\n-                        \"{\\\"id\\\":3, \\\"name\\\":\\\"Jim\\\", \\\"salary\\\":330.5, \\\"permanent\\\":true, \" +\n-                        \"\\\"dependents\\\":[], \" +\n-                        \"\\\"contact\\\":{\" +\n-                            \"\\\"phone\\\":[960960, 889889], \" +\n-                            \"\\\"address\\\":{\\\"number\\\":46, \\\"street\\\":\\\"Queens\\\"}, \" +\n-                        \"\\\"emergency\\\":\\\"Veronica\\\"}}]\");\n+        Assert.assertEquals(returns[0].stringValue(), \"{\\\"foo\\\":{\\\"bar\\\":\\\"2\\\", \\\"car\\\":\\\"\\\"}}\");", "originalCommit": "97a429a4045b65a05ab12eb0cb9cd82aa12385c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY3NTgwNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24406#discussion_r460675805", "bodyText": "And in Ballerina, shall we assert the value itself, without converting to string?", "author": "MaryamZi", "createdAt": "2020-07-27T06:38:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY3NTMxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY3Njc1OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24406#discussion_r460676759", "bodyText": "You mean to create the complete json value and assert or assert specific bits?", "author": "rdhananjaya", "createdAt": "2020-07-27T06:41:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY3NTMxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY3OTAwMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24406#discussion_r460679002", "bodyText": "We can create the complete value and assert against it right?", "author": "MaryamZi", "createdAt": "2020-07-27T06:47:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY3NTMxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY4NTE5NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24406#discussion_r460685195", "bodyText": "For simple json values like this one, we can do it, but I don't think it's a productive thing to do for bit complex cases like in L:77.", "author": "rdhananjaya", "createdAt": "2020-07-27T07:03:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY3NTMxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgxNjA2MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24406#discussion_r460816060", "bodyText": "Then maybe we can have a set of tests that cover the creation of new values, like conversion to arrays and maps, where we actually assert against the value and maybe a separate set to cover composite scenarios.\nMy concern with string representations is that we don't assert the actual type. For example, here this could be a string itself or the string representation of a JSON object, right? And this can go on for nested values too.", "author": "MaryamZi", "createdAt": "2020-07-27T11:10:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY3NTMxMA=="}], "type": "inlineReview"}, {"oid": "a450e1dc9ca66cd7703af31981379be605daf238", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a450e1dc9ca66cd7703af31981379be605daf238", "message": "Add few test cases comparing ballerina json vals", "committedDate": "2020-08-04T06:45:39Z", "type": "commit"}, {"oid": "8b42a19ccf53442514dc8702c708d677dd7cf870", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8b42a19ccf53442514dc8702c708d677dd7cf870", "message": "Update stdlib/jsonutils/src/test/resources/test-src/jsonutils_test.bal", "committedDate": "2020-08-04T09:01:18Z", "type": "commit"}]}