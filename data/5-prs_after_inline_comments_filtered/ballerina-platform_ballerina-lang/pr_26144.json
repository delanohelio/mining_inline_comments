{"pr_number": 26144, "pr_title": "Implement mapping-match-pattern", "pr_createdAt": "2020-09-28T14:12:07Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144", "timeline": [{"oid": "350b2303816107f65442f9b83cb853e1158ec3b4", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/350b2303816107f65442f9b83cb853e1158ec3b4", "message": "Enable tests", "committedDate": "2020-10-05T10:38:50Z", "type": "forcePushed"}, {"oid": "53c49cecef51da58516076e79d9e3a72aabaaae0", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/53c49cecef51da58516076e79d9e3a72aabaaae0", "message": "Enable tests", "committedDate": "2020-10-06T05:49:28Z", "type": "forcePushed"}, {"oid": "f6adfbcf4f81049289f9ef550ece11e3be7a8b7e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f6adfbcf4f81049289f9ef550ece11e3be7a8b7e", "message": "Rebase with master", "committedDate": "2020-10-19T09:00:30Z", "type": "forcePushed"}, {"oid": "1ba840594a125c0163957673f62aaba61bb56f5c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1ba840594a125c0163957673f62aaba61bb56f5c", "message": "Add tests", "committedDate": "2020-10-23T04:46:39Z", "type": "forcePushed"}, {"oid": "c8e24ab9baa7970f4d12358d6b4a62310cb16c82", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c8e24ab9baa7970f4d12358d6b4a62310cb16c82", "message": "Add tests", "committedDate": "2020-10-23T04:59:48Z", "type": "forcePushed"}, {"oid": "092cfbe5bebb9b77f71bfa6732b3e57c30d02e62", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/092cfbe5bebb9b77f71bfa6732b3e57c30d02e62", "message": "Add tests", "committedDate": "2020-10-23T05:18:30Z", "type": "forcePushed"}, {"oid": "85716441863b970c3dbba302c08cb4ed3e55fa06", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/85716441863b970c3dbba302c08cb4ed3e55fa06", "message": "Disable a formatter test", "committedDate": "2020-11-02T19:17:46Z", "type": "forcePushed"}, {"oid": "b00e917509b394720d660bdc253245fcc333d346", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b00e917509b394720d660bdc253245fcc333d346", "message": "Disable a formatter test", "committedDate": "2020-11-03T11:37:23Z", "type": "forcePushed"}, {"oid": "6bb24bce0a62d65e933f2d8f3bff8b5d4381b5b6", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6bb24bce0a62d65e933f2d8f3bff8b5d4381b5b6", "message": "Add more tests", "committedDate": "2020-11-04T14:56:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI3ODMyMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r520278323", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @since Swan Lake\n          \n          \n            \n             * @since 2.0.0\n          \n      \n    \n    \n  \n\nPlease fix in other new classes too.", "author": "MaryamZi", "createdAt": "2020-11-10T04:26:13Z", "path": "compiler/ballerina-lang/src/main/java/org/ballerinalang/model/tree/matchpatterns/FieldMatchPatternNode.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.model.tree.matchpatterns;\n+\n+import org.ballerinalang.model.tree.IdentifierNode;\n+import org.ballerinalang.model.tree.Node;\n+\n+/**\n+ * The interface with the APIs to implement the field-match-pattern.\n+ *\n+ * @since Swan Lake", "originalCommit": "6bb24bce0a62d65e933f2d8f3bff8b5d4381b5b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgyMTM0Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r521821343", "bodyText": "Changed.", "author": "KavinduZoysa", "createdAt": "2020-11-12T04:00:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI3ODMyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI4MDA2Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r520280063", "bodyText": "Shall we move this to the end and assert against i? That way we will assert all the errors in the future too.\nAssert.assertEquals(resultNegative.getErrorCount(), i);\nWill have to change i's initial value and switch to i++.", "author": "MaryamZi", "createdAt": "2020-11-10T04:33:05Z", "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/matchstmt/MatchStmtMappingMatchPatternTest.java", "diffHunk": "@@ -0,0 +1,198 @@\n+// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+//\n+// WSO2 Inc. licenses this file to you under the Apache License,\n+// Version 2.0 (the \"License\"); you may not use this file except\n+// in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package org.ballerinalang.test.statements.matchstmt;\n+\n+import org.ballerinalang.test.util.BAssertUtil;\n+import org.ballerinalang.test.util.BCompileUtil;\n+import org.ballerinalang.test.util.BRunUtil;\n+import org.ballerinalang.test.util.CompileResult;\n+import org.testng.Assert;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * Test cases to verify the behaviour of the mapping-match-pattern.\n+ *\n+ * @since Swan Lake\n+ */\n+@Test(groups = { \"disableOnOldParser\" })\n+public class MatchStmtMappingMatchPatternTest {\n+\n+    private CompileResult result, resultNegative, resultRestPattern;\n+    private String patternNotMatched = \"pattern will not be matched\";\n+    private String unreachablePattern = \"unreachable pattern\";\n+\n+    @BeforeClass\n+    public void setup() {\n+        result = BCompileUtil.compile(\"test-src/statements/matchstmt/mapping-match-pattern.bal\");\n+        resultRestPattern = BCompileUtil.compile(\"test-src/statements/matchstmt/mapping-match-pattern-with-rest-match\" +\n+                \"-pattern.bal\");\n+        resultNegative = BCompileUtil.compile(\"test-src/statements/matchstmt/mapping-mach-pattern-negative.bal\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern1() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern1\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern2() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern2\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern3() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern3\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern4() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern4\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern5() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern5\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern6() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern6\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern7() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern7\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern8() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern8\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern9() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern9\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern10() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern10\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern11() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern11\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern12() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern12\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern13() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern13\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern14() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern14\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern15() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern15\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern16() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern16\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern17() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern17\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern18() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern18\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern19() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern19\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern20() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern20\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern21() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern21\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern22() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern22\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPattern23() {\n+        BRunUtil.invoke(result, \"testMappingMatchPattern23\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPatternWithRestPattern1() {\n+        BRunUtil.invoke(resultRestPattern, \"testMappingMatchPattern1\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPatternWithRestPattern2() {\n+        BRunUtil.invoke(resultRestPattern, \"testMappingMatchPattern2\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPatternWithRestPattern3() {\n+        BRunUtil.invoke(resultRestPattern, \"testMappingMatchPattern3\");\n+    }\n+\n+    @Test\n+    public void testMappingMatchPatternNegative() {\n+        Assert.assertEquals(resultNegative.getErrorCount(), 16);", "originalCommit": "6bb24bce0a62d65e933f2d8f3bff8b5d4381b5b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgyMTQ4MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r521821481", "bodyText": "+1", "author": "KavinduZoysa", "createdAt": "2020-11-12T04:00:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI4MDA2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI4MTY5NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r520281695", "bodyText": "Shall we make these constants?", "author": "MaryamZi", "createdAt": "2020-11-10T04:39:32Z", "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/matchstmt/MatchStmtMappingMatchPatternTest.java", "diffHunk": "@@ -0,0 +1,198 @@\n+// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+//\n+// WSO2 Inc. licenses this file to you under the Apache License,\n+// Version 2.0 (the \"License\"); you may not use this file except\n+// in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+package org.ballerinalang.test.statements.matchstmt;\n+\n+import org.ballerinalang.test.util.BAssertUtil;\n+import org.ballerinalang.test.util.BCompileUtil;\n+import org.ballerinalang.test.util.BRunUtil;\n+import org.ballerinalang.test.util.CompileResult;\n+import org.testng.Assert;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * Test cases to verify the behaviour of the mapping-match-pattern.\n+ *\n+ * @since Swan Lake\n+ */\n+@Test(groups = { \"disableOnOldParser\" })\n+public class MatchStmtMappingMatchPatternTest {\n+\n+    private CompileResult result, resultNegative, resultRestPattern;\n+    private String patternNotMatched = \"pattern will not be matched\";\n+    private String unreachablePattern = \"unreachable pattern\";", "originalCommit": "6bb24bce0a62d65e933f2d8f3bff8b5d4381b5b6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI4MzEzMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r520283131", "bodyText": "Shall we add at least a brief description? Please check other classes too.", "author": "MaryamZi", "createdAt": "2020-11-10T04:45:10Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/tree/matchpatterns/BLangMappingMatchPattern.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.tree.matchpatterns;\n+\n+import org.ballerinalang.model.tree.NodeKind;\n+import org.ballerinalang.model.tree.matchpatterns.FieldMatchPatternNode;\n+import org.ballerinalang.model.tree.matchpatterns.MappingMatchPatternNode;\n+import org.ballerinalang.model.tree.matchpatterns.RestMatchPatternNode;\n+import org.wso2.ballerinalang.compiler.tree.BLangNodeVisitor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * @since Swan Lake", "originalCommit": "6bb24bce0a62d65e933f2d8f3bff8b5d4381b5b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgyMTgzNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r521821837", "bodyText": "Added", "author": "KavinduZoysa", "createdAt": "2020-11-12T04:01:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI4MzEzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI4MzE4NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r520283184", "bodyText": "Is this still relevant?", "author": "MaryamZi", "createdAt": "2020-11-10T04:45:22Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/tree/matchpatterns/BLangMappingMatchPattern.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.tree.matchpatterns;\n+\n+import org.ballerinalang.model.tree.NodeKind;\n+import org.ballerinalang.model.tree.matchpatterns.FieldMatchPatternNode;\n+import org.ballerinalang.model.tree.matchpatterns.MappingMatchPatternNode;\n+import org.ballerinalang.model.tree.matchpatterns.RestMatchPatternNode;\n+import org.wso2.ballerinalang.compiler.tree.BLangNodeVisitor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * @since Swan Lake\n+ */\n+public class BLangMappingMatchPattern extends BLangMatchPattern implements MappingMatchPatternNode {\n+\n+    public List<BLangFieldMatchPattern> fieldMatchPatterns = new ArrayList<>();\n+    public BLangRestMatchPattern restMatchPattern;\n+    // TODO : add rest-match-pattern", "originalCommit": "6bb24bce0a62d65e933f2d8f3bff8b5d4381b5b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgyMTk2Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r521821967", "bodyText": "No, removed", "author": "KavinduZoysa", "createdAt": "2020-11-12T04:01:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI4MzE4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI4MzIzNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r520283234", "bodyText": "Extra new line inconsistent with the rest of the class?", "author": "MaryamZi", "createdAt": "2020-11-10T04:45:39Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/tree/matchpatterns/BLangMappingMatchPattern.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.tree.matchpatterns;\n+\n+import org.ballerinalang.model.tree.NodeKind;\n+import org.ballerinalang.model.tree.matchpatterns.FieldMatchPatternNode;\n+import org.ballerinalang.model.tree.matchpatterns.MappingMatchPatternNode;\n+import org.ballerinalang.model.tree.matchpatterns.RestMatchPatternNode;\n+import org.wso2.ballerinalang.compiler.tree.BLangNodeVisitor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * @since Swan Lake\n+ */\n+public class BLangMappingMatchPattern extends BLangMatchPattern implements MappingMatchPatternNode {\n+\n+    public List<BLangFieldMatchPattern> fieldMatchPatterns = new ArrayList<>();\n+    public BLangRestMatchPattern restMatchPattern;\n+    // TODO : add rest-match-pattern\n+\n+    @Override\n+    public void accept(BLangNodeVisitor visitor) {\n+        visitor.visit(this);\n+    }\n+\n+    @Override\n+    public NodeKind getKind() {\n+        return NodeKind.MAPPING_MATCH_PATTERN;\n+    }\n+\n+    @Override\n+    public List<? extends FieldMatchPatternNode> getFieldMatchPatterns() {\n+", "originalCommit": "6bb24bce0a62d65e933f2d8f3bff8b5d4381b5b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgyMjA5Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r521822093", "bodyText": "Removed.", "author": "KavinduZoysa", "createdAt": "2020-11-12T04:01:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI4MzIzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI4Mzk4Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r520283986", "bodyText": "@pubudu91, along with your recent changes, we need to set the ANONYMOUS flag here, right?", "author": "MaryamZi", "createdAt": "2020-11-10T04:48:40Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SemanticAnalyzer.java", "diffHunk": "@@ -2345,6 +2348,136 @@ public void visit(BLangMatchGuard matchGuard) {\n         matchGuard.expr.accept(this);\n     }\n \n+    @Override\n+    public void visit(BLangMappingMatchPattern mappingMatchPattern) {\n+        BRecordTypeSymbol recordSymbol =\n+                Symbols.createRecordSymbol(0, names.fromString(\"$anonRecordType$\" + recordCount++),", "originalCommit": "6bb24bce0a62d65e933f2d8f3bff8b5d4381b5b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjY2NDAzMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r522664031", "bodyText": "Since this is a VIRTUAL symbol, it doesn't really matter. But I think as a best practice, it's better to treat any additional symbols that we create for desugared/inferred components/types just as we do for constructs in code and try to give as much as accurate details when creating the symbols (in this case, the ANONYMOUS flag).\n@KavinduZoysa Also, any particular reason not to use BLangAnonymousModelHelper to generate the anon name?", "author": "pubudu91", "createdAt": "2020-11-13T05:28:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI4Mzk4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzUzMjcyMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r527532720", "bodyText": "Fixed", "author": "KavinduZoysa", "createdAt": "2020-11-20T08:50:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI4Mzk4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI4NDUyMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r520284523", "bodyText": "Can't/shouldn't we call analyzeNode instead of directly calling accept?", "author": "MaryamZi", "createdAt": "2020-11-10T04:50:20Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SemanticAnalyzer.java", "diffHunk": "@@ -2345,6 +2348,136 @@ public void visit(BLangMatchGuard matchGuard) {\n         matchGuard.expr.accept(this);\n     }\n \n+    @Override\n+    public void visit(BLangMappingMatchPattern mappingMatchPattern) {\n+        BRecordTypeSymbol recordSymbol =\n+                Symbols.createRecordSymbol(0, names.fromString(\"$anonRecordType$\" + recordCount++),\n+                        env.enclPkg.symbol.pkgID, null, env.scope.owner, mappingMatchPattern.pos, VIRTUAL);\n+        LinkedHashMap<String, BField> fields = new LinkedHashMap<>();\n+\n+        for (BLangFieldMatchPattern fieldMatchPattern : mappingMatchPattern.fieldMatchPatterns) {\n+            fieldMatchPattern.accept(this);", "originalCommit": "6bb24bce0a62d65e933f2d8f3bff8b5d4381b5b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgyMjMwNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r521822306", "bodyText": "Chnaged", "author": "KavinduZoysa", "createdAt": "2020-11-12T04:02:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI4NDUyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5MDU3Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r520290576", "bodyText": "Don't we have to reset this?", "author": "MaryamZi", "createdAt": "2020-11-10T05:13:03Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -367,6 +373,19 @@ public BType resolvePatternTypeFromMatchExpr(BLangExpression matchExpr, BLangExp\n         return symTable.noType;\n     }\n \n+    public BType resolvePatternTypeFromMatchExpr(BLangMappingMatchPattern mappingMatchPattern, BType patternType,\n+                                                 SymbolEnv env) {\n+        if (mappingMatchPattern.matchExpr == null) {\n+            return patternType;\n+        }\n+        this.env = env;", "originalCommit": "6bb24bce0a62d65e933f2d8f3bff8b5d4381b5b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzUzMjc2NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r527532764", "bodyText": "Changed", "author": "KavinduZoysa", "createdAt": "2020-11-20T08:50:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5MDU3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5NDUxMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r520294513", "bodyText": "The rest match pattern needs to allow for all unmatched fields which can include non-rest fields in the case of a record.\nThe following doesn't fail atm.\npublic function main() {\n    record {|\n        int a;\n        int b;\n        string...;\n    |} x = {a : 2, b: 3};\n\n    match x {\n        {a: 2, ...var rst} => {\n            map<string> mp = rst; // no compilation error, even though the type of `rst`\n                                  // is `record {|int b; string...;|}`  \n        }\n    }\n}", "author": "MaryamZi", "createdAt": "2020-11-10T05:27:00Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SemanticAnalyzer.java", "diffHunk": "@@ -2345,6 +2348,136 @@ public void visit(BLangMatchGuard matchGuard) {\n         matchGuard.expr.accept(this);\n     }\n \n+    @Override\n+    public void visit(BLangMappingMatchPattern mappingMatchPattern) {\n+        BRecordTypeSymbol recordSymbol =\n+                Symbols.createRecordSymbol(0, names.fromString(\"$anonRecordType$\" + recordCount++),\n+                        env.enclPkg.symbol.pkgID, null, env.scope.owner, mappingMatchPattern.pos, VIRTUAL);\n+        LinkedHashMap<String, BField> fields = new LinkedHashMap<>();\n+\n+        for (BLangFieldMatchPattern fieldMatchPattern : mappingMatchPattern.fieldMatchPatterns) {\n+            fieldMatchPattern.accept(this);\n+            String fieldName = fieldMatchPattern.fieldName.value;\n+            BVarSymbol fieldSymbol = new BVarSymbol(0, names.fromString(fieldName), env.enclPkg.symbol.pkgID,\n+                    fieldMatchPattern.matchPattern.type, recordSymbol, fieldMatchPattern.pos, COMPILED_SOURCE);\n+            BField field = new BField(names.fromString(fieldName), fieldMatchPattern.pos, fieldSymbol);\n+            fields.put(fieldName, field);\n+            mappingMatchPattern.declaredVars.putAll(fieldMatchPattern.declaredVars);\n+        }\n+        BRecordType recordVarType = new BRecordType(recordSymbol);\n+        recordVarType.fields = fields;\n+        recordVarType.restFieldType = symTable.anydataType;\n+        if (mappingMatchPattern.restMatchPattern != null) {", "originalCommit": "6bb24bce0a62d65e933f2d8f3bff8b5d4381b5b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgyMjQ3Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r521822477", "bodyText": "Fixed", "author": "KavinduZoysa", "createdAt": "2020-11-12T04:02:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5NDUxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5NTgyMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r520295821", "bodyText": "Types is like a stateless util class, so IMO, we shouldn't do this. Can't we pass the env from wherever the methods are called?", "author": "MaryamZi", "createdAt": "2020-11-10T05:29:07Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -128,6 +132,8 @@\n     private Names names;\n     private int finiteTypeCount = 0;\n     private BUnionType expandedXMLBuiltinSubtypes;\n+    private int recordCount = 0;\n+    private SymbolEnv env;", "originalCommit": "6bb24bce0a62d65e933f2d8f3bff8b5d4381b5b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQxNTU5MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r521415590", "bodyText": "Even with this approach, just setting env for match won't work well with other places that call getTypeIntersection.\nFor example, the following results in a bad, sad error due to env being null.\npublic function main() {\n    map<int> m = {a: 1};\n\n    if m is record {int a;} {\n        \n    }\n}\n[2020-11-11 20:24:19,518] SEVERE {b7a.log.crash} - null \njava.lang.NullPointerException\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.Types.getTypeForRecordTypeMembersAssignableToType(Types.java:2813)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.Types.getTypeForMapTypeMembersAssignableToType(Types.java:2804)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.Types.lambda$getTypeIntersection$51(Types.java:3198)\n\tat java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:195)\n\tat java.base/java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1654)\n\tat java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484)\n\tat java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474)\n\tat java.base/java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:913)\n\tat java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)\n\tat java.base/java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:578)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.Types.getTypeIntersection(Types.java:3211)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.TypeNarrower.visit(TypeNarrower.java:194)\n\tat org.wso2.ballerinalang.compiler.tree.expressions.BLangTypeTestExpr.accept(BLangTypeTestExpr.java:65)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.TypeNarrower.analyzeExpr(TypeNarrower.java:224)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.TypeNarrower.getNarrowedTypes(TypeNarrower.java:202)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.TypeNarrower.evaluateTruth(TypeNarrower.java:92)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.TypeNarrower.evaluateTruth(TypeNarrower.java:114)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SemanticAnalyzer.visit(SemanticAnalyzer.java:2282)\n\tat org.wso2.ballerinalang.compiler.tree.statements.BLangIf.accept(BLangIf.java:56)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SemanticAnalyzer.analyzeNode(SemanticAnalyzer.java:3047)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SemanticAnalyzer.analyzeNode(SemanticAnalyzer.java:3015)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SemanticAnalyzer.analyzeStmt(SemanticAnalyzer.java:3011)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SemanticAnalyzer.visit(SemanticAnalyzer.java:392)\n\tat org.wso2.ballerinalang.compiler.tree.BLangBlockFunctionBody.accept(BLangBlockFunctionBody.java:58)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SemanticAnalyzer.analyzeNode(SemanticAnalyzer.java:3047)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SemanticAnalyzer.visit(SemanticAnalyzer.java:364)\n\tat org.wso2.ballerinalang.compiler.tree.BLangFunction.accept(BLangFunction.java:73)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SemanticAnalyzer.analyzeNode(SemanticAnalyzer.java:3047)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SemanticAnalyzer.analyzeNode(SemanticAnalyzer.java:3015)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SemanticAnalyzer.analyzeDef(SemanticAnalyzer.java:3007)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SemanticAnalyzer.visit(SemanticAnalyzer.java:280)\n\tat org.wso2.ballerinalang.compiler.tree.BLangPackage.accept(BLangPackage.java:163)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SemanticAnalyzer.analyze(SemanticAnalyzer.java:254)\n\tat org.wso2.ballerinalang.compiler.CompilerDriver.typeCheck(CompilerDriver.java:347)\n\tat org.wso2.ballerinalang.compiler.CompilerDriver.compile(CompilerDriver.java:276)\n\tat org.wso2.ballerinalang.compiler.CompilerDriver.compilePackageSymbol(CompilerDriver.java:268)\n\tat org.wso2.ballerinalang.compiler.CompilerDriver.compilePackage(CompilerDriver.java:144)\n\tat org.wso2.ballerinalang.compiler.Compiler.compilePackages(Compiler.java:176)\n\tat org.wso2.ballerinalang.compiler.Compiler.compilePackage(Compiler.java:221)\n\tat org.wso2.ballerinalang.compiler.Compiler.compile(Compiler.java:101)\n\tat org.wso2.ballerinalang.compiler.Compiler.build(Compiler.java:109)\n\tat org.ballerinalang.packerina.task.CompileTask.execute(CompileTask.java:55)\n\tat org.ballerinalang.packerina.TaskExecutor.executeTasks(TaskExecutor.java:38)\n\tat org.ballerinalang.packerina.cmd.RunCommand.execute(RunCommand.java:297)\n\tat java.base/java.util.Optional.ifPresent(Optional.java:183)\n\tat org.ballerinalang.tool.Main.main(Main.java:57)", "author": "MaryamZi", "createdAt": "2020-11-11T14:56:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5NTgyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQxNTk3OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r521415978", "bodyText": "I think we'll have to fix this by making getTypeIntersection accept the env.", "author": "MaryamZi", "createdAt": "2020-11-11T14:57:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5NTgyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzUzMjgwMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r527532801", "bodyText": "Changed", "author": "KavinduZoysa", "createdAt": "2020-11-20T08:50:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5NTgyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5NzI4NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r520297284", "bodyText": "Neither any nor anydata contain error. So shouldn't we check what the other type is here?", "author": "MaryamZi", "createdAt": "2020-11-10T05:31:17Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -380,10 +399,32 @@ private boolean containsAnyType(BType type) {\n         return false;\n     }\n \n+    private boolean containsAnyDataType(BType type) {\n+        if (type.tag != TypeTags.UNION) {\n+            return type.tag == TypeTags.ANYDATA;\n+        }\n+\n+        for (BType memberTypes : ((BUnionType) type).getMemberTypes()) {\n+            if (memberTypes.tag == TypeTags.ANYDATA) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n     public BType mergeTypes(BType typeFirst, BType typeSecond) {\n         if (containsAnyType(typeFirst)) {\n             return typeSecond;\n         }\n+        if (containsAnyType(typeSecond)) {\n+            return typeFirst;\n+        }\n+        if (containsAnyDataType(typeFirst)) {\n+            return typeSecond;\n+        }\n+        if (containsAnyDataType(typeSecond)) {\n+            return typeFirst;\n+        }", "originalCommit": "6bb24bce0a62d65e933f2d8f3bff8b5d4381b5b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzUzMjkxMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r527532911", "bodyText": "Yes, fixed", "author": "KavinduZoysa", "createdAt": "2020-11-20T08:50:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5NzI4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5NzY2MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r520297661", "bodyText": "Shouldn't we create a new BMapType here instead of updating the parameter?", "author": "MaryamZi", "createdAt": "2020-11-10T05:32:52Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2756,6 +2788,61 @@ BType getTypeForUnionTypeMembersAssignableToType(BUnionType unionType, BType tar\n         }\n     }\n \n+    BType getTypeForMapTypeMembersAssignableToType(BMapType mapType, BType targetType) {\n+        if (targetType.tag != TypeTags.MAP && targetType.tag != TypeTags.RECORD) {\n+            return symTable.semanticError;\n+        }\n+        if (targetType.tag == TypeTags.MAP) {\n+            BType intersectionConstraintType = getTypeIntersection(mapType.constraint,\n+                    ((BMapType) targetType).constraint);\n+            if (intersectionConstraintType != symTable.semanticError) {\n+                return symTable.semanticError;\n+            }\n+            mapType.constraint = intersectionConstraintType;", "originalCommit": "6bb24bce0a62d65e933f2d8f3bff8b5d4381b5b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgyMjY0MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r521822640", "bodyText": "I cannot find any special reason to do so. Is there any reason?", "author": "KavinduZoysa", "createdAt": "2020-11-12T04:02:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5NzY2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgzNDQ0OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r521834448", "bodyText": "Update the type passed as a parameter can cause different errors elsewhere.\nFor example, check\npublic function main() {\n    map<int|boolean> m1 = {};\n\n    if m1 is map<string> {\n       \n    }\n\n    map<int> x = m1;\n}\nThe error for this on slp5 is\nincompatible types: expected 'map<int>', found 'map<(int|boolean)>'\nBut with this change it is\nincompatible types: expected 'map<int>', found 'map<other>'", "author": "MaryamZi", "createdAt": "2020-11-12T04:37:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5NzY2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgzNDY4MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r521834681", "bodyText": "Anyway why do we return symTable.semanticError if intersectionConstraintType != symTable.semanticError?\nDoesn't intersectionConstraintType != symTable.semanticError mean the intersection is valid?", "author": "MaryamZi", "createdAt": "2020-11-12T04:39:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5NzY2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTkzMjAyMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r521932020", "bodyText": "It is fixed.", "author": "KavinduZoysa", "createdAt": "2020-11-12T08:44:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI5NzY2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDMwMjU1Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r520302557", "bodyText": "Are these names accurate? Just gets the intersection, right?", "author": "MaryamZi", "createdAt": "2020-11-10T05:49:44Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2756,6 +2788,61 @@ BType getTypeForUnionTypeMembersAssignableToType(BUnionType unionType, BType tar\n         }\n     }\n \n+    BType getTypeForMapTypeMembersAssignableToType(BMapType mapType, BType targetType) {", "originalCommit": "6bb24bce0a62d65e933f2d8f3bff8b5d4381b5b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgyMjcyMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r521822720", "bodyText": "Changed", "author": "KavinduZoysa", "createdAt": "2020-11-12T04:02:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDMwMjU1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDMwMzE1NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r520303155", "bodyText": "Aren't we implementing record-record intersection here? If so shouldn't we change the check in L2808 to just\ntargetType.tag != TypeTags.MAP\n@dulvinw is probably implementing record-record intersection though.", "author": "MaryamZi", "createdAt": "2020-11-10T05:51:37Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2756,6 +2788,61 @@ BType getTypeForUnionTypeMembersAssignableToType(BUnionType unionType, BType tar\n         }\n     }\n \n+    BType getTypeForMapTypeMembersAssignableToType(BMapType mapType, BType targetType) {\n+        if (targetType.tag != TypeTags.MAP && targetType.tag != TypeTags.RECORD) {\n+            return symTable.semanticError;\n+        }\n+        if (targetType.tag == TypeTags.MAP) {\n+            BType intersectionConstraintType = getTypeIntersection(mapType.constraint,\n+                    ((BMapType) targetType).constraint);\n+            if (intersectionConstraintType != symTable.semanticError) {\n+                return symTable.semanticError;\n+            }\n+            mapType.constraint = intersectionConstraintType;\n+            return mapType;\n+        }\n+        return getTypeForRecordTypeMembersAssignableToType((BRecordType) targetType, mapType);\n+    }\n+\n+    BType getTypeForRecordTypeMembersAssignableToType(BRecordType recordType, BType targetType) {\n+        if (targetType.tag != TypeTags.MAP && targetType.tag != TypeTags.RECORD) {\n+            return symTable.semanticError;\n+        }\n+        if (targetType.tag == TypeTags.MAP) {\n+            BRecordTypeSymbol recordSymbol =\n+                    Symbols.createRecordSymbol(0, names.fromString(\"$anonRecordIntersectionType$\" + recordCount++),\n+                            env.enclPkg.symbol.pkgID, null, env.scope.owner, recordType.tsymbol.pos, VIRTUAL);\n+            LinkedHashMap<String, BField> fields = new LinkedHashMap<>();\n+            for (String key : recordType.fields.keySet()) {\n+                BType intersectionKeyType = getTypeIntersection(recordType.fields.get(key).type,\n+                        ((BMapType) targetType).constraint);\n+                if (intersectionKeyType == symTable.semanticError) {\n+                    return symTable.semanticError;\n+                }\n+                BVarSymbol fieldSymbol = new BVarSymbol(0, names.fromString(key), env.enclPkg.symbol.pkgID,\n+                        intersectionKeyType, recordSymbol, recordType.fields.get(key).pos, COMPILED_SOURCE);\n+                BField field = new BField(names.fromString(key), recordType.fields.get(key).pos, fieldSymbol);\n+                fields.put(key, field);\n+            }\n+            BRecordType intersectionRecordType = new BRecordType(recordSymbol);\n+            recordSymbol.type = intersectionRecordType;\n+            intersectionRecordType.fields = fields;\n+\n+            if (recordType.restFieldType != null) {\n+                BType intersectionRestType = getTypeIntersection(recordType.restFieldType,\n+                        ((BMapType) targetType).constraint);\n+                if (intersectionRestType == symTable.semanticError) {\n+                    intersectionRecordType.sealed = true;\n+                }\n+                intersectionRecordType.restFieldType = intersectionRestType;\n+            } else {\n+                intersectionRecordType.sealed = recordType.sealed;\n+            }\n+            return intersectionRecordType;\n+        }\n+        return symTable.semanticError;", "originalCommit": "6bb24bce0a62d65e933f2d8f3bff8b5d4381b5b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDkwNjkzMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r524906931", "bodyText": "This is added with the help of @dulvinw 's implementation.", "author": "KavinduZoysa", "createdAt": "2020-11-17T06:16:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDMwMzE1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDMwMzc5MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r520303790", "bodyText": "Is this still relevant?", "author": "MaryamZi", "createdAt": "2020-11-10T05:53:42Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/tree/matchpatterns/BLangMappingMatchPattern.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.tree.matchpatterns;\n+\n+import org.ballerinalang.model.tree.NodeKind;\n+import org.ballerinalang.model.tree.matchpatterns.FieldMatchPatternNode;\n+import org.ballerinalang.model.tree.matchpatterns.MappingMatchPatternNode;\n+import org.ballerinalang.model.tree.matchpatterns.RestMatchPatternNode;\n+import org.wso2.ballerinalang.compiler.tree.BLangNodeVisitor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * @since Swan Lake\n+ */\n+public class BLangMappingMatchPattern extends BLangMatchPattern implements MappingMatchPatternNode {\n+\n+    public List<BLangFieldMatchPattern> fieldMatchPatterns = new ArrayList<>();\n+    public BLangRestMatchPattern restMatchPattern;\n+    // TODO : add rest-match-pattern", "originalCommit": "6bb24bce0a62d65e933f2d8f3bff8b5d4381b5b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgyMjc3Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r521822777", "bodyText": "No, removed", "author": "KavinduZoysa", "createdAt": "2020-11-12T04:02:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDMwMzc5MA=="}], "type": "inlineReview"}, {"oid": "1f6b301ac68a9deeb1d4176dc36f1d668366101a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1f6b301ac68a9deeb1d4176dc36f1d668366101a", "message": "Fix review suggestions", "committedDate": "2020-11-12T04:09:59Z", "type": "forcePushed"}, {"oid": "eb08826815f53e2db2b5bc5da000cda33122c47c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/eb08826815f53e2db2b5bc5da000cda33122c47c", "message": "Fix review suggestions", "committedDate": "2020-11-12T08:43:26Z", "type": "forcePushed"}, {"oid": "366c9a4bacd059aa1c6d6e33fc04bd34c07e7d61", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/366c9a4bacd059aa1c6d6e33fc04bd34c07e7d61", "message": "Add record intersection", "committedDate": "2020-11-17T04:44:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM5NTk4NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r527395984", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @since Swan Lake\n          \n          \n            \n             * @since 2.0.0", "author": "MaryamZi", "createdAt": "2020-11-20T04:50:52Z", "path": "compiler/ballerina-lang/src/main/java/org/ballerinalang/model/tree/matchpatterns/MappingMatchPatternNode.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.model.tree.matchpatterns;\n+\n+import org.ballerinalang.model.tree.Node;\n+\n+import java.util.List;\n+\n+/**\n+ * The interface with the APIs to implement the mapping-match-pattern.\n+ *\n+ * @since Swan Lake", "originalCommit": "60633c4b0cba351b0952428c39168a63cc34d2df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzUzMzAxMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r527533011", "bodyText": "Fixed", "author": "KavinduZoysa", "createdAt": "2020-11-20T08:51:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM5NTk4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM5NzAyMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r527397023", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @since Swan Lake\n          \n          \n            \n             * @since 2.0.0", "author": "MaryamZi", "createdAt": "2020-11-20T04:54:50Z", "path": "compiler/ballerina-lang/src/main/java/org/ballerinalang/model/tree/matchpatterns/RestMatchPatternNode.java", "diffHunk": "@@ -18,13 +18,14 @@\n package org.ballerinalang.model.tree.matchpatterns;\n \n import org.ballerinalang.model.tree.IdentifierNode;\n+import org.ballerinalang.model.tree.Node;\n \n /**\n  * The interface with the APIs to implement the rest-match-pattern.\n  *\n- * @since 2.0.0\n+ * @since Swan Lake", "originalCommit": "60633c4b0cba351b0952428c39168a63cc34d2df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzUzMzMxMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r527533313", "bodyText": "Fixed", "author": "KavinduZoysa", "createdAt": "2020-11-20T08:51:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM5NzAyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQwMDkzOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r527400938", "bodyText": "Do we have an issue to track cleaning these up?", "author": "MaryamZi", "createdAt": "2020-11-20T05:09:58Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/BLangNodeTransformer.java", "diffHunk": "@@ -3916,23 +3927,53 @@ private BLangMatchPattern transformMatchPattern(Node matchPattern, Location matc\n             if (listMatchPatternNode.restMatchPattern().isPresent()) {\n                 RestMatchPatternNode restMatchPatternNode = listMatchPatternNode.restMatchPattern().get();\n                 bLangListMatchPattern.setRestMatchPattern(\n-                        (BLangRestMatchPattern) transformMatchPattern(restMatchPatternNode,\n-                                getPosition(restMatchPatternNode)));\n+                        (BLangRestMatchPattern) transformMatchPattern(restMatchPatternNode));\n             }\n             return bLangListMatchPattern;\n-        } else if (matchPattern.kind() == SyntaxKind.REST_MATCH_PATTERN) {\n+        }\n+\n+        if (kind == SyntaxKind.REST_MATCH_PATTERN) {\n             RestMatchPatternNode restMatchPatternNode = (RestMatchPatternNode) matchPattern;\n             BLangRestMatchPattern bLangRestMatchPattern = (BLangRestMatchPattern) TreeBuilder.createRestMatchPattern();\n             bLangRestMatchPattern.pos = matchPatternPos;\n \n             SimpleNameReferenceNode variableName = restMatchPatternNode.variableName();\n             bLangRestMatchPattern.setIdentifier(createIdentifier(getPosition(variableName), variableName.name()));\n             return bLangRestMatchPattern;\n-        } else {\n-            // TODO : Remove this after all binding patterns are implemented\n-            dlog.error(matchPatternPos, DiagnosticCode.MATCH_PATTERN_NOT_SUPPORTED);\n-            return null;\n         }\n+\n+        if (kind == SyntaxKind.MAPPING_MATCH_PATTERN) {\n+            MappingMatchPatternNode mappingMatchPatternNode = (MappingMatchPatternNode) matchPattern;\n+            BLangMappingMatchPattern bLangMappingMatchPattern =\n+                    (BLangMappingMatchPattern) TreeBuilder.createMappingMatchPattern();\n+            bLangMappingMatchPattern.pos = matchPatternPos;\n+\n+            for (FieldMatchPatternNode fieldMatchPatternNode : mappingMatchPatternNode.fieldMatchPatterns()) {\n+                bLangMappingMatchPattern.fieldMatchPatterns.add((BLangFieldMatchPattern)\n+                        transformMatchPattern(fieldMatchPatternNode));\n+            }\n+            if (mappingMatchPatternNode.restMatchPattern().isPresent()) {\n+                bLangMappingMatchPattern.restMatchPattern =\n+                        (BLangRestMatchPattern) transformMatchPattern(mappingMatchPatternNode.restMatchPattern().get());\n+            }\n+\n+            return bLangMappingMatchPattern;\n+        }\n+\n+        if (kind == SyntaxKind.FIELD_MATCH_PATTERN) {\n+            FieldMatchPatternNode fieldMatchPatternNode = (FieldMatchPatternNode) matchPattern;\n+            BLangFieldMatchPattern bLangFieldMatchPattern =\n+                    (BLangFieldMatchPattern) TreeBuilder.createFieldMatchPattern();\n+\n+            bLangFieldMatchPattern.fieldName =\n+                    createIdentifier(fieldMatchPatternNode.fieldNameNode());\n+            bLangFieldMatchPattern.matchPattern = transformMatchPattern(fieldMatchPatternNode.matchPattern());\n+            return bLangFieldMatchPattern;\n+        }\n+\n+        // TODO : Remove this after all binding patterns are implemented", "originalCommit": "60633c4b0cba351b0952428c39168a63cc34d2df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzU3NjU3Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r527576573", "bodyText": "#24607", "author": "KavinduZoysa", "createdAt": "2020-11-20T09:54:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQwMDkzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQwMTE3NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r527401175", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void visit(BLangFieldMatchPattern fieldMatchPattern) {}\n          \n          \n            \n                public void visit(BLangFieldMatchPattern fieldMatchPattern) {\n          \n          \n            \n                }", "author": "MaryamZi", "createdAt": "2020-11-20T05:10:33Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java", "diffHunk": "@@ -898,6 +900,13 @@ public void visit(BLangMatchClause matchClause) {\n         resetStatementReturns();\n     }\n \n+    @Override\n+    public void visit(BLangMappingMatchPattern mappingMatchPattern) {\n+    }\n+\n+    @Override\n+    public void visit(BLangFieldMatchPattern fieldMatchPattern) {}", "originalCommit": "60633c4b0cba351b0952428c39168a63cc34d2df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzUzMzQ3MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r527533471", "bodyText": "Fixed", "author": "KavinduZoysa", "createdAt": "2020-11-20T08:51:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQwMTE3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQxMDMyMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r527410323", "bodyText": "Is it correct to pass the pkgEnv here? Shouldn't it be the current env?\nFor example, if this env is eventually used to create a record for an intersection, and that intersection is within a function, the owner has to be the function and not the module?", "author": "MaryamZi", "createdAt": "2020-11-20T05:28:40Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeNarrower.java", "diffHunk": "@@ -257,15 +258,16 @@ private NarrowedTypes getNarrowedTypesForBinaryOp(Map<BVarSymbol, NarrowedTypes>\n             rhsTrueType = rhsFalseType = symbol.type;\n         }\n \n+        SymbolEnv pkgEnv = symTable.pkgEnvMap.get(this.env.enclPkg.symbol);\n         BType trueType, falseType;\n         if (operator == OperatorKind.AND) {\n-            trueType = types.getTypeIntersection(lhsTrueType, rhsTrueType);\n-            BType tmpType = types.getTypeIntersection(lhsTrueType, rhsFalseType);\n+            trueType = types.getTypeIntersection(lhsTrueType, rhsTrueType, pkgEnv);", "originalCommit": "60633c4b0cba351b0952428c39168a63cc34d2df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzUzMzkzOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r527533939", "bodyText": "Fixed", "author": "KavinduZoysa", "createdAt": "2020-11-20T08:52:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQxMDMyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUxNzQyNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r541517425", "bodyText": "Still seems to be using pkgEnv?", "author": "MaryamZi", "createdAt": "2020-12-12T06:44:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQxMDMyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk2ODk3Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r544968972", "bodyText": "I missed that, fixed it.", "author": "KavinduZoysa", "createdAt": "2020-12-17T10:13:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQxMDMyMw=="}], "type": "inlineReview"}, {"oid": "f4c1e7fa41fac422ee832a102c029316dc408594", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f4c1e7fa41fac422ee832a102c029316dc408594", "message": "Rebase with master", "committedDate": "2020-11-20T08:49:09Z", "type": "forcePushed"}, {"oid": "b8de7c9cbdc760ababb5c117b942185a816939d3", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b8de7c9cbdc760ababb5c117b942185a816939d3", "message": "Rebase with master", "committedDate": "2020-11-23T03:17:06Z", "type": "forcePushed"}, {"oid": "1055ec1c66a9e91c8786d22d559dffc403d1011c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1055ec1c66a9e91c8786d22d559dffc403d1011c", "message": "Rebase with master", "committedDate": "2020-11-23T06:32:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUwNTc2OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r541505768", "bodyText": "Is this used? If this is needed how come we don not need set methods for the field match patterns?", "author": "MaryamZi", "createdAt": "2020-12-12T05:22:42Z", "path": "compiler/ballerina-lang/src/main/java/org/ballerinalang/model/tree/matchpatterns/MappingMatchPatternNode.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.model.tree.matchpatterns;\n+\n+import org.ballerinalang.model.tree.Node;\n+\n+import java.util.List;\n+\n+/**\n+ * The interface with the APIs to implement the mapping-match-pattern.\n+ *\n+ * @since 2.0.0\n+ */\n+public interface MappingMatchPatternNode extends Node {\n+    List<? extends FieldMatchPatternNode> getFieldMatchPatterns();\n+\n+    RestMatchPatternNode getRestMatchPattern();\n+\n+    void setRestMatchPattern(RestMatchPatternNode restMatchPattern);", "originalCommit": "1055ec1c66a9e91c8786d22d559dffc403d1011c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk2ODkwOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r544968908", "bodyText": "Added setters", "author": "KavinduZoysa", "createdAt": "2020-12-17T10:13:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUwNTc2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUwNjU4Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r541506586", "bodyText": "Do we need to set the symbol also here? We don't usually do that in the node cloner, right?", "author": "MaryamZi", "createdAt": "2020-12-12T05:28:57Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/NodeCloner.java", "diffHunk": "@@ -746,6 +748,23 @@ public void visit(BLangListMatchPattern source) {\n         clone.declaredVars = source.declaredVars;\n     }\n \n+    @Override\n+    public void visit(BLangCaptureBindingPattern source) {\n+        BLangCaptureBindingPattern clone = new BLangCaptureBindingPattern();\n+        source.cloneRef = clone;\n+        clone.setIdentifier(source.getIdentifier());\n+        clone.symbol = (BVarSymbol) source.getSymbol();", "originalCommit": "1055ec1c66a9e91c8786d22d559dffc403d1011c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk2ODg5MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r544968891", "bodyText": "Yes, removed", "author": "KavinduZoysa", "createdAt": "2020-12-17T10:13:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUwNjU4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUxMjg4NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r541512884", "bodyText": "The following should work, right? x in the block scope should override the one in module scope?\nmap<int> x = {};\n\npublic function main() {\n    map<int> m = {a: 1, b: 2, c: 3};\n\n    // var x = m; // OK\n\n    match m {\n        {a: 1, ...var x} => {\n\n        }\n    }\n}\nFails with a \"redeclared symbol 'x'\" error for the module-level variable.", "author": "MaryamZi", "createdAt": "2020-12-12T06:13:14Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SemanticAnalyzer.java", "diffHunk": "@@ -2349,7 +2356,20 @@ public void visit(BLangMatchClause matchClause) {\n         SymbolEnv blockEnv = SymbolEnv.createBlockEnv(matchClause.blockStmt, env);\n \n         for (BLangMatchPattern matchPattern : matchClause.matchPatterns) {\n-            analyzeNode(matchPattern, blockEnv);\n+            SymbolEnv patternEnv = SymbolEnv.createPatternEnv(matchPattern, env);\n+            analyzeNode(matchPattern, patternEnv);\n+            Map<String, BVarSymbol> clauseVariables = matchClause.declaredVars;\n+            Map<String, BVarSymbol> patternVariables = matchPattern.declaredVars;\n+            for (String patternVariableName : patternVariables.keySet()) {\n+                BVarSymbol patternVariableSymbol = patternVariables.get(patternVariableName);\n+                if (!clauseVariables.containsKey(patternVariableName)) {\n+                    symbolEnter.defineSymbol(patternVariableSymbol.pos, patternVariableSymbol, blockEnv);", "originalCommit": "1055ec1c66a9e91c8786d22d559dffc403d1011c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk2ODg2Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r544968867", "bodyText": "Fixed", "author": "KavinduZoysa", "createdAt": "2020-12-17T10:13:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUxMjg4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUxOTI4NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r541519284", "bodyText": "Wouldn't the isAssignable check handle this and more cases here?", "author": "MaryamZi", "createdAt": "2020-12-12T06:58:26Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -381,10 +404,32 @@ private boolean containsAnyType(BType type) {\n         return false;\n     }\n \n+    private boolean containsAnyDataType(BType type) {\n+        if (type.tag != TypeTags.UNION) {\n+            return type.tag == TypeTags.ANYDATA;\n+        }\n+\n+        for (BType memberTypes : ((BUnionType) type).getMemberTypes()) {\n+            if (memberTypes.tag == TypeTags.ANYDATA) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n     public BType mergeTypes(BType typeFirst, BType typeSecond) {\n-        if (containsAnyType(typeFirst)) {\n+        if (containsAnyType(typeFirst) && !containsErrorType(typeSecond)) {\n             return typeSecond;\n         }\n+        if (containsAnyType(typeSecond) && !containsErrorType(typeFirst)) {\n+            return typeFirst;\n+        }\n+        if (containsAnyDataType(typeFirst) && !containsErrorType(typeSecond)) {\n+            return typeSecond;\n+        }\n+        if (containsAnyDataType(typeSecond) && !containsErrorType(typeFirst)) {\n+            return typeFirst;\n+        }", "originalCommit": "1055ec1c66a9e91c8786d22d559dffc403d1011c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI2Mjc0OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r556262749", "bodyText": "Ping on this.\nAlso I don't think the subsequent check with isSameBasicType works either.\nFor example, if you passed int as the first type and 'int:Signed16 as the second type we would return int here.\nBut if we pass 'int:Signed16 as the first type as int as the second type we would return 'int:Signed16. Is this correct?", "author": "MaryamZi", "createdAt": "2021-01-13T04:58:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUxOTI4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUxOTYzMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r541519632", "bodyText": "This can be a package-private method.", "author": "MaryamZi", "createdAt": "2020-12-12T07:00:49Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -381,10 +404,32 @@ private boolean containsAnyType(BType type) {\n         return false;\n     }\n \n+    private boolean containsAnyDataType(BType type) {\n+        if (type.tag != TypeTags.UNION) {\n+            return type.tag == TypeTags.ANYDATA;\n+        }\n+\n+        for (BType memberTypes : ((BUnionType) type).getMemberTypes()) {\n+            if (memberTypes.tag == TypeTags.ANYDATA) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n     public BType mergeTypes(BType typeFirst, BType typeSecond) {", "originalCommit": "1055ec1c66a9e91c8786d22d559dffc403d1011c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk2ODcyMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r544968723", "bodyText": "Fixed", "author": "KavinduZoysa", "createdAt": "2020-12-17T10:13:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUxOTYzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUyMjM4Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r541522382", "bodyText": "The following results in a bad, sad error here.\npublic function main() {\n    map<int>|map<json> m = {a: \"foo\", b: 2, c: 3};\n\n    match m {\n        {a: 1, ...var x}|{a: \"foo\", ...var x} => {\n\n        }\n    }\n}", "author": "MaryamZi", "createdAt": "2020-12-12T07:20:42Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -3203,89 +3227,256 @@ private BLangExpression createConditionForListMemberPattern(int index, BLangMatc\n         return createVarCheckCondition(listMemberMatchPattern, tempVarRef);\n     }\n \n-    private BLangExpression createVarCheckCondition(BLangMatchPattern matchPattern,\n-                                                    BLangSimpleVarRef varRef) {\n+    private BLangExpression createConditionForMappingMatchPattern(BLangMappingMatchPattern mappingMatchPattern,\n+                                                                  BLangSimpleVarRef matchExprVarRef) {\n+        BType matchPatternType = mappingMatchPattern.type;\n+        Location pos = mappingMatchPattern.pos;\n \n-        NodeKind patternKind = matchPattern.getKind();\n-        switch (patternKind) {\n-            case WILDCARD_MATCH_PATTERN:\n-                return createConditionForWildCardMatchPattern((BLangWildCardMatchPattern) matchPattern);\n-            case CONST_MATCH_PATTERN:\n-                return createConditionForConstMatchPattern((BLangConstPattern) matchPattern, varRef);\n-            case VAR_BINDING_PATTERN_MATCH_PATTERN:\n-                return createConditionForVarBindingPatternMatchPattern(\n-                        (BLangVarBindingPatternMatchPattern) matchPattern, varRef);\n-            case LIST_MATCH_PATTERN:\n-                BLangListMatchPattern listMatchPattern = (BLangListMatchPattern) matchPattern;\n-                Location pos = listMatchPattern.pos;\n-                BLangBlockStmt blockStmt = ASTBuilderUtil.createBlockStmt(pos);\n-\n-                BLangSimpleVariableDef resultVarDef = createVarDef(\"$listPatternVarResult$\", symTable.booleanType, null,\n-                        pos);\n-                BLangSimpleVarRef resultVarRef = ASTBuilderUtil.createVariableRef(pos, resultVarDef.var.symbol);\n-                blockStmt.addStatement(resultVarDef);\n-\n-                BLangAssignment failureResult =\n-                        ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(false));\n-                BLangAssignment successResult =\n-                        ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(true));\n-                blockStmt.addStatement(failureResult);\n-\n-                List<BType> memberTupleTypes = ((BTupleType) varRef.type).getTupleTypes();\n-                List<BLangMatchPattern> matchPatterns = listMatchPattern.matchPatterns;\n-\n-                BLangSimpleVariableDef tempCastVarDef = createVarDef(\"$castTemp$\", varRef.type, varRef, pos);\n-                blockStmt.addStatement(tempCastVarDef);\n-                BLangExpression condition = createConditionForListMemberPattern(0, matchPatterns.get(0),\n-                        tempCastVarDef, blockStmt, memberTupleTypes.get(0), pos);\n-\n-                for (int i = 1; i < matchPatterns.size(); i++) {\n-                    BLangExpression memberPatternCondition = createConditionForListMemberPattern(i,\n-                            matchPatterns.get(i), tempCastVarDef, blockStmt, memberTupleTypes.get(i), pos);\n-\n-                    condition = ASTBuilderUtil.createBinaryExpr(pos, condition, memberPatternCondition,\n-                            symTable.booleanType, OperatorKind.AND, (BOperatorSymbol) symResolver\n-                                    .resolveBinaryOperator(OperatorKind.AND, symTable.booleanType,\n-                                            symTable.booleanType));\n-                }\n+        BLangSimpleVariableDef resultVarDef = createVarDef(\"$mappingPatternResult$\", symTable.booleanType, null, pos);\n+        BLangSimpleVarRef resultVarRef = ASTBuilderUtil.createVariableRef(pos, resultVarDef.var.symbol);\n+        BLangBlockStmt mainBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+        mainBlockStmt.addStatement(resultVarDef);\n+\n+        BLangAssignment failureResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(false));\n+        BLangAssignment successResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(true));\n+        mainBlockStmt.addStatement(failureResult);\n \n-                BLangBlockStmt tempBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n-                tempBlockStmt.addStatement(successResult);\n-                BLangIf ifStmtForMatchPatterns = ASTBuilderUtil.createIfElseStmt(pos, condition, tempBlockStmt, null);\n-                blockStmt.addStatement(ifStmtForMatchPatterns);\n+        BLangExpression typeCheckCondition = createIsLikeExpression(mappingMatchPattern.pos, matchExprVarRef,\n+                matchPatternType);\n+        BLangExpression typeConvertedExpr = addConversionExprIfRequired(matchExprVarRef, matchPatternType);\n+        BLangSimpleVariableDef tempCastVarDef = createVarDef(\"$castTemp$\", matchPatternType, typeConvertedExpr, pos);\n+        BLangSimpleVarRef tempCastVarRef = ASTBuilderUtil.createVariableRef(pos, tempCastVarDef.var.symbol);\n \n-                BLangStatementExpression statementExpression = ASTBuilderUtil.createStatementExpression(blockStmt,\n-                        resultVarRef);\n-                statementExpression.type = symTable.booleanType;\n-                return statementExpression;\n-            default:\n-                // If some patterns are not implemented, those should be detected before this phase\n-                // TODO : Remove this after all patterns are implemented\n-                return null;\n+        BLangBlockStmt ifBlock = ASTBuilderUtil.createBlockStmt(pos);\n+        ifBlock.addStatement(tempCastVarDef);\n+        BLangIf ifStmt = ASTBuilderUtil.createIfElseStmt(pos, typeCheckCondition, ifBlock, null);\n+        mainBlockStmt.addStatement(ifStmt);\n+\n+        BLangExpression condition = createConditionForFieldMatchPatterns(mappingMatchPattern.fieldMatchPatterns,\n+                tempCastVarDef, ifBlock, pos);\n+\n+        BLangBlockStmt tempBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+        tempBlockStmt.addStatement(successResult);\n+        if (mappingMatchPattern.restMatchPattern != null) {\n+            BLangRestMatchPattern restMatchPattern = mappingMatchPattern.restMatchPattern;\n+            Location restPatternPos = restMatchPattern.pos;\n+            List<String> keysToRemove = getKeysToRemove(mappingMatchPattern);\n+            BMapType entriesType = new BMapType(TypeTags.MAP, new BTupleType(Arrays.asList(symTable.stringType,\n+                    ((BRecordType) matchPatternType).restFieldType)), null);\n+            BLangInvocation entriesInvocation = generateMapEntriesInvocation(tempCastVarRef, entriesType);\n+            BLangSimpleVariableDef entriesVarDef = createVarDef(\"$entries$\", entriesType, entriesInvocation,\n+                    restPatternPos);\n+            tempBlockStmt.addStatement(entriesVarDef);\n+            BLangLambdaFunction filteringFunction = createFuncToFilterOutRestParam(keysToRemove, restPatternPos);\n+            BLangInvocation filterInvocation = generateMapFilterInvocation(pos, entriesVarDef.var, filteringFunction);\n+            BLangSimpleVariableDef filtersVarDef = createVarDef(\"$filteredVarDef$\", entriesType, filterInvocation,\n+                    restPatternPos);\n+            tempBlockStmt.addStatement(filtersVarDef);\n+            BLangLambdaFunction backToMapLambda = generateEntriesToMapLambda(restPatternPos);\n+            BLangInvocation mapInvocation = generateMapMapInvocation(restPatternPos, filtersVarDef.var,\n+                    backToMapLambda);\n+            BLangSimpleVariable restVar =\n+                    ASTBuilderUtil.createVariable(restPatternPos, restMatchPattern.getIdentifier().getValue(),\n+                            restMatchPattern.symbol.type, mapInvocation, restMatchPattern.symbol);\n+            BLangSimpleVariableDef restVarDef = ASTBuilderUtil.createVariableDef(restPatternPos, restVar);\n+            tempBlockStmt.addStatement(restVarDef);\n+        }\n+        BLangIf ifStmtForMatchPatterns = ASTBuilderUtil.createIfElseStmt(pos, condition, tempBlockStmt, null);\n+        ifBlock.addStatement(ifStmtForMatchPatterns);\n+\n+        BLangStatementExpression statementExpression = ASTBuilderUtil.createStatementExpression(mainBlockStmt,\n+                resultVarRef);\n+        statementExpression.type = symTable.booleanType;\n+\n+        addAsRecordTypeDefinition(matchPatternType, pos);\n+        return statementExpression;\n+    }\n+\n+    private List<String> getKeysToRemove(BLangMappingMatchPattern mappingMatchPattern) {\n+        List<String> allKeys = new ArrayList<>(((BRecordType) mappingMatchPattern.type).fields.keySet());", "originalCommit": "1055ec1c66a9e91c8786d22d559dffc403d1011c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk2ODY5Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r544968693", "bodyText": "fixed", "author": "KavinduZoysa", "createdAt": "2020-12-17T10:13:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUyMjM4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUyMjk2OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r541522969", "bodyText": "Please recheck the access modifiers for these methods. Seems like they don't have to be public.", "author": "MaryamZi", "createdAt": "2020-12-12T07:24:46Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -368,6 +379,18 @@ public BType resolvePatternTypeFromMatchExpr(BLangExpression matchExpr, BLangExp\n         return symTable.noType;\n     }\n \n+    public BType resolvePatternTypeFromMatchExpr(BLangMappingMatchPattern mappingMatchPattern, BType patternType,", "originalCommit": "1055ec1c66a9e91c8786d22d559dffc403d1011c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk2ODY3Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r544968677", "bodyText": "Fixed", "author": "KavinduZoysa", "createdAt": "2020-12-17T10:13:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUyMjk2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUyMzI2MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r541523260", "bodyText": "The comment is no longer relevant?", "author": "MaryamZi", "createdAt": "2020-12-12T07:26:52Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2736,25 +2781,16 @@ BType getTypeForFiniteTypeValuesAssignableToType(BFiniteType finiteType, BType t\n      * @return           a single type or a new union type if at least one member type of the union type is\n      *                      assignable to targetType, else semanticError\n      */\n-    BType getTypeForUnionTypeMembersAssignableToType(BUnionType unionType, BType targetType) {\n+    BType getTypeForUnionTypeMembersAssignableToType(BUnionType unionType, BType targetType, SymbolEnv env) {\n         List<BType> intersection = new LinkedList<>();\n \n         // type FooOne \"foo\"|1;\n         // type FooBar \"foo\"|\"bar\";\n         // unionType - boolean|FooOne, targetType - boolean|FooBar", "originalCommit": "1055ec1c66a9e91c8786d22d559dffc403d1011c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk2ODY1NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r544968655", "bodyText": "Removed", "author": "KavinduZoysa", "createdAt": "2020-12-17T10:13:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUyMzI2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUyMzY3Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r541523672", "bodyText": "Can you check if we can replace this entire method with a direct call to getTypeIntersection instead?", "author": "MaryamZi", "createdAt": "2020-12-12T07:29:48Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2736,25 +2781,16 @@ BType getTypeForFiniteTypeValuesAssignableToType(BFiniteType finiteType, BType t\n      * @return           a single type or a new union type if at least one member type of the union type is\n      *                      assignable to targetType, else semanticError\n      */\n-    BType getTypeForUnionTypeMembersAssignableToType(BUnionType unionType, BType targetType) {\n+    BType getTypeForUnionTypeMembersAssignableToType(BUnionType unionType, BType targetType, SymbolEnv env) {\n         List<BType> intersection = new LinkedList<>();\n \n         // type FooOne \"foo\"|1;\n         // type FooBar \"foo\"|\"bar\";\n         // unionType - boolean|FooOne, targetType - boolean|FooBar\n         unionType.getMemberTypes().forEach(memType -> {", "originalCommit": "1055ec1c66a9e91c8786d22d559dffc403d1011c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk2ODYyNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r544968627", "bodyText": "I did not get what you mean here, As I understood it is to replace getTypeForUnionTypeMembersAssignableToType -> getTypeIntersection and remove the getTypeForUnionTypeMembersAssignableToType from the switch-case check in  getTypeIntersection. Is that correct?", "author": "KavinduZoysa", "createdAt": "2020-12-17T10:13:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUyMzY3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI2MzY2NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r556263664", "bodyText": "I missed that this was getting called from getTypeIntersection. This is OK.", "author": "MaryamZi", "createdAt": "2021-01-13T05:01:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUyMzY3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUyNDM5NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r541524395", "bodyText": "Given that it's just two case can't we do\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (targetType.tag != TypeTags.MAP && targetType.tag != TypeTags.RECORD) {\n          \n          \n            \n                        return symTable.semanticError;\n          \n          \n            \n                    }\n          \n          \n            \n                    if (targetType.tag == TypeTags.MAP) {\n          \n          \n            \n                        BType intersectionConstraintType = getTypeIntersection(mapType.constraint,\n          \n          \n            \n                                ((BMapType) targetType).constraint, env);\n          \n          \n            \n                        if (intersectionConstraintType == symTable.semanticError) {\n          \n          \n            \n                            return symTable.semanticError;\n          \n          \n            \n                        }\n          \n          \n            \n                        return new BMapType(TypeTags.MAP, intersectionConstraintType, null);\n          \n          \n            \n                    }\n          \n          \n            \n                    return getTypeIntersectedWithRecordType((BRecordType) targetType, mapType, env);\n          \n          \n            \n                    int targetTypeTag = targetType.tag;\n          \n          \n            \n                    \n          \n          \n            \n                    if (targetTypeTag == TypeTags.MAP) {\n          \n          \n            \n                        BType intersectionConstraintType = getTypeIntersection(mapType.constraint,\n          \n          \n            \n                                ((BMapType) targetType).constraint, env);\n          \n          \n            \n                        if (intersectionConstraintType == symTable.semanticError) {\n          \n          \n            \n                            return symTable.semanticError;\n          \n          \n            \n                        }\n          \n          \n            \n                        return new BMapType(TypeTags.MAP, intersectionConstraintType, null);\n          \n          \n            \n                    }\n          \n          \n            \n                    \n          \n          \n            \n                    if (targetTypeTag == TypeTags.RECORD) {\n          \n          \n            \n                        return getTypeIntersectedWithRecordType((BRecordType) targetType, mapType, env);\n          \n          \n            \n                    }\n          \n          \n            \n                    \n          \n          \n            \n                    return symTable.semanticError;", "author": "MaryamZi", "createdAt": "2020-12-12T07:35:08Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2769,6 +2805,146 @@ BType getTypeForUnionTypeMembersAssignableToType(BUnionType unionType, BType tar\n         }\n     }\n \n+    BType getTypeIntersectedWithMapType(BMapType mapType, BType targetType, SymbolEnv env) {\n+        if (targetType.tag != TypeTags.MAP && targetType.tag != TypeTags.RECORD) {\n+            return symTable.semanticError;\n+        }\n+        if (targetType.tag == TypeTags.MAP) {\n+            BType intersectionConstraintType = getTypeIntersection(mapType.constraint,\n+                    ((BMapType) targetType).constraint, env);\n+            if (intersectionConstraintType == symTable.semanticError) {\n+                return symTable.semanticError;\n+            }\n+            return new BMapType(TypeTags.MAP, intersectionConstraintType, null);\n+        }\n+        return getTypeIntersectedWithRecordType((BRecordType) targetType, mapType, env);", "originalCommit": "1055ec1c66a9e91c8786d22d559dffc403d1011c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk2ODU4NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r544968585", "bodyText": "Changed", "author": "KavinduZoysa", "createdAt": "2020-12-17T10:13:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUyNDM5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUyNDc1Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r541524756", "bodyText": "Aren't we repeating some checks by doing this? Wouldn't it be better to extract out the map-record intersection logic to a separate method and directly call that here and in getTypeIntersectedWithRecordType?", "author": "MaryamZi", "createdAt": "2020-12-12T07:37:33Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2769,6 +2805,146 @@ BType getTypeForUnionTypeMembersAssignableToType(BUnionType unionType, BType tar\n         }\n     }\n \n+    BType getTypeIntersectedWithMapType(BMapType mapType, BType targetType, SymbolEnv env) {\n+        if (targetType.tag != TypeTags.MAP && targetType.tag != TypeTags.RECORD) {\n+            return symTable.semanticError;\n+        }\n+        if (targetType.tag == TypeTags.MAP) {\n+            BType intersectionConstraintType = getTypeIntersection(mapType.constraint,\n+                    ((BMapType) targetType).constraint, env);\n+            if (intersectionConstraintType == symTable.semanticError) {\n+                return symTable.semanticError;\n+            }\n+            return new BMapType(TypeTags.MAP, intersectionConstraintType, null);\n+        }\n+        return getTypeIntersectedWithRecordType((BRecordType) targetType, mapType, env);", "originalCommit": "1055ec1c66a9e91c8786d22d559dffc403d1011c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUyNTg1Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r541525852", "bodyText": "Seems like getTypeIntersectedWithRecordType is only called from this method. If so we can change the targetType param of getTypeIntersectedWithRecordType to be of a BMapType and remove the tag checks.", "author": "MaryamZi", "createdAt": "2020-12-12T07:45:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUyNDc1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk2ODU0Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r544968546", "bodyText": "Refactored", "author": "KavinduZoysa", "createdAt": "2020-12-17T10:13:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUyNDc1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUyNTE2Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r541525167", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } else if (isAssignable(origField.type, overlappingField.type)) {\n          \n          \n            \n                        return origField.type;\n          \n          \n            \n                    } else {\n          \n          \n            \n                        return symTable.semanticError;\n          \n          \n            \n                    }\n          \n          \n            \n                    } \n          \n          \n            \n                    \n          \n          \n            \n                    if (isAssignable(origField.type, overlappingField.type)) {\n          \n          \n            \n                        return origField.type;\n          \n          \n            \n                    }\n          \n          \n            \n                    return symTable.semanticError;", "author": "MaryamZi", "createdAt": "2020-12-12T07:40:38Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2769,6 +2805,146 @@ BType getTypeForUnionTypeMembersAssignableToType(BUnionType unionType, BType tar\n         }\n     }\n \n+    BType getTypeIntersectedWithMapType(BMapType mapType, BType targetType, SymbolEnv env) {\n+        if (targetType.tag != TypeTags.MAP && targetType.tag != TypeTags.RECORD) {\n+            return symTable.semanticError;\n+        }\n+        if (targetType.tag == TypeTags.MAP) {\n+            BType intersectionConstraintType = getTypeIntersection(mapType.constraint,\n+                    ((BMapType) targetType).constraint, env);\n+            if (intersectionConstraintType == symTable.semanticError) {\n+                return symTable.semanticError;\n+            }\n+            return new BMapType(TypeTags.MAP, intersectionConstraintType, null);\n+        }\n+        return getTypeIntersectedWithRecordType((BRecordType) targetType, mapType, env);\n+    }\n+\n+    BType getTypeIntersectedWithRecordType(BRecordType recordType, BType targetType, SymbolEnv env) {\n+        if (targetType.tag != TypeTags.MAP && targetType.tag != TypeTags.RECORD) {\n+            return symTable.semanticError;\n+        }\n+        if (targetType.tag == TypeTags.MAP) {\n+            BRecordType intersectionRecordType = createAnonymousRecord(env);\n+            LinkedHashMap<String, BField> fields = new LinkedHashMap<>();\n+            for (String key : recordType.fields.keySet()) {\n+                BType intersectionKeyType = getTypeIntersection(recordType.fields.get(key).type,\n+                        ((BMapType) targetType).constraint, env);\n+                if (intersectionKeyType == symTable.semanticError) {\n+                    return symTable.semanticError;\n+                }\n+                BVarSymbol fieldSymbol = new BVarSymbol(0, names.fromString(key), env.enclPkg.symbol.pkgID,\n+                        intersectionKeyType, intersectionRecordType.tsymbol, recordType.fields.get(key).pos,\n+                        COMPILED_SOURCE);\n+                BField field = new BField(names.fromString(key), recordType.fields.get(key).pos, fieldSymbol);\n+                fields.put(key, field);\n+            }\n+            intersectionRecordType.fields = fields;\n+\n+            if (recordType.restFieldType != null) {\n+                BType intersectionRestType = getTypeIntersection(recordType.restFieldType,\n+                        ((BMapType) targetType).constraint, env);\n+                if (intersectionRestType == symTable.semanticError) {\n+                    intersectionRecordType.sealed = true;\n+                }\n+                intersectionRecordType.restFieldType = intersectionRestType;\n+            } else {\n+                intersectionRecordType.sealed = recordType.sealed;\n+            }\n+            return intersectionRecordType;\n+        }\n+        return createRecordIntersection(recordType, targetType, env);\n+    }\n+\n+    private BType createRecordIntersection(BType recordTypeOne, BType recordTypeTwo, SymbolEnv env) {\n+        BRecordType recordType = createAnonymousRecord(env);\n+\n+        if (!populateRecordFields(recordType, recordTypeOne, env) ||\n+                !populateRecordFields(recordType, recordTypeTwo, env)) {\n+            return symTable.semanticError;\n+        }\n+\n+        recordType.restFieldType = getTypeIntersection(((BRecordType) recordTypeOne).restFieldType,\n+                ((BRecordType) recordTypeTwo).restFieldType, env);\n+\n+        if (recordType.restFieldType == symTable.semanticError) {\n+            return symTable.semanticError;\n+        }\n+        return recordType;\n+    }\n+\n+    private boolean populateRecordFields(BRecordType recordType, BType originalType, SymbolEnv env) {\n+        BTypeSymbol intersectionRecordSymbol = recordType.tsymbol;\n+        // If the detail type is BMapType simply ignore since the resulting detail type has `anydata` as rest type.\n+        if (originalType.getKind() != TypeKind.RECORD) {\n+            return true;\n+        }\n+        BRecordType originalRecordType = (BRecordType) originalType;\n+        LinkedHashMap<String, BField> fields = new LinkedHashMap<>();\n+        for (BField origField : originalRecordType.fields.values()) {\n+            org.wso2.ballerinalang.compiler.util.Name origFieldName = origField.name;\n+            String nameString = origFieldName.value;\n+\n+            BType recordFieldType = validateOverlappingFields(recordType, origField);\n+            if (recordFieldType == symTable.semanticError) {\n+                return false;\n+            }\n+\n+            BVarSymbol recordFieldSymbol = new BVarSymbol(origField.symbol.flags, origFieldName,\n+                    env.enclPkg.packageID, recordFieldType,\n+                    intersectionRecordSymbol, origField.pos, SOURCE);\n+            if (recordFieldType.tag == TypeTags.INVOKABLE && recordFieldType.tsymbol != null) {\n+                BInvokableTypeSymbol tsymbol = (BInvokableTypeSymbol) recordFieldType.tsymbol;\n+                BInvokableSymbol invokableSymbol = (BInvokableSymbol) recordFieldSymbol;\n+                invokableSymbol.params = tsymbol.params;\n+                invokableSymbol.restParam = tsymbol.restParam;\n+                invokableSymbol.retType = tsymbol.returnType;\n+                invokableSymbol.flags = tsymbol.flags;\n+            }\n+            fields.put(nameString, new BField(origFieldName, null, recordFieldSymbol));\n+        }\n+        recordType.fields.putAll(fields);\n+        return true;\n+    }\n+\n+    private BType validateOverlappingFields(BRecordType recordType, BField origField) {\n+        BField overlappingField = recordType.fields.get(origField.name.value);\n+        if (overlappingField == null) {\n+            return origField.type;\n+        }\n+\n+        if (isAssignable(overlappingField.type, origField.type)) {\n+            return overlappingField.type;\n+        } else if (isAssignable(origField.type, overlappingField.type)) {\n+            return origField.type;\n+        } else {\n+            return symTable.semanticError;\n+        }", "originalCommit": "1055ec1c66a9e91c8786d22d559dffc403d1011c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk2ODUxMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r544968511", "bodyText": "Changed", "author": "KavinduZoysa", "createdAt": "2020-12-17T10:13:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUyNTE2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUyNTUyNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r541525524", "bodyText": "Is setting intersectionRestType correct even if intersectionRestType is symTable.semanticError? Shouln't it be symTable.noType if it is an exclusive record?", "author": "MaryamZi", "createdAt": "2020-12-12T07:43:03Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2769,6 +2805,146 @@ BType getTypeForUnionTypeMembersAssignableToType(BUnionType unionType, BType tar\n         }\n     }\n \n+    BType getTypeIntersectedWithMapType(BMapType mapType, BType targetType, SymbolEnv env) {\n+        if (targetType.tag != TypeTags.MAP && targetType.tag != TypeTags.RECORD) {\n+            return symTable.semanticError;\n+        }\n+        if (targetType.tag == TypeTags.MAP) {\n+            BType intersectionConstraintType = getTypeIntersection(mapType.constraint,\n+                    ((BMapType) targetType).constraint, env);\n+            if (intersectionConstraintType == symTable.semanticError) {\n+                return symTable.semanticError;\n+            }\n+            return new BMapType(TypeTags.MAP, intersectionConstraintType, null);\n+        }\n+        return getTypeIntersectedWithRecordType((BRecordType) targetType, mapType, env);\n+    }\n+\n+    BType getTypeIntersectedWithRecordType(BRecordType recordType, BType targetType, SymbolEnv env) {\n+        if (targetType.tag != TypeTags.MAP && targetType.tag != TypeTags.RECORD) {\n+            return symTable.semanticError;\n+        }\n+        if (targetType.tag == TypeTags.MAP) {\n+            BRecordType intersectionRecordType = createAnonymousRecord(env);\n+            LinkedHashMap<String, BField> fields = new LinkedHashMap<>();\n+            for (String key : recordType.fields.keySet()) {\n+                BType intersectionKeyType = getTypeIntersection(recordType.fields.get(key).type,\n+                        ((BMapType) targetType).constraint, env);\n+                if (intersectionKeyType == symTable.semanticError) {\n+                    return symTable.semanticError;\n+                }\n+                BVarSymbol fieldSymbol = new BVarSymbol(0, names.fromString(key), env.enclPkg.symbol.pkgID,\n+                        intersectionKeyType, intersectionRecordType.tsymbol, recordType.fields.get(key).pos,\n+                        COMPILED_SOURCE);\n+                BField field = new BField(names.fromString(key), recordType.fields.get(key).pos, fieldSymbol);\n+                fields.put(key, field);\n+            }\n+            intersectionRecordType.fields = fields;\n+\n+            if (recordType.restFieldType != null) {\n+                BType intersectionRestType = getTypeIntersection(recordType.restFieldType,\n+                        ((BMapType) targetType).constraint, env);\n+                if (intersectionRestType == symTable.semanticError) {\n+                    intersectionRecordType.sealed = true;\n+                }\n+                intersectionRecordType.restFieldType = intersectionRestType;", "originalCommit": "1055ec1c66a9e91c8786d22d559dffc403d1011c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk2ODQ5MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r544968490", "bodyText": "Fixed", "author": "KavinduZoysa", "createdAt": "2020-12-17T10:13:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUyNTUyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUyNjg1MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r541526850", "bodyText": "AFAIK restFieldType is never null in a BRecordType. If it is an exclusive record, the restType will be symTable.noType. We may have to change this check.", "author": "MaryamZi", "createdAt": "2020-12-12T07:52:25Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2769,6 +2805,146 @@ BType getTypeForUnionTypeMembersAssignableToType(BUnionType unionType, BType tar\n         }\n     }\n \n+    BType getTypeIntersectedWithMapType(BMapType mapType, BType targetType, SymbolEnv env) {\n+        if (targetType.tag != TypeTags.MAP && targetType.tag != TypeTags.RECORD) {\n+            return symTable.semanticError;\n+        }\n+        if (targetType.tag == TypeTags.MAP) {\n+            BType intersectionConstraintType = getTypeIntersection(mapType.constraint,\n+                    ((BMapType) targetType).constraint, env);\n+            if (intersectionConstraintType == symTable.semanticError) {\n+                return symTable.semanticError;\n+            }\n+            return new BMapType(TypeTags.MAP, intersectionConstraintType, null);\n+        }\n+        return getTypeIntersectedWithRecordType((BRecordType) targetType, mapType, env);\n+    }\n+\n+    BType getTypeIntersectedWithRecordType(BRecordType recordType, BType targetType, SymbolEnv env) {\n+        if (targetType.tag != TypeTags.MAP && targetType.tag != TypeTags.RECORD) {\n+            return symTable.semanticError;\n+        }\n+        if (targetType.tag == TypeTags.MAP) {\n+            BRecordType intersectionRecordType = createAnonymousRecord(env);\n+            LinkedHashMap<String, BField> fields = new LinkedHashMap<>();\n+            for (String key : recordType.fields.keySet()) {\n+                BType intersectionKeyType = getTypeIntersection(recordType.fields.get(key).type,\n+                        ((BMapType) targetType).constraint, env);\n+                if (intersectionKeyType == symTable.semanticError) {\n+                    return symTable.semanticError;\n+                }\n+                BVarSymbol fieldSymbol = new BVarSymbol(0, names.fromString(key), env.enclPkg.symbol.pkgID,\n+                        intersectionKeyType, intersectionRecordType.tsymbol, recordType.fields.get(key).pos,\n+                        COMPILED_SOURCE);\n+                BField field = new BField(names.fromString(key), recordType.fields.get(key).pos, fieldSymbol);\n+                fields.put(key, field);\n+            }\n+            intersectionRecordType.fields = fields;\n+\n+            if (recordType.restFieldType != null) {", "originalCommit": "1055ec1c66a9e91c8786d22d559dffc403d1011c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk2ODQ2MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r544968460", "bodyText": "Fixed", "author": "KavinduZoysa", "createdAt": "2020-12-17T10:13:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUyNjg1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUyNzIwOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r541527209", "bodyText": "Shouldn't we check if the field is optional here?\nFor example, map<json> and record {|int i; stream<int> j?;|} has an intersection, right?\nrecord {|int i;|}", "author": "MaryamZi", "createdAt": "2020-12-12T07:55:03Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2769,6 +2805,146 @@ BType getTypeForUnionTypeMembersAssignableToType(BUnionType unionType, BType tar\n         }\n     }\n \n+    BType getTypeIntersectedWithMapType(BMapType mapType, BType targetType, SymbolEnv env) {\n+        if (targetType.tag != TypeTags.MAP && targetType.tag != TypeTags.RECORD) {\n+            return symTable.semanticError;\n+        }\n+        if (targetType.tag == TypeTags.MAP) {\n+            BType intersectionConstraintType = getTypeIntersection(mapType.constraint,\n+                    ((BMapType) targetType).constraint, env);\n+            if (intersectionConstraintType == symTable.semanticError) {\n+                return symTable.semanticError;\n+            }\n+            return new BMapType(TypeTags.MAP, intersectionConstraintType, null);\n+        }\n+        return getTypeIntersectedWithRecordType((BRecordType) targetType, mapType, env);\n+    }\n+\n+    BType getTypeIntersectedWithRecordType(BRecordType recordType, BType targetType, SymbolEnv env) {\n+        if (targetType.tag != TypeTags.MAP && targetType.tag != TypeTags.RECORD) {\n+            return symTable.semanticError;\n+        }\n+        if (targetType.tag == TypeTags.MAP) {\n+            BRecordType intersectionRecordType = createAnonymousRecord(env);\n+            LinkedHashMap<String, BField> fields = new LinkedHashMap<>();\n+            for (String key : recordType.fields.keySet()) {\n+                BType intersectionKeyType = getTypeIntersection(recordType.fields.get(key).type,\n+                        ((BMapType) targetType).constraint, env);\n+                if (intersectionKeyType == symTable.semanticError) {", "originalCommit": "1055ec1c66a9e91c8786d22d559dffc403d1011c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI2NDU3NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r545264575", "bodyText": "Fixed", "author": "KavinduZoysa", "createdAt": "2020-12-17T17:22:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUyNzIwOQ=="}], "type": "inlineReview"}, {"oid": "575ec7b55a3c6d28c8dbb0c5c378989a08a8c3cc", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/575ec7b55a3c6d28c8dbb0c5c378989a08a8c3cc", "message": "Fix sugestions", "committedDate": "2020-12-17T10:12:18Z", "type": "forcePushed"}, {"oid": "f6b3cd10f2ec69868abea4b2daee20526352400c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f6b3cd10f2ec69868abea4b2daee20526352400c", "message": "Fix sugestions", "committedDate": "2020-12-17T17:21:48Z", "type": "forcePushed"}, {"oid": "827faf60c52de396ec39662b767279e3460ded62", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/827faf60c52de396ec39662b767279e3460ded62", "message": "Fix sugestions", "committedDate": "2021-01-04T04:34:11Z", "type": "forcePushed"}, {"oid": "b3f60111f23c01a3f321cace2b0311cce9c4de46", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b3f60111f23c01a3f321cace2b0311cce9c4de46", "message": "Sync with master", "committedDate": "2021-01-12T07:43:03Z", "type": "forcePushed"}, {"oid": "a795ecd1ecb76c24c1d87a0e00b7ecd1849f0ef4", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a795ecd1ecb76c24c1d87a0e00b7ecd1849f0ef4", "message": "Sync with master", "committedDate": "2021-01-12T10:57:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI1NjI5OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r556256298", "bodyText": "There's quite a bit of repeated code between this and createVarCheckConditionForListMatchPattern, right? Shall we check if we can refactor these methods to avoid repetition?", "author": "MaryamZi", "createdAt": "2021-01-13T04:33:22Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -3463,89 +3487,252 @@ private BLangExpression createConditionForListMemberPattern(int index, BLangMatc\n         return createVarCheckCondition(listMemberMatchPattern, tempVarRef);\n     }\n \n-    private BLangExpression createVarCheckCondition(BLangMatchPattern matchPattern,\n-                                                    BLangSimpleVarRef varRef) {\n+    private BLangExpression createConditionForMappingMatchPattern(BLangMappingMatchPattern mappingMatchPattern,\n+                                                                  BLangSimpleVarRef matchExprVarRef) {\n+        BType matchPatternType = mappingMatchPattern.type;\n+        Location pos = mappingMatchPattern.pos;\n \n-        NodeKind patternKind = matchPattern.getKind();\n-        switch (patternKind) {\n-            case WILDCARD_MATCH_PATTERN:\n-                return createConditionForWildCardMatchPattern((BLangWildCardMatchPattern) matchPattern);\n-            case CONST_MATCH_PATTERN:\n-                return createConditionForConstMatchPattern((BLangConstPattern) matchPattern, varRef);\n-            case VAR_BINDING_PATTERN_MATCH_PATTERN:\n-                return createConditionForVarBindingPatternMatchPattern(\n-                        (BLangVarBindingPatternMatchPattern) matchPattern, varRef);\n-            case LIST_MATCH_PATTERN:\n-                BLangListMatchPattern listMatchPattern = (BLangListMatchPattern) matchPattern;\n-                Location pos = listMatchPattern.pos;\n-                BLangBlockStmt blockStmt = ASTBuilderUtil.createBlockStmt(pos);\n-\n-                BLangSimpleVariableDef resultVarDef = createVarDef(\"$listPatternVarResult$\", symTable.booleanType, null,\n-                        pos);\n-                BLangSimpleVarRef resultVarRef = ASTBuilderUtil.createVariableRef(pos, resultVarDef.var.symbol);\n-                blockStmt.addStatement(resultVarDef);\n-\n-                BLangAssignment failureResult =\n-                        ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(false));\n-                BLangAssignment successResult =\n-                        ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(true));\n-                blockStmt.addStatement(failureResult);\n-\n-                List<BType> memberTupleTypes = ((BTupleType) varRef.type).getTupleTypes();\n-                List<BLangMatchPattern> matchPatterns = listMatchPattern.matchPatterns;\n-\n-                BLangSimpleVariableDef tempCastVarDef = createVarDef(\"$castTemp$\", varRef.type, varRef, pos);\n-                blockStmt.addStatement(tempCastVarDef);\n-                BLangExpression condition = createConditionForListMemberPattern(0, matchPatterns.get(0),\n-                        tempCastVarDef, blockStmt, memberTupleTypes.get(0), pos);\n-\n-                for (int i = 1; i < matchPatterns.size(); i++) {\n-                    BLangExpression memberPatternCondition = createConditionForListMemberPattern(i,\n-                            matchPatterns.get(i), tempCastVarDef, blockStmt, memberTupleTypes.get(i), pos);\n-\n-                    condition = ASTBuilderUtil.createBinaryExpr(pos, condition, memberPatternCondition,\n-                            symTable.booleanType, OperatorKind.AND, (BOperatorSymbol) symResolver\n-                                    .resolveBinaryOperator(OperatorKind.AND, symTable.booleanType,\n-                                            symTable.booleanType));\n-                }\n+        BLangSimpleVariableDef resultVarDef = createVarDef(\"$mappingPatternResult$\", symTable.booleanType, null, pos);\n+        BLangSimpleVarRef resultVarRef = ASTBuilderUtil.createVariableRef(pos, resultVarDef.var.symbol);\n+        BLangBlockStmt mainBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+        mainBlockStmt.addStatement(resultVarDef);\n+\n+        BLangAssignment failureResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(false));\n+        BLangAssignment successResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(true));\n+        mainBlockStmt.addStatement(failureResult);\n \n-                BLangBlockStmt tempBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n-                tempBlockStmt.addStatement(successResult);\n-                BLangIf ifStmtForMatchPatterns = ASTBuilderUtil.createIfElseStmt(pos, condition, tempBlockStmt, null);\n-                blockStmt.addStatement(ifStmtForMatchPatterns);\n+        BLangExpression typeCheckCondition = createIsLikeExpression(mappingMatchPattern.pos, matchExprVarRef,\n+                matchPatternType);\n+        BLangExpression typeConvertedExpr = addConversionExprIfRequired(matchExprVarRef, matchPatternType);\n+        BLangSimpleVariableDef tempCastVarDef = createVarDef(\"$castTemp$\", matchPatternType, typeConvertedExpr, pos);\n+        BLangSimpleVarRef tempCastVarRef = ASTBuilderUtil.createVariableRef(pos, tempCastVarDef.var.symbol);\n \n-                BLangStatementExpression statementExpression = ASTBuilderUtil.createStatementExpression(blockStmt,\n-                        resultVarRef);\n-                statementExpression.type = symTable.booleanType;\n-                return statementExpression;\n-            default:\n-                // If some patterns are not implemented, those should be detected before this phase\n-                // TODO : Remove this after all patterns are implemented\n-                return null;\n+        BLangBlockStmt ifBlock = ASTBuilderUtil.createBlockStmt(pos);\n+        ifBlock.addStatement(tempCastVarDef);\n+        BLangIf ifStmt = ASTBuilderUtil.createIfElseStmt(pos, typeCheckCondition, ifBlock, null);\n+        mainBlockStmt.addStatement(ifStmt);\n+\n+        BLangExpression condition = createConditionForFieldMatchPatterns(mappingMatchPattern.fieldMatchPatterns,\n+                tempCastVarDef, ifBlock, pos);\n+\n+        BLangBlockStmt tempBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+        tempBlockStmt.addStatement(successResult);\n+        if (mappingMatchPattern.restMatchPattern != null) {\n+            BLangRestMatchPattern restMatchPattern = mappingMatchPattern.restMatchPattern;\n+            Location restPatternPos = restMatchPattern.pos;\n+            List<String> keysToRemove = getKeysToRemove(mappingMatchPattern);\n+            BMapType entriesType = new BMapType(TypeTags.MAP, new BTupleType(Arrays.asList(symTable.stringType,\n+                    ((BMapType) mappingMatchPattern.restMatchPattern.type).constraint)), null);\n+            BLangInvocation entriesInvocation = generateMapEntriesInvocation(tempCastVarRef, entriesType);\n+            BLangSimpleVariableDef entriesVarDef = createVarDef(\"$entries$\", entriesType, entriesInvocation,\n+                    restPatternPos);\n+            tempBlockStmt.addStatement(entriesVarDef);\n+            BLangLambdaFunction filteringFunction = createFuncToFilterOutRestParam(keysToRemove, restPatternPos);\n+            BLangInvocation filterInvocation = generateMapFilterInvocation(pos, entriesVarDef.var, filteringFunction);\n+            BLangSimpleVariableDef filtersVarDef = createVarDef(\"$filteredVarDef$\", entriesType, filterInvocation,\n+                    restPatternPos);\n+            tempBlockStmt.addStatement(filtersVarDef);\n+            BLangLambdaFunction backToMapLambda = generateEntriesToMapLambda(restPatternPos);\n+            BLangInvocation mapInvocation = generateMapMapInvocation(restPatternPos, filtersVarDef.var,\n+                    backToMapLambda);\n+            BLangSimpleVarRef restMatchPatternVarRef = declaredVarDef.get(restMatchPattern.getIdentifier().getValue());\n+            tempBlockStmt.addStatement(ASTBuilderUtil.createAssignmentStmt(pos, restMatchPatternVarRef, mapInvocation));\n+        }\n+        BLangIf ifStmtForMatchPatterns = ASTBuilderUtil.createIfElseStmt(pos, condition, tempBlockStmt, null);\n+        ifBlock.addStatement(ifStmtForMatchPatterns);\n+\n+        BLangStatementExpression statementExpression = ASTBuilderUtil.createStatementExpression(mainBlockStmt,\n+                resultVarRef);\n+        statementExpression.type = symTable.booleanType;\n+\n+        addAsRecordTypeDefinition(matchPatternType, pos);\n+        return statementExpression;\n+    }\n+\n+    private List<String> getKeysToRemove(BLangMappingMatchPattern mappingMatchPattern) {\n+        List<String> keysToRemove = new ArrayList<>();\n+        for (BLangFieldMatchPattern fieldMatchPattern : mappingMatchPattern.fieldMatchPatterns) {\n+            keysToRemove.add(fieldMatchPattern.fieldName.value);\n         }\n+        return keysToRemove;\n     }\n \n-    private BLangExpression createConditionForMatchPattern(BLangMatchPattern matchPattern,\n-                                                           BLangSimpleVarRef matchExprVarRef) {\n+    private BLangExpression createConditionForFieldMatchPatterns(List<BLangFieldMatchPattern> fieldMatchPatterns,\n+                                                                 BLangSimpleVariableDef varDef,\n+                                                                 BLangBlockStmt blockStmt,\n+                                                                 Location pos) {\n+        BLangExpression condition = ASTBuilderUtil.createLiteral(pos, symTable.booleanType, true);\n+        for (int i = 0; i < fieldMatchPatterns.size(); i++) {\n+            BLangExpression fieldMatchPatternCondition =\n+                    createConditionForFieldMatchPattern(i, fieldMatchPatterns.get(i), varDef, blockStmt);\n+            condition = ASTBuilderUtil.createBinaryExpr(pos, condition, fieldMatchPatternCondition,\n+                    symTable.booleanType, OperatorKind.AND, (BOperatorSymbol) symResolver\n+                            .resolveBinaryOperator(OperatorKind.AND, symTable.booleanType, symTable.booleanType));\n+        }\n+        return condition;\n+    }\n+\n+    private BLangExpression createConditionForFieldMatchPattern(int index, BLangFieldMatchPattern fieldMatchPattern,\n+                                                                BLangSimpleVariableDef tempCastVarDef,\n+                                                                BLangBlockStmt blockStmt) {\n+        String fieldName = fieldMatchPattern.fieldName.value;\n+        BLangMatchPattern matchPattern = fieldMatchPattern.matchPattern;\n+        BLangFieldBasedAccess fieldBasedAccessExpr = getFieldAccessExpression(fieldMatchPattern.pos, fieldName,\n+                matchPattern.type, tempCastVarDef.var.symbol);\n+        BLangSimpleVariableDef tempVarDef = createVarDef(\"$memberVarTemp$\" + index + \"_$\", matchPattern.type,\n+                fieldBasedAccessExpr, matchPattern.pos);\n+        BLangSimpleVarRef tempVarRef = ASTBuilderUtil.createVariableRef(matchPattern.pos, tempVarDef.var.symbol);\n+        blockStmt.addStatement(tempVarDef);\n+        return createVarCheckCondition(matchPattern, tempVarRef);\n+    }\n+\n+    private BLangExpression createVarCheckCondition(BLangMatchPattern matchPattern, BLangSimpleVarRef varRef) {\n \n         NodeKind patternKind = matchPattern.getKind();\n         switch (patternKind) {\n             case WILDCARD_MATCH_PATTERN:\n                 return createConditionForWildCardMatchPattern((BLangWildCardMatchPattern) matchPattern);\n             case CONST_MATCH_PATTERN:\n-                return createConditionForConstMatchPattern((BLangConstPattern) matchPattern, matchExprVarRef);\n+                return createConditionForConstMatchPattern((BLangConstPattern) matchPattern, varRef);\n             case VAR_BINDING_PATTERN_MATCH_PATTERN:\n                 return createConditionForVarBindingPatternMatchPattern(\n-                        (BLangVarBindingPatternMatchPattern) matchPattern, matchExprVarRef);\n+                        (BLangVarBindingPatternMatchPattern) matchPattern, varRef);\n             case LIST_MATCH_PATTERN:\n-                return createConditionForListMatchPattern((BLangListMatchPattern) matchPattern, matchExprVarRef);\n+                return createVarCheckConditionForListMatchPattern((BLangListMatchPattern) matchPattern, varRef);\n+            case MAPPING_MATCH_PATTERN:\n+                return createVarCheckConditionForMappingMatchPattern((BLangMappingMatchPattern) matchPattern, varRef);\n             default:\n                 // If some patterns are not implemented, those should be detected before this phase\n                 // TODO : Remove this after all patterns are implemented\n                 return null;\n         }\n     }\n \n+    private BLangExpression createVarCheckConditionForListMatchPattern(BLangListMatchPattern listMatchPattern,\n+                                                                       BLangSimpleVarRef varRef) {\n+        Location pos = listMatchPattern.pos;\n+        BLangBlockStmt blockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+\n+        BLangSimpleVariableDef resultVarDef = createVarDef(\"$listPatternVarResult$\", symTable.booleanType, null,\n+                pos);\n+        BLangSimpleVarRef resultVarRef = ASTBuilderUtil.createVariableRef(pos, resultVarDef.var.symbol);\n+        blockStmt.addStatement(resultVarDef);\n+\n+        BLangAssignment failureResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(false));\n+        BLangAssignment successResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(true));\n+        blockStmt.addStatement(failureResult);\n+\n+        List<BType> memberTupleTypes = ((BTupleType) varRef.type).getTupleTypes();\n+        List<BLangMatchPattern> matchPatterns = listMatchPattern.matchPatterns;\n+\n+        BLangSimpleVariableDef tempCastVarDef = createVarDef(\"$castTemp$\", varRef.type, varRef, pos);\n+        blockStmt.addStatement(tempCastVarDef);\n+        BLangExpression condition = createConditionForListMemberPattern(0, matchPatterns.get(0),\n+                tempCastVarDef, blockStmt, memberTupleTypes.get(0), pos);\n+\n+        for (int i = 1; i < matchPatterns.size(); i++) {\n+            BLangExpression memberPatternCondition = createConditionForListMemberPattern(i,\n+                    matchPatterns.get(i), tempCastVarDef, blockStmt, memberTupleTypes.get(i), pos);\n+\n+            condition = ASTBuilderUtil.createBinaryExpr(pos, condition, memberPatternCondition,\n+                    symTable.booleanType, OperatorKind.AND, (BOperatorSymbol) symResolver\n+                            .resolveBinaryOperator(OperatorKind.AND, symTable.booleanType,\n+                                    symTable.booleanType));\n+        }\n+\n+        BLangBlockStmt tempBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+        tempBlockStmt.addStatement(successResult);\n+        BLangIf ifStmtForMatchPatterns = ASTBuilderUtil.createIfElseStmt(pos, condition, tempBlockStmt, null);\n+        blockStmt.addStatement(ifStmtForMatchPatterns);\n+\n+        BLangStatementExpression statementExpression = ASTBuilderUtil.createStatementExpression(blockStmt,\n+                resultVarRef);\n+        statementExpression.type = symTable.booleanType;\n+        return statementExpression;\n+    }\n+\n+    private BLangExpression createVarCheckConditionForMappingMatchPattern(BLangMappingMatchPattern mappingMatchPattern,", "originalCommit": "a795ecd1ecb76c24c1d87a0e00b7ecd1849f0ef4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI1NjgyOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r556256828", "bodyText": "Can't we return here? Or we have to unnecessarily check the tag in L3701 and return?", "author": "MaryamZi", "createdAt": "2021-01-13T04:35:31Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -3463,89 +3487,252 @@ private BLangExpression createConditionForListMemberPattern(int index, BLangMatc\n         return createVarCheckCondition(listMemberMatchPattern, tempVarRef);\n     }\n \n-    private BLangExpression createVarCheckCondition(BLangMatchPattern matchPattern,\n-                                                    BLangSimpleVarRef varRef) {\n+    private BLangExpression createConditionForMappingMatchPattern(BLangMappingMatchPattern mappingMatchPattern,\n+                                                                  BLangSimpleVarRef matchExprVarRef) {\n+        BType matchPatternType = mappingMatchPattern.type;\n+        Location pos = mappingMatchPattern.pos;\n \n-        NodeKind patternKind = matchPattern.getKind();\n-        switch (patternKind) {\n-            case WILDCARD_MATCH_PATTERN:\n-                return createConditionForWildCardMatchPattern((BLangWildCardMatchPattern) matchPattern);\n-            case CONST_MATCH_PATTERN:\n-                return createConditionForConstMatchPattern((BLangConstPattern) matchPattern, varRef);\n-            case VAR_BINDING_PATTERN_MATCH_PATTERN:\n-                return createConditionForVarBindingPatternMatchPattern(\n-                        (BLangVarBindingPatternMatchPattern) matchPattern, varRef);\n-            case LIST_MATCH_PATTERN:\n-                BLangListMatchPattern listMatchPattern = (BLangListMatchPattern) matchPattern;\n-                Location pos = listMatchPattern.pos;\n-                BLangBlockStmt blockStmt = ASTBuilderUtil.createBlockStmt(pos);\n-\n-                BLangSimpleVariableDef resultVarDef = createVarDef(\"$listPatternVarResult$\", symTable.booleanType, null,\n-                        pos);\n-                BLangSimpleVarRef resultVarRef = ASTBuilderUtil.createVariableRef(pos, resultVarDef.var.symbol);\n-                blockStmt.addStatement(resultVarDef);\n-\n-                BLangAssignment failureResult =\n-                        ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(false));\n-                BLangAssignment successResult =\n-                        ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(true));\n-                blockStmt.addStatement(failureResult);\n-\n-                List<BType> memberTupleTypes = ((BTupleType) varRef.type).getTupleTypes();\n-                List<BLangMatchPattern> matchPatterns = listMatchPattern.matchPatterns;\n-\n-                BLangSimpleVariableDef tempCastVarDef = createVarDef(\"$castTemp$\", varRef.type, varRef, pos);\n-                blockStmt.addStatement(tempCastVarDef);\n-                BLangExpression condition = createConditionForListMemberPattern(0, matchPatterns.get(0),\n-                        tempCastVarDef, blockStmt, memberTupleTypes.get(0), pos);\n-\n-                for (int i = 1; i < matchPatterns.size(); i++) {\n-                    BLangExpression memberPatternCondition = createConditionForListMemberPattern(i,\n-                            matchPatterns.get(i), tempCastVarDef, blockStmt, memberTupleTypes.get(i), pos);\n-\n-                    condition = ASTBuilderUtil.createBinaryExpr(pos, condition, memberPatternCondition,\n-                            symTable.booleanType, OperatorKind.AND, (BOperatorSymbol) symResolver\n-                                    .resolveBinaryOperator(OperatorKind.AND, symTable.booleanType,\n-                                            symTable.booleanType));\n-                }\n+        BLangSimpleVariableDef resultVarDef = createVarDef(\"$mappingPatternResult$\", symTable.booleanType, null, pos);\n+        BLangSimpleVarRef resultVarRef = ASTBuilderUtil.createVariableRef(pos, resultVarDef.var.symbol);\n+        BLangBlockStmt mainBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+        mainBlockStmt.addStatement(resultVarDef);\n+\n+        BLangAssignment failureResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(false));\n+        BLangAssignment successResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(true));\n+        mainBlockStmt.addStatement(failureResult);\n \n-                BLangBlockStmt tempBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n-                tempBlockStmt.addStatement(successResult);\n-                BLangIf ifStmtForMatchPatterns = ASTBuilderUtil.createIfElseStmt(pos, condition, tempBlockStmt, null);\n-                blockStmt.addStatement(ifStmtForMatchPatterns);\n+        BLangExpression typeCheckCondition = createIsLikeExpression(mappingMatchPattern.pos, matchExprVarRef,\n+                matchPatternType);\n+        BLangExpression typeConvertedExpr = addConversionExprIfRequired(matchExprVarRef, matchPatternType);\n+        BLangSimpleVariableDef tempCastVarDef = createVarDef(\"$castTemp$\", matchPatternType, typeConvertedExpr, pos);\n+        BLangSimpleVarRef tempCastVarRef = ASTBuilderUtil.createVariableRef(pos, tempCastVarDef.var.symbol);\n \n-                BLangStatementExpression statementExpression = ASTBuilderUtil.createStatementExpression(blockStmt,\n-                        resultVarRef);\n-                statementExpression.type = symTable.booleanType;\n-                return statementExpression;\n-            default:\n-                // If some patterns are not implemented, those should be detected before this phase\n-                // TODO : Remove this after all patterns are implemented\n-                return null;\n+        BLangBlockStmt ifBlock = ASTBuilderUtil.createBlockStmt(pos);\n+        ifBlock.addStatement(tempCastVarDef);\n+        BLangIf ifStmt = ASTBuilderUtil.createIfElseStmt(pos, typeCheckCondition, ifBlock, null);\n+        mainBlockStmt.addStatement(ifStmt);\n+\n+        BLangExpression condition = createConditionForFieldMatchPatterns(mappingMatchPattern.fieldMatchPatterns,\n+                tempCastVarDef, ifBlock, pos);\n+\n+        BLangBlockStmt tempBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+        tempBlockStmt.addStatement(successResult);\n+        if (mappingMatchPattern.restMatchPattern != null) {\n+            BLangRestMatchPattern restMatchPattern = mappingMatchPattern.restMatchPattern;\n+            Location restPatternPos = restMatchPattern.pos;\n+            List<String> keysToRemove = getKeysToRemove(mappingMatchPattern);\n+            BMapType entriesType = new BMapType(TypeTags.MAP, new BTupleType(Arrays.asList(symTable.stringType,\n+                    ((BMapType) mappingMatchPattern.restMatchPattern.type).constraint)), null);\n+            BLangInvocation entriesInvocation = generateMapEntriesInvocation(tempCastVarRef, entriesType);\n+            BLangSimpleVariableDef entriesVarDef = createVarDef(\"$entries$\", entriesType, entriesInvocation,\n+                    restPatternPos);\n+            tempBlockStmt.addStatement(entriesVarDef);\n+            BLangLambdaFunction filteringFunction = createFuncToFilterOutRestParam(keysToRemove, restPatternPos);\n+            BLangInvocation filterInvocation = generateMapFilterInvocation(pos, entriesVarDef.var, filteringFunction);\n+            BLangSimpleVariableDef filtersVarDef = createVarDef(\"$filteredVarDef$\", entriesType, filterInvocation,\n+                    restPatternPos);\n+            tempBlockStmt.addStatement(filtersVarDef);\n+            BLangLambdaFunction backToMapLambda = generateEntriesToMapLambda(restPatternPos);\n+            BLangInvocation mapInvocation = generateMapMapInvocation(restPatternPos, filtersVarDef.var,\n+                    backToMapLambda);\n+            BLangSimpleVarRef restMatchPatternVarRef = declaredVarDef.get(restMatchPattern.getIdentifier().getValue());\n+            tempBlockStmt.addStatement(ASTBuilderUtil.createAssignmentStmt(pos, restMatchPatternVarRef, mapInvocation));\n+        }\n+        BLangIf ifStmtForMatchPatterns = ASTBuilderUtil.createIfElseStmt(pos, condition, tempBlockStmt, null);\n+        ifBlock.addStatement(ifStmtForMatchPatterns);\n+\n+        BLangStatementExpression statementExpression = ASTBuilderUtil.createStatementExpression(mainBlockStmt,\n+                resultVarRef);\n+        statementExpression.type = symTable.booleanType;\n+\n+        addAsRecordTypeDefinition(matchPatternType, pos);\n+        return statementExpression;\n+    }\n+\n+    private List<String> getKeysToRemove(BLangMappingMatchPattern mappingMatchPattern) {\n+        List<String> keysToRemove = new ArrayList<>();\n+        for (BLangFieldMatchPattern fieldMatchPattern : mappingMatchPattern.fieldMatchPatterns) {\n+            keysToRemove.add(fieldMatchPattern.fieldName.value);\n         }\n+        return keysToRemove;\n     }\n \n-    private BLangExpression createConditionForMatchPattern(BLangMatchPattern matchPattern,\n-                                                           BLangSimpleVarRef matchExprVarRef) {\n+    private BLangExpression createConditionForFieldMatchPatterns(List<BLangFieldMatchPattern> fieldMatchPatterns,\n+                                                                 BLangSimpleVariableDef varDef,\n+                                                                 BLangBlockStmt blockStmt,\n+                                                                 Location pos) {\n+        BLangExpression condition = ASTBuilderUtil.createLiteral(pos, symTable.booleanType, true);\n+        for (int i = 0; i < fieldMatchPatterns.size(); i++) {\n+            BLangExpression fieldMatchPatternCondition =\n+                    createConditionForFieldMatchPattern(i, fieldMatchPatterns.get(i), varDef, blockStmt);\n+            condition = ASTBuilderUtil.createBinaryExpr(pos, condition, fieldMatchPatternCondition,\n+                    symTable.booleanType, OperatorKind.AND, (BOperatorSymbol) symResolver\n+                            .resolveBinaryOperator(OperatorKind.AND, symTable.booleanType, symTable.booleanType));\n+        }\n+        return condition;\n+    }\n+\n+    private BLangExpression createConditionForFieldMatchPattern(int index, BLangFieldMatchPattern fieldMatchPattern,\n+                                                                BLangSimpleVariableDef tempCastVarDef,\n+                                                                BLangBlockStmt blockStmt) {\n+        String fieldName = fieldMatchPattern.fieldName.value;\n+        BLangMatchPattern matchPattern = fieldMatchPattern.matchPattern;\n+        BLangFieldBasedAccess fieldBasedAccessExpr = getFieldAccessExpression(fieldMatchPattern.pos, fieldName,\n+                matchPattern.type, tempCastVarDef.var.symbol);\n+        BLangSimpleVariableDef tempVarDef = createVarDef(\"$memberVarTemp$\" + index + \"_$\", matchPattern.type,\n+                fieldBasedAccessExpr, matchPattern.pos);\n+        BLangSimpleVarRef tempVarRef = ASTBuilderUtil.createVariableRef(matchPattern.pos, tempVarDef.var.symbol);\n+        blockStmt.addStatement(tempVarDef);\n+        return createVarCheckCondition(matchPattern, tempVarRef);\n+    }\n+\n+    private BLangExpression createVarCheckCondition(BLangMatchPattern matchPattern, BLangSimpleVarRef varRef) {\n \n         NodeKind patternKind = matchPattern.getKind();\n         switch (patternKind) {\n             case WILDCARD_MATCH_PATTERN:\n                 return createConditionForWildCardMatchPattern((BLangWildCardMatchPattern) matchPattern);\n             case CONST_MATCH_PATTERN:\n-                return createConditionForConstMatchPattern((BLangConstPattern) matchPattern, matchExprVarRef);\n+                return createConditionForConstMatchPattern((BLangConstPattern) matchPattern, varRef);\n             case VAR_BINDING_PATTERN_MATCH_PATTERN:\n                 return createConditionForVarBindingPatternMatchPattern(\n-                        (BLangVarBindingPatternMatchPattern) matchPattern, matchExprVarRef);\n+                        (BLangVarBindingPatternMatchPattern) matchPattern, varRef);\n             case LIST_MATCH_PATTERN:\n-                return createConditionForListMatchPattern((BLangListMatchPattern) matchPattern, matchExprVarRef);\n+                return createVarCheckConditionForListMatchPattern((BLangListMatchPattern) matchPattern, varRef);\n+            case MAPPING_MATCH_PATTERN:\n+                return createVarCheckConditionForMappingMatchPattern((BLangMappingMatchPattern) matchPattern, varRef);\n             default:\n                 // If some patterns are not implemented, those should be detected before this phase\n                 // TODO : Remove this after all patterns are implemented\n                 return null;\n         }\n     }\n \n+    private BLangExpression createVarCheckConditionForListMatchPattern(BLangListMatchPattern listMatchPattern,\n+                                                                       BLangSimpleVarRef varRef) {\n+        Location pos = listMatchPattern.pos;\n+        BLangBlockStmt blockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+\n+        BLangSimpleVariableDef resultVarDef = createVarDef(\"$listPatternVarResult$\", symTable.booleanType, null,\n+                pos);\n+        BLangSimpleVarRef resultVarRef = ASTBuilderUtil.createVariableRef(pos, resultVarDef.var.symbol);\n+        blockStmt.addStatement(resultVarDef);\n+\n+        BLangAssignment failureResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(false));\n+        BLangAssignment successResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(true));\n+        blockStmt.addStatement(failureResult);\n+\n+        List<BType> memberTupleTypes = ((BTupleType) varRef.type).getTupleTypes();\n+        List<BLangMatchPattern> matchPatterns = listMatchPattern.matchPatterns;\n+\n+        BLangSimpleVariableDef tempCastVarDef = createVarDef(\"$castTemp$\", varRef.type, varRef, pos);\n+        blockStmt.addStatement(tempCastVarDef);\n+        BLangExpression condition = createConditionForListMemberPattern(0, matchPatterns.get(0),\n+                tempCastVarDef, blockStmt, memberTupleTypes.get(0), pos);\n+\n+        for (int i = 1; i < matchPatterns.size(); i++) {\n+            BLangExpression memberPatternCondition = createConditionForListMemberPattern(i,\n+                    matchPatterns.get(i), tempCastVarDef, blockStmt, memberTupleTypes.get(i), pos);\n+\n+            condition = ASTBuilderUtil.createBinaryExpr(pos, condition, memberPatternCondition,\n+                    symTable.booleanType, OperatorKind.AND, (BOperatorSymbol) symResolver\n+                            .resolveBinaryOperator(OperatorKind.AND, symTable.booleanType,\n+                                    symTable.booleanType));\n+        }\n+\n+        BLangBlockStmt tempBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+        tempBlockStmt.addStatement(successResult);\n+        BLangIf ifStmtForMatchPatterns = ASTBuilderUtil.createIfElseStmt(pos, condition, tempBlockStmt, null);\n+        blockStmt.addStatement(ifStmtForMatchPatterns);\n+\n+        BLangStatementExpression statementExpression = ASTBuilderUtil.createStatementExpression(blockStmt,\n+                resultVarRef);\n+        statementExpression.type = symTable.booleanType;\n+        return statementExpression;\n+    }\n+\n+    private BLangExpression createVarCheckConditionForMappingMatchPattern(BLangMappingMatchPattern mappingMatchPattern,\n+                                                                          BLangSimpleVarRef varRef) {\n+        BRecordType recordType = (BRecordType) mappingMatchPattern.type;\n+        Location pos = mappingMatchPattern.pos;\n+        BLangBlockStmt blockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+\n+        BLangSimpleVariableDef resultVarDef = createVarDef(\"$mappingPatternVarResult$\", symTable.booleanType,\n+                null, pos);\n+        BLangSimpleVarRef resultVarRef = ASTBuilderUtil.createVariableRef(pos, resultVarDef.var.symbol);\n+        blockStmt.addStatement(resultVarDef);\n+\n+        BLangAssignment failureResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(false));\n+        BLangAssignment successResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(true));\n+        blockStmt.addStatement(failureResult);\n+\n+        BLangSimpleVariableDef tempCastVarDef = createVarDef(\"$castTemp$\", mappingMatchPattern.type, varRef,\n+                pos);\n+        blockStmt.addStatement(tempCastVarDef);\n+\n+        BLangExpression condition =\n+                createConditionForFieldMatchPatterns(mappingMatchPattern.fieldMatchPatterns, tempCastVarDef,\n+                        blockStmt, pos);\n+\n+        BLangBlockStmt tempBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+        tempBlockStmt.addStatement(successResult);\n+        BLangIf ifStmtForMatchPatterns = ASTBuilderUtil.createIfElseStmt(pos, condition, tempBlockStmt, null);\n+        blockStmt.addStatement(ifStmtForMatchPatterns);\n+\n+        BLangStatementExpression statementExpression = ASTBuilderUtil.createStatementExpression(blockStmt,\n+                resultVarRef);\n+        statementExpression.type = symTable.booleanType;\n+        addAsRecordTypeDefinition(recordType, pos);\n+        return statementExpression;\n+    }\n+\n+    private void addAsRecordTypeDefinition(BType type, Location pos) {\n+        if (type.tag == TypeTags.UNION) {\n+            for (BType memberType : ((BUnionType) type).getMemberTypes()) {\n+                addAsRecordTypeDefinition(memberType, pos);\n+            }", "originalCommit": "a795ecd1ecb76c24c1d87a0e00b7ecd1849f0ef4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM2OTc0Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r556369743", "bodyText": "Fixed", "author": "KavinduZoysa", "createdAt": "2021-01-13T09:15:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI1NjgyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI1ODAyNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r556258025", "bodyText": "Can't we use org.wso2.ballerinalang.compiler.util.TypeDefBuilderHelper#createRecordTypeNode(org.wso2.ballerinalang.compiler.semantics.model.types.BRecordType, org.ballerinalang.model.elements.PackageID, org.wso2.ballerinalang.compiler.semantics.model.SymbolTable, io.ballerina.tools.diagnostics.Location) here?\nIf there's something missing I think it should go in TypeDefBuilderHelper rather than adding it here.", "author": "MaryamZi", "createdAt": "2021-01-13T04:39:41Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -3463,89 +3487,252 @@ private BLangExpression createConditionForListMemberPattern(int index, BLangMatc\n         return createVarCheckCondition(listMemberMatchPattern, tempVarRef);\n     }\n \n-    private BLangExpression createVarCheckCondition(BLangMatchPattern matchPattern,\n-                                                    BLangSimpleVarRef varRef) {\n+    private BLangExpression createConditionForMappingMatchPattern(BLangMappingMatchPattern mappingMatchPattern,\n+                                                                  BLangSimpleVarRef matchExprVarRef) {\n+        BType matchPatternType = mappingMatchPattern.type;\n+        Location pos = mappingMatchPattern.pos;\n \n-        NodeKind patternKind = matchPattern.getKind();\n-        switch (patternKind) {\n-            case WILDCARD_MATCH_PATTERN:\n-                return createConditionForWildCardMatchPattern((BLangWildCardMatchPattern) matchPattern);\n-            case CONST_MATCH_PATTERN:\n-                return createConditionForConstMatchPattern((BLangConstPattern) matchPattern, varRef);\n-            case VAR_BINDING_PATTERN_MATCH_PATTERN:\n-                return createConditionForVarBindingPatternMatchPattern(\n-                        (BLangVarBindingPatternMatchPattern) matchPattern, varRef);\n-            case LIST_MATCH_PATTERN:\n-                BLangListMatchPattern listMatchPattern = (BLangListMatchPattern) matchPattern;\n-                Location pos = listMatchPattern.pos;\n-                BLangBlockStmt blockStmt = ASTBuilderUtil.createBlockStmt(pos);\n-\n-                BLangSimpleVariableDef resultVarDef = createVarDef(\"$listPatternVarResult$\", symTable.booleanType, null,\n-                        pos);\n-                BLangSimpleVarRef resultVarRef = ASTBuilderUtil.createVariableRef(pos, resultVarDef.var.symbol);\n-                blockStmt.addStatement(resultVarDef);\n-\n-                BLangAssignment failureResult =\n-                        ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(false));\n-                BLangAssignment successResult =\n-                        ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(true));\n-                blockStmt.addStatement(failureResult);\n-\n-                List<BType> memberTupleTypes = ((BTupleType) varRef.type).getTupleTypes();\n-                List<BLangMatchPattern> matchPatterns = listMatchPattern.matchPatterns;\n-\n-                BLangSimpleVariableDef tempCastVarDef = createVarDef(\"$castTemp$\", varRef.type, varRef, pos);\n-                blockStmt.addStatement(tempCastVarDef);\n-                BLangExpression condition = createConditionForListMemberPattern(0, matchPatterns.get(0),\n-                        tempCastVarDef, blockStmt, memberTupleTypes.get(0), pos);\n-\n-                for (int i = 1; i < matchPatterns.size(); i++) {\n-                    BLangExpression memberPatternCondition = createConditionForListMemberPattern(i,\n-                            matchPatterns.get(i), tempCastVarDef, blockStmt, memberTupleTypes.get(i), pos);\n-\n-                    condition = ASTBuilderUtil.createBinaryExpr(pos, condition, memberPatternCondition,\n-                            symTable.booleanType, OperatorKind.AND, (BOperatorSymbol) symResolver\n-                                    .resolveBinaryOperator(OperatorKind.AND, symTable.booleanType,\n-                                            symTable.booleanType));\n-                }\n+        BLangSimpleVariableDef resultVarDef = createVarDef(\"$mappingPatternResult$\", symTable.booleanType, null, pos);\n+        BLangSimpleVarRef resultVarRef = ASTBuilderUtil.createVariableRef(pos, resultVarDef.var.symbol);\n+        BLangBlockStmt mainBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+        mainBlockStmt.addStatement(resultVarDef);\n+\n+        BLangAssignment failureResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(false));\n+        BLangAssignment successResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(true));\n+        mainBlockStmt.addStatement(failureResult);\n \n-                BLangBlockStmt tempBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n-                tempBlockStmt.addStatement(successResult);\n-                BLangIf ifStmtForMatchPatterns = ASTBuilderUtil.createIfElseStmt(pos, condition, tempBlockStmt, null);\n-                blockStmt.addStatement(ifStmtForMatchPatterns);\n+        BLangExpression typeCheckCondition = createIsLikeExpression(mappingMatchPattern.pos, matchExprVarRef,\n+                matchPatternType);\n+        BLangExpression typeConvertedExpr = addConversionExprIfRequired(matchExprVarRef, matchPatternType);\n+        BLangSimpleVariableDef tempCastVarDef = createVarDef(\"$castTemp$\", matchPatternType, typeConvertedExpr, pos);\n+        BLangSimpleVarRef tempCastVarRef = ASTBuilderUtil.createVariableRef(pos, tempCastVarDef.var.symbol);\n \n-                BLangStatementExpression statementExpression = ASTBuilderUtil.createStatementExpression(blockStmt,\n-                        resultVarRef);\n-                statementExpression.type = symTable.booleanType;\n-                return statementExpression;\n-            default:\n-                // If some patterns are not implemented, those should be detected before this phase\n-                // TODO : Remove this after all patterns are implemented\n-                return null;\n+        BLangBlockStmt ifBlock = ASTBuilderUtil.createBlockStmt(pos);\n+        ifBlock.addStatement(tempCastVarDef);\n+        BLangIf ifStmt = ASTBuilderUtil.createIfElseStmt(pos, typeCheckCondition, ifBlock, null);\n+        mainBlockStmt.addStatement(ifStmt);\n+\n+        BLangExpression condition = createConditionForFieldMatchPatterns(mappingMatchPattern.fieldMatchPatterns,\n+                tempCastVarDef, ifBlock, pos);\n+\n+        BLangBlockStmt tempBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+        tempBlockStmt.addStatement(successResult);\n+        if (mappingMatchPattern.restMatchPattern != null) {\n+            BLangRestMatchPattern restMatchPattern = mappingMatchPattern.restMatchPattern;\n+            Location restPatternPos = restMatchPattern.pos;\n+            List<String> keysToRemove = getKeysToRemove(mappingMatchPattern);\n+            BMapType entriesType = new BMapType(TypeTags.MAP, new BTupleType(Arrays.asList(symTable.stringType,\n+                    ((BMapType) mappingMatchPattern.restMatchPattern.type).constraint)), null);\n+            BLangInvocation entriesInvocation = generateMapEntriesInvocation(tempCastVarRef, entriesType);\n+            BLangSimpleVariableDef entriesVarDef = createVarDef(\"$entries$\", entriesType, entriesInvocation,\n+                    restPatternPos);\n+            tempBlockStmt.addStatement(entriesVarDef);\n+            BLangLambdaFunction filteringFunction = createFuncToFilterOutRestParam(keysToRemove, restPatternPos);\n+            BLangInvocation filterInvocation = generateMapFilterInvocation(pos, entriesVarDef.var, filteringFunction);\n+            BLangSimpleVariableDef filtersVarDef = createVarDef(\"$filteredVarDef$\", entriesType, filterInvocation,\n+                    restPatternPos);\n+            tempBlockStmt.addStatement(filtersVarDef);\n+            BLangLambdaFunction backToMapLambda = generateEntriesToMapLambda(restPatternPos);\n+            BLangInvocation mapInvocation = generateMapMapInvocation(restPatternPos, filtersVarDef.var,\n+                    backToMapLambda);\n+            BLangSimpleVarRef restMatchPatternVarRef = declaredVarDef.get(restMatchPattern.getIdentifier().getValue());\n+            tempBlockStmt.addStatement(ASTBuilderUtil.createAssignmentStmt(pos, restMatchPatternVarRef, mapInvocation));\n+        }\n+        BLangIf ifStmtForMatchPatterns = ASTBuilderUtil.createIfElseStmt(pos, condition, tempBlockStmt, null);\n+        ifBlock.addStatement(ifStmtForMatchPatterns);\n+\n+        BLangStatementExpression statementExpression = ASTBuilderUtil.createStatementExpression(mainBlockStmt,\n+                resultVarRef);\n+        statementExpression.type = symTable.booleanType;\n+\n+        addAsRecordTypeDefinition(matchPatternType, pos);\n+        return statementExpression;\n+    }\n+\n+    private List<String> getKeysToRemove(BLangMappingMatchPattern mappingMatchPattern) {\n+        List<String> keysToRemove = new ArrayList<>();\n+        for (BLangFieldMatchPattern fieldMatchPattern : mappingMatchPattern.fieldMatchPatterns) {\n+            keysToRemove.add(fieldMatchPattern.fieldName.value);\n         }\n+        return keysToRemove;\n     }\n \n-    private BLangExpression createConditionForMatchPattern(BLangMatchPattern matchPattern,\n-                                                           BLangSimpleVarRef matchExprVarRef) {\n+    private BLangExpression createConditionForFieldMatchPatterns(List<BLangFieldMatchPattern> fieldMatchPatterns,\n+                                                                 BLangSimpleVariableDef varDef,\n+                                                                 BLangBlockStmt blockStmt,\n+                                                                 Location pos) {\n+        BLangExpression condition = ASTBuilderUtil.createLiteral(pos, symTable.booleanType, true);\n+        for (int i = 0; i < fieldMatchPatterns.size(); i++) {\n+            BLangExpression fieldMatchPatternCondition =\n+                    createConditionForFieldMatchPattern(i, fieldMatchPatterns.get(i), varDef, blockStmt);\n+            condition = ASTBuilderUtil.createBinaryExpr(pos, condition, fieldMatchPatternCondition,\n+                    symTable.booleanType, OperatorKind.AND, (BOperatorSymbol) symResolver\n+                            .resolveBinaryOperator(OperatorKind.AND, symTable.booleanType, symTable.booleanType));\n+        }\n+        return condition;\n+    }\n+\n+    private BLangExpression createConditionForFieldMatchPattern(int index, BLangFieldMatchPattern fieldMatchPattern,\n+                                                                BLangSimpleVariableDef tempCastVarDef,\n+                                                                BLangBlockStmt blockStmt) {\n+        String fieldName = fieldMatchPattern.fieldName.value;\n+        BLangMatchPattern matchPattern = fieldMatchPattern.matchPattern;\n+        BLangFieldBasedAccess fieldBasedAccessExpr = getFieldAccessExpression(fieldMatchPattern.pos, fieldName,\n+                matchPattern.type, tempCastVarDef.var.symbol);\n+        BLangSimpleVariableDef tempVarDef = createVarDef(\"$memberVarTemp$\" + index + \"_$\", matchPattern.type,\n+                fieldBasedAccessExpr, matchPattern.pos);\n+        BLangSimpleVarRef tempVarRef = ASTBuilderUtil.createVariableRef(matchPattern.pos, tempVarDef.var.symbol);\n+        blockStmt.addStatement(tempVarDef);\n+        return createVarCheckCondition(matchPattern, tempVarRef);\n+    }\n+\n+    private BLangExpression createVarCheckCondition(BLangMatchPattern matchPattern, BLangSimpleVarRef varRef) {\n \n         NodeKind patternKind = matchPattern.getKind();\n         switch (patternKind) {\n             case WILDCARD_MATCH_PATTERN:\n                 return createConditionForWildCardMatchPattern((BLangWildCardMatchPattern) matchPattern);\n             case CONST_MATCH_PATTERN:\n-                return createConditionForConstMatchPattern((BLangConstPattern) matchPattern, matchExprVarRef);\n+                return createConditionForConstMatchPattern((BLangConstPattern) matchPattern, varRef);\n             case VAR_BINDING_PATTERN_MATCH_PATTERN:\n                 return createConditionForVarBindingPatternMatchPattern(\n-                        (BLangVarBindingPatternMatchPattern) matchPattern, matchExprVarRef);\n+                        (BLangVarBindingPatternMatchPattern) matchPattern, varRef);\n             case LIST_MATCH_PATTERN:\n-                return createConditionForListMatchPattern((BLangListMatchPattern) matchPattern, matchExprVarRef);\n+                return createVarCheckConditionForListMatchPattern((BLangListMatchPattern) matchPattern, varRef);\n+            case MAPPING_MATCH_PATTERN:\n+                return createVarCheckConditionForMappingMatchPattern((BLangMappingMatchPattern) matchPattern, varRef);\n             default:\n                 // If some patterns are not implemented, those should be detected before this phase\n                 // TODO : Remove this after all patterns are implemented\n                 return null;\n         }\n     }\n \n+    private BLangExpression createVarCheckConditionForListMatchPattern(BLangListMatchPattern listMatchPattern,\n+                                                                       BLangSimpleVarRef varRef) {\n+        Location pos = listMatchPattern.pos;\n+        BLangBlockStmt blockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+\n+        BLangSimpleVariableDef resultVarDef = createVarDef(\"$listPatternVarResult$\", symTable.booleanType, null,\n+                pos);\n+        BLangSimpleVarRef resultVarRef = ASTBuilderUtil.createVariableRef(pos, resultVarDef.var.symbol);\n+        blockStmt.addStatement(resultVarDef);\n+\n+        BLangAssignment failureResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(false));\n+        BLangAssignment successResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(true));\n+        blockStmt.addStatement(failureResult);\n+\n+        List<BType> memberTupleTypes = ((BTupleType) varRef.type).getTupleTypes();\n+        List<BLangMatchPattern> matchPatterns = listMatchPattern.matchPatterns;\n+\n+        BLangSimpleVariableDef tempCastVarDef = createVarDef(\"$castTemp$\", varRef.type, varRef, pos);\n+        blockStmt.addStatement(tempCastVarDef);\n+        BLangExpression condition = createConditionForListMemberPattern(0, matchPatterns.get(0),\n+                tempCastVarDef, blockStmt, memberTupleTypes.get(0), pos);\n+\n+        for (int i = 1; i < matchPatterns.size(); i++) {\n+            BLangExpression memberPatternCondition = createConditionForListMemberPattern(i,\n+                    matchPatterns.get(i), tempCastVarDef, blockStmt, memberTupleTypes.get(i), pos);\n+\n+            condition = ASTBuilderUtil.createBinaryExpr(pos, condition, memberPatternCondition,\n+                    symTable.booleanType, OperatorKind.AND, (BOperatorSymbol) symResolver\n+                            .resolveBinaryOperator(OperatorKind.AND, symTable.booleanType,\n+                                    symTable.booleanType));\n+        }\n+\n+        BLangBlockStmt tempBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+        tempBlockStmt.addStatement(successResult);\n+        BLangIf ifStmtForMatchPatterns = ASTBuilderUtil.createIfElseStmt(pos, condition, tempBlockStmt, null);\n+        blockStmt.addStatement(ifStmtForMatchPatterns);\n+\n+        BLangStatementExpression statementExpression = ASTBuilderUtil.createStatementExpression(blockStmt,\n+                resultVarRef);\n+        statementExpression.type = symTable.booleanType;\n+        return statementExpression;\n+    }\n+\n+    private BLangExpression createVarCheckConditionForMappingMatchPattern(BLangMappingMatchPattern mappingMatchPattern,\n+                                                                          BLangSimpleVarRef varRef) {\n+        BRecordType recordType = (BRecordType) mappingMatchPattern.type;\n+        Location pos = mappingMatchPattern.pos;\n+        BLangBlockStmt blockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+\n+        BLangSimpleVariableDef resultVarDef = createVarDef(\"$mappingPatternVarResult$\", symTable.booleanType,\n+                null, pos);\n+        BLangSimpleVarRef resultVarRef = ASTBuilderUtil.createVariableRef(pos, resultVarDef.var.symbol);\n+        blockStmt.addStatement(resultVarDef);\n+\n+        BLangAssignment failureResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(false));\n+        BLangAssignment successResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(true));\n+        blockStmt.addStatement(failureResult);\n+\n+        BLangSimpleVariableDef tempCastVarDef = createVarDef(\"$castTemp$\", mappingMatchPattern.type, varRef,\n+                pos);\n+        blockStmt.addStatement(tempCastVarDef);\n+\n+        BLangExpression condition =\n+                createConditionForFieldMatchPatterns(mappingMatchPattern.fieldMatchPatterns, tempCastVarDef,\n+                        blockStmt, pos);\n+\n+        BLangBlockStmt tempBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+        tempBlockStmt.addStatement(successResult);\n+        BLangIf ifStmtForMatchPatterns = ASTBuilderUtil.createIfElseStmt(pos, condition, tempBlockStmt, null);\n+        blockStmt.addStatement(ifStmtForMatchPatterns);\n+\n+        BLangStatementExpression statementExpression = ASTBuilderUtil.createStatementExpression(blockStmt,\n+                resultVarRef);\n+        statementExpression.type = symTable.booleanType;\n+        addAsRecordTypeDefinition(recordType, pos);\n+        return statementExpression;\n+    }\n+\n+    private void addAsRecordTypeDefinition(BType type, Location pos) {", "originalCommit": "a795ecd1ecb76c24c1d87a0e00b7ecd1849f0ef4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI1ODIzMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r556258230", "bodyText": "What's the scenario where this becomes true?", "author": "MaryamZi", "createdAt": "2021-01-13T04:40:29Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -3463,89 +3487,252 @@ private BLangExpression createConditionForListMemberPattern(int index, BLangMatc\n         return createVarCheckCondition(listMemberMatchPattern, tempVarRef);\n     }\n \n-    private BLangExpression createVarCheckCondition(BLangMatchPattern matchPattern,\n-                                                    BLangSimpleVarRef varRef) {\n+    private BLangExpression createConditionForMappingMatchPattern(BLangMappingMatchPattern mappingMatchPattern,\n+                                                                  BLangSimpleVarRef matchExprVarRef) {\n+        BType matchPatternType = mappingMatchPattern.type;\n+        Location pos = mappingMatchPattern.pos;\n \n-        NodeKind patternKind = matchPattern.getKind();\n-        switch (patternKind) {\n-            case WILDCARD_MATCH_PATTERN:\n-                return createConditionForWildCardMatchPattern((BLangWildCardMatchPattern) matchPattern);\n-            case CONST_MATCH_PATTERN:\n-                return createConditionForConstMatchPattern((BLangConstPattern) matchPattern, varRef);\n-            case VAR_BINDING_PATTERN_MATCH_PATTERN:\n-                return createConditionForVarBindingPatternMatchPattern(\n-                        (BLangVarBindingPatternMatchPattern) matchPattern, varRef);\n-            case LIST_MATCH_PATTERN:\n-                BLangListMatchPattern listMatchPattern = (BLangListMatchPattern) matchPattern;\n-                Location pos = listMatchPattern.pos;\n-                BLangBlockStmt blockStmt = ASTBuilderUtil.createBlockStmt(pos);\n-\n-                BLangSimpleVariableDef resultVarDef = createVarDef(\"$listPatternVarResult$\", symTable.booleanType, null,\n-                        pos);\n-                BLangSimpleVarRef resultVarRef = ASTBuilderUtil.createVariableRef(pos, resultVarDef.var.symbol);\n-                blockStmt.addStatement(resultVarDef);\n-\n-                BLangAssignment failureResult =\n-                        ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(false));\n-                BLangAssignment successResult =\n-                        ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(true));\n-                blockStmt.addStatement(failureResult);\n-\n-                List<BType> memberTupleTypes = ((BTupleType) varRef.type).getTupleTypes();\n-                List<BLangMatchPattern> matchPatterns = listMatchPattern.matchPatterns;\n-\n-                BLangSimpleVariableDef tempCastVarDef = createVarDef(\"$castTemp$\", varRef.type, varRef, pos);\n-                blockStmt.addStatement(tempCastVarDef);\n-                BLangExpression condition = createConditionForListMemberPattern(0, matchPatterns.get(0),\n-                        tempCastVarDef, blockStmt, memberTupleTypes.get(0), pos);\n-\n-                for (int i = 1; i < matchPatterns.size(); i++) {\n-                    BLangExpression memberPatternCondition = createConditionForListMemberPattern(i,\n-                            matchPatterns.get(i), tempCastVarDef, blockStmt, memberTupleTypes.get(i), pos);\n-\n-                    condition = ASTBuilderUtil.createBinaryExpr(pos, condition, memberPatternCondition,\n-                            symTable.booleanType, OperatorKind.AND, (BOperatorSymbol) symResolver\n-                                    .resolveBinaryOperator(OperatorKind.AND, symTable.booleanType,\n-                                            symTable.booleanType));\n-                }\n+        BLangSimpleVariableDef resultVarDef = createVarDef(\"$mappingPatternResult$\", symTable.booleanType, null, pos);\n+        BLangSimpleVarRef resultVarRef = ASTBuilderUtil.createVariableRef(pos, resultVarDef.var.symbol);\n+        BLangBlockStmt mainBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+        mainBlockStmt.addStatement(resultVarDef);\n+\n+        BLangAssignment failureResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(false));\n+        BLangAssignment successResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(true));\n+        mainBlockStmt.addStatement(failureResult);\n \n-                BLangBlockStmt tempBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n-                tempBlockStmt.addStatement(successResult);\n-                BLangIf ifStmtForMatchPatterns = ASTBuilderUtil.createIfElseStmt(pos, condition, tempBlockStmt, null);\n-                blockStmt.addStatement(ifStmtForMatchPatterns);\n+        BLangExpression typeCheckCondition = createIsLikeExpression(mappingMatchPattern.pos, matchExprVarRef,\n+                matchPatternType);\n+        BLangExpression typeConvertedExpr = addConversionExprIfRequired(matchExprVarRef, matchPatternType);\n+        BLangSimpleVariableDef tempCastVarDef = createVarDef(\"$castTemp$\", matchPatternType, typeConvertedExpr, pos);\n+        BLangSimpleVarRef tempCastVarRef = ASTBuilderUtil.createVariableRef(pos, tempCastVarDef.var.symbol);\n \n-                BLangStatementExpression statementExpression = ASTBuilderUtil.createStatementExpression(blockStmt,\n-                        resultVarRef);\n-                statementExpression.type = symTable.booleanType;\n-                return statementExpression;\n-            default:\n-                // If some patterns are not implemented, those should be detected before this phase\n-                // TODO : Remove this after all patterns are implemented\n-                return null;\n+        BLangBlockStmt ifBlock = ASTBuilderUtil.createBlockStmt(pos);\n+        ifBlock.addStatement(tempCastVarDef);\n+        BLangIf ifStmt = ASTBuilderUtil.createIfElseStmt(pos, typeCheckCondition, ifBlock, null);\n+        mainBlockStmt.addStatement(ifStmt);\n+\n+        BLangExpression condition = createConditionForFieldMatchPatterns(mappingMatchPattern.fieldMatchPatterns,\n+                tempCastVarDef, ifBlock, pos);\n+\n+        BLangBlockStmt tempBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+        tempBlockStmt.addStatement(successResult);\n+        if (mappingMatchPattern.restMatchPattern != null) {\n+            BLangRestMatchPattern restMatchPattern = mappingMatchPattern.restMatchPattern;\n+            Location restPatternPos = restMatchPattern.pos;\n+            List<String> keysToRemove = getKeysToRemove(mappingMatchPattern);\n+            BMapType entriesType = new BMapType(TypeTags.MAP, new BTupleType(Arrays.asList(symTable.stringType,\n+                    ((BMapType) mappingMatchPattern.restMatchPattern.type).constraint)), null);\n+            BLangInvocation entriesInvocation = generateMapEntriesInvocation(tempCastVarRef, entriesType);\n+            BLangSimpleVariableDef entriesVarDef = createVarDef(\"$entries$\", entriesType, entriesInvocation,\n+                    restPatternPos);\n+            tempBlockStmt.addStatement(entriesVarDef);\n+            BLangLambdaFunction filteringFunction = createFuncToFilterOutRestParam(keysToRemove, restPatternPos);\n+            BLangInvocation filterInvocation = generateMapFilterInvocation(pos, entriesVarDef.var, filteringFunction);\n+            BLangSimpleVariableDef filtersVarDef = createVarDef(\"$filteredVarDef$\", entriesType, filterInvocation,\n+                    restPatternPos);\n+            tempBlockStmt.addStatement(filtersVarDef);\n+            BLangLambdaFunction backToMapLambda = generateEntriesToMapLambda(restPatternPos);\n+            BLangInvocation mapInvocation = generateMapMapInvocation(restPatternPos, filtersVarDef.var,\n+                    backToMapLambda);\n+            BLangSimpleVarRef restMatchPatternVarRef = declaredVarDef.get(restMatchPattern.getIdentifier().getValue());\n+            tempBlockStmt.addStatement(ASTBuilderUtil.createAssignmentStmt(pos, restMatchPatternVarRef, mapInvocation));\n+        }\n+        BLangIf ifStmtForMatchPatterns = ASTBuilderUtil.createIfElseStmt(pos, condition, tempBlockStmt, null);\n+        ifBlock.addStatement(ifStmtForMatchPatterns);\n+\n+        BLangStatementExpression statementExpression = ASTBuilderUtil.createStatementExpression(mainBlockStmt,\n+                resultVarRef);\n+        statementExpression.type = symTable.booleanType;\n+\n+        addAsRecordTypeDefinition(matchPatternType, pos);\n+        return statementExpression;\n+    }\n+\n+    private List<String> getKeysToRemove(BLangMappingMatchPattern mappingMatchPattern) {\n+        List<String> keysToRemove = new ArrayList<>();\n+        for (BLangFieldMatchPattern fieldMatchPattern : mappingMatchPattern.fieldMatchPatterns) {\n+            keysToRemove.add(fieldMatchPattern.fieldName.value);\n         }\n+        return keysToRemove;\n     }\n \n-    private BLangExpression createConditionForMatchPattern(BLangMatchPattern matchPattern,\n-                                                           BLangSimpleVarRef matchExprVarRef) {\n+    private BLangExpression createConditionForFieldMatchPatterns(List<BLangFieldMatchPattern> fieldMatchPatterns,\n+                                                                 BLangSimpleVariableDef varDef,\n+                                                                 BLangBlockStmt blockStmt,\n+                                                                 Location pos) {\n+        BLangExpression condition = ASTBuilderUtil.createLiteral(pos, symTable.booleanType, true);\n+        for (int i = 0; i < fieldMatchPatterns.size(); i++) {\n+            BLangExpression fieldMatchPatternCondition =\n+                    createConditionForFieldMatchPattern(i, fieldMatchPatterns.get(i), varDef, blockStmt);\n+            condition = ASTBuilderUtil.createBinaryExpr(pos, condition, fieldMatchPatternCondition,\n+                    symTable.booleanType, OperatorKind.AND, (BOperatorSymbol) symResolver\n+                            .resolveBinaryOperator(OperatorKind.AND, symTable.booleanType, symTable.booleanType));\n+        }\n+        return condition;\n+    }\n+\n+    private BLangExpression createConditionForFieldMatchPattern(int index, BLangFieldMatchPattern fieldMatchPattern,\n+                                                                BLangSimpleVariableDef tempCastVarDef,\n+                                                                BLangBlockStmt blockStmt) {\n+        String fieldName = fieldMatchPattern.fieldName.value;\n+        BLangMatchPattern matchPattern = fieldMatchPattern.matchPattern;\n+        BLangFieldBasedAccess fieldBasedAccessExpr = getFieldAccessExpression(fieldMatchPattern.pos, fieldName,\n+                matchPattern.type, tempCastVarDef.var.symbol);\n+        BLangSimpleVariableDef tempVarDef = createVarDef(\"$memberVarTemp$\" + index + \"_$\", matchPattern.type,\n+                fieldBasedAccessExpr, matchPattern.pos);\n+        BLangSimpleVarRef tempVarRef = ASTBuilderUtil.createVariableRef(matchPattern.pos, tempVarDef.var.symbol);\n+        blockStmt.addStatement(tempVarDef);\n+        return createVarCheckCondition(matchPattern, tempVarRef);\n+    }\n+\n+    private BLangExpression createVarCheckCondition(BLangMatchPattern matchPattern, BLangSimpleVarRef varRef) {\n \n         NodeKind patternKind = matchPattern.getKind();\n         switch (patternKind) {\n             case WILDCARD_MATCH_PATTERN:\n                 return createConditionForWildCardMatchPattern((BLangWildCardMatchPattern) matchPattern);\n             case CONST_MATCH_PATTERN:\n-                return createConditionForConstMatchPattern((BLangConstPattern) matchPattern, matchExprVarRef);\n+                return createConditionForConstMatchPattern((BLangConstPattern) matchPattern, varRef);\n             case VAR_BINDING_PATTERN_MATCH_PATTERN:\n                 return createConditionForVarBindingPatternMatchPattern(\n-                        (BLangVarBindingPatternMatchPattern) matchPattern, matchExprVarRef);\n+                        (BLangVarBindingPatternMatchPattern) matchPattern, varRef);\n             case LIST_MATCH_PATTERN:\n-                return createConditionForListMatchPattern((BLangListMatchPattern) matchPattern, matchExprVarRef);\n+                return createVarCheckConditionForListMatchPattern((BLangListMatchPattern) matchPattern, varRef);\n+            case MAPPING_MATCH_PATTERN:\n+                return createVarCheckConditionForMappingMatchPattern((BLangMappingMatchPattern) matchPattern, varRef);\n             default:\n                 // If some patterns are not implemented, those should be detected before this phase\n                 // TODO : Remove this after all patterns are implemented\n                 return null;\n         }\n     }\n \n+    private BLangExpression createVarCheckConditionForListMatchPattern(BLangListMatchPattern listMatchPattern,\n+                                                                       BLangSimpleVarRef varRef) {\n+        Location pos = listMatchPattern.pos;\n+        BLangBlockStmt blockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+\n+        BLangSimpleVariableDef resultVarDef = createVarDef(\"$listPatternVarResult$\", symTable.booleanType, null,\n+                pos);\n+        BLangSimpleVarRef resultVarRef = ASTBuilderUtil.createVariableRef(pos, resultVarDef.var.symbol);\n+        blockStmt.addStatement(resultVarDef);\n+\n+        BLangAssignment failureResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(false));\n+        BLangAssignment successResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(true));\n+        blockStmt.addStatement(failureResult);\n+\n+        List<BType> memberTupleTypes = ((BTupleType) varRef.type).getTupleTypes();\n+        List<BLangMatchPattern> matchPatterns = listMatchPattern.matchPatterns;\n+\n+        BLangSimpleVariableDef tempCastVarDef = createVarDef(\"$castTemp$\", varRef.type, varRef, pos);\n+        blockStmt.addStatement(tempCastVarDef);\n+        BLangExpression condition = createConditionForListMemberPattern(0, matchPatterns.get(0),\n+                tempCastVarDef, blockStmt, memberTupleTypes.get(0), pos);\n+\n+        for (int i = 1; i < matchPatterns.size(); i++) {\n+            BLangExpression memberPatternCondition = createConditionForListMemberPattern(i,\n+                    matchPatterns.get(i), tempCastVarDef, blockStmt, memberTupleTypes.get(i), pos);\n+\n+            condition = ASTBuilderUtil.createBinaryExpr(pos, condition, memberPatternCondition,\n+                    symTable.booleanType, OperatorKind.AND, (BOperatorSymbol) symResolver\n+                            .resolveBinaryOperator(OperatorKind.AND, symTable.booleanType,\n+                                    symTable.booleanType));\n+        }\n+\n+        BLangBlockStmt tempBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+        tempBlockStmt.addStatement(successResult);\n+        BLangIf ifStmtForMatchPatterns = ASTBuilderUtil.createIfElseStmt(pos, condition, tempBlockStmt, null);\n+        blockStmt.addStatement(ifStmtForMatchPatterns);\n+\n+        BLangStatementExpression statementExpression = ASTBuilderUtil.createStatementExpression(blockStmt,\n+                resultVarRef);\n+        statementExpression.type = symTable.booleanType;\n+        return statementExpression;\n+    }\n+\n+    private BLangExpression createVarCheckConditionForMappingMatchPattern(BLangMappingMatchPattern mappingMatchPattern,\n+                                                                          BLangSimpleVarRef varRef) {\n+        BRecordType recordType = (BRecordType) mappingMatchPattern.type;\n+        Location pos = mappingMatchPattern.pos;\n+        BLangBlockStmt blockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+\n+        BLangSimpleVariableDef resultVarDef = createVarDef(\"$mappingPatternVarResult$\", symTable.booleanType,\n+                null, pos);\n+        BLangSimpleVarRef resultVarRef = ASTBuilderUtil.createVariableRef(pos, resultVarDef.var.symbol);\n+        blockStmt.addStatement(resultVarDef);\n+\n+        BLangAssignment failureResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(false));\n+        BLangAssignment successResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(true));\n+        blockStmt.addStatement(failureResult);\n+\n+        BLangSimpleVariableDef tempCastVarDef = createVarDef(\"$castTemp$\", mappingMatchPattern.type, varRef,\n+                pos);\n+        blockStmt.addStatement(tempCastVarDef);\n+\n+        BLangExpression condition =\n+                createConditionForFieldMatchPatterns(mappingMatchPattern.fieldMatchPatterns, tempCastVarDef,\n+                        blockStmt, pos);\n+\n+        BLangBlockStmt tempBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+        tempBlockStmt.addStatement(successResult);\n+        BLangIf ifStmtForMatchPatterns = ASTBuilderUtil.createIfElseStmt(pos, condition, tempBlockStmt, null);\n+        blockStmt.addStatement(ifStmtForMatchPatterns);\n+\n+        BLangStatementExpression statementExpression = ASTBuilderUtil.createStatementExpression(blockStmt,\n+                resultVarRef);\n+        statementExpression.type = symTable.booleanType;\n+        addAsRecordTypeDefinition(recordType, pos);\n+        return statementExpression;\n+    }\n+\n+    private void addAsRecordTypeDefinition(BType type, Location pos) {\n+        if (type.tag == TypeTags.UNION) {\n+            for (BType memberType : ((BUnionType) type).getMemberTypes()) {\n+                addAsRecordTypeDefinition(memberType, pos);\n+            }\n+        }\n+        if (type.tag != TypeTags.RECORD) {\n+            return;\n+        }\n+        BRecordType recordType = (BRecordType) type;\n+        if (isRecordTypeDefExist(recordType.tsymbol, env)) {", "originalCommit": "a795ecd1ecb76c24c1d87a0e00b7ecd1849f0ef4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM2OTY0MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r556369640", "bodyText": "function foo(record {int x; int|string y;} v) returns string {\n    match v {\n        {x: 2, y: 3} => {\n            return \"match1\";\n        }\n        {x: 2, y: \"3\"} => {\n            return \"match2\";\n        }\n        {x: 2, y: var a} => {\n            return \"match3\";\n        }\n    }\n    return \"No match\";\n}\n\nIn this example, type of 3rd match-pattern is taken as {int, any|error}. Then it is resolved as {int, int|string} (type of v). In this process, tSymbol of match-pattern becomes, the tSymbol of v (this happens in getIntersectionType() function) which is already defined as typeDef in top level.", "author": "KavinduZoysa", "createdAt": "2021-01-13T09:15:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI1ODIzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI2MDMzNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r556260334", "bodyText": "Unused variables.", "author": "MaryamZi", "createdAt": "2021-01-13T04:48:44Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -136,6 +137,8 @@\n     private Names names;\n     private int finiteTypeCount = 0;\n     private BUnionType expandedXMLBuiltinSubtypes;\n+    private int recordCount = 0;\n+    private SymbolEnv env;", "originalCommit": "a795ecd1ecb76c24c1d87a0e00b7ecd1849f0ef4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM2OTY1Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r556369652", "bodyText": "Fixed", "author": "KavinduZoysa", "createdAt": "2021-01-13T09:15:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI2MDMzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI2Mzc5MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r556263790", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @since Swan Lake\n          \n          \n            \n             * @since 2.0.0", "author": "MaryamZi", "createdAt": "2021-01-13T05:02:18Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/tree/matchpatterns/BLangMappingMatchPattern.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.tree.matchpatterns;\n+\n+import org.ballerinalang.model.tree.NodeKind;\n+import org.ballerinalang.model.tree.matchpatterns.FieldMatchPatternNode;\n+import org.ballerinalang.model.tree.matchpatterns.MappingMatchPatternNode;\n+import org.ballerinalang.model.tree.matchpatterns.RestMatchPatternNode;\n+import org.wso2.ballerinalang.compiler.tree.BLangNodeVisitor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Represent mapping-match-pattern.\n+ *\n+ * @since Swan Lake", "originalCommit": "a795ecd1ecb76c24c1d87a0e00b7ecd1849f0ef4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM2OTY4Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26144#discussion_r556369683", "bodyText": "Fixed", "author": "KavinduZoysa", "createdAt": "2021-01-13T09:15:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI2Mzc5MA=="}], "type": "inlineReview"}, {"oid": "72d63ef3b4ded54361a1f82dddc788d97dbf7f6d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/72d63ef3b4ded54361a1f82dddc788d97dbf7f6d", "message": "Fix review suggestions", "committedDate": "2021-01-13T09:14:22Z", "type": "forcePushed"}, {"oid": "545a8bb9b1f8b158053c3b811f61a2a5a2824366", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/545a8bb9b1f8b158053c3b811f61a2a5a2824366", "message": "Fix review suggestions", "committedDate": "2021-01-13T19:30:19Z", "type": "forcePushed"}, {"oid": "802a27539a3c7e3150df324046fa8bbf07efb9f7", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/802a27539a3c7e3150df324046fa8bbf07efb9f7", "message": "Fix review suggestions", "committedDate": "2021-01-14T03:51:57Z", "type": "forcePushed"}, {"oid": "dd2c008b0eead60dafd35099504dc2ddb14e9299", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/dd2c008b0eead60dafd35099504dc2ddb14e9299", "message": "Changed the parser", "committedDate": "2021-01-14T07:32:17Z", "type": "commit"}, {"oid": "05d18205bfc27cc2711e4a553cd928f6b879477f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/05d18205bfc27cc2711e4a553cd928f6b879477f", "message": "Change the transformer", "committedDate": "2021-01-14T07:32:17Z", "type": "commit"}, {"oid": "4e6b081c1fc6f8a0a2774b9dfb4a6eff8a365369", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4e6b081c1fc6f8a0a2774b9dfb4a6eff8a365369", "message": "Add nodes", "committedDate": "2021-01-14T07:32:17Z", "type": "commit"}, {"oid": "c768c6790c200168d47c9f7831bc85055a092929", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c768c6790c200168d47c9f7831bc85055a092929", "message": "Implement the logic", "committedDate": "2021-01-14T07:32:17Z", "type": "commit"}, {"oid": "ce467510a5a0a130e7a94796fed3b0593a2a24be", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ce467510a5a0a130e7a94796fed3b0593a2a24be", "message": "Add the tests", "committedDate": "2021-01-14T07:32:17Z", "type": "commit"}, {"oid": "63b4849b15c72b9342688792e46c6f56743e58be", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/63b4849b15c72b9342688792e46c6f56743e58be", "message": "Remove unused imports", "committedDate": "2021-01-14T07:32:17Z", "type": "commit"}, {"oid": "32f38ac77d0e92e13183ce4f63b401b4a2791e68", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/32f38ac77d0e92e13183ce4f63b401b4a2791e68", "message": "Enable tests", "committedDate": "2021-01-14T07:32:17Z", "type": "commit"}, {"oid": "b20a5d1a94c42580cf58aa14dc6751c2abe7cba9", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b20a5d1a94c42580cf58aa14dc6751c2abe7cba9", "message": "Support for rest-match-pattern", "committedDate": "2021-01-14T07:32:17Z", "type": "commit"}, {"oid": "0027e3a889c771376df1602f53d8d31e54d3c63c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0027e3a889c771376df1602f53d8d31e54d3c63c", "message": "Add tests", "committedDate": "2021-01-14T07:32:17Z", "type": "commit"}, {"oid": "c23bd2c93e3f7a4d0e053f83d68cc1d8732db34f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c23bd2c93e3f7a4d0e053f83d68cc1d8732db34f", "message": "Disable a formatter test", "committedDate": "2021-01-14T07:32:17Z", "type": "commit"}, {"oid": "710195563428498eddb454fc757e6f86a4ec088a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/710195563428498eddb454fc757e6f86a4ec088a", "message": "Add more tests", "committedDate": "2021-01-14T07:32:17Z", "type": "commit"}, {"oid": "829a0f7cee5549dc304f3b93f6301d1c59dbf480", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/829a0f7cee5549dc304f3b93f6301d1c59dbf480", "message": "Add new env", "committedDate": "2021-01-14T07:32:17Z", "type": "commit"}, {"oid": "c47f94d03f1fe418e1bb4a25a837d39ed9a9911a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c47f94d03f1fe418e1bb4a25a837d39ed9a9911a", "message": "Fix review suggestions", "committedDate": "2021-01-14T07:32:17Z", "type": "commit"}, {"oid": "f7b6f87e0ed27f0ca81b4b80a5fb9a5a4d569dc3", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f7b6f87e0ed27f0ca81b4b80a5fb9a5a4d569dc3", "message": "Add record intersection", "committedDate": "2021-01-14T07:32:17Z", "type": "commit"}, {"oid": "cacb48491f5363850b2c6cd28aa26fc18b562107", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/cacb48491f5363850b2c6cd28aa26fc18b562107", "message": "Handle zero patterns and fix suggestions", "committedDate": "2021-01-14T07:32:17Z", "type": "commit"}, {"oid": "a67288db480bc700e90d8c9a6ba92968fc657b47", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a67288db480bc700e90d8c9a6ba92968fc657b47", "message": "Rebase with master", "committedDate": "2021-01-14T07:32:17Z", "type": "commit"}, {"oid": "2c4afc627e79a1098feaeb77dc0d7d0ae3496ebe", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2c4afc627e79a1098feaeb77dc0d7d0ae3496ebe", "message": "Fix sugestions", "committedDate": "2021-01-14T07:32:17Z", "type": "commit"}, {"oid": "620d6c203a8ca74d79d00bb0a7aab9980d34f7dd", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/620d6c203a8ca74d79d00bb0a7aab9980d34f7dd", "message": "Sync with master", "committedDate": "2021-01-14T07:32:17Z", "type": "commit"}, {"oid": "3912c8b24c867847fec11d4e2c6a7fd17f57b3e6", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3912c8b24c867847fec11d4e2c6a7fd17f57b3e6", "message": "Fix review suggestions", "committedDate": "2021-01-14T07:32:17Z", "type": "commit"}, {"oid": "3912c8b24c867847fec11d4e2c6a7fd17f57b3e6", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3912c8b24c867847fec11d4e2c6a7fd17f57b3e6", "message": "Fix review suggestions", "committedDate": "2021-01-14T07:32:17Z", "type": "forcePushed"}]}