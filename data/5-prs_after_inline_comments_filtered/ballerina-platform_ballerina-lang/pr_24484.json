{"pr_number": 24484, "pr_title": "Add support for `readonly` fields in a mapping constructor expression and allow using `readonly` as the CET for mapping/list constructor expressions", "pr_createdAt": "2020-06-29T06:18:10Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484", "timeline": [{"oid": "48cee8ecce948907314da12198c6c57ae3fde0bc", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/48cee8ecce948907314da12198c6c57ae3fde0bc", "message": "Fix setting field readonly flag", "committedDate": "2020-06-24T06:22:47Z", "type": "commit"}, {"oid": "dad358769b870c33c37082d9a06780c74b4e5dbc", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/dad358769b870c33c37082d9a06780c74b4e5dbc", "message": "Infer a type for mapping-constrs with readonly fields", "committedDate": "2020-06-24T17:55:22Z", "type": "commit"}, {"oid": "77730ccd2afd3c7e3187f6967365dd1f660cb09a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/77730ccd2afd3c7e3187f6967365dd1f660cb09a", "message": "Fix error on readonly field with invalid type", "committedDate": "2020-06-24T18:46:58Z", "type": "commit"}, {"oid": "68257ea62dad097ad7effd55c5e6d088c3f4f8bb", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/68257ea62dad097ad7effd55c5e6d088c3f4f8bb", "message": "Make the inferred exclusive record type readonly if all constructor and CET fields are readonly", "committedDate": "2020-06-25T13:51:22Z", "type": "commit"}, {"oid": "fa6fc74f98f340aeb7cfca44c43fda066458e0b9", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fa6fc74f98f340aeb7cfca44c43fda066458e0b9", "message": "Add tests for readonly fields in the mapping-constructor", "committedDate": "2020-06-25T18:03:21Z", "type": "commit"}, {"oid": "871ac410420b9a9b50b1b5bdfd23d86204d55809", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/871ac410420b9a9b50b1b5bdfd23d86204d55809", "message": "Add readonly modifier in record/object readonly field string representation", "committedDate": "2020-06-26T14:25:27Z", "type": "commit"}, {"oid": "a635d3ba5837cae49d511cd1133fe0f1e5dcef00", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a635d3ba5837cae49d511cd1133fe0f1e5dcef00", "message": "Allow using readonly as the CET for map/list constructor exprs", "committedDate": "2020-06-28T07:34:15Z", "type": "commit"}, {"oid": "cc72c493e613c8cb89a93fbe6eb30e62e10dba58", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/cc72c493e613c8cb89a93fbe6eb30e62e10dba58", "message": "Fix anon record rest field not getting rewritten at desugar", "committedDate": "2020-06-28T07:45:28Z", "type": "commit"}, {"oid": "e5ba2799c8ee6b439cf47bb14d564db2e029cb28", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e5ba2799c8ee6b439cf47bb14d564db2e029cb28", "message": "Fix constr type-checking against readonly in union and add tests", "committedDate": "2020-06-28T10:49:55Z", "type": "commit"}, {"oid": "f34a4da4bdaf3e136c59e1936ba63f688862867c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f34a4da4bdaf3e136c59e1936ba63f688862867c", "message": "Add tests for union CET with readonly", "committedDate": "2020-06-28T12:02:16Z", "type": "commit"}, {"oid": "7f8304c89fa0cf39750fb00c14e763f8040e1d37", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7f8304c89fa0cf39750fb00c14e763f8040e1d37", "message": "Merge branch 'master' of https://github.com/ballerina-lang/ballerina into readonly-support", "committedDate": "2020-06-28T12:02:42Z", "type": "commit"}, {"oid": "b0624bb903dc06b54205c97b611c5463a97d0583", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b0624bb903dc06b54205c97b611c5463a97d0583", "message": "Use intersection effective type for type-checking", "committedDate": "2020-06-28T20:48:24Z", "type": "commit"}, {"oid": "98462d7940d5582d7606cf0984488e7df0950409", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/98462d7940d5582d7606cf0984488e7df0950409", "message": "Add tests for readonly with mapping constr with diff. field kinds", "committedDate": "2020-06-28T20:53:33Z", "type": "commit"}, {"oid": "562ef0f7e36ee2e9e06d45d8ac01f46331068dfd", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/562ef0f7e36ee2e9e06d45d8ac01f46331068dfd", "message": "Merge branch 'master' of https://github.com/ballerina-lang/ballerina into readonly-support", "committedDate": "2020-06-30T07:21:58Z", "type": "commit"}, {"oid": "6398a7b7a98df7144045aba0e528596680d8af9f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6398a7b7a98df7144045aba0e528596680d8af9f", "message": "Avoid rest field literal key check for gen.ed record types and narrow type for readonly fields", "committedDate": "2020-06-30T16:40:06Z", "type": "commit"}, {"oid": "7679816a9718b649c4a1f0e2a43f9d8abfc755af", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7679816a9718b649c4a1f0e2a43f9d8abfc755af", "message": "Refactor expected type setting logic for mapping-constructors", "committedDate": "2020-07-01T07:56:08Z", "type": "commit"}, {"oid": "b4da316a9935e882730f3910cd71d89089862c50", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b4da316a9935e882730f3910cd71d89089862c50", "message": "Construct values as read-only when used with a cast to readonly", "committedDate": "2020-07-03T11:01:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTczODk1NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#discussion_r449738954", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // A record type is inferred for a record literal even if the CET is a map, if the mapping\n          \n          \n            \n                    // constructor expression has `readonly` fields.\n          \n          \n            \n                    // A record type is inferred for a record literal even if the CET (contextually expected type) is a map, if \n          \n          \n            \n                    // the mapping constructor expression has `readonly` fields.", "author": "KRVPerera", "createdAt": "2020-07-04T04:46:44Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java", "diffHunk": "@@ -1998,7 +1998,14 @@ public void visit(BLangRecordLiteral recordLiteral) {\n \n         Set<Object> names = new HashSet<>();\n         BType type = recordLiteral.type;\n-        boolean isOpenRecord = type != null && type.tag == TypeTags.RECORD && !((BRecordType) type).sealed;\n+        boolean isRecord = type != null && type.tag == TypeTags.RECORD;\n+        boolean isOpenRecord = isRecord && !((BRecordType) type).sealed;\n+\n+        // A record type is inferred for a record literal even if the CET is a map, if the mapping\n+        // constructor expression has `readonly` fields.", "originalCommit": "b4da316a9935e882730f3910cd71d89089862c50", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0MTg4NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#discussion_r450141885", "bodyText": "Fixed in 290649c.", "author": "MaryamZi", "createdAt": "2020-07-06T10:53:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTczODk1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTczOTY5Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#discussion_r449739692", "bodyText": "origExpType type is not used.", "author": "KRVPerera", "createdAt": "2020-07-04T04:58:50Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -360,16 +348,35 @@ public BType checkExpr(BLangExpression expr, SymbolEnv env, BType expType, Diagn\n \n         expr.accept(this);\n \n-        expr.type = resultType.tag != TypeTags.INTERSECTION ? resultType :\n-                ((BIntersectionType) resultType).effectiveType;\n+        if (resultType.tag == TypeTags.INTERSECTION) {\n+            resultType = ((BIntersectionType) resultType).effectiveType;\n+        }\n+\n+        expr.type = resultType;\n         expr.typeChecked = isTypeChecked;\n         this.env = prevEnv;\n         this.expType = preExpType;\n         this.diagCode = preDiagCode;\n-        if (resultType.tag != TypeTags.SEMANTIC_ERROR) {\n+\n+        validateAndSetExprExpectedType(expr, expType);\n+\n+        return resultType;\n+    }\n+\n+    private void validateAndSetExprExpectedType(BLangExpression expr, BType origExpType) {", "originalCommit": "b4da316a9935e882730f3910cd71d89089862c50", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE0MTgzNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#discussion_r450141837", "bodyText": "Thanks, fixed in 290649c.", "author": "MaryamZi", "createdAt": "2020-07-06T10:53:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTczOTY5Mg=="}], "type": "inlineReview"}, {"oid": "db6dd878879ed81545688e40046afbd5d14b3af1", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/db6dd878879ed81545688e40046afbd5d14b3af1", "message": "Merge branch 'master' of https://github.com/ballerina-lang/ballerina into readonly-support", "committedDate": "2020-07-06T06:17:29Z", "type": "commit"}, {"oid": "290649cd679228bbe66d06897c69a3401caa8498", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/290649cd679228bbe66d06897c69a3401caa8498", "message": "Address review suggestions", "committedDate": "2020-07-06T07:16:37Z", "type": "commit"}, {"oid": "95533b19950d9d6557473bafa304a16a65ed2a02", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/95533b19950d9d6557473bafa304a16a65ed2a02", "message": "Merge branch 'master' of https://github.com/ballerina-lang/ballerina into readonly-support", "committedDate": "2020-07-06T12:24:31Z", "type": "commit"}, {"oid": "4f67df544ffe98957721d6037f08ec6faa125752", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4f67df544ffe98957721d6037f08ec6faa125752", "message": "Merge branch 'master' of https://github.com/ballerina-lang/ballerina into readonly-support", "committedDate": "2020-07-15T06:41:13Z", "type": "commit"}, {"oid": "ed729d2aa3f90d27522bb8d1f867a4ee61da6cd8", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ed729d2aa3f90d27522bb8d1f867a4ee61da6cd8", "message": "Fix tests", "committedDate": "2020-07-15T10:15:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI5Mzg4OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#discussion_r455293888", "bodyText": "Not related to this PR, but there shouldn't be a case where the type of a record literal is null in code analyzer right?", "author": "pubudu91", "createdAt": "2020-07-15T19:34:45Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java", "diffHunk": "@@ -2020,7 +2020,14 @@ public void visit(BLangRecordLiteral recordLiteral) {\n \n         Set<Object> names = new HashSet<>();\n         BType type = recordLiteral.type;\n-        boolean isOpenRecord = type != null && type.tag == TypeTags.RECORD && !((BRecordType) type).sealed;\n+        boolean isRecord = type != null && type.tag == TypeTags.RECORD;", "originalCommit": "ed729d2aa3f90d27522bb8d1f867a4ee61da6cd8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMwNTY5MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#discussion_r455305691", "bodyText": "Yeah, ideally should never be null.", "author": "MaryamZi", "createdAt": "2020-07-15T19:56:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI5Mzg4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMwMDA1Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#discussion_r455300057", "bodyText": "Why is the expected type changed here?", "author": "pubudu91", "createdAt": "2020-07-15T19:46:30Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java", "diffHunk": "@@ -2084,6 +2091,10 @@ public void visit(BLangRecordLiteral recordLiteral) {\n                 }\n             }\n         }\n+\n+        if (isInferredRecordForMapCET) {\n+            recordLiteral.expectedType = type;", "originalCommit": "ed729d2aa3f90d27522bb8d1f867a4ee61da6cd8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxMDQ4OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#discussion_r455310488", "bodyText": "We don't log the error at L2079 if a record type is inferred for a mapping constructor expression when the contextually expected type is a map type.\ne.g.,\nmap<int> m = {\n   readonly a: 1,\n   b: 2\n};\nHere the actual type of the constructed value is record {| readonly int a; int...; |}. Usually you'll have to use a literal key to provide for the rest field (b in the sample), but that is not required when a record type is inferred for a map ACET.\nTo do this, we need to know here what the original applicable expected type was.\nUsually, the expectedType field of an expression is overridden in checkExpr, but for this particular scenario we don't do it because we need to know the exact ACET - see \n  \n    \n      ballerina-lang/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java\n    \n    \n         Line 378\n      in\n      ed729d2\n    \n    \n    \n    \n\n        \n          \n           // If the expected type is a map, but a record type is inferred due to the presence of `readonly` fields in \n        \n    \n  \n\n\nI don't think this is required, but just for uniformity we set the expectedType as the normal path here.", "author": "MaryamZi", "createdAt": "2020-07-15T20:05:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMwMDA1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxMDMwMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#discussion_r455310303", "bodyText": "Shall we move this above line 371? When placed here, it looks like a dangling comment", "author": "pubudu91", "createdAt": "2020-07-15T20:05:37Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -360,16 +348,35 @@ public BType checkExpr(BLangExpression expr, SymbolEnv env, BType expType, Diagn\n \n         expr.accept(this);\n \n-        expr.type = resultType.tag != TypeTags.INTERSECTION ? resultType :\n-                ((BIntersectionType) resultType).effectiveType;\n+        if (resultType.tag == TypeTags.INTERSECTION) {\n+            resultType = ((BIntersectionType) resultType).effectiveType;\n+        }\n+\n+        expr.type = resultType;\n         expr.typeChecked = isTypeChecked;\n         this.env = prevEnv;\n         this.expType = preExpType;\n         this.diagCode = preDiagCode;\n-        if (resultType.tag != TypeTags.SEMANTIC_ERROR) {\n+\n+        validateAndSetExprExpectedType(expr);\n+\n+        return resultType;\n+    }\n+\n+    private void validateAndSetExprExpectedType(BLangExpression expr) {\n+        if (resultType.tag == TypeTags.SEMANTIC_ERROR) {\n+            return;\n+        }\n+\n+        if (expr.getKind() != NodeKind.RECORD_LITERAL_EXPR ||\n+                expr.expectedType == null ||\n+                expr.expectedType.tag != TypeTags.MAP ||\n+                expr.type.tag != TypeTags.RECORD) {\n             expr.expectedType = resultType;\n         }\n-        return resultType;\n+\n+        // If the expected type is a map, but a record type is inferred due to the presence of `readonly` fields in\n+        // the mapping constructor expression, we don't override the expected type.", "originalCommit": "ed729d2aa3f90d27522bb8d1f867a4ee61da6cd8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxMDY2Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#discussion_r455310667", "bodyText": "Wouldn't the inverse of this check read better?", "author": "pubudu91", "createdAt": "2020-07-15T20:06:20Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -360,16 +348,35 @@ public BType checkExpr(BLangExpression expr, SymbolEnv env, BType expType, Diagn\n \n         expr.accept(this);\n \n-        expr.type = resultType.tag != TypeTags.INTERSECTION ? resultType :\n-                ((BIntersectionType) resultType).effectiveType;\n+        if (resultType.tag == TypeTags.INTERSECTION) {\n+            resultType = ((BIntersectionType) resultType).effectiveType;\n+        }\n+\n+        expr.type = resultType;\n         expr.typeChecked = isTypeChecked;\n         this.env = prevEnv;\n         this.expType = preExpType;\n         this.diagCode = preDiagCode;\n-        if (resultType.tag != TypeTags.SEMANTIC_ERROR) {\n+\n+        validateAndSetExprExpectedType(expr);\n+\n+        return resultType;\n+    }\n+\n+    private void validateAndSetExprExpectedType(BLangExpression expr) {\n+        if (resultType.tag == TypeTags.SEMANTIC_ERROR) {\n+            return;\n+        }\n+\n+        if (expr.getKind() != NodeKind.RECORD_LITERAL_EXPR ||\n+                expr.expectedType == null ||\n+                expr.expectedType.tag != TypeTags.MAP ||\n+                expr.type.tag != TypeTags.RECORD) {", "originalCommit": "ed729d2aa3f90d27522bb8d1f867a4ee61da6cd8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTM0Njg0MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#discussion_r455346840", "bodyText": "I actually found this more readable \ud83d\ude03 But when swapping the comment, I changed it to return early if it matches the inverse, so it's kinda swapped now.", "author": "MaryamZi", "createdAt": "2020-07-15T21:08:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxMDY2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyNDk5MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#discussion_r455324990", "bodyText": "I think we should consider providing common info such as the name, type of a field through an API. Would simplify code like this. Again, I mean as a future improvement.", "author": "pubudu91", "createdAt": "2020-07-15T20:33:36Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -1481,51 +1497,193 @@ private boolean exprIncompatible(BType eType, BLangExpression expr) {\n         return checkExpr(exprToCheck, this.env, eType) == symTable.semanticError;\n     }\n \n-    private BType[] getExprListUniqueTypes(List<BLangExpression> exprs, SymbolEnv env) {\n-        LinkedHashSet<BType> typesSet = new LinkedHashSet<>(checkExprList(exprs, env));\n-        return typesSet.toArray(new BType[0]);\n+    private List<BType> checkExprList(List<BLangExpression> exprs, SymbolEnv env) {\n+        return checkExprList(exprs, env, symTable.noType);\n     }\n \n-    private List<BType> checkExprList(List<BLangExpression> exprs, SymbolEnv env) {\n+    private List<BType> checkExprList(List<BLangExpression> exprs, SymbolEnv env, BType expType) {\n         List<BType> types = new ArrayList<>();\n         SymbolEnv prevEnv = this.env;\n         BType preExpType = this.expType;\n         this.env = env;\n-        this.expType = symTable.noType;\n+        this.expType = expType;\n         for (BLangExpression e : exprs) {\n-            checkExpr(e, this.env);\n+            checkExpr(e, this.env, expType);\n             types.add(resultType);\n         }\n         this.env = prevEnv;\n         this.expType = preExpType;\n         return types;\n     }\n \n-    private BType getInferredTupleType(BLangListConstructorExpr listConstructor) {\n-        List<BType> memTypes = checkExprList(listConstructor.exprs, env);\n+    private BType getInferredTupleType(BLangListConstructorExpr listConstructor, BType expType) {\n+        List<BType> memTypes = checkExprList(listConstructor.exprs, env, expType);\n \n         for (BType memType : memTypes) {\n             if (memType == symTable.semanticError) {\n                 return symTable.semanticError;\n             }\n         }\n \n-        return new BTupleType(memTypes);\n+        BTupleType tupleType = new BTupleType(memTypes);\n+\n+        if (expType.tag != TypeTags.READONLY) {\n+            return tupleType;\n+        }\n+\n+        tupleType.flags |= Flags.READONLY;\n+        return tupleType;\n     }\n \n     public void visit(BLangRecordLiteral recordLiteral) {\n         int expTypeTag = expType.tag;\n \n-        if (expTypeTag == TypeTags.NONE) {\n-            expType = defineInferredRecordType(recordLiteral);\n+        if (expTypeTag == TypeTags.NONE || expTypeTag == TypeTags.READONLY) {\n+            expType = defineInferredRecordType(recordLiteral, expType);\n         } else if (expTypeTag == TypeTags.OBJECT) {\n-            dlog.error(recordLiteral.pos,\n-                       DiagnosticCode.INVALID_RECORD_LITERAL, expType);\n+            dlog.error(recordLiteral.pos, DiagnosticCode.INVALID_RECORD_LITERAL, expType);\n             resultType = symTable.semanticError;\n             return;\n         }\n \n-        resultType = checkMappingConstructorCompatibility(expType, recordLiteral);\n+        resultType = getEffectiveMappingType(recordLiteral,\n+                                             checkMappingConstructorCompatibility(expType, recordLiteral));\n+    }\n+\n+    private BType getEffectiveMappingType(BLangRecordLiteral recordLiteral, BType applicableMappingType) {\n+        if (applicableMappingType == symTable.semanticError ||\n+                (applicableMappingType.tag == TypeTags.RECORD && Symbols.isFlagOn(applicableMappingType.flags,\n+                                                                                  Flags.READONLY))) {\n+            return applicableMappingType;\n+        }\n+\n+        Map<String, RecordLiteralNode.RecordField> readOnlyFields = new LinkedHashMap<>();\n+        LinkedHashMap<String, BField> applicableTypeFields =\n+                applicableMappingType.tag == TypeTags.RECORD ? ((BRecordType) applicableMappingType).fields :\n+                        new LinkedHashMap<>();\n+\n+        for (RecordLiteralNode.RecordField field : recordLiteral.fields) {\n+            if (field.getKind() == NodeKind.RECORD_LITERAL_SPREAD_OP) {\n+                continue;\n+            }\n+\n+            String name;\n+            if (field.isKeyValueField()) {\n+                BLangRecordKeyValueField keyValueField = (BLangRecordKeyValueField) field;\n+\n+                if (!keyValueField.readonly) {\n+                    continue;\n+                }\n+\n+                BLangExpression keyExpr = keyValueField.key.expr;\n+                if (keyExpr.getKind() == NodeKind.SIMPLE_VARIABLE_REF) {\n+                    name = ((BLangSimpleVarRef) keyExpr).variableName.value;\n+                } else {\n+                    name = (String) ((BLangLiteral) keyExpr).value;\n+                }\n+            } else {\n+                BLangRecordVarNameField varNameField = (BLangRecordVarNameField) field;\n+\n+                if (!varNameField.readonly) {\n+                    continue;\n+                }\n+                name = varNameField.variableName.value;\n+            }", "originalCommit": "ed729d2aa3f90d27522bb8d1f867a4ee61da6cd8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTM0NzM0NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#discussion_r455347344", "bodyText": "Yeah, +1.", "author": "MaryamZi", "createdAt": "2020-07-15T21:08:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyNDk5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyNTM5OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24484#discussion_r455325398", "bodyText": "Another example of what I mentioned above.", "author": "pubudu91", "createdAt": "2020-07-15T20:34:24Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -1481,51 +1497,193 @@ private boolean exprIncompatible(BType eType, BLangExpression expr) {\n         return checkExpr(exprToCheck, this.env, eType) == symTable.semanticError;\n     }\n \n-    private BType[] getExprListUniqueTypes(List<BLangExpression> exprs, SymbolEnv env) {\n-        LinkedHashSet<BType> typesSet = new LinkedHashSet<>(checkExprList(exprs, env));\n-        return typesSet.toArray(new BType[0]);\n+    private List<BType> checkExprList(List<BLangExpression> exprs, SymbolEnv env) {\n+        return checkExprList(exprs, env, symTable.noType);\n     }\n \n-    private List<BType> checkExprList(List<BLangExpression> exprs, SymbolEnv env) {\n+    private List<BType> checkExprList(List<BLangExpression> exprs, SymbolEnv env, BType expType) {\n         List<BType> types = new ArrayList<>();\n         SymbolEnv prevEnv = this.env;\n         BType preExpType = this.expType;\n         this.env = env;\n-        this.expType = symTable.noType;\n+        this.expType = expType;\n         for (BLangExpression e : exprs) {\n-            checkExpr(e, this.env);\n+            checkExpr(e, this.env, expType);\n             types.add(resultType);\n         }\n         this.env = prevEnv;\n         this.expType = preExpType;\n         return types;\n     }\n \n-    private BType getInferredTupleType(BLangListConstructorExpr listConstructor) {\n-        List<BType> memTypes = checkExprList(listConstructor.exprs, env);\n+    private BType getInferredTupleType(BLangListConstructorExpr listConstructor, BType expType) {\n+        List<BType> memTypes = checkExprList(listConstructor.exprs, env, expType);\n \n         for (BType memType : memTypes) {\n             if (memType == symTable.semanticError) {\n                 return symTable.semanticError;\n             }\n         }\n \n-        return new BTupleType(memTypes);\n+        BTupleType tupleType = new BTupleType(memTypes);\n+\n+        if (expType.tag != TypeTags.READONLY) {\n+            return tupleType;\n+        }\n+\n+        tupleType.flags |= Flags.READONLY;\n+        return tupleType;\n     }\n \n     public void visit(BLangRecordLiteral recordLiteral) {\n         int expTypeTag = expType.tag;\n \n-        if (expTypeTag == TypeTags.NONE) {\n-            expType = defineInferredRecordType(recordLiteral);\n+        if (expTypeTag == TypeTags.NONE || expTypeTag == TypeTags.READONLY) {\n+            expType = defineInferredRecordType(recordLiteral, expType);\n         } else if (expTypeTag == TypeTags.OBJECT) {\n-            dlog.error(recordLiteral.pos,\n-                       DiagnosticCode.INVALID_RECORD_LITERAL, expType);\n+            dlog.error(recordLiteral.pos, DiagnosticCode.INVALID_RECORD_LITERAL, expType);\n             resultType = symTable.semanticError;\n             return;\n         }\n \n-        resultType = checkMappingConstructorCompatibility(expType, recordLiteral);\n+        resultType = getEffectiveMappingType(recordLiteral,\n+                                             checkMappingConstructorCompatibility(expType, recordLiteral));\n+    }\n+\n+    private BType getEffectiveMappingType(BLangRecordLiteral recordLiteral, BType applicableMappingType) {\n+        if (applicableMappingType == symTable.semanticError ||\n+                (applicableMappingType.tag == TypeTags.RECORD && Symbols.isFlagOn(applicableMappingType.flags,\n+                                                                                  Flags.READONLY))) {\n+            return applicableMappingType;\n+        }\n+\n+        Map<String, RecordLiteralNode.RecordField> readOnlyFields = new LinkedHashMap<>();\n+        LinkedHashMap<String, BField> applicableTypeFields =\n+                applicableMappingType.tag == TypeTags.RECORD ? ((BRecordType) applicableMappingType).fields :\n+                        new LinkedHashMap<>();\n+\n+        for (RecordLiteralNode.RecordField field : recordLiteral.fields) {\n+            if (field.getKind() == NodeKind.RECORD_LITERAL_SPREAD_OP) {\n+                continue;\n+            }\n+\n+            String name;\n+            if (field.isKeyValueField()) {\n+                BLangRecordKeyValueField keyValueField = (BLangRecordKeyValueField) field;\n+\n+                if (!keyValueField.readonly) {\n+                    continue;\n+                }\n+\n+                BLangExpression keyExpr = keyValueField.key.expr;\n+                if (keyExpr.getKind() == NodeKind.SIMPLE_VARIABLE_REF) {\n+                    name = ((BLangSimpleVarRef) keyExpr).variableName.value;\n+                } else {\n+                    name = (String) ((BLangLiteral) keyExpr).value;\n+                }\n+            } else {\n+                BLangRecordVarNameField varNameField = (BLangRecordVarNameField) field;\n+\n+                if (!varNameField.readonly) {\n+                    continue;\n+                }\n+                name = varNameField.variableName.value;\n+            }\n+\n+            if (applicableTypeFields.containsKey(name) &&\n+                    Symbols.isFlagOn(applicableTypeFields.get(name).symbol.flags, Flags.READONLY)) {\n+                continue;\n+            }\n+\n+            readOnlyFields.put(name, field);\n+        }\n+\n+        if (readOnlyFields.isEmpty()) {\n+            return applicableMappingType;\n+        }\n+\n+        PackageID pkgID = env.enclPkg.symbol.pkgID;\n+        BRecordTypeSymbol recordSymbol = createRecordTypeSymbol(pkgID);\n+\n+        LinkedHashMap<String, BField> newFields = new LinkedHashMap<>();\n+\n+        for (Map.Entry<String, RecordLiteralNode.RecordField> readOnlyEntry : readOnlyFields.entrySet()) {\n+            RecordLiteralNode.RecordField field = readOnlyEntry.getValue();\n+\n+            String key = readOnlyEntry.getKey();\n+            Name fieldName = names.fromString(key);\n+\n+            BType readOnlyFieldType;\n+            if (field.isKeyValueField()) {\n+                readOnlyFieldType = ((BLangRecordKeyValueField) field).valueExpr.type;\n+            } else {\n+                // Has to be a varname field.\n+                readOnlyFieldType = ((BLangRecordVarNameField) field).type;\n+            }", "originalCommit": "ed729d2aa3f90d27522bb8d1f867a4ee61da6cd8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8f1e3d6896a9d118ea91c15175257d0bac1daa46", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8f1e3d6896a9d118ea91c15175257d0bac1daa46", "message": "Address review suggestions", "committedDate": "2020-07-15T21:11:23Z", "type": "commit"}, {"oid": "2cf9cdf5e3924c0e4728eb04f505eea61e75350f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2cf9cdf5e3924c0e4728eb04f505eea61e75350f", "message": "Merge branch 'master' of https://github.com/ballerina-lang/ballerina into readonly-support", "committedDate": "2020-07-15T21:49:00Z", "type": "commit"}, {"oid": "ac3b92785bf915d106596a351d375766bbfbb304", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ac3b92785bf915d106596a351d375766bbfbb304", "message": "Fix RawTemplateLiteralTest", "committedDate": "2020-07-15T22:02:36Z", "type": "commit"}]}