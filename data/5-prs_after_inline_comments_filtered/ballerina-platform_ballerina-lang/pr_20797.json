{"pr_number": 20797, "pr_title": "Improve final executable jar creation task", "pr_createdAt": "2020-01-30T05:16:16Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/20797", "timeline": [{"oid": "363ab4909b69d564f638a883266abaec080a4012", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/363ab4909b69d564f638a883266abaec080a4012", "message": "improve final executable jar creation task", "committedDate": "2020-01-30T05:13:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc3ODU3Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20797#discussion_r372778573", "bodyText": "shall we wrap this with a BufferedInputStream as well?", "author": "SupunS", "createdAt": "2020-01-30T06:33:02Z", "path": "cli/ballerina-packerina/src/main/java/org/ballerinalang/packerina/task/CreateExecutableTask.java", "diffHunk": "@@ -111,77 +90,88 @@ public void execute(BuildContext buildContext) {\n         }\n     }\n \n-    private void assembleExecutable(Path jarFromCachePath, HashSet<Path> dependencySet, ZipOutputStream outStream) {\n+    private void assembleExecutable(Path jarFromCachePath, HashSet<Path> dependencySet,\n+                                    ZipArchiveOutputStream outStream) {\n         try {\n-            HashSet<String> entries = (HashSet<String>) namesField.get(outStream);\n-            HashMap<String, StringBuilder> services = new HashMap<>();\n-            copyJarToJar(outStream, jarFromCachePath.toString(), entries, services);\n+            // Used to prevent adding duplicated entries during the final jar creation.\n+            HashSet<String> entries = new HashSet<>();\n+            // Used to process SPI related metadata entries separately. The reason is unlike the other entry types,\n+            // service loader related information should be merged together in the final executable jar creation.\n+            HashMap<String, StringBuilder> serviceEntries = new HashMap<>();\n+            // Copy executable thin jar and the dependency jars.\n+            // Executable is created at given location.\n+            // If no entry point is found, we do nothing.\n+            copyJarToJar(outStream, jarFromCachePath.toString(), entries, serviceEntries);\n             for (Path path : dependencySet) {\n-                copyJarToJar(outStream, path.toString(), entries, services);\n+                copyJarToJar(outStream, path.toString(), entries, serviceEntries);\n             }\n-            // Copy merged spi services\n-            for (Map.Entry<String, StringBuilder> entry : services.entrySet()) {\n+            // Copy merged spi services.\n+            for (Map.Entry<String, StringBuilder> entry : serviceEntries.entrySet()) {\n                 String s = entry.getKey();\n                 StringBuilder service = entry.getValue();\n-                ZipEntry e = new ZipEntry(s);\n-                outStream.putNextEntry(e);\n+                JarArchiveEntry e = new JarArchiveEntry(s);\n+                outStream.putArchiveEntry(e);\n                 outStream.write(service.toString().getBytes(StandardCharsets.UTF_8));\n-                outStream.closeEntry();\n+                outStream.closeArchiveEntry();\n             }\n-            // Copy dependency jar\n-            // Copy dependency libraries\n-            // Executable is created at give location.\n-            // If no entry point is found we do nothing.\n-        } catch (IOException | NullPointerException | IllegalAccessException e) {\n+        } catch (IOException | NullPointerException e) {\n             throw createLauncherException(\"unable to create the executable: \" + e.getMessage());\n         }\n     }\n \n     /**\n-     * Copy jar file to executable fat jar.\n+     * Copies a given jar file into the executable fat jar.\n      *\n-     * @param outStream     Executable jar out stream\n-     * @param sourceJarFile Source file\n-     * @param entries       Entries set wiil be used ignore duplicate files\n+     * @param outStream     Output stream of the final uber jar.\n+     * @param sourceJarFile Path of the source jar file.\n+     * @param entries       Entries set will be used to ignore duplicate files.\n      * @param services      Services will be used to temporary hold merged spi files.\n-     * @throws IOException If file copy failed ioexception will be thrown\n+     * @throws IOException If jar file copying is failed.\n      */\n-    private void copyJarToJar(ZipOutputStream outStream, String sourceJarFile, HashSet<String> entries,\n+    private void copyJarToJar(ZipArchiveOutputStream outStream, String sourceJarFile, HashSet<String> entries,\n                               HashMap<String, StringBuilder> services) throws IOException {\n \n-        byte[] buffer = new byte[1024];\n-        int len;\n-        try (ZipInputStream inStream = new ZipInputStream(new FileInputStream(sourceJarFile))) {\n-            for (ZipEntry e; (e = inStream.getNextEntry()) != null; ) {\n-                String entryName = e.getName();\n-                // Skip already copied files or excluded extensions.\n-                if (e.isDirectory() || entries.contains(entryName) ||\n-                        excludeExtensions.contains(entryName.substring(entryName.lastIndexOf(\".\") + 1))) {\n-                    continue;\n-                }\n-                // SPIs will be merged first and then put into jar separately.\n+        ZipFile zipFile = new ZipFile(sourceJarFile);\n+        ZipArchiveEntryPredicate predicate = entry -> {\n+            try {\n+                String entryName = entry.getName();\n                 if (entryName.startsWith(\"META-INF/services\")) {\n                     StringBuilder s = services.get(entryName);\n                     if (s == null) {\n                         s = new StringBuilder();\n                         services.put(entryName, s);\n                     }\n                     char c = '\\n';\n+                    InputStream inStream = zipFile.getInputStream(entry);", "originalCommit": "363ab4909b69d564f638a883266abaec080a4012", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc4MzMxNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20797#discussion_r372783315", "bodyText": "@SupunS I have already tried wrapping input streams with the buffered ones, but couldn't had any noticeable gain. The reason might be we have to access input streams only for very few entries (only for the entries under META-INF/services). Anyway let have this included. :)", "author": "NipunaRanasinghe", "createdAt": "2020-01-30T06:53:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc3ODU3Mw=="}], "type": "inlineReview"}, {"oid": "a04f172e6edd0a247c5e97f2164cd969b3c084bb", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a04f172e6edd0a247c5e97f2164cd969b3c084bb", "message": "Add buffered input stream", "committedDate": "2020-01-30T08:48:39Z", "type": "commit"}, {"oid": "a04f172e6edd0a247c5e97f2164cd969b3c084bb", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a04f172e6edd0a247c5e97f2164cd969b3c084bb", "message": "Add buffered input stream", "committedDate": "2020-01-30T08:48:39Z", "type": "forcePushed"}]}