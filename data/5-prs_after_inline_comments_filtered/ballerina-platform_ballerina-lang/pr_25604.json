{"pr_number": 25604, "pr_title": "Add `array:sort` function", "pr_createdAt": "2020-09-03T17:29:08Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604", "timeline": [{"oid": "959536a0ef44d7500a4279197726c97acecfe3bf", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/959536a0ef44d7500a4279197726c97acecfe3bf", "message": "Add support for revamped array:sort function", "committedDate": "2020-09-03T11:29:31Z", "type": "commit"}, {"oid": "a26ce67f53ca20c2eba82a88eb6ed33e98b310c2", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a26ce67f53ca20c2eba82a88eb6ed33e98b310c2", "message": "Add tests for array:sort function", "committedDate": "2020-09-03T11:30:01Z", "type": "commit"}, {"oid": "1c5c87f602f18158ed30461d92032de5758a2d0b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1c5c87f602f18158ed30461d92032de5758a2d0b", "message": "Refactor code", "committedDate": "2020-09-03T17:15:42Z", "type": "commit"}, {"oid": "3684528fc6b404386962b35984c02b97d29938f7", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3684528fc6b404386962b35984c02b97d29938f7", "message": "Add more tests for array:sort", "committedDate": "2020-09-03T17:16:18Z", "type": "commit"}, {"oid": "f6242477c6a3f424e14896da82d393f2393efb0d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f6242477c6a3f424e14896da82d393f2393efb0d", "message": "Remove unnecessary newlines", "committedDate": "2020-09-03T17:28:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwMDUyMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r483200521", "bodyText": "No need to special case the array right? Can use the same switch case to do this.", "author": "pubudu91", "createdAt": "2020-09-03T19:16:08Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -3474,6 +3474,15 @@ public BType resolveExprType(BType type) {\n      * @return boolean whether the type is basic type or not.\n      */\n     public boolean isBasicType(BType type) {\n+        if (type.tag == TypeTags.ARRAY) {\n+            BType arrType = ((BArrayType) type).eType;\n+            return checkBasicType(arrType);\n+        } else {\n+            return checkBasicType(type);", "originalCommit": "f6242477c6a3f424e14896da82d393f2393efb0d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwMjM3Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r483202373", "bodyText": "Also, what's the exact purpose of this method? The name of the method conveys a completely different meaning from its implementation. e.g., this seems to consider union types with () as basic. But in the spec, unions aren't considered as a basic type.\nEven without the union, this seems to be considering an arbitrary set of types from the basic types.", "author": "pubudu91", "createdAt": "2020-09-03T19:20:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwMDUyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM3NTY0Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r483375643", "bodyText": "Will look into it and do the necessary changes", "author": "lasinicl", "createdAt": "2020-09-04T04:15:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwMDUyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM5NTc3Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r483395773", "bodyText": "This also seems to miss the int and string subtypes. I also think isBasicType (I think isSimpleBasicType is more accurate here) should just check for the simple basic types in line with the spec, and we can maybe introduce a separate method that handles arrays and unions, eventually calling isBasicType.", "author": "MaryamZi", "createdAt": "2020-09-04T05:31:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwMDUyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwNTg3Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r483205877", "bodyText": "Ideally, there shouldn't be any need to hard code the type checking for this. Why do we need to do this?", "author": "pubudu91", "createdAt": "2020-09-03T19:27:17Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -5390,6 +5395,28 @@ private BType checkInvocationArgs(BLangInvocation iExpr, List<BType> paramTypes,\n         }\n     }\n \n+    private void checkArrayLibSortFuncArgs(BLangInvocation iExpr) {\n+        if (iExpr.argExprs.size() <= 2) {\n+            if (!types.isBasicType(iExpr.expr.type)) {\n+                dlog.error(iExpr.expr.pos, DiagnosticCode.INVALID_SORT_ARRAY_MEMBER_TYPE, iExpr.expr.type);\n+            }\n+        } else if (iExpr.argExprs.size() == 3) {\n+            if (iExpr.argExprs.get(2).type != null) {\n+                if (iExpr.argExprs.get(2).type.tag == TypeTags.SEMANTIC_ERROR) {\n+                    return;\n+                } else if (iExpr.argExprs.get(2).type.tag == TypeTags.NIL && !types.isBasicType(iExpr.expr.type)) {\n+                    dlog.error(iExpr.expr.pos, DiagnosticCode.INVALID_SORT_ARRAY_MEMBER_TYPE, iExpr.expr.type);\n+                }\n+            } else {\n+                BLangLambdaFunction func = (BLangLambdaFunction) iExpr.argExprs.get(2);\n+                BType returnType = func.function.type.getReturnType();\n+                if (!types.isBasicType(returnType)) {\n+                    dlog.error(iExpr.expr.pos, DiagnosticCode.INVALID_SORT_FUNC_RETURN_TYPE, returnType);\n+                }\n+            }\n+        }\n+    }", "originalCommit": "f6242477c6a3f424e14896da82d393f2393efb0d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM2ODE0OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r483368149", "bodyText": "In the spec issue, James has mentioned that\n\"The compiler needs to check a few things that cannot be expressed in the signature:\n\n\nif a key function is specified as an argument, then its return value must be an ordered type\n\n\nif there is no key function, then the member type of the array must be ordered type\"\n\n\nballerina-platform/ballerina-spec#572 (comment)", "author": "lasinicl", "createdAt": "2020-09-04T03:44:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwNTg3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM4OTc5NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r483389794", "bodyText": "Since function doesn't change for a single invocation, wouldn't it be better to do\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (int i = 0; i < arr.size(); i++) {\n          \n          \n            \n                        if (function != null) {\n          \n          \n            \n                            Object x = function.call(new Object[]{strand, arr.get(i), true});\n          \n          \n            \n                            sortArr[i][0] = x;\n          \n          \n            \n                        } else {\n          \n          \n            \n                            sortArr[i][0] = arr.get(i);\n          \n          \n            \n                        }\n          \n          \n            \n                        sortArr[i][1] = arr.get(i);\n          \n          \n            \n                    }\n          \n          \n            \n                    if (function != null) {\n          \n          \n            \n                        for (int i = 0; i < arr.size(); i++) {\n          \n          \n            \n                            sortArr[i][0] = function.call(new Object[]{strand, arr.get(i), true});\n          \n          \n            \n                            sortArr[i][1] = arr.get(i);\n          \n          \n            \n                        }\n          \n          \n            \n                    } else {\n          \n          \n            \n                        for (int i = 0; i < arr.size(); i++) {\n          \n          \n            \n                            sortArr[i][0] = sortArr[i][1] = arr.get(i);\n          \n          \n            \n                        }\n          \n          \n            \n                    }", "author": "MaryamZi", "createdAt": "2020-09-04T05:10:02Z", "path": "langlib/lang.array/src/main/java/org/ballerinalang/langlib/array/Sort.java", "diffHunk": "@@ -18,73 +18,185 @@\n \n package org.ballerinalang.langlib.array;\n \n+import org.ballerinalang.jvm.BallerinaErrors;\n import org.ballerinalang.jvm.scheduling.Strand;\n import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BFunctionType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BUnionType;\n+import org.ballerinalang.jvm.types.TypeTags;\n import org.ballerinalang.jvm.values.ArrayValue;\n-import org.ballerinalang.jvm.values.ArrayValueImpl;\n import org.ballerinalang.jvm.values.FPValue;\n import org.ballerinalang.model.types.TypeKind;\n import org.ballerinalang.natives.annotations.Argument;\n import org.ballerinalang.natives.annotations.BallerinaFunction;\n import org.ballerinalang.natives.annotations.ReturnType;\n \n+import java.math.BigDecimal;\n+import java.util.Optional;\n+\n import static org.ballerinalang.jvm.values.utils.ArrayUtils.checkIsArrayOnlyOperation;\n import static org.ballerinalang.util.BLangCompilerConstants.ARRAY_VERSION;\n \n /**\n- * Native implementation of lang.array:sort((any|error)[], function).\n+ * Native implementation of lang.array:sort((any|error)[], direction, function).\n  *\n  * @since 1.0\n  */\n @BallerinaFunction(\n         orgName = \"ballerina\", packageName = \"lang.array\", version = ARRAY_VERSION, functionName = \"sort\",\n-        args = {@Argument(name = \"arr\", type = TypeKind.ARRAY), @Argument(name = \"func\", type = TypeKind.FUNCTION)},\n+        args = {@Argument(name = \"arr\", type = TypeKind.ARRAY), @Argument(name = \"direction\", type = TypeKind.OBJECT),\n+                @Argument(name = \"func\", type = TypeKind.OBJECT)},\n         returnType = {@ReturnType(type = TypeKind.ARRAY)},\n         isPublic = true\n )\n public class Sort {\n \n-    public static ArrayValue sort(Strand strand, ArrayValue arr, FPValue<Object, Long> func) {\n+    public static ArrayValue sort(Strand strand, ArrayValue arr, Object direction, Object func) {\n         checkIsArrayOnlyOperation(arr.getType(), \"sort()\");\n-        ArrayValue aux = new ArrayValueImpl((BArrayType) arr.getType());\n-        mergesort(arr, aux, 0, arr.size() - 1, strand, func);\n+        FPValue<Object, Object> function = (FPValue<Object, Object>) func;\n+        BType elemType = ((BArrayType) arr.getType()).getElementType();\n+        boolean isAscending = true;\n+        if (direction.toString().equals(\"descending\")) {\n+            isAscending = false;\n+        }\n+\n+        Object[][] sortArr = new Object[arr.size()][2];\n+        Object[][] sortArrClone = new Object[arr.size()][2];\n+        for (int i = 0; i < arr.size(); i++) {\n+            if (function != null) {\n+                Object x = function.call(new Object[]{strand, arr.get(i), true});\n+                sortArr[i][0] = x;\n+            } else {\n+                sortArr[i][0] = arr.get(i);\n+            }\n+            sortArr[i][1] = arr.get(i);\n+        }", "originalCommit": "f6242477c6a3f424e14896da82d393f2393efb0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM4OTkzMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r483389930", "bodyText": "If go with the suggestion to swap the null check above, we can move this there too.", "author": "MaryamZi", "createdAt": "2020-09-04T05:10:32Z", "path": "langlib/lang.array/src/main/java/org/ballerinalang/langlib/array/Sort.java", "diffHunk": "@@ -18,73 +18,185 @@\n \n package org.ballerinalang.langlib.array;\n \n+import org.ballerinalang.jvm.BallerinaErrors;\n import org.ballerinalang.jvm.scheduling.Strand;\n import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BFunctionType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BUnionType;\n+import org.ballerinalang.jvm.types.TypeTags;\n import org.ballerinalang.jvm.values.ArrayValue;\n-import org.ballerinalang.jvm.values.ArrayValueImpl;\n import org.ballerinalang.jvm.values.FPValue;\n import org.ballerinalang.model.types.TypeKind;\n import org.ballerinalang.natives.annotations.Argument;\n import org.ballerinalang.natives.annotations.BallerinaFunction;\n import org.ballerinalang.natives.annotations.ReturnType;\n \n+import java.math.BigDecimal;\n+import java.util.Optional;\n+\n import static org.ballerinalang.jvm.values.utils.ArrayUtils.checkIsArrayOnlyOperation;\n import static org.ballerinalang.util.BLangCompilerConstants.ARRAY_VERSION;\n \n /**\n- * Native implementation of lang.array:sort((any|error)[], function).\n+ * Native implementation of lang.array:sort((any|error)[], direction, function).\n  *\n  * @since 1.0\n  */\n @BallerinaFunction(\n         orgName = \"ballerina\", packageName = \"lang.array\", version = ARRAY_VERSION, functionName = \"sort\",\n-        args = {@Argument(name = \"arr\", type = TypeKind.ARRAY), @Argument(name = \"func\", type = TypeKind.FUNCTION)},\n+        args = {@Argument(name = \"arr\", type = TypeKind.ARRAY), @Argument(name = \"direction\", type = TypeKind.OBJECT),\n+                @Argument(name = \"func\", type = TypeKind.OBJECT)},\n         returnType = {@ReturnType(type = TypeKind.ARRAY)},\n         isPublic = true\n )\n public class Sort {\n \n-    public static ArrayValue sort(Strand strand, ArrayValue arr, FPValue<Object, Long> func) {\n+    public static ArrayValue sort(Strand strand, ArrayValue arr, Object direction, Object func) {\n         checkIsArrayOnlyOperation(arr.getType(), \"sort()\");\n-        ArrayValue aux = new ArrayValueImpl((BArrayType) arr.getType());\n-        mergesort(arr, aux, 0, arr.size() - 1, strand, func);\n+        FPValue<Object, Object> function = (FPValue<Object, Object>) func;\n+        BType elemType = ((BArrayType) arr.getType()).getElementType();\n+        boolean isAscending = true;\n+        if (direction.toString().equals(\"descending\")) {\n+            isAscending = false;\n+        }\n+\n+        Object[][] sortArr = new Object[arr.size()][2];\n+        Object[][] sortArrClone = new Object[arr.size()][2];\n+        for (int i = 0; i < arr.size(); i++) {\n+            if (function != null) {\n+                Object x = function.call(new Object[]{strand, arr.get(i), true});\n+                sortArr[i][0] = x;\n+            } else {\n+                sortArr[i][0] = arr.get(i);\n+            }\n+            sortArr[i][1] = arr.get(i);\n+        }\n+\n+        if (function != null) {\n+            elemType = ((BFunctionType) function.getType()).retType;", "originalCommit": "f6242477c6a3f424e14896da82d393f2393efb0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM5MTY5OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r483391698", "bodyText": "We avoid using streams due to perf impact.", "author": "MaryamZi", "createdAt": "2020-09-04T05:16:44Z", "path": "langlib/lang.array/src/main/java/org/ballerinalang/langlib/array/Sort.java", "diffHunk": "@@ -18,73 +18,185 @@\n \n package org.ballerinalang.langlib.array;\n \n+import org.ballerinalang.jvm.BallerinaErrors;\n import org.ballerinalang.jvm.scheduling.Strand;\n import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BFunctionType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BUnionType;\n+import org.ballerinalang.jvm.types.TypeTags;\n import org.ballerinalang.jvm.values.ArrayValue;\n-import org.ballerinalang.jvm.values.ArrayValueImpl;\n import org.ballerinalang.jvm.values.FPValue;\n import org.ballerinalang.model.types.TypeKind;\n import org.ballerinalang.natives.annotations.Argument;\n import org.ballerinalang.natives.annotations.BallerinaFunction;\n import org.ballerinalang.natives.annotations.ReturnType;\n \n+import java.math.BigDecimal;\n+import java.util.Optional;\n+\n import static org.ballerinalang.jvm.values.utils.ArrayUtils.checkIsArrayOnlyOperation;\n import static org.ballerinalang.util.BLangCompilerConstants.ARRAY_VERSION;\n \n /**\n- * Native implementation of lang.array:sort((any|error)[], function).\n+ * Native implementation of lang.array:sort((any|error)[], direction, function).\n  *\n  * @since 1.0\n  */\n @BallerinaFunction(\n         orgName = \"ballerina\", packageName = \"lang.array\", version = ARRAY_VERSION, functionName = \"sort\",\n-        args = {@Argument(name = \"arr\", type = TypeKind.ARRAY), @Argument(name = \"func\", type = TypeKind.FUNCTION)},\n+        args = {@Argument(name = \"arr\", type = TypeKind.ARRAY), @Argument(name = \"direction\", type = TypeKind.OBJECT),\n+                @Argument(name = \"func\", type = TypeKind.OBJECT)},\n         returnType = {@ReturnType(type = TypeKind.ARRAY)},\n         isPublic = true\n )\n public class Sort {\n \n-    public static ArrayValue sort(Strand strand, ArrayValue arr, FPValue<Object, Long> func) {\n+    public static ArrayValue sort(Strand strand, ArrayValue arr, Object direction, Object func) {\n         checkIsArrayOnlyOperation(arr.getType(), \"sort()\");\n-        ArrayValue aux = new ArrayValueImpl((BArrayType) arr.getType());\n-        mergesort(arr, aux, 0, arr.size() - 1, strand, func);\n+        FPValue<Object, Object> function = (FPValue<Object, Object>) func;\n+        BType elemType = ((BArrayType) arr.getType()).getElementType();\n+        boolean isAscending = true;\n+        if (direction.toString().equals(\"descending\")) {\n+            isAscending = false;\n+        }\n+\n+        Object[][] sortArr = new Object[arr.size()][2];\n+        Object[][] sortArrClone = new Object[arr.size()][2];\n+        for (int i = 0; i < arr.size(); i++) {\n+            if (function != null) {\n+                Object x = function.call(new Object[]{strand, arr.get(i), true});\n+                sortArr[i][0] = x;\n+            } else {\n+                sortArr[i][0] = arr.get(i);\n+            }\n+            sortArr[i][1] = arr.get(i);\n+        }\n+\n+        if (function != null) {\n+            elemType = ((BFunctionType) function.getType()).retType;\n+        }\n+        if (elemType.getTag() == TypeTags.UNION_TAG) {\n+            elemType = getType(elemType);\n+        }\n+        if (elemType.getTag() == TypeTags.ARRAY_TAG) {\n+            BType type = ((BArrayType) elemType).getElementType();\n+            if (type.getTag() == TypeTags.UNION_TAG) {\n+                elemType = getType(type);\n+            }\n+        }\n+\n+        mergesort(sortArr, sortArrClone, 0, sortArr.length - 1, isAscending, elemType);\n+\n+        for (int k = 0; k < sortArr.length; k++) {\n+            arr.add(k, sortArr[k][1]);\n+        }\n+\n         return arr;\n     }\n \n-    // Adapted from https://algs4.cs.princeton.edu/22mergesort/Merge.java.html\n-    private static void mergesort(ArrayValue input, ArrayValue aux, int lo, int hi, Strand strand,\n-                                  FPValue<Object, Long> comparator) {\n+    private static BType getType(BType type) {\n+        Optional<BType> mainType = ((BUnionType) type).getMemberTypes().stream()", "originalCommit": "f6242477c6a3f424e14896da82d393f2393efb0d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY0NTA2NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r483645065", "bodyText": "Refactored this", "author": "lasinicl", "createdAt": "2020-09-04T14:19:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM5MTY5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM5MTgyMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r483391821", "bodyText": "What if the union has multiple compatible types? Should it not be an error?", "author": "MaryamZi", "createdAt": "2020-09-04T05:17:11Z", "path": "langlib/lang.array/src/main/java/org/ballerinalang/langlib/array/Sort.java", "diffHunk": "@@ -18,73 +18,185 @@\n \n package org.ballerinalang.langlib.array;\n \n+import org.ballerinalang.jvm.BallerinaErrors;\n import org.ballerinalang.jvm.scheduling.Strand;\n import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BFunctionType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BUnionType;\n+import org.ballerinalang.jvm.types.TypeTags;\n import org.ballerinalang.jvm.values.ArrayValue;\n-import org.ballerinalang.jvm.values.ArrayValueImpl;\n import org.ballerinalang.jvm.values.FPValue;\n import org.ballerinalang.model.types.TypeKind;\n import org.ballerinalang.natives.annotations.Argument;\n import org.ballerinalang.natives.annotations.BallerinaFunction;\n import org.ballerinalang.natives.annotations.ReturnType;\n \n+import java.math.BigDecimal;\n+import java.util.Optional;\n+\n import static org.ballerinalang.jvm.values.utils.ArrayUtils.checkIsArrayOnlyOperation;\n import static org.ballerinalang.util.BLangCompilerConstants.ARRAY_VERSION;\n \n /**\n- * Native implementation of lang.array:sort((any|error)[], function).\n+ * Native implementation of lang.array:sort((any|error)[], direction, function).\n  *\n  * @since 1.0\n  */\n @BallerinaFunction(\n         orgName = \"ballerina\", packageName = \"lang.array\", version = ARRAY_VERSION, functionName = \"sort\",\n-        args = {@Argument(name = \"arr\", type = TypeKind.ARRAY), @Argument(name = \"func\", type = TypeKind.FUNCTION)},\n+        args = {@Argument(name = \"arr\", type = TypeKind.ARRAY), @Argument(name = \"direction\", type = TypeKind.OBJECT),\n+                @Argument(name = \"func\", type = TypeKind.OBJECT)},\n         returnType = {@ReturnType(type = TypeKind.ARRAY)},\n         isPublic = true\n )\n public class Sort {\n \n-    public static ArrayValue sort(Strand strand, ArrayValue arr, FPValue<Object, Long> func) {\n+    public static ArrayValue sort(Strand strand, ArrayValue arr, Object direction, Object func) {\n         checkIsArrayOnlyOperation(arr.getType(), \"sort()\");\n-        ArrayValue aux = new ArrayValueImpl((BArrayType) arr.getType());\n-        mergesort(arr, aux, 0, arr.size() - 1, strand, func);\n+        FPValue<Object, Object> function = (FPValue<Object, Object>) func;\n+        BType elemType = ((BArrayType) arr.getType()).getElementType();\n+        boolean isAscending = true;\n+        if (direction.toString().equals(\"descending\")) {\n+            isAscending = false;\n+        }\n+\n+        Object[][] sortArr = new Object[arr.size()][2];\n+        Object[][] sortArrClone = new Object[arr.size()][2];\n+        for (int i = 0; i < arr.size(); i++) {\n+            if (function != null) {\n+                Object x = function.call(new Object[]{strand, arr.get(i), true});\n+                sortArr[i][0] = x;\n+            } else {\n+                sortArr[i][0] = arr.get(i);\n+            }\n+            sortArr[i][1] = arr.get(i);\n+        }\n+\n+        if (function != null) {\n+            elemType = ((BFunctionType) function.getType()).retType;\n+        }\n+        if (elemType.getTag() == TypeTags.UNION_TAG) {\n+            elemType = getType(elemType);\n+        }\n+        if (elemType.getTag() == TypeTags.ARRAY_TAG) {\n+            BType type = ((BArrayType) elemType).getElementType();\n+            if (type.getTag() == TypeTags.UNION_TAG) {\n+                elemType = getType(type);\n+            }\n+        }\n+\n+        mergesort(sortArr, sortArrClone, 0, sortArr.length - 1, isAscending, elemType);\n+\n+        for (int k = 0; k < sortArr.length; k++) {\n+            arr.add(k, sortArr[k][1]);\n+        }\n+\n         return arr;\n     }\n \n-    // Adapted from https://algs4.cs.princeton.edu/22mergesort/Merge.java.html\n-    private static void mergesort(ArrayValue input, ArrayValue aux, int lo, int hi, Strand strand,\n-                                  FPValue<Object, Long> comparator) {\n+    private static BType getType(BType type) {\n+        Optional<BType> mainType = ((BUnionType) type).getMemberTypes().stream()\n+                .filter(m -> m.getTag() == TypeTags.INT_TAG || m.getTag() == TypeTags.BYTE_TAG ||\n+                        m.getTag() == TypeTags.FLOAT_TAG || m.getTag() == TypeTags.DECIMAL_TAG ||\n+                        m.getTag() == TypeTags.STRING_TAG || m.getTag() == TypeTags.BOOLEAN_TAG ||\n+                        m.getTag() == TypeTags.ARRAY_TAG).findFirst();", "originalCommit": "f6242477c6a3f424e14896da82d393f2393efb0d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY0Mzk3MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r483643971", "bodyText": "Handled this at compile time during type checking", "author": "lasinicl", "createdAt": "2020-09-04T14:17:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM5MTgyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM5MjAwNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r483392007", "bodyText": "Can we rename the function to indicate what we're actually looking for and change the param to a BUnionType?", "author": "MaryamZi", "createdAt": "2020-09-04T05:17:53Z", "path": "langlib/lang.array/src/main/java/org/ballerinalang/langlib/array/Sort.java", "diffHunk": "@@ -18,73 +18,185 @@\n \n package org.ballerinalang.langlib.array;\n \n+import org.ballerinalang.jvm.BallerinaErrors;\n import org.ballerinalang.jvm.scheduling.Strand;\n import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BFunctionType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BUnionType;\n+import org.ballerinalang.jvm.types.TypeTags;\n import org.ballerinalang.jvm.values.ArrayValue;\n-import org.ballerinalang.jvm.values.ArrayValueImpl;\n import org.ballerinalang.jvm.values.FPValue;\n import org.ballerinalang.model.types.TypeKind;\n import org.ballerinalang.natives.annotations.Argument;\n import org.ballerinalang.natives.annotations.BallerinaFunction;\n import org.ballerinalang.natives.annotations.ReturnType;\n \n+import java.math.BigDecimal;\n+import java.util.Optional;\n+\n import static org.ballerinalang.jvm.values.utils.ArrayUtils.checkIsArrayOnlyOperation;\n import static org.ballerinalang.util.BLangCompilerConstants.ARRAY_VERSION;\n \n /**\n- * Native implementation of lang.array:sort((any|error)[], function).\n+ * Native implementation of lang.array:sort((any|error)[], direction, function).\n  *\n  * @since 1.0\n  */\n @BallerinaFunction(\n         orgName = \"ballerina\", packageName = \"lang.array\", version = ARRAY_VERSION, functionName = \"sort\",\n-        args = {@Argument(name = \"arr\", type = TypeKind.ARRAY), @Argument(name = \"func\", type = TypeKind.FUNCTION)},\n+        args = {@Argument(name = \"arr\", type = TypeKind.ARRAY), @Argument(name = \"direction\", type = TypeKind.OBJECT),\n+                @Argument(name = \"func\", type = TypeKind.OBJECT)},\n         returnType = {@ReturnType(type = TypeKind.ARRAY)},\n         isPublic = true\n )\n public class Sort {\n \n-    public static ArrayValue sort(Strand strand, ArrayValue arr, FPValue<Object, Long> func) {\n+    public static ArrayValue sort(Strand strand, ArrayValue arr, Object direction, Object func) {\n         checkIsArrayOnlyOperation(arr.getType(), \"sort()\");\n-        ArrayValue aux = new ArrayValueImpl((BArrayType) arr.getType());\n-        mergesort(arr, aux, 0, arr.size() - 1, strand, func);\n+        FPValue<Object, Object> function = (FPValue<Object, Object>) func;\n+        BType elemType = ((BArrayType) arr.getType()).getElementType();\n+        boolean isAscending = true;\n+        if (direction.toString().equals(\"descending\")) {\n+            isAscending = false;\n+        }\n+\n+        Object[][] sortArr = new Object[arr.size()][2];\n+        Object[][] sortArrClone = new Object[arr.size()][2];\n+        for (int i = 0; i < arr.size(); i++) {\n+            if (function != null) {\n+                Object x = function.call(new Object[]{strand, arr.get(i), true});\n+                sortArr[i][0] = x;\n+            } else {\n+                sortArr[i][0] = arr.get(i);\n+            }\n+            sortArr[i][1] = arr.get(i);\n+        }\n+\n+        if (function != null) {\n+            elemType = ((BFunctionType) function.getType()).retType;\n+        }\n+        if (elemType.getTag() == TypeTags.UNION_TAG) {\n+            elemType = getType(elemType);\n+        }\n+        if (elemType.getTag() == TypeTags.ARRAY_TAG) {\n+            BType type = ((BArrayType) elemType).getElementType();\n+            if (type.getTag() == TypeTags.UNION_TAG) {\n+                elemType = getType(type);\n+            }\n+        }\n+\n+        mergesort(sortArr, sortArrClone, 0, sortArr.length - 1, isAscending, elemType);\n+\n+        for (int k = 0; k < sortArr.length; k++) {\n+            arr.add(k, sortArr[k][1]);\n+        }\n+\n         return arr;\n     }\n \n-    // Adapted from https://algs4.cs.princeton.edu/22mergesort/Merge.java.html\n-    private static void mergesort(ArrayValue input, ArrayValue aux, int lo, int hi, Strand strand,\n-                                  FPValue<Object, Long> comparator) {\n+    private static BType getType(BType type) {", "originalCommit": "f6242477c6a3f424e14896da82d393f2393efb0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM5MjcwNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r483392707", "bodyText": "Since you're definitely returning in the previous if bock we can make this another if instead of an else-if right?", "author": "MaryamZi", "createdAt": "2020-09-04T05:20:32Z", "path": "langlib/lang.array/src/main/java/org/ballerinalang/langlib/array/Sort.java", "diffHunk": "@@ -18,73 +18,185 @@\n \n package org.ballerinalang.langlib.array;\n \n+import org.ballerinalang.jvm.BallerinaErrors;\n import org.ballerinalang.jvm.scheduling.Strand;\n import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BFunctionType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BUnionType;\n+import org.ballerinalang.jvm.types.TypeTags;\n import org.ballerinalang.jvm.values.ArrayValue;\n-import org.ballerinalang.jvm.values.ArrayValueImpl;\n import org.ballerinalang.jvm.values.FPValue;\n import org.ballerinalang.model.types.TypeKind;\n import org.ballerinalang.natives.annotations.Argument;\n import org.ballerinalang.natives.annotations.BallerinaFunction;\n import org.ballerinalang.natives.annotations.ReturnType;\n \n+import java.math.BigDecimal;\n+import java.util.Optional;\n+\n import static org.ballerinalang.jvm.values.utils.ArrayUtils.checkIsArrayOnlyOperation;\n import static org.ballerinalang.util.BLangCompilerConstants.ARRAY_VERSION;\n \n /**\n- * Native implementation of lang.array:sort((any|error)[], function).\n+ * Native implementation of lang.array:sort((any|error)[], direction, function).\n  *\n  * @since 1.0\n  */\n @BallerinaFunction(\n         orgName = \"ballerina\", packageName = \"lang.array\", version = ARRAY_VERSION, functionName = \"sort\",\n-        args = {@Argument(name = \"arr\", type = TypeKind.ARRAY), @Argument(name = \"func\", type = TypeKind.FUNCTION)},\n+        args = {@Argument(name = \"arr\", type = TypeKind.ARRAY), @Argument(name = \"direction\", type = TypeKind.OBJECT),\n+                @Argument(name = \"func\", type = TypeKind.OBJECT)},\n         returnType = {@ReturnType(type = TypeKind.ARRAY)},\n         isPublic = true\n )\n public class Sort {\n \n-    public static ArrayValue sort(Strand strand, ArrayValue arr, FPValue<Object, Long> func) {\n+    public static ArrayValue sort(Strand strand, ArrayValue arr, Object direction, Object func) {\n         checkIsArrayOnlyOperation(arr.getType(), \"sort()\");\n-        ArrayValue aux = new ArrayValueImpl((BArrayType) arr.getType());\n-        mergesort(arr, aux, 0, arr.size() - 1, strand, func);\n+        FPValue<Object, Object> function = (FPValue<Object, Object>) func;\n+        BType elemType = ((BArrayType) arr.getType()).getElementType();\n+        boolean isAscending = true;\n+        if (direction.toString().equals(\"descending\")) {\n+            isAscending = false;\n+        }\n+\n+        Object[][] sortArr = new Object[arr.size()][2];\n+        Object[][] sortArrClone = new Object[arr.size()][2];\n+        for (int i = 0; i < arr.size(); i++) {\n+            if (function != null) {\n+                Object x = function.call(new Object[]{strand, arr.get(i), true});\n+                sortArr[i][0] = x;\n+            } else {\n+                sortArr[i][0] = arr.get(i);\n+            }\n+            sortArr[i][1] = arr.get(i);\n+        }\n+\n+        if (function != null) {\n+            elemType = ((BFunctionType) function.getType()).retType;\n+        }\n+        if (elemType.getTag() == TypeTags.UNION_TAG) {\n+            elemType = getType(elemType);\n+        }\n+        if (elemType.getTag() == TypeTags.ARRAY_TAG) {\n+            BType type = ((BArrayType) elemType).getElementType();\n+            if (type.getTag() == TypeTags.UNION_TAG) {\n+                elemType = getType(type);\n+            }\n+        }\n+\n+        mergesort(sortArr, sortArrClone, 0, sortArr.length - 1, isAscending, elemType);\n+\n+        for (int k = 0; k < sortArr.length; k++) {\n+            arr.add(k, sortArr[k][1]);\n+        }\n+\n         return arr;\n     }\n \n-    // Adapted from https://algs4.cs.princeton.edu/22mergesort/Merge.java.html\n-    private static void mergesort(ArrayValue input, ArrayValue aux, int lo, int hi, Strand strand,\n-                                  FPValue<Object, Long> comparator) {\n+    private static BType getType(BType type) {\n+        Optional<BType> mainType = ((BUnionType) type).getMemberTypes().stream()\n+                .filter(m -> m.getTag() == TypeTags.INT_TAG || m.getTag() == TypeTags.BYTE_TAG ||\n+                        m.getTag() == TypeTags.FLOAT_TAG || m.getTag() == TypeTags.DECIMAL_TAG ||\n+                        m.getTag() == TypeTags.STRING_TAG || m.getTag() == TypeTags.BOOLEAN_TAG ||\n+                        m.getTag() == TypeTags.ARRAY_TAG).findFirst();\n+        if (mainType.isPresent()) {\n+            type = mainType.get();\n+        }\n+        return type;\n+    }\n+\n+    private static void mergesort(Object[][] input, Object[][] aux, int lo, int hi, boolean isAscending, BType type) {\n         if (hi <= lo) {\n             return;\n         }\n \n         int mid = lo + (hi - lo) / 2;\n \n-        mergesort(input, aux, lo, mid, strand, comparator);\n-        mergesort(input, aux, mid + 1, hi, strand, comparator);\n+        mergesort(input, aux, lo, mid, isAscending, type);\n+        mergesort(input, aux, mid + 1, hi, isAscending, type);\n \n-        merge(input, aux, lo, mid, hi, strand, comparator);\n+        merge(input, aux, lo, mid, hi, isAscending, type);\n     }\n \n-    private static void merge(ArrayValue input, ArrayValue aux, int lo, int mid, int hi, Strand strand,\n-                              FPValue<Object, Long> comparator) {\n-        int elemTypeTag = input.getElementType().getTag();\n-\n-        for (int i = lo; i <= hi; i++) {\n-            aux.add(i, input.get(i));\n+    private static void merge(Object[][] input, Object[][] aux, int lo, int mid, int hi, boolean isAscending,\n+                              BType type) {\n+        if (hi + 1 - lo >= 0) {\n+            System.arraycopy(input, lo, aux, lo, hi + 1 - lo);\n         }\n \n         for (int i = lo, j = mid + 1, k = lo; k <= hi; k++) {\n+            int index;\n             if (i > mid) {\n-                input.add(k, aux.get(j++));\n+                index = j++;\n             } else if (j > hi) {\n-                input.add(k, aux.get(i++));\n-            } else if (comparator.call(new Object[]{strand, aux.get(j), true, aux.get(i), true}) < 0) {\n-                input.add(k, aux.get(j++));\n+                index = i++;\n+            } else if (isAscending && sortFunc(aux[j][0], aux[i][0], type, true) < 0) {\n+                index = j++;\n+            } else if (!isAscending && sortFunc(aux[i][0], aux[j][0], type, false) < 0) {\n+                index = j++;\n             } else {\n-                input.add(k, aux.get(i++));\n+                index = i++;\n             }\n+            input[k] = aux[index];\n         }\n     }\n \n+    private static int sortFunc(Object value1, Object value2, BType type, boolean isAscending) {\n+        int c = -999;\n+        // () should come last irrespective of the sort direction.\n+        if (value1 == null) {\n+            if (value2 == null) {\n+                return 0;\n+            }\n+            if (isAscending) {\n+                return 1;\n+            }\n+            return -1;\n+        } else if (value2 == null) {", "originalCommit": "f6242477c6a3f424e14896da82d393f2393efb0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM5MzI1NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r483393255", "bodyText": "What about subtypes like SIGNED32_INT_TAG, SIGNED16_INT_TAG, etc.? Same for string and char too.\nThe util methods in TypeTags.java may be useful. org.ballerinalang.jvm.types.TypeTags#isIntegerTypeTag", "author": "MaryamZi", "createdAt": "2020-09-04T05:22:37Z", "path": "langlib/lang.array/src/main/java/org/ballerinalang/langlib/array/Sort.java", "diffHunk": "@@ -18,73 +18,185 @@\n \n package org.ballerinalang.langlib.array;\n \n+import org.ballerinalang.jvm.BallerinaErrors;\n import org.ballerinalang.jvm.scheduling.Strand;\n import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BFunctionType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BUnionType;\n+import org.ballerinalang.jvm.types.TypeTags;\n import org.ballerinalang.jvm.values.ArrayValue;\n-import org.ballerinalang.jvm.values.ArrayValueImpl;\n import org.ballerinalang.jvm.values.FPValue;\n import org.ballerinalang.model.types.TypeKind;\n import org.ballerinalang.natives.annotations.Argument;\n import org.ballerinalang.natives.annotations.BallerinaFunction;\n import org.ballerinalang.natives.annotations.ReturnType;\n \n+import java.math.BigDecimal;\n+import java.util.Optional;\n+\n import static org.ballerinalang.jvm.values.utils.ArrayUtils.checkIsArrayOnlyOperation;\n import static org.ballerinalang.util.BLangCompilerConstants.ARRAY_VERSION;\n \n /**\n- * Native implementation of lang.array:sort((any|error)[], function).\n+ * Native implementation of lang.array:sort((any|error)[], direction, function).\n  *\n  * @since 1.0\n  */\n @BallerinaFunction(\n         orgName = \"ballerina\", packageName = \"lang.array\", version = ARRAY_VERSION, functionName = \"sort\",\n-        args = {@Argument(name = \"arr\", type = TypeKind.ARRAY), @Argument(name = \"func\", type = TypeKind.FUNCTION)},\n+        args = {@Argument(name = \"arr\", type = TypeKind.ARRAY), @Argument(name = \"direction\", type = TypeKind.OBJECT),\n+                @Argument(name = \"func\", type = TypeKind.OBJECT)},\n         returnType = {@ReturnType(type = TypeKind.ARRAY)},\n         isPublic = true\n )\n public class Sort {\n \n-    public static ArrayValue sort(Strand strand, ArrayValue arr, FPValue<Object, Long> func) {\n+    public static ArrayValue sort(Strand strand, ArrayValue arr, Object direction, Object func) {\n         checkIsArrayOnlyOperation(arr.getType(), \"sort()\");\n-        ArrayValue aux = new ArrayValueImpl((BArrayType) arr.getType());\n-        mergesort(arr, aux, 0, arr.size() - 1, strand, func);\n+        FPValue<Object, Object> function = (FPValue<Object, Object>) func;\n+        BType elemType = ((BArrayType) arr.getType()).getElementType();\n+        boolean isAscending = true;\n+        if (direction.toString().equals(\"descending\")) {\n+            isAscending = false;\n+        }\n+\n+        Object[][] sortArr = new Object[arr.size()][2];\n+        Object[][] sortArrClone = new Object[arr.size()][2];\n+        for (int i = 0; i < arr.size(); i++) {\n+            if (function != null) {\n+                Object x = function.call(new Object[]{strand, arr.get(i), true});\n+                sortArr[i][0] = x;\n+            } else {\n+                sortArr[i][0] = arr.get(i);\n+            }\n+            sortArr[i][1] = arr.get(i);\n+        }\n+\n+        if (function != null) {\n+            elemType = ((BFunctionType) function.getType()).retType;\n+        }\n+        if (elemType.getTag() == TypeTags.UNION_TAG) {\n+            elemType = getType(elemType);\n+        }\n+        if (elemType.getTag() == TypeTags.ARRAY_TAG) {\n+            BType type = ((BArrayType) elemType).getElementType();\n+            if (type.getTag() == TypeTags.UNION_TAG) {\n+                elemType = getType(type);\n+            }\n+        }\n+\n+        mergesort(sortArr, sortArrClone, 0, sortArr.length - 1, isAscending, elemType);\n+\n+        for (int k = 0; k < sortArr.length; k++) {\n+            arr.add(k, sortArr[k][1]);\n+        }\n+\n         return arr;\n     }\n \n-    // Adapted from https://algs4.cs.princeton.edu/22mergesort/Merge.java.html\n-    private static void mergesort(ArrayValue input, ArrayValue aux, int lo, int hi, Strand strand,\n-                                  FPValue<Object, Long> comparator) {\n+    private static BType getType(BType type) {\n+        Optional<BType> mainType = ((BUnionType) type).getMemberTypes().stream()\n+                .filter(m -> m.getTag() == TypeTags.INT_TAG || m.getTag() == TypeTags.BYTE_TAG ||\n+                        m.getTag() == TypeTags.FLOAT_TAG || m.getTag() == TypeTags.DECIMAL_TAG ||\n+                        m.getTag() == TypeTags.STRING_TAG || m.getTag() == TypeTags.BOOLEAN_TAG ||\n+                        m.getTag() == TypeTags.ARRAY_TAG).findFirst();\n+        if (mainType.isPresent()) {\n+            type = mainType.get();\n+        }\n+        return type;\n+    }\n+\n+    private static void mergesort(Object[][] input, Object[][] aux, int lo, int hi, boolean isAscending, BType type) {\n         if (hi <= lo) {\n             return;\n         }\n \n         int mid = lo + (hi - lo) / 2;\n \n-        mergesort(input, aux, lo, mid, strand, comparator);\n-        mergesort(input, aux, mid + 1, hi, strand, comparator);\n+        mergesort(input, aux, lo, mid, isAscending, type);\n+        mergesort(input, aux, mid + 1, hi, isAscending, type);\n \n-        merge(input, aux, lo, mid, hi, strand, comparator);\n+        merge(input, aux, lo, mid, hi, isAscending, type);\n     }\n \n-    private static void merge(ArrayValue input, ArrayValue aux, int lo, int mid, int hi, Strand strand,\n-                              FPValue<Object, Long> comparator) {\n-        int elemTypeTag = input.getElementType().getTag();\n-\n-        for (int i = lo; i <= hi; i++) {\n-            aux.add(i, input.get(i));\n+    private static void merge(Object[][] input, Object[][] aux, int lo, int mid, int hi, boolean isAscending,\n+                              BType type) {\n+        if (hi + 1 - lo >= 0) {\n+            System.arraycopy(input, lo, aux, lo, hi + 1 - lo);\n         }\n \n         for (int i = lo, j = mid + 1, k = lo; k <= hi; k++) {\n+            int index;\n             if (i > mid) {\n-                input.add(k, aux.get(j++));\n+                index = j++;\n             } else if (j > hi) {\n-                input.add(k, aux.get(i++));\n-            } else if (comparator.call(new Object[]{strand, aux.get(j), true, aux.get(i), true}) < 0) {\n-                input.add(k, aux.get(j++));\n+                index = i++;\n+            } else if (isAscending && sortFunc(aux[j][0], aux[i][0], type, true) < 0) {\n+                index = j++;\n+            } else if (!isAscending && sortFunc(aux[i][0], aux[j][0], type, false) < 0) {\n+                index = j++;\n             } else {\n-                input.add(k, aux.get(i++));\n+                index = i++;\n             }\n+            input[k] = aux[index];\n         }\n     }\n \n+    private static int sortFunc(Object value1, Object value2, BType type, boolean isAscending) {\n+        int c = -999;\n+        // () should come last irrespective of the sort direction.\n+        if (value1 == null) {\n+            if (value2 == null) {\n+                return 0;\n+            }\n+            if (isAscending) {\n+                return 1;\n+            }\n+            return -1;\n+        } else if (value2 == null) {\n+            if (isAscending) {\n+                return -1;\n+            }\n+            return 1;\n+        } else if (type.getTag() == TypeTags.INT_TAG) {", "originalCommit": "f6242477c6a3f424e14896da82d393f2393efb0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM5Mzk2NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r483393965", "bodyText": "This doesn't seem to follow the normal practice we follow for langlib errors. We currently have a simple string as the error message and the second arg goes into the detail. Please check other usage of this method.", "author": "MaryamZi", "createdAt": "2020-09-04T05:25:15Z", "path": "langlib/lang.array/src/main/java/org/ballerinalang/langlib/array/Sort.java", "diffHunk": "@@ -18,73 +18,185 @@\n \n package org.ballerinalang.langlib.array;\n \n+import org.ballerinalang.jvm.BallerinaErrors;\n import org.ballerinalang.jvm.scheduling.Strand;\n import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BFunctionType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BUnionType;\n+import org.ballerinalang.jvm.types.TypeTags;\n import org.ballerinalang.jvm.values.ArrayValue;\n-import org.ballerinalang.jvm.values.ArrayValueImpl;\n import org.ballerinalang.jvm.values.FPValue;\n import org.ballerinalang.model.types.TypeKind;\n import org.ballerinalang.natives.annotations.Argument;\n import org.ballerinalang.natives.annotations.BallerinaFunction;\n import org.ballerinalang.natives.annotations.ReturnType;\n \n+import java.math.BigDecimal;\n+import java.util.Optional;\n+\n import static org.ballerinalang.jvm.values.utils.ArrayUtils.checkIsArrayOnlyOperation;\n import static org.ballerinalang.util.BLangCompilerConstants.ARRAY_VERSION;\n \n /**\n- * Native implementation of lang.array:sort((any|error)[], function).\n+ * Native implementation of lang.array:sort((any|error)[], direction, function).\n  *\n  * @since 1.0\n  */\n @BallerinaFunction(\n         orgName = \"ballerina\", packageName = \"lang.array\", version = ARRAY_VERSION, functionName = \"sort\",\n-        args = {@Argument(name = \"arr\", type = TypeKind.ARRAY), @Argument(name = \"func\", type = TypeKind.FUNCTION)},\n+        args = {@Argument(name = \"arr\", type = TypeKind.ARRAY), @Argument(name = \"direction\", type = TypeKind.OBJECT),\n+                @Argument(name = \"func\", type = TypeKind.OBJECT)},\n         returnType = {@ReturnType(type = TypeKind.ARRAY)},\n         isPublic = true\n )\n public class Sort {\n \n-    public static ArrayValue sort(Strand strand, ArrayValue arr, FPValue<Object, Long> func) {\n+    public static ArrayValue sort(Strand strand, ArrayValue arr, Object direction, Object func) {\n         checkIsArrayOnlyOperation(arr.getType(), \"sort()\");\n-        ArrayValue aux = new ArrayValueImpl((BArrayType) arr.getType());\n-        mergesort(arr, aux, 0, arr.size() - 1, strand, func);\n+        FPValue<Object, Object> function = (FPValue<Object, Object>) func;\n+        BType elemType = ((BArrayType) arr.getType()).getElementType();\n+        boolean isAscending = true;\n+        if (direction.toString().equals(\"descending\")) {\n+            isAscending = false;\n+        }\n+\n+        Object[][] sortArr = new Object[arr.size()][2];\n+        Object[][] sortArrClone = new Object[arr.size()][2];\n+        for (int i = 0; i < arr.size(); i++) {\n+            if (function != null) {\n+                Object x = function.call(new Object[]{strand, arr.get(i), true});\n+                sortArr[i][0] = x;\n+            } else {\n+                sortArr[i][0] = arr.get(i);\n+            }\n+            sortArr[i][1] = arr.get(i);\n+        }\n+\n+        if (function != null) {\n+            elemType = ((BFunctionType) function.getType()).retType;\n+        }\n+        if (elemType.getTag() == TypeTags.UNION_TAG) {\n+            elemType = getType(elemType);\n+        }\n+        if (elemType.getTag() == TypeTags.ARRAY_TAG) {\n+            BType type = ((BArrayType) elemType).getElementType();\n+            if (type.getTag() == TypeTags.UNION_TAG) {\n+                elemType = getType(type);\n+            }\n+        }\n+\n+        mergesort(sortArr, sortArrClone, 0, sortArr.length - 1, isAscending, elemType);\n+\n+        for (int k = 0; k < sortArr.length; k++) {\n+            arr.add(k, sortArr[k][1]);\n+        }\n+\n         return arr;\n     }\n \n-    // Adapted from https://algs4.cs.princeton.edu/22mergesort/Merge.java.html\n-    private static void mergesort(ArrayValue input, ArrayValue aux, int lo, int hi, Strand strand,\n-                                  FPValue<Object, Long> comparator) {\n+    private static BType getType(BType type) {\n+        Optional<BType> mainType = ((BUnionType) type).getMemberTypes().stream()\n+                .filter(m -> m.getTag() == TypeTags.INT_TAG || m.getTag() == TypeTags.BYTE_TAG ||\n+                        m.getTag() == TypeTags.FLOAT_TAG || m.getTag() == TypeTags.DECIMAL_TAG ||\n+                        m.getTag() == TypeTags.STRING_TAG || m.getTag() == TypeTags.BOOLEAN_TAG ||\n+                        m.getTag() == TypeTags.ARRAY_TAG).findFirst();\n+        if (mainType.isPresent()) {\n+            type = mainType.get();\n+        }\n+        return type;\n+    }\n+\n+    private static void mergesort(Object[][] input, Object[][] aux, int lo, int hi, boolean isAscending, BType type) {\n         if (hi <= lo) {\n             return;\n         }\n \n         int mid = lo + (hi - lo) / 2;\n \n-        mergesort(input, aux, lo, mid, strand, comparator);\n-        mergesort(input, aux, mid + 1, hi, strand, comparator);\n+        mergesort(input, aux, lo, mid, isAscending, type);\n+        mergesort(input, aux, mid + 1, hi, isAscending, type);\n \n-        merge(input, aux, lo, mid, hi, strand, comparator);\n+        merge(input, aux, lo, mid, hi, isAscending, type);\n     }\n \n-    private static void merge(ArrayValue input, ArrayValue aux, int lo, int mid, int hi, Strand strand,\n-                              FPValue<Object, Long> comparator) {\n-        int elemTypeTag = input.getElementType().getTag();\n-\n-        for (int i = lo; i <= hi; i++) {\n-            aux.add(i, input.get(i));\n+    private static void merge(Object[][] input, Object[][] aux, int lo, int mid, int hi, boolean isAscending,\n+                              BType type) {\n+        if (hi + 1 - lo >= 0) {\n+            System.arraycopy(input, lo, aux, lo, hi + 1 - lo);\n         }\n \n         for (int i = lo, j = mid + 1, k = lo; k <= hi; k++) {\n+            int index;\n             if (i > mid) {\n-                input.add(k, aux.get(j++));\n+                index = j++;\n             } else if (j > hi) {\n-                input.add(k, aux.get(i++));\n-            } else if (comparator.call(new Object[]{strand, aux.get(j), true, aux.get(i), true}) < 0) {\n-                input.add(k, aux.get(j++));\n+                index = i++;\n+            } else if (isAscending && sortFunc(aux[j][0], aux[i][0], type, true) < 0) {\n+                index = j++;\n+            } else if (!isAscending && sortFunc(aux[i][0], aux[j][0], type, false) < 0) {\n+                index = j++;\n             } else {\n-                input.add(k, aux.get(i++));\n+                index = i++;\n             }\n+            input[k] = aux[index];\n         }\n     }\n \n+    private static int sortFunc(Object value1, Object value2, BType type, boolean isAscending) {\n+        int c = -999;\n+        // () should come last irrespective of the sort direction.\n+        if (value1 == null) {\n+            if (value2 == null) {\n+                return 0;\n+            }\n+            if (isAscending) {\n+                return 1;\n+            }\n+            return -1;\n+        } else if (value2 == null) {\n+            if (isAscending) {\n+                return -1;\n+            }\n+            return 1;\n+        } else if (type.getTag() == TypeTags.INT_TAG) {\n+            c = Long.compare((long) value1, (long) value2);\n+        } else if (type.getTag() == TypeTags.FLOAT_TAG) {\n+            // NaN should be placed last or one before the last when () is present irrespective of the sort direction.\n+            if (Double.isNaN((double) value1)) {\n+                if (Double.isNaN((double) value2)) {\n+                    return 0;\n+                }\n+                if (isAscending) {\n+                    return 1;\n+                }\n+                return -1;\n+            } else if (Double.isNaN((double) value2)) {\n+                if (isAscending) {\n+                    return -1;\n+                }\n+                return 1;\n+            }\n+            c = Double.compare((double) value1, (double) value2);\n+        } else if (type.getTag() == TypeTags.DECIMAL_TAG) {\n+            c = new BigDecimal(value1.toString()).compareTo(new BigDecimal(value2.toString()));\n+        } else if (type.getTag() == TypeTags.BOOLEAN_TAG) {\n+            c = Boolean.compare((boolean) value1, (boolean) value2);\n+        } else if (type.getTag() == TypeTags.STRING_TAG) {\n+            c = value1.toString().compareToIgnoreCase(value2.toString());\n+        } else if (type.getTag() == TypeTags.BYTE_TAG) {\n+            c = Integer.compare((int) value1, (int) value2);\n+        } else if (type.getTag() == TypeTags.ARRAY_TAG) {\n+            for (int i = 0; i < ((ArrayValue) value1).size(); i++) {\n+                c = sortFunc(((ArrayValue) value1).get(i), ((ArrayValue) value2).get(i),\n+                        ((ArrayValue) value1).getElementType(), isAscending);\n+                if (c != 0) {\n+                    break;\n+                }\n+            }\n+        } else {\n+            throw BallerinaErrors.createError(\"invalid sort key type\", \"Failed to sort array\");", "originalCommit": "f6242477c6a3f424e14896da82d393f2393efb0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM5NzQ5OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r483397499", "bodyText": "I think we can refactor this method a bit by returning early on error and merging the if blocks.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (iExpr.argExprs.size() <= 2) {\n          \n          \n            \n                        if (!types.isBasicType(iExpr.expr.type)) {\n          \n          \n            \n                            dlog.error(iExpr.expr.pos, DiagnosticCode.INVALID_SORT_ARRAY_MEMBER_TYPE, iExpr.expr.type);\n          \n          \n            \n                        }\n          \n          \n            \n                    } else if (iExpr.argExprs.size() == 3) {\n          \n          \n            \n                        if (iExpr.argExprs.get(2).type != null) {\n          \n          \n            \n                            if (iExpr.argExprs.get(2).type.tag == TypeTags.SEMANTIC_ERROR) {\n          \n          \n            \n                                return;\n          \n          \n            \n                            } else if (iExpr.argExprs.get(2).type.tag == TypeTags.NIL && !types.isBasicType(iExpr.expr.type)) {\n          \n          \n            \n                                dlog.error(iExpr.expr.pos, DiagnosticCode.INVALID_SORT_ARRAY_MEMBER_TYPE, iExpr.expr.type);\n          \n          \n            \n                            }\n          \n          \n            \n                        } else {\n          \n          \n            \n                            BLangLambdaFunction func = (BLangLambdaFunction) iExpr.argExprs.get(2);\n          \n          \n            \n                            BType returnType = func.function.type.getReturnType();\n          \n          \n            \n                            if (!types.isBasicType(returnType)) {\n          \n          \n            \n                                dlog.error(iExpr.expr.pos, DiagnosticCode.INVALID_SORT_FUNC_RETURN_TYPE, returnType);\n          \n          \n            \n                            }\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n                private void checkArrayLibSortFuncArgs(BLangInvocation iExpr) {\n          \n          \n            \n                    if (iExpr.argExprs.size() <= 2 && !types.isBasicType(iExpr.expr.type)) {\n          \n          \n            \n                        dlog.error(iExpr.expr.pos, DiagnosticCode.INVALID_SORT_ARRAY_MEMBER_TYPE, iExpr.expr.type);\n          \n          \n            \n                    } \n          \n          \n            \n                    \n          \n          \n            \n                    if (iExpr.argExprs.size() != 3) {\n          \n          \n            \n                        return;\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    BLangExpression argThree = iExpr.argExprs.get(2);\n          \n          \n            \n                    BType argThreeType = argThree.type;\n          \n          \n            \n                    if (argThreeType != null) {\n          \n          \n            \n                        if (argThreeType.tag == TypeTags.SEMANTIC_ERROR) {\n          \n          \n            \n                            return;\n          \n          \n            \n                        }\n          \n          \n            \n                        \n          \n          \n            \n                        if (argThreeType.tag == TypeTags.NIL && !types.isBasicType(iExpr.expr.type)) {\n          \n          \n            \n                            dlog.error(iExpr.expr.pos, DiagnosticCode.INVALID_SORT_ARRAY_MEMBER_TYPE, iExpr.expr.type);\n          \n          \n            \n                            return;\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                    \n          \n          \n            \n                    BLangLambdaFunction func = (BLangLambdaFunction) argThree;\n          \n          \n            \n                    BType returnType = func.function.type.getReturnType();\n          \n          \n            \n                    if (!types.isBasicType(returnType)) {\n          \n          \n            \n                        dlog.error(iExpr.expr.pos, DiagnosticCode.INVALID_SORT_FUNC_RETURN_TYPE, returnType);\n          \n          \n            \n                    }\n          \n          \n            \n                }", "author": "MaryamZi", "createdAt": "2020-09-04T05:37:55Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -5390,6 +5395,28 @@ private BType checkInvocationArgs(BLangInvocation iExpr, List<BType> paramTypes,\n         }\n     }\n \n+    private void checkArrayLibSortFuncArgs(BLangInvocation iExpr) {\n+        if (iExpr.argExprs.size() <= 2) {\n+            if (!types.isBasicType(iExpr.expr.type)) {\n+                dlog.error(iExpr.expr.pos, DiagnosticCode.INVALID_SORT_ARRAY_MEMBER_TYPE, iExpr.expr.type);\n+            }\n+        } else if (iExpr.argExprs.size() == 3) {\n+            if (iExpr.argExprs.get(2).type != null) {\n+                if (iExpr.argExprs.get(2).type.tag == TypeTags.SEMANTIC_ERROR) {\n+                    return;\n+                } else if (iExpr.argExprs.get(2).type.tag == TypeTags.NIL && !types.isBasicType(iExpr.expr.type)) {\n+                    dlog.error(iExpr.expr.pos, DiagnosticCode.INVALID_SORT_ARRAY_MEMBER_TYPE, iExpr.expr.type);\n+                }\n+            } else {\n+                BLangLambdaFunction func = (BLangLambdaFunction) iExpr.argExprs.get(2);\n+                BType returnType = func.function.type.getReturnType();\n+                if (!types.isBasicType(returnType)) {\n+                    dlog.error(iExpr.expr.pos, DiagnosticCode.INVALID_SORT_FUNC_RETURN_TYPE, returnType);\n+                }\n+            }\n+        }\n+    }", "originalCommit": "f6242477c6a3f424e14896da82d393f2393efb0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM5ODExOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r483398118", "bodyText": "In org.wso2.ballerinalang.compiler.semantics.analyzer.TypeChecker#checkInLangLib we do some langlib specific validations. Wondering if we should move this also there.", "author": "MaryamZi", "createdAt": "2020-09-04T05:40:15Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -5228,6 +5228,11 @@ private BType checkInvocationArgs(BLangInvocation iExpr, List<BType> paramTypes,\n             requiredParams.add(nonRestParam);\n         }\n \n+        // check argument types in arr:sort function\n+        if (iExpr.langLibInvocation && iExpr.name.value.equals(\"sort\")) {", "originalCommit": "f6242477c6a3f424e14896da82d393f2393efb0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7903eae523a001f7295dc45221c011ac96703fb0", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7903eae523a001f7295dc45221c011ac96703fb0", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into array-sort-func", "committedDate": "2020-09-04T13:37:36Z", "type": "commit"}, {"oid": "2443e4b262ebdace6d3ed06cb2b5efc3573f83b6", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2443e4b262ebdace6d3ed06cb2b5efc3573f83b6", "message": "Fix review suggestions", "committedDate": "2020-09-04T14:13:21Z", "type": "commit"}, {"oid": "855f834aa20e94b6a93c662e8a9dec63b4cca104", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/855f834aa20e94b6a93c662e8a9dec63b4cca104", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into array-sort-func", "committedDate": "2020-09-08T05:33:19Z", "type": "commit"}, {"oid": "8481a2bd849a79154b46e06d56d3557762ce64c5", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8481a2bd849a79154b46e06d56d3557762ce64c5", "message": "Improve array sort", "committedDate": "2020-09-08T06:01:00Z", "type": "commit"}, {"oid": "1cacfe176dd2f95f07d35b746f1f60dbb1f56e12", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1cacfe176dd2f95f07d35b746f1f60dbb1f56e12", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into array-sort-func", "committedDate": "2020-09-08T06:22:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDcwMTc3Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r484701773", "bodyText": "Isn't this invalid key function return type?", "author": "mohanvive", "createdAt": "2020-09-08T07:18:04Z", "path": "compiler/ballerina-lang/src/main/java/org/ballerinalang/util/diagnostic/DiagnosticCode.java", "diffHunk": "@@ -302,6 +302,8 @@\n     INVALID_LIST_INDEX_EXPR(\"invalid.list.index.expr\"),\n     INVALID_ARRAY_INDEX_EXPR(\"invalid.array.index.expr\"),\n     SEALED_ARRAY_TYPE_CAN_NOT_INFER_SIZE(\"sealed.array.type.can.not.infer.size\"),\n+    INVALID_SORT_FUNC_RETURN_TYPE(\"invalid.sort.func.return.type\"),", "originalCommit": "8481a2bd849a79154b46e06d56d3557762ce64c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDcwMzE5Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r484703193", "bodyText": "Don't we need any error message for this case and it needs to be the first condition to verify in the method.", "author": "mohanvive", "createdAt": "2020-09-08T07:20:47Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -5384,6 +5389,37 @@ private BType checkInvocationArgs(BLangInvocation iExpr, List<BType> paramTypes,\n         }\n     }\n \n+    private void checkArrayLibSortFuncArgs(BLangInvocation iExpr) {\n+        if (iExpr.argExprs.size() <= 2 && !types.isOrderedType(iExpr.expr.type)) {\n+            dlog.error(iExpr.expr.pos, DiagnosticCode.INVALID_SORT_ARRAY_MEMBER_TYPE, iExpr.expr.type);\n+        }\n+\n+        if (iExpr.argExprs.size() != 3) {\n+            return;", "originalCommit": "8481a2bd849a79154b46e06d56d3557762ce64c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc3MjI0MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r484772241", "bodyText": "iExpr.argExprs list can have 1 to a maximum of 3  members considering the scenarios given below\narr.sort(), arr.sort(direction), arr.sort(direction, key). Therefore this can not be taken as the first condition to be verified.\nWhen there are more than 3 members it'll be handled by the following \n  \n    \n      ballerina-lang/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java\n    \n    \n         Line 5299\n      in\n      8481a2b\n    \n    \n    \n    \n\n        \n          \n           dlog.error(iExpr.pos, DiagnosticCode.TOO_MANY_ARGS_FUNC_CALL, iExpr.name.value);", "author": "lasinicl", "createdAt": "2020-09-08T09:15:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDcwMzE5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDcwMzY0Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r484703646", "bodyText": "Please use proper names for arguments. (argThreee does not provide any context)", "author": "mohanvive", "createdAt": "2020-09-08T07:21:37Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -5384,6 +5389,37 @@ private BType checkInvocationArgs(BLangInvocation iExpr, List<BType> paramTypes,\n         }\n     }\n \n+    private void checkArrayLibSortFuncArgs(BLangInvocation iExpr) {\n+        if (iExpr.argExprs.size() <= 2 && !types.isOrderedType(iExpr.expr.type)) {\n+            dlog.error(iExpr.expr.pos, DiagnosticCode.INVALID_SORT_ARRAY_MEMBER_TYPE, iExpr.expr.type);\n+        }\n+\n+        if (iExpr.argExprs.size() != 3) {\n+            return;\n+        }\n+\n+        BLangExpression argThree = iExpr.argExprs.get(2);", "originalCommit": "8481a2bd849a79154b46e06d56d3557762ce64c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDcxMTMzNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r484711334", "bodyText": "Shouldn't it simply be a recursive call to isOrderedType() on elementType? For example, what happens if the array has more than two dimensions?", "author": "pubudu91", "createdAt": "2020-09-08T07:35:01Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -3467,30 +3467,44 @@ public BType resolveExprType(BType type) {\n         }\n     }\n \n-    /**\n-     * Check whether a order-key expression type is a basic type.\n-     *\n-     * @param type type of the order-key expression.\n-     * @return boolean whether the type is basic type or not.\n-     */\n-    public boolean isBasicType(BType type) {\n-        switch (type.tag) {\n-            case TypeTags.INT:\n+    private boolean isSimpleBasicType(int tag) {\n+        switch (tag) {\n             case TypeTags.BYTE:\n             case TypeTags.FLOAT:\n             case TypeTags.DECIMAL:\n-            case TypeTags.STRING:\n             case TypeTags.BOOLEAN:\n             case TypeTags.NIL:\n                 return true;\n+            default:\n+                return (TypeTags.isIntegerTypeTag(tag)) || (TypeTags.isStringTypeTag(tag));\n+        }\n+    }\n+\n+    /**\n+     * Check whether a type is an ordered type.\n+     *\n+     * @param type type.\n+     * @return boolean whether the type is an ordered type or not.\n+     */\n+    public boolean isOrderedType(BType type) {\n+        switch (type.tag) {\n             case TypeTags.UNION:\n-                if (((BUnionType) type).getMemberTypes().contains(symTable.nilType)) {\n-                    return true;\n-                } else {\n-                    return false;\n+                Set<BType> memberTypes = ((BUnionType) type).getMemberTypes();\n+                // can not sort (string?|int)/(string|int), can sort string?\n+                return memberTypes.size() <= 2 && memberTypes.contains(symTable.nilType);\n+            case TypeTags.ARRAY:\n+                BType elementType = ((BArrayType) type).eType;\n+                if (elementType.tag == TypeTags.ARRAY) {\n+                    elementType = ((BArrayType) elementType).eType;\n                 }\n+                if (elementType.tag == TypeTags.UNION) {\n+                    Set<BType> memTypes = ((BUnionType) elementType).getMemberTypes();\n+                    // can not sort (string?|int)[]/(string|int)[], can sort string?[]\n+                    return memTypes.size() <= 2 && memTypes.contains(symTable.nilType);\n+                }", "originalCommit": "8481a2bd849a79154b46e06d56d3557762ce64c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDcxMjA5Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r484712092", "bodyText": "What happens here if the union has a non-ordered type as a member type?", "author": "pubudu91", "createdAt": "2020-09-08T07:36:21Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -3467,30 +3467,44 @@ public BType resolveExprType(BType type) {\n         }\n     }\n \n-    /**\n-     * Check whether a order-key expression type is a basic type.\n-     *\n-     * @param type type of the order-key expression.\n-     * @return boolean whether the type is basic type or not.\n-     */\n-    public boolean isBasicType(BType type) {\n-        switch (type.tag) {\n-            case TypeTags.INT:\n+    private boolean isSimpleBasicType(int tag) {\n+        switch (tag) {\n             case TypeTags.BYTE:\n             case TypeTags.FLOAT:\n             case TypeTags.DECIMAL:\n-            case TypeTags.STRING:\n             case TypeTags.BOOLEAN:\n             case TypeTags.NIL:\n                 return true;\n+            default:\n+                return (TypeTags.isIntegerTypeTag(tag)) || (TypeTags.isStringTypeTag(tag));\n+        }\n+    }\n+\n+    /**\n+     * Check whether a type is an ordered type.\n+     *\n+     * @param type type.\n+     * @return boolean whether the type is an ordered type or not.\n+     */\n+    public boolean isOrderedType(BType type) {\n+        switch (type.tag) {\n             case TypeTags.UNION:\n-                if (((BUnionType) type).getMemberTypes().contains(symTable.nilType)) {\n-                    return true;\n-                } else {\n-                    return false;\n+                Set<BType> memberTypes = ((BUnionType) type).getMemberTypes();\n+                // can not sort (string?|int)/(string|int), can sort string?\n+                return memberTypes.size() <= 2 && memberTypes.contains(symTable.nilType);", "originalCommit": "8481a2bd849a79154b46e06d56d3557762ce64c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDcxMjcwNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r484712707", "bodyText": "Should be calling isOrderedType() recursively on the member types, in addition to the above checks right?", "author": "pubudu91", "createdAt": "2020-09-08T07:37:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDcxMjA5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDcyMDgzOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r484720838", "bodyText": "At this point, don't need the iExpr.langLibInvocation check here since at this point, we know for sure (Line# 2753) that this is a lang lib call.", "author": "pubudu91", "createdAt": "2020-09-08T07:51:56Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -2761,6 +2761,11 @@ private void checkInLangLib(BLangInvocation iExpr, BType varRefType) {\n         }\n \n         checkIllegalStorageSizeChangeMethodCall(iExpr, varRefType);\n+\n+        // check argument types in arr:sort function\n+        if (iExpr.langLibInvocation && iExpr.name.value.equals(\"sort\")) {", "originalCommit": "8481a2bd849a79154b46e06d56d3557762ce64c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "05beec628f686a94eeca165b415de0885514352f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/05beec628f686a94eeca165b415de0885514352f", "message": "Fix sort in http", "committedDate": "2020-09-08T09:01:53Z", "type": "commit"}, {"oid": "fe3596855969923da43d26c3662d17899c966f3c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fe3596855969923da43d26c3662d17899c966f3c", "message": "Fix review suggestions", "committedDate": "2020-09-08T09:02:37Z", "type": "commit"}, {"oid": "b0960a00392c7e1c41c054b832038dbf900e0d3a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b0960a00392c7e1c41c054b832038dbf900e0d3a", "message": "Fix review suggestions", "committedDate": "2020-09-08T10:21:15Z", "type": "commit"}, {"oid": "210648a091d744aa53e4c729fce5d79f0d5801d0", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/210648a091d744aa53e4c729fce5d79f0d5801d0", "message": "Fix failing tests", "committedDate": "2020-09-08T10:33:43Z", "type": "commit"}, {"oid": "6b7913235ed9de8d2679e6837fb55979520daeac", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6b7913235ed9de8d2679e6837fb55979520daeac", "message": "Fix tests with sort", "committedDate": "2020-09-08T11:24:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk3NDEwNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r484974104", "bodyText": "Put the constant value on the left side of equals to avoid possible NPEs", "author": "grainier", "createdAt": "2020-09-08T14:40:34Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -2761,6 +2761,11 @@ private void checkInLangLib(BLangInvocation iExpr, BType varRefType) {\n         }\n \n         checkIllegalStorageSizeChangeMethodCall(iExpr, varRefType);\n+\n+        // check argument types in arr:sort function\n+        if (iExpr.name.value.equals(\"sort\")) {", "originalCommit": "6b7913235ed9de8d2679e6837fb55979520daeac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk3ODM4MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r484978381", "bodyText": "What is this -999? And Why it's -999?", "author": "grainier", "createdAt": "2020-09-08T14:46:13Z", "path": "langlib/lang.array/src/main/java/org/ballerinalang/langlib/array/Sort.java", "diffHunk": "@@ -18,73 +18,230 @@\n \n package org.ballerinalang.langlib.array;\n \n+import org.ballerinalang.jvm.BallerinaErrors;\n import org.ballerinalang.jvm.scheduling.Strand;\n import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BFunctionType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BUnionType;\n+import org.ballerinalang.jvm.types.TypeTags;\n import org.ballerinalang.jvm.values.ArrayValue;\n-import org.ballerinalang.jvm.values.ArrayValueImpl;\n import org.ballerinalang.jvm.values.FPValue;\n import org.ballerinalang.model.types.TypeKind;\n import org.ballerinalang.natives.annotations.Argument;\n import org.ballerinalang.natives.annotations.BallerinaFunction;\n import org.ballerinalang.natives.annotations.ReturnType;\n \n+import java.math.BigDecimal;\n+import java.util.List;\n+import java.util.PrimitiveIterator;\n+\n import static org.ballerinalang.jvm.values.utils.ArrayUtils.checkIsArrayOnlyOperation;\n import static org.ballerinalang.util.BLangCompilerConstants.ARRAY_VERSION;\n \n /**\n- * Native implementation of lang.array:sort((any|error)[], function).\n+ * Native implementation of lang.array:sort((any|error)[], direction, function).\n  *\n  * @since 1.0\n  */\n @BallerinaFunction(\n         orgName = \"ballerina\", packageName = \"lang.array\", version = ARRAY_VERSION, functionName = \"sort\",\n-        args = {@Argument(name = \"arr\", type = TypeKind.ARRAY), @Argument(name = \"func\", type = TypeKind.FUNCTION)},\n+        args = {@Argument(name = \"arr\", type = TypeKind.ARRAY), @Argument(name = \"direction\", type = TypeKind.OBJECT),\n+                @Argument(name = \"func\", type = TypeKind.OBJECT)},\n         returnType = {@ReturnType(type = TypeKind.ARRAY)},\n         isPublic = true\n )\n public class Sort {\n \n-    public static ArrayValue sort(Strand strand, ArrayValue arr, FPValue<Object, Long> func) {\n+    public static ArrayValue sort(Strand strand, ArrayValue arr, Object direction, Object func) {\n         checkIsArrayOnlyOperation(arr.getType(), \"sort()\");\n-        ArrayValue aux = new ArrayValueImpl((BArrayType) arr.getType());\n-        mergesort(arr, aux, 0, arr.size() - 1, strand, func);\n+        FPValue<Object, Object> function = (FPValue<Object, Object>) func;\n+        BType elemType = ((BArrayType) arr.getType()).getElementType();\n+        boolean isAscending = true;\n+        if (direction.toString().equals(\"descending\")) {\n+            isAscending = false;\n+        }\n+\n+        Object[][] sortArr = new Object[arr.size()][2];\n+        Object[][] sortArrClone = new Object[arr.size()][2];\n+        if (function != null) {\n+            elemType = ((BFunctionType) function.getType()).retType;\n+            for (int i = 0; i < arr.size(); i++) {\n+                sortArr[i][0] = function.call(new Object[]{strand, arr.get(i), true});\n+                sortArr[i][1] = arr.get(i);\n+            }\n+        } else {\n+            for (int i = 0; i < arr.size(); i++) {\n+                sortArr[i][0] = sortArr[i][1] = arr.get(i);\n+            }\n+        }\n+\n+        if (elemType.getTag() == TypeTags.UNION_TAG) {\n+            elemType = getMemberType((BUnionType) elemType);\n+        }\n+        if (elemType.getTag() == TypeTags.ARRAY_TAG) {\n+            BType type = ((BArrayType) elemType).getElementType();\n+            if (type.getTag() == TypeTags.UNION_TAG) {\n+                BType memberType = getMemberType((BUnionType) type);\n+                elemType = new BArrayType(memberType);\n+            }\n+        }\n+\n+        mergesort(sortArr, sortArrClone, 0, sortArr.length - 1, isAscending, elemType);\n+\n+        for (int k = 0; k < sortArr.length; k++) {\n+            arr.add(k, sortArr[k][1]);\n+        }\n+\n         return arr;\n     }\n \n+    private static BType getMemberType(BUnionType unionType) {\n+        List<BType> memberTypes = unionType.getMemberTypes();\n+        for (BType type : memberTypes) {\n+            if (type.getTag() != TypeTags.NULL_TAG) {\n+                return type;\n+            }\n+        }\n+        return unionType;\n+    }\n+\n     // Adapted from https://algs4.cs.princeton.edu/22mergesort/Merge.java.html\n-    private static void mergesort(ArrayValue input, ArrayValue aux, int lo, int hi, Strand strand,\n-                                  FPValue<Object, Long> comparator) {\n+    private static void mergesort(Object[][] input, Object[][] aux, int lo, int hi, boolean isAscending, BType type) {\n         if (hi <= lo) {\n             return;\n         }\n \n         int mid = lo + (hi - lo) / 2;\n \n-        mergesort(input, aux, lo, mid, strand, comparator);\n-        mergesort(input, aux, mid + 1, hi, strand, comparator);\n+        mergesort(input, aux, lo, mid, isAscending, type);\n+        mergesort(input, aux, mid + 1, hi, isAscending, type);\n \n-        merge(input, aux, lo, mid, hi, strand, comparator);\n+        merge(input, aux, lo, mid, hi, isAscending, type);\n     }\n \n-    private static void merge(ArrayValue input, ArrayValue aux, int lo, int mid, int hi, Strand strand,\n-                              FPValue<Object, Long> comparator) {\n-        int elemTypeTag = input.getElementType().getTag();\n-\n-        for (int i = lo; i <= hi; i++) {\n-            aux.add(i, input.get(i));\n+    private static void merge(Object[][] input, Object[][] aux, int lo, int mid, int hi, boolean isAscending,\n+                              BType type) {\n+        if (hi + 1 - lo >= 0) {\n+            System.arraycopy(input, lo, aux, lo, hi + 1 - lo);\n         }\n \n         for (int i = lo, j = mid + 1, k = lo; k <= hi; k++) {\n+            int index;\n             if (i > mid) {\n-                input.add(k, aux.get(j++));\n+                index = j++;\n             } else if (j > hi) {\n-                input.add(k, aux.get(i++));\n-            } else if (comparator.call(new Object[]{strand, aux.get(j), true, aux.get(i), true}) < 0) {\n-                input.add(k, aux.get(j++));\n+                index = i++;\n+            } else if (isAscending && sortFunc(aux[j][0], aux[i][0], type, true) < 0) {\n+                index = j++;\n+            } else if (!isAscending && sortFunc(aux[i][0], aux[j][0], type, false) < 0) {\n+                index = j++;\n             } else {\n-                input.add(k, aux.get(i++));\n+                index = i++;\n             }\n+            input[k] = aux[index];\n         }\n     }\n \n+    private static int sortFunc(Object value1, Object value2, BType type, boolean isAscending) {\n+        int c = -999;", "originalCommit": "6b7913235ed9de8d2679e6837fb55979520daeac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "62d470fa9d5069bfa89d83bc91d049141beb1712", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/62d470fa9d5069bfa89d83bc91d049141beb1712", "message": "Fix review suggestions", "committedDate": "2020-09-08T15:35:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE1OTI5NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r485159294", "bodyText": "This error message needs to conform to the same format we follow for other lang lib errors. You can check the other places in the lang lib where panics are created for reference. Also, IIRC, we don't start the detail with a capital letter. @MaryamZi", "author": "pubudu91", "createdAt": "2020-09-08T19:51:38Z", "path": "langlib/lang.array/src/main/java/org/ballerinalang/langlib/array/Sort.java", "diffHunk": "@@ -18,73 +18,229 @@\n \n package org.ballerinalang.langlib.array;\n \n+import org.ballerinalang.jvm.BallerinaErrors;\n import org.ballerinalang.jvm.scheduling.Strand;\n import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BFunctionType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BUnionType;\n+import org.ballerinalang.jvm.types.TypeTags;\n import org.ballerinalang.jvm.values.ArrayValue;\n-import org.ballerinalang.jvm.values.ArrayValueImpl;\n import org.ballerinalang.jvm.values.FPValue;\n import org.ballerinalang.model.types.TypeKind;\n import org.ballerinalang.natives.annotations.Argument;\n import org.ballerinalang.natives.annotations.BallerinaFunction;\n import org.ballerinalang.natives.annotations.ReturnType;\n \n+import java.math.BigDecimal;\n+import java.util.List;\n+import java.util.PrimitiveIterator;\n+\n import static org.ballerinalang.jvm.values.utils.ArrayUtils.checkIsArrayOnlyOperation;\n import static org.ballerinalang.util.BLangCompilerConstants.ARRAY_VERSION;\n \n /**\n- * Native implementation of lang.array:sort((any|error)[], function).\n+ * Native implementation of lang.array:sort((any|error)[], direction, function).\n  *\n  * @since 1.0\n  */\n @BallerinaFunction(\n         orgName = \"ballerina\", packageName = \"lang.array\", version = ARRAY_VERSION, functionName = \"sort\",\n-        args = {@Argument(name = \"arr\", type = TypeKind.ARRAY), @Argument(name = \"func\", type = TypeKind.FUNCTION)},\n+        args = {@Argument(name = \"arr\", type = TypeKind.ARRAY), @Argument(name = \"direction\", type = TypeKind.OBJECT),\n+                @Argument(name = \"func\", type = TypeKind.OBJECT)},\n         returnType = {@ReturnType(type = TypeKind.ARRAY)},\n         isPublic = true\n )\n public class Sort {\n \n-    public static ArrayValue sort(Strand strand, ArrayValue arr, FPValue<Object, Long> func) {\n+    public static ArrayValue sort(Strand strand, ArrayValue arr, Object direction, Object func) {\n         checkIsArrayOnlyOperation(arr.getType(), \"sort()\");\n-        ArrayValue aux = new ArrayValueImpl((BArrayType) arr.getType());\n-        mergesort(arr, aux, 0, arr.size() - 1, strand, func);\n+        FPValue<Object, Object> function = (FPValue<Object, Object>) func;\n+        BType elemType = ((BArrayType) arr.getType()).getElementType();\n+        boolean isAscending = true;\n+        if (direction.toString().equals(\"descending\")) {\n+            isAscending = false;\n+        }\n+\n+        Object[][] sortArr = new Object[arr.size()][2];\n+        Object[][] sortArrClone = new Object[arr.size()][2];\n+        if (function != null) {\n+            elemType = ((BFunctionType) function.getType()).retType;\n+            for (int i = 0; i < arr.size(); i++) {\n+                sortArr[i][0] = function.call(new Object[]{strand, arr.get(i), true});\n+                sortArr[i][1] = arr.get(i);\n+            }\n+        } else {\n+            for (int i = 0; i < arr.size(); i++) {\n+                sortArr[i][0] = sortArr[i][1] = arr.get(i);\n+            }\n+        }\n+\n+        if (elemType.getTag() == TypeTags.UNION_TAG) {\n+            elemType = getMemberType((BUnionType) elemType);\n+        }\n+        if (elemType.getTag() == TypeTags.ARRAY_TAG) {\n+            BType type = ((BArrayType) elemType).getElementType();\n+            if (type.getTag() == TypeTags.UNION_TAG) {\n+                BType memberType = getMemberType((BUnionType) type);\n+                elemType = new BArrayType(memberType);\n+            }\n+        }\n+\n+        mergesort(sortArr, sortArrClone, 0, sortArr.length - 1, isAscending, elemType);\n+\n+        for (int k = 0; k < sortArr.length; k++) {\n+            arr.add(k, sortArr[k][1]);\n+        }\n+\n         return arr;\n     }\n \n+    private static BType getMemberType(BUnionType unionType) {\n+        List<BType> memberTypes = unionType.getMemberTypes();\n+        for (BType type : memberTypes) {\n+            if (type.getTag() != TypeTags.NULL_TAG) {\n+                return type;\n+            }\n+        }\n+        return unionType;\n+    }\n+\n     // Adapted from https://algs4.cs.princeton.edu/22mergesort/Merge.java.html\n-    private static void mergesort(ArrayValue input, ArrayValue aux, int lo, int hi, Strand strand,\n-                                  FPValue<Object, Long> comparator) {\n+    private static void mergesort(Object[][] input, Object[][] aux, int lo, int hi, boolean isAscending, BType type) {\n         if (hi <= lo) {\n             return;\n         }\n \n         int mid = lo + (hi - lo) / 2;\n \n-        mergesort(input, aux, lo, mid, strand, comparator);\n-        mergesort(input, aux, mid + 1, hi, strand, comparator);\n+        mergesort(input, aux, lo, mid, isAscending, type);\n+        mergesort(input, aux, mid + 1, hi, isAscending, type);\n \n-        merge(input, aux, lo, mid, hi, strand, comparator);\n+        merge(input, aux, lo, mid, hi, isAscending, type);\n     }\n \n-    private static void merge(ArrayValue input, ArrayValue aux, int lo, int mid, int hi, Strand strand,\n-                              FPValue<Object, Long> comparator) {\n-        int elemTypeTag = input.getElementType().getTag();\n-\n-        for (int i = lo; i <= hi; i++) {\n-            aux.add(i, input.get(i));\n+    private static void merge(Object[][] input, Object[][] aux, int lo, int mid, int hi, boolean isAscending,\n+                              BType type) {\n+        if (hi + 1 - lo >= 0) {\n+            System.arraycopy(input, lo, aux, lo, hi + 1 - lo);\n         }\n \n         for (int i = lo, j = mid + 1, k = lo; k <= hi; k++) {\n+            int index;\n             if (i > mid) {\n-                input.add(k, aux.get(j++));\n+                index = j++;\n             } else if (j > hi) {\n-                input.add(k, aux.get(i++));\n-            } else if (comparator.call(new Object[]{strand, aux.get(j), true, aux.get(i), true}) < 0) {\n-                input.add(k, aux.get(j++));\n+                index = i++;\n+            } else if (isAscending && sortFunc(aux[j][0], aux[i][0], type, true) < 0) {\n+                index = j++;\n+            } else if (!isAscending && sortFunc(aux[i][0], aux[j][0], type, false) < 0) {\n+                index = j++;\n             } else {\n-                input.add(k, aux.get(i++));\n+                index = i++;\n             }\n+            input[k] = aux[index];\n         }\n     }\n \n+    private static int sortFunc(Object value1, Object value2, BType type, boolean isAscending) {\n+        // () should come last irrespective of the sort direction.\n+        if (value1 == null) {\n+            if (value2 == null) {\n+                return 0;\n+            }\n+            if (isAscending) {\n+                return 1;\n+            }\n+            return -1;\n+        }\n+        if (value2 == null) {\n+            if (isAscending) {\n+                return -1;\n+            }\n+            return 1;\n+        }\n+        if (TypeTags.isIntegerTypeTag(type.getTag())) {\n+            return Long.compare((long) value1, (long) value2);\n+        } else if (type.getTag() == TypeTags.FLOAT_TAG) {\n+            // NaN should be placed last or one before the last when () is present irrespective of the sort direction.\n+            if (Double.isNaN((double) value1)) {\n+                if (Double.isNaN((double) value2)) {\n+                    return 0;\n+                }\n+                if (isAscending) {\n+                    return 1;\n+                }\n+                return -1;\n+            }\n+            if (Double.isNaN((double) value2)) {\n+                if (isAscending) {\n+                    return -1;\n+                }\n+                return 1;\n+            }\n+            // -0.0 = +0.0\n+            if ((double) value1 == 0 && (double) value2 == 0) {\n+                return 0;\n+            }\n+            return Double.compare((double) value1, (double) value2);\n+        } else if (type.getTag() == TypeTags.DECIMAL_TAG) {\n+            return new BigDecimal(value1.toString()).compareTo(new BigDecimal(value2.toString()));\n+        } else if (type.getTag() == TypeTags.BOOLEAN_TAG) {\n+            return Boolean.compare((boolean) value1, (boolean) value2);\n+        } else if (TypeTags.isStringTypeTag(type.getTag())) {\n+            return codePointCompare(value1.toString(), value2.toString());\n+        } else if (type.getTag() == TypeTags.BYTE_TAG) {\n+            return Integer.compare((int) value1, (int) value2);\n+        } else if (type.getTag() == TypeTags.ARRAY_TAG) {\n+            int lengthVal1 = ((ArrayValue) value1).size();\n+            int lengthVal2 = ((ArrayValue) value2).size();\n+            if (lengthVal1 == 0) {\n+                if (lengthVal2 == 0) {\n+                    return 0;\n+                }\n+                return -1;\n+            }\n+            if (lengthVal2 == 0) {\n+                return 1;\n+            }\n+            int len = Math.min(lengthVal1, lengthVal2);\n+            int c = 0;\n+            for (int i = 0; i < len; i++) {\n+                c = sortFunc(((ArrayValue) value1).get(i), ((ArrayValue) value2).get(i),\n+                        ((BArrayType) type).getElementType(), isAscending);\n+                if (c != 0) {\n+                    break;\n+                } else {\n+                    if (i == len - 1 && lengthVal1 < lengthVal2) {\n+                        return -1;\n+                    }\n+                }\n+            }\n+            return c;\n+        }\n+        throw BallerinaErrors.createError(\"Invalid type to sort\", \"Expected an ordered type, but found type: \"", "originalCommit": "62d470fa9d5069bfa89d83bc91d049141beb1712", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MDU1NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r485170554", "bodyText": "Shall we add a couple of tests for the array:sort() style of usage as well? Both positive and negative.", "author": "pubudu91", "createdAt": "2020-09-08T20:14:05Z", "path": "langlib/langlib-test/src/test/java/org/ballerinalang/langlib/test/LangLibArrayTest.java", "diffHunk": "@@ -419,66 +382,153 @@ public void callingLengthModificationFunctionsOnFixedLengthLists() {\n         int errorIndex = 0;\n         BAssertUtil.validateError(negativeResult, errorIndex++, \"cannot call 'push' on fixed length list(s) of type \" +\n                                           \"'int[1]'\",\n-                                  19, 22);\n+                                  20, 22);\n         BAssertUtil.validateError(negativeResult, errorIndex++, \"cannot call 'push' on fixed length list(s) of type \" +\n                                           \"'[int,int]'\",\n-                                  24, 22);\n+                                  25, 22);\n         BAssertUtil.validateError(negativeResult, errorIndex++, \"cannot call 'pop' on fixed length list(s) of type \" +\n                                           \"'int[1]'\",\n-                                  29, 35);\n+                                  30, 35);\n         BAssertUtil.validateError(negativeResult, errorIndex++, \"cannot call 'pop' on fixed length list(s) of type \" +\n                                           \"'[int,int]'\",\n-                                  34, 35);\n+                                  35, 35);\n         BAssertUtil.validateError(negativeResult, errorIndex++, \"cannot call 'shift' on fixed length list(s) of type \" +\n                                           \"'int[1]'\",\n-                                  45, 30);\n+                                  46, 30);\n         BAssertUtil.validateError(negativeResult, errorIndex++, \"cannot call 'unshift' on fixed length list(s) of \" +\n                                           \"type 'int[1]'\",\n-                                  50, 22);\n+                                  51, 22);\n         BAssertUtil.validateError(negativeResult, errorIndex++, \"cannot call 'shift' on fixed length list(s) of type \" +\n                                           \"'[int,int]'\",\n-                                  55, 35);\n+                                  56, 35);\n         BAssertUtil.validateError(negativeResult, errorIndex++,\n                                   \"cannot call 'unshift' on fixed length list(s) of type '[int,int]'\",\n-                                  60, 22);\n+                                  61, 22);\n         BAssertUtil.validateError(negativeResult, errorIndex++, \"cannot call 'push' on fixed length list(s) of type \" +\n                                           \"'int[2]'\",\n-                                  66, 22);\n+                                  67, 22);\n         BAssertUtil.validateError(negativeResult, errorIndex++, \"cannot call 'pop' on fixed length list(s) of type \" +\n                                           \"'int[2]'\",\n-                                  67, 30);\n+                                  68, 30);\n         BAssertUtil.validateError(negativeResult, errorIndex++, \"cannot call 'shift' on fixed length list(s) of type \" +\n                                           \"'int[2]'\",\n-                                  68, 26);\n+                                  69, 26);\n         BAssertUtil.validateError(negativeResult, errorIndex++, \"cannot call 'unshift' on fixed length list(s) of \" +\n                                           \"type 'int[2]'\",\n-                                  69, 22);\n+                                  70, 22);\n         BAssertUtil.validateError(negativeResult, errorIndex++,\n                                   \"cannot call 'push' on fixed length list(s) of type '(int[1]|float[1])'\",\n-                                  74, 22);\n+                                  75, 22);\n         BAssertUtil.validateError(negativeResult, errorIndex++,\n                                   \"cannot call 'push' on fixed length list(s) of type '([int,int][1]|[float,\" +\n                                           \"float][1])'\",\n-                                  79, 22);\n+                                  80, 22);\n         BAssertUtil.validateError(negativeResult, errorIndex++,\n                                   \"cannot call 'shift' on tuple(s) of type '[int,string...]': cannot violate inherent\" +\n                                           \" type\",\n-                                  84, 24);\n+                                  85, 24);\n         BAssertUtil.validateError(negativeResult, errorIndex++,\n                                   \"cannot call 'shift' on tuple(s) of type '[int,string,int...]': cannot violate \" +\n                                           \"inherent type\",\n-                                  89, 24);\n+                                  90, 24);\n         BAssertUtil.validateError(negativeResult, errorIndex++,\n                                   \"cannot call 'push' on fixed length list(s) of type '([int,int]|[float,float])'\",\n-                                  100, 22);\n+                                  101, 22);\n         BAssertUtil.validateError(negativeResult, errorIndex++,\n                                   \"cannot call 'shift' on fixed length list(s) of type '[string,int]'\",\n-                                  118, 24);\n+                                  119, 24);\n+        BAssertUtil.validateError(negativeResult, errorIndex++,\n+                \"incompatible types: expected '(descending|ascending)', found 'function (int) returns (int)'\",\n+                126, 32);\n+        BAssertUtil.validateError(negativeResult, errorIndex++,\n+                \"incompatible types: expected '(descending|ascending)', found 'function (int) returns (int)'\",\n+                130, 33);\n+        BAssertUtil.validateError(negativeResult, errorIndex++,\n+                \"incompatible types: expected 'function ((any|error)) returns \" +\n+                        \"((boolean|int|float|decimal|string|(boolean|int|float|decimal|string)?[])?)?', \" +\n+                        \"found 'string'\", 132, 8);\n+        BAssertUtil.validateError(negativeResult, errorIndex++,\n+                \"invalid member type of the array to sort: type '(string|int)[]' is not an ordered type\",\n+                136, 33);\n+        BAssertUtil.validateError(negativeResult, errorIndex++,\n+                \"invalid member type of the array to sort: type '(string|int)[]' is not an ordered type\",\n+                138, 33);\n+        BAssertUtil.validateError(negativeResult, errorIndex++,\n+                \"invalid member type of the array to sort: type '(string|int)[]' is not an ordered type\",\n+                140, 33);\n+        BAssertUtil.validateError(negativeResult, errorIndex++,\n+                \"invalid array sort key function return type: type '(string|int)' is not an ordered type\",\n+                142, 33);\n+        BAssertUtil.validateError(negativeResult, errorIndex++,\n+                \"invalid member type of the array to sort: type 'map<string>?[]' is not an ordered type\",\n+                148, 35);\n+        BAssertUtil.validateError(negativeResult, errorIndex++,\n+                \"incompatible types: expected 'function ((any|error)) returns ((boolean|int|float|decimal|string|\" +\n+                        \"(boolean|int|float|decimal|string)?[])?)?', found 'function (map<string>?) \" +\n+                        \"returns (map<string>?)'\",\n+                150, 62);\n+        BAssertUtil.validateError(negativeResult, errorIndex++,\n+                \"too many arguments in call to 'sort()'\", 154, 24);\n         Assert.assertEquals(negativeResult.getErrorCount(), errorIndex);\n     }\n \n     @Test\n     public void testShiftOperation() {\n         BRunUtil.invoke(compileResult, \"testShiftOperation\");\n     }\n+\n+    @Test\n+    public void testSort1() {\n+        BRunUtil.invoke(compileResult, \"testSort1\");\n+    }\n+\n+    @Test\n+    public void testSort2() {\n+        BRunUtil.invoke(compileResult, \"testSort2\");\n+    }\n+\n+    @Test\n+    public void testSort3() {\n+        BValue[] returns = BRunUtil.invoke(compileResult, \"testSort3\");\n+\n+        assertEquals(returns[0].getType().getTag(), TypeTags.ARRAY_TAG);\n+        BValueArray arr = (BValueArray) returns[0];\n+\n+        assertEquals(arr.elementType.getTag(), TypeTags.INT_TAG);\n+        assertEquals(arr.size(), 100);\n+\n+        for (int i = 1; i < arr.size(); i++) {\n+            assertTrue(arr.getInt(i) < arr.getInt(i - 1));\n+        }\n+    }\n+\n+    @Test\n+    public void testSort4() {\n+        BRunUtil.invoke(compileResult, \"testSort4\");\n+    }\n+\n+    @Test\n+    public void testSort5() {\n+        BRunUtil.invoke(compileResult, \"testSort5\");\n+    }\n+\n+    @Test\n+    public void testSort6() {\n+        BRunUtil.invoke(compileResult, \"testSort6\");\n+    }\n+\n+    @Test\n+    public void testSort7() {\n+        BRunUtil.invoke(compileResult, \"testSort7\");\n+    }\n+\n+    @Test\n+    public void testSort8() {\n+        BRunUtil.invoke(compileResult, \"testSort8\");\n+    }\n+\n+    @Test\n+    public void testSort9() {\n+        BRunUtil.invoke(compileResult, \"testSort9\");\n+    }", "originalCommit": "62d470fa9d5069bfa89d83bc91d049141beb1712", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MTU1Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r485171557", "bodyText": "And what about arrays of finite types?", "author": "pubudu91", "createdAt": "2020-09-08T20:15:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MDU1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTMwNTk5NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r485305995", "bodyText": "Shall we add a couple of tests for the array:sort() style of usage as well? Both positive and negative.\n\nHave already added for both.\nSome positive cases have been added in\n#L701\n#L793\n#L853\nSome negative cases have been added in\n#[L136]\n#[L148]", "author": "lasinicl", "createdAt": "2020-09-09T02:50:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MDU1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM1MTY2Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r485351667", "bodyText": "No, I meant using it as a normal function. For example,\nint[] sorted = array:sort(arr);", "author": "pubudu91", "createdAt": "2020-09-09T05:44:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MDU1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MjUzNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r485172537", "bodyText": "For what scenarios would keyFunctionType be null here?", "author": "pubudu91", "createdAt": "2020-09-08T20:17:57Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -5384,6 +5390,37 @@ private BType checkInvocationArgs(BLangInvocation iExpr, List<BType> paramTypes,\n         }\n     }\n \n+    private void checkArrayLibSortFuncArgs(BLangInvocation iExpr) {\n+        if (iExpr.argExprs.size() <= 2 && !types.isOrderedType(iExpr.expr.type)) {\n+            dlog.error(iExpr.expr.pos, DiagnosticCode.INVALID_SORT_ARRAY_MEMBER_TYPE, iExpr.expr.type);\n+        }\n+\n+        if (iExpr.argExprs.size() != 3) {\n+            return;\n+        }\n+\n+        BLangExpression keyFunction = iExpr.argExprs.get(2);\n+        BType keyFunctionType = keyFunction.type;\n+        if (keyFunctionType != null) {", "originalCommit": "62d470fa9d5069bfa89d83bc91d049141beb1712", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTMwOTAzMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r485309032", "bodyText": "seems it's an unnecessary check. will remove it :)", "author": "lasinicl", "createdAt": "2020-09-09T03:02:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MjUzNw=="}], "type": "inlineReview"}, {"oid": "f1416eb0f110589cdffa66156ab4f381c0ffeb6b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f1416eb0f110589cdffa66156ab4f381c0ffeb6b", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into array-sort-func", "committedDate": "2020-09-09T02:37:54Z", "type": "commit"}, {"oid": "1f6f38fcf679fb780b4176cd8f6d7a6dfedab9aa", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1f6f38fcf679fb780b4176cd8f6d7a6dfedab9aa", "message": "Fix review suggestions", "committedDate": "2020-09-09T04:51:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM1MzU0OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25604#discussion_r485353548", "bodyText": "Shall we just simply say but found '\" + type.toString() + \"'\"?", "author": "pubudu91", "createdAt": "2020-09-09T05:50:20Z", "path": "langlib/lang.array/src/main/java/org/ballerinalang/langlib/array/Sort.java", "diffHunk": "@@ -219,8 +222,8 @@ private static int sortFunc(Object value1, Object value2, BType type, boolean is\n             }\n             return c;\n         }\n-        throw BallerinaErrors.createError(\"Invalid type to sort\", \"Expected an ordered type, but found type: \"\n-                + type.toString());\n+        throw BallerinaErrors.createError(getModulePrefixedReason(ARRAY_LANG_LIB, INVALID_TYPE_TO_SORT),\n+                \"expected an ordered type, but found type: '\" + type.toString() + \"'\");", "originalCommit": "1f6f38fcf679fb780b4176cd8f6d7a6dfedab9aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4dda78b72b814f75fffb77fbf713d65f272323f0", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4dda78b72b814f75fffb77fbf713d65f272323f0", "message": "Fix review suggestions", "committedDate": "2020-09-09T08:06:58Z", "type": "commit"}]}