{"pr_number": 25023, "pr_title": "Port mocking feature to 1.2.x branch", "pr_createdAt": "2020-07-29T19:31:08Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/25023", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcyMzUyNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25023#discussion_r462723525", "bodyText": "We can remove this commented lines.", "author": "azinneera", "createdAt": "2020-07-30T04:12:16Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/MockDesugar.java", "diffHunk": "@@ -0,0 +1,459 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.desugar;\n+\n+\n+import org.ballerinalang.model.TreeBuilder;\n+import org.ballerinalang.model.tree.IdentifierNode;\n+import org.wso2.ballerinalang.compiler.semantics.analyzer.SymbolResolver;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolTable;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BInvokableSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BVarSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BInvokableType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.tree.BLangFunction;\n+import org.wso2.ballerinalang.compiler.tree.BLangFunctionBody;\n+import org.wso2.ballerinalang.compiler.tree.BLangIdentifier;\n+import org.wso2.ballerinalang.compiler.tree.BLangImportPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangSimpleVariable;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangExpression;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangFieldBasedAccess;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangInvocation;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangListConstructorExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangSimpleVarRef;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTypeConversionExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangVariableReference;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangAssignment;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangReturn;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangStatement;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangType;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangValueType;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.FieldKind;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Class to generate Mock Functions.\n+ *\n+ * @since 2.0.0\n+ */\n+public class MockDesugar {\n+\n+    private static final CompilerContext.Key<MockDesugar> MOCK_DESUGAR_KEY = new CompilerContext.Key<>();\n+    private static final String MOCK_ANNOTATION_DELIMITER = \"#\";\n+    private final SymbolTable symTable;\n+    private final SymbolResolver symResolver;\n+    private BLangPackage bLangPackage;\n+    private BLangFunction originalFunction;\n+    private BInvokableSymbol importFunction;\n+    private String mockFnObjectName;\n+\n+    private MockDesugar(CompilerContext context) {\n+        context.put(MOCK_DESUGAR_KEY, this);\n+        this.symTable = SymbolTable.getInstance(context);\n+        this.symResolver = SymbolResolver.getInstance(context);\n+    }\n+\n+    public static MockDesugar getInstance(CompilerContext context) {\n+        MockDesugar desugar = context.get(MOCK_DESUGAR_KEY);\n+        if (desugar == null) {\n+            desugar = new MockDesugar(context);\n+        }\n+        return desugar;\n+    }\n+\n+    private static IdentifierNode createIdentifier(String value) {\n+        IdentifierNode node = TreeBuilder.createIdentifierNode();\n+        if (value != null) {\n+            node.setValue(value);\n+        }\n+        return node;\n+    }\n+\n+    public void generateMockFunctions(BLangPackage pkgNode) {\n+        // Set the BLangPackage\n+        this.bLangPackage = pkgNode;\n+\n+        // Get the Mock Function map from the pkgNode\n+        Map<String, String> mockFunctionMap = pkgNode.getTestablePkg().getMockFunctionNamesMap();\n+\n+        // Get the set of functions to generate\n+        Set<String> mockFunctionSet = mockFunctionMap.keySet();\n+\n+        for (String function : mockFunctionSet) {\n+            if (!function.contains(\"~\")) {\n+                pkgNode.getTestablePkg().functions.add(generateMockFunction(function));\n+            }\n+        }\n+    }\n+\n+    private BLangFunction generateMockFunction(String functionName) {\n+        // Set the current mock object\n+        this.mockFnObjectName = this.bLangPackage.getTestablePkg().getMockFunctionNamesMap().get(functionName);\n+\n+        // Reset both import and original functions\n+        this.importFunction = null;\n+        this.originalFunction = null;\n+\n+        // Function name is going to be 'ballerina/math:1.0.0 # absInt'\n+        String currentPackageId = this.bLangPackage.packageID.toString();\n+\n+\n+        // We need to identify if the function is part of the current package or imported package\n+        if (functionName.contains(currentPackageId)) {\n+            // Simply extract the name only and set it to function name\n+            functionName = functionName.substring(functionName.indexOf(MOCK_ANNOTATION_DELIMITER) + 1);\n+            this.originalFunction = getOriginalFunction(functionName);\n+        } else {\n+            // Extract the name and the package details\n+            String packageName = functionName.contains(\":\") ?\n+                    functionName.substring(functionName.indexOf('/') + 1, functionName.indexOf(':')) :\n+                    functionName.substring(functionName.indexOf('/') + 1,\n+                                           functionName.indexOf(MOCK_ANNOTATION_DELIMITER));\n+            functionName = functionName.substring(functionName.indexOf(MOCK_ANNOTATION_DELIMITER) + 1);\n+            this.importFunction = getImportFunction(functionName, packageName);\n+        }\n+\n+        // Set the function name to $MOCK_<functionName>\n+        functionName = \"$MOCK_\" + functionName;\n+\n+        // Create the Base function with the name\n+        BLangFunction generatedMock = ASTBuilderUtil.createFunction(bLangPackage.pos, functionName);\n+\n+        if (this.originalFunction != null || this.importFunction != null) {\n+            generatedMock.requiredParams = generateRequiredParams();        // Required Params\n+            generatedMock.restParam = generateRestParam();                  // Rest Param\n+            generatedMock.returnTypeNode = generateReturnTypeNode();        // Return Type Node\n+            generatedMock.body = generateBody();                            // Body\n+            generatedMock.type = generateSymbolInvokableType();             // Invokable Type\n+            generatedMock.symbol = generateSymbol(functionName);            // Invokable Symbol\n+        } else {\n+            throw new IllegalStateException(\"Mock Function and Function to Mock cannot be null\");\n+        }\n+\n+        return generatedMock;\n+    }\n+\n+    private BLangFunction getOriginalFunction(String functionName) {\n+        List<BLangFunction> functionList = bLangPackage.getFunctions();\n+        for (BLangFunction function : functionList) {\n+            if (function.getName().toString().equals(functionName)) {\n+                return function;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private BInvokableSymbol getImportFunction(String functionName, String packageName) {\n+        BInvokableSymbol bInvokableSymbol =\n+                getInvokableSymbol(functionName, packageName, this.bLangPackage.getImports());\n+\n+        if (bInvokableSymbol == null) {\n+            bInvokableSymbol =\n+                    getInvokableSymbol(functionName, packageName, this.bLangPackage.getTestablePkg().getImports());\n+        }\n+\n+        return bInvokableSymbol;\n+    }\n+\n+    private BInvokableSymbol getInvokableSymbol(String functionName,\n+                                                String packageName,\n+                                                List<BLangImportPackage> importList) {\n+        // Loop through each BLangImportPackage\n+        for (BLangImportPackage importPkg : importList) {\n+            // If the import package name matches\n+            if (importPkg.alias.getValue().equals(packageName)) {\n+                // return the function name defined in the package entry map\n+                return (BInvokableSymbol) importPkg.symbol.scope.entries.get(new Name(functionName)).symbol;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    private List<BLangSimpleVariable> generateRequiredParams() {\n+        List<BLangSimpleVariable> requiredParams;\n+\n+        if (this.originalFunction == null) {\n+            requiredParams = generateImportRequiredParams();\n+        } else {\n+            requiredParams = this.originalFunction.requiredParams;\n+        }\n+\n+        return requiredParams;\n+    }\n+\n+    private List<BLangSimpleVariable> generateImportRequiredParams() {\n+        List<BLangSimpleVariable> bLangSimpleVariables = new ArrayList<>();\n+\n+        // Iterate through the params and generate the BLangSimpleVariable\n+        for (BVarSymbol bVarSymbol : this.importFunction.params) {\n+            BLangSimpleVariable bLangSimpleVariable =\n+                    ASTBuilderUtil.createVariable(bLangPackage.pos, bVarSymbol.name.getValue(),\n+                                                  bVarSymbol.type, null, bVarSymbol);\n+            bLangSimpleVariables.add(bLangSimpleVariable);\n+        }\n+\n+\n+        return bLangSimpleVariables;\n+    }\n+\n+    private BLangSimpleVariable generateRestParam() {\n+        BLangSimpleVariable bLangSimpleVariable = null;\n+\n+        if (this.importFunction != null) {\n+            BVarSymbol restParam = this.importFunction.restParam;\n+\n+            if (this.importFunction.restParam != null) {\n+                bLangSimpleVariable = ASTBuilderUtil.createVariable(bLangPackage.pos, restParam.name.getValue(),\n+                                                                    restParam.type, null, restParam);\n+                bLangSimpleVariable.typeNode = ASTBuilderUtil.createTypeNode(restParam.type);\n+            }\n+        }\n+\n+        return bLangSimpleVariable;\n+    }\n+\n+    private BLangType generateReturnTypeNode() {\n+        BLangType returnTypeNode;\n+\n+        if (this.originalFunction == null) {\n+            returnTypeNode = generateImportReturnTypeNode();\n+        } else {\n+            returnTypeNode = this.originalFunction.returnTypeNode;\n+        }\n+\n+        return returnTypeNode;\n+    }\n+\n+    private BLangType generateImportReturnTypeNode() {\n+        BLangValueType typeNode = (BLangValueType) TreeBuilder.createValueTypeNode();\n+        typeNode.pos = this.bLangPackage.pos;\n+        typeNode.typeKind = this.importFunction.retType.getKind();\n+        typeNode.type = this.importFunction.retType;\n+\n+        return typeNode;\n+    }\n+\n+    private BInvokableSymbol generateSymbol(String functionName) {\n+        BInvokableSymbol symbol = new BInvokableSymbol(\n+                820,\n+                0,\n+                new Name(functionName),\n+                bLangPackage.packageID,\n+                generateSymbolInvokableType(),\n+                bLangPackage.symbol\n+        );\n+\n+        return symbol;\n+    }\n+\n+    private BInvokableType generateSymbolInvokableType() {\n+        BInvokableType bInvokableType;\n+\n+        if (this.originalFunction == null && this.importFunction != null) {\n+            bInvokableType = (BInvokableType) this.importFunction.type;\n+        } else {\n+            bInvokableType = (BInvokableType) this.originalFunction.symbol.type;\n+        }\n+        return bInvokableType;\n+    }\n+\n+    private BLangFunctionBody generateBody() {\n+        BLangFunctionBody body = ASTBuilderUtil.createBlockFunctionBody(bLangPackage.pos, generateStatements());\n+        body.scope = bLangPackage.symbol.scope;\n+        return body;\n+    }\n+\n+    private List<BLangStatement> generateStatements() {\n+        // <MockFunctionObj>.functionToMock = (functionToMock);\n+        String functionToMockVal = (this.originalFunction == null) ?\n+                this.importFunction.name.toString() : this.originalFunction.name.toString();\n+        BLangAssignment bLangAssignment1 = ASTBuilderUtil.createAssignmentStmt(\n+                bLangPackage.pos,\n+                generateFieldBasedAccess(\"functionToMock\"),\n+                generateRHSExpr(functionToMockVal));\n+\n+        // <MockFunctionObj>.functionToMockPackage = (functionToMockPackage);  // ballerina/math/natives", "originalCommit": "a9e115b9f8140852d7ed77a994c178d451ef21c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcyMzYwMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25023#discussion_r462723603", "bodyText": "Let's make the comments more descriptive.", "author": "azinneera", "createdAt": "2020-07-30T04:12:42Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/MockDesugar.java", "diffHunk": "@@ -0,0 +1,459 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.desugar;\n+\n+\n+import org.ballerinalang.model.TreeBuilder;\n+import org.ballerinalang.model.tree.IdentifierNode;\n+import org.wso2.ballerinalang.compiler.semantics.analyzer.SymbolResolver;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolTable;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BInvokableSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BVarSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BInvokableType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.tree.BLangFunction;\n+import org.wso2.ballerinalang.compiler.tree.BLangFunctionBody;\n+import org.wso2.ballerinalang.compiler.tree.BLangIdentifier;\n+import org.wso2.ballerinalang.compiler.tree.BLangImportPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangSimpleVariable;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangExpression;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangFieldBasedAccess;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangInvocation;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangListConstructorExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangSimpleVarRef;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTypeConversionExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangVariableReference;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangAssignment;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangReturn;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangStatement;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangType;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangValueType;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.FieldKind;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Class to generate Mock Functions.\n+ *\n+ * @since 2.0.0\n+ */\n+public class MockDesugar {\n+\n+    private static final CompilerContext.Key<MockDesugar> MOCK_DESUGAR_KEY = new CompilerContext.Key<>();\n+    private static final String MOCK_ANNOTATION_DELIMITER = \"#\";\n+    private final SymbolTable symTable;\n+    private final SymbolResolver symResolver;\n+    private BLangPackage bLangPackage;\n+    private BLangFunction originalFunction;\n+    private BInvokableSymbol importFunction;\n+    private String mockFnObjectName;\n+\n+    private MockDesugar(CompilerContext context) {\n+        context.put(MOCK_DESUGAR_KEY, this);\n+        this.symTable = SymbolTable.getInstance(context);\n+        this.symResolver = SymbolResolver.getInstance(context);\n+    }\n+\n+    public static MockDesugar getInstance(CompilerContext context) {\n+        MockDesugar desugar = context.get(MOCK_DESUGAR_KEY);\n+        if (desugar == null) {\n+            desugar = new MockDesugar(context);\n+        }\n+        return desugar;\n+    }\n+\n+    private static IdentifierNode createIdentifier(String value) {\n+        IdentifierNode node = TreeBuilder.createIdentifierNode();\n+        if (value != null) {\n+            node.setValue(value);\n+        }\n+        return node;\n+    }\n+\n+    public void generateMockFunctions(BLangPackage pkgNode) {\n+        // Set the BLangPackage\n+        this.bLangPackage = pkgNode;\n+\n+        // Get the Mock Function map from the pkgNode\n+        Map<String, String> mockFunctionMap = pkgNode.getTestablePkg().getMockFunctionNamesMap();\n+\n+        // Get the set of functions to generate\n+        Set<String> mockFunctionSet = mockFunctionMap.keySet();\n+\n+        for (String function : mockFunctionSet) {\n+            if (!function.contains(\"~\")) {\n+                pkgNode.getTestablePkg().functions.add(generateMockFunction(function));\n+            }\n+        }\n+    }\n+\n+    private BLangFunction generateMockFunction(String functionName) {\n+        // Set the current mock object\n+        this.mockFnObjectName = this.bLangPackage.getTestablePkg().getMockFunctionNamesMap().get(functionName);\n+\n+        // Reset both import and original functions\n+        this.importFunction = null;\n+        this.originalFunction = null;\n+\n+        // Function name is going to be 'ballerina/math:1.0.0 # absInt'\n+        String currentPackageId = this.bLangPackage.packageID.toString();\n+\n+\n+        // We need to identify if the function is part of the current package or imported package\n+        if (functionName.contains(currentPackageId)) {\n+            // Simply extract the name only and set it to function name\n+            functionName = functionName.substring(functionName.indexOf(MOCK_ANNOTATION_DELIMITER) + 1);\n+            this.originalFunction = getOriginalFunction(functionName);\n+        } else {\n+            // Extract the name and the package details\n+            String packageName = functionName.contains(\":\") ?\n+                    functionName.substring(functionName.indexOf('/') + 1, functionName.indexOf(':')) :\n+                    functionName.substring(functionName.indexOf('/') + 1,\n+                                           functionName.indexOf(MOCK_ANNOTATION_DELIMITER));\n+            functionName = functionName.substring(functionName.indexOf(MOCK_ANNOTATION_DELIMITER) + 1);\n+            this.importFunction = getImportFunction(functionName, packageName);\n+        }\n+\n+        // Set the function name to $MOCK_<functionName>\n+        functionName = \"$MOCK_\" + functionName;\n+\n+        // Create the Base function with the name\n+        BLangFunction generatedMock = ASTBuilderUtil.createFunction(bLangPackage.pos, functionName);\n+\n+        if (this.originalFunction != null || this.importFunction != null) {\n+            generatedMock.requiredParams = generateRequiredParams();        // Required Params\n+            generatedMock.restParam = generateRestParam();                  // Rest Param\n+            generatedMock.returnTypeNode = generateReturnTypeNode();        // Return Type Node\n+            generatedMock.body = generateBody();                            // Body\n+            generatedMock.type = generateSymbolInvokableType();             // Invokable Type\n+            generatedMock.symbol = generateSymbol(functionName);            // Invokable Symbol\n+        } else {\n+            throw new IllegalStateException(\"Mock Function and Function to Mock cannot be null\");\n+        }\n+\n+        return generatedMock;\n+    }\n+\n+    private BLangFunction getOriginalFunction(String functionName) {\n+        List<BLangFunction> functionList = bLangPackage.getFunctions();\n+        for (BLangFunction function : functionList) {\n+            if (function.getName().toString().equals(functionName)) {\n+                return function;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private BInvokableSymbol getImportFunction(String functionName, String packageName) {\n+        BInvokableSymbol bInvokableSymbol =\n+                getInvokableSymbol(functionName, packageName, this.bLangPackage.getImports());\n+\n+        if (bInvokableSymbol == null) {\n+            bInvokableSymbol =\n+                    getInvokableSymbol(functionName, packageName, this.bLangPackage.getTestablePkg().getImports());\n+        }\n+\n+        return bInvokableSymbol;\n+    }\n+\n+    private BInvokableSymbol getInvokableSymbol(String functionName,\n+                                                String packageName,\n+                                                List<BLangImportPackage> importList) {\n+        // Loop through each BLangImportPackage\n+        for (BLangImportPackage importPkg : importList) {\n+            // If the import package name matches\n+            if (importPkg.alias.getValue().equals(packageName)) {\n+                // return the function name defined in the package entry map\n+                return (BInvokableSymbol) importPkg.symbol.scope.entries.get(new Name(functionName)).symbol;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    private List<BLangSimpleVariable> generateRequiredParams() {\n+        List<BLangSimpleVariable> requiredParams;\n+\n+        if (this.originalFunction == null) {\n+            requiredParams = generateImportRequiredParams();\n+        } else {\n+            requiredParams = this.originalFunction.requiredParams;\n+        }\n+\n+        return requiredParams;\n+    }\n+\n+    private List<BLangSimpleVariable> generateImportRequiredParams() {\n+        List<BLangSimpleVariable> bLangSimpleVariables = new ArrayList<>();\n+\n+        // Iterate through the params and generate the BLangSimpleVariable\n+        for (BVarSymbol bVarSymbol : this.importFunction.params) {\n+            BLangSimpleVariable bLangSimpleVariable =\n+                    ASTBuilderUtil.createVariable(bLangPackage.pos, bVarSymbol.name.getValue(),\n+                                                  bVarSymbol.type, null, bVarSymbol);\n+            bLangSimpleVariables.add(bLangSimpleVariable);\n+        }\n+\n+\n+        return bLangSimpleVariables;\n+    }\n+\n+    private BLangSimpleVariable generateRestParam() {\n+        BLangSimpleVariable bLangSimpleVariable = null;\n+\n+        if (this.importFunction != null) {\n+            BVarSymbol restParam = this.importFunction.restParam;\n+\n+            if (this.importFunction.restParam != null) {\n+                bLangSimpleVariable = ASTBuilderUtil.createVariable(bLangPackage.pos, restParam.name.getValue(),\n+                                                                    restParam.type, null, restParam);\n+                bLangSimpleVariable.typeNode = ASTBuilderUtil.createTypeNode(restParam.type);\n+            }\n+        }\n+\n+        return bLangSimpleVariable;\n+    }\n+\n+    private BLangType generateReturnTypeNode() {\n+        BLangType returnTypeNode;\n+\n+        if (this.originalFunction == null) {\n+            returnTypeNode = generateImportReturnTypeNode();\n+        } else {\n+            returnTypeNode = this.originalFunction.returnTypeNode;\n+        }\n+\n+        return returnTypeNode;\n+    }\n+\n+    private BLangType generateImportReturnTypeNode() {\n+        BLangValueType typeNode = (BLangValueType) TreeBuilder.createValueTypeNode();\n+        typeNode.pos = this.bLangPackage.pos;\n+        typeNode.typeKind = this.importFunction.retType.getKind();\n+        typeNode.type = this.importFunction.retType;\n+\n+        return typeNode;\n+    }\n+\n+    private BInvokableSymbol generateSymbol(String functionName) {\n+        BInvokableSymbol symbol = new BInvokableSymbol(\n+                820,\n+                0,\n+                new Name(functionName),\n+                bLangPackage.packageID,\n+                generateSymbolInvokableType(),\n+                bLangPackage.symbol\n+        );\n+\n+        return symbol;\n+    }\n+\n+    private BInvokableType generateSymbolInvokableType() {\n+        BInvokableType bInvokableType;\n+\n+        if (this.originalFunction == null && this.importFunction != null) {\n+            bInvokableType = (BInvokableType) this.importFunction.type;\n+        } else {\n+            bInvokableType = (BInvokableType) this.originalFunction.symbol.type;\n+        }\n+        return bInvokableType;\n+    }\n+\n+    private BLangFunctionBody generateBody() {\n+        BLangFunctionBody body = ASTBuilderUtil.createBlockFunctionBody(bLangPackage.pos, generateStatements());\n+        body.scope = bLangPackage.symbol.scope;\n+        return body;\n+    }\n+\n+    private List<BLangStatement> generateStatements() {\n+        // <MockFunctionObj>.functionToMock = (functionToMock);\n+        String functionToMockVal = (this.originalFunction == null) ?\n+                this.importFunction.name.toString() : this.originalFunction.name.toString();\n+        BLangAssignment bLangAssignment1 = ASTBuilderUtil.createAssignmentStmt(\n+                bLangPackage.pos,\n+                generateFieldBasedAccess(\"functionToMock\"),\n+                generateRHSExpr(functionToMockVal));\n+\n+        // <MockFunctionObj>.functionToMockPackage = (functionToMockPackage);  // ballerina/math/natives\n+//        String functionToMockPackageVal = (this.originalFunction == null) ?\n+//                this.importFunction.pkgID.toString()\n+//                        + \"/\" + getFunctionSource(this.importFunction.source) :\n+//                this.originalFunction.symbol.pkgID.toString()\n+//                        + \"/\" + getFunctionSource(this.originalFunction.symbol.source);\n+//        BLangAssignment bLangAssignment2 = ASTBuilderUtil.createAssignmentStmt(\n+//                bLangPackage.pos,\n+//                generateFieldBasedAccess(\"functionToMockPackage\"),\n+//                generateRHSExpr(functionToMockPackageVal));\n+\n+        // BLangReturn Statement <retType> test:MockHandler(<MockFunctionObj>, [<args?>])\n+        BLangReturn blangReturn =\n+                ASTBuilderUtil.createReturnStmt(bLangPackage.pos, generateTypeConversionExpression());\n+\n+        List<BLangStatement> statements = new ArrayList<>();\n+\n+//        statements.add(bLangAssignment1);\n+//        statements.add(bLangAssignment2);\n+        statements.add(blangReturn);\n+\n+        return statements;\n+    }\n+\n+    private String getFunctionSource(String source) {\n+        return source.replaceAll(\".bal\", \"\");\n+    }\n+\n+    // <mockobj>.functionToMock =", "originalCommit": "a9e115b9f8140852d7ed77a994c178d451ef21c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcyNDc2Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25023#discussion_r462724766", "bodyText": "Let's use the node Kind to check the condition.\ni.e. attachmentNode.getExpression().getKind() == NodeKind.RECORD_LITERAL_EXP", "author": "azinneera", "createdAt": "2020-07-30T04:17:46Z", "path": "misc/testerina/modules/testerina-core/src/main/java/org/ballerinalang/testerina/core/TestAnnotationProcessor.java", "diffHunk": "@@ -319,86 +236,163 @@ public void process(FunctionNode functionNode, List<AnnotationAttachmentNode> an\n                 if (!shouldSkip.get()) {\n                     suite.addTests(test);\n                 }\n+            } else if (MOCK_ANNOTATION_NAME.equals(annotationName)) {\n+                String[] vals = new String[2];\n+                // TODO: when default values are supported in annotation struct we can remove this\n+                vals[0] = packageName;\n+                if (attachmentNode.getExpression() instanceof BLangRecordLiteral) {", "originalCommit": "a9e115b9f8140852d7ed77a994c178d451ef21c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcyNTk3Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25023#discussion_r462725976", "bodyText": "Let's move \"$MOCK_\" to constants", "author": "azinneera", "createdAt": "2020-07-30T04:22:21Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/BIRGen.java", "diffHunk": "@@ -293,37 +294,48 @@ private void visitBuiltinFunctions(BLangPackage pkgNode, BLangFunction function)\n     }\n \n     private void replaceMockedFunctions(BIRPackage birPkg, Map<String, String> mockFunctionMap) {\n-        for (BIRFunction function : birPkg.functions) {\n-            List<BIRBasicBlock> functionBasicBlocks = function.basicBlocks;\n-            for (BIRBasicBlock functionBasicBlock : functionBasicBlocks) {\n-                BIRTerminator bbTerminator = functionBasicBlock.terminator;\n+        // Replace Mocked function calls in every function\n+        replaceFunctions(birPkg.functions, mockFunctionMap);\n+\n+        // Replace Mocked Function calls in every service\n+        if (birPkg.typeDefs.size() != 0) {\n+            for (BIRTypeDefinition typeDef : birPkg.typeDefs) {\n+                if (typeDef.type instanceof BServiceType) {\n+                    // Replace Mocked function calls in every service function\n+                    replaceFunctions(typeDef.attachedFuncs, mockFunctionMap);\n+                }\n+            }\n+        }\n+    }\n+\n+    private void replaceFunctions(List<BIRFunction> functionList, Map<String, String> mockFunctionMap) {\n+        // Loop through all defined BIRFunctions in functionList\n+        for (BIRFunction function : functionList) {\n+            List<BIRBasicBlock> basicBlocks = function.basicBlocks;\n+            for (BIRBasicBlock basicBlock : basicBlocks) {\n+                BIRTerminator bbTerminator = basicBlock.terminator;\n                 if (bbTerminator.kind.equals(InstructionKind.CALL)) {\n+                    //We get the callee and the name and generate 'calleepackage#name'\n                     BIRTerminator.Call callTerminator = (BIRTerminator.Call) bbTerminator;\n-                    String functionKey = null;\n-\n-                    // Generate the function key\n-                    if (callTerminator.isVirtual) {\n-                        // Function key for object methods\n-                        String objectPkg = callTerminator.args.get(0).variableDcl.type.toString();\n-                        functionKey = objectPkg + MOCK_ANNOTATION_DELIMITER + callTerminator.name.toString();\n-                    } else {\n-                        // Function key for normal functions\n-                        functionKey = callTerminator.calleePkg.toString() + MOCK_ANNOTATION_DELIMITER\n-                                + callTerminator.name.toString();\n-                    }\n \n-                    // Get the mock function from the Mock function map and replace where necessary\n-                    if (mockFunctionMap.get(functionKey) != null) {\n-                        String mockFunctionName = mockFunctionMap.get(functionKey);\n-                        callTerminator.name = new Name(mockFunctionName);\n-                        callTerminator.calleePkg = function.pos.src.pkgID;\n+                    String functionKey = callTerminator.calleePkg.toString() + MOCK_ANNOTATION_DELIMITER\n+                            + callTerminator.name.toString();\n \n-                        if (callTerminator.isVirtual) {\n-                            callTerminator.isVirtual = false;\n-                            callTerminator.args.remove(0);\n-                        }\n-                    }\n+                    String legacyKey = callTerminator.calleePkg.toString() + MOCK_FN_DELIMITER\n+                            + callTerminator.name.toString();\n \n+                    // If function in basic block exists in the MockFunctionMap\n+                    if (mockFunctionMap.containsKey(functionKey)) {\n+                        // Replace the function call with the equivalent $MOCK_ substitiute\n+                        String desugarFunction = \"$MOCK_\" + callTerminator.name.getValue();", "originalCommit": "a9e115b9f8140852d7ed77a994c178d451ef21c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "772ac4b68a63f9adc31e217391d3c7582e94b06b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/772ac4b68a63f9adc31e217391d3c7582e94b06b", "message": "Address PR comments", "committedDate": "2020-08-04T06:55:19Z", "type": "forcePushed"}, {"oid": "c3f75e5abf0d0b2d301a72abb95e01b6fa4d957d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c3f75e5abf0d0b2d301a72abb95e01b6fa4d957d", "message": "Address PR comments", "committedDate": "2020-08-04T08:33:43Z", "type": "forcePushed"}, {"oid": "e16ea32d68cac90da57ca1bb8f568e3b805fb9ec", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e16ea32d68cac90da57ca1bb8f568e3b805fb9ec", "message": "Address PR comments", "committedDate": "2020-08-06T08:06:08Z", "type": "forcePushed"}, {"oid": "fd6536a922aac9523f20811ada94901091d7d78a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fd6536a922aac9523f20811ada94901091d7d78a", "message": "Add Testerina mocking functionality", "committedDate": "2020-08-06T11:29:41Z", "type": "commit"}, {"oid": "e1e44618f63264352f8f13786075fd49f9678a8d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e1e44618f63264352f8f13786075fd49f9678a8d", "message": "Add Testerina mocking refactored classes", "committedDate": "2020-08-06T11:29:41Z", "type": "commit"}, {"oid": "9b4225833c419e59efa55b75ea19400f5792d81c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9b4225833c419e59efa55b75ea19400f5792d81c", "message": "Address PR comments", "committedDate": "2020-08-06T11:29:42Z", "type": "commit"}, {"oid": "9058e9a8731bf2e4cdf23248746c4e11b0cb76d7", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9058e9a8731bf2e4cdf23248746c4e11b0cb76d7", "message": "Add function mocking runtime validation", "committedDate": "2020-08-06T11:29:42Z", "type": "forcePushed"}, {"oid": "f1fcd0843de554c6118c7d6fbc1210183529e635", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f1fcd0843de554c6118c7d6fbc1210183529e635", "message": "Add function mocking runtime validation", "committedDate": "2020-08-06T11:37:47Z", "type": "commit"}, {"oid": "f1fcd0843de554c6118c7d6fbc1210183529e635", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f1fcd0843de554c6118c7d6fbc1210183529e635", "message": "Add function mocking runtime validation", "committedDate": "2020-08-06T11:37:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3MjYxOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25023#discussion_r466572619", "bodyText": "Wrong version", "author": "azinneera", "createdAt": "2020-08-06T17:28:47Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/MockDesugar.java", "diffHunk": "@@ -0,0 +1,523 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.desugar;\n+\n+import org.ballerinalang.model.TreeBuilder;\n+import org.ballerinalang.model.tree.IdentifierNode;\n+import org.wso2.ballerinalang.compiler.semantics.analyzer.SymbolResolver;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolTable;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BInvokableSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BVarSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BInvokableType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.tree.BLangFunction;\n+import org.wso2.ballerinalang.compiler.tree.BLangFunctionBody;\n+import org.wso2.ballerinalang.compiler.tree.BLangIdentifier;\n+import org.wso2.ballerinalang.compiler.tree.BLangImportPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangSimpleVariable;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangExpression;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangFieldBasedAccess;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangInvocation;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangSimpleVarRef;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTypeConversionExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangVariableReference;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangAssignment;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangReturn;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangStatement;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangType;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangValueType;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.FieldKind;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Class to generate Mock Functions.\n+ *\n+ * @since 2.0.0", "originalCommit": "f1fcd0843de554c6118c7d6fbc1210183529e635", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY0MTUwMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25023#discussion_r466641502", "bodyText": "Changed version to 1.2.7", "author": "Ibaqu", "createdAt": "2020-08-06T19:36:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3MjYxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3MzcwMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25023#discussion_r466573701", "bodyText": "\"/\" can be a constant.", "author": "azinneera", "createdAt": "2020-08-06T17:30:36Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/MockDesugar.java", "diffHunk": "@@ -0,0 +1,523 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.desugar;\n+\n+import org.ballerinalang.model.TreeBuilder;\n+import org.ballerinalang.model.tree.IdentifierNode;\n+import org.wso2.ballerinalang.compiler.semantics.analyzer.SymbolResolver;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolTable;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BInvokableSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BVarSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BInvokableType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.tree.BLangFunction;\n+import org.wso2.ballerinalang.compiler.tree.BLangFunctionBody;\n+import org.wso2.ballerinalang.compiler.tree.BLangIdentifier;\n+import org.wso2.ballerinalang.compiler.tree.BLangImportPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangSimpleVariable;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangExpression;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangFieldBasedAccess;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangInvocation;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangSimpleVarRef;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTypeConversionExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangVariableReference;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangAssignment;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangReturn;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangStatement;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangType;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangValueType;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.FieldKind;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Class to generate Mock Functions.\n+ *\n+ * @since 2.0.0\n+ */\n+public class MockDesugar {\n+\n+    private static final CompilerContext.Key<MockDesugar> MOCK_DESUGAR_KEY = new CompilerContext.Key<>();\n+    private static final String MOCK_ANNOTATION_DELIMITER = \"#\";\n+    private static final String MOCK_PREFIX = \"$MOCK_\";\n+    private final SymbolTable symTable;\n+    private final SymbolResolver symResolver;\n+    private BLangPackage bLangPackage;\n+    private BLangFunction originalFunction;\n+    private BInvokableSymbol importFunction;\n+    private String mockFnObjectName;\n+\n+    private MockDesugar(CompilerContext context) {\n+        context.put(MOCK_DESUGAR_KEY, this);\n+        this.symTable = SymbolTable.getInstance(context);\n+        this.symResolver = SymbolResolver.getInstance(context);\n+    }\n+\n+    public static MockDesugar getInstance(CompilerContext context) {\n+        MockDesugar desugar = context.get(MOCK_DESUGAR_KEY);\n+        if (desugar == null) {\n+            desugar = new MockDesugar(context);\n+        }\n+        return desugar;\n+    }\n+\n+    private static IdentifierNode createIdentifier(String value) {\n+        IdentifierNode node = TreeBuilder.createIdentifierNode();\n+        if (value != null) {\n+            node.setValue(value);\n+        }\n+        return node;\n+    }\n+\n+    /**\n+     * Generates all the Mock Functions and adds them to the BLangPackage's TestablePkg function list.\n+     *\n+     * @param pkgNode BLangPackage\n+     */\n+    public void generateMockFunctions(BLangPackage pkgNode) {\n+        // Set the BLangPackage\n+        this.bLangPackage = pkgNode;\n+\n+        // Get the Mock Function map from the pkgNode\n+        Map<String, String> mockFunctionMap = pkgNode.getTestablePkg().getMockFunctionNamesMap();\n+\n+        // Get the set of functions to generate\n+        Set<String> mockFunctionSet = mockFunctionMap.keySet();\n+\n+        for (String function : mockFunctionSet) {\n+            if (!function.contains(\"~\")) {\n+                pkgNode.getTestablePkg().functions.add(generateMockFunction(function));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Generates a BLangFunction based on the function name provided.\n+     *\n+     * @param functionName Name of the function to generate the mock\n+     * @return Generated BLangFunction\n+     */\n+    private BLangFunction generateMockFunction(String functionName) {\n+        // Set the current mock object\n+        this.mockFnObjectName = this.bLangPackage.getTestablePkg().getMockFunctionNamesMap().get(functionName);\n+\n+        // Reset both import and original functions\n+        this.importFunction = null;\n+        this.originalFunction = null;\n+\n+        // Identify if function is part of current package or import package\n+        if (functionName.contains(this.bLangPackage.packageID.toString())) {\n+            // Simply extract the name only\n+            functionName = functionName.substring(functionName.indexOf(MOCK_ANNOTATION_DELIMITER) + 1);\n+            this.originalFunction = getOriginalFunction(functionName);\n+        } else {\n+            // Extract the name and the package details\n+            String packageName = (functionName.contains(\":\")) ?\n+                    functionName.substring(functionName.indexOf('/') + 1, functionName.indexOf(':')) :\n+                    functionName.substring(functionName.indexOf('/') + 1,\n+                                           functionName.indexOf(MOCK_ANNOTATION_DELIMITER));\n+            functionName = functionName.substring(functionName.indexOf(MOCK_ANNOTATION_DELIMITER) + 1);\n+            this.importFunction = getImportFunction(functionName, packageName);\n+        }\n+\n+        // Set the function name to $MOCK_<functionName>\n+        functionName = MOCK_PREFIX + functionName;\n+\n+        // Create the Base function with the name\n+        BLangFunction generatedMock = ASTBuilderUtil.createFunction(bLangPackage.pos, functionName);\n+\n+        if (this.originalFunction != null || this.importFunction != null) {\n+            generatedMock.requiredParams = generateRequiredParams();        // Required Params\n+            generatedMock.restParam = generateRestParam();                  // Rest Param\n+            generatedMock.returnTypeNode = generateReturnTypeNode();        // Return Type Node\n+            generatedMock.body = generateBody();                            // Body\n+            generatedMock.type = generateSymbolInvokableType();             // Invokable Type\n+            generatedMock.symbol = generateSymbol(functionName);            // Invokable Symbol\n+        } else {\n+            throw new IllegalStateException(\"Mock Function and Function to Mock cannot be null\");\n+        }\n+\n+        return generatedMock;\n+    }\n+\n+    private BLangFunction getOriginalFunction(String functionName) {\n+        List<BLangFunction> functionList = bLangPackage.getFunctions();\n+        for (BLangFunction function : functionList) {\n+            if (function.getName().toString().equals(functionName)) {\n+                return function;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private BInvokableSymbol getImportFunction(String functionName, String packageName) {\n+        BInvokableSymbol bInvokableSymbol =\n+                getInvokableSymbol(functionName, packageName, this.bLangPackage.getImports());\n+\n+        if (bInvokableSymbol == null) {\n+            bInvokableSymbol =\n+                    getInvokableSymbol(functionName, packageName, this.bLangPackage.getTestablePkg().getImports());\n+        }\n+\n+        return bInvokableSymbol;\n+    }\n+\n+    private BInvokableSymbol getInvokableSymbol(String functionName, String packageName,\n+                                                List<BLangImportPackage> importList) {\n+        // Loop through each BLangImportPackage\n+        for (BLangImportPackage importPkg : importList) {\n+            // If the import package name matches\n+            if (importPkg.alias.getValue().equals(packageName)) {\n+                // return the function name defined in the package entry map\n+                return (BInvokableSymbol) importPkg.symbol.scope.entries.get(new Name(functionName)).symbol;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    private List<BLangSimpleVariable> generateRequiredParams() {\n+        List<BLangSimpleVariable> requiredParams;\n+\n+        if (this.originalFunction != null) {\n+            requiredParams = this.originalFunction.requiredParams;\n+        } else {\n+            requiredParams = generateImportRequiredParams();\n+        }\n+\n+        return requiredParams;\n+    }\n+\n+    private List<BLangSimpleVariable> generateImportRequiredParams() {\n+        List<BLangSimpleVariable> bLangSimpleVariables = new ArrayList<>();\n+\n+        // Iterate through the params and generate the BLangSimpleVariable\n+        for (BVarSymbol bVarSymbol : this.importFunction.params) {\n+            BLangSimpleVariable bLangSimpleVariable =\n+                    ASTBuilderUtil.createVariable(bLangPackage.pos, bVarSymbol.name.getValue(),\n+                                                  bVarSymbol.type, null, bVarSymbol);\n+            bLangSimpleVariables.add(bLangSimpleVariable);\n+        }\n+\n+        return bLangSimpleVariables;\n+    }\n+\n+    private BLangSimpleVariable generateRestParam() {\n+        BLangSimpleVariable bLangSimpleVariable = null;\n+\n+        if (this.importFunction != null) {\n+            if (this.importFunction.restParam != null) {\n+                bLangSimpleVariable =\n+                        ASTBuilderUtil.createVariable(bLangPackage.pos, this.importFunction.restParam.name.getValue(),\n+                                                      this.importFunction.restParam.type, null,\n+                                                      this.importFunction.restParam);\n+                bLangSimpleVariable.typeNode = ASTBuilderUtil.createTypeNode(this.importFunction.restParam.type);\n+            }\n+        } else {\n+            bLangSimpleVariable = this.originalFunction.restParam;\n+        }\n+\n+        return bLangSimpleVariable;\n+    }\n+\n+    private BLangType generateReturnTypeNode() {\n+        BLangType returnTypeNode;\n+\n+        if (this.originalFunction == null) {\n+            returnTypeNode = generateImportReturnTypeNode();\n+        } else {\n+            returnTypeNode = this.originalFunction.returnTypeNode;\n+        }\n+\n+        return returnTypeNode;\n+    }\n+\n+    private BLangType generateImportReturnTypeNode() {\n+        BLangValueType typeNode = (BLangValueType) TreeBuilder.createValueTypeNode();\n+        typeNode.pos = this.bLangPackage.pos;\n+        typeNode.typeKind = this.importFunction.retType.getKind();\n+        typeNode.type = this.importFunction.retType;\n+\n+        return typeNode;\n+    }\n+\n+    private BInvokableSymbol generateSymbol(String functionName) {\n+        BInvokableSymbol symbol = new BInvokableSymbol(\n+                820,\n+                0,\n+                new Name(functionName),\n+                bLangPackage.packageID,\n+                generateSymbolInvokableType(),\n+                bLangPackage.symbol\n+        );\n+\n+        return symbol;\n+    }\n+\n+    private BInvokableType generateSymbolInvokableType() {\n+        BInvokableType bInvokableType;\n+\n+        if (this.originalFunction == null && this.importFunction != null) {\n+            bInvokableType = (BInvokableType) this.importFunction.type;\n+        } else {\n+            bInvokableType = (BInvokableType) this.originalFunction.symbol.type;\n+        }\n+        return bInvokableType;\n+    }\n+\n+    private BLangFunctionBody generateBody() {\n+        BLangFunctionBody body = ASTBuilderUtil.createBlockFunctionBody(bLangPackage.pos, generateStatements());\n+        body.scope = bLangPackage.symbol.scope;\n+        return body;\n+    }\n+\n+    private List<BLangStatement> generateStatements() {\n+        // The following synthesizes the equivalent of : `<MockFunctionObj>.functionToMock = (functionToMock);`\n+        String functionToMockVal = (this.originalFunction == null) ?\n+                this.importFunction.name.toString() : this.originalFunction.name.toString();\n+        BLangAssignment bLangAssignment1 = ASTBuilderUtil.createAssignmentStmt(\n+                bLangPackage.pos,\n+                generateFieldBasedAccess(\"functionToMock\"),\n+                generateRHSExpr(functionToMockVal));\n+\n+        // <MockFunctionObj>.functionToMockPackage = (functionToMockPackage);  // ballerina/math/natives\n+        String functionToMockPackageVal = (this.originalFunction == null) ?\n+                this.importFunction.pkgID.orgName.toString()\n+                        + \"/\" + this.importFunction.pkgID.name.toString()", "originalCommit": "f1fcd0843de554c6118c7d6fbc1210183529e635", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY0MTU0Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25023#discussion_r466641543", "bodyText": "Added \"/\" to the constants", "author": "Ibaqu", "createdAt": "2020-08-06T19:36:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3MzcwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3NjczOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25023#discussion_r466576739", "bodyText": "Indentation issue", "author": "azinneera", "createdAt": "2020-08-06T17:36:01Z", "path": "misc/testerina/modules/testerina-core/src/main/java/org/ballerinalang/testerina/core/TestAnnotationProcessor.java", "diffHunk": "@@ -256,7 +174,7 @@ public void process(FunctionNode functionNode, List<AnnotationAttachmentNode> an\n \n                         // Check if enable property is present in the annotation\n                         if (TEST_ENABLE_ANNOTATION_NAME.equals(name) && \"false\".equals(valueExpr\n-                                .toString())) {\n+                                                                                               .toString())) {", "originalCommit": "f1fcd0843de554c6118c7d6fbc1210183529e635", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY0MTcyMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25023#discussion_r466641723", "bodyText": "Corrected indentation issue", "author": "Ibaqu", "createdAt": "2020-08-06T19:36:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3NjczOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3ODEzNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25023#discussion_r466578136", "bodyText": "We should add javadocs to public functions", "author": "azinneera", "createdAt": "2020-08-06T17:38:18Z", "path": "misc/testerina/modules/testerina-core/src/main/java/org/ballerinalang/testerina/natives/test/FunctionMock.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.ballerinalang.testerina.natives.test;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.scheduling.Scheduler;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.values.AbstractObjectValue;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.jvm.values.connector.Executor;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Method;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Class that contains inter-op function related to function mocking.\n+ */\n+public class FunctionMock {\n+\n+    public static ErrorValue thenReturn(ObjectValue caseObj) {", "originalCommit": "f1fcd0843de554c6118c7d6fbc1210183529e635", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY0MTkxOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25023#discussion_r466641919", "bodyText": "Added Javadocs to public functions in class", "author": "Ibaqu", "createdAt": "2020-08-06T19:36:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3ODEzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3OTQ3OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25023#discussion_r466579478", "bodyText": "Can't we utilize the classloader for getting the classname?", "author": "azinneera", "createdAt": "2020-08-06T17:40:45Z", "path": "misc/testerina/modules/testerina-core/src/main/java/org/ballerinalang/testerina/natives/test/FunctionMock.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.ballerinalang.testerina.natives.test;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.scheduling.Scheduler;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.values.AbstractObjectValue;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.jvm.values.connector.Executor;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Method;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Class that contains inter-op function related to function mocking.\n+ */\n+public class FunctionMock {\n+\n+    public static ErrorValue thenReturn(ObjectValue caseObj) {\n+        ObjectValue mockFunctionObj = caseObj.getObjectValue(\"mockFuncObj\");\n+        ArrayValue args = caseObj.getArrayValue(\"args\");\n+        Object returnVal = caseObj.get(\"returnValue\");\n+        MockRegistry.getInstance().registerCase(mockFunctionObj, null, args, returnVal);\n+        return null;\n+    }\n+\n+    public static Object mockHandler(ObjectValue mockFuncObj, Object... args) {\n+        List<String> caseIds = getCaseIds(mockFuncObj, args);\n+        String originalFunction =\n+                mockFuncObj.getStringValue(\"functionToMock\");\n+        String originalFunctionPackage =\n+                mockFuncObj.getStringValue(\"functionToMockPackage\");\n+        originalFunctionPackage = formatFunctionPackage(originalFunctionPackage);\n+        String version =\n+                mockFuncObj.getStringValue(\"packageVersion\");\n+        Object returnVal = null;\n+\n+        for (String caseId : caseIds) {\n+            if (MockRegistry.getInstance().hasCase(caseId)) {\n+                returnVal = MockRegistry.getInstance().getReturnValue(caseId);\n+                if (returnVal.toString().contains(MockConstants.FUNCTION_CALL_PLACEHOLDER)) {\n+                    return callFunction(originalFunction, originalFunctionPackage, returnVal.toString(), version, args);\n+                }\n+                break;\n+            }\n+        }\n+        if (returnVal == null) {\n+            String detail = \"no return value or action registered for function\";\n+            return BallerinaErrors.createError(MockConstants.FUNCTION_CALL_ERROR, detail);\n+        }\n+        return returnVal;\n+    }\n+\n+    private static Object callFunction(String originalFunction, String originalFunctionPackage, String returnVal,\n+                                       String version, Object... args) {\n+        int prefixPos = returnVal.indexOf(MockConstants.FUNCTION_CALL_PLACEHOLDER);\n+        String methodName = returnVal.substring(prefixPos + MockConstants.FUNCTION_CALL_PLACEHOLDER.length());\n+        Strand strand = Scheduler.getStrand();\n+\n+        String className;\n+        String orgName;\n+        String packageName;\n+\n+        // Set project info\n+        try {\n+            String[] projectInfo =\n+                    Thread.currentThread().getStackTrace()[4].getClassName().split(Pattern.quote(\".\"));\n+            orgName = projectInfo[0];\n+            packageName = projectInfo[1];\n+            className = \"tests.\" +\n+                    getClassName(methodName, orgName, packageName, version, originalFunction, originalFunctionPackage);\n+        } catch (IOException | ClassNotFoundException e) {\n+            return BallerinaErrors.createError(MockConstants.FUNCTION_CALL_ERROR, e.getMessage());\n+        }\n+\n+        List<Object> argsList = new ArrayList<>();\n+        for (Object arg : args) {\n+            argsList.add(arg);\n+        }\n+\n+        ClassLoader classLoader = FunctionMock.class.getClassLoader();\n+        return Executor.executeFunction(strand.scheduler, classLoader, orgName,\n+                                        packageName, className, methodName, argsList.toArray());\n+    }\n+\n+    private static String getClassName(String mockMethodName, String orgName, String packageName, String version,\n+                                       String originalMethodName, String originalPackageName)\n+            throws IOException, ClassNotFoundException {\n+        String jarName = orgName + \"-\" + packageName + \"-\" + version + \"-testable.jar\";", "originalCommit": "f1fcd0843de554c6118c7d6fbc1210183529e635", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY0MzA3OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25023#discussion_r466643079", "bodyText": "I worked on implementing this using the class loader and it worked fine for Mock functions defined in the same file. However, when moving mock functions to a different file, the implementation fails.\nEventually, I settled for directly obtaining the version and passing it from the compile-time desugar phase to the runtime and it works.\nThis might have to be revisited", "author": "Ibaqu", "createdAt": "2020-08-06T19:39:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3OTQ3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU4MjMxNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25023#discussion_r466582316", "bodyText": "Shall we make the function names self explanatory, since there are two for function mocking?", "author": "azinneera", "createdAt": "2020-08-06T17:45:54Z", "path": "tests/testerina-integration-test/src/test/java/org/ballerinalang/testerina/test/MockTest.java", "diffHunk": "@@ -31,20 +31,45 @@\n \n     private BMainInstance balClient;\n     private String projectPath;\n+    private String projectPath2;\n \n     @BeforeClass\n     public void setup() throws BallerinaTestException {\n         balClient = new BMainInstance(balServer);\n         projectPath = mockProjectPath.toString();\n+        projectPath2 = mockProjectPath2.toString();\n     }\n \n     @Test\n-    public void testAssertTrue() throws BallerinaTestException {\n-        String msg = \"5 passing\";\n-        LogLeecher clientLeecher = new LogLeecher(msg);\n-        balClient.runMain(\"test\", new String[]{\"--all\"}, null,\n-                new String[]{}, new LogLeecher[]{clientLeecher}, projectPath);\n-        clientLeecher.waitForText(20000);\n+    public void testFunctionMocking() throws BallerinaTestException {", "originalCommit": "f1fcd0843de554c6118c7d6fbc1210183529e635", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY0MzMxMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25023#discussion_r466643310", "bodyText": "Changed the second test function to better reflect what the test does", "author": "Ibaqu", "createdAt": "2020-08-06T19:39:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU4MjMxNg=="}], "type": "inlineReview"}, {"oid": "3da116294448ab20644c2f076feee27af78fd739", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3da116294448ab20644c2f076feee27af78fd739", "message": "Address PR comments", "committedDate": "2020-08-06T19:28:00Z", "type": "commit"}]}