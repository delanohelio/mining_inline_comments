{"pr_number": 23450, "pr_title": "Add enum declaration support to new parser", "pr_createdAt": "2020-05-22T18:07:21Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/23450", "timeline": [{"oid": "284ee8ab350fbfadc815cc578a8f8d2f47cf8140", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/284ee8ab350fbfadc815cc578a8f8d2f47cf8140", "message": "Module enum declaration support.", "committedDate": "2020-05-22T07:50:25Z", "type": "commit"}, {"oid": "1529ada0cc6a8d5dfd92008004354e5861cf9dfe", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1529ada0cc6a8d5dfd92008004354e5861cf9dfe", "message": "Recovery logic and test cases for module enum declaration.", "committedDate": "2020-05-22T17:43:19Z", "type": "commit"}, {"oid": "dfcd1ac831930ec13ff0c709e9a40d0b9b8df1d9", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/dfcd1ac831930ec13ff0c709e9a40d0b9b8df1d9", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into tuple-type", "committedDate": "2020-05-22T18:03:14Z", "type": "commit"}, {"oid": "f064353a3b19c89f7ccd71c0f8083a0e11dc4560", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f064353a3b19c89f7ccd71c0f8083a0e11dc4560", "message": "Removed extra new lines.", "committedDate": "2020-05-22T18:12:19Z", "type": "commit"}, {"oid": "126f69cb7996d944324fa820a43b45288ae77074", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/126f69cb7996d944324fa820a43b45288ae77074", "message": "Added new line to EOF.", "committedDate": "2020-05-22T18:14:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU0MDY1MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23450#discussion_r429540651", "bodyText": "Can say parseEnumMemberEnd", "author": "SupunS", "createdAt": "2020-05-23T12:12:59Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10857,4 +10866,164 @@ private STNode parseConditionalExpression(STNode lhsExpr) {\n         STNode endExpr = parseExpression(OperatorPrecedence.ELVIS_CONDITIONAL, true, false);\n         return STNodeFactory.createConditionalExpressionNode(lhsExpr, questionMark, middleExpr, colon, endExpr);\n     }\n+\n+    /**\n+     * Parse enum declaration.\n+     * <p>\n+     * module-enum-decl :=\n+     *  metadata\n+     *  [public] enum identifier { enum-member (, enum-member)* }\n+     * enum-member := metadata identifier [= const-expr]\n+     * </p>\n+     * @param metadata\n+     * @param qualifier\n+     *\n+     * @return Parsed enum node.\n+     */\n+    private STNode parseEnumDeclaration(STNode metadata, STNode qualifier) {\n+        startContext(ParserRuleContext.MODULE_ENUM_DECLARATION);\n+        STNode enumKeywordToken = parseEnumKeyword();\n+        STNode identifier = parseIdentifier(ParserRuleContext.MODULE_ENUM_NAME);\n+        STNode openBraceToken = parseOpenBrace();\n+        STNode enumMemberList = parseEnumMemberList();\n+        STNode closeBraceToken = parseCloseBrace();\n+\n+        endContext();\n+        return STNodeFactory.createEnumDeclarationNode(metadata, qualifier, enumKeywordToken, identifier,\n+                openBraceToken, enumMemberList, closeBraceToken);\n+    }\n+\n+    /**\n+     * Parse enum member list.\n+     * <p>enum-member := metadata identifier [= const-expr]</p>\n+     *\n+     * @return enum member list node.\n+     */\n+    private STNode parseEnumMemberList() {\n+        startContext(ParserRuleContext.ENUM_MEMBER_LIST);\n+        List<STNode> enumMemberList = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Report an empty enum member list\n+        if (nextToken.kind == SyntaxKind.CLOSE_BRACE_TOKEN) {\n+            this.errorHandler.reportMissingTokenError(\"enum member list cannot be empty\");\n+            return STNodeFactory.createNodeList(new ArrayList<>());\n+        }\n+\n+        // Parse first enum member, that has no leading comma\n+        STNode enumMember = parseEnumMember();\n+\n+        // Parse the remaining enum members\n+        nextToken = peek();\n+        STNode enumMemberRhs;\n+        while (nextToken.kind != SyntaxKind.CLOSE_BRACE_TOKEN) {\n+            enumMemberRhs = parseEnumMemberRhs(nextToken.kind);\n+            if (enumMemberRhs == null) {\n+                break;\n+            }\n+            enumMemberList.add(enumMember);\n+            enumMemberList.add(enumMemberRhs);\n+            enumMember = parseEnumMember();\n+            nextToken = peek();\n+        }\n+\n+        enumMemberList.add(enumMember);\n+\n+        endContext();\n+        return STNodeFactory.createNodeList(enumMemberList);\n+    }\n+\n+    /**\n+     * Parse enum member.\n+     * <p>enum-member := metadata identifier [= const-expr]</p>\n+     *\n+     * @return Parsed enum member node.\n+     */\n+    private STNode parseEnumMember() {\n+        STToken nextToken = peek();\n+        STNode metadata;\n+        switch (nextToken.kind) {\n+            case DOCUMENTATION_LINE:\n+            case AT_TOKEN:\n+                metadata = parseMetaData(nextToken.kind);\n+                break;\n+            default:\n+                metadata = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode identifierNode = parseIdentifier(ParserRuleContext.ENUM_MEMBER_NAME);\n+        return parseEnumMemberInternalRhs(metadata, identifierNode);\n+    }\n+\n+    private STNode parseEnumMemberInternalRhs(STNode metadata, STNode identifierNode) {\n+        return parseEnumMemberInternalRhs(metadata, identifierNode, peek().kind);\n+    }\n+\n+    private STNode parseEnumMemberInternalRhs(STNode metadata, STNode identifierNode, SyntaxKind nextToken) {\n+        STNode equalToken, constExprNode;\n+        switch (nextToken) {\n+            case EQUAL_TOKEN:\n+                equalToken = parseAssignOp();\n+                constExprNode = parseExpression();\n+                break;\n+            case COMMA_TOKEN:\n+            case CLOSE_BRACE_TOKEN:\n+                equalToken = STNodeFactory.createEmptyNode();\n+                constExprNode = STNodeFactory.createEmptyNode();\n+                break;\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.ENUM_MEMBER_INTERNAL_RHS, metadata,\n+                        identifierNode);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseEnumMemberInternalRhs(metadata, identifierNode, solution.tokenKind);\n+        }\n+\n+        return STNodeFactory.createEnumMemberNode(metadata, identifierNode, equalToken, constExprNode);\n+    }\n+\n+    private STNode parseEnumMemberRhs() {\n+        return parseEnumMemberRhs(peek().kind);\n+    }\n+\n+    private STNode parseEnumMemberRhs(SyntaxKind nextTokenKind) {", "originalCommit": "126f69cb7996d944324fa820a43b45288ae77074", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU0MDY3Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23450#discussion_r429540673", "bodyText": "can say parseEnumMemberRhs", "author": "SupunS", "createdAt": "2020-05-23T12:13:14Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10857,4 +10866,164 @@ private STNode parseConditionalExpression(STNode lhsExpr) {\n         STNode endExpr = parseExpression(OperatorPrecedence.ELVIS_CONDITIONAL, true, false);\n         return STNodeFactory.createConditionalExpressionNode(lhsExpr, questionMark, middleExpr, colon, endExpr);\n     }\n+\n+    /**\n+     * Parse enum declaration.\n+     * <p>\n+     * module-enum-decl :=\n+     *  metadata\n+     *  [public] enum identifier { enum-member (, enum-member)* }\n+     * enum-member := metadata identifier [= const-expr]\n+     * </p>\n+     * @param metadata\n+     * @param qualifier\n+     *\n+     * @return Parsed enum node.\n+     */\n+    private STNode parseEnumDeclaration(STNode metadata, STNode qualifier) {\n+        startContext(ParserRuleContext.MODULE_ENUM_DECLARATION);\n+        STNode enumKeywordToken = parseEnumKeyword();\n+        STNode identifier = parseIdentifier(ParserRuleContext.MODULE_ENUM_NAME);\n+        STNode openBraceToken = parseOpenBrace();\n+        STNode enumMemberList = parseEnumMemberList();\n+        STNode closeBraceToken = parseCloseBrace();\n+\n+        endContext();\n+        return STNodeFactory.createEnumDeclarationNode(metadata, qualifier, enumKeywordToken, identifier,\n+                openBraceToken, enumMemberList, closeBraceToken);\n+    }\n+\n+    /**\n+     * Parse enum member list.\n+     * <p>enum-member := metadata identifier [= const-expr]</p>\n+     *\n+     * @return enum member list node.\n+     */\n+    private STNode parseEnumMemberList() {\n+        startContext(ParserRuleContext.ENUM_MEMBER_LIST);\n+        List<STNode> enumMemberList = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Report an empty enum member list\n+        if (nextToken.kind == SyntaxKind.CLOSE_BRACE_TOKEN) {\n+            this.errorHandler.reportMissingTokenError(\"enum member list cannot be empty\");\n+            return STNodeFactory.createNodeList(new ArrayList<>());\n+        }\n+\n+        // Parse first enum member, that has no leading comma\n+        STNode enumMember = parseEnumMember();\n+\n+        // Parse the remaining enum members\n+        nextToken = peek();\n+        STNode enumMemberRhs;\n+        while (nextToken.kind != SyntaxKind.CLOSE_BRACE_TOKEN) {\n+            enumMemberRhs = parseEnumMemberRhs(nextToken.kind);\n+            if (enumMemberRhs == null) {\n+                break;\n+            }\n+            enumMemberList.add(enumMember);\n+            enumMemberList.add(enumMemberRhs);\n+            enumMember = parseEnumMember();\n+            nextToken = peek();\n+        }\n+\n+        enumMemberList.add(enumMember);\n+\n+        endContext();\n+        return STNodeFactory.createNodeList(enumMemberList);\n+    }\n+\n+    /**\n+     * Parse enum member.\n+     * <p>enum-member := metadata identifier [= const-expr]</p>\n+     *\n+     * @return Parsed enum member node.\n+     */\n+    private STNode parseEnumMember() {\n+        STToken nextToken = peek();\n+        STNode metadata;\n+        switch (nextToken.kind) {\n+            case DOCUMENTATION_LINE:\n+            case AT_TOKEN:\n+                metadata = parseMetaData(nextToken.kind);\n+                break;\n+            default:\n+                metadata = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode identifierNode = parseIdentifier(ParserRuleContext.ENUM_MEMBER_NAME);\n+        return parseEnumMemberInternalRhs(metadata, identifierNode);\n+    }\n+\n+    private STNode parseEnumMemberInternalRhs(STNode metadata, STNode identifierNode) {\n+        return parseEnumMemberInternalRhs(metadata, identifierNode, peek().kind);\n+    }\n+\n+    private STNode parseEnumMemberInternalRhs(STNode metadata, STNode identifierNode, SyntaxKind nextToken) {", "originalCommit": "126f69cb7996d944324fa820a43b45288ae77074", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU0MDcwNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23450#discussion_r429540704", "bodyText": "Let's have the SyntaxKind nextToken as the first param. Thats the pattern we have followed elsewhere...", "author": "SupunS", "createdAt": "2020-05-23T12:14:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU0MDY3Mw=="}], "type": "inlineReview"}]}