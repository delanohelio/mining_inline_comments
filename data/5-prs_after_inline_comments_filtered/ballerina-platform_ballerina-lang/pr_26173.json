{"pr_number": 26173, "pr_title": "Add missing similarity criteria between array and tuple types ", "pr_createdAt": "2020-10-01T17:33:10Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/26173", "timeline": [{"oid": "667539fac15144c9df8406c69996fc4379fcdd42", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/667539fac15144c9df8406c69996fc4379fcdd42", "message": "Update array and tuple type logic and tests", "committedDate": "2020-10-01T14:06:56Z", "type": "commit"}, {"oid": "92f192db5e04af53cba3acfe7f1ad5f604e0c6c0", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/92f192db5e04af53cba3acfe7f1ad5f604e0c6c0", "message": "Change array state constant names", "committedDate": "2020-10-04T16:49:07Z", "type": "commit"}, {"oid": "b4a5d761508c0140ad1274a32ade6b284fa0ad63", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b4a5d761508c0140ad1274a32ade6b284fa0ad63", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into similarities_array_and_tuple", "committedDate": "2020-10-05T05:09:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE4NzQwNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26173#discussion_r500187404", "bodyText": "additional parenthesis", "author": "SupunS", "createdAt": "2020-10-06T11:02:54Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "diffHunk": "@@ -1242,32 +1247,45 @@ private static boolean checkIsArrayType(BType sourceType, BArrayType targetType,\n                 tupleTypes.add(sourceTupleType.getRestType());\n             }\n             if (tupleTypes.isEmpty()) {\n-                return targetType.getState() == ArrayState.UNSEALED || targetType.getSize() == 0;\n+                return targetType.getState() == ArrayState.OPEN || targetType.getSize() == 0;\n+            }\n+\n+            if (sourceTupleType.getRestType() != null && targetType.getState() == ArrayState.OPEN) {\n+                boolean memberTypesMatch = true;\n+                if (!(tupleTypes.isEmpty())) {", "originalCommit": "b4a5d761508c0140ad1274a32ade6b284fa0ad63", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE4Nzc4NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26173#discussion_r500187785", "bodyText": "seems theres a formatting issue here", "author": "SupunS", "createdAt": "2020-10-06T11:03:39Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "diffHunk": "@@ -1242,32 +1247,45 @@ private static boolean checkIsArrayType(BType sourceType, BArrayType targetType,\n                 tupleTypes.add(sourceTupleType.getRestType());\n             }\n             if (tupleTypes.isEmpty()) {\n-                return targetType.getState() == ArrayState.UNSEALED || targetType.getSize() == 0;\n+                return targetType.getState() == ArrayState.OPEN || targetType.getSize() == 0;\n+            }\n+\n+            if (sourceTupleType.getRestType() != null && targetType.getState() == ArrayState.OPEN) {\n+                boolean memberTypesMatch = true;\n+                if (!(tupleTypes.isEmpty())) {\n+                    for (BType sourceElementType : tupleTypes) {\n+                        if (!checkIsType(sourceElementType, targetElementType, unresolvedTypes)) {\n+                            memberTypesMatch = false;\n+                        }\n+                    }\n+                }\n+                if (memberTypesMatch) {\n+                    BType sourceRestType = sourceTupleType.getRestType();\n+                    return checkIsType (sourceRestType, targetElementType, unresolvedTypes);", "originalCommit": "b4a5d761508c0140ad1274a32ade6b284fa0ad63", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE4OTY1Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26173#discussion_r500189657", "bodyText": "We can remove this if-condition, if you bring the condition in the else-if, before this one\ni.e:\nif (sourceArrayType.getSize() < targetTypes.size()) {\n    return false;\n}\n\n// rest of the code goes here...", "author": "SupunS", "createdAt": "2020-10-06T11:07:23Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "diffHunk": "@@ -1279,32 +1297,118 @@ private static boolean checkIsArrayType(BType sourceType, BArrayType targetType,\n     }\n \n     private static boolean checkIsTupleType(BType sourceType, BTupleType targetType, List<TypePair> unresolvedTypes) {\n-        if (sourceType.getTag() != TypeTags.TUPLE_TAG) {\n-            return false;\n+        int sourceTypeTag = sourceType.getTag();\n+\n+        if (sourceTypeTag == TypeTags.UNION_TAG) {\n+            for (BType memberType : ((BUnionType) sourceType).getMemberTypes()) {\n+                if (!checkIsTupleType(memberType, targetType, unresolvedTypes)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n         }\n \n-        List<BType> sourceTypes = new ArrayList<>(((BTupleType) sourceType).getTupleTypes());\n-        BType sourceRestType = ((BTupleType) sourceType).getRestType();\n-        if (sourceRestType != null) {\n-            sourceTypes.add(sourceRestType);\n+        if (sourceTypeTag != TypeTags.ARRAY_TAG && sourceTypeTag != TypeTags.TUPLE_TAG) {\n+            return false;\n         }\n \n         List<BType> targetTypes = new ArrayList<>(targetType.getTupleTypes());\n         BType targetRestType = targetType.getRestType();\n-        if (targetRestType != null) {\n-            targetTypes.add(targetRestType);\n+\n+        BTupleType sourceTupleType = null;\n+        if (sourceTypeTag == TypeTags.TUPLE_TAG) {\n+            sourceTupleType = (BTupleType) sourceType;\n+        } else {\n+            BArrayType sourceArrayType = (BArrayType) sourceType;\n+            BType sourceElementType = sourceArrayType.getElementType();\n+\n+            switch (sourceArrayType.getState()) {\n+                case OPEN:\n+                    if (targetRestType == null) {\n+                        return false;\n+                    }\n+                    if (targetTypes.isEmpty()) {\n+                        return checkIsType(sourceElementType, targetRestType, unresolvedTypes);\n+                    }\n+                    return false;\n+                case CLOSED:\n+                    if (sourceArrayType.getSize() >= targetTypes.size()) {", "originalCommit": "b4a5d761508c0140ad1274a32ade6b284fa0ad63", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE5MDAzOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26173#discussion_r500190038", "bodyText": "better to do the memberTypesMatch check first. Then we can fail-fast", "author": "SupunS", "createdAt": "2020-10-06T11:08:09Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "diffHunk": "@@ -1279,32 +1297,118 @@ private static boolean checkIsArrayType(BType sourceType, BArrayType targetType,\n     }\n \n     private static boolean checkIsTupleType(BType sourceType, BTupleType targetType, List<TypePair> unresolvedTypes) {\n-        if (sourceType.getTag() != TypeTags.TUPLE_TAG) {\n-            return false;\n+        int sourceTypeTag = sourceType.getTag();\n+\n+        if (sourceTypeTag == TypeTags.UNION_TAG) {\n+            for (BType memberType : ((BUnionType) sourceType).getMemberTypes()) {\n+                if (!checkIsTupleType(memberType, targetType, unresolvedTypes)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n         }\n \n-        List<BType> sourceTypes = new ArrayList<>(((BTupleType) sourceType).getTupleTypes());\n-        BType sourceRestType = ((BTupleType) sourceType).getRestType();\n-        if (sourceRestType != null) {\n-            sourceTypes.add(sourceRestType);\n+        if (sourceTypeTag != TypeTags.ARRAY_TAG && sourceTypeTag != TypeTags.TUPLE_TAG) {\n+            return false;\n         }\n \n         List<BType> targetTypes = new ArrayList<>(targetType.getTupleTypes());\n         BType targetRestType = targetType.getRestType();\n-        if (targetRestType != null) {\n-            targetTypes.add(targetRestType);\n+\n+        BTupleType sourceTupleType = null;\n+        if (sourceTypeTag == TypeTags.TUPLE_TAG) {\n+            sourceTupleType = (BTupleType) sourceType;\n+        } else {\n+            BArrayType sourceArrayType = (BArrayType) sourceType;\n+            BType sourceElementType = sourceArrayType.getElementType();\n+\n+            switch (sourceArrayType.getState()) {\n+                case OPEN:\n+                    if (targetRestType == null) {\n+                        return false;\n+                    }\n+                    if (targetTypes.isEmpty()) {\n+                        return checkIsType(sourceElementType, targetRestType, unresolvedTypes);\n+                    }\n+                    return false;\n+                case CLOSED:\n+                    if (sourceArrayType.getSize() >= targetTypes.size()) {\n+                        if (targetTypes.isEmpty()) {\n+                            if (targetRestType != null) {\n+                                return checkIsType(sourceElementType, targetRestType, unresolvedTypes);\n+                            }\n+                            if (sourceArrayType.getSize() == 0) {\n+                                return true;\n+                            }\n+                            return false;\n+                        }\n+\n+                        boolean memberTypesMatch = true;\n+\n+                        for (BType targetElementType : targetTypes) {\n+                            if (!(checkIsType(sourceElementType, targetElementType, unresolvedTypes))) {\n+                                memberTypesMatch = false;\n+                            }\n+                        }\n+                        if (sourceArrayType.getSize() == targetTypes.size()) {\n+                            return memberTypesMatch;\n+                        }\n+                        if (targetRestType != null) {\n+                            return (checkIsType(sourceElementType, targetRestType, unresolvedTypes)\n+                                    && memberTypesMatch);", "originalCommit": "b4a5d761508c0140ad1274a32ade6b284fa0ad63", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE5MDY0Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26173#discussion_r500190643", "bodyText": "same as above", "author": "SupunS", "createdAt": "2020-10-06T11:09:20Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "diffHunk": "@@ -1279,32 +1297,118 @@ private static boolean checkIsArrayType(BType sourceType, BArrayType targetType,\n     }\n \n     private static boolean checkIsTupleType(BType sourceType, BTupleType targetType, List<TypePair> unresolvedTypes) {\n-        if (sourceType.getTag() != TypeTags.TUPLE_TAG) {\n-            return false;\n+        int sourceTypeTag = sourceType.getTag();\n+\n+        if (sourceTypeTag == TypeTags.UNION_TAG) {\n+            for (BType memberType : ((BUnionType) sourceType).getMemberTypes()) {\n+                if (!checkIsTupleType(memberType, targetType, unresolvedTypes)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n         }\n \n-        List<BType> sourceTypes = new ArrayList<>(((BTupleType) sourceType).getTupleTypes());\n-        BType sourceRestType = ((BTupleType) sourceType).getRestType();\n-        if (sourceRestType != null) {\n-            sourceTypes.add(sourceRestType);\n+        if (sourceTypeTag != TypeTags.ARRAY_TAG && sourceTypeTag != TypeTags.TUPLE_TAG) {\n+            return false;\n         }\n \n         List<BType> targetTypes = new ArrayList<>(targetType.getTupleTypes());\n         BType targetRestType = targetType.getRestType();\n-        if (targetRestType != null) {\n-            targetTypes.add(targetRestType);\n+\n+        BTupleType sourceTupleType = null;\n+        if (sourceTypeTag == TypeTags.TUPLE_TAG) {\n+            sourceTupleType = (BTupleType) sourceType;\n+        } else {\n+            BArrayType sourceArrayType = (BArrayType) sourceType;\n+            BType sourceElementType = sourceArrayType.getElementType();\n+\n+            switch (sourceArrayType.getState()) {\n+                case OPEN:\n+                    if (targetRestType == null) {\n+                        return false;\n+                    }\n+                    if (targetTypes.isEmpty()) {\n+                        return checkIsType(sourceElementType, targetRestType, unresolvedTypes);\n+                    }\n+                    return false;\n+                case CLOSED:\n+                    if (sourceArrayType.getSize() >= targetTypes.size()) {\n+                        if (targetTypes.isEmpty()) {\n+                            if (targetRestType != null) {\n+                                return checkIsType(sourceElementType, targetRestType, unresolvedTypes);\n+                            }\n+                            if (sourceArrayType.getSize() == 0) {\n+                                return true;\n+                            }\n+                            return false;\n+                        }\n+\n+                        boolean memberTypesMatch = true;\n+\n+                        for (BType targetElementType : targetTypes) {\n+                            if (!(checkIsType(sourceElementType, targetElementType, unresolvedTypes))) {\n+                                memberTypesMatch = false;\n+                            }\n+                        }\n+                        if (sourceArrayType.getSize() == targetTypes.size()) {\n+                            return memberTypesMatch;\n+                        }\n+                        if (targetRestType != null) {\n+                            return (checkIsType(sourceElementType, targetRestType, unresolvedTypes)\n+                                    && memberTypesMatch);\n+                        }\n+                        return false;\n+                    } else if (sourceArrayType.getSize() < targetTypes.size()) {\n+                        return false;\n+                    }\n+                    break;\n+            }\n+        }\n+\n+        List<BType> sourceTypes = new ArrayList<>(sourceTupleType.getTupleTypes());\n+        BType sourceRestType = sourceTupleType.getRestType();\n+\n+        if (sourceRestType != null && targetRestType == null) {\n+            return false;\n         }\n+        int sourceTypeSize = sourceTypes.size();\n+        int targetTypeSize = targetTypes.size();\n \n-        if (sourceTypes.size() != targetTypes.size()) {\n+        if ((sourceRestType == null && targetRestType == null) && sourceTypeSize != targetTypeSize) {\n             return false;\n         }\n \n-        for (int i = 0; i < sourceTypes.size(); i++) {\n-            if (!checkIsType(sourceTypes.get(i), targetTypes.get(i), unresolvedTypes)) {\n-                return false;\n+        boolean memberTypesMatch = true;\n+\n+        if (sourceTypeSize >= targetTypeSize) {\n+            for (int i = 0; i < targetTypeSize; i++) {\n+                if (!checkIsType(sourceTypes.get(i), targetTypes.get(i), unresolvedTypes)) {\n+                    memberTypesMatch = false;\n+                }\n+            }\n+            if (sourceTypeSize == targetTypeSize) {\n+                if (sourceRestType != null) {\n+                    return (checkIsType (sourceRestType, targetRestType, unresolvedTypes)\n+                            && memberTypesMatch);\n+                }\n+                return memberTypesMatch;\n             }\n+\n+            boolean remainingMemberTypesMatch = true;\n+\n+            for (int i = targetTypeSize; i < sourceTypeSize; i++) {\n+                if (!checkIsType(sourceTypes.get(i), targetRestType, unresolvedTypes)) {\n+                    remainingMemberTypesMatch = false;\n+                }\n+            }\n+            if (sourceRestType != null) {\n+                return (checkIsType (sourceRestType, targetRestType, unresolvedTypes)\n+                        && memberTypesMatch && remainingMemberTypesMatch);", "originalCommit": "b4a5d761508c0140ad1274a32ade6b284fa0ad63", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE5MDg4Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26173#discussion_r500190887", "bodyText": "additional parenthesis", "author": "SupunS", "createdAt": "2020-10-06T11:09:46Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "diffHunk": "@@ -1279,32 +1297,118 @@ private static boolean checkIsArrayType(BType sourceType, BArrayType targetType,\n     }\n \n     private static boolean checkIsTupleType(BType sourceType, BTupleType targetType, List<TypePair> unresolvedTypes) {\n-        if (sourceType.getTag() != TypeTags.TUPLE_TAG) {\n-            return false;\n+        int sourceTypeTag = sourceType.getTag();\n+\n+        if (sourceTypeTag == TypeTags.UNION_TAG) {\n+            for (BType memberType : ((BUnionType) sourceType).getMemberTypes()) {\n+                if (!checkIsTupleType(memberType, targetType, unresolvedTypes)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n         }\n \n-        List<BType> sourceTypes = new ArrayList<>(((BTupleType) sourceType).getTupleTypes());\n-        BType sourceRestType = ((BTupleType) sourceType).getRestType();\n-        if (sourceRestType != null) {\n-            sourceTypes.add(sourceRestType);\n+        if (sourceTypeTag != TypeTags.ARRAY_TAG && sourceTypeTag != TypeTags.TUPLE_TAG) {\n+            return false;\n         }\n \n         List<BType> targetTypes = new ArrayList<>(targetType.getTupleTypes());\n         BType targetRestType = targetType.getRestType();\n-        if (targetRestType != null) {\n-            targetTypes.add(targetRestType);\n+\n+        BTupleType sourceTupleType = null;\n+        if (sourceTypeTag == TypeTags.TUPLE_TAG) {\n+            sourceTupleType = (BTupleType) sourceType;\n+        } else {\n+            BArrayType sourceArrayType = (BArrayType) sourceType;\n+            BType sourceElementType = sourceArrayType.getElementType();\n+\n+            switch (sourceArrayType.getState()) {\n+                case OPEN:\n+                    if (targetRestType == null) {\n+                        return false;\n+                    }\n+                    if (targetTypes.isEmpty()) {\n+                        return checkIsType(sourceElementType, targetRestType, unresolvedTypes);\n+                    }\n+                    return false;\n+                case CLOSED:\n+                    if (sourceArrayType.getSize() >= targetTypes.size()) {\n+                        if (targetTypes.isEmpty()) {\n+                            if (targetRestType != null) {\n+                                return checkIsType(sourceElementType, targetRestType, unresolvedTypes);\n+                            }\n+                            if (sourceArrayType.getSize() == 0) {\n+                                return true;\n+                            }\n+                            return false;\n+                        }\n+\n+                        boolean memberTypesMatch = true;\n+\n+                        for (BType targetElementType : targetTypes) {\n+                            if (!(checkIsType(sourceElementType, targetElementType, unresolvedTypes))) {\n+                                memberTypesMatch = false;\n+                            }\n+                        }\n+                        if (sourceArrayType.getSize() == targetTypes.size()) {\n+                            return memberTypesMatch;\n+                        }\n+                        if (targetRestType != null) {\n+                            return (checkIsType(sourceElementType, targetRestType, unresolvedTypes)\n+                                    && memberTypesMatch);\n+                        }\n+                        return false;\n+                    } else if (sourceArrayType.getSize() < targetTypes.size()) {\n+                        return false;\n+                    }\n+                    break;\n+            }\n+        }\n+\n+        List<BType> sourceTypes = new ArrayList<>(sourceTupleType.getTupleTypes());\n+        BType sourceRestType = sourceTupleType.getRestType();\n+\n+        if (sourceRestType != null && targetRestType == null) {\n+            return false;\n         }\n+        int sourceTypeSize = sourceTypes.size();\n+        int targetTypeSize = targetTypes.size();\n \n-        if (sourceTypes.size() != targetTypes.size()) {\n+        if ((sourceRestType == null && targetRestType == null) && sourceTypeSize != targetTypeSize) {", "originalCommit": "b4a5d761508c0140ad1274a32ade6b284fa0ad63", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "60589a1f98d261191694dbb369e8fc86a47e3810", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/60589a1f98d261191694dbb369e8fc86a47e3810", "message": "Refactor TypeChecker", "committedDate": "2020-10-06T14:20:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ3MTQwOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26173#discussion_r500471409", "bodyText": "Shall we extract sourceTupleType.getRestType() out to a variable since it is used multiple times?", "author": "MaryamZi", "createdAt": "2020-10-06T17:26:05Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "diffHunk": "@@ -1242,32 +1247,45 @@ private static boolean checkIsArrayType(BType sourceType, BArrayType targetType,\n                 tupleTypes.add(sourceTupleType.getRestType());", "originalCommit": "60589a1f98d261191694dbb369e8fc86a47e3810", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ4Njc0MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26173#discussion_r500486740", "bodyText": "Not a change introduced by this PR, but reusing the flags from sourceTupleType when creating the union type could lead to issues. We also need to pass whether or not it is readonly.\nFor example, where the tuple is of type [int, ()] the union type would be int?. Thus even though the source tuple is not nilable, the union type is, and the flags should reflect that. Shall we switch to use the constructor that accepts readonly instead?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                new BArrayType(new BUnionType(new ArrayList<>(tupleTypes), sourceTupleType.getTypeFlags()));\n          \n          \n            \n                                new BArrayType(new BUnionType(new ArrayList<>(tupleTypes), sourceTupleType.isReadOnly()));\n          \n      \n    \n    \n  \n\nPlease check other array creations in this method too.\nShall we also add simple runtime tests for these?\ne.g.,\n    [int, ()] x = [1, ()];\n    assertTrue(<any> x is (int|string?)[]);", "author": "MaryamZi", "createdAt": "2020-10-06T17:51:25Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "diffHunk": "@@ -1242,32 +1247,45 @@ private static boolean checkIsArrayType(BType sourceType, BArrayType targetType,\n                 tupleTypes.add(sourceTupleType.getRestType());\n             }\n             if (tupleTypes.isEmpty()) {\n-                return targetType.getState() == ArrayState.UNSEALED || targetType.getSize() == 0;\n+                return targetType.getState() == ArrayState.OPEN || targetType.getSize() == 0;\n             }\n+\n+            if (sourceTupleType.getRestType() != null && targetType.getState() == ArrayState.OPEN) {\n+                boolean memberTypesMatch = true;\n+                if (!tupleTypes.isEmpty()) {\n+                    for (BType sourceElementType : tupleTypes) {\n+                        if (!checkIsType(sourceElementType, targetElementType, unresolvedTypes)) {\n+                            memberTypesMatch = false;\n+                        }\n+                    }\n+                }\n+                if (memberTypesMatch) {\n+                    BType sourceRestType = sourceTupleType.getRestType();\n+                    return checkIsType(sourceRestType, targetElementType, unresolvedTypes);\n+                }\n+                return false;\n+            }\n+\n             sourceArrayType =\n                     new BArrayType(new BUnionType(new ArrayList<>(tupleTypes), sourceTupleType.getTypeFlags()));", "originalCommit": "60589a1f98d261191694dbb369e8fc86a47e3810", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUxNTk4NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26173#discussion_r500515984", "bodyText": "Isn't this always true because we return at L1250?", "author": "MaryamZi", "createdAt": "2020-10-06T18:37:59Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "diffHunk": "@@ -1242,32 +1247,45 @@ private static boolean checkIsArrayType(BType sourceType, BArrayType targetType,\n                 tupleTypes.add(sourceTupleType.getRestType());\n             }\n             if (tupleTypes.isEmpty()) {\n-                return targetType.getState() == ArrayState.UNSEALED || targetType.getSize() == 0;\n+                return targetType.getState() == ArrayState.OPEN || targetType.getSize() == 0;\n             }\n+\n+            if (sourceTupleType.getRestType() != null && targetType.getState() == ArrayState.OPEN) {\n+                boolean memberTypesMatch = true;\n+                if (!tupleTypes.isEmpty()) {", "originalCommit": "60589a1f98d261191694dbb369e8fc86a47e3810", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUyMjM4MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26173#discussion_r500522380", "bodyText": "Since the rest type is added to tupleTypes in L1247, isn't this checked already?\nWhy do we need to special case the sourceTupleType.getRestType() != null && targetType.getState() == ArrayState.OPEN scenario anyway?\nShouldn't we special case the scenario where the target type is a closed array instead? The following should pass, but doesn't atm.\n    [int, ()] x = [1, ()];\n    assertTrue(<any> x is (string|int?)[2]);\nWhen the target array is open, can't we let the flow to continue by setting the proper state to sourceArrayType?\ni.e.,\n\ntuple type with no rest type - CLOSED\ntuple type with rest type - OPEN", "author": "MaryamZi", "createdAt": "2020-10-06T18:49:04Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "diffHunk": "@@ -1242,32 +1247,45 @@ private static boolean checkIsArrayType(BType sourceType, BArrayType targetType,\n                 tupleTypes.add(sourceTupleType.getRestType());\n             }\n             if (tupleTypes.isEmpty()) {\n-                return targetType.getState() == ArrayState.UNSEALED || targetType.getSize() == 0;\n+                return targetType.getState() == ArrayState.OPEN || targetType.getSize() == 0;\n             }\n+\n+            if (sourceTupleType.getRestType() != null && targetType.getState() == ArrayState.OPEN) {\n+                boolean memberTypesMatch = true;\n+                if (!tupleTypes.isEmpty()) {\n+                    for (BType sourceElementType : tupleTypes) {\n+                        if (!checkIsType(sourceElementType, targetElementType, unresolvedTypes)) {\n+                            memberTypesMatch = false;\n+                        }\n+                    }\n+                }\n+                if (memberTypesMatch) {\n+                    BType sourceRestType = sourceTupleType.getRestType();\n+                    return checkIsType(sourceRestType, targetElementType, unresolvedTypes);\n+                }", "originalCommit": "60589a1f98d261191694dbb369e8fc86a47e3810", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU5ODgxNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26173#discussion_r503598817", "bodyText": "Ya actually the logic here is a bit wrong. I re-did the whole tuple evaluation in the checkIsArrayType().", "author": "suleka96", "createdAt": "2020-10-13T00:14:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUyMjM4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUyNjQ4Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26173#discussion_r500526486", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    if (sourceArrayType.getSize() == 0) {\n          \n          \n            \n                                        return true;\n          \n          \n            \n                                    }\n          \n          \n            \n                                    return false;\n          \n          \n            \n                                    return sourceArrayType.getSize() == 0;", "author": "MaryamZi", "createdAt": "2020-10-06T18:56:10Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "diffHunk": "@@ -1279,32 +1297,115 @@ private static boolean checkIsArrayType(BType sourceType, BArrayType targetType,\n     }\n \n     private static boolean checkIsTupleType(BType sourceType, BTupleType targetType, List<TypePair> unresolvedTypes) {\n-        if (sourceType.getTag() != TypeTags.TUPLE_TAG) {\n-            return false;\n+        int sourceTypeTag = sourceType.getTag();\n+\n+        if (sourceTypeTag == TypeTags.UNION_TAG) {\n+            for (BType memberType : ((BUnionType) sourceType).getMemberTypes()) {\n+                if (!checkIsTupleType(memberType, targetType, unresolvedTypes)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n         }\n \n-        List<BType> sourceTypes = new ArrayList<>(((BTupleType) sourceType).getTupleTypes());\n-        BType sourceRestType = ((BTupleType) sourceType).getRestType();\n-        if (sourceRestType != null) {\n-            sourceTypes.add(sourceRestType);\n+        if (sourceTypeTag != TypeTags.ARRAY_TAG && sourceTypeTag != TypeTags.TUPLE_TAG) {\n+            return false;\n         }\n \n         List<BType> targetTypes = new ArrayList<>(targetType.getTupleTypes());\n         BType targetRestType = targetType.getRestType();\n-        if (targetRestType != null) {\n-            targetTypes.add(targetRestType);\n+\n+        BTupleType sourceTupleType = null;\n+        if (sourceTypeTag == TypeTags.TUPLE_TAG) {\n+            sourceTupleType = (BTupleType) sourceType;\n+        } else {\n+            BArrayType sourceArrayType = (BArrayType) sourceType;\n+            BType sourceElementType = sourceArrayType.getElementType();\n+\n+            switch (sourceArrayType.getState()) {\n+                case OPEN:\n+                    if (targetRestType == null) {\n+                        return false;\n+                    }\n+                    if (targetTypes.isEmpty()) {\n+                        return checkIsType(sourceElementType, targetRestType, unresolvedTypes);\n+                    }\n+                    return false;\n+                case CLOSED:\n+                    if (sourceArrayType.getSize() < targetTypes.size()) {\n+                        return false;\n+                    }\n+                    if (targetTypes.isEmpty()) {\n+                        if (targetRestType != null) {\n+                            return checkIsType(sourceElementType, targetRestType, unresolvedTypes);\n+                        }\n+                        if (sourceArrayType.getSize() == 0) {\n+                            return true;\n+                        }\n+                        return false;", "originalCommit": "60589a1f98d261191694dbb369e8fc86a47e3810", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUyNzQ0Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26173#discussion_r500527443", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    return (memberTypesMatch &&\n          \n          \n            \n                                            checkIsType(sourceElementType, targetRestType, unresolvedTypes));\n          \n          \n            \n                                    return memberTypesMatch &&\n          \n          \n            \n                                            checkIsType(sourceElementType, targetRestType, unresolvedTypes);", "author": "MaryamZi", "createdAt": "2020-10-06T18:57:48Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "diffHunk": "@@ -1279,32 +1297,115 @@ private static boolean checkIsArrayType(BType sourceType, BArrayType targetType,\n     }\n \n     private static boolean checkIsTupleType(BType sourceType, BTupleType targetType, List<TypePair> unresolvedTypes) {\n-        if (sourceType.getTag() != TypeTags.TUPLE_TAG) {\n-            return false;\n+        int sourceTypeTag = sourceType.getTag();\n+\n+        if (sourceTypeTag == TypeTags.UNION_TAG) {\n+            for (BType memberType : ((BUnionType) sourceType).getMemberTypes()) {\n+                if (!checkIsTupleType(memberType, targetType, unresolvedTypes)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n         }\n \n-        List<BType> sourceTypes = new ArrayList<>(((BTupleType) sourceType).getTupleTypes());\n-        BType sourceRestType = ((BTupleType) sourceType).getRestType();\n-        if (sourceRestType != null) {\n-            sourceTypes.add(sourceRestType);\n+        if (sourceTypeTag != TypeTags.ARRAY_TAG && sourceTypeTag != TypeTags.TUPLE_TAG) {\n+            return false;\n         }\n \n         List<BType> targetTypes = new ArrayList<>(targetType.getTupleTypes());\n         BType targetRestType = targetType.getRestType();\n-        if (targetRestType != null) {\n-            targetTypes.add(targetRestType);\n+\n+        BTupleType sourceTupleType = null;\n+        if (sourceTypeTag == TypeTags.TUPLE_TAG) {\n+            sourceTupleType = (BTupleType) sourceType;\n+        } else {\n+            BArrayType sourceArrayType = (BArrayType) sourceType;\n+            BType sourceElementType = sourceArrayType.getElementType();\n+\n+            switch (sourceArrayType.getState()) {\n+                case OPEN:\n+                    if (targetRestType == null) {\n+                        return false;\n+                    }\n+                    if (targetTypes.isEmpty()) {\n+                        return checkIsType(sourceElementType, targetRestType, unresolvedTypes);\n+                    }\n+                    return false;\n+                case CLOSED:\n+                    if (sourceArrayType.getSize() < targetTypes.size()) {\n+                        return false;\n+                    }\n+                    if (targetTypes.isEmpty()) {\n+                        if (targetRestType != null) {\n+                            return checkIsType(sourceElementType, targetRestType, unresolvedTypes);\n+                        }\n+                        if (sourceArrayType.getSize() == 0) {\n+                            return true;\n+                        }\n+                        return false;\n+                    }\n+                    boolean memberTypesMatch = true;\n+\n+                    for (BType targetElementType : targetTypes) {\n+                        if (!(checkIsType(sourceElementType, targetElementType, unresolvedTypes))) {\n+                            memberTypesMatch = false;\n+                        }\n+                    }\n+                    if (sourceArrayType.getSize() == targetTypes.size()) {\n+                        return memberTypesMatch;\n+                    }\n+                    if (targetRestType != null) {\n+                        return (memberTypesMatch &&\n+                                checkIsType(sourceElementType, targetRestType, unresolvedTypes));", "originalCommit": "60589a1f98d261191694dbb369e8fc86a47e3810", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUyODk3Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26173#discussion_r500528977", "bodyText": "Since we seem to be returning within the else block shall we refactor the code to do something like\nif (sourceTypeTag == TypeTags.ARRAY_TAG) { \n    // move logic in else\n}\n\nBTupleType sourceTupleType = (BTupleType) sourceType;\nReduces the indentation and the variable will be defined closer to where it is used.", "author": "MaryamZi", "createdAt": "2020-10-06T19:00:24Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "diffHunk": "@@ -1279,32 +1297,115 @@ private static boolean checkIsArrayType(BType sourceType, BArrayType targetType,\n     }\n \n     private static boolean checkIsTupleType(BType sourceType, BTupleType targetType, List<TypePair> unresolvedTypes) {\n-        if (sourceType.getTag() != TypeTags.TUPLE_TAG) {\n-            return false;\n+        int sourceTypeTag = sourceType.getTag();\n+\n+        if (sourceTypeTag == TypeTags.UNION_TAG) {\n+            for (BType memberType : ((BUnionType) sourceType).getMemberTypes()) {\n+                if (!checkIsTupleType(memberType, targetType, unresolvedTypes)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n         }\n \n-        List<BType> sourceTypes = new ArrayList<>(((BTupleType) sourceType).getTupleTypes());\n-        BType sourceRestType = ((BTupleType) sourceType).getRestType();\n-        if (sourceRestType != null) {\n-            sourceTypes.add(sourceRestType);\n+        if (sourceTypeTag != TypeTags.ARRAY_TAG && sourceTypeTag != TypeTags.TUPLE_TAG) {\n+            return false;\n         }\n \n         List<BType> targetTypes = new ArrayList<>(targetType.getTupleTypes());\n         BType targetRestType = targetType.getRestType();\n-        if (targetRestType != null) {\n-            targetTypes.add(targetRestType);\n+\n+        BTupleType sourceTupleType = null;\n+        if (sourceTypeTag == TypeTags.TUPLE_TAG) {\n+            sourceTupleType = (BTupleType) sourceType;\n+        } else {", "originalCommit": "60589a1f98d261191694dbb369e8fc86a47e3810", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUyOTgzNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26173#discussion_r500529837", "bodyText": "We can switch the check here also, and remove the else block.\n        if (sourceTypeSize < targetTypeSize) {\n            return false;\n        }\n\n        for (int i = 0; i < targetTypeSize; i++) {", "author": "MaryamZi", "createdAt": "2020-10-06T19:02:00Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "diffHunk": "@@ -1279,32 +1297,115 @@ private static boolean checkIsArrayType(BType sourceType, BArrayType targetType,\n     }\n \n     private static boolean checkIsTupleType(BType sourceType, BTupleType targetType, List<TypePair> unresolvedTypes) {\n-        if (sourceType.getTag() != TypeTags.TUPLE_TAG) {\n-            return false;\n+        int sourceTypeTag = sourceType.getTag();\n+\n+        if (sourceTypeTag == TypeTags.UNION_TAG) {\n+            for (BType memberType : ((BUnionType) sourceType).getMemberTypes()) {\n+                if (!checkIsTupleType(memberType, targetType, unresolvedTypes)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n         }\n \n-        List<BType> sourceTypes = new ArrayList<>(((BTupleType) sourceType).getTupleTypes());\n-        BType sourceRestType = ((BTupleType) sourceType).getRestType();\n-        if (sourceRestType != null) {\n-            sourceTypes.add(sourceRestType);\n+        if (sourceTypeTag != TypeTags.ARRAY_TAG && sourceTypeTag != TypeTags.TUPLE_TAG) {\n+            return false;\n         }\n \n         List<BType> targetTypes = new ArrayList<>(targetType.getTupleTypes());\n         BType targetRestType = targetType.getRestType();\n-        if (targetRestType != null) {\n-            targetTypes.add(targetRestType);\n+\n+        BTupleType sourceTupleType = null;\n+        if (sourceTypeTag == TypeTags.TUPLE_TAG) {\n+            sourceTupleType = (BTupleType) sourceType;\n+        } else {\n+            BArrayType sourceArrayType = (BArrayType) sourceType;\n+            BType sourceElementType = sourceArrayType.getElementType();\n+\n+            switch (sourceArrayType.getState()) {\n+                case OPEN:\n+                    if (targetRestType == null) {\n+                        return false;\n+                    }\n+                    if (targetTypes.isEmpty()) {\n+                        return checkIsType(sourceElementType, targetRestType, unresolvedTypes);\n+                    }\n+                    return false;\n+                case CLOSED:\n+                    if (sourceArrayType.getSize() < targetTypes.size()) {\n+                        return false;\n+                    }\n+                    if (targetTypes.isEmpty()) {\n+                        if (targetRestType != null) {\n+                            return checkIsType(sourceElementType, targetRestType, unresolvedTypes);\n+                        }\n+                        if (sourceArrayType.getSize() == 0) {\n+                            return true;\n+                        }\n+                        return false;\n+                    }\n+                    boolean memberTypesMatch = true;\n+\n+                    for (BType targetElementType : targetTypes) {\n+                        if (!(checkIsType(sourceElementType, targetElementType, unresolvedTypes))) {\n+                            memberTypesMatch = false;\n+                        }\n+                    }\n+                    if (sourceArrayType.getSize() == targetTypes.size()) {\n+                        return memberTypesMatch;\n+                    }\n+                    if (targetRestType != null) {\n+                        return (memberTypesMatch &&\n+                                checkIsType(sourceElementType, targetRestType, unresolvedTypes));\n+                    }\n+                    return false;\n+            }\n         }\n \n-        if (sourceTypes.size() != targetTypes.size()) {\n+        List<BType> sourceTypes = new ArrayList<>(sourceTupleType.getTupleTypes());\n+        BType sourceRestType = sourceTupleType.getRestType();\n+\n+        if (sourceRestType != null && targetRestType == null) {\n             return false;\n         }\n+        int sourceTypeSize = sourceTypes.size();\n+        int targetTypeSize = targetTypes.size();\n \n-        for (int i = 0; i < sourceTypes.size(); i++) {\n-            if (!checkIsType(sourceTypes.get(i), targetTypes.get(i), unresolvedTypes)) {\n-                return false;\n+        if (sourceRestType == null && targetRestType == null && sourceTypeSize != targetTypeSize) {\n+            return false;\n+        }\n+\n+        boolean memberTypesMatch = true;\n+\n+        if (sourceTypeSize >= targetTypeSize) {", "originalCommit": "60589a1f98d261191694dbb369e8fc86a47e3810", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUzMDM1OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26173#discussion_r500530359", "bodyText": "Can't we directly return false here instead of setting it to memberTypesMatch?", "author": "MaryamZi", "createdAt": "2020-10-06T19:03:04Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "diffHunk": "@@ -1279,32 +1297,115 @@ private static boolean checkIsArrayType(BType sourceType, BArrayType targetType,\n     }\n \n     private static boolean checkIsTupleType(BType sourceType, BTupleType targetType, List<TypePair> unresolvedTypes) {\n-        if (sourceType.getTag() != TypeTags.TUPLE_TAG) {\n-            return false;\n+        int sourceTypeTag = sourceType.getTag();\n+\n+        if (sourceTypeTag == TypeTags.UNION_TAG) {\n+            for (BType memberType : ((BUnionType) sourceType).getMemberTypes()) {\n+                if (!checkIsTupleType(memberType, targetType, unresolvedTypes)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n         }\n \n-        List<BType> sourceTypes = new ArrayList<>(((BTupleType) sourceType).getTupleTypes());\n-        BType sourceRestType = ((BTupleType) sourceType).getRestType();\n-        if (sourceRestType != null) {\n-            sourceTypes.add(sourceRestType);\n+        if (sourceTypeTag != TypeTags.ARRAY_TAG && sourceTypeTag != TypeTags.TUPLE_TAG) {\n+            return false;\n         }\n \n         List<BType> targetTypes = new ArrayList<>(targetType.getTupleTypes());\n         BType targetRestType = targetType.getRestType();\n-        if (targetRestType != null) {\n-            targetTypes.add(targetRestType);\n+\n+        BTupleType sourceTupleType = null;\n+        if (sourceTypeTag == TypeTags.TUPLE_TAG) {\n+            sourceTupleType = (BTupleType) sourceType;\n+        } else {\n+            BArrayType sourceArrayType = (BArrayType) sourceType;\n+            BType sourceElementType = sourceArrayType.getElementType();\n+\n+            switch (sourceArrayType.getState()) {\n+                case OPEN:\n+                    if (targetRestType == null) {\n+                        return false;\n+                    }\n+                    if (targetTypes.isEmpty()) {\n+                        return checkIsType(sourceElementType, targetRestType, unresolvedTypes);\n+                    }\n+                    return false;\n+                case CLOSED:\n+                    if (sourceArrayType.getSize() < targetTypes.size()) {\n+                        return false;\n+                    }\n+                    if (targetTypes.isEmpty()) {\n+                        if (targetRestType != null) {\n+                            return checkIsType(sourceElementType, targetRestType, unresolvedTypes);\n+                        }\n+                        if (sourceArrayType.getSize() == 0) {\n+                            return true;\n+                        }\n+                        return false;\n+                    }\n+                    boolean memberTypesMatch = true;\n+\n+                    for (BType targetElementType : targetTypes) {\n+                        if (!(checkIsType(sourceElementType, targetElementType, unresolvedTypes))) {\n+                            memberTypesMatch = false;\n+                        }\n+                    }\n+                    if (sourceArrayType.getSize() == targetTypes.size()) {\n+                        return memberTypesMatch;\n+                    }\n+                    if (targetRestType != null) {\n+                        return (memberTypesMatch &&\n+                                checkIsType(sourceElementType, targetRestType, unresolvedTypes));\n+                    }\n+                    return false;\n+            }\n         }\n \n-        if (sourceTypes.size() != targetTypes.size()) {\n+        List<BType> sourceTypes = new ArrayList<>(sourceTupleType.getTupleTypes());\n+        BType sourceRestType = sourceTupleType.getRestType();\n+\n+        if (sourceRestType != null && targetRestType == null) {\n             return false;\n         }\n+        int sourceTypeSize = sourceTypes.size();\n+        int targetTypeSize = targetTypes.size();\n \n-        for (int i = 0; i < sourceTypes.size(); i++) {\n-            if (!checkIsType(sourceTypes.get(i), targetTypes.get(i), unresolvedTypes)) {\n-                return false;\n+        if (sourceRestType == null && targetRestType == null && sourceTypeSize != targetTypeSize) {\n+            return false;\n+        }\n+\n+        boolean memberTypesMatch = true;\n+\n+        if (sourceTypeSize >= targetTypeSize) {\n+            for (int i = 0; i < targetTypeSize; i++) {\n+                if (!checkIsType(sourceTypes.get(i), targetTypes.get(i), unresolvedTypes)) {\n+                    memberTypesMatch = false;", "originalCommit": "60589a1f98d261191694dbb369e8fc86a47e3810", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUzMDgxMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26173#discussion_r500530812", "bodyText": "Check remainingMemberTypesMatch too.", "author": "MaryamZi", "createdAt": "2020-10-06T19:03:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUzMDM1OQ=="}], "type": "inlineReview"}, {"oid": "f31cc4c0bf955202d16b4d38cf10615c118a35ea", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f31cc4c0bf955202d16b4d38cf10615c118a35ea", "message": "Update source array evaluation logic", "committedDate": "2020-10-13T07:08:29Z", "type": "commit"}, {"oid": "57f54c19ccde8e987aff4a61a368958712224680", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/57f54c19ccde8e987aff4a61a368958712224680", "message": "Refactor code", "committedDate": "2020-10-13T07:31:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ2NTEyNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26173#discussion_r504465124", "bodyText": "With the new changes we only seem to be using this sourceArrayType when the source itself is an array, and it is always (BArrayType) sourceType.\nI think we can clean this up a bit, and define two methods for when the source is an array vs when the source is a tuple and call them from here.\nprivate static boolean checkIsArrayType(BArrayType sourceType, BArrayType targetType, List<TypePair> unresolvedTypes)\nand\nprivate static boolean checkIsArrayType(BTupleType sourceType, BArrayType targetType, List<TypePair> unresolvedTypes)", "author": "MaryamZi", "createdAt": "2020-10-14T07:38:52Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "diffHunk": "@@ -1228,82 +1230,174 @@ private static boolean checkIsArrayType(BType sourceType, BArrayType targetType,\n             return true;\n         }\n \n-        if (sourceType.getTag() != TypeTags.ARRAY_TAG && sourceType.getTag() != TypeTags.TUPLE_TAG) {\n+        if (sourceTypeTag != TypeTags.ARRAY_TAG && sourceTypeTag != TypeTags.TUPLE_TAG) {\n             return false;\n         }\n \n+        BType targetElementType = targetType.getElementType();\n+        int targetElementTypeTag = targetElementType.getTag();\n+\n         BArrayType sourceArrayType;", "originalCommit": "57f54c19ccde8e987aff4a61a368958712224680", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ2NzEyMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26173#discussion_r504467123", "bodyText": "IMO we can remove this special-casing, since checkIsType does pretty much the same.", "author": "MaryamZi", "createdAt": "2020-10-14T07:42:24Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "diffHunk": "@@ -1228,82 +1230,174 @@ private static boolean checkIsArrayType(BType sourceType, BArrayType targetType,\n             return true;\n         }\n \n-        if (sourceType.getTag() != TypeTags.ARRAY_TAG && sourceType.getTag() != TypeTags.TUPLE_TAG) {\n+        if (sourceTypeTag != TypeTags.ARRAY_TAG && sourceTypeTag != TypeTags.TUPLE_TAG) {\n             return false;\n         }\n \n+        BType targetElementType = targetType.getElementType();\n+        int targetElementTypeTag = targetElementType.getTag();\n+\n         BArrayType sourceArrayType;\n-        if (sourceType.getTag() == TypeTags.ARRAY_TAG) {\n+        if (sourceTypeTag == TypeTags.ARRAY_TAG) {\n             sourceArrayType = (BArrayType) sourceType;\n         } else {\n             BTupleType sourceTupleType = (BTupleType) sourceType;\n             Set<BType> tupleTypes = new HashSet<>(sourceTupleType.getTupleTypes());\n-            if (sourceTupleType.getRestType() != null) {\n-                tupleTypes.add(sourceTupleType.getRestType());\n+            BType sourceRestType = sourceTupleType.getRestType();\n+\n+            if (sourceRestType != null) {\n+                tupleTypes.add(sourceRestType);\n             }\n+\n             if (tupleTypes.isEmpty()) {\n-                return targetType.getState() == ArrayState.UNSEALED || targetType.getSize() == 0;\n+                return targetType.getState() == ArrayState.OPEN || targetType.getSize() == 0;\n             }\n-            sourceArrayType =\n-                    new BArrayType(new BUnionType(new ArrayList<>(tupleTypes), sourceTupleType.getTypeFlags()));\n+\n+            if (targetType.getState() == ArrayState.CLOSED) {\n+                if (sourceRestType != null) {\n+                    return false;\n+                }\n+                if (tupleTypes.size() != targetType.getSize()) {\n+                    return false;\n+                }\n+                for (BType sourceElementType : tupleTypes) {\n+                    if (!checkIsType(sourceElementType, targetElementType, unresolvedTypes)) {\n+                        return false;\n+                    }\n+                }\n+            } else {\n+                for (BType sourceElementType : tupleTypes) {\n+                    if (!checkIsType(sourceElementType, targetElementType, unresolvedTypes)) {\n+                        return false;\n+                    }\n+                }\n+            }\n+            return true;\n         }\n \n+        BType sourceElementType = sourceArrayType.getElementType();\n+\n         switch (sourceArrayType.getState()) {\n-            case UNSEALED:\n-                if (targetType.getState() != ArrayState.UNSEALED) {\n+            case OPEN:\n+                if (targetType.getState() != ArrayState.OPEN) {\n                     return false;\n                 }\n                 break;\n-            case CLOSED_SEALED:\n-                if (targetType.getState() == ArrayState.CLOSED_SEALED &&\n+            case CLOSED:\n+                if (targetType.getState() == ArrayState.CLOSED &&\n                         sourceArrayType.getSize() != targetType.getSize()) {\n                     return false;\n                 }\n                 break;\n         }\n \n-        //If element type is a value type, then check same type\n-        BType targetElementType = targetType.getElementType();\n-        int targetElementTypeTag = targetElementType.getTag();\n-\n-        BType sourceElementType = sourceArrayType.getElementType();\n-\n         if (targetElementTypeTag <= TypeTags.BOOLEAN_TAG) {\n             if (targetElementTypeTag == TypeTags.INT_TAG && sourceElementType.getTag() == TypeTags.BYTE_TAG) {\n                 return true;\n             }\n \n             return sourceElementType.getTag() == targetElementTypeTag;\n         }", "originalCommit": "57f54c19ccde8e987aff4a61a368958712224680", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ3NjU0Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26173#discussion_r504476547", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        } else {\n          \n          \n            \n                            for (BType sourceElementType : tupleTypes) {\n          \n          \n            \n                                if (!checkIsType(sourceElementType, targetElementType, unresolvedTypes)) {\n          \n          \n            \n                                    return false;\n          \n          \n            \n                                }\n          \n          \n            \n                            }\n          \n          \n            \n                        }\n          \n          \n            \n                        return true;\n          \n          \n            \n                            return true;\n          \n          \n            \n                        }\n          \n          \n            \n                        for (BType sourceElementType : tupleTypes) {\n          \n          \n            \n                            if (!checkIsType(sourceElementType, targetElementType, unresolvedTypes)) {\n          \n          \n            \n                                return false;\n          \n          \n            \n                            }\n          \n          \n            \n                        }\n          \n          \n            \n                        return true;\n          \n      \n    \n    \n  \n\nWe can also switch the first check to be targetType.getState() == ArrayState.OPEN and reduce the number of lines of code that is indented.", "author": "MaryamZi", "createdAt": "2020-10-14T07:58:17Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "diffHunk": "@@ -1228,82 +1230,174 @@ private static boolean checkIsArrayType(BType sourceType, BArrayType targetType,\n             return true;\n         }\n \n-        if (sourceType.getTag() != TypeTags.ARRAY_TAG && sourceType.getTag() != TypeTags.TUPLE_TAG) {\n+        if (sourceTypeTag != TypeTags.ARRAY_TAG && sourceTypeTag != TypeTags.TUPLE_TAG) {\n             return false;\n         }\n \n+        BType targetElementType = targetType.getElementType();\n+        int targetElementTypeTag = targetElementType.getTag();\n+\n         BArrayType sourceArrayType;\n-        if (sourceType.getTag() == TypeTags.ARRAY_TAG) {\n+        if (sourceTypeTag == TypeTags.ARRAY_TAG) {\n             sourceArrayType = (BArrayType) sourceType;\n         } else {\n             BTupleType sourceTupleType = (BTupleType) sourceType;\n             Set<BType> tupleTypes = new HashSet<>(sourceTupleType.getTupleTypes());\n-            if (sourceTupleType.getRestType() != null) {\n-                tupleTypes.add(sourceTupleType.getRestType());\n+            BType sourceRestType = sourceTupleType.getRestType();\n+\n+            if (sourceRestType != null) {\n+                tupleTypes.add(sourceRestType);\n             }\n+\n             if (tupleTypes.isEmpty()) {\n-                return targetType.getState() == ArrayState.UNSEALED || targetType.getSize() == 0;\n+                return targetType.getState() == ArrayState.OPEN || targetType.getSize() == 0;\n             }\n-            sourceArrayType =\n-                    new BArrayType(new BUnionType(new ArrayList<>(tupleTypes), sourceTupleType.getTypeFlags()));\n+\n+            if (targetType.getState() == ArrayState.CLOSED) {\n+                if (sourceRestType != null) {\n+                    return false;\n+                }\n+                if (tupleTypes.size() != targetType.getSize()) {\n+                    return false;\n+                }\n+                for (BType sourceElementType : tupleTypes) {\n+                    if (!checkIsType(sourceElementType, targetElementType, unresolvedTypes)) {\n+                        return false;\n+                    }\n+                }\n+            } else {\n+                for (BType sourceElementType : tupleTypes) {\n+                    if (!checkIsType(sourceElementType, targetElementType, unresolvedTypes)) {\n+                        return false;\n+                    }\n+                }\n+            }\n+            return true;", "originalCommit": "57f54c19ccde8e987aff4a61a368958712224680", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ3NzY1NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26173#discussion_r504477654", "bodyText": "Have we added tests for this? Where the source type is a union of lists?", "author": "MaryamZi", "createdAt": "2020-10-14T08:00:01Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "diffHunk": "@@ -1228,82 +1230,174 @@ private static boolean checkIsArrayType(BType sourceType, BArrayType targetType,\n             return true;\n         }\n \n-        if (sourceType.getTag() != TypeTags.ARRAY_TAG && sourceType.getTag() != TypeTags.TUPLE_TAG) {\n+        if (sourceTypeTag != TypeTags.ARRAY_TAG && sourceTypeTag != TypeTags.TUPLE_TAG) {\n             return false;\n         }\n \n+        BType targetElementType = targetType.getElementType();\n+        int targetElementTypeTag = targetElementType.getTag();\n+\n         BArrayType sourceArrayType;\n-        if (sourceType.getTag() == TypeTags.ARRAY_TAG) {\n+        if (sourceTypeTag == TypeTags.ARRAY_TAG) {\n             sourceArrayType = (BArrayType) sourceType;\n         } else {\n             BTupleType sourceTupleType = (BTupleType) sourceType;\n             Set<BType> tupleTypes = new HashSet<>(sourceTupleType.getTupleTypes());\n-            if (sourceTupleType.getRestType() != null) {\n-                tupleTypes.add(sourceTupleType.getRestType());\n+            BType sourceRestType = sourceTupleType.getRestType();\n+\n+            if (sourceRestType != null) {\n+                tupleTypes.add(sourceRestType);\n             }\n+\n             if (tupleTypes.isEmpty()) {\n-                return targetType.getState() == ArrayState.UNSEALED || targetType.getSize() == 0;\n+                return targetType.getState() == ArrayState.OPEN || targetType.getSize() == 0;\n             }\n-            sourceArrayType =\n-                    new BArrayType(new BUnionType(new ArrayList<>(tupleTypes), sourceTupleType.getTypeFlags()));\n+\n+            if (targetType.getState() == ArrayState.CLOSED) {\n+                if (sourceRestType != null) {\n+                    return false;\n+                }\n+                if (tupleTypes.size() != targetType.getSize()) {\n+                    return false;\n+                }\n+                for (BType sourceElementType : tupleTypes) {\n+                    if (!checkIsType(sourceElementType, targetElementType, unresolvedTypes)) {\n+                        return false;\n+                    }\n+                }\n+            } else {\n+                for (BType sourceElementType : tupleTypes) {\n+                    if (!checkIsType(sourceElementType, targetElementType, unresolvedTypes)) {\n+                        return false;\n+                    }\n+                }\n+            }\n+            return true;\n         }\n \n+        BType sourceElementType = sourceArrayType.getElementType();\n+\n         switch (sourceArrayType.getState()) {\n-            case UNSEALED:\n-                if (targetType.getState() != ArrayState.UNSEALED) {\n+            case OPEN:\n+                if (targetType.getState() != ArrayState.OPEN) {\n                     return false;\n                 }\n                 break;\n-            case CLOSED_SEALED:\n-                if (targetType.getState() == ArrayState.CLOSED_SEALED &&\n+            case CLOSED:\n+                if (targetType.getState() == ArrayState.CLOSED &&\n                         sourceArrayType.getSize() != targetType.getSize()) {\n                     return false;\n                 }\n                 break;\n         }\n \n-        //If element type is a value type, then check same type\n-        BType targetElementType = targetType.getElementType();\n-        int targetElementTypeTag = targetElementType.getTag();\n-\n-        BType sourceElementType = sourceArrayType.getElementType();\n-\n         if (targetElementTypeTag <= TypeTags.BOOLEAN_TAG) {\n             if (targetElementTypeTag == TypeTags.INT_TAG && sourceElementType.getTag() == TypeTags.BYTE_TAG) {\n                 return true;\n             }\n \n             return sourceElementType.getTag() == targetElementTypeTag;\n         }\n+\n         return checkIsType(sourceElementType, targetElementType, unresolvedTypes);\n     }\n \n     private static boolean checkIsTupleType(BType sourceType, BTupleType targetType, List<TypePair> unresolvedTypes) {\n-        if (sourceType.getTag() != TypeTags.TUPLE_TAG) {\n-            return false;\n+        int sourceTypeTag = sourceType.getTag();\n+\n+        if (sourceTypeTag == TypeTags.UNION_TAG) {", "originalCommit": "57f54c19ccde8e987aff4a61a368958712224680", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ3ODA2MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26173#discussion_r504478060", "bodyText": "Let's extract these two scenarios also to two methods.", "author": "MaryamZi", "createdAt": "2020-10-14T08:00:34Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "diffHunk": "@@ -1228,82 +1230,174 @@ private static boolean checkIsArrayType(BType sourceType, BArrayType targetType,\n             return true;\n         }\n \n-        if (sourceType.getTag() != TypeTags.ARRAY_TAG && sourceType.getTag() != TypeTags.TUPLE_TAG) {\n+        if (sourceTypeTag != TypeTags.ARRAY_TAG && sourceTypeTag != TypeTags.TUPLE_TAG) {\n             return false;\n         }\n \n+        BType targetElementType = targetType.getElementType();\n+        int targetElementTypeTag = targetElementType.getTag();\n+\n         BArrayType sourceArrayType;\n-        if (sourceType.getTag() == TypeTags.ARRAY_TAG) {\n+        if (sourceTypeTag == TypeTags.ARRAY_TAG) {\n             sourceArrayType = (BArrayType) sourceType;\n         } else {\n             BTupleType sourceTupleType = (BTupleType) sourceType;\n             Set<BType> tupleTypes = new HashSet<>(sourceTupleType.getTupleTypes());\n-            if (sourceTupleType.getRestType() != null) {\n-                tupleTypes.add(sourceTupleType.getRestType());\n+            BType sourceRestType = sourceTupleType.getRestType();\n+\n+            if (sourceRestType != null) {\n+                tupleTypes.add(sourceRestType);\n             }\n+\n             if (tupleTypes.isEmpty()) {\n-                return targetType.getState() == ArrayState.UNSEALED || targetType.getSize() == 0;\n+                return targetType.getState() == ArrayState.OPEN || targetType.getSize() == 0;\n             }\n-            sourceArrayType =\n-                    new BArrayType(new BUnionType(new ArrayList<>(tupleTypes), sourceTupleType.getTypeFlags()));\n+\n+            if (targetType.getState() == ArrayState.CLOSED) {\n+                if (sourceRestType != null) {\n+                    return false;\n+                }\n+                if (tupleTypes.size() != targetType.getSize()) {\n+                    return false;\n+                }\n+                for (BType sourceElementType : tupleTypes) {\n+                    if (!checkIsType(sourceElementType, targetElementType, unresolvedTypes)) {\n+                        return false;\n+                    }\n+                }\n+            } else {\n+                for (BType sourceElementType : tupleTypes) {\n+                    if (!checkIsType(sourceElementType, targetElementType, unresolvedTypes)) {\n+                        return false;\n+                    }\n+                }\n+            }\n+            return true;\n         }\n \n+        BType sourceElementType = sourceArrayType.getElementType();\n+\n         switch (sourceArrayType.getState()) {\n-            case UNSEALED:\n-                if (targetType.getState() != ArrayState.UNSEALED) {\n+            case OPEN:\n+                if (targetType.getState() != ArrayState.OPEN) {\n                     return false;\n                 }\n                 break;\n-            case CLOSED_SEALED:\n-                if (targetType.getState() == ArrayState.CLOSED_SEALED &&\n+            case CLOSED:\n+                if (targetType.getState() == ArrayState.CLOSED &&\n                         sourceArrayType.getSize() != targetType.getSize()) {\n                     return false;\n                 }\n                 break;\n         }\n \n-        //If element type is a value type, then check same type\n-        BType targetElementType = targetType.getElementType();\n-        int targetElementTypeTag = targetElementType.getTag();\n-\n-        BType sourceElementType = sourceArrayType.getElementType();\n-\n         if (targetElementTypeTag <= TypeTags.BOOLEAN_TAG) {\n             if (targetElementTypeTag == TypeTags.INT_TAG && sourceElementType.getTag() == TypeTags.BYTE_TAG) {\n                 return true;\n             }\n \n             return sourceElementType.getTag() == targetElementTypeTag;\n         }\n+\n         return checkIsType(sourceElementType, targetElementType, unresolvedTypes);\n     }\n \n     private static boolean checkIsTupleType(BType sourceType, BTupleType targetType, List<TypePair> unresolvedTypes) {\n-        if (sourceType.getTag() != TypeTags.TUPLE_TAG) {\n-            return false;\n+        int sourceTypeTag = sourceType.getTag();\n+\n+        if (sourceTypeTag == TypeTags.UNION_TAG) {\n+            for (BType memberType : ((BUnionType) sourceType).getMemberTypes()) {\n+                if (!checkIsTupleType(memberType, targetType, unresolvedTypes)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n         }\n \n-        List<BType> sourceTypes = new ArrayList<>(((BTupleType) sourceType).getTupleTypes());\n-        BType sourceRestType = ((BTupleType) sourceType).getRestType();\n-        if (sourceRestType != null) {\n-            sourceTypes.add(sourceRestType);\n+        if (sourceTypeTag != TypeTags.ARRAY_TAG && sourceTypeTag != TypeTags.TUPLE_TAG) {\n+            return false;\n         }\n \n         List<BType> targetTypes = new ArrayList<>(targetType.getTupleTypes());\n         BType targetRestType = targetType.getRestType();\n-        if (targetRestType != null) {\n-            targetTypes.add(targetRestType);\n+\n+        if (sourceTypeTag == TypeTags.ARRAY_TAG) {", "originalCommit": "57f54c19ccde8e987aff4a61a368958712224680", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ4MjIyMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26173#discussion_r504482223", "bodyText": "Instead of adding the rest-descriptor to tupleTypes can we handle it separately?\nFor example,\n\nif the target array is closed, the source cannot have a rest-descriptor (return false directly). If there is no rest-descriptor it may be valid, so check each member against the target array's element type - we seem to be doing this already\nif the target array is open, check member types against element type, and then check the rest-descriptor against the target element type separately - add another check to the else block below", "author": "MaryamZi", "createdAt": "2020-10-14T08:07:35Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "diffHunk": "@@ -1228,82 +1230,174 @@ private static boolean checkIsArrayType(BType sourceType, BArrayType targetType,\n             return true;\n         }\n \n-        if (sourceType.getTag() != TypeTags.ARRAY_TAG && sourceType.getTag() != TypeTags.TUPLE_TAG) {\n+        if (sourceTypeTag != TypeTags.ARRAY_TAG && sourceTypeTag != TypeTags.TUPLE_TAG) {\n             return false;\n         }\n \n+        BType targetElementType = targetType.getElementType();\n+        int targetElementTypeTag = targetElementType.getTag();\n+\n         BArrayType sourceArrayType;\n-        if (sourceType.getTag() == TypeTags.ARRAY_TAG) {\n+        if (sourceTypeTag == TypeTags.ARRAY_TAG) {\n             sourceArrayType = (BArrayType) sourceType;\n         } else {\n             BTupleType sourceTupleType = (BTupleType) sourceType;\n             Set<BType> tupleTypes = new HashSet<>(sourceTupleType.getTupleTypes());\n-            if (sourceTupleType.getRestType() != null) {\n-                tupleTypes.add(sourceTupleType.getRestType());\n+            BType sourceRestType = sourceTupleType.getRestType();\n+\n+            if (sourceRestType != null) {\n+                tupleTypes.add(sourceRestType);", "originalCommit": "57f54c19ccde8e987aff4a61a368958712224680", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1774964f3ee6ccaeed0a194a68a459e5ae1a6e22", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1774964f3ee6ccaeed0a194a68a459e5ae1a6e22", "message": "Refactor TypeChecker", "committedDate": "2020-10-20T10:57:09Z", "type": "commit"}, {"oid": "6852e4d783e7ccfc02edfadf8982fca316855712", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6852e4d783e7ccfc02edfadf8982fca316855712", "message": "Fix merge issues", "committedDate": "2020-10-20T11:56:38Z", "type": "commit"}, {"oid": "c788e911da0f0c7bfb3def5e5d2291041b5e819e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c788e911da0f0c7bfb3def5e5d2291041b5e819e", "message": "Refactor TypeChecker", "committedDate": "2020-10-20T12:24:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU4MjMxOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26173#discussion_r508582318", "bodyText": "Since these are only used in L1267 we can move these to immediately before L1267 or just remove these and change that to\nreturn checkIsType(sourceType.getElementType(), targetType.getElementType(), unresolvedTypes);", "author": "MaryamZi", "createdAt": "2020-10-20T14:57:18Z", "path": "bvm/ballerina-runtime/src/main/java/io/ballerina/runtime/TypeChecker.java", "diffHunk": "@@ -1246,8 +1246,62 @@ private static boolean hasIncompatibleReadOnlyFlags(Field targetField, Field sou\n                                                                                          Flags.READONLY);\n     }\n \n+    private static boolean checkIsArrayType(BArrayType sourceType, BArrayType targetType,\n+                                            List<TypePair> unresolvedTypes) {\n+        Type sourceElementType = sourceType.getElementType();\n+        Type targetElementType = targetType.getElementType();", "originalCommit": "c788e911da0f0c7bfb3def5e5d2291041b5e819e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU4OTEwNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26173#discussion_r508589107", "bodyText": "Do we need a new set here? Can't we just work with the list returned by sourceType.getTupleTypes()?", "author": "MaryamZi", "createdAt": "2020-10-20T15:05:39Z", "path": "bvm/ballerina-runtime/src/main/java/io/ballerina/runtime/TypeChecker.java", "diffHunk": "@@ -1246,8 +1246,62 @@ private static boolean hasIncompatibleReadOnlyFlags(Field targetField, Field sou\n                                                                                          Flags.READONLY);\n     }\n \n+    private static boolean checkIsArrayType(BArrayType sourceType, BArrayType targetType,\n+                                            List<TypePair> unresolvedTypes) {\n+        Type sourceElementType = sourceType.getElementType();\n+        Type targetElementType = targetType.getElementType();\n+\n+        switch (sourceType.getState()) {\n+            case OPEN:\n+                if (targetType.getState() != ArrayState.OPEN) {\n+                    return false;\n+                }\n+                break;\n+            case CLOSED:\n+                if (targetType.getState() == ArrayState.CLOSED &&\n+                        sourceType.getSize() != targetType.getSize()) {\n+                    return false;\n+                }\n+                break;\n+        }\n+        return checkIsType(sourceElementType, targetElementType, unresolvedTypes);\n+    }\n+\n+    private static boolean checkIsArrayType(BTupleType sourceType, BArrayType targetType,\n+                                            List<TypePair> unresolvedTypes) {\n+        Set<Type> tupleTypes = new HashSet<>(sourceType.getTupleTypes());", "originalCommit": "c788e911da0f0c7bfb3def5e5d2291041b5e819e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU5MjQ2MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26173#discussion_r508592460", "bodyText": "Here again, for both sourceTypes and targetTypes, since we are no longer adding the rest types to these lists we can directly use the lists returned by getTupleTypes() instead of creating new lists.", "author": "MaryamZi", "createdAt": "2020-10-20T15:09:50Z", "path": "bvm/ballerina-runtime/src/main/java/io/ballerina/runtime/TypeChecker.java", "diffHunk": "@@ -1256,83 +1310,123 @@ private static boolean checkIsArrayType(Type sourceType, BArrayType targetType,\n             return true;\n         }\n \n-        if (sourceType.getTag() != TypeTags.ARRAY_TAG && sourceType.getTag() != TypeTags.TUPLE_TAG) {\n+        if (sourceTypeTag != TypeTags.ARRAY_TAG && sourceTypeTag != TypeTags.TUPLE_TAG) {\n             return false;\n         }\n \n-        BArrayType sourceArrayType;\n-        if (sourceType.getTag() == TypeTags.ARRAY_TAG) {\n-            sourceArrayType = (BArrayType) sourceType;\n-        } else {\n-            BTupleType sourceTupleType = (BTupleType) sourceType;\n-            Set<Type> tupleTypes = new HashSet<>(sourceTupleType.getTupleTypes());\n-            if (sourceTupleType.getRestType() != null) {\n-                tupleTypes.add(sourceTupleType.getRestType());\n-            }\n-            if (tupleTypes.isEmpty()) {\n-                return targetType.getState() == ArrayType.ArrayState.UNSEALED || targetType.getSize() == 0;\n-            }\n-            sourceArrayType =\n-                    new BArrayType(new BUnionType(new ArrayList<>(tupleTypes), sourceTupleType.getTypeFlags()));\n+        if (sourceTypeTag == TypeTags.ARRAY_TAG) {\n+            return checkIsArrayType((BArrayType) sourceType, targetType, unresolvedTypes);\n         }\n+        return checkIsArrayType((BTupleType) sourceType, targetType, unresolvedTypes);\n+    }\n \n-        switch (sourceArrayType.getState()) {\n-            case UNSEALED:\n-                if (targetType.getState() != ArrayType.ArrayState.UNSEALED) {\n+    private static boolean checkIsTupleType(BArrayType sourceType, BTupleType targetType,\n+                                            List<TypePair> unresolvedTypes) {\n+        Type sourceElementType = sourceType.getElementType();\n+        List<Type> targetTypes = new ArrayList<>(targetType.getTupleTypes());\n+        Type targetRestType = targetType.getRestType();\n+\n+        switch (sourceType.getState()) {\n+            case OPEN:\n+                if (targetRestType == null) {\n                     return false;\n                 }\n-                break;\n-            case CLOSED_SEALED:\n-                if (targetType.getState() == ArrayType.ArrayState.CLOSED_SEALED &&\n-                        sourceArrayType.getSize() != targetType.getSize()) {\n+                if (targetTypes.isEmpty()) {\n+                    return checkIsType(sourceElementType, targetRestType, unresolvedTypes);\n+                }\n+                return false;\n+            case CLOSED:\n+                if (sourceType.getSize() < targetTypes.size()) {\n                     return false;\n                 }\n-                break;\n-        }\n+                if (targetTypes.isEmpty()) {\n+                    if (targetRestType != null) {\n+                        return checkIsType(sourceElementType, targetRestType, unresolvedTypes);\n+                    }\n+                    return sourceType.getSize() == 0;\n+                }\n \n-        //If element type is a value type, then check same type\n-        Type targetElementType = targetType.getElementType();\n-        int targetElementTypeTag = targetElementType.getTag();\n+                for (Type targetElementType : targetTypes) {\n+                    if (!(checkIsType(sourceElementType, targetElementType, unresolvedTypes))) {\n+                        return false;\n+                    }\n+                }\n+                if (sourceType.getSize() == targetTypes.size()) {\n+                    return true;\n+                }\n+                if (targetRestType != null) {\n+                    return checkIsType(sourceElementType, targetRestType, unresolvedTypes);\n+                }\n+                return false;\n+            default:\n+                return false;\n+        }\n+    }\n \n-        Type sourceElementType = sourceArrayType.getElementType();\n+    private static boolean checkIsTupleType(BTupleType sourceType, BTupleType targetType,\n+                                            List<TypePair> unresolvedTypes) {\n+        List<Type> sourceTypes = new ArrayList<>(sourceType.getTupleTypes());\n+        Type sourceRestType = sourceType.getRestType();\n+        List<Type> targetTypes = new ArrayList<>(targetType.getTupleTypes());", "originalCommit": "c788e911da0f0c7bfb3def5e5d2291041b5e819e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9c7529d04e8a8b8aaa767e4ab50dd51566beb250", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9c7529d04e8a8b8aaa767e4ab50dd51566beb250", "message": "Refactor TypeChecker", "committedDate": "2020-10-20T15:52:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY3NjE4OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26173#discussion_r508676189", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    List<Type> targetTypes = new ArrayList<>(targetType.getTupleTypes());\n          \n          \n            \n                    List<Type> targetTypes = targetType.getTupleTypes();", "author": "MaryamZi", "createdAt": "2020-10-20T16:34:54Z", "path": "bvm/ballerina-runtime/src/main/java/io/ballerina/runtime/TypeChecker.java", "diffHunk": "@@ -1256,83 +1307,123 @@ private static boolean checkIsArrayType(Type sourceType, BArrayType targetType,\n             return true;\n         }\n \n-        if (sourceType.getTag() != TypeTags.ARRAY_TAG && sourceType.getTag() != TypeTags.TUPLE_TAG) {\n+        if (sourceTypeTag != TypeTags.ARRAY_TAG && sourceTypeTag != TypeTags.TUPLE_TAG) {\n             return false;\n         }\n \n-        BArrayType sourceArrayType;\n-        if (sourceType.getTag() == TypeTags.ARRAY_TAG) {\n-            sourceArrayType = (BArrayType) sourceType;\n-        } else {\n-            BTupleType sourceTupleType = (BTupleType) sourceType;\n-            Set<Type> tupleTypes = new HashSet<>(sourceTupleType.getTupleTypes());\n-            if (sourceTupleType.getRestType() != null) {\n-                tupleTypes.add(sourceTupleType.getRestType());\n-            }\n-            if (tupleTypes.isEmpty()) {\n-                return targetType.getState() == ArrayType.ArrayState.UNSEALED || targetType.getSize() == 0;\n-            }\n-            sourceArrayType =\n-                    new BArrayType(new BUnionType(new ArrayList<>(tupleTypes), sourceTupleType.getTypeFlags()));\n+        if (sourceTypeTag == TypeTags.ARRAY_TAG) {\n+            return checkIsArrayType((BArrayType) sourceType, targetType, unresolvedTypes);\n         }\n+        return checkIsArrayType((BTupleType) sourceType, targetType, unresolvedTypes);\n+    }\n \n-        switch (sourceArrayType.getState()) {\n-            case UNSEALED:\n-                if (targetType.getState() != ArrayType.ArrayState.UNSEALED) {\n+    private static boolean checkIsTupleType(BArrayType sourceType, BTupleType targetType,\n+                                            List<TypePair> unresolvedTypes) {\n+        Type sourceElementType = sourceType.getElementType();\n+        List<Type> targetTypes = new ArrayList<>(targetType.getTupleTypes());", "originalCommit": "9c7529d04e8a8b8aaa767e4ab50dd51566beb250", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3d8c0e97695635903406988c86f53a413f07e3de", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3d8c0e97695635903406988c86f53a413f07e3de", "message": "Refactor new list creation", "committedDate": "2020-10-20T16:44:39Z", "type": "commit"}]}