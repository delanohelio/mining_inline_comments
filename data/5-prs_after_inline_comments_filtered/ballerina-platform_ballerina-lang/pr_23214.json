{"pr_number": 23214, "pr_title": "Add Typed-binding-pattern support for incremental parser", "pr_createdAt": "2020-05-13T14:33:20Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214", "timeline": [{"oid": "6449bfcfcd51253086ca7b2324ec2bc67effea38", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6449bfcfcd51253086ca7b2324ec2bc67effea38", "message": "changed fork statement to use typed-binding-pattern", "committedDate": "2020-05-11T09:45:03Z", "type": "commit"}, {"oid": "20ad7527783dfeec06b77abed6bac4ba6df28eee", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/20ad7527783dfeec06b77abed6bac4ba6df28eee", "message": "fix merge conflict", "committedDate": "2020-05-11T10:16:46Z", "type": "commit"}, {"oid": "e3192bb4020ecd16a80ef142f256b69938334983", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e3192bb4020ecd16a80ef142f256b69938334983", "message": "Add typed-binding-pattern support to foreach-statement", "committedDate": "2020-05-11T15:05:02Z", "type": "commit"}, {"oid": "8d5c3c7f5926259ac2e8719654528af7ea8b27af", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8d5c3c7f5926259ac2e8719654528af7ea8b27af", "message": "Fix binding pattern structure", "committedDate": "2020-05-12T09:06:25Z", "type": "commit"}, {"oid": "44327d5db23ce24a178a4bba4fd5ce19327d4a27", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/44327d5db23ce24a178a4bba4fd5ce19327d4a27", "message": "Fix Typos", "committedDate": "2020-05-12T09:13:01Z", "type": "commit"}, {"oid": "4920cdf8715bc87416b3ad6c528185471b4b6b7f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4920cdf8715bc87416b3ad6c528185471b4b6b7f", "message": "Add structure change in json tree", "committedDate": "2020-05-12T09:13:54Z", "type": "commit"}, {"oid": "3f3e797eedd2018ff77cca9b4994dea141d3bd69", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3f3e797eedd2018ff77cca9b4994dea141d3bd69", "message": "Fix typos", "committedDate": "2020-05-12T09:16:44Z", "type": "commit"}, {"oid": "933e0b2cd61ab29c58ce8ca988e3983af5b9d155", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/933e0b2cd61ab29c58ce8ca988e3983af5b9d155", "message": "Fix typo", "committedDate": "2020-05-12T09:18:36Z", "type": "commit"}, {"oid": "b40619b9a68db5c2547dbd6bef6e2c408e4c294e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b40619b9a68db5c2547dbd6bef6e2c408e4c294e", "message": "Fix merge conflicts", "committedDate": "2020-05-12T09:29:08Z", "type": "commit"}, {"oid": "708915d7a5044e50901639712f0a45822f9936b6", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/708915d7a5044e50901639712f0a45822f9936b6", "message": "Add list-binding-pattern support for typed-binding-pattern", "committedDate": "2020-05-12T14:58:57Z", "type": "commit"}, {"oid": "56bd1e972dc688a0b5d499baccdffca9022c2282", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/56bd1e972dc688a0b5d499baccdffca9022c2282", "message": "Added recovery for typed-binding-pattern", "committedDate": "2020-05-12T17:19:26Z", "type": "commit"}, {"oid": "6f59c9f816e9fa721fef006bf10b6b26e97da170", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6f59c9f816e9fa721fef006bf10b6b26e97da170", "message": "Add resume parsing", "committedDate": "2020-05-13T08:53:09Z", "type": "commit"}, {"oid": "71eb8f94adbfec3f9c29bcafb0e02f2a266f4ad1", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/71eb8f94adbfec3f9c29bcafb0e02f2a266f4ad1", "message": "Fix Typo", "committedDate": "2020-05-13T09:33:04Z", "type": "commit"}, {"oid": "88cc559fa4f9d22e8a943e6a2ef87d2b9e5d6aa8", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/88cc559fa4f9d22e8a943e6a2ef87d2b9e5d6aa8", "message": "Add list-binding-pattern support", "committedDate": "2020-05-13T14:28:52Z", "type": "commit"}, {"oid": "fe25e580795f35d55553f029534baf4882072c7c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fe25e580795f35d55553f029534baf4882072c7c", "message": "Fix merge conflict", "committedDate": "2020-05-13T14:58:41Z", "type": "commit"}, {"oid": "63733194a4124cf50a82d89d2b7ade9eee64bcd4", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/63733194a4124cf50a82d89d2b7ade9eee64bcd4", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into listbindingexp", "committedDate": "2020-05-14T04:16:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg2NTIxNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r424865215", "bodyText": "It is not correct to create typed-binding-patterns here. Reason is, this is a generic method to parse type-descs.\nBut typed-binding-patterns are not supported for all places where a type is supported.\ne.g: type-cast, func-return, type-parameter, etc. there are many places where a type-desc can appear without a binding pattern.", "author": "SupunS", "createdAt": "2020-05-14T04:32:39Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -1983,7 +1991,10 @@ private STNode parseComplexTypeDescriptor(STNode typeDesc, ParserRuleContext con\n                 return parseComplexTypeDescriptor(parseOptionalTypeDescriptor(typeDesc), context);\n             // If next token after a type descriptor is <code>[</code> then it is an array type descriptor\n             case OPEN_BRACKET_TOKEN:\n-                return parseComplexTypeDescriptor(parseArrayTypeDescriptor(typeDesc), context);\n+                if (isListBindingPattern()) { // return typed binding attern if we find a list-b-p\n+                    return STNodeFactory.createTypedBindingPatternNode(typeDesc, parseListBindingPattern());\n+                }", "originalCommit": "fe25e580795f35d55553f029534baf4882072c7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg2NjQ3NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r424866474", "bodyText": "hmmm, that makes sense. Fixed", "author": "m36dot", "createdAt": "2020-05-14T04:38:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg2NTIxNQ=="}], "type": "inlineReview"}, {"oid": "618f1f7d5204ea788b44153e2d5aec97ed2beea3", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/618f1f7d5204ea788b44153e2d5aec97ed2beea3", "message": "Reformat Code", "committedDate": "2020-05-14T05:15:02Z", "type": "commit"}, {"oid": "e34a683aa5e4e692a407bf1469c8914c1315e699", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e34a683aa5e4e692a407bf1469c8914c1315e699", "message": "renamed test in foreach stmt", "committedDate": "2020-05-14T05:18:43Z", "type": "commit"}, {"oid": "6995e32701d8894f7a74cc8d69680510bcfcfdd7", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6995e32701d8894f7a74cc8d69680510bcfcfdd7", "message": "Refactor list-binding-expression parse", "committedDate": "2020-05-14T09:23:24Z", "type": "commit"}, {"oid": "280874e4491d522863ac72c86522d8fed0402444", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/280874e4491d522863ac72c86522d8fed0402444", "message": "Fix recovery", "committedDate": "2020-05-14T14:06:33Z", "type": "commit"}, {"oid": "3adbd8eab0b39e274dff1276bde5cc407efca857", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3adbd8eab0b39e274dff1276bde5cc407efca857", "message": "Fix issue with invalid token at end of list-b-p", "committedDate": "2020-05-18T08:20:18Z", "type": "commit"}, {"oid": "27867203e27735a96efea6c4a86933b0326a60cf", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/27867203e27735a96efea6c4a86933b0326a60cf", "message": "fix infinite loop LBP", "committedDate": "2020-05-18T11:17:04Z", "type": "commit"}, {"oid": "040c18c881978c8c8f6ddb73a9bbdb1946efdfc0", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/040c18c881978c8c8f6ddb73a9bbdb1946efdfc0", "message": "Merge branch 'treegenfix' into listbindingexp", "committedDate": "2020-05-18T12:07:04Z", "type": "commit"}, {"oid": "0e1d5994f3adf89a684d1d1f04dc32e4da40a034", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0e1d5994f3adf89a684d1d1f04dc32e4da40a034", "message": "Add type array desc and listbinding expression parsing", "committedDate": "2020-05-18T17:14:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5NTI0MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r426995241", "bodyText": "Need a proper name for the flag.\nAlso, can it be a boolean instead of int?", "author": "SupunS", "createdAt": "2020-05-19T02:32:56Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -1953,18 +1951,26 @@ private STNode parseReturnsKeyword() {\n      *\n      * @return Parsed node\n      */\n-    private STNode parseTypeDescriptor(ParserRuleContext context) {\n+    private STNode parseTypeDescriptor(ParserRuleContext context, int flag) {", "originalCommit": "0e1d5994f3adf89a684d1d1f04dc32e4da40a034", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5NjAyOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r426996029", "bodyText": "Can we please use the same pattern as in other places? If there is some issue, we should fix that, rather than changing this.", "author": "SupunS", "createdAt": "2020-05-19T02:35:42Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8423,4 +8434,337 @@ private STNode parseParenthesisedTypeDesc() {\n         STNode closeParen = parseCloseParenthesis();\n         return STNodeFactory.createParenthesisedTypeDescriptorNode(openParen, typedesc, closeParen);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternContent = parselistBindingPatternContent();\n+        bindingPatterns.add(listBindingPatternContent);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = getNextLBPToken(); // get next valid token\n+        STNode comma = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternContent.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            comma = parseComma();", "originalCommit": "0e1d5994f3adf89a684d1d1f04dc32e4da40a034", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5Njg5Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r426996893", "bodyText": "Do we need all these?\nYou are terminating the loop if a rest-binding pattern is reached. So wouldn't  checking listBindingPatternContent after the loop be sufficient?", "author": "SupunS", "createdAt": "2020-05-19T02:38:48Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8423,4 +8434,337 @@ private STNode parseParenthesisedTypeDesc() {\n         STNode closeParen = parseCloseParenthesis();\n         return STNodeFactory.createParenthesisedTypeDescriptorNode(openParen, typedesc, closeParen);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternContent = parselistBindingPatternContent();\n+        bindingPatterns.add(listBindingPatternContent);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = getNextLBPToken(); // get next valid token\n+        STNode comma = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternContent.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            comma = parseComma();\n+            bindingPatterns.add(comma);\n+            listBindingPatternContent = parselistBindingPatternContent();\n+            bindingPatterns.add(listBindingPatternContent);\n+            token = getNextLBPToken();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = STNodeFactory.createEmptyNode();\n+        int lastIndex = bindingPatterns.size() - 1;\n+        STNode lastItem = bindingPatterns.get(lastIndex);\n+        if (lastItem.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(lastIndex);\n+        }", "originalCommit": "0e1d5994f3adf89a684d1d1f04dc32e4da40a034", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5NzA5Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r426997096", "bodyText": "Shall we rename this to listBindingPatternMember", "author": "SupunS", "createdAt": "2020-05-19T02:39:37Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8423,4 +8434,337 @@ private STNode parseParenthesisedTypeDesc() {\n         STNode closeParen = parseCloseParenthesis();\n         return STNodeFactory.createParenthesisedTypeDescriptorNode(openParen, typedesc, closeParen);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternContent = parselistBindingPatternContent();\n+        bindingPatterns.add(listBindingPatternContent);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = getNextLBPToken(); // get next valid token\n+        STNode comma = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternContent.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            comma = parseComma();\n+            bindingPatterns.add(comma);\n+            listBindingPatternContent = parselistBindingPatternContent();", "originalCommit": "0e1d5994f3adf89a684d1d1f04dc32e4da40a034", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5NzQwOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r426997409", "bodyText": "I don't think we should do this. Can't we  simply use peek()?", "author": "SupunS", "createdAt": "2020-05-19T02:40:45Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8423,4 +8434,337 @@ private STNode parseParenthesisedTypeDesc() {\n         STNode closeParen = parseCloseParenthesis();\n         return STNodeFactory.createParenthesisedTypeDescriptorNode(openParen, typedesc, closeParen);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternContent = parselistBindingPatternContent();\n+        bindingPatterns.add(listBindingPatternContent);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = getNextLBPToken(); // get next valid token\n+        STNode comma = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternContent.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            comma = parseComma();\n+            bindingPatterns.add(comma);\n+            listBindingPatternContent = parselistBindingPatternContent();\n+            bindingPatterns.add(listBindingPatternContent);\n+            token = getNextLBPToken();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = STNodeFactory.createEmptyNode();\n+        int lastIndex = bindingPatterns.size() - 1;\n+        STNode lastItem = bindingPatterns.get(lastIndex);\n+        if (lastItem.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(lastIndex);\n+        }\n+\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createListBindingPatternNode(openBracket,\n+                                                    bindingPatternsNode,\n+                                                    restBindingPattern,\n+                                                    closeBracket);\n+    }\n+\n+    private STToken getNextLBPToken() {", "originalCommit": "0e1d5994f3adf89a684d1d1f04dc32e4da40a034", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5Nzg4Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r426997887", "bodyText": "Let's replace LPB with ListBindingPattern. Otherwise any new reader will have a hard time figuring out what it means", "author": "SupunS", "createdAt": "2020-05-19T02:42:47Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8423,4 +8434,337 @@ private STNode parseParenthesisedTypeDesc() {\n         STNode closeParen = parseCloseParenthesis();\n         return STNodeFactory.createParenthesisedTypeDescriptorNode(openParen, typedesc, closeParen);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternContent = parselistBindingPatternContent();\n+        bindingPatterns.add(listBindingPatternContent);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = getNextLBPToken(); // get next valid token\n+        STNode comma = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternContent.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            comma = parseComma();\n+            bindingPatterns.add(comma);\n+            listBindingPatternContent = parselistBindingPatternContent();\n+            bindingPatterns.add(listBindingPatternContent);\n+            token = getNextLBPToken();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = STNodeFactory.createEmptyNode();\n+        int lastIndex = bindingPatterns.size() - 1;\n+        STNode lastItem = bindingPatterns.get(lastIndex);\n+        if (lastItem.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(lastIndex);\n+        }\n+\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createListBindingPatternNode(openBracket,\n+                                                    bindingPatternsNode,\n+                                                    restBindingPattern,\n+                                                    closeBracket);\n+    }\n+\n+    private STToken getNextLBPToken() {\n+        STToken token = peek();\n+\n+        if (isEndOfListBindingPattern(token.kind)) {\n+            return token;\n+        }\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+            case IDENTIFIER_TOKEN:\n+            case ELLIPSIS_TOKEN:\n+            case OPEN_BRACKET_TOKEN:\n+            case COMMA_TOKEN:\n+                return token;\n+            default:\n+                consume(); // use the invalid token\n+                this.errorHandler.reportInvalidNode(token,\n+                        \"invalid Token in list-binding-pattern\");\n+                return getNextLBPToken();\n+        }\n+    }\n+\n+    private boolean isEndOfListBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACKET_TOKEN:\n+            case EOF_TOKEN:\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Parse rest-binding-pattern.\n+     *\n+     * rest-binding-pattern := ... variable-name\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parseRestBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                startContext(ParserRuleContext.REST_BINDING_PATTERN);\n+                STNode ellipsis = parseEllipsis();\n+                STNode varName = parseVariableName();\n+                endContext();\n+                return STNodeFactory.createRestBindingPatternNode(ellipsis, varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.REST_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-pattern entry.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parselistBindingPatternContent() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return consume();\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseBindingPattern();\n+        }\n+    }\n+\n+    /**\n+     * Parse Typed-binding-pattern.\n+     *\n+     * <code>typed-binding-pattern := inferable-type-descriptor binding-pattern</code>\n+     * <code>inferable-type-descriptor := type-descriptor | var</code>\n+     *\n+     * @return Fork statement\n+     */\n+    private STNode parseTypedBindingPattern() {\n+        startContext(ParserRuleContext.TYPED_BINDING_PATTERN);\n+        STNode typeDesc = parseTypeDescriptor(ParserRuleContext.TYPE_DESC_IN_TYPE_BINDING_PATTERN, 1);\n+\n+        STNode bindingPattern = null;\n+        if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            STNode[] parsed = parseArrayTypeDescOrLBP(typeDesc);\n+            typeDesc = parsed[0];\n+            bindingPattern = parsed[1];\n+        } else {\n+            bindingPattern = parseBindingPattern();\n+        }\n+\n+        endContext();\n+        return STNodeFactory.createTypedBindingPatternNode(typeDesc, bindingPattern);\n+    }\n+\n+    private STNode[] parseArrayTypeDescOrLBP(STNode typeDesc) {", "originalCommit": "0e1d5994f3adf89a684d1d1f04dc32e4da40a034", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk5ODA3MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r426998070", "bodyText": "Don't need to initialize", "author": "SupunS", "createdAt": "2020-05-19T02:43:30Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8423,4 +8434,337 @@ private STNode parseParenthesisedTypeDesc() {\n         STNode closeParen = parseCloseParenthesis();\n         return STNodeFactory.createParenthesisedTypeDescriptorNode(openParen, typedesc, closeParen);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternContent = parselistBindingPatternContent();\n+        bindingPatterns.add(listBindingPatternContent);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = getNextLBPToken(); // get next valid token\n+        STNode comma = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternContent.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            comma = parseComma();\n+            bindingPatterns.add(comma);\n+            listBindingPatternContent = parselistBindingPatternContent();\n+            bindingPatterns.add(listBindingPatternContent);\n+            token = getNextLBPToken();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = STNodeFactory.createEmptyNode();\n+        int lastIndex = bindingPatterns.size() - 1;\n+        STNode lastItem = bindingPatterns.get(lastIndex);\n+        if (lastItem.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(lastIndex);\n+        }\n+\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createListBindingPatternNode(openBracket,\n+                                                    bindingPatternsNode,\n+                                                    restBindingPattern,\n+                                                    closeBracket);\n+    }\n+\n+    private STToken getNextLBPToken() {\n+        STToken token = peek();\n+\n+        if (isEndOfListBindingPattern(token.kind)) {\n+            return token;\n+        }\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+            case IDENTIFIER_TOKEN:\n+            case ELLIPSIS_TOKEN:\n+            case OPEN_BRACKET_TOKEN:\n+            case COMMA_TOKEN:\n+                return token;\n+            default:\n+                consume(); // use the invalid token\n+                this.errorHandler.reportInvalidNode(token,\n+                        \"invalid Token in list-binding-pattern\");\n+                return getNextLBPToken();\n+        }\n+    }\n+\n+    private boolean isEndOfListBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACKET_TOKEN:\n+            case EOF_TOKEN:\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Parse rest-binding-pattern.\n+     *\n+     * rest-binding-pattern := ... variable-name\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parseRestBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                startContext(ParserRuleContext.REST_BINDING_PATTERN);\n+                STNode ellipsis = parseEllipsis();\n+                STNode varName = parseVariableName();\n+                endContext();\n+                return STNodeFactory.createRestBindingPatternNode(ellipsis, varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.REST_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-pattern entry.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parselistBindingPatternContent() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return consume();\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseBindingPattern();\n+        }\n+    }\n+\n+    /**\n+     * Parse Typed-binding-pattern.\n+     *\n+     * <code>typed-binding-pattern := inferable-type-descriptor binding-pattern</code>\n+     * <code>inferable-type-descriptor := type-descriptor | var</code>\n+     *\n+     * @return Fork statement\n+     */\n+    private STNode parseTypedBindingPattern() {\n+        startContext(ParserRuleContext.TYPED_BINDING_PATTERN);\n+        STNode typeDesc = parseTypeDescriptor(ParserRuleContext.TYPE_DESC_IN_TYPE_BINDING_PATTERN, 1);\n+\n+        STNode bindingPattern = null;", "originalCommit": "0e1d5994f3adf89a684d1d1f04dc32e4da40a034", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAwODQ4MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427008481", "bodyText": "Without returning an array of STNode, can we create the final typed-binding-pattern here and return?\nSame for below cases as well", "author": "SupunS", "createdAt": "2020-05-19T03:26:11Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8423,4 +8434,337 @@ private STNode parseParenthesisedTypeDesc() {\n         STNode closeParen = parseCloseParenthesis();\n         return STNodeFactory.createParenthesisedTypeDescriptorNode(openParen, typedesc, closeParen);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternContent = parselistBindingPatternContent();\n+        bindingPatterns.add(listBindingPatternContent);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = getNextLBPToken(); // get next valid token\n+        STNode comma = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternContent.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            comma = parseComma();\n+            bindingPatterns.add(comma);\n+            listBindingPatternContent = parselistBindingPatternContent();\n+            bindingPatterns.add(listBindingPatternContent);\n+            token = getNextLBPToken();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = STNodeFactory.createEmptyNode();\n+        int lastIndex = bindingPatterns.size() - 1;\n+        STNode lastItem = bindingPatterns.get(lastIndex);\n+        if (lastItem.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(lastIndex);\n+        }\n+\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createListBindingPatternNode(openBracket,\n+                                                    bindingPatternsNode,\n+                                                    restBindingPattern,\n+                                                    closeBracket);\n+    }\n+\n+    private STToken getNextLBPToken() {\n+        STToken token = peek();\n+\n+        if (isEndOfListBindingPattern(token.kind)) {\n+            return token;\n+        }\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+            case IDENTIFIER_TOKEN:\n+            case ELLIPSIS_TOKEN:\n+            case OPEN_BRACKET_TOKEN:\n+            case COMMA_TOKEN:\n+                return token;\n+            default:\n+                consume(); // use the invalid token\n+                this.errorHandler.reportInvalidNode(token,\n+                        \"invalid Token in list-binding-pattern\");\n+                return getNextLBPToken();\n+        }\n+    }\n+\n+    private boolean isEndOfListBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACKET_TOKEN:\n+            case EOF_TOKEN:\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Parse rest-binding-pattern.\n+     *\n+     * rest-binding-pattern := ... variable-name\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parseRestBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                startContext(ParserRuleContext.REST_BINDING_PATTERN);\n+                STNode ellipsis = parseEllipsis();\n+                STNode varName = parseVariableName();\n+                endContext();\n+                return STNodeFactory.createRestBindingPatternNode(ellipsis, varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.REST_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-pattern entry.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parselistBindingPatternContent() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return consume();\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseBindingPattern();\n+        }\n+    }\n+\n+    /**\n+     * Parse Typed-binding-pattern.\n+     *\n+     * <code>typed-binding-pattern := inferable-type-descriptor binding-pattern</code>\n+     * <code>inferable-type-descriptor := type-descriptor | var</code>\n+     *\n+     * @return Fork statement\n+     */\n+    private STNode parseTypedBindingPattern() {\n+        startContext(ParserRuleContext.TYPED_BINDING_PATTERN);\n+        STNode typeDesc = parseTypeDescriptor(ParserRuleContext.TYPE_DESC_IN_TYPE_BINDING_PATTERN, 1);\n+\n+        STNode bindingPattern = null;\n+        if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            STNode[] parsed = parseArrayTypeDescOrLBP(typeDesc);\n+            typeDesc = parsed[0];\n+            bindingPattern = parsed[1];\n+        } else {\n+            bindingPattern = parseBindingPattern();\n+        }\n+\n+        endContext();\n+        return STNodeFactory.createTypedBindingPatternNode(typeDesc, bindingPattern);\n+    }\n+\n+    private STNode[] parseArrayTypeDescOrLBP(STNode typeDesc) {\n+\n+        STNode arrayDescOrBLP = parseListBindingPattern();\n+\n+        if (isLBPDefinitively(arrayDescOrBLP)) { // ambiguous means T[a]\n+            return new STNode[]{typeDesc, cleanLBP(arrayDescOrBLP)};", "originalCommit": "0e1d5994f3adf89a684d1d1f04dc32e4da40a034", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAwOTA2Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427009063", "bodyText": "lets have a better name for the second parameter. (also should start with lower case)", "author": "SupunS", "createdAt": "2020-05-19T03:28:48Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8423,4 +8434,337 @@ private STNode parseParenthesisedTypeDesc() {\n         STNode closeParen = parseCloseParenthesis();\n         return STNodeFactory.createParenthesisedTypeDescriptorNode(openParen, typedesc, closeParen);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternContent = parselistBindingPatternContent();\n+        bindingPatterns.add(listBindingPatternContent);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = getNextLBPToken(); // get next valid token\n+        STNode comma = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternContent.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            comma = parseComma();\n+            bindingPatterns.add(comma);\n+            listBindingPatternContent = parselistBindingPatternContent();\n+            bindingPatterns.add(listBindingPatternContent);\n+            token = getNextLBPToken();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = STNodeFactory.createEmptyNode();\n+        int lastIndex = bindingPatterns.size() - 1;\n+        STNode lastItem = bindingPatterns.get(lastIndex);\n+        if (lastItem.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(lastIndex);\n+        }\n+\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createListBindingPatternNode(openBracket,\n+                                                    bindingPatternsNode,\n+                                                    restBindingPattern,\n+                                                    closeBracket);\n+    }\n+\n+    private STToken getNextLBPToken() {\n+        STToken token = peek();\n+\n+        if (isEndOfListBindingPattern(token.kind)) {\n+            return token;\n+        }\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+            case IDENTIFIER_TOKEN:\n+            case ELLIPSIS_TOKEN:\n+            case OPEN_BRACKET_TOKEN:\n+            case COMMA_TOKEN:\n+                return token;\n+            default:\n+                consume(); // use the invalid token\n+                this.errorHandler.reportInvalidNode(token,\n+                        \"invalid Token in list-binding-pattern\");\n+                return getNextLBPToken();\n+        }\n+    }\n+\n+    private boolean isEndOfListBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACKET_TOKEN:\n+            case EOF_TOKEN:\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Parse rest-binding-pattern.\n+     *\n+     * rest-binding-pattern := ... variable-name\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parseRestBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                startContext(ParserRuleContext.REST_BINDING_PATTERN);\n+                STNode ellipsis = parseEllipsis();\n+                STNode varName = parseVariableName();\n+                endContext();\n+                return STNodeFactory.createRestBindingPatternNode(ellipsis, varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.REST_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-pattern entry.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parselistBindingPatternContent() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return consume();\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseBindingPattern();\n+        }\n+    }\n+\n+    /**\n+     * Parse Typed-binding-pattern.\n+     *\n+     * <code>typed-binding-pattern := inferable-type-descriptor binding-pattern</code>\n+     * <code>inferable-type-descriptor := type-descriptor | var</code>\n+     *\n+     * @return Fork statement\n+     */\n+    private STNode parseTypedBindingPattern() {\n+        startContext(ParserRuleContext.TYPED_BINDING_PATTERN);\n+        STNode typeDesc = parseTypeDescriptor(ParserRuleContext.TYPE_DESC_IN_TYPE_BINDING_PATTERN, 1);\n+\n+        STNode bindingPattern = null;\n+        if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            STNode[] parsed = parseArrayTypeDescOrLBP(typeDesc);\n+            typeDesc = parsed[0];\n+            bindingPattern = parsed[1];\n+        } else {\n+            bindingPattern = parseBindingPattern();\n+        }\n+\n+        endContext();\n+        return STNodeFactory.createTypedBindingPatternNode(typeDesc, bindingPattern);\n+    }\n+\n+    private STNode[] parseArrayTypeDescOrLBP(STNode typeDesc) {\n+\n+        STNode arrayDescOrBLP = parseListBindingPattern();\n+\n+        if (isLBPDefinitively(arrayDescOrBLP)) { // ambiguous means T[a]\n+            return new STNode[]{typeDesc, cleanLBP(arrayDescOrBLP)};\n+        } else {\n+            if (isFollowTypedBindingPattern(peek().kind)) {\n+                return new STNode[]{typeDesc, cleanLBP(arrayDescOrBLP)};\n+            } else {\n+                typeDesc = mergeTypeDescAndLBP(typeDesc, arrayDescOrBLP);\n+                if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+                    //this means arrayDescOrBLP is a array type desc\n+                    return parseArrayTypeDescOrLBP(typeDesc);\n+                } else {\n+                    return new STNode[]{typeDesc, parseBindingPattern()};\n+                }\n+            }\n+        }\n+    }\n+\n+    private STNode mergeTypeDescAndLBP(STNode typeDesc, STNode LBP) {", "originalCommit": "0e1d5994f3adf89a684d1d1f04dc32e4da40a034", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAwOTcyMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427009721", "bodyText": "Don't need 'else', since you are returning inside 'if'", "author": "SupunS", "createdAt": "2020-05-19T03:31:14Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8423,4 +8434,337 @@ private STNode parseParenthesisedTypeDesc() {\n         STNode closeParen = parseCloseParenthesis();\n         return STNodeFactory.createParenthesisedTypeDescriptorNode(openParen, typedesc, closeParen);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternContent = parselistBindingPatternContent();\n+        bindingPatterns.add(listBindingPatternContent);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = getNextLBPToken(); // get next valid token\n+        STNode comma = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternContent.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            comma = parseComma();\n+            bindingPatterns.add(comma);\n+            listBindingPatternContent = parselistBindingPatternContent();\n+            bindingPatterns.add(listBindingPatternContent);\n+            token = getNextLBPToken();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = STNodeFactory.createEmptyNode();\n+        int lastIndex = bindingPatterns.size() - 1;\n+        STNode lastItem = bindingPatterns.get(lastIndex);\n+        if (lastItem.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(lastIndex);\n+        }\n+\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createListBindingPatternNode(openBracket,\n+                                                    bindingPatternsNode,\n+                                                    restBindingPattern,\n+                                                    closeBracket);\n+    }\n+\n+    private STToken getNextLBPToken() {\n+        STToken token = peek();\n+\n+        if (isEndOfListBindingPattern(token.kind)) {\n+            return token;\n+        }\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+            case IDENTIFIER_TOKEN:\n+            case ELLIPSIS_TOKEN:\n+            case OPEN_BRACKET_TOKEN:\n+            case COMMA_TOKEN:\n+                return token;\n+            default:\n+                consume(); // use the invalid token\n+                this.errorHandler.reportInvalidNode(token,\n+                        \"invalid Token in list-binding-pattern\");\n+                return getNextLBPToken();\n+        }\n+    }\n+\n+    private boolean isEndOfListBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACKET_TOKEN:\n+            case EOF_TOKEN:\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Parse rest-binding-pattern.\n+     *\n+     * rest-binding-pattern := ... variable-name\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parseRestBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                startContext(ParserRuleContext.REST_BINDING_PATTERN);\n+                STNode ellipsis = parseEllipsis();\n+                STNode varName = parseVariableName();\n+                endContext();\n+                return STNodeFactory.createRestBindingPatternNode(ellipsis, varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.REST_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-pattern entry.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parselistBindingPatternContent() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return consume();\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseBindingPattern();\n+        }\n+    }\n+\n+    /**\n+     * Parse Typed-binding-pattern.\n+     *\n+     * <code>typed-binding-pattern := inferable-type-descriptor binding-pattern</code>\n+     * <code>inferable-type-descriptor := type-descriptor | var</code>\n+     *\n+     * @return Fork statement\n+     */\n+    private STNode parseTypedBindingPattern() {\n+        startContext(ParserRuleContext.TYPED_BINDING_PATTERN);\n+        STNode typeDesc = parseTypeDescriptor(ParserRuleContext.TYPE_DESC_IN_TYPE_BINDING_PATTERN, 1);\n+\n+        STNode bindingPattern = null;\n+        if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            STNode[] parsed = parseArrayTypeDescOrLBP(typeDesc);\n+            typeDesc = parsed[0];\n+            bindingPattern = parsed[1];\n+        } else {\n+            bindingPattern = parseBindingPattern();\n+        }\n+\n+        endContext();\n+        return STNodeFactory.createTypedBindingPatternNode(typeDesc, bindingPattern);\n+    }\n+\n+    private STNode[] parseArrayTypeDescOrLBP(STNode typeDesc) {\n+\n+        STNode arrayDescOrBLP = parseListBindingPattern();\n+\n+        if (isLBPDefinitively(arrayDescOrBLP)) { // ambiguous means T[a]\n+            return new STNode[]{typeDesc, cleanLBP(arrayDescOrBLP)};\n+        } else {", "originalCommit": "0e1d5994f3adf89a684d1d1f04dc32e4da40a034", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAwOTkyMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427009920", "bodyText": "wrong param name", "author": "SupunS", "createdAt": "2020-05-19T03:32:00Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8423,4 +8434,337 @@ private STNode parseParenthesisedTypeDesc() {\n         STNode closeParen = parseCloseParenthesis();\n         return STNodeFactory.createParenthesisedTypeDescriptorNode(openParen, typedesc, closeParen);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternContent = parselistBindingPatternContent();\n+        bindingPatterns.add(listBindingPatternContent);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = getNextLBPToken(); // get next valid token\n+        STNode comma = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternContent.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            comma = parseComma();\n+            bindingPatterns.add(comma);\n+            listBindingPatternContent = parselistBindingPatternContent();\n+            bindingPatterns.add(listBindingPatternContent);\n+            token = getNextLBPToken();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = STNodeFactory.createEmptyNode();\n+        int lastIndex = bindingPatterns.size() - 1;\n+        STNode lastItem = bindingPatterns.get(lastIndex);\n+        if (lastItem.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(lastIndex);\n+        }\n+\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createListBindingPatternNode(openBracket,\n+                                                    bindingPatternsNode,\n+                                                    restBindingPattern,\n+                                                    closeBracket);\n+    }\n+\n+    private STToken getNextLBPToken() {\n+        STToken token = peek();\n+\n+        if (isEndOfListBindingPattern(token.kind)) {\n+            return token;\n+        }\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+            case IDENTIFIER_TOKEN:\n+            case ELLIPSIS_TOKEN:\n+            case OPEN_BRACKET_TOKEN:\n+            case COMMA_TOKEN:\n+                return token;\n+            default:\n+                consume(); // use the invalid token\n+                this.errorHandler.reportInvalidNode(token,\n+                        \"invalid Token in list-binding-pattern\");\n+                return getNextLBPToken();\n+        }\n+    }\n+\n+    private boolean isEndOfListBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACKET_TOKEN:\n+            case EOF_TOKEN:\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Parse rest-binding-pattern.\n+     *\n+     * rest-binding-pattern := ... variable-name\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parseRestBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                startContext(ParserRuleContext.REST_BINDING_PATTERN);\n+                STNode ellipsis = parseEllipsis();\n+                STNode varName = parseVariableName();\n+                endContext();\n+                return STNodeFactory.createRestBindingPatternNode(ellipsis, varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.REST_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-pattern entry.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parselistBindingPatternContent() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return consume();\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseBindingPattern();\n+        }\n+    }\n+\n+    /**\n+     * Parse Typed-binding-pattern.\n+     *\n+     * <code>typed-binding-pattern := inferable-type-descriptor binding-pattern</code>\n+     * <code>inferable-type-descriptor := type-descriptor | var</code>\n+     *\n+     * @return Fork statement\n+     */\n+    private STNode parseTypedBindingPattern() {\n+        startContext(ParserRuleContext.TYPED_BINDING_PATTERN);\n+        STNode typeDesc = parseTypeDescriptor(ParserRuleContext.TYPE_DESC_IN_TYPE_BINDING_PATTERN, 1);\n+\n+        STNode bindingPattern = null;\n+        if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            STNode[] parsed = parseArrayTypeDescOrLBP(typeDesc);\n+            typeDesc = parsed[0];\n+            bindingPattern = parsed[1];\n+        } else {\n+            bindingPattern = parseBindingPattern();\n+        }\n+\n+        endContext();\n+        return STNodeFactory.createTypedBindingPatternNode(typeDesc, bindingPattern);\n+    }\n+\n+    private STNode[] parseArrayTypeDescOrLBP(STNode typeDesc) {\n+\n+        STNode arrayDescOrBLP = parseListBindingPattern();\n+\n+        if (isLBPDefinitively(arrayDescOrBLP)) { // ambiguous means T[a]\n+            return new STNode[]{typeDesc, cleanLBP(arrayDescOrBLP)};\n+        } else {\n+            if (isFollowTypedBindingPattern(peek().kind)) {\n+                return new STNode[]{typeDesc, cleanLBP(arrayDescOrBLP)};\n+            } else {\n+                typeDesc = mergeTypeDescAndLBP(typeDesc, arrayDescOrBLP);\n+                if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+                    //this means arrayDescOrBLP is a array type desc\n+                    return parseArrayTypeDescOrLBP(typeDesc);\n+                } else {\n+                    return new STNode[]{typeDesc, parseBindingPattern()};\n+                }\n+            }\n+        }\n+    }\n+\n+    private STNode mergeTypeDescAndLBP(STNode typeDesc, STNode LBP) {\n+        STListBindingPatternNode lbp = (STListBindingPatternNode) LBP;\n+        STNodeList childArray = (STNodeList)lbp.bindingPatterns;\n+        STNode child = childArray.childInBucket(0);\n+        if (child.kind == SyntaxKind.CAPTURE_BINDING_PATTERN) {\n+            child = ((STCaptureBindingPatternNode)child).variableName;\n+        }\n+        return STNodeFactory.createIndexedExpressionNode(typeDesc, lbp.openBracket,\n+                child,\n+                lbp.closeBracket);\n+    }\n+\n+    private STNode cleanLBP(STNode arrayDescOrBLP) {\n+        STListBindingPatternNode lbp = (STListBindingPatternNode) arrayDescOrBLP;\n+        STNodeList childArray = (STNodeList)lbp.bindingPatterns;\n+        int numberOfChildren = childArray.bucketCount();\n+\n+        ArrayList<STNode> cleanedChildren = new ArrayList<>();\n+        STNode child = null;\n+        for (int i =0; i<numberOfChildren;i++) {\n+            child = childArray.childInBucket(i);\n+            switch (child.kind) {\n+                case DECIMAL_INTEGER_LITERAL:\n+                case HEX_INTEGER_LITERAL:\n+                case ASTERISK_TOKEN:\n+                    this.errorHandler.reportInvalidNode(null,\n+                            \"invalid Node \" + child.kind + \" in list-binding-pattern\");\n+                    cleanedChildren.add(STNodeFactory.createMissingToken(SyntaxKind.IDENTIFIER_TOKEN));\n+                    break;\n+                default:\n+                    cleanedChildren.add(child);\n+                    break;\n+            }\n+        }\n+\n+        return STNodeFactory.createListBindingPatternNode(lbp.openBracket,\n+                STNodeFactory.createNodeList(cleanedChildren),\n+                lbp.restBindingPattern,\n+                lbp.closeBracket);\n+    }\n+\n+    private boolean isLBPDefinitively(STNode arrayDescOrBLP) {", "originalCommit": "0e1d5994f3adf89a684d1d1f04dc32e4da40a034", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAxNTAwOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427015008", "bodyText": "what happens for something like: a[b][c] = 5 where in[][] a = []; ?\nThis is an assignment with member access.", "author": "SupunS", "createdAt": "2020-05-19T03:52:06Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -8423,4 +8434,337 @@ private STNode parseParenthesisedTypeDesc() {\n         STNode closeParen = parseCloseParenthesis();\n         return STNodeFactory.createParenthesisedTypeDescriptorNode(openParen, typedesc, closeParen);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternContent = parselistBindingPatternContent();\n+        bindingPatterns.add(listBindingPatternContent);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = getNextLBPToken(); // get next valid token\n+        STNode comma = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternContent.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            comma = parseComma();\n+            bindingPatterns.add(comma);\n+            listBindingPatternContent = parselistBindingPatternContent();\n+            bindingPatterns.add(listBindingPatternContent);\n+            token = getNextLBPToken();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = STNodeFactory.createEmptyNode();\n+        int lastIndex = bindingPatterns.size() - 1;\n+        STNode lastItem = bindingPatterns.get(lastIndex);\n+        if (lastItem.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(lastIndex);\n+        }\n+\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createListBindingPatternNode(openBracket,\n+                                                    bindingPatternsNode,\n+                                                    restBindingPattern,\n+                                                    closeBracket);\n+    }\n+\n+    private STToken getNextLBPToken() {\n+        STToken token = peek();\n+\n+        if (isEndOfListBindingPattern(token.kind)) {\n+            return token;\n+        }\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+            case IDENTIFIER_TOKEN:\n+            case ELLIPSIS_TOKEN:\n+            case OPEN_BRACKET_TOKEN:\n+            case COMMA_TOKEN:\n+                return token;\n+            default:\n+                consume(); // use the invalid token\n+                this.errorHandler.reportInvalidNode(token,\n+                        \"invalid Token in list-binding-pattern\");\n+                return getNextLBPToken();\n+        }\n+    }\n+\n+    private boolean isEndOfListBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACKET_TOKEN:\n+            case EOF_TOKEN:\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Parse rest-binding-pattern.\n+     *\n+     * rest-binding-pattern := ... variable-name\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parseRestBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                startContext(ParserRuleContext.REST_BINDING_PATTERN);\n+                STNode ellipsis = parseEllipsis();\n+                STNode varName = parseVariableName();\n+                endContext();\n+                return STNodeFactory.createRestBindingPatternNode(ellipsis, varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.REST_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-pattern entry.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parselistBindingPatternContent() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return consume();\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseBindingPattern();\n+        }\n+    }\n+\n+    /**\n+     * Parse Typed-binding-pattern.\n+     *\n+     * <code>typed-binding-pattern := inferable-type-descriptor binding-pattern</code>\n+     * <code>inferable-type-descriptor := type-descriptor | var</code>\n+     *\n+     * @return Fork statement\n+     */\n+    private STNode parseTypedBindingPattern() {\n+        startContext(ParserRuleContext.TYPED_BINDING_PATTERN);\n+        STNode typeDesc = parseTypeDescriptor(ParserRuleContext.TYPE_DESC_IN_TYPE_BINDING_PATTERN, 1);\n+\n+        STNode bindingPattern = null;\n+        if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            STNode[] parsed = parseArrayTypeDescOrLBP(typeDesc);\n+            typeDesc = parsed[0];\n+            bindingPattern = parsed[1];\n+        } else {\n+            bindingPattern = parseBindingPattern();\n+        }\n+\n+        endContext();\n+        return STNodeFactory.createTypedBindingPatternNode(typeDesc, bindingPattern);\n+    }\n+\n+    private STNode[] parseArrayTypeDescOrLBP(STNode typeDesc) {\n+\n+        STNode arrayDescOrBLP = parseListBindingPattern();\n+\n+        if (isLBPDefinitively(arrayDescOrBLP)) { // ambiguous means T[a]\n+            return new STNode[]{typeDesc, cleanLBP(arrayDescOrBLP)};\n+        } else {\n+            if (isFollowTypedBindingPattern(peek().kind)) {\n+                return new STNode[]{typeDesc, cleanLBP(arrayDescOrBLP)};\n+            } else {\n+                typeDesc = mergeTypeDescAndLBP(typeDesc, arrayDescOrBLP);\n+                if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+                    //this means arrayDescOrBLP is a array type desc\n+                    return parseArrayTypeDescOrLBP(typeDesc);\n+                } else {\n+                    return new STNode[]{typeDesc, parseBindingPattern()};\n+                }\n+            }\n+        }\n+    }\n+\n+    private STNode mergeTypeDescAndLBP(STNode typeDesc, STNode LBP) {\n+        STListBindingPatternNode lbp = (STListBindingPatternNode) LBP;\n+        STNodeList childArray = (STNodeList)lbp.bindingPatterns;\n+        STNode child = childArray.childInBucket(0);\n+        if (child.kind == SyntaxKind.CAPTURE_BINDING_PATTERN) {\n+            child = ((STCaptureBindingPatternNode)child).variableName;\n+        }\n+        return STNodeFactory.createIndexedExpressionNode(typeDesc, lbp.openBracket,\n+                child,\n+                lbp.closeBracket);\n+    }\n+\n+    private STNode cleanLBP(STNode arrayDescOrBLP) {\n+        STListBindingPatternNode lbp = (STListBindingPatternNode) arrayDescOrBLP;\n+        STNodeList childArray = (STNodeList)lbp.bindingPatterns;\n+        int numberOfChildren = childArray.bucketCount();\n+\n+        ArrayList<STNode> cleanedChildren = new ArrayList<>();\n+        STNode child = null;\n+        for (int i =0; i<numberOfChildren;i++) {\n+            child = childArray.childInBucket(i);\n+            switch (child.kind) {\n+                case DECIMAL_INTEGER_LITERAL:\n+                case HEX_INTEGER_LITERAL:\n+                case ASTERISK_TOKEN:\n+                    this.errorHandler.reportInvalidNode(null,\n+                            \"invalid Node \" + child.kind + \" in list-binding-pattern\");\n+                    cleanedChildren.add(STNodeFactory.createMissingToken(SyntaxKind.IDENTIFIER_TOKEN));\n+                    break;\n+                default:\n+                    cleanedChildren.add(child);\n+                    break;\n+            }\n+        }\n+\n+        return STNodeFactory.createListBindingPatternNode(lbp.openBracket,\n+                STNodeFactory.createNodeList(cleanedChildren),\n+                lbp.restBindingPattern,\n+                lbp.closeBracket);\n+    }\n+\n+    private boolean isLBPDefinitively(STNode arrayDescOrBLP) {\n+        STListBindingPatternNode lbp = (STListBindingPatternNode) arrayDescOrBLP;\n+        STNodeList childArray = (STNodeList)lbp.bindingPatterns;\n+        int numberOfChildren = childArray.bucketCount();\n+\n+        if (lbp.restBindingPattern != null) {\n+            return true;\n+        }\n+\n+        if (numberOfChildren ==1 ) {\n+            STNode child = childArray.childInBucket(0);\n+            switch (child.kind) {\n+                case DECIMAL_INTEGER_LITERAL:\n+                case HEX_INTEGER_LITERAL:\n+                case ASTERISK_TOKEN:\n+                case CAPTURE_BINDING_PATTERN:\n+                    return false;\n+                default: // cases like [ and {\n+                    return true;\n+            }\n+        } else {", "originalCommit": "0e1d5994f3adf89a684d1d1f04dc32e4da40a034", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA2MTgyNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427061826", "bodyText": "the only time we have to solve this problem is to decide between array type desc and list-b-p in typed binding patterns; if there are no typed binding patterns then it proceeds like usual(like it did before our code).", "author": "m36dot", "createdAt": "2020-05-19T06:36:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAxNTAwOA=="}], "type": "inlineReview"}, {"oid": "e8c7613c2603559c2478a3ccd61151d3593f9282", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e8c7613c2603559c2478a3ccd61151d3593f9282", "message": "Refactor Code", "committedDate": "2020-05-19T07:22:59Z", "type": "commit"}, {"oid": "a8da3de833d2c37c457a677d7d7738536b3b005f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a8da3de833d2c37c457a677d7d7738536b3b005f", "message": "Fix checkstyle issue", "committedDate": "2020-05-19T07:53:47Z", "type": "commit"}, {"oid": "a39a345646e917a504271e5b8534b7a4f76d51a5", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a39a345646e917a504271e5b8534b7a4f76d51a5", "message": "Fix merge conflict", "committedDate": "2020-05-19T08:43:56Z", "type": "commit"}, {"oid": "ec0194d19cb63c5625e12d2e801076bf078fc873", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ec0194d19cb63c5625e12d2e801076bf078fc873", "message": "Fix infinite loop with the right pattern", "committedDate": "2020-05-19T09:14:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE3NzUwOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427177509", "bodyText": "Should create the createEmptyNode inside else block of the below 'if'", "author": "SupunS", "createdAt": "2020-05-19T09:55:08Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9343,4 +9375,340 @@ private STNode parseIntersectionTypeDescriptor(STNode leftTypeDesc, ParserRuleCo\n         STNode rightTypeDesc = parseTypeDescriptor(context);\n         return STNodeFactory.createIntersectionTypeDescriptorNode(leftTypeDesc, bitwiseAndToken, rightTypeDesc);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternMember = parselistBindingPatternMember();\n+        bindingPatterns.add(listBindingPatternMember);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode listBindingPatternRhs = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            listBindingPatternRhs = parseListBindingpatternRhs(token.kind);\n+            if (listBindingPatternRhs == null) {\n+                break;\n+            }\n+            bindingPatterns.add(listBindingPatternRhs);\n+            listBindingPatternMember = parselistBindingPatternMember();\n+            bindingPatterns.add(listBindingPatternMember);\n+            token = peek();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = STNodeFactory.createEmptyNode();", "originalCommit": "ec0194d19cb63c5625e12d2e801076bf078fc873", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE5MTQxOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427191419", "bodyText": "ok", "author": "m36dot", "createdAt": "2020-05-19T10:18:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE3NzUwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE3Nzc0Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427177743", "bodyText": "wrong context.", "author": "SupunS", "createdAt": "2020-05-19T09:55:33Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9343,4 +9375,340 @@ private STNode parseIntersectionTypeDescriptor(STNode leftTypeDesc, ParserRuleCo\n         STNode rightTypeDesc = parseTypeDescriptor(context);\n         return STNodeFactory.createIntersectionTypeDescriptorNode(leftTypeDesc, bitwiseAndToken, rightTypeDesc);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternMember = parselistBindingPatternMember();\n+        bindingPatterns.add(listBindingPatternMember);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode listBindingPatternRhs = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            listBindingPatternRhs = parseListBindingpatternRhs(token.kind);\n+            if (listBindingPatternRhs == null) {\n+                break;\n+            }\n+            bindingPatterns.add(listBindingPatternRhs);\n+            listBindingPatternMember = parselistBindingPatternMember();\n+            bindingPatterns.add(listBindingPatternMember);\n+            token = peek();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = STNodeFactory.createEmptyNode();\n+        if (listBindingPatternMember.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(bindingPatterns.size() - 1);\n+        }\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createListBindingPatternNode(openBracket,\n+                                                    bindingPatternsNode,\n+                                                    restBindingPattern,\n+                                                    closeBracket);\n+    }\n+\n+    private STNode parseListBindingpatternRhs() {\n+        return parseListBindingpatternRhs(peek().kind);\n+    }\n+\n+    private STNode parseListBindingpatternRhs(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case COMMA_TOKEN:\n+                return parseComma();\n+            case CLOSE_BRACKET_TOKEN:\n+                return null;\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TYPE_DESC_IN_TUPLE_RHS);", "originalCommit": "ec0194d19cb63c5625e12d2e801076bf078fc873", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE5MTUxNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427191516", "bodyText": "sorry didnt notice", "author": "m36dot", "createdAt": "2020-05-19T10:18:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE3Nzc0Mw=="}], "type": "inlineReview"}, {"oid": "86b3868076bb1f535f392b0160046ac64a83811d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/86b3868076bb1f535f392b0160046ac64a83811d", "message": "Fix typo", "committedDate": "2020-05-19T10:26:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE5MDM5MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427190391", "bodyText": "body of this if block is same as above. can we merge the two?", "author": "SupunS", "createdAt": "2020-05-19T10:16:37Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9343,4 +9375,340 @@ private STNode parseIntersectionTypeDescriptor(STNode leftTypeDesc, ParserRuleCo\n         STNode rightTypeDesc = parseTypeDescriptor(context);\n         return STNodeFactory.createIntersectionTypeDescriptorNode(leftTypeDesc, bitwiseAndToken, rightTypeDesc);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternMember = parselistBindingPatternMember();\n+        bindingPatterns.add(listBindingPatternMember);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode listBindingPatternRhs = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            listBindingPatternRhs = parseListBindingpatternRhs(token.kind);\n+            if (listBindingPatternRhs == null) {\n+                break;\n+            }\n+            bindingPatterns.add(listBindingPatternRhs);\n+            listBindingPatternMember = parselistBindingPatternMember();\n+            bindingPatterns.add(listBindingPatternMember);\n+            token = peek();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = STNodeFactory.createEmptyNode();\n+        if (listBindingPatternMember.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(bindingPatterns.size() - 1);\n+        }\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createListBindingPatternNode(openBracket,\n+                                                    bindingPatternsNode,\n+                                                    restBindingPattern,\n+                                                    closeBracket);\n+    }\n+\n+    private STNode parseListBindingpatternRhs() {\n+        return parseListBindingpatternRhs(peek().kind);\n+    }\n+\n+    private STNode parseListBindingpatternRhs(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case COMMA_TOKEN:\n+                return parseComma();\n+            case CLOSE_BRACKET_TOKEN:\n+                return null;\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TYPE_DESC_IN_TUPLE_RHS);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseListBindingpatternRhs(solution.tokenKind);\n+        }\n+    }\n+\n+    private boolean isEndOfListBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACKET_TOKEN:\n+            case EOF_TOKEN:\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Parse rest-binding-pattern.\n+     *\n+     * rest-binding-pattern := ... variable-name\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parseRestBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                startContext(ParserRuleContext.REST_BINDING_PATTERN);\n+                STNode ellipsis = parseEllipsis();\n+                STNode varName = parseVariableName();\n+                endContext();\n+                return STNodeFactory.createRestBindingPatternNode(ellipsis, varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.REST_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-pattern entry.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parselistBindingPatternMember() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return consume();\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseBindingPattern();\n+        }\n+    }\n+\n+    /**\n+     * Parse Typed-binding-pattern.\n+     *\n+     * <code>typed-binding-pattern := inferable-type-descriptor binding-pattern</code>\n+     * <code>inferable-type-descriptor := type-descriptor | var</code>\n+     *\n+     * @return Fork statement\n+     */\n+    private STNode parseTypedBindingPattern() {\n+        startContext(ParserRuleContext.TYPED_BINDING_PATTERN);\n+        STNode typeDesc = parseTypeDescriptor(ParserRuleContext.TYPE_DESC_IN_TYPE_BINDING_PATTERN, true);\n+\n+        STNode bindingPattern = null;\n+        if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            STNode typedBindingPattern = parseArrayTypeDescOrListBindingPattern(typeDesc);\n+            endContext();\n+            return typedBindingPattern;\n+        }\n+        bindingPattern = parseBindingPattern();\n+\n+        endContext();\n+        return STNodeFactory.createTypedBindingPatternNode(typeDesc, bindingPattern);\n+    }\n+\n+    private STNode parseArrayTypeDescOrListBindingPattern(STNode typeDesc) {\n+\n+        STNode arrayDescOrListBindingPattern = parseListBindingPattern();\n+\n+        if (isListBindingPatternDefinitively(arrayDescOrListBindingPattern)) { // ambiguous means T[a]\n+            return STNodeFactory.createTypedBindingPatternNode(typeDesc,\n+                    cleanListBindingPattern(arrayDescOrListBindingPattern));\n+        }\n+\n+        if (isFollowTypedBindingPattern(peek().kind)) {\n+            return STNodeFactory.createTypedBindingPatternNode(typeDesc,\n+                    cleanListBindingPattern(arrayDescOrListBindingPattern));\n+        }", "originalCommit": "ec0194d19cb63c5625e12d2e801076bf078fc873", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE5MTU1MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427191550", "bodyText": "Can you add a comment mentioning what are we checking here, and why we need that?", "author": "SupunS", "createdAt": "2020-05-19T10:18:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE5MDM5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE5MTg5OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427191899", "bodyText": "Extra new lines", "author": "SupunS", "createdAt": "2020-05-19T10:19:19Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9343,4 +9375,340 @@ private STNode parseIntersectionTypeDescriptor(STNode leftTypeDesc, ParserRuleCo\n         STNode rightTypeDesc = parseTypeDescriptor(context);\n         return STNodeFactory.createIntersectionTypeDescriptorNode(leftTypeDesc, bitwiseAndToken, rightTypeDesc);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternMember = parselistBindingPatternMember();\n+        bindingPatterns.add(listBindingPatternMember);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode listBindingPatternRhs = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            listBindingPatternRhs = parseListBindingpatternRhs(token.kind);\n+            if (listBindingPatternRhs == null) {\n+                break;\n+            }\n+            bindingPatterns.add(listBindingPatternRhs);\n+            listBindingPatternMember = parselistBindingPatternMember();\n+            bindingPatterns.add(listBindingPatternMember);\n+            token = peek();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = STNodeFactory.createEmptyNode();\n+        if (listBindingPatternMember.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(bindingPatterns.size() - 1);\n+        }\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createListBindingPatternNode(openBracket,\n+                                                    bindingPatternsNode,\n+                                                    restBindingPattern,\n+                                                    closeBracket);\n+    }\n+\n+    private STNode parseListBindingpatternRhs() {\n+        return parseListBindingpatternRhs(peek().kind);\n+    }\n+\n+    private STNode parseListBindingpatternRhs(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case COMMA_TOKEN:\n+                return parseComma();\n+            case CLOSE_BRACKET_TOKEN:\n+                return null;\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.TYPE_DESC_IN_TUPLE_RHS);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseListBindingpatternRhs(solution.tokenKind);\n+        }\n+    }\n+\n+    private boolean isEndOfListBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACKET_TOKEN:\n+            case EOF_TOKEN:\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Parse rest-binding-pattern.\n+     *\n+     * rest-binding-pattern := ... variable-name\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parseRestBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                startContext(ParserRuleContext.REST_BINDING_PATTERN);\n+                STNode ellipsis = parseEllipsis();\n+                STNode varName = parseVariableName();\n+                endContext();\n+                return STNodeFactory.createRestBindingPatternNode(ellipsis, varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.REST_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-pattern entry.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parselistBindingPatternMember() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return consume();\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseBindingPattern();\n+        }\n+    }\n+\n+    /**\n+     * Parse Typed-binding-pattern.\n+     *\n+     * <code>typed-binding-pattern := inferable-type-descriptor binding-pattern</code>\n+     * <code>inferable-type-descriptor := type-descriptor | var</code>\n+     *\n+     * @return Fork statement\n+     */\n+    private STNode parseTypedBindingPattern() {\n+        startContext(ParserRuleContext.TYPED_BINDING_PATTERN);\n+        STNode typeDesc = parseTypeDescriptor(ParserRuleContext.TYPE_DESC_IN_TYPE_BINDING_PATTERN, true);\n+\n+        STNode bindingPattern = null;\n+        if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            STNode typedBindingPattern = parseArrayTypeDescOrListBindingPattern(typeDesc);\n+            endContext();\n+            return typedBindingPattern;\n+        }\n+        bindingPattern = parseBindingPattern();\n+\n+        endContext();\n+        return STNodeFactory.createTypedBindingPatternNode(typeDesc, bindingPattern);\n+    }\n+\n+    private STNode parseArrayTypeDescOrListBindingPattern(STNode typeDesc) {\n+\n+        STNode arrayDescOrListBindingPattern = parseListBindingPattern();\n+\n+        if (isListBindingPatternDefinitively(arrayDescOrListBindingPattern)) { // ambiguous means T[a]\n+            return STNodeFactory.createTypedBindingPatternNode(typeDesc,\n+                    cleanListBindingPattern(arrayDescOrListBindingPattern));\n+        }\n+\n+        if (isFollowTypedBindingPattern(peek().kind)) {\n+            return STNodeFactory.createTypedBindingPatternNode(typeDesc,\n+                    cleanListBindingPattern(arrayDescOrListBindingPattern));\n+        }\n+\n+        typeDesc = mergeTypeDescAndListBindingPattern(typeDesc, arrayDescOrListBindingPattern);\n+        if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            //this means arrayDescOrBLP is a array type desc\n+            return parseArrayTypeDescOrListBindingPattern(typeDesc);\n+        } else {\n+            return STNodeFactory.createTypedBindingPatternNode(typeDesc,\n+                    parseBindingPattern());\n+        }\n+\n+", "originalCommit": "ec0194d19cb63c5625e12d2e801076bf078fc873", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE5ODI1NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427198254", "bodyText": "I think its safe to do the reverse of this.\ni.e: if the only-child is captured-binding-patterns, then return true.\nThat way we don't have to update this method, when we add new binding patterns.", "author": "SupunS", "createdAt": "2020-05-19T10:31:00Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9343,4 +9375,342 @@ private STNode parseIntersectionTypeDescriptor(STNode leftTypeDesc, ParserRuleCo\n         STNode rightTypeDesc = parseTypeDescriptor(context);\n         return STNodeFactory.createIntersectionTypeDescriptorNode(leftTypeDesc, bitwiseAndToken, rightTypeDesc);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternMember = parselistBindingPatternMember();\n+        bindingPatterns.add(listBindingPatternMember);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode listBindingPatternRhs = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            listBindingPatternRhs = parseListBindingpatternRhs(token.kind);\n+            if (listBindingPatternRhs == null) {\n+                break;\n+            }\n+            bindingPatterns.add(listBindingPatternRhs);\n+            listBindingPatternMember = parselistBindingPatternMember();\n+            bindingPatterns.add(listBindingPatternMember);\n+            token = peek();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = null;\n+        if (listBindingPatternMember.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(bindingPatterns.size() - 1);\n+        } else {\n+            restBindingPattern = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createListBindingPatternNode(openBracket,\n+                                                    bindingPatternsNode,\n+                                                    restBindingPattern,\n+                                                    closeBracket);\n+    }\n+\n+    private STNode parseListBindingpatternRhs() {\n+        return parseListBindingpatternRhs(peek().kind);\n+    }\n+\n+    private STNode parseListBindingpatternRhs(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case COMMA_TOKEN:\n+                return parseComma();\n+            case CLOSE_BRACKET_TOKEN:\n+                return null;\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.LIST_BINDING_PATTERN_END_OR_CONTINUE);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseListBindingpatternRhs(solution.tokenKind);\n+        }\n+    }\n+\n+    private boolean isEndOfListBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACKET_TOKEN:\n+            case EOF_TOKEN:\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Parse rest-binding-pattern.\n+     *\n+     * rest-binding-pattern := ... variable-name\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parseRestBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                startContext(ParserRuleContext.REST_BINDING_PATTERN);\n+                STNode ellipsis = parseEllipsis();\n+                STNode varName = parseVariableName();\n+                endContext();\n+                return STNodeFactory.createRestBindingPatternNode(ellipsis, varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.REST_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-pattern entry.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parselistBindingPatternMember() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return consume();\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseBindingPattern();\n+        }\n+    }\n+\n+    /**\n+     * Parse Typed-binding-pattern.\n+     *\n+     * <code>typed-binding-pattern := inferable-type-descriptor binding-pattern</code>\n+     * <code>inferable-type-descriptor := type-descriptor | var</code>\n+     *\n+     * @return Fork statement\n+     */\n+    private STNode parseTypedBindingPattern() {\n+        startContext(ParserRuleContext.TYPED_BINDING_PATTERN);\n+        STNode typeDesc = parseTypeDescriptor(ParserRuleContext.TYPE_DESC_IN_TYPE_BINDING_PATTERN, true);\n+\n+        STNode bindingPattern = null;\n+        if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            STNode typedBindingPattern = parseArrayTypeDescOrListBindingPattern(typeDesc);\n+            endContext();\n+            return typedBindingPattern;\n+        }\n+        bindingPattern = parseBindingPattern();\n+\n+        endContext();\n+        return STNodeFactory.createTypedBindingPatternNode(typeDesc, bindingPattern);\n+    }\n+\n+    private STNode parseArrayTypeDescOrListBindingPattern(STNode typeDesc) {\n+\n+        STNode arrayDescOrListBindingPattern = parseListBindingPattern();\n+\n+        if (isListBindingPatternDefinitively(arrayDescOrListBindingPattern)) { // ambiguous means T[a]\n+            return STNodeFactory.createTypedBindingPatternNode(typeDesc,\n+                    cleanListBindingPattern(arrayDescOrListBindingPattern));\n+        }\n+\n+        if (isFollowTypedBindingPattern(peek().kind)) {\n+            return STNodeFactory.createTypedBindingPatternNode(typeDesc,\n+                    cleanListBindingPattern(arrayDescOrListBindingPattern));\n+        }\n+\n+        typeDesc = mergeTypeDescAndListBindingPattern(typeDesc, arrayDescOrListBindingPattern);\n+        if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            //this means arrayDescOrBLP is a array type desc\n+            return parseArrayTypeDescOrListBindingPattern(typeDesc);\n+        } else {\n+            return STNodeFactory.createTypedBindingPatternNode(typeDesc,\n+                    parseBindingPattern());\n+        }\n+\n+\n+    }\n+\n+    private STNode mergeTypeDescAndListBindingPattern(STNode typeDesc,\n+                                                      STNode bindingPattern) {\n+        STListBindingPatternNode listBindingPattern = (STListBindingPatternNode) bindingPattern;\n+        STNodeList childArray = (STNodeList) listBindingPattern.bindingPatterns;\n+        STNode child = childArray.childInBucket(0);\n+        if (child.kind == SyntaxKind.CAPTURE_BINDING_PATTERN) {\n+            child = ((STCaptureBindingPatternNode) child).variableName;\n+        }\n+        return STNodeFactory.createIndexedExpressionNode(typeDesc, listBindingPattern.openBracket,\n+                child,\n+                listBindingPattern.closeBracket);\n+    }\n+\n+    private STNode cleanListBindingPattern(STNode bindingPattern) {\n+        STListBindingPatternNode listBindingPattern = (STListBindingPatternNode) bindingPattern;\n+        STNodeList childArray = (STNodeList) listBindingPattern.bindingPatterns;\n+        int numberOfChildren = childArray.bucketCount();\n+\n+        ArrayList<STNode> cleanedChildren = new ArrayList<>();\n+        STNode child = null;\n+        for (int i = 0; i < numberOfChildren; i++) {\n+            child = childArray.childInBucket(i);\n+            switch (child.kind) {\n+                case DECIMAL_INTEGER_LITERAL:\n+                case HEX_INTEGER_LITERAL:\n+                case ASTERISK_TOKEN:\n+                    this.errorHandler.reportInvalidNode(null,\n+                            \"invalid Node \" + child.kind + \" in list-binding-pattern\");\n+                    cleanedChildren.add(STNodeFactory.createMissingToken(SyntaxKind.IDENTIFIER_TOKEN));\n+                    break;\n+                default:\n+                    cleanedChildren.add(child);\n+                    break;\n+            }\n+        }\n+\n+        return STNodeFactory.createListBindingPatternNode(listBindingPattern.openBracket,\n+                STNodeFactory.createNodeList(cleanedChildren),\n+                listBindingPattern.restBindingPattern,\n+                listBindingPattern.closeBracket);\n+    }\n+\n+    private boolean isListBindingPatternDefinitively(STNode bindingPattern) {\n+        STListBindingPatternNode listBindingPattern = (STListBindingPatternNode) bindingPattern;\n+        STNodeList childArray = (STNodeList) listBindingPattern.bindingPatterns;\n+        int numberOfChildren = childArray.bucketCount();\n+\n+        if (listBindingPattern.restBindingPattern != null) {\n+            return true;\n+        }\n+\n+        if (numberOfChildren == 1) {\n+            STNode child = childArray.childInBucket(0);\n+            switch (child.kind) {\n+                case LIST_BINDING_PATTERN:\n+                case REST_BINDING_PATTERN:\n+                    return true;\n+                default: // cases like [ and {\n+                    return false;", "originalCommit": "86b3868076bb1f535f392b0160046ac64a83811d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIwNzg1OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427207858", "bodyText": "sure", "author": "m36dot", "createdAt": "2020-05-19T10:49:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE5ODI1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIwMDMzMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23214#discussion_r427200333", "bodyText": "Regardless whether its a valid child or an invalid child, we need to keep it. That is required to regenerate the source-code using the syntax tree.\nSo we can simply rename this method as \"validateListBindingPattern\", and only log an error for invalid children, but let them stay.", "author": "SupunS", "createdAt": "2020-05-19T10:34:56Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9343,4 +9375,342 @@ private STNode parseIntersectionTypeDescriptor(STNode leftTypeDesc, ParserRuleCo\n         STNode rightTypeDesc = parseTypeDescriptor(context);\n         return STNodeFactory.createIntersectionTypeDescriptorNode(leftTypeDesc, bitwiseAndToken, rightTypeDesc);\n     }\n+\n+    /**\n+     * Parse binding-patterns.\n+     *\n+     * binding-pattern :=\n+     *   capture-binding-pattern\n+     *    | wildcard-binding-pattern\n+     *    | list-binding-pattern\n+     *    | mapping-binding-pattern\n+     *    | functional-binding-pattern\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     * wildcard-binding-pattern := _\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *    binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ] \n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     * rest-binding-pattern := ... variable-name\n+     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * arg-list-binding-pattern :=\n+     *    positional-arg-binding-patterns [, other-arg-binding-patterns]\n+     *    | other-arg-binding-patterns\n+     * positional-arg-binding-patterns := positional-arg-binding-pattern (, positional-arg-binding-pattern)*\n+     * positional-arg-binding-pattern := binding-pattern\n+     * other-arg-binding-patterns :=\n+     *    named-arg-binding-patterns [, rest-binding-pattern]\n+     *    | [rest-binding-pattern]\n+     * named-arg-binding-patterns := named-arg-binding-pattern (, named-arg-binding-pattern)*\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n+     *\n+     * @return binding-pattern node\n+     */\n+    private STNode parseBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case OPEN_BRACKET_TOKEN:\n+                return parseListBindingPattern();\n+            case IDENTIFIER_TOKEN:\n+                return parseCaptureBindingPattern();\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse capture-binding-pattern.\n+     *\n+     * capture-binding-pattern := variable-name\n+     * variable-name := identifier\n+     *\n+     * @return capture-binding-pattern node\n+     */\n+    private STNode parseCaptureBindingPattern() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case IDENTIFIER_TOKEN:\n+                STNode varName = parseVariableName();\n+                return STNodeFactory.createCaptureBindingPatternNode(varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.CAPTURE_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-patterns.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return list-binding-pattern node\n+     */\n+    private STNode parseListBindingPattern() {\n+        startContext(ParserRuleContext.LIST_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBracket = parseOpenBracket();\n+\n+        STNode listBindingPatternMember = parselistBindingPatternMember();\n+        bindingPatterns.add(listBindingPatternMember);\n+\n+        //parsing the main chunck of list-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode listBindingPatternRhs = null;\n+        while (!isEndOfListBindingPattern(token.kind) &&\n+                listBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            listBindingPatternRhs = parseListBindingpatternRhs(token.kind);\n+            if (listBindingPatternRhs == null) {\n+                break;\n+            }\n+            bindingPatterns.add(listBindingPatternRhs);\n+            listBindingPatternMember = parselistBindingPatternMember();\n+            bindingPatterns.add(listBindingPatternMember);\n+            token = peek();\n+        }\n+        STNode closeBracket = parseCloseBracket();\n+\n+        //seperating out the restbindingpattern\n+        STNode restBindingPattern = null;\n+        if (listBindingPatternMember.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(bindingPatterns.size() - 1);\n+        } else {\n+            restBindingPattern = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createListBindingPatternNode(openBracket,\n+                                                    bindingPatternsNode,\n+                                                    restBindingPattern,\n+                                                    closeBracket);\n+    }\n+\n+    private STNode parseListBindingpatternRhs() {\n+        return parseListBindingpatternRhs(peek().kind);\n+    }\n+\n+    private STNode parseListBindingpatternRhs(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case COMMA_TOKEN:\n+                return parseComma();\n+            case CLOSE_BRACKET_TOKEN:\n+                return null;\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.LIST_BINDING_PATTERN_END_OR_CONTINUE);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseListBindingpatternRhs(solution.tokenKind);\n+        }\n+    }\n+\n+    private boolean isEndOfListBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACKET_TOKEN:\n+            case EOF_TOKEN:\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Parse rest-binding-pattern.\n+     *\n+     * rest-binding-pattern := ... variable-name\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parseRestBindingPattern() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                startContext(ParserRuleContext.REST_BINDING_PATTERN);\n+                STNode ellipsis = parseEllipsis();\n+                STNode varName = parseVariableName();\n+                endContext();\n+                return STNodeFactory.createRestBindingPatternNode(ellipsis, varName);\n+            default:\n+                Solution sol = recover(token, ParserRuleContext.REST_BINDING_PATTERN);\n+                return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse list-binding-pattern entry.\n+     *\n+     * list-binding-pattern := [ list-member-binding-patterns ]\n+     * list-member-binding-patterns :=\n+     *      binding-pattern (, binding-pattern)* [, rest-binding-pattern]\n+     *      | [ rest-binding-pattern ]\n+     *\n+     * @return rest-binding-pattern node\n+     */\n+    private STNode parselistBindingPatternMember() {\n+        STToken token = peek();\n+\n+        switch (token.kind) {\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case ASTERISK_TOKEN:\n+                return consume();\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseBindingPattern();\n+        }\n+    }\n+\n+    /**\n+     * Parse Typed-binding-pattern.\n+     *\n+     * <code>typed-binding-pattern := inferable-type-descriptor binding-pattern</code>\n+     * <code>inferable-type-descriptor := type-descriptor | var</code>\n+     *\n+     * @return Fork statement\n+     */\n+    private STNode parseTypedBindingPattern() {\n+        startContext(ParserRuleContext.TYPED_BINDING_PATTERN);\n+        STNode typeDesc = parseTypeDescriptor(ParserRuleContext.TYPE_DESC_IN_TYPE_BINDING_PATTERN, true);\n+\n+        STNode bindingPattern = null;\n+        if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            STNode typedBindingPattern = parseArrayTypeDescOrListBindingPattern(typeDesc);\n+            endContext();\n+            return typedBindingPattern;\n+        }\n+        bindingPattern = parseBindingPattern();\n+\n+        endContext();\n+        return STNodeFactory.createTypedBindingPatternNode(typeDesc, bindingPattern);\n+    }\n+\n+    private STNode parseArrayTypeDescOrListBindingPattern(STNode typeDesc) {\n+\n+        STNode arrayDescOrListBindingPattern = parseListBindingPattern();\n+\n+        if (isListBindingPatternDefinitively(arrayDescOrListBindingPattern)) { // ambiguous means T[a]\n+            return STNodeFactory.createTypedBindingPatternNode(typeDesc,\n+                    cleanListBindingPattern(arrayDescOrListBindingPattern));\n+        }\n+\n+        if (isFollowTypedBindingPattern(peek().kind)) {\n+            return STNodeFactory.createTypedBindingPatternNode(typeDesc,\n+                    cleanListBindingPattern(arrayDescOrListBindingPattern));\n+        }\n+\n+        typeDesc = mergeTypeDescAndListBindingPattern(typeDesc, arrayDescOrListBindingPattern);\n+        if (peek().kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            //this means arrayDescOrBLP is a array type desc\n+            return parseArrayTypeDescOrListBindingPattern(typeDesc);\n+        } else {\n+            return STNodeFactory.createTypedBindingPatternNode(typeDesc,\n+                    parseBindingPattern());\n+        }\n+\n+\n+    }\n+\n+    private STNode mergeTypeDescAndListBindingPattern(STNode typeDesc,\n+                                                      STNode bindingPattern) {\n+        STListBindingPatternNode listBindingPattern = (STListBindingPatternNode) bindingPattern;\n+        STNodeList childArray = (STNodeList) listBindingPattern.bindingPatterns;\n+        STNode child = childArray.childInBucket(0);\n+        if (child.kind == SyntaxKind.CAPTURE_BINDING_PATTERN) {\n+            child = ((STCaptureBindingPatternNode) child).variableName;\n+        }\n+        return STNodeFactory.createIndexedExpressionNode(typeDesc, listBindingPattern.openBracket,\n+                child,\n+                listBindingPattern.closeBracket);\n+    }\n+\n+    private STNode cleanListBindingPattern(STNode bindingPattern) {\n+        STListBindingPatternNode listBindingPattern = (STListBindingPatternNode) bindingPattern;\n+        STNodeList childArray = (STNodeList) listBindingPattern.bindingPatterns;\n+        int numberOfChildren = childArray.bucketCount();\n+\n+        ArrayList<STNode> cleanedChildren = new ArrayList<>();\n+        STNode child = null;\n+        for (int i = 0; i < numberOfChildren; i++) {\n+            child = childArray.childInBucket(i);\n+            switch (child.kind) {\n+                case DECIMAL_INTEGER_LITERAL:\n+                case HEX_INTEGER_LITERAL:\n+                case ASTERISK_TOKEN:\n+                    this.errorHandler.reportInvalidNode(null,\n+                            \"invalid Node \" + child.kind + \" in list-binding-pattern\");\n+                    cleanedChildren.add(STNodeFactory.createMissingToken(SyntaxKind.IDENTIFIER_TOKEN));\n+                    break;\n+                default:\n+                    cleanedChildren.add(child);", "originalCommit": "86b3868076bb1f535f392b0160046ac64a83811d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6b08cbe92377b1bc413ff4a170865b8e9dbf3274", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6b08cbe92377b1bc413ff4a170865b8e9dbf3274", "message": "Refactor Code", "committedDate": "2020-05-19T11:28:15Z", "type": "commit"}]}