{"pr_number": 26106, "pr_title": "Implement error-match-pattern in parser", "pr_createdAt": "2020-09-25T10:58:08Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/26106", "timeline": [{"oid": "1361448ca8ba918eb6ebb63fd9cad7d114a357e0", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1361448ca8ba918eb6ebb63fd9cad7d114a357e0", "message": "Parser changes for error match pattern.", "committedDate": "2020-09-18T15:35:43Z", "type": "commit"}, {"oid": "c0038dcba629861d026f6840d0d8504a1494616c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c0038dcba629861d026f6840d0d8504a1494616c", "message": "Remove FunctionalMatchPattern", "committedDate": "2020-09-18T15:38:14Z", "type": "commit"}, {"oid": "ca8b33614bafcba085efdc7fdb649a351d9cd034", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ca8b33614bafcba085efdc7fdb649a351d9cd034", "message": "Error handler changes.", "committedDate": "2020-09-21T11:19:58Z", "type": "commit"}, {"oid": "f07898be82bde0268b6546395a8f17c4bc56555c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f07898be82bde0268b6546395a8f17c4bc56555c", "message": "Complete error handler for error binding pattern.", "committedDate": "2020-09-24T18:16:40Z", "type": "commit"}, {"oid": "19f3e5e30b97dc899ac9a3f252d1dd518260d2e1", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/19f3e5e30b97dc899ac9a3f252d1dd518260d2e1", "message": "Update test files.", "committedDate": "2020-09-25T09:21:33Z", "type": "commit"}, {"oid": "3d8fb9a21df2b5267b669d241470e1249b0af29e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3d8fb9a21df2b5267b669d241470e1249b0af29e", "message": "Fix failing parser tests.", "committedDate": "2020-09-25T09:49:40Z", "type": "commit"}, {"oid": "ad55053625d26a06221d6021f4a42fddc78aba97", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ad55053625d26a06221d6021f4a42fddc78aba97", "message": "Fix failing jballerina unit tests.", "committedDate": "2020-09-25T10:49:44Z", "type": "commit"}, {"oid": "7edd6425dae52598e3ef947260a7609e79eb8d60", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7edd6425dae52598e3ef947260a7609e79eb8d60", "message": "Update failing parser assert.", "committedDate": "2020-09-25T11:07:32Z", "type": "commit"}, {"oid": "a0cdadabd93b65a6e3305026f3f3f18e1c04b5a9", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a0cdadabd93b65a6e3305026f3f3f18e1c04b5a9", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into remove-functional-match", "committedDate": "2020-09-25T11:19:20Z", "type": "commit"}, {"oid": "5715172d1a0f0325bef0e47a7ac55d23144fd89b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5715172d1a0f0325bef0e47a7ac55d23144fd89b", "message": "Fix formatter issues.", "committedDate": "2020-09-25T12:00:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY3OTc4NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26106#discussion_r495679784", "bodyText": "It would be good to add the spec-snippet here as well, as a doc comment.\nThat would make it easier to quickly refer the grammar for someone who checks the code..", "author": "SupunS", "createdAt": "2020-09-28T04:10:56Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12216,84 +12213,174 @@ private boolean isMatchPatternEnd(SyntaxKind tokenKind) {\n     /**\n      * Parse functional match pattern.\n      * <p>\n-     * functional-match-pattern := functionally-constructible-type-reference ( arg-list-match-pattern )\n-     * <br/>\n-     * functionally-constructible-type-reference := error | type-reference\n-     * <br/>\n-     * type-reference := identifier | qualified-identifier\n-     * <br/>\n-     * arg-list-match-pattern := positional-arg-match-patterns [, other-arg-match-patterns]\n-     * | other-arg-match-patterns\n+     * error-match-pattern := error [error-type-reference] ( error-arg-list-match-pattern )\n+     * error-arg-list-match-pattern :=\n+     * error-message-match-pattern [, error-cause-match-pattern] [, error-field-match-patterns]\n+     * | [error-field-match-patterns]\n+     * error-message-match-pattern := simple-match-pattern\n+     * error-cause-match-pattern := simple-match-pattern | error-match-pattern\n+     * simple-match-pattern :=\n+     * wildcard-match-pattern\n+     * | const-pattern\n+     * | var variable-name\n+     * error-field-match-patterns :=\n+     * named-arg-match-pattern (, named-arg-match-pattern)* [, rest-match-pattern]\n+     * | rest-match-pattern\n+     * named-arg-match-pattern := arg-name = match-pattern\n      * </p>\n      *\n      * @return Parsed functional match pattern node.\n      */\n-    private STNode parseFunctionalMatchPattern(STNode typeRef) {\n-        startContext(ParserRuleContext.FUNCTIONAL_MATCH_PATTERN);\n+    private STNode parseErrorMatchPattern() {\n+        startContext(ParserRuleContext.ERROR_MATCH_PATTERN);\n+        STNode errorKeyword = consume();\n+        return parseErrorMatchPattern(errorKeyword);\n+    }\n+\n+    private STNode parseErrorMatchPattern(STNode errorKeyword) {\n+        STToken nextToken = peek();\n+        STNode typeRef;\n+        switch (nextToken.kind) {\n+            case IDENTIFIER_TOKEN:\n+                typeRef = parseTypeReference();\n+                break;\n+            case OPEN_PAREN_TOKEN:\n+                typeRef = STNodeFactory.createEmptyNode();\n+                break;\n+            default:\n+                recover(peek(), ParserRuleContext.ERROR_MATCH_PATTERN_ERROR_KEYWORD_RHS);\n+                return parseErrorMatchPattern(errorKeyword);\n+        }\n+        return parseErrorMatchPattern(errorKeyword, typeRef);\n+    }\n+\n+    private STNode parseErrorMatchPattern(STNode errorKeyword, STNode typeRef) {\n         STNode openParenthesisToken = parseOpenParenthesis(ParserRuleContext.OPEN_PARENTHESIS);\n-        STNode argListMatchPatternNode = parseArgListMatchPatterns();\n+        STNode argListMatchPatternNode = parseErrorArgListMatchPatterns();\n         STNode closeParenthesisToken = parseCloseParenthesis();\n         endContext();\n-        return STNodeFactory.createFunctionalMatchPatternNode(typeRef, openParenthesisToken, argListMatchPatternNode,\n-                closeParenthesisToken);\n+        return STNodeFactory.createErrorMatchPatternNode(errorKeyword, typeRef, openParenthesisToken,\n+                argListMatchPatternNode, closeParenthesisToken);\n     }\n \n-    private STNode parseArgListMatchPatterns() {\n+    private STNode parseErrorArgListMatchPatterns() {\n         List<STNode> argListMatchPatterns = new ArrayList<>();\n-        SyntaxKind lastValidArgKind = SyntaxKind.IDENTIFIER_TOKEN;\n \n-        while (!isEndOfFunctionalMatchPattern()) {\n-            STNode currentArg = parseArgMatchPattern();\n-            DiagnosticErrorCode errorCode = validateArgMatchPatternOrder(lastValidArgKind, currentArg.kind);\n-            if (errorCode == null) {\n-                argListMatchPatterns.add(currentArg);\n-                lastValidArgKind = currentArg.kind;\n+        if (isEndOfErrorFieldMatchPatterns()) {\n+            return STNodeFactory.createNodeList(argListMatchPatterns);\n+        }\n+        startContext(ParserRuleContext.ERROR_ARG_LIST_MATCH_PATTERN_FIRST_ARG);\n+        STNode firstArg = parseErrorArgListMatchPattern(ParserRuleContext.ERROR_ARG_LIST_MATCH_PATTERN_START);\n+        endContext();\n+        if (isSimpleMatchPattern(firstArg.kind)) {\n+\n+            argListMatchPatterns.add(firstArg);\n+            STNode argEnd = parseErrorArgListMatchPatternEnd(ParserRuleContext.ERROR_MESSAGE_MATCH_PATTERN_END);\n+            if (argEnd != null) {\n+                // null marks the end of args\n+                STNode secondArg = parseErrorArgListMatchPattern(ParserRuleContext.ERROR_MESSAGE_MATCH_PATTERN_RHS);\n+                if (isValidSecondArgMatchPattern(secondArg.kind)) {\n+                    argListMatchPatterns.add(argEnd);\n+                    argListMatchPatterns.add(secondArg);\n+                } else {\n+                    updateLastNodeInListWithInvalidNode(argListMatchPatterns, argEnd, null);\n+                    updateLastNodeInListWithInvalidNode(argListMatchPatterns, secondArg,\n+                            DiagnosticErrorCode.ERROR_MATCH_PATTERN_NOT_ALLOWED);\n+                }\n+            }\n+        } else {\n+            if (firstArg.kind != SyntaxKind.NAMED_ARG_MATCH_PATTERN &&\n+                    firstArg.kind != SyntaxKind.REST_MATCH_PATTERN) {\n+                addInvalidNodeToNextToken(firstArg, DiagnosticErrorCode.ERROR_MATCH_PATTERN_NOT_ALLOWED);\n             } else {\n-                updateLastNodeInListWithInvalidNode(argListMatchPatterns, currentArg, errorCode);\n+                argListMatchPatterns.add(firstArg);\n             }\n+        }\n \n-            STNode argRhs = parseArgMatchPatternRhs();\n+        parseErrorFieldMatchPatterns(argListMatchPatterns);\n+        return STNodeFactory.createNodeList(argListMatchPatterns);\n+    }\n+\n+    private boolean isSimpleMatchPattern(SyntaxKind matchPatternKind) {\n+        switch (matchPatternKind) {\n+            case IDENTIFIER_TOKEN:\n+            case SIMPLE_NAME_REFERENCE:\n+            case NUMERIC_LITERAL:\n+            case STRING_LITERAL:\n+            case NULL_LITERAL:\n+            case NIL_LITERAL:\n+            case BOOLEAN_LITERAL:\n+            case TYPED_BINDING_PATTERN:\n+            case UNARY_EXPRESSION:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean isValidSecondArgMatchPattern(SyntaxKind syntaxKind) {\n+        switch (syntaxKind) {\n+            case ERROR_MATCH_PATTERN:\n+            case NAMED_ARG_MATCH_PATTERN:\n+            case REST_MATCH_PATTERN:\n+                return true;\n+            default:\n+                if (isSimpleMatchPattern(syntaxKind)) {\n+                    return true;\n+                }\n+                return false;\n+        }\n+    }\n \n-            if (argRhs == null) {\n+    private void parseErrorFieldMatchPatterns(List<STNode> argListMatchPatterns) {", "originalCommit": "5715172d1a0f0325bef0e47a7ac55d23144fd89b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5NzY1MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26106#discussion_r495697650", "bodyText": "added", "author": "rdulmina", "createdAt": "2020-09-28T05:34:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY3OTc4NA=="}], "type": "inlineReview"}, {"oid": "59c78d1c3404d2bb23d640472c92c61f2de2dcd3", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/59c78d1c3404d2bb23d640472c92c61f2de2dcd3", "message": "Changed typeReference node type to NameReferenceNode.", "committedDate": "2020-09-28T05:21:49Z", "type": "commit"}, {"oid": "b17fbdb7d98b8c9130064fcd6ddc4b186353eeb8", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b17fbdb7d98b8c9130064fcd6ddc4b186353eeb8", "message": "Added requested doc comment.", "committedDate": "2020-09-28T05:32:48Z", "type": "commit"}, {"oid": "aff2e2e32f598a21c1382d34d316faca4b7d4e36", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/aff2e2e32f598a21c1382d34d316faca4b7d4e36", "message": "Fix checkstyle issue.", "committedDate": "2020-09-28T05:58:13Z", "type": "commit"}, {"oid": "a27c396710325e1a3ce5ab6bcf2551efdc84028e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a27c396710325e1a3ce5ab6bcf2551efdc84028e", "message": "Add missing type cast.", "committedDate": "2020-09-28T06:52:59Z", "type": "commit"}]}