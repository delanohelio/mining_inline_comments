{"pr_number": 27504, "pr_title": "[Testerina] Derive test suite from Syntax tree and Semantic API", "pr_createdAt": "2020-12-15T12:12:54Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/27504", "timeline": [{"oid": "eee1af5930f819d3b2e4d34f7c0c2d681d67f36a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/eee1af5930f819d3b2e4d34f7c0c2d681d67f36a", "message": "Change annotation processing for tests", "committedDate": "2020-12-15T13:51:01Z", "type": "forcePushed"}, {"oid": "e73cbb5c10074869b54fa591ded435052fa7be3f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e73cbb5c10074869b54fa591ded435052fa7be3f", "message": "Change annotation processing for tests", "committedDate": "2020-12-15T14:32:29Z", "type": "commit"}, {"oid": "e73cbb5c10074869b54fa591ded435052fa7be3f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e73cbb5c10074869b54fa591ded435052fa7be3f", "message": "Change annotation processing for tests", "committedDate": "2020-12-15T14:32:29Z", "type": "forcePushed"}, {"oid": "3bc47b1bd0180b5715432ea13ee4806e624cf3d5", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3bc47b1bd0180b5715432ea13ee4806e624cf3d5", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into new-testerina", "committedDate": "2020-12-15T14:33:04Z", "type": "commit"}, {"oid": "c08b1ed5a93cccac9696c12e5c94f5b4a3a4b4af", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c08b1ed5a93cccac9696c12e5c94f5b4a3a4b4af", "message": "Improve test annotation processing", "committedDate": "2020-12-17T20:37:25Z", "type": "commit"}, {"oid": "3b8a8b28e392beae9fb3b3248589771d5f237b84", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3b8a8b28e392beae9fb3b3248589771d5f237b84", "message": "Move test json generation logic", "committedDate": "2020-12-17T20:38:00Z", "type": "commit"}, {"oid": "3b8a8b28e392beae9fb3b3248589771d5f237b84", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3b8a8b28e392beae9fb3b3248589771d5f237b84", "message": "Move test json generation logic", "committedDate": "2020-12-17T20:38:00Z", "type": "forcePushed"}, {"oid": "2ac83d6dbda8f10ede0c8cc9a919adca64600b6e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2ac83d6dbda8f10ede0c8cc9a919adca64600b6e", "message": "Update annotation processing for Testerina", "committedDate": "2020-12-22T06:49:49Z", "type": "commit"}, {"oid": "cc648209fdb43a698f991feeda8cef8e5f629268", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/cc648209fdb43a698f991feeda8cef8e5f629268", "message": "Resolve conflicts", "committedDate": "2020-12-22T07:56:31Z", "type": "commit"}, {"oid": "828f40cb1a943a98eb2d7c53dfa015261da9c671", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/828f40cb1a943a98eb2d7c53dfa015261da9c671", "message": "Fix issues with testing", "committedDate": "2021-01-01T14:42:39Z", "type": "forcePushed"}, {"oid": "882e2a25d97224dc32fcadb9b2560f261a4f4c79", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/882e2a25d97224dc32fcadb9b2560f261a4f4c79", "message": "Fix issues after testing", "committedDate": "2021-01-04T06:39:57Z", "type": "commit"}, {"oid": "882e2a25d97224dc32fcadb9b2560f261a4f4c79", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/882e2a25d97224dc32fcadb9b2560f261a4f4c79", "message": "Fix issues after testing", "committedDate": "2021-01-04T06:39:57Z", "type": "forcePushed"}, {"oid": "02f8628b533cbbd923342d6257a964d4a5f83c70", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/02f8628b533cbbd923342d6257a964d4a5f83c70", "message": "Remove old implementation", "committedDate": "2021-01-04T08:11:37Z", "type": "commit"}, {"oid": "1a6d97ba6bb3a24893a54bbd1d58fd95bda10ff2", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1a6d97ba6bb3a24893a54bbd1d58fd95bda10ff2", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into new-testerina", "committedDate": "2021-01-04T08:29:38Z", "type": "commit"}, {"oid": "6d088463a01fd6c21745316b480214e82c0e38fc", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6d088463a01fd6c21745316b480214e82c0e38fc", "message": "Remove old implementation", "committedDate": "2021-01-04T10:57:22Z", "type": "commit"}, {"oid": "7c7fb3bda9984dba6588abb60caad24f5b33da7f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7c7fb3bda9984dba6588abb60caad24f5b33da7f", "message": "Fix review suggestions", "committedDate": "2021-01-05T17:57:19Z", "type": "commit"}, {"oid": "27247b8520ea63a584080d24fae101b534abf1cb", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/27247b8520ea63a584080d24fae101b534abf1cb", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into new-testerina", "committedDate": "2021-01-05T17:57:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM5NTU4NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27504#discussion_r552395584", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n          \n          \n            \n             * Copyright (c) 2021, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.", "author": "azinneera", "createdAt": "2021-01-06T06:36:09Z", "path": "misc/testerina/modules/testerina-core/src/main/java/org/ballerinalang/testerina/core/MockAnnotationProcessor.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.", "originalCommit": "27247b8520ea63a584080d24fae101b534abf1cb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM5NjA5MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27504#discussion_r552396090", "bodyText": "missing return statement", "author": "azinneera", "createdAt": "2021-01-06T06:37:47Z", "path": "misc/testerina/modules/testerina-core/src/main/java/org/ballerinalang/testerina/core/TestProcessor.java", "diffHunk": "@@ -0,0 +1,480 @@\n+/*\n+ * Copyright (c) 2021, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.ballerinalang.testerina.core;\n+\n+import io.ballerina.compiler.api.symbols.AnnotationSymbol;\n+import io.ballerina.compiler.api.symbols.FunctionSymbol;\n+import io.ballerina.compiler.api.symbols.Qualifier;\n+import io.ballerina.compiler.api.symbols.Symbol;\n+import io.ballerina.compiler.api.symbols.SymbolKind;\n+import io.ballerina.compiler.syntax.tree.AnnotationNode;\n+import io.ballerina.compiler.syntax.tree.ExpressionNode;\n+import io.ballerina.compiler.syntax.tree.FunctionDefinitionNode;\n+import io.ballerina.compiler.syntax.tree.ListConstructorExpressionNode;\n+import io.ballerina.compiler.syntax.tree.MappingConstructorExpressionNode;\n+import io.ballerina.compiler.syntax.tree.MappingFieldNode;\n+import io.ballerina.compiler.syntax.tree.MetadataNode;\n+import io.ballerina.compiler.syntax.tree.ModulePartNode;\n+import io.ballerina.compiler.syntax.tree.Node;\n+import io.ballerina.compiler.syntax.tree.NodeList;\n+import io.ballerina.compiler.syntax.tree.SpecificFieldNode;\n+import io.ballerina.compiler.syntax.tree.SyntaxKind;\n+import io.ballerina.compiler.syntax.tree.SyntaxTree;\n+import io.ballerina.projects.Document;\n+import io.ballerina.projects.JarResolver;\n+import io.ballerina.projects.Module;\n+import io.ballerina.projects.Project;\n+import io.ballerina.projects.ProjectKind;\n+import io.ballerina.projects.testsuite.Test;\n+import io.ballerina.projects.testsuite.TestSuite;\n+import io.ballerina.tools.diagnostics.Location;\n+import io.ballerina.tools.text.LinePosition;\n+import org.ballerinalang.model.elements.Flag;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Responsible of processing Testerina annotations.\n+ * Lifetime of an instance of this class will end upon the completion of processing a ballerina package.\n+ */\n+public class TestProcessor {\n+    private static final String TEST_ANNOTATION_NAME = \"Config\";\n+    private static final String BEFORE_SUITE_ANNOTATION_NAME = \"BeforeSuite\";\n+    private static final String AFTER_SUITE_ANNOTATION_NAME = \"AfterSuite\";\n+    private static final String BEFORE_EACH_ANNOTATION_NAME = \"BeforeEach\";\n+    private static final String AFTER_EACH_ANNOTATION_NAME = \"AfterEach\";\n+    private static final String BEFORE_FUNCTION = \"before\";\n+    private static final String AFTER_FUNCTION = \"after\";\n+    private static final String DEPENDS_ON_FUNCTIONS = \"dependsOn\";\n+    private static final String GROUP_ANNOTATION_NAME = \"groups\";\n+    private static final String VALUE_SET_ANNOTATION_NAME = \"dataProvider\";\n+    private static final String TEST_ENABLE_ANNOTATION_NAME = \"enable\";\n+    private static final String AFTER_SUITE_ALWAYS_RUN_FIELD_NAME = \"alwaysRun\";\n+    private static final String VALUE_FIELD_NAME = \"value\";\n+    private static final String BEFORE_GROUPS_ANNOTATION_NAME = \"BeforeGroups\";\n+    private static final String AFTER_GROUPS_ANNOTATION_NAME = \"AfterGroups\";\n+    private static final String TEST_PREFIX = \"@test:\";\n+\n+    private TesterinaRegistry registry = TesterinaRegistry.getInstance();\n+\n+    /**\n+     * Generate and return the testsuite for module tests.\n+     *\n+     * @param module  Module\n+     * @param project Project\n+     * @return Optional<TestSuite>\n+     */\n+    public Optional<TestSuite> testSuite(Module module, Project project) {\n+        if (project.kind() != ProjectKind.SINGLE_FILE_PROJECT\n+                && module.testDocumentIds().isEmpty()) {\n+            return Optional.empty();\n+        }\n+        // skip generation of the testsuite if --skip-tests option is set to true\n+        if (project.buildOptions().skipTests()) {\n+            return Optional.empty();\n+        }\n+        return Optional.of(generateTestSuite(module));\n+    }\n+\n+    /**\n+     * Get the syntax tree for tests.\n+     *\n+     * @param module Module\n+     * @return Map<String, SyntaxTree>\n+     */\n+    private Map<String, SyntaxTree> getTestSyntaxTreeMap(Module module) {\n+        Map<String, SyntaxTree> syntaxTreeMap = new HashMap<>();\n+        if (isSingleFileProject(module.project())) {\n+            module.documentIds().forEach(documentId -> {\n+                Document document = module.document(documentId);\n+                syntaxTreeMap.put(document.name(), document.syntaxTree());\n+            });\n+        } else {\n+            module.testDocumentIds().forEach(documentId -> {\n+                Document document = module.document(documentId);\n+                syntaxTreeMap.put(document.name(), document.syntaxTree());\n+            });\n+        }\n+        return syntaxTreeMap;\n+    }\n+\n+    /**\n+     * Generate the testsuite for module using syntax and semantic APIs.\n+     *\n+     * @param module  Module\n+     */", "originalCommit": "27247b8520ea63a584080d24fae101b534abf1cb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM5Njc1Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27504#discussion_r552396756", "bodyText": "Shall we use the constant in ProjectConstants instead of hardcoding .bal", "author": "azinneera", "createdAt": "2021-01-06T06:39:57Z", "path": "misc/testerina/modules/testerina-core/src/main/java/org/ballerinalang/testerina/core/TestProcessor.java", "diffHunk": "@@ -0,0 +1,480 @@\n+/*\n+ * Copyright (c) 2021, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.ballerinalang.testerina.core;\n+\n+import io.ballerina.compiler.api.symbols.AnnotationSymbol;\n+import io.ballerina.compiler.api.symbols.FunctionSymbol;\n+import io.ballerina.compiler.api.symbols.Qualifier;\n+import io.ballerina.compiler.api.symbols.Symbol;\n+import io.ballerina.compiler.api.symbols.SymbolKind;\n+import io.ballerina.compiler.syntax.tree.AnnotationNode;\n+import io.ballerina.compiler.syntax.tree.ExpressionNode;\n+import io.ballerina.compiler.syntax.tree.FunctionDefinitionNode;\n+import io.ballerina.compiler.syntax.tree.ListConstructorExpressionNode;\n+import io.ballerina.compiler.syntax.tree.MappingConstructorExpressionNode;\n+import io.ballerina.compiler.syntax.tree.MappingFieldNode;\n+import io.ballerina.compiler.syntax.tree.MetadataNode;\n+import io.ballerina.compiler.syntax.tree.ModulePartNode;\n+import io.ballerina.compiler.syntax.tree.Node;\n+import io.ballerina.compiler.syntax.tree.NodeList;\n+import io.ballerina.compiler.syntax.tree.SpecificFieldNode;\n+import io.ballerina.compiler.syntax.tree.SyntaxKind;\n+import io.ballerina.compiler.syntax.tree.SyntaxTree;\n+import io.ballerina.projects.Document;\n+import io.ballerina.projects.JarResolver;\n+import io.ballerina.projects.Module;\n+import io.ballerina.projects.Project;\n+import io.ballerina.projects.ProjectKind;\n+import io.ballerina.projects.testsuite.Test;\n+import io.ballerina.projects.testsuite.TestSuite;\n+import io.ballerina.tools.diagnostics.Location;\n+import io.ballerina.tools.text.LinePosition;\n+import org.ballerinalang.model.elements.Flag;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Responsible of processing Testerina annotations.\n+ * Lifetime of an instance of this class will end upon the completion of processing a ballerina package.\n+ */\n+public class TestProcessor {\n+    private static final String TEST_ANNOTATION_NAME = \"Config\";\n+    private static final String BEFORE_SUITE_ANNOTATION_NAME = \"BeforeSuite\";\n+    private static final String AFTER_SUITE_ANNOTATION_NAME = \"AfterSuite\";\n+    private static final String BEFORE_EACH_ANNOTATION_NAME = \"BeforeEach\";\n+    private static final String AFTER_EACH_ANNOTATION_NAME = \"AfterEach\";\n+    private static final String BEFORE_FUNCTION = \"before\";\n+    private static final String AFTER_FUNCTION = \"after\";\n+    private static final String DEPENDS_ON_FUNCTIONS = \"dependsOn\";\n+    private static final String GROUP_ANNOTATION_NAME = \"groups\";\n+    private static final String VALUE_SET_ANNOTATION_NAME = \"dataProvider\";\n+    private static final String TEST_ENABLE_ANNOTATION_NAME = \"enable\";\n+    private static final String AFTER_SUITE_ALWAYS_RUN_FIELD_NAME = \"alwaysRun\";\n+    private static final String VALUE_FIELD_NAME = \"value\";\n+    private static final String BEFORE_GROUPS_ANNOTATION_NAME = \"BeforeGroups\";\n+    private static final String AFTER_GROUPS_ANNOTATION_NAME = \"AfterGroups\";\n+    private static final String TEST_PREFIX = \"@test:\";\n+\n+    private TesterinaRegistry registry = TesterinaRegistry.getInstance();\n+\n+    /**\n+     * Generate and return the testsuite for module tests.\n+     *\n+     * @param module  Module\n+     * @param project Project\n+     * @return Optional<TestSuite>\n+     */\n+    public Optional<TestSuite> testSuite(Module module, Project project) {\n+        if (project.kind() != ProjectKind.SINGLE_FILE_PROJECT\n+                && module.testDocumentIds().isEmpty()) {\n+            return Optional.empty();\n+        }\n+        // skip generation of the testsuite if --skip-tests option is set to true\n+        if (project.buildOptions().skipTests()) {\n+            return Optional.empty();\n+        }\n+        return Optional.of(generateTestSuite(module));\n+    }\n+\n+    /**\n+     * Get the syntax tree for tests.\n+     *\n+     * @param module Module\n+     * @return Map<String, SyntaxTree>\n+     */\n+    private Map<String, SyntaxTree> getTestSyntaxTreeMap(Module module) {\n+        Map<String, SyntaxTree> syntaxTreeMap = new HashMap<>();\n+        if (isSingleFileProject(module.project())) {\n+            module.documentIds().forEach(documentId -> {\n+                Document document = module.document(documentId);\n+                syntaxTreeMap.put(document.name(), document.syntaxTree());\n+            });\n+        } else {\n+            module.testDocumentIds().forEach(documentId -> {\n+                Document document = module.document(documentId);\n+                syntaxTreeMap.put(document.name(), document.syntaxTree());\n+            });\n+        }\n+        return syntaxTreeMap;\n+    }\n+\n+    /**\n+     * Generate the testsuite for module using syntax and semantic APIs.\n+     *\n+     * @param module  Module\n+     */\n+    private TestSuite generateTestSuite(Module module) {\n+        TestSuite testSuite = new TestSuite(module.descriptor().name().toString(),\n+                module.descriptor().packageName().toString(),\n+                module.descriptor().org().value(), module.descriptor().version().toString());\n+        TesterinaRegistry.getInstance().getTestSuites().put(\n+                module.descriptor().name().toString(), testSuite);\n+        testSuite.setPackageName(module.descriptor().packageName().toString());\n+        testSuite.setSourceRootPath(module.project().sourceRoot().toString());\n+        addUtilityFunctions(module, testSuite);\n+        processAnnotations(module, testSuite);\n+        return testSuite;\n+    }\n+\n+    /**\n+     * Process the annotations for a given module.\n+     *\n+     * @param module        Module\n+     * @param suite        TestSuite\n+     */\n+    private void processAnnotations(Module module, TestSuite suite) {\n+        Map<String, SyntaxTree> syntaxTreeMap = getTestSyntaxTreeMap(module);\n+        List<FunctionSymbol> functionSymbolList = getFunctionSymbolList(syntaxTreeMap, module);\n+        for (FunctionSymbol functionSymbol : functionSymbolList) {\n+            String functionName = functionSymbol.name();\n+            List<AnnotationSymbol> annotations = functionSymbol.annotations();\n+            for (AnnotationSymbol annotationSymbol : annotations) {\n+                String annotationName = annotationSymbol.name();\n+                if (annotationName.contains(BEFORE_SUITE_ANNOTATION_NAME)) {\n+                    suite.addBeforeSuiteFunction(functionName);\n+                } else if (annotationName.contains(AFTER_SUITE_ANNOTATION_NAME)) {\n+                    suite.addAfterSuiteFunction(functionName,\n+                            isAlwaysRunAfterSuite(getAnnotationNode(annotationSymbol, syntaxTreeMap, functionName)));\n+                } else if (annotationName.contains(BEFORE_GROUPS_ANNOTATION_NAME)) {\n+                    processGroupsAnnotation(getAnnotationNode(annotationSymbol, syntaxTreeMap, functionName),\n+                            functionName, suite, true);\n+                } else if (annotationName.contains(AFTER_GROUPS_ANNOTATION_NAME)) {\n+                    processGroupsAnnotation(getAnnotationNode(annotationSymbol, syntaxTreeMap, functionName),\n+                            functionName, suite, false);\n+                } else if (annotationName.contains(BEFORE_EACH_ANNOTATION_NAME)) {\n+                    suite.addBeforeEachFunction(functionName);\n+                } else if (annotationName.contains(AFTER_EACH_ANNOTATION_NAME)) {\n+                    suite.addAfterEachFunction(functionName);\n+                } else if (annotationName.contains(TEST_ANNOTATION_NAME)) {\n+                    processTestAnnotation(getAnnotationNode(annotationSymbol, syntaxTreeMap, functionName),\n+                            functionName, suite);\n+                } else {\n+                    // disregard this annotation\n+                }\n+            }\n+        }\n+    }\n+\n+    private AnnotationNode getAnnotationNode(AnnotationSymbol annotationSymbol, Map<String, SyntaxTree> syntaxTreeMap,\n+                                             String function) {\n+        for (Map.Entry<String, SyntaxTree> syntaxTreeEntry : syntaxTreeMap.entrySet()) {\n+            if (syntaxTreeEntry.getValue().containsModulePart()) {\n+                ModulePartNode modulePartNode = syntaxTreeMap.get(syntaxTreeEntry.getKey()).rootNode();\n+                for (Node node : modulePartNode.members()) {\n+                    if ((node.kind() == SyntaxKind.FUNCTION_DEFINITION) && node instanceof FunctionDefinitionNode) {\n+                        String functionName = ((FunctionDefinitionNode) node).functionName().text();\n+                        if (functionName.equals(function)) {\n+                            Optional<MetadataNode> optionalMetadataNode = ((FunctionDefinitionNode) node).metadata();\n+                            if (optionalMetadataNode.isEmpty()) {\n+                                continue;\n+                            } else {\n+                                NodeList<AnnotationNode> annotations = optionalMetadataNode.get().annotations();\n+                                for (AnnotationNode annotation : annotations) {\n+                                    if ((annotation.toString().trim()).contains(\n+                                            TEST_PREFIX + annotationSymbol.name())) {\n+                                        return annotation;\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Get function symbols list using syntax tree and semantic API.\n+     *\n+     * @param syntaxTreeMap Map<String, SyntaxTree>\n+     * @param module        Module\n+     * @return List<FunctionSymbol>\n+     */\n+    private List<FunctionSymbol> getFunctionSymbolList(Map<String, SyntaxTree> syntaxTreeMap, Module module) {\n+        List<FunctionSymbol> functionSymbolList = new ArrayList<>();\n+        List<String> functionNamesList = new ArrayList<>();\n+        for (Map.Entry<String, SyntaxTree> syntaxTreeEntry : syntaxTreeMap.entrySet()) {\n+            List<Symbol> symbols = module.getCompilation().getSemanticModel().visibleSymbols(\n+                    syntaxTreeEntry.getKey(),\n+                    LinePosition.from(syntaxTreeEntry.getValue().rootNode().location().lineRange().endLine().line(),\n+                            syntaxTreeEntry.getValue().rootNode().location().lineRange().endLine().offset()));\n+            for (Symbol symbol : symbols) {\n+                if (symbol.kind() == SymbolKind.FUNCTION && symbol instanceof FunctionSymbol &&\n+                        !functionNamesList.contains(symbol.name())) {\n+                    functionSymbolList.add((FunctionSymbol) symbol);\n+                    functionNamesList.add(symbol.name());\n+                }\n+            }\n+        }\n+        return functionSymbolList;\n+    }\n+\n+    /**\n+     * Checks whether given project is a single file project.\n+     *\n+     * @param project Project\n+     * @return boolean\n+     */\n+    private boolean isSingleFileProject(Project project) {\n+        boolean isSingleFileProject = false;\n+        if (project.kind() == ProjectKind.SINGLE_FILE_PROJECT) {\n+            isSingleFileProject = true;\n+        }\n+        return isSingleFileProject;\n+    }\n+\n+    /**\n+     * Add utility functions for the test suite.\n+     *\n+     * @param module        Module\n+     * @param testSuite     TestSuite\n+     */\n+    private void addUtilityFunctions(Module module, TestSuite testSuite) {\n+        Map<String, SyntaxTree> syntaxTreeMap = new HashMap<>();\n+        module.documentIds().forEach(documentId -> {\n+            Document document = module.document(documentId);\n+            syntaxTreeMap.put(document.name(), document.syntaxTree());\n+        });\n+        if (!isSingleFileProject(module.project())) {\n+            module.testDocumentIds().forEach(documentId -> {\n+                Document document = module.document(documentId);\n+                syntaxTreeMap.put(document.name(), document.syntaxTree());\n+            });\n+        }\n+        List<FunctionSymbol> functionSymbolList = getFunctionSymbolList(syntaxTreeMap, module);\n+        for (FunctionSymbol functionSymbol : functionSymbolList) {\n+            String functionName = functionSymbol.name();\n+            Location pos = functionSymbol.location();\n+            List<Qualifier> qualifiers = functionSymbol.qualifiers();\n+            boolean isUtility = true;\n+            for (Qualifier qualifier : qualifiers) {\n+                if (Flag.RESOURCE.name().equals(qualifier.getValue()) ||\n+                        Flag.REMOTE.name().equals(qualifier.getValue())) {\n+                    isUtility = false;\n+                    break;\n+                }\n+            }\n+            if (pos != null && isUtility) {\n+                // Remove the duplicated annotations.\n+                String className = pos.lineRange().filePath().replace(\".bal\", \"\")", "originalCommit": "27247b8520ea63a584080d24fae101b534abf1cb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM5NzM3Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27504#discussion_r552397373", "bodyText": "shall we remove the io.ballerina.projects.testsuite package and move all the classes back to testerina runtime module?", "author": "azinneera", "createdAt": "2021-01-06T06:42:05Z", "path": "misc/testerina/modules/testerina-core/src/main/java/org/ballerinalang/testerina/core/TesterinaRegistry.java", "diffHunk": "@@ -17,7 +17,7 @@\n */\n package org.ballerinalang.testerina.core;\n \n-import org.ballerinalang.test.runtime.entity.TestSuite;\n+import io.ballerina.projects.testsuite.TestSuite;", "originalCommit": "27247b8520ea63a584080d24fae101b534abf1cb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM5Nzg1OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/27504#discussion_r552397859", "bodyText": "we can access the project from the module using module.project()", "author": "azinneera", "createdAt": "2021-01-06T06:43:47Z", "path": "cli/ballerina-cli/src/main/java/io/ballerina/cli/task/RunTestsTask.java", "diffHunk": "@@ -160,15 +161,15 @@ public void execute(Project project) {\n         PackageCompilation packageCompilation = project.currentPackage().getCompilation();\n         JBallerinaBackend jBallerinaBackend = JBallerinaBackend.from(packageCompilation, JvmTarget.JAVA_11);\n         JarResolver jarResolver = jBallerinaBackend.jarResolver();\n-\n+        TestProcessor testProcessor = new TestProcessor();\n         // Only tests in packages are executed so default packages i.e. single bal files which has the package name\n         // as \".\" are ignored. This is to be consistent with the \"ballerina test\" command which only executes tests\n         // in packages.\n         for (ModuleId moduleId : project.currentPackage().moduleIds()) {\n             Module module = project.currentPackage().module(moduleId);\n             ModuleName moduleName = module.moduleName();\n \n-            TestSuite suite = jBallerinaBackend.testSuite(module).orElse(null);\n+            TestSuite suite = testProcessor.testSuite(module, project).orElse(null);", "originalCommit": "27247b8520ea63a584080d24fae101b534abf1cb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "42e4227f2a68b54ce451945ead2cdc03f096f2cd", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/42e4227f2a68b54ce451945ead2cdc03f096f2cd", "message": "Fix PR suggestions", "committedDate": "2021-01-06T09:55:25Z", "type": "commit"}, {"oid": "5f4728dc5bf62753fd38f3f59674ad7d9e2590fb", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5f4728dc5bf62753fd38f3f59674ad7d9e2590fb", "message": "Fix formatting issue", "committedDate": "2021-01-06T17:54:57Z", "type": "commit"}]}