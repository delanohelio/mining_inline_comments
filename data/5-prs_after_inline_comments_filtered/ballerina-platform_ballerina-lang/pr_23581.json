{"pr_number": 23581, "pr_title": "Add xml navigate expression parsing", "pr_createdAt": "2020-05-28T15:33:27Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/23581", "timeline": [{"oid": "34923daf61e79ad83969655226da5cd3ec299ef5", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/34923daf61e79ad83969655226da5cd3ec299ef5", "message": "Add xml filter expression parsing", "committedDate": "2020-05-28T08:24:27Z", "type": "commit"}, {"oid": "f45163e9fa568a4130f19f0c2be49ac44d225194", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f45163e9fa568a4130f19f0c2be49ac44d225194", "message": "Add xml filter syntax validation test cases", "committedDate": "2020-05-28T08:25:40Z", "type": "commit"}, {"oid": "76dfb9a159cd93547a1dfede80e876bc191d00d4", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/76dfb9a159cd93547a1dfede80e876bc191d00d4", "message": "Add xml step expression parsing", "committedDate": "2020-05-28T13:42:04Z", "type": "commit"}, {"oid": "3201944e69e4d896b18781435d23def7f6eaf143", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3201944e69e4d896b18781435d23def7f6eaf143", "message": "Add xml filter syntax validation test cases", "committedDate": "2020-05-28T13:43:43Z", "type": "commit"}, {"oid": "2fafddc846bc83ee150b1b775050d159dab1b671", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2fafddc846bc83ee150b1b775050d159dab1b671", "message": "Refactor Code", "committedDate": "2020-05-28T15:22:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIzNzIyNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23581#discussion_r432237226", "bodyText": "Can we use parseMemberAccessExpr? Because it already handles the contexts as well, and I feel both grammar are the same:\nexpression xml-step-start [expression] is equivalent to both:\n\nexpression [expression] and\nexpression xml-step-start xml-step-extend\n\nSo we can simply return if its not .< and parseExpressionRhs will take care of the rest. wdyt?", "author": "SupunS", "createdAt": "2020-05-29T03:32:46Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12025,4 +12043,338 @@ private STNode parseByteArrayContent(SyntaxKind kind) {\n \n         return content;\n     }\n+\n+    /**\n+     * Parse xml filter expression.\n+     * <p>\n+     * <code>xml-filter-expr := expression .< xml-name-pattern ></code>\n+     *\n+     * @param lhsExpr Preceding expression of .< token\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLFilterExpression(STNode lhsExpr) {\n+        STNode xmlNamePatternChain = parseXMLFilterExpressionRhs();\n+        return STNodeFactory.createXMLFilterExpressionNode(lhsExpr, xmlNamePatternChain);\n+    }\n+\n+    /**\n+     * Parse xml filter expression rhs.\n+     * <p>\n+     * <code>filer-expression-rhs := .< xml-name-pattern ></code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLFilterExpressionRhs() {\n+        STNode dotLTToken = parseDotLTToken();\n+        return parseXMLNamePatternChain(dotLTToken);\n+    }\n+\n+    /**\n+     * Parse xml name pattern chain.\n+     * <p>\n+     * <code>\n+     * xml-name-pattern-chain := filer-expression-rhs | xml-element-children-step | xml-element-descendants-step\n+     * <br/>\n+     * filer-expression-rhs := .< xml-name-pattern >\n+     * <br/>\n+     * xml-element-children-step := /< xml-name-pattern >\n+     * <br/>\n+     * xml-element-descendants-step := /**\\/<xml-name-pattern >\n+     * </code>\n+     *\n+     * @param startToken Preceding token of xml name pattern\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLNamePatternChain(STNode startToken) {\n+        STNode xmlNamePattern = parseXMLNamePattern();\n+        STNode gtToken = parseGTToken();\n+        return STNodeFactory.createXMLNamePatternChainingNode(startToken, xmlNamePattern, gtToken);\n+    }\n+\n+    /**\n+     * Parse <code> .< </code> token.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseDotLTToken() {\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.DOT_LT_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(nextToken, ParserRuleContext.DOT_LT_TOKEN);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse xml name pattern.\n+     * <p>\n+     * <code>xml-name-pattern := xml-atomic-name-pattern [| xml-atomic-name-pattern]*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLNamePattern() {\n+        List<STNode> xmlAtomicNamePatternList = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Return an empty list\n+        if (isEndOfXMLNamePattern(nextToken.kind)) {\n+            this.errorHandler.reportMissingTokenError(\"missing xml atomic name pattern\");\n+            return STNodeFactory.createNodeList(xmlAtomicNamePatternList);\n+        }\n+\n+        // Parse first xml atomic name pattern, that has no leading pipe token\n+        STNode xmlAtomicNamePattern = parseXMLAtomicNamePattern();\n+        xmlAtomicNamePatternList.add(xmlAtomicNamePattern);\n+\n+        // Parse the remaining xml atomic name patterns\n+        nextToken = peek();\n+        STNode leadingPipe;\n+        while (!isEndOfXMLNamePattern(nextToken.kind)) {\n+            leadingPipe = parsePipeToken();\n+            xmlAtomicNamePatternList.add(leadingPipe);\n+            xmlAtomicNamePattern = parseXMLAtomicNamePattern();\n+            xmlAtomicNamePatternList.add(xmlAtomicNamePattern);\n+            nextToken = peek();\n+        }\n+\n+        return STNodeFactory.createNodeList(xmlAtomicNamePatternList);\n+    }\n+\n+    private boolean isEndOfXMLNamePattern(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case IDENTIFIER_TOKEN:\n+            case ASTERISK_TOKEN:\n+            case COLON_TOKEN:\n+                return false;\n+            case GT_TOKEN:\n+            case EOF_TOKEN:\n+            case AT_TOKEN:\n+            case DOCUMENTATION_LINE:\n+            case CLOSE_BRACE_TOKEN:\n+            case SEMICOLON_TOKEN:\n+            case PUBLIC_KEYWORD:\n+            case PRIVATE_KEYWORD:\n+            case FUNCTION_KEYWORD:\n+            case RETURNS_KEYWORD:\n+            case SERVICE_KEYWORD:\n+            case TYPE_KEYWORD:\n+            case LISTENER_KEYWORD:\n+            case CONST_KEYWORD:\n+            case FINAL_KEYWORD:\n+            case RESOURCE_KEYWORD:\n+                return true;\n+            default:\n+                return isSimpleType(tokenKind);\n+        }\n+    }\n+\n+    /**\n+     * Parse xml atomic name pattern.\n+     * <p>\n+     * <code>\n+     * xml-atomic-name-pattern :=\n+     *   *\n+     *   | identifier\n+     *   | xml-namespace-prefix : identifier\n+     *   | xml-namespace-prefix : *\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLAtomicNamePattern() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.ASTERISK_TOKEN) {\n+            return consume();\n+        } else if (token.kind == SyntaxKind.IDENTIFIER_TOKEN) {\n+            STNode identifier = consume();\n+            return parseXMLAtomicNameIdentifier(identifier);\n+        }\n+        return STNodeFactory.createEmptyNode();\n+    }\n+\n+    private STNode parseXMLAtomicNameIdentifier(STNode identifier) {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.COLON_TOKEN) {\n+            STNode colon = consume();\n+            STToken nextToken = peek();\n+            if (nextToken.kind == SyntaxKind.IDENTIFIER_TOKEN || nextToken.kind == SyntaxKind.ASTERISK_TOKEN) {\n+                STToken endToken = consume();\n+                return STNodeFactory.createXMLAtomicNamePatternNode(identifier, colon, endToken);\n+            }\n+        }\n+        return STNodeFactory.createSimpleNameReferenceNode(identifier);\n+    }\n+\n+    /**\n+     * Parse xml step expression.\n+     * <p>\n+     * <code>xml-step-expr := expression xml-step-start xml-step-extend*</code>\n+     *\n+     * @param lhsExpr Preceding expression of /*, /<, or /**\\/< token\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLStepExpression(STNode lhsExpr) {\n+        STNode xmlStepStart = parseXMLStepStart();\n+        STNode xmlStepExtendList = parseXMLStepExtendList();\n+        return STNodeFactory.createXMLStepExpressionNode(lhsExpr, xmlStepStart, xmlStepExtendList);\n+    }\n+\n+    /**\n+     * Parse xml filter expression rhs.\n+     * <p>\n+     * <code>\n+     *  xml-step-start :=\n+     *      xml-all-children-step\n+     *      | xml-element-children-step\n+     *      | xml-element-descendants-step\n+     * <br/>\n+     * xml-all-children-step := /*\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLStepStart() {\n+        STToken token = peek();\n+        STNode startToken;\n+\n+        switch (token.kind) {\n+            case SLASH_ASTERISK_TOKEN:\n+                return consume();\n+            case DOUBLE_SLASH_DOUBLE_ASTERISK_LT_TOKEN:\n+                startToken = parseDoubleSlashDoubleAsteriskLTToken();\n+                break;\n+            case SLASH_LT_TOKEN:\n+            default:\n+                startToken = parseSlashLTToken();\n+                break;\n+        }\n+        return parseXMLNamePatternChain(startToken);\n+    }\n+\n+    /**\n+     * Parse <code> /< </code> token.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseSlashLTToken() {\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.SLASH_LT_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(nextToken, ParserRuleContext.SLASH_LT_TOKEN);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse <code> /< </code> token.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseDoubleSlashDoubleAsteriskLTToken() {\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.DOUBLE_SLASH_DOUBLE_ASTERISK_LT_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(nextToken, ParserRuleContext.DOUBLE_SLASH_DOUBLE_ASTERISK_LT_TOKEN);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse xml step extend list.\n+     * <p>\n+     * <code>xml-step-extend-list := xml-step-extend*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLStepExtendList() {\n+        List<STNode> xmlStepExtendList = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Return an empty list\n+        if (isEndOfXMLStepExtend(nextToken.kind)) {\n+            return STNodeFactory.createNodeList(xmlStepExtendList);\n+        }\n+\n+        nextToken = peek();\n+        STNode xmlStepExtend;\n+        while (!isEndOfXMLNamePattern(nextToken.kind)) {\n+            xmlStepExtend = parseXMLStepExtend();\n+            xmlStepExtendList.add(xmlStepExtend);\n+            nextToken = peek();\n+        }\n+\n+        return STNodeFactory.createNodeList(xmlStepExtendList);\n+    }\n+\n+    private boolean isEndOfXMLStepExtend(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case DOT_LT_TOKEN:\n+            case OPEN_BRACKET_TOKEN:\n+            case DOT_TOKEN:\n+                return false;\n+            default:\n+                return true;\n+        }\n+    }\n+\n+    /**\n+     * Parse xml step extend list.\n+     * <p>\n+     * <code>\n+     * xml-step-extend :=\n+     *    .< xml-name-pattern >\n+     *    | [ expression ]\n+     *    | . method-name ( arg-list )\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLStepExtend() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case DOT_LT_TOKEN:\n+                return parseXMLFilterExpressionRhs();\n+            case DOT_TOKEN:\n+                return parseMethodCallChain();\n+            // token kind is already validated in isEndOfXMLStepExtend and reach here.\n+            // therefore, a recover solution is not required for the default case.\n+            case OPEN_BRACKET_TOKEN:\n+            default:\n+                return parseOpenBracketExpressionChain();\n+\n+        }\n+    }\n+\n+    /**\n+     * Parse open bracket expression chain.\n+     * <p>\n+     * <code>open-bracket-expression-chain := `[` expression `]`</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOpenBracketExpressionChain() {", "originalCommit": "2fafddc846bc83ee150b1b775050d159dab1b671", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3MjAyMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23581#discussion_r432272023", "bodyText": "Please review the last commit.\nWith above change we will have problems like following.\na /* .<*> [e] .b()\nearlier [e] and .b() are parsed as two xml-step-extends. Now [e] .b() is combined and make a single method-call-expr\na /* [d] [e] .<*>\nearlier [d], [e] and .<*> are parsed as three xml-step-extends. Now [d] [e] .<*> is parsed as a xml-filter-expr as it has expr .<xml-name-pattern> grammar.", "author": "lochana-chathura", "createdAt": "2020-05-29T06:01:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIzNzIyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMzMTIxNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23581#discussion_r432331217", "bodyText": "I think thats OK.\nThat separation in the grammar is used to describe the runtime behaviour. For the parser, it's a one structure.", "author": "SupunS", "createdAt": "2020-05-29T08:23:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIzNzIyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIzNzk2Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23581#discussion_r432237963", "bodyText": "Probably be able to simply let the parseExpressionRhs handles it, similar to above.", "author": "SupunS", "createdAt": "2020-05-29T03:36:23Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12025,4 +12043,338 @@ private STNode parseByteArrayContent(SyntaxKind kind) {\n \n         return content;\n     }\n+\n+    /**\n+     * Parse xml filter expression.\n+     * <p>\n+     * <code>xml-filter-expr := expression .< xml-name-pattern ></code>\n+     *\n+     * @param lhsExpr Preceding expression of .< token\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLFilterExpression(STNode lhsExpr) {\n+        STNode xmlNamePatternChain = parseXMLFilterExpressionRhs();\n+        return STNodeFactory.createXMLFilterExpressionNode(lhsExpr, xmlNamePatternChain);\n+    }\n+\n+    /**\n+     * Parse xml filter expression rhs.\n+     * <p>\n+     * <code>filer-expression-rhs := .< xml-name-pattern ></code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLFilterExpressionRhs() {\n+        STNode dotLTToken = parseDotLTToken();\n+        return parseXMLNamePatternChain(dotLTToken);\n+    }\n+\n+    /**\n+     * Parse xml name pattern chain.\n+     * <p>\n+     * <code>\n+     * xml-name-pattern-chain := filer-expression-rhs | xml-element-children-step | xml-element-descendants-step\n+     * <br/>\n+     * filer-expression-rhs := .< xml-name-pattern >\n+     * <br/>\n+     * xml-element-children-step := /< xml-name-pattern >\n+     * <br/>\n+     * xml-element-descendants-step := /**\\/<xml-name-pattern >\n+     * </code>\n+     *\n+     * @param startToken Preceding token of xml name pattern\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLNamePatternChain(STNode startToken) {\n+        STNode xmlNamePattern = parseXMLNamePattern();\n+        STNode gtToken = parseGTToken();\n+        return STNodeFactory.createXMLNamePatternChainingNode(startToken, xmlNamePattern, gtToken);\n+    }\n+\n+    /**\n+     * Parse <code> .< </code> token.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseDotLTToken() {\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.DOT_LT_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(nextToken, ParserRuleContext.DOT_LT_TOKEN);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse xml name pattern.\n+     * <p>\n+     * <code>xml-name-pattern := xml-atomic-name-pattern [| xml-atomic-name-pattern]*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLNamePattern() {\n+        List<STNode> xmlAtomicNamePatternList = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Return an empty list\n+        if (isEndOfXMLNamePattern(nextToken.kind)) {\n+            this.errorHandler.reportMissingTokenError(\"missing xml atomic name pattern\");\n+            return STNodeFactory.createNodeList(xmlAtomicNamePatternList);\n+        }\n+\n+        // Parse first xml atomic name pattern, that has no leading pipe token\n+        STNode xmlAtomicNamePattern = parseXMLAtomicNamePattern();\n+        xmlAtomicNamePatternList.add(xmlAtomicNamePattern);\n+\n+        // Parse the remaining xml atomic name patterns\n+        nextToken = peek();\n+        STNode leadingPipe;\n+        while (!isEndOfXMLNamePattern(nextToken.kind)) {\n+            leadingPipe = parsePipeToken();\n+            xmlAtomicNamePatternList.add(leadingPipe);\n+            xmlAtomicNamePattern = parseXMLAtomicNamePattern();\n+            xmlAtomicNamePatternList.add(xmlAtomicNamePattern);\n+            nextToken = peek();\n+        }\n+\n+        return STNodeFactory.createNodeList(xmlAtomicNamePatternList);\n+    }\n+\n+    private boolean isEndOfXMLNamePattern(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case IDENTIFIER_TOKEN:\n+            case ASTERISK_TOKEN:\n+            case COLON_TOKEN:\n+                return false;\n+            case GT_TOKEN:\n+            case EOF_TOKEN:\n+            case AT_TOKEN:\n+            case DOCUMENTATION_LINE:\n+            case CLOSE_BRACE_TOKEN:\n+            case SEMICOLON_TOKEN:\n+            case PUBLIC_KEYWORD:\n+            case PRIVATE_KEYWORD:\n+            case FUNCTION_KEYWORD:\n+            case RETURNS_KEYWORD:\n+            case SERVICE_KEYWORD:\n+            case TYPE_KEYWORD:\n+            case LISTENER_KEYWORD:\n+            case CONST_KEYWORD:\n+            case FINAL_KEYWORD:\n+            case RESOURCE_KEYWORD:\n+                return true;\n+            default:\n+                return isSimpleType(tokenKind);\n+        }\n+    }\n+\n+    /**\n+     * Parse xml atomic name pattern.\n+     * <p>\n+     * <code>\n+     * xml-atomic-name-pattern :=\n+     *   *\n+     *   | identifier\n+     *   | xml-namespace-prefix : identifier\n+     *   | xml-namespace-prefix : *\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLAtomicNamePattern() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.ASTERISK_TOKEN) {\n+            return consume();\n+        } else if (token.kind == SyntaxKind.IDENTIFIER_TOKEN) {\n+            STNode identifier = consume();\n+            return parseXMLAtomicNameIdentifier(identifier);\n+        }\n+        return STNodeFactory.createEmptyNode();\n+    }\n+\n+    private STNode parseXMLAtomicNameIdentifier(STNode identifier) {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.COLON_TOKEN) {\n+            STNode colon = consume();\n+            STToken nextToken = peek();\n+            if (nextToken.kind == SyntaxKind.IDENTIFIER_TOKEN || nextToken.kind == SyntaxKind.ASTERISK_TOKEN) {\n+                STToken endToken = consume();\n+                return STNodeFactory.createXMLAtomicNamePatternNode(identifier, colon, endToken);\n+            }\n+        }\n+        return STNodeFactory.createSimpleNameReferenceNode(identifier);\n+    }\n+\n+    /**\n+     * Parse xml step expression.\n+     * <p>\n+     * <code>xml-step-expr := expression xml-step-start xml-step-extend*</code>\n+     *\n+     * @param lhsExpr Preceding expression of /*, /<, or /**\\/< token\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLStepExpression(STNode lhsExpr) {\n+        STNode xmlStepStart = parseXMLStepStart();\n+        STNode xmlStepExtendList = parseXMLStepExtendList();\n+        return STNodeFactory.createXMLStepExpressionNode(lhsExpr, xmlStepStart, xmlStepExtendList);\n+    }\n+\n+    /**\n+     * Parse xml filter expression rhs.\n+     * <p>\n+     * <code>\n+     *  xml-step-start :=\n+     *      xml-all-children-step\n+     *      | xml-element-children-step\n+     *      | xml-element-descendants-step\n+     * <br/>\n+     * xml-all-children-step := /*\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLStepStart() {\n+        STToken token = peek();\n+        STNode startToken;\n+\n+        switch (token.kind) {\n+            case SLASH_ASTERISK_TOKEN:\n+                return consume();\n+            case DOUBLE_SLASH_DOUBLE_ASTERISK_LT_TOKEN:\n+                startToken = parseDoubleSlashDoubleAsteriskLTToken();\n+                break;\n+            case SLASH_LT_TOKEN:\n+            default:\n+                startToken = parseSlashLTToken();\n+                break;\n+        }\n+        return parseXMLNamePatternChain(startToken);\n+    }\n+\n+    /**\n+     * Parse <code> /< </code> token.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseSlashLTToken() {\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.SLASH_LT_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(nextToken, ParserRuleContext.SLASH_LT_TOKEN);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse <code> /< </code> token.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseDoubleSlashDoubleAsteriskLTToken() {\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.DOUBLE_SLASH_DOUBLE_ASTERISK_LT_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(nextToken, ParserRuleContext.DOUBLE_SLASH_DOUBLE_ASTERISK_LT_TOKEN);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse xml step extend list.\n+     * <p>\n+     * <code>xml-step-extend-list := xml-step-extend*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLStepExtendList() {\n+        List<STNode> xmlStepExtendList = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Return an empty list\n+        if (isEndOfXMLStepExtend(nextToken.kind)) {\n+            return STNodeFactory.createNodeList(xmlStepExtendList);\n+        }\n+\n+        nextToken = peek();\n+        STNode xmlStepExtend;\n+        while (!isEndOfXMLNamePattern(nextToken.kind)) {\n+            xmlStepExtend = parseXMLStepExtend();\n+            xmlStepExtendList.add(xmlStepExtend);\n+            nextToken = peek();\n+        }\n+\n+        return STNodeFactory.createNodeList(xmlStepExtendList);\n+    }\n+\n+    private boolean isEndOfXMLStepExtend(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case DOT_LT_TOKEN:\n+            case OPEN_BRACKET_TOKEN:\n+            case DOT_TOKEN:\n+                return false;\n+            default:\n+                return true;\n+        }\n+    }\n+\n+    /**\n+     * Parse xml step extend list.\n+     * <p>\n+     * <code>\n+     * xml-step-extend :=\n+     *    .< xml-name-pattern >\n+     *    | [ expression ]\n+     *    | . method-name ( arg-list )\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLStepExtend() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case DOT_LT_TOKEN:\n+                return parseXMLFilterExpressionRhs();\n+            case DOT_TOKEN:\n+                return parseMethodCallChain();\n+            // token kind is already validated in isEndOfXMLStepExtend and reach here.\n+            // therefore, a recover solution is not required for the default case.\n+            case OPEN_BRACKET_TOKEN:\n+            default:\n+                return parseOpenBracketExpressionChain();\n+\n+        }\n+    }\n+\n+    /**\n+     * Parse open bracket expression chain.\n+     * <p>\n+     * <code>open-bracket-expression-chain := `[` expression `]`</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseOpenBracketExpressionChain() {\n+        STNode openBracketToken = parseOpenBracket();\n+        STNode expression = parseExpression();\n+        STNode closeBracketToken = parseCloseBracket();\n+        return STNodeFactory.createOpenBracketExpressionChainingNode(openBracketToken, expression, closeBracketToken);\n+    }\n+\n+    /**\n+     * Parse method call chain.\n+     * <p>\n+     * <code>method-call-chain := `.` method-name `(` arg-list `)`</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseMethodCallChain() {\n+        STNode dotToken = parseDotToken();\n+        STNode methodName = parseIdentifier(ParserRuleContext.FIELD_OR_FUNC_NAME);\n+        STNode openParen = parseOpenParenthesis(ParserRuleContext.ARG_LIST_START);\n+        STNode args = parseArgsList();\n+        STNode closeParen = parseCloseParenthesis();\n+        return STNodeFactory.createMethodCallChainingNode(dotToken, methodName, openParen, args, closeParen);", "originalCommit": "2fafddc846bc83ee150b1b775050d159dab1b671", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b66404743dd61d9e3e1f2f255c210ab92a0376ff", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b66404743dd61d9e3e1f2f255c210ab92a0376ff", "message": "Change xml-step-extend parsing", "committedDate": "2020-05-29T05:45:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM0MDk1Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23581#discussion_r432340956", "bodyText": "I think we don't need parseXMLStepExtendListmethod at all :)\nReason is .<, . and [ are already handled by parseExpressionRhs method. So xml-step-expression node always have only lhsExpr and xmlStepStart", "author": "SupunS", "createdAt": "2020-05-29T08:41:45Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12025,4 +12043,307 @@ private STNode parseByteArrayContent(SyntaxKind kind) {\n \n         return content;\n     }\n+\n+    /**\n+     * Parse xml filter expression.\n+     * <p>\n+     * <code>xml-filter-expr := expression .< xml-name-pattern ></code>\n+     *\n+     * @param lhsExpr Preceding expression of .< token\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLFilterExpression(STNode lhsExpr) {\n+        STNode xmlNamePatternChain = parseXMLFilterExpressionRhs();\n+        return STNodeFactory.createXMLFilterExpressionNode(lhsExpr, xmlNamePatternChain);\n+    }\n+\n+    /**\n+     * Parse xml filter expression rhs.\n+     * <p>\n+     * <code>filer-expression-rhs := .< xml-name-pattern ></code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLFilterExpressionRhs() {\n+        STNode dotLTToken = parseDotLTToken();\n+        return parseXMLNamePatternChain(dotLTToken);\n+    }\n+\n+    /**\n+     * Parse xml name pattern chain.\n+     * <p>\n+     * <code>\n+     * xml-name-pattern-chain := filer-expression-rhs | xml-element-children-step | xml-element-descendants-step\n+     * <br/>\n+     * filer-expression-rhs := .< xml-name-pattern >\n+     * <br/>\n+     * xml-element-children-step := /< xml-name-pattern >\n+     * <br/>\n+     * xml-element-descendants-step := /**\\/<xml-name-pattern >\n+     * </code>\n+     *\n+     * @param startToken Preceding token of xml name pattern\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLNamePatternChain(STNode startToken) {\n+        STNode xmlNamePattern = parseXMLNamePattern();\n+        STNode gtToken = parseGTToken();\n+        return STNodeFactory.createXMLNamePatternChainingNode(startToken, xmlNamePattern, gtToken);\n+    }\n+\n+    /**\n+     * Parse <code> .< </code> token.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseDotLTToken() {\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.DOT_LT_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(nextToken, ParserRuleContext.DOT_LT_TOKEN);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse xml name pattern.\n+     * <p>\n+     * <code>xml-name-pattern := xml-atomic-name-pattern [| xml-atomic-name-pattern]*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLNamePattern() {\n+        List<STNode> xmlAtomicNamePatternList = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Return an empty list\n+        if (isEndOfXMLNamePattern(nextToken.kind)) {\n+            this.errorHandler.reportMissingTokenError(\"missing xml atomic name pattern\");\n+            return STNodeFactory.createNodeList(xmlAtomicNamePatternList);\n+        }\n+\n+        // Parse first xml atomic name pattern, that has no leading pipe token\n+        STNode xmlAtomicNamePattern = parseXMLAtomicNamePattern();\n+        xmlAtomicNamePatternList.add(xmlAtomicNamePattern);\n+\n+        // Parse the remaining xml atomic name patterns\n+        nextToken = peek();\n+        STNode leadingPipe;\n+        while (!isEndOfXMLNamePattern(nextToken.kind)) {\n+            leadingPipe = parsePipeToken();\n+            xmlAtomicNamePatternList.add(leadingPipe);\n+            xmlAtomicNamePattern = parseXMLAtomicNamePattern();\n+            xmlAtomicNamePatternList.add(xmlAtomicNamePattern);\n+            nextToken = peek();\n+        }\n+\n+        return STNodeFactory.createNodeList(xmlAtomicNamePatternList);\n+    }\n+\n+    private boolean isEndOfXMLNamePattern(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case IDENTIFIER_TOKEN:\n+            case ASTERISK_TOKEN:\n+            case COLON_TOKEN:\n+                return false;\n+            case GT_TOKEN:\n+            case EOF_TOKEN:\n+            case AT_TOKEN:\n+            case DOCUMENTATION_LINE:\n+            case CLOSE_BRACE_TOKEN:\n+            case SEMICOLON_TOKEN:\n+            case PUBLIC_KEYWORD:\n+            case PRIVATE_KEYWORD:\n+            case FUNCTION_KEYWORD:\n+            case RETURNS_KEYWORD:\n+            case SERVICE_KEYWORD:\n+            case TYPE_KEYWORD:\n+            case LISTENER_KEYWORD:\n+            case CONST_KEYWORD:\n+            case FINAL_KEYWORD:\n+            case RESOURCE_KEYWORD:\n+                return true;\n+            default:\n+                return isSimpleType(tokenKind);\n+        }\n+    }\n+\n+    /**\n+     * Parse xml atomic name pattern.\n+     * <p>\n+     * <code>\n+     * xml-atomic-name-pattern :=\n+     *   *\n+     *   | identifier\n+     *   | xml-namespace-prefix : identifier\n+     *   | xml-namespace-prefix : *\n+     * </code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLAtomicNamePattern() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.ASTERISK_TOKEN) {\n+            return consume();\n+        } else if (token.kind == SyntaxKind.IDENTIFIER_TOKEN) {\n+            STNode identifier = consume();\n+            return parseXMLAtomicNameIdentifier(identifier);\n+        }\n+        return STNodeFactory.createEmptyNode();\n+    }\n+\n+    private STNode parseXMLAtomicNameIdentifier(STNode identifier) {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.COLON_TOKEN) {\n+            STNode colon = consume();\n+            STToken nextToken = peek();\n+            if (nextToken.kind == SyntaxKind.IDENTIFIER_TOKEN || nextToken.kind == SyntaxKind.ASTERISK_TOKEN) {\n+                STToken endToken = consume();\n+                return STNodeFactory.createXMLAtomicNamePatternNode(identifier, colon, endToken);\n+            }\n+        }\n+        return STNodeFactory.createSimpleNameReferenceNode(identifier);\n+    }\n+\n+    /**\n+     * Parse xml step expression.\n+     * <p>\n+     * <code>xml-step-expr := expression xml-step-start xml-step-extend*</code>\n+     *\n+     * @param lhsExpr Preceding expression of /*, /<, or /**\\/< token\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLStepExpression(STNode lhsExpr) {\n+        STNode xmlStepStart = parseXMLStepStart();\n+        STNode xmlStepExtendList = parseXMLStepExtendList();", "originalCommit": "b66404743dd61d9e3e1f2f255c210ab92a0376ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM0MTc4Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23581#discussion_r432341783", "bodyText": "The problem here is, theres a grammar ambiguity.", "author": "SupunS", "createdAt": "2020-05-29T08:43:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM0MDk1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA1MTI5OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23581#discussion_r433051299", "bodyText": "Then the syntax tree for  a /* .<*> [e] .b() xml-step-expr would look like;\n{\n  \"kind\": \"METHOD_CALL\",\n  \"children\": [\n    {\n      \"kind\": \"INDEXED_EXPRESSION\",\n      \"children\": [\n        {\n          \"kind\": \"XML_FILTER_EXPRESSION\",\n          \"children\": [\n            {\n              \"kind\": \"XML_STEP_EXPRESSION\",\n              \"children\": [\n                {\n                  \"kind\": \"IDENTIFIER_TOKEN\",\n                  \"value\": \"a\"\n                },\n                {\n                  \"kind\": \"SLASH_ASTERISK_TOKEN\"\n                }\n              ]\n            },\n            {\n              \"kind\": \"XML_NAME_PATTERN_CHAIN\",\n              \"children\": [\n                {\n                  \"kind\": \"DOT_LT_TOKEN\"\n                },\n                {\n                  \"kind\": \"LIST\",\n                  \"children\": [\n                    {\n                      \"kind\": \"ASTERISK_TOKEN\"\n                    }\n                  ]\n                },\n                {\n                  \"kind\": \"GT_TOKEN\"\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"kind\": \"OPEN_BRACKET_TOKEN\"\n        },\n        {\n          \"kind\": \"LIST\",\n          \"children\": [\n            {\n              \"kind\": \"IDENTIFIER_TOKEN\",\n              \"value\": \"e\"\n            }\n          ]\n        },\n        {\n          \"kind\": \"CLOSE_BRACKET_TOKEN\"\n        }\n      ]\n    },\n    {\n      \"kind\": \"DOT_TOKEN\"\n    },\n    {\n      \"kind\": \"IDENTIFIER_TOKEN\",\n      \"value\": \"b\"\n    },\n    {\n      \"kind\": \"OPEN_PAREN_TOKEN\"\n    },\n    {\n      \"kind\": \"LIST\",\n      \"children\": []\n    },\n    {\n      \"kind\": \"CLOSE_PAREN_TOKEN\"\n    }\n  ]\n}\n\nIs it alright? I'm not quite sure.", "author": "lochana-chathura", "createdAt": "2020-06-01T05:44:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM0MDk1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA1MzQyOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23581#discussion_r433053428", "bodyText": "@SupunS plz review the last commit 9c01f06 for the above change.", "author": "lochana-chathura", "createdAt": "2020-06-01T05:53:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM0MDk1Ng=="}], "type": "inlineReview"}, {"oid": "9c01f069e108ef6ae158daaed3cbfb385371606b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9c01f069e108ef6ae158daaed3cbfb385371606b", "message": "Change xml-step-expr parsing", "committedDate": "2020-06-01T05:52:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA1ODU3MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23581#discussion_r433058570", "bodyText": "Can lhsExpr be null?", "author": "SupunS", "createdAt": "2020-06-01T06:12:38Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -4516,7 +4522,7 @@ private STNode parseExpressionRhs(SyntaxKind tokenKind, OperatorPrecedence curre\n             return lhsExpr;\n         }\n \n-        if (lhsExpr.kind == SyntaxKind.ASYNC_SEND_ACTION) {\n+        if (lhsExpr != null && lhsExpr.kind == SyntaxKind.ASYNC_SEND_ACTION) {", "originalCommit": "9c01f069e108ef6ae158daaed3cbfb385371606b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA2MDYyMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23581#discussion_r433060620", "bodyText": "That is from the previous commit. Now we don't need that. I'll correct.", "author": "lochana-chathura", "createdAt": "2020-06-01T06:20:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA1ODU3MA=="}], "type": "inlineReview"}, {"oid": "3281d8cf188fc5e65108ede699bc6b36232a3b54", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3281d8cf188fc5e65108ede699bc6b36232a3b54", "message": "Change xml-step-expr parsing", "committedDate": "2020-06-01T06:50:32Z", "type": "commit"}, {"oid": "3281d8cf188fc5e65108ede699bc6b36232a3b54", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3281d8cf188fc5e65108ede699bc6b36232a3b54", "message": "Change xml-step-expr parsing", "committedDate": "2020-06-01T06:50:32Z", "type": "forcePushed"}, {"oid": "8fb1a0c4b318d2388892ca5ed96af4a35bc96474", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8fb1a0c4b318d2388892ca5ed96af4a35bc96474", "message": "Add error recovery", "committedDate": "2020-06-02T06:14:53Z", "type": "commit"}, {"oid": "8fb1a0c4b318d2388892ca5ed96af4a35bc96474", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8fb1a0c4b318d2388892ca5ed96af4a35bc96474", "message": "Add error recovery", "committedDate": "2020-06-02T06:14:53Z", "type": "forcePushed"}, {"oid": "4a6ab66456ae38753ab25fe5947a023751ff5bde", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4a6ab66456ae38753ab25fe5947a023751ff5bde", "message": "Fix error recovery", "committedDate": "2020-06-02T10:39:28Z", "type": "commit"}, {"oid": "d5b47727e19fd0c37b819d8cbe6d366f1a08f474", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d5b47727e19fd0c37b819d8cbe6d366f1a08f474", "message": "Add recovery test cases", "committedDate": "2020-06-02T11:00:31Z", "type": "commit"}, {"oid": "5821c25336abac2b2495b0864a0eb7140f1141c7", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5821c25336abac2b2495b0864a0eb7140f1141c7", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into xml-navigate-support\n\n\u0001 Conflicts:\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/diagnostics/DiagnosticErrorCode.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/AbstractParserErrorHandler.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "committedDate": "2020-06-02T11:35:15Z", "type": "commit"}, {"oid": "a983b5be508678cce324d851ce9d38d07b64e9b2", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a983b5be508678cce324d851ce9d38d07b64e9b2", "message": "Fix merging issue", "committedDate": "2020-06-02T11:52:34Z", "type": "commit"}, {"oid": "a7777e528ff4a4e146a5a2c7e808fc68bc9971c9", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a7777e528ff4a4e146a5a2c7e808fc68bc9971c9", "message": "Remove OPEN_BRACKET_EXPRESSION_CHAIN, METHOD_CALL_CHAIN syntax kinds", "committedDate": "2020-06-02T12:21:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg0OTU2NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23581#discussion_r433849565", "bodyText": "Better to move starting and ending contexts inside the parseXMLAtomicNamePattern", "author": "SupunS", "createdAt": "2020-06-02T12:50:33Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -11100,6 +11124,266 @@ private STNode parseByteArrayContent(SyntaxKind kind) {\n         return content;\n     }\n \n+    /**\n+     * Parse xml filter expression.\n+     * <p>\n+     * <code>xml-filter-expr := expression .< xml-name-pattern ></code>\n+     *\n+     * @param lhsExpr Preceding expression of .< token\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLFilterExpression(STNode lhsExpr) {\n+        STNode xmlNamePatternChain = parseXMLFilterExpressionRhs();\n+        return STNodeFactory.createXMLFilterExpressionNode(lhsExpr, xmlNamePatternChain);\n+    }\n+\n+    /**\n+     * Parse xml filter expression rhs.\n+     * <p>\n+     * <code>filer-expression-rhs := .< xml-name-pattern ></code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLFilterExpressionRhs() {\n+        STNode dotLTToken = parseDotLTToken();\n+        return parseXMLNamePatternChain(dotLTToken);\n+    }\n+\n+    /**\n+     * Parse xml name pattern chain.\n+     * <p>\n+     * <code>\n+     * xml-name-pattern-chain := filer-expression-rhs | xml-element-children-step | xml-element-descendants-step\n+     * <br/>\n+     * filer-expression-rhs := .< xml-name-pattern >\n+     * <br/>\n+     * xml-element-children-step := /< xml-name-pattern >\n+     * <br/>\n+     * xml-element-descendants-step := /**\\/<xml-name-pattern >\n+     * </code>\n+     *\n+     * @param startToken Preceding token of xml name pattern\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLNamePatternChain(STNode startToken) {\n+        startContext(ParserRuleContext.XML_NAME_PATTERN);\n+        STNode xmlNamePattern = parseXMLNamePattern();\n+        STNode gtToken = parseGTToken();\n+        endContext();\n+        return STNodeFactory.createXMLNamePatternChainingNode(startToken, xmlNamePattern, gtToken);\n+    }\n+\n+    /**\n+     * Parse <code> .< </code> token.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseDotLTToken() {\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.DOT_LT_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(nextToken, ParserRuleContext.DOT_LT_TOKEN);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse xml name pattern.\n+     * <p>\n+     * <code>xml-name-pattern := xml-atomic-name-pattern [| xml-atomic-name-pattern]*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLNamePattern() {\n+        List<STNode> xmlAtomicNamePatternList = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Return an empty list\n+        if (isEndOfXMLNamePattern(nextToken.kind)) {\n+            this.errorHandler.reportMissingTokenError(\"missing xml atomic name pattern\");\n+            return STNodeFactory.createNodeList(xmlAtomicNamePatternList);\n+        }\n+\n+        // Parse first xml atomic name pattern, that has no leading pipe token\n+        startContext(ParserRuleContext.XML_ATOMIC_NAME_PATTERN);\n+        STNode xmlAtomicNamePattern = parseXMLAtomicNamePattern();\n+        endContext();", "originalCommit": "a7777e528ff4a4e146a5a2c7e808fc68bc9971c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1MTgzMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23581#discussion_r433851830", "bodyText": "Since the nextToken is used only at this place, can simply use peek() here itself. No need of a local variable..", "author": "SupunS", "createdAt": "2020-06-02T12:54:15Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -11100,6 +11124,266 @@ private STNode parseByteArrayContent(SyntaxKind kind) {\n         return content;\n     }\n \n+    /**\n+     * Parse xml filter expression.\n+     * <p>\n+     * <code>xml-filter-expr := expression .< xml-name-pattern ></code>\n+     *\n+     * @param lhsExpr Preceding expression of .< token\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLFilterExpression(STNode lhsExpr) {\n+        STNode xmlNamePatternChain = parseXMLFilterExpressionRhs();\n+        return STNodeFactory.createXMLFilterExpressionNode(lhsExpr, xmlNamePatternChain);\n+    }\n+\n+    /**\n+     * Parse xml filter expression rhs.\n+     * <p>\n+     * <code>filer-expression-rhs := .< xml-name-pattern ></code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLFilterExpressionRhs() {\n+        STNode dotLTToken = parseDotLTToken();\n+        return parseXMLNamePatternChain(dotLTToken);\n+    }\n+\n+    /**\n+     * Parse xml name pattern chain.\n+     * <p>\n+     * <code>\n+     * xml-name-pattern-chain := filer-expression-rhs | xml-element-children-step | xml-element-descendants-step\n+     * <br/>\n+     * filer-expression-rhs := .< xml-name-pattern >\n+     * <br/>\n+     * xml-element-children-step := /< xml-name-pattern >\n+     * <br/>\n+     * xml-element-descendants-step := /**\\/<xml-name-pattern >\n+     * </code>\n+     *\n+     * @param startToken Preceding token of xml name pattern\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLNamePatternChain(STNode startToken) {\n+        startContext(ParserRuleContext.XML_NAME_PATTERN);\n+        STNode xmlNamePattern = parseXMLNamePattern();\n+        STNode gtToken = parseGTToken();\n+        endContext();\n+        return STNodeFactory.createXMLNamePatternChainingNode(startToken, xmlNamePattern, gtToken);\n+    }\n+\n+    /**\n+     * Parse <code> .< </code> token.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseDotLTToken() {\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.DOT_LT_TOKEN) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(nextToken, ParserRuleContext.DOT_LT_TOKEN);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse xml name pattern.\n+     * <p>\n+     * <code>xml-name-pattern := xml-atomic-name-pattern [| xml-atomic-name-pattern]*</code>\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseXMLNamePattern() {\n+        List<STNode> xmlAtomicNamePatternList = new ArrayList<>();\n+        STToken nextToken = peek();\n+\n+        // Return an empty list\n+        if (isEndOfXMLNamePattern(nextToken.kind)) {\n+            this.errorHandler.reportMissingTokenError(\"missing xml atomic name pattern\");\n+            return STNodeFactory.createNodeList(xmlAtomicNamePatternList);\n+        }\n+\n+        // Parse first xml atomic name pattern, that has no leading pipe token\n+        startContext(ParserRuleContext.XML_ATOMIC_NAME_PATTERN);\n+        STNode xmlAtomicNamePattern = parseXMLAtomicNamePattern();\n+        endContext();\n+        xmlAtomicNamePatternList.add(xmlAtomicNamePattern);\n+\n+        // Parse the remaining xml atomic name patterns\n+        nextToken = peek();\n+        STNode leadingPipe;\n+        while (!isEndOfXMLNamePattern(nextToken.kind)) {", "originalCommit": "a7777e528ff4a4e146a5a2c7e808fc68bc9971c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1NDM4MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23581#discussion_r433854381", "bodyText": "since getParentContext() is called more than once, better to move it to a local variable.", "author": "SupunS", "createdAt": "2020-06-02T12:58:23Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -2246,6 +2324,8 @@ private ParserRuleContext getNextRuleInternal(ParserRuleContext currentCtx, int\n             case PIPE:\n                 if (getParentContext() == ParserRuleContext.ALTERNATE_WAIT_EXPRS) {\n                     return ParserRuleContext.EXPRESSION;\n+                } else if (getParentContext() == ParserRuleContext.XML_NAME_PATTERN) {", "originalCommit": "a7777e528ff4a4e146a5a2c7e808fc68bc9971c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b84f28db9832dc3ea85f95638d7cf25cb1120875", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b84f28db9832dc3ea85f95638d7cf25cb1120875", "message": "Refactor code", "committedDate": "2020-06-02T14:57:31Z", "type": "commit"}]}