{"pr_number": 26197, "pr_title": "Support for error-match-pattern", "pr_createdAt": "2020-10-04T18:41:29Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197", "timeline": [{"oid": "d089cf01183869bce84db9c4b933b1196a4ecff1", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d089cf01183869bce84db9c4b933b1196a4ecff1", "message": "Add tests", "committedDate": "2020-10-05T03:50:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYyOTI4NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r499629284", "bodyText": "Do we need this new line ?", "author": "anupama-pathirage", "createdAt": "2020-10-05T14:12:57Z", "path": "compiler/ballerina-lang/src/main/java/org/ballerinalang/model/TreeBuilder.java", "diffHunk": "@@ -776,9 +788,40 @@ public static CaptureBindingPattern createCaptureBindingPattern() {\n     }\n \n     public static ListBindingPattern createListBindingPattern() {\n+\n         return new BLangListBindingPattern();\n     }\n \n+    public static ErrorMatchPatternNode createErrorMatchPattern() {\n+", "originalCommit": "d089cf01183869bce84db9c4b933b1196a4ecff1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAwMjE5OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r500002199", "bodyText": "Fixed", "author": "KavinduZoysa", "createdAt": "2020-10-06T04:41:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYyOTI4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYzNDc1Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r499634757", "bodyText": "In this PR, some classes have a new line before the first line of the class/interface, while others don't have. Can we use a consistent formatting?", "author": "anupama-pathirage", "createdAt": "2020-10-05T14:20:38Z", "path": "compiler/ballerina-lang/src/main/java/org/ballerinalang/model/tree/matchpatterns/ErrorMessageMatchPatternNode.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.model.tree.matchpatterns;\n+\n+import org.ballerinalang.model.tree.Node;\n+\n+/**\n+ * The interface with the APIs to implement the error-message-match-pattern.\n+ *\n+ * @since Swan Lake\n+ */\n+public interface ErrorMessageMatchPatternNode extends Node {\n+    SimpleMatchPatternNode getSimpleMatchPattern();", "originalCommit": "d089cf01183869bce84db9c4b933b1196a4ecff1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAwMjIxMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r500002212", "bodyText": "Fixed", "author": "KavinduZoysa", "createdAt": "2020-10-06T04:41:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYzNDc1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc5MDQ1OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r499790459", "bodyText": "Shall we reformat this code? Unnecessary line breaks it harder to read.", "author": "anupama-pathirage", "createdAt": "2020-10-05T18:27:50Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -3003,76 +3011,315 @@ private BLangExpression createConditionFromMatchPatterns(List<BLangMatchPattern>\n         BLangSimpleVariableDef resultVarDef = createVarDef(\"$result$\", symTable.booleanType, null, pos);\n         BLangSimpleVarRef resultVarRef = ASTBuilderUtil.createVariableRef(pos, resultVarDef.var.symbol);\n         // $result$ = true\n-        BLangBlockStmt successBody = ASTBuilderUtil.createBlockStmt(pos);\n-        BLangAssignment successAssignment =\n-                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(true));\n-        successBody.addStatement(successAssignment);\n-        // $result$ = false\n-        BLangBlockStmt failureBody = ASTBuilderUtil.createBlockStmt(pos);\n-        BLangAssignment failureAssignment =\n-                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(false));\n-        failureBody.addStatement(failureAssignment);\n+        BLangBlockStmt successBody = createSuccessOrFailureBody(true, resultVarRef, pos);\n \n         BLangIf parentIfElse = createIfElseStmtFromMatchPattern(matchPatterns.get(0), matchExprVar, successBody, pos);\n         BLangIf currentIfElse = parentIfElse;\n \n         for (int i = 1; i < matchPatterns.size(); i++) {\n+            successBody = createSuccessOrFailureBody(true, resultVarRef, pos);\n             currentIfElse.elseStmt = createIfElseStmtFromMatchPattern(matchPatterns.get(i), matchExprVar, successBody,\n                     matchPatterns.get(i).pos);\n             currentIfElse = (BLangIf) currentIfElse.elseStmt;\n         }\n-        currentIfElse.elseStmt = failureBody;\n \n+        currentIfElse.elseStmt = createSuccessOrFailureBody(false, resultVarRef, pos);\n         BLangBlockStmt blockStmt = ASTBuilderUtil.createBlockStmt(pos, Lists.of(resultVarDef, parentIfElse));\n         BLangStatementExpression stmtExpr = createStatementExpression(blockStmt, resultVarRef);\n \n         return rewriteExpr(stmtExpr);\n     }\n \n+    private BLangBlockStmt createSuccessOrFailureBody(boolean status, BLangSimpleVarRef varRef, DiagnosticPos pos) {\n+        BLangBlockStmt blockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+        BLangAssignment bLangAssignment =\n+                ASTBuilderUtil.createAssignmentStmt(pos, varRef, getBooleanLiteral(status));\n+        blockStmt.addStatement(bLangAssignment);\n+        return blockStmt;\n+    }\n+\n     private BLangIf createIfElseStmtFromMatchPattern(BLangMatchPattern matchPattern,\n-                                                             BLangSimpleVariable matchExprVar,\n-                                                             BLangBlockStmt successBody,\n-                                                             DiagnosticPos pos) {\n-        NodeKind patternKind = matchPattern.getKind();\n+                                                     BLangSimpleVariable matchExprVar,\n+                                                     BLangBlockStmt successBody,\n+                                                     DiagnosticPos pos) {\n+\n         BLangSimpleVarRef matchExprVarRef = ASTBuilderUtil.createVariableRef(matchExprVar.pos, matchExprVar.symbol);\n \n+        BLangExpression condition = createConditionForMatchPattern(matchPattern, matchExprVarRef);\n+        successBody.getStatements().addAll(matchStmtsForPattern);\n+        matchStmtsForPattern.clear();\n+        return ASTBuilderUtil.createIfElseStmt(pos, condition, successBody, null);\n+    }\n+\n+    private BLangExpression createConditionForWildCardMatchPattern(BLangWildCardMatchPattern wildCardMatchPattern,\n+                                                                   BLangSimpleVarRef matchExprVarRef) {\n+\n+        boolean condition;\n+        if (wildCardMatchPattern.matchesAll) {\n+            condition = true;\n+        } else {\n+            condition = types.isAssignable(matchExprVarRef.type, symTable.anyType);\n+        }\n+        return ASTBuilderUtil.createLiteral(wildCardMatchPattern.pos, symTable.booleanType, condition);\n+    }\n+\n+    private BLangExpression createConditionForConstMatchPattern(BLangConstPattern constPattern,\n+                                                                BLangSimpleVarRef matchExprVarRef) {\n+\n+        return createBinaryExpression(constPattern.pos, matchExprVarRef, constPattern.expr);\n+    }\n+\n+    private BLangExpression createConditionForVarBindingPatternMatchPattern(BLangVarBindingPatternMatchPattern\n+                                                                                    varBindingPatternMatchPattern,\n+                                                                            BLangSimpleVarRef matchExprVarRef) {\n+\n+        BLangBindingPattern bindingPattern = varBindingPatternMatchPattern.getBindingPattern();\n+\n+        switch (bindingPattern.getKind()) {\n+            case CAPTURE_BINDING_PATTERN:\n+                BLangCaptureBindingPattern captureBindingPattern = (BLangCaptureBindingPattern) bindingPattern;\n+                DiagnosticPos captureBindingPatternPos = captureBindingPattern.pos;\n+                BLangSimpleVariable captureBindingPatternVar =\n+                        ASTBuilderUtil.createVariable(captureBindingPatternPos,\n+                                captureBindingPattern.getIdentifier().getValue(), matchExprVarRef.type,\n+                                matchExprVarRef, captureBindingPattern.symbol);\n+                captureBindingPattern.symbol.type = matchExprVarRef.type;\n+                BLangSimpleVariableDef captureBindingPatternVarDef =\n+                        ASTBuilderUtil.createVariableDef(captureBindingPatternPos, captureBindingPatternVar);\n+                matchStmtsForPattern.add(captureBindingPatternVarDef);\n+\n+                return ASTBuilderUtil.createLiteral(captureBindingPattern.pos, symTable.booleanType, true);\n+        }\n+        // If some patterns are not implemented, those should be detected before this phase\n+        // TODO : Remove this after all patterns are implemented\n+        return null;\n+    }\n+\n+    private BLangExpression createConditionForErrorMatchPattern(BLangErrorMatchPattern errorMatchPattern,\n+                                                                BLangSimpleVarRef matchExprVarRef) {\n+\n+        BType matchPatternType = errorMatchPattern.type;\n+        DiagnosticPos pos = errorMatchPattern.pos;\n+\n+        BLangSimpleVariableDef resultVarDef = createVarDef(\"errorPatternResult$\",\n+                symTable.booleanType, null, pos);\n+        BLangSimpleVarRef resultVarRef = ASTBuilderUtil.createVariableRef(pos, resultVarDef.var.symbol);\n+        BLangBlockStmt mainBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+        mainBlockStmt.addStatement(resultVarDef);\n+\n+        BLangAssignment failureResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(false));\n+        BLangAssignment successResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(true));\n+        mainBlockStmt.addStatement(failureResult);\n+\n+        BLangExpression typeCheckCondition = createIsLikeExpression(errorMatchPattern.pos, matchExprVarRef,\n+                matchPatternType);\n+        BLangExpression typeConvertedExpr = addConversionExprIfRequired(matchExprVarRef, matchPatternType);\n+        BLangSimpleVariableDef tempCastVarDef = createVarDef(\"$castTemp$\", matchPatternType, typeConvertedExpr, pos);\n+        BLangSimpleVarRef tempCastVarRef = ASTBuilderUtil.createVariableRef(pos, tempCastVarDef.var.symbol);\n+\n+        BLangBlockStmt ifBlock = ASTBuilderUtil.createBlockStmt(pos);\n+        ifBlock.addStatement(tempCastVarDef);\n+        BLangIf ifStmt = ASTBuilderUtil.createIfElseStmt(pos, typeCheckCondition, ifBlock, null);\n+        mainBlockStmt.addStatement(ifStmt);\n+\n+        BLangExpression condition = null;\n+        if (errorMatchPattern.errorMessageMatchPattern != null) {\n+            DiagnosticPos messagePos = errorMatchPattern.errorMessageMatchPattern.pos;\n+            BLangInvocation messageInvocation = createLangLibInvocationNode(ERROR_MESSAGE_FUNCTION_NAME,\n+                    tempCastVarRef,\n+                    new ArrayList<>(), null, messagePos);\n+            BLangSimpleVariableDef messageVarDef = createVarDef(\"$errorMessage$\", messageInvocation.type,\n+                    messageInvocation, messagePos);\n+            ifBlock.addStatement(messageVarDef);\n+            BLangSimpleVarRef messageVarRef = ASTBuilderUtil.createVariableRef(messagePos,\n+                    messageVarDef.var.symbol);\n+            condition =\n+                    createConditionForErrorMessageMatchPattern(errorMatchPattern.errorMessageMatchPattern,\n+                            messageVarRef);\n+        }", "originalCommit": "d089cf01183869bce84db9c4b933b1196a4ecff1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAwMjIyMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r500002221", "bodyText": "Fixed", "author": "KavinduZoysa", "createdAt": "2020-10-06T04:41:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc5MDQ1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk3NzI1NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r499977255", "bodyText": "Shouldn't the version be 2.0.0?", "author": "nadeeshaan", "createdAt": "2020-10-06T02:52:01Z", "path": "compiler/ballerina-lang/src/main/java/org/ballerinalang/model/tree/matchpatterns/ErrorCauseMatchPatternNode.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.model.tree.matchpatterns;\n+\n+import org.ballerinalang.model.tree.Node;\n+\n+/**\n+ * The interface with the APIs to implement the error-cause-match-pattern.\n+ *\n+ * @since Swan Lake", "originalCommit": "d089cf01183869bce84db9c4b933b1196a4ecff1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA5MzUwNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r530093507", "bodyText": "Fixed", "author": "KavinduZoysa", "createdAt": "2020-11-25T04:00:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk3NzI1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk3ODYzNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r499978634", "bodyText": "will it be possible to collapse the if statement to a conditional op?", "author": "nadeeshaan", "createdAt": "2020-10-06T02:58:03Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -3003,76 +3011,315 @@ private BLangExpression createConditionFromMatchPatterns(List<BLangMatchPattern>\n         BLangSimpleVariableDef resultVarDef = createVarDef(\"$result$\", symTable.booleanType, null, pos);\n         BLangSimpleVarRef resultVarRef = ASTBuilderUtil.createVariableRef(pos, resultVarDef.var.symbol);\n         // $result$ = true\n-        BLangBlockStmt successBody = ASTBuilderUtil.createBlockStmt(pos);\n-        BLangAssignment successAssignment =\n-                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(true));\n-        successBody.addStatement(successAssignment);\n-        // $result$ = false\n-        BLangBlockStmt failureBody = ASTBuilderUtil.createBlockStmt(pos);\n-        BLangAssignment failureAssignment =\n-                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(false));\n-        failureBody.addStatement(failureAssignment);\n+        BLangBlockStmt successBody = createSuccessOrFailureBody(true, resultVarRef, pos);\n \n         BLangIf parentIfElse = createIfElseStmtFromMatchPattern(matchPatterns.get(0), matchExprVar, successBody, pos);\n         BLangIf currentIfElse = parentIfElse;\n \n         for (int i = 1; i < matchPatterns.size(); i++) {\n+            successBody = createSuccessOrFailureBody(true, resultVarRef, pos);\n             currentIfElse.elseStmt = createIfElseStmtFromMatchPattern(matchPatterns.get(i), matchExprVar, successBody,\n                     matchPatterns.get(i).pos);\n             currentIfElse = (BLangIf) currentIfElse.elseStmt;\n         }\n-        currentIfElse.elseStmt = failureBody;\n \n+        currentIfElse.elseStmt = createSuccessOrFailureBody(false, resultVarRef, pos);\n         BLangBlockStmt blockStmt = ASTBuilderUtil.createBlockStmt(pos, Lists.of(resultVarDef, parentIfElse));\n         BLangStatementExpression stmtExpr = createStatementExpression(blockStmt, resultVarRef);\n \n         return rewriteExpr(stmtExpr);\n     }\n \n+    private BLangBlockStmt createSuccessOrFailureBody(boolean status, BLangSimpleVarRef varRef, DiagnosticPos pos) {\n+        BLangBlockStmt blockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+        BLangAssignment bLangAssignment =\n+                ASTBuilderUtil.createAssignmentStmt(pos, varRef, getBooleanLiteral(status));\n+        blockStmt.addStatement(bLangAssignment);\n+        return blockStmt;\n+    }\n+\n     private BLangIf createIfElseStmtFromMatchPattern(BLangMatchPattern matchPattern,\n-                                                             BLangSimpleVariable matchExprVar,\n-                                                             BLangBlockStmt successBody,\n-                                                             DiagnosticPos pos) {\n-        NodeKind patternKind = matchPattern.getKind();\n+                                                     BLangSimpleVariable matchExprVar,\n+                                                     BLangBlockStmt successBody,\n+                                                     DiagnosticPos pos) {\n+\n         BLangSimpleVarRef matchExprVarRef = ASTBuilderUtil.createVariableRef(matchExprVar.pos, matchExprVar.symbol);\n \n+        BLangExpression condition = createConditionForMatchPattern(matchPattern, matchExprVarRef);\n+        successBody.getStatements().addAll(matchStmtsForPattern);\n+        matchStmtsForPattern.clear();\n+        return ASTBuilderUtil.createIfElseStmt(pos, condition, successBody, null);\n+    }\n+\n+    private BLangExpression createConditionForWildCardMatchPattern(BLangWildCardMatchPattern wildCardMatchPattern,\n+                                                                   BLangSimpleVarRef matchExprVarRef) {\n+\n+        boolean condition;\n+        if (wildCardMatchPattern.matchesAll) {", "originalCommit": "d089cf01183869bce84db9c4b933b1196a4ecff1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAwMjI1Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r500002253", "bodyText": "Done", "author": "KavinduZoysa", "createdAt": "2020-10-06T04:42:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk3ODYzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk3OTA5Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r499979097", "bodyText": "instead of this, add the default case to the switch", "author": "nadeeshaan", "createdAt": "2020-10-06T02:59:59Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -3003,76 +3011,315 @@ private BLangExpression createConditionFromMatchPatterns(List<BLangMatchPattern>\n         BLangSimpleVariableDef resultVarDef = createVarDef(\"$result$\", symTable.booleanType, null, pos);\n         BLangSimpleVarRef resultVarRef = ASTBuilderUtil.createVariableRef(pos, resultVarDef.var.symbol);\n         // $result$ = true\n-        BLangBlockStmt successBody = ASTBuilderUtil.createBlockStmt(pos);\n-        BLangAssignment successAssignment =\n-                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(true));\n-        successBody.addStatement(successAssignment);\n-        // $result$ = false\n-        BLangBlockStmt failureBody = ASTBuilderUtil.createBlockStmt(pos);\n-        BLangAssignment failureAssignment =\n-                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(false));\n-        failureBody.addStatement(failureAssignment);\n+        BLangBlockStmt successBody = createSuccessOrFailureBody(true, resultVarRef, pos);\n \n         BLangIf parentIfElse = createIfElseStmtFromMatchPattern(matchPatterns.get(0), matchExprVar, successBody, pos);\n         BLangIf currentIfElse = parentIfElse;\n \n         for (int i = 1; i < matchPatterns.size(); i++) {\n+            successBody = createSuccessOrFailureBody(true, resultVarRef, pos);\n             currentIfElse.elseStmt = createIfElseStmtFromMatchPattern(matchPatterns.get(i), matchExprVar, successBody,\n                     matchPatterns.get(i).pos);\n             currentIfElse = (BLangIf) currentIfElse.elseStmt;\n         }\n-        currentIfElse.elseStmt = failureBody;\n \n+        currentIfElse.elseStmt = createSuccessOrFailureBody(false, resultVarRef, pos);\n         BLangBlockStmt blockStmt = ASTBuilderUtil.createBlockStmt(pos, Lists.of(resultVarDef, parentIfElse));\n         BLangStatementExpression stmtExpr = createStatementExpression(blockStmt, resultVarRef);\n \n         return rewriteExpr(stmtExpr);\n     }\n \n+    private BLangBlockStmt createSuccessOrFailureBody(boolean status, BLangSimpleVarRef varRef, DiagnosticPos pos) {\n+        BLangBlockStmt blockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+        BLangAssignment bLangAssignment =\n+                ASTBuilderUtil.createAssignmentStmt(pos, varRef, getBooleanLiteral(status));\n+        blockStmt.addStatement(bLangAssignment);\n+        return blockStmt;\n+    }\n+\n     private BLangIf createIfElseStmtFromMatchPattern(BLangMatchPattern matchPattern,\n-                                                             BLangSimpleVariable matchExprVar,\n-                                                             BLangBlockStmt successBody,\n-                                                             DiagnosticPos pos) {\n-        NodeKind patternKind = matchPattern.getKind();\n+                                                     BLangSimpleVariable matchExprVar,\n+                                                     BLangBlockStmt successBody,\n+                                                     DiagnosticPos pos) {\n+\n         BLangSimpleVarRef matchExprVarRef = ASTBuilderUtil.createVariableRef(matchExprVar.pos, matchExprVar.symbol);\n \n+        BLangExpression condition = createConditionForMatchPattern(matchPattern, matchExprVarRef);\n+        successBody.getStatements().addAll(matchStmtsForPattern);\n+        matchStmtsForPattern.clear();\n+        return ASTBuilderUtil.createIfElseStmt(pos, condition, successBody, null);\n+    }\n+\n+    private BLangExpression createConditionForWildCardMatchPattern(BLangWildCardMatchPattern wildCardMatchPattern,\n+                                                                   BLangSimpleVarRef matchExprVarRef) {\n+\n+        boolean condition;\n+        if (wildCardMatchPattern.matchesAll) {\n+            condition = true;\n+        } else {\n+            condition = types.isAssignable(matchExprVarRef.type, symTable.anyType);\n+        }\n+        return ASTBuilderUtil.createLiteral(wildCardMatchPattern.pos, symTable.booleanType, condition);\n+    }\n+\n+    private BLangExpression createConditionForConstMatchPattern(BLangConstPattern constPattern,\n+                                                                BLangSimpleVarRef matchExprVarRef) {\n+\n+        return createBinaryExpression(constPattern.pos, matchExprVarRef, constPattern.expr);\n+    }\n+\n+    private BLangExpression createConditionForVarBindingPatternMatchPattern(BLangVarBindingPatternMatchPattern\n+                                                                                    varBindingPatternMatchPattern,\n+                                                                            BLangSimpleVarRef matchExprVarRef) {\n+\n+        BLangBindingPattern bindingPattern = varBindingPatternMatchPattern.getBindingPattern();\n+\n+        switch (bindingPattern.getKind()) {\n+            case CAPTURE_BINDING_PATTERN:\n+                BLangCaptureBindingPattern captureBindingPattern = (BLangCaptureBindingPattern) bindingPattern;\n+                DiagnosticPos captureBindingPatternPos = captureBindingPattern.pos;\n+                BLangSimpleVariable captureBindingPatternVar =\n+                        ASTBuilderUtil.createVariable(captureBindingPatternPos,\n+                                captureBindingPattern.getIdentifier().getValue(), matchExprVarRef.type,\n+                                matchExprVarRef, captureBindingPattern.symbol);\n+                captureBindingPattern.symbol.type = matchExprVarRef.type;\n+                BLangSimpleVariableDef captureBindingPatternVarDef =\n+                        ASTBuilderUtil.createVariableDef(captureBindingPatternPos, captureBindingPatternVar);\n+                matchStmtsForPattern.add(captureBindingPatternVarDef);\n+\n+                return ASTBuilderUtil.createLiteral(captureBindingPattern.pos, symTable.booleanType, true);\n+        }\n+        // If some patterns are not implemented, those should be detected before this phase\n+        // TODO : Remove this after all patterns are implemented\n+        return null;", "originalCommit": "d089cf01183869bce84db9c4b933b1196a4ecff1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAwMjI2MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r500002260", "bodyText": "Done", "author": "KavinduZoysa", "createdAt": "2020-10-06T04:42:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk3OTA5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk3OTU5Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r499979593", "bodyText": "Method seems to be too long, it might be better if we can try to refactor", "author": "nadeeshaan", "createdAt": "2020-10-06T03:01:54Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -3003,76 +3011,315 @@ private BLangExpression createConditionFromMatchPatterns(List<BLangMatchPattern>\n         BLangSimpleVariableDef resultVarDef = createVarDef(\"$result$\", symTable.booleanType, null, pos);\n         BLangSimpleVarRef resultVarRef = ASTBuilderUtil.createVariableRef(pos, resultVarDef.var.symbol);\n         // $result$ = true\n-        BLangBlockStmt successBody = ASTBuilderUtil.createBlockStmt(pos);\n-        BLangAssignment successAssignment =\n-                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(true));\n-        successBody.addStatement(successAssignment);\n-        // $result$ = false\n-        BLangBlockStmt failureBody = ASTBuilderUtil.createBlockStmt(pos);\n-        BLangAssignment failureAssignment =\n-                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(false));\n-        failureBody.addStatement(failureAssignment);\n+        BLangBlockStmt successBody = createSuccessOrFailureBody(true, resultVarRef, pos);\n \n         BLangIf parentIfElse = createIfElseStmtFromMatchPattern(matchPatterns.get(0), matchExprVar, successBody, pos);\n         BLangIf currentIfElse = parentIfElse;\n \n         for (int i = 1; i < matchPatterns.size(); i++) {\n+            successBody = createSuccessOrFailureBody(true, resultVarRef, pos);\n             currentIfElse.elseStmt = createIfElseStmtFromMatchPattern(matchPatterns.get(i), matchExprVar, successBody,\n                     matchPatterns.get(i).pos);\n             currentIfElse = (BLangIf) currentIfElse.elseStmt;\n         }\n-        currentIfElse.elseStmt = failureBody;\n \n+        currentIfElse.elseStmt = createSuccessOrFailureBody(false, resultVarRef, pos);\n         BLangBlockStmt blockStmt = ASTBuilderUtil.createBlockStmt(pos, Lists.of(resultVarDef, parentIfElse));\n         BLangStatementExpression stmtExpr = createStatementExpression(blockStmt, resultVarRef);\n \n         return rewriteExpr(stmtExpr);\n     }\n \n+    private BLangBlockStmt createSuccessOrFailureBody(boolean status, BLangSimpleVarRef varRef, DiagnosticPos pos) {\n+        BLangBlockStmt blockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+        BLangAssignment bLangAssignment =\n+                ASTBuilderUtil.createAssignmentStmt(pos, varRef, getBooleanLiteral(status));\n+        blockStmt.addStatement(bLangAssignment);\n+        return blockStmt;\n+    }\n+\n     private BLangIf createIfElseStmtFromMatchPattern(BLangMatchPattern matchPattern,\n-                                                             BLangSimpleVariable matchExprVar,\n-                                                             BLangBlockStmt successBody,\n-                                                             DiagnosticPos pos) {\n-        NodeKind patternKind = matchPattern.getKind();\n+                                                     BLangSimpleVariable matchExprVar,\n+                                                     BLangBlockStmt successBody,\n+                                                     DiagnosticPos pos) {\n+\n         BLangSimpleVarRef matchExprVarRef = ASTBuilderUtil.createVariableRef(matchExprVar.pos, matchExprVar.symbol);\n \n+        BLangExpression condition = createConditionForMatchPattern(matchPattern, matchExprVarRef);\n+        successBody.getStatements().addAll(matchStmtsForPattern);\n+        matchStmtsForPattern.clear();\n+        return ASTBuilderUtil.createIfElseStmt(pos, condition, successBody, null);\n+    }\n+\n+    private BLangExpression createConditionForWildCardMatchPattern(BLangWildCardMatchPattern wildCardMatchPattern,\n+                                                                   BLangSimpleVarRef matchExprVarRef) {\n+\n+        boolean condition;\n+        if (wildCardMatchPattern.matchesAll) {\n+            condition = true;\n+        } else {\n+            condition = types.isAssignable(matchExprVarRef.type, symTable.anyType);\n+        }\n+        return ASTBuilderUtil.createLiteral(wildCardMatchPattern.pos, symTable.booleanType, condition);\n+    }\n+\n+    private BLangExpression createConditionForConstMatchPattern(BLangConstPattern constPattern,\n+                                                                BLangSimpleVarRef matchExprVarRef) {\n+\n+        return createBinaryExpression(constPattern.pos, matchExprVarRef, constPattern.expr);\n+    }\n+\n+    private BLangExpression createConditionForVarBindingPatternMatchPattern(BLangVarBindingPatternMatchPattern\n+                                                                                    varBindingPatternMatchPattern,\n+                                                                            BLangSimpleVarRef matchExprVarRef) {\n+\n+        BLangBindingPattern bindingPattern = varBindingPatternMatchPattern.getBindingPattern();\n+\n+        switch (bindingPattern.getKind()) {\n+            case CAPTURE_BINDING_PATTERN:\n+                BLangCaptureBindingPattern captureBindingPattern = (BLangCaptureBindingPattern) bindingPattern;\n+                DiagnosticPos captureBindingPatternPos = captureBindingPattern.pos;\n+                BLangSimpleVariable captureBindingPatternVar =\n+                        ASTBuilderUtil.createVariable(captureBindingPatternPos,\n+                                captureBindingPattern.getIdentifier().getValue(), matchExprVarRef.type,\n+                                matchExprVarRef, captureBindingPattern.symbol);\n+                captureBindingPattern.symbol.type = matchExprVarRef.type;\n+                BLangSimpleVariableDef captureBindingPatternVarDef =\n+                        ASTBuilderUtil.createVariableDef(captureBindingPatternPos, captureBindingPatternVar);\n+                matchStmtsForPattern.add(captureBindingPatternVarDef);\n+\n+                return ASTBuilderUtil.createLiteral(captureBindingPattern.pos, symTable.booleanType, true);\n+        }\n+        // If some patterns are not implemented, those should be detected before this phase\n+        // TODO : Remove this after all patterns are implemented\n+        return null;\n+    }\n+\n+    private BLangExpression createConditionForErrorMatchPattern(BLangErrorMatchPattern errorMatchPattern,\n+                                                                BLangSimpleVarRef matchExprVarRef) {\n+\n+        BType matchPatternType = errorMatchPattern.type;", "originalCommit": "d089cf01183869bce84db9c4b933b1196a4ecff1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAwMjI4Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r500002287", "bodyText": "Changed", "author": "KavinduZoysa", "createdAt": "2020-10-06T04:42:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk3OTU5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk4MDU2NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r499980565", "bodyText": "No need to use the else-if clause, we can use the if clause", "author": "nadeeshaan", "createdAt": "2020-10-06T03:05:55Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -3003,76 +3011,315 @@ private BLangExpression createConditionFromMatchPatterns(List<BLangMatchPattern>\n         BLangSimpleVariableDef resultVarDef = createVarDef(\"$result$\", symTable.booleanType, null, pos);\n         BLangSimpleVarRef resultVarRef = ASTBuilderUtil.createVariableRef(pos, resultVarDef.var.symbol);\n         // $result$ = true\n-        BLangBlockStmt successBody = ASTBuilderUtil.createBlockStmt(pos);\n-        BLangAssignment successAssignment =\n-                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(true));\n-        successBody.addStatement(successAssignment);\n-        // $result$ = false\n-        BLangBlockStmt failureBody = ASTBuilderUtil.createBlockStmt(pos);\n-        BLangAssignment failureAssignment =\n-                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(false));\n-        failureBody.addStatement(failureAssignment);\n+        BLangBlockStmt successBody = createSuccessOrFailureBody(true, resultVarRef, pos);\n \n         BLangIf parentIfElse = createIfElseStmtFromMatchPattern(matchPatterns.get(0), matchExprVar, successBody, pos);\n         BLangIf currentIfElse = parentIfElse;\n \n         for (int i = 1; i < matchPatterns.size(); i++) {\n+            successBody = createSuccessOrFailureBody(true, resultVarRef, pos);\n             currentIfElse.elseStmt = createIfElseStmtFromMatchPattern(matchPatterns.get(i), matchExprVar, successBody,\n                     matchPatterns.get(i).pos);\n             currentIfElse = (BLangIf) currentIfElse.elseStmt;\n         }\n-        currentIfElse.elseStmt = failureBody;\n \n+        currentIfElse.elseStmt = createSuccessOrFailureBody(false, resultVarRef, pos);\n         BLangBlockStmt blockStmt = ASTBuilderUtil.createBlockStmt(pos, Lists.of(resultVarDef, parentIfElse));\n         BLangStatementExpression stmtExpr = createStatementExpression(blockStmt, resultVarRef);\n \n         return rewriteExpr(stmtExpr);\n     }\n \n+    private BLangBlockStmt createSuccessOrFailureBody(boolean status, BLangSimpleVarRef varRef, DiagnosticPos pos) {\n+        BLangBlockStmt blockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+        BLangAssignment bLangAssignment =\n+                ASTBuilderUtil.createAssignmentStmt(pos, varRef, getBooleanLiteral(status));\n+        blockStmt.addStatement(bLangAssignment);\n+        return blockStmt;\n+    }\n+\n     private BLangIf createIfElseStmtFromMatchPattern(BLangMatchPattern matchPattern,\n-                                                             BLangSimpleVariable matchExprVar,\n-                                                             BLangBlockStmt successBody,\n-                                                             DiagnosticPos pos) {\n-        NodeKind patternKind = matchPattern.getKind();\n+                                                     BLangSimpleVariable matchExprVar,\n+                                                     BLangBlockStmt successBody,\n+                                                     DiagnosticPos pos) {\n+\n         BLangSimpleVarRef matchExprVarRef = ASTBuilderUtil.createVariableRef(matchExprVar.pos, matchExprVar.symbol);\n \n+        BLangExpression condition = createConditionForMatchPattern(matchPattern, matchExprVarRef);\n+        successBody.getStatements().addAll(matchStmtsForPattern);\n+        matchStmtsForPattern.clear();\n+        return ASTBuilderUtil.createIfElseStmt(pos, condition, successBody, null);\n+    }\n+\n+    private BLangExpression createConditionForWildCardMatchPattern(BLangWildCardMatchPattern wildCardMatchPattern,\n+                                                                   BLangSimpleVarRef matchExprVarRef) {\n+\n+        boolean condition;\n+        if (wildCardMatchPattern.matchesAll) {\n+            condition = true;\n+        } else {\n+            condition = types.isAssignable(matchExprVarRef.type, symTable.anyType);\n+        }\n+        return ASTBuilderUtil.createLiteral(wildCardMatchPattern.pos, symTable.booleanType, condition);\n+    }\n+\n+    private BLangExpression createConditionForConstMatchPattern(BLangConstPattern constPattern,\n+                                                                BLangSimpleVarRef matchExprVarRef) {\n+\n+        return createBinaryExpression(constPattern.pos, matchExprVarRef, constPattern.expr);\n+    }\n+\n+    private BLangExpression createConditionForVarBindingPatternMatchPattern(BLangVarBindingPatternMatchPattern\n+                                                                                    varBindingPatternMatchPattern,\n+                                                                            BLangSimpleVarRef matchExprVarRef) {\n+\n+        BLangBindingPattern bindingPattern = varBindingPatternMatchPattern.getBindingPattern();\n+\n+        switch (bindingPattern.getKind()) {\n+            case CAPTURE_BINDING_PATTERN:\n+                BLangCaptureBindingPattern captureBindingPattern = (BLangCaptureBindingPattern) bindingPattern;\n+                DiagnosticPos captureBindingPatternPos = captureBindingPattern.pos;\n+                BLangSimpleVariable captureBindingPatternVar =\n+                        ASTBuilderUtil.createVariable(captureBindingPatternPos,\n+                                captureBindingPattern.getIdentifier().getValue(), matchExprVarRef.type,\n+                                matchExprVarRef, captureBindingPattern.symbol);\n+                captureBindingPattern.symbol.type = matchExprVarRef.type;\n+                BLangSimpleVariableDef captureBindingPatternVarDef =\n+                        ASTBuilderUtil.createVariableDef(captureBindingPatternPos, captureBindingPatternVar);\n+                matchStmtsForPattern.add(captureBindingPatternVarDef);\n+\n+                return ASTBuilderUtil.createLiteral(captureBindingPattern.pos, symTable.booleanType, true);\n+        }\n+        // If some patterns are not implemented, those should be detected before this phase\n+        // TODO : Remove this after all patterns are implemented\n+        return null;\n+    }\n+\n+    private BLangExpression createConditionForErrorMatchPattern(BLangErrorMatchPattern errorMatchPattern,\n+                                                                BLangSimpleVarRef matchExprVarRef) {\n+\n+        BType matchPatternType = errorMatchPattern.type;\n+        DiagnosticPos pos = errorMatchPattern.pos;\n+\n+        BLangSimpleVariableDef resultVarDef = createVarDef(\"errorPatternResult$\",\n+                symTable.booleanType, null, pos);\n+        BLangSimpleVarRef resultVarRef = ASTBuilderUtil.createVariableRef(pos, resultVarDef.var.symbol);\n+        BLangBlockStmt mainBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+        mainBlockStmt.addStatement(resultVarDef);\n+\n+        BLangAssignment failureResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(false));\n+        BLangAssignment successResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(true));\n+        mainBlockStmt.addStatement(failureResult);\n+\n+        BLangExpression typeCheckCondition = createIsLikeExpression(errorMatchPattern.pos, matchExprVarRef,\n+                matchPatternType);\n+        BLangExpression typeConvertedExpr = addConversionExprIfRequired(matchExprVarRef, matchPatternType);\n+        BLangSimpleVariableDef tempCastVarDef = createVarDef(\"$castTemp$\", matchPatternType, typeConvertedExpr, pos);\n+        BLangSimpleVarRef tempCastVarRef = ASTBuilderUtil.createVariableRef(pos, tempCastVarDef.var.symbol);\n+\n+        BLangBlockStmt ifBlock = ASTBuilderUtil.createBlockStmt(pos);\n+        ifBlock.addStatement(tempCastVarDef);\n+        BLangIf ifStmt = ASTBuilderUtil.createIfElseStmt(pos, typeCheckCondition, ifBlock, null);\n+        mainBlockStmt.addStatement(ifStmt);\n+\n+        BLangExpression condition = null;\n+        if (errorMatchPattern.errorMessageMatchPattern != null) {\n+            DiagnosticPos messagePos = errorMatchPattern.errorMessageMatchPattern.pos;\n+            BLangInvocation messageInvocation = createLangLibInvocationNode(ERROR_MESSAGE_FUNCTION_NAME,\n+                    tempCastVarRef,\n+                    new ArrayList<>(), null, messagePos);\n+            BLangSimpleVariableDef messageVarDef = createVarDef(\"$errorMessage$\", messageInvocation.type,\n+                    messageInvocation, messagePos);\n+            ifBlock.addStatement(messageVarDef);\n+            BLangSimpleVarRef messageVarRef = ASTBuilderUtil.createVariableRef(messagePos,\n+                    messageVarDef.var.symbol);\n+            condition =\n+                    createConditionForErrorMessageMatchPattern(errorMatchPattern.errorMessageMatchPattern,\n+                            messageVarRef);\n+        }\n+\n+        if (errorMatchPattern.errorCauseMatchPattern != null) {\n+            DiagnosticPos errorCausePos = errorMatchPattern.errorCauseMatchPattern.pos;\n+            BLangInvocation causeInvocation = createLangLibInvocationNode(ERROR_CAUSE_FUNCTION_NAME,\n+                    tempCastVarRef,\n+                    new ArrayList<>(), null, errorCausePos);\n+            BLangSimpleVariableDef causeVarDef = createVarDef(\"$errorCause$\", causeInvocation.type,\n+                    causeInvocation, errorCausePos);\n+            ifBlock.addStatement(causeVarDef);\n+            BLangSimpleVarRef causeVarRef = ASTBuilderUtil.createVariableRef(errorCausePos,\n+                    causeVarDef.var.symbol);\n+            BLangExpression errorCauseCondition =\n+                    createConditionForErrorCauseMatchPattern(errorMatchPattern.errorCauseMatchPattern,\n+                            causeVarRef);\n+            condition = ASTBuilderUtil.createBinaryExpr(pos, condition, errorCauseCondition,\n+                    symTable.booleanType, OperatorKind.AND, (BOperatorSymbol) symResolver\n+                            .resolveBinaryOperator(OperatorKind.AND, symTable.booleanType,\n+                                    symTable.booleanType));\n+        }\n+\n+        if (errorMatchPattern.errorFieldMatchPatterns != null) {\n+            DiagnosticPos errorFieldPos = errorMatchPattern.errorFieldMatchPatterns.pos;\n+            BLangInvocation errorDetailInvocation = createLangLibInvocationNode(ERROR_DETAIL_FUNCTION_NAME,\n+                    tempCastVarRef, new ArrayList<>(), null, errorFieldPos);\n+            BLangSimpleVariableDef errorDetailVarDef = createVarDef(\"$errorDetail$\", errorDetailInvocation.type,\n+                    errorDetailInvocation, errorFieldPos);\n+            ifBlock.addStatement(errorDetailVarDef);\n+            BLangSimpleVarRef errorDetailVarRef = ASTBuilderUtil.createVariableRef(errorFieldPos,\n+                    errorDetailVarDef.var.symbol);\n+\n+            BLangExpression errorDetailCondition =\n+                    createConditionForErrorFieldMatchPatterns(errorMatchPattern.errorFieldMatchPatterns,\n+                            errorDetailVarRef);\n+\n+            if (condition != null) {\n+                condition = ASTBuilderUtil.createBinaryExpr(pos, condition, errorDetailCondition,\n+                        symTable.booleanType, OperatorKind.AND, (BOperatorSymbol) symResolver\n+                                .resolveBinaryOperator(OperatorKind.AND, symTable.booleanType,\n+                                        symTable.booleanType));\n+            } else {\n+                condition = errorDetailCondition;\n+            }\n+        }\n+\n+        BLangBlockStmt tempBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+        tempBlockStmt.addStatement(successResult);\n+        BLangIf ifStmtForMatchPatterns = ASTBuilderUtil.createIfElseStmt(pos, condition, tempBlockStmt, null);\n+        ifBlock.addStatement(ifStmtForMatchPatterns);\n+\n+        BLangStatementExpression statementExpression = ASTBuilderUtil.createStatementExpression(mainBlockStmt,\n+                resultVarRef);\n+        statementExpression.type = symTable.booleanType;\n+\n+        return statementExpression;\n+    }\n+\n+    private BLangExpression createConditionForErrorFieldMatchPatterns(\n+            BLangErrorFieldMatchPatterns errorFieldMatchPatterns, BLangSimpleVarRef matchExprVarRef) {\n+\n+        DiagnosticPos pos = errorFieldMatchPatterns.pos;\n+        BLangSimpleVariableDef resultVarDef = createVarDef(\"errorFieldResult$\", symTable.booleanType, null, pos);\n+        BLangSimpleVarRef resultVarRef = ASTBuilderUtil.createVariableRef(pos, resultVarDef.var.symbol);\n+        BLangBlockStmt mainBlockStmt = ASTBuilderUtil.createBlockStmt(pos);\n+        mainBlockStmt.addStatement(resultVarDef);\n+\n+        BLangAssignment failureResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(false));\n+        BLangAssignment successResult =\n+                ASTBuilderUtil.createAssignmentStmt(pos, resultVarRef, getBooleanLiteral(true));\n+        mainBlockStmt.addStatement(failureResult);\n+\n+        BLangExpression condition = null;\n+        for (int i = 0; i < errorFieldMatchPatterns.namedArgMatchPatterns.size(); i++) {\n+            BLangNamedArgMatchPattern namedArgMatchPattern = errorFieldMatchPatterns.namedArgMatchPatterns.get(i);\n+            String argName = namedArgMatchPattern.argName.value;\n+            BLangMatchPattern matchPattern = namedArgMatchPattern.matchPattern;\n+            DiagnosticPos matchPatternPos = matchPattern.pos;\n+\n+            BLangFieldBasedAccess fieldBasedAccessExpr = getFieldAccessExpression(matchPatternPos, argName,\n+                    symTable.anydataOrReadonly, (BVarSymbol) matchExprVarRef.symbol);\n+            BLangSimpleVariableDef tempVarDef = createVarDef(\"$errorFieldVarTemp$\" + i + \"_$\",\n+                    symTable.anydataOrReadonly,\n+                    fieldBasedAccessExpr, matchPatternPos);\n+            mainBlockStmt.addStatement(tempVarDef);\n+            BLangSimpleVarRef tempVarRef = ASTBuilderUtil.createVariableRef(matchPatternPos, tempVarDef.var.symbol);\n+\n+            BLangExpression varCheckCondition = createConditionForNamedArgMatchPattern(matchPattern, tempVarRef);\n+            if (i == 0) {\n+                condition = varCheckCondition;\n+                continue;\n+            }\n+            condition = ASTBuilderUtil.createBinaryExpr(matchPatternPos, condition, varCheckCondition,\n+                    symTable.booleanType, OperatorKind.AND, (BOperatorSymbol) symResolver\n+                            .resolveBinaryOperator(OperatorKind.AND, symTable.booleanType, symTable.booleanType));\n+\n+        }\n+\n+        BLangBlockStmt tempBLock = ASTBuilderUtil.createBlockStmt(pos);\n+        tempBLock.addStatement(successResult);\n+        BLangIf ifStmtForFieldMatchPatterns = ASTBuilderUtil.createIfElseStmt(pos, condition, tempBLock, null);\n+        mainBlockStmt.addStatement(ifStmtForFieldMatchPatterns);\n+\n+        BLangStatementExpression statementExpression = ASTBuilderUtil.createStatementExpression(mainBlockStmt,\n+                resultVarRef);\n+        statementExpression.type = symTable.booleanType;\n+\n+        return statementExpression;\n+    }\n+\n+    private BLangExpression createConditionForNamedArgMatchPattern(BLangMatchPattern matchPattern,\n+                                                                   BLangSimpleVarRef matchExprVarRef) {\n+\n+        return createVarCheckCondition(matchPattern, matchExprVarRef);\n+    }\n+\n+    private BLangExpression createConditionForErrorCauseMatchPattern(BLangErrorCauseMatchPattern errorCausePattern,\n+                                                                     BLangSimpleVarRef matchExprVarRef) {\n+\n+        if (errorCausePattern.simpleMatchPattern != null) {\n+            return createConditionForSimpleMatchPattern(errorCausePattern.simpleMatchPattern, matchExprVarRef);\n+        }\n+        return createConditionForErrorMatchPattern(errorCausePattern.errorMatchPattern, matchExprVarRef);\n+    }\n+\n+    private BLangExpression createConditionForErrorMessageMatchPattern(BLangErrorMessageMatchPattern errorMsgPattern,\n+                                                                       BLangSimpleVarRef matchExprVarRef) {\n+\n+        return createConditionForSimpleMatchPattern(errorMsgPattern.simpleMatchPattern, matchExprVarRef);\n+    }\n+\n+    private BLangExpression createConditionForSimpleMatchPattern(BLangSimpleMatchPattern simpleMatchPattern,\n+                                                                 BLangSimpleVarRef matchExprVarRef) {\n+\n+        if (simpleMatchPattern.wildCardMatchPattern != null) {\n+            return createVarCheckCondition(simpleMatchPattern.wildCardMatchPattern, matchExprVarRef);\n+        } else if (simpleMatchPattern.constPattern != null) {", "originalCommit": "d089cf01183869bce84db9c4b933b1196a4ecff1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAwMjM3MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r500002370", "bodyText": "Done", "author": "KavinduZoysa", "createdAt": "2020-10-06T04:42:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk4MDU2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk4MTY5MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r499981690", "bodyText": "Shall we refactor this method with an if ladder? since each clause do a return?", "author": "nadeeshaan", "createdAt": "2020-10-06T03:11:01Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/BLangNodeTransformer.java", "diffHunk": "@@ -3815,27 +3825,37 @@ public BLangNode transform(MatchStatementNode matchStatementNode) {\n         return matchStatement;\n     }\n \n-    private BLangMatchPattern transformMatchPattern(Node matchPattern, DiagnosticPos matchPatternPos) {\n+    private BLangMatchPattern transformMatchPattern(Node matchPattern) {", "originalCommit": "d089cf01183869bce84db9c4b933b1196a4ecff1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAwMjM3Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r500002377", "bodyText": "Done", "author": "KavinduZoysa", "createdAt": "2020-10-06T04:42:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk4MTY5MA=="}], "type": "inlineReview"}, {"oid": "8829de15397ffafebdfbc7af8a51b799d85f9857", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8829de15397ffafebdfbc7af8a51b799d85f9857", "message": "Refactor the code", "committedDate": "2020-10-06T04:31:07Z", "type": "forcePushed"}, {"oid": "d4b1733e3be75019f4f2052d615e277277761edf", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d4b1733e3be75019f4f2052d615e277277761edf", "message": "Refactor the code", "committedDate": "2020-10-06T04:41:17Z", "type": "forcePushed"}, {"oid": "0a028f530b7074c4824564eadbaf5bc3a06668e7", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0a028f530b7074c4824564eadbaf5bc3a06668e7", "message": "Refactor the code", "committedDate": "2020-10-06T08:49:02Z", "type": "forcePushed"}, {"oid": "3d78cd258d459188a781b9c2d9aef58b0c8908a4", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3d78cd258d459188a781b9c2d9aef58b0c8908a4", "message": "Add tests", "committedDate": "2020-10-23T13:53:04Z", "type": "forcePushed"}, {"oid": "565a517f0c1a27340f5897b203ea2cac98e214c3", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/565a517f0c1a27340f5897b203ea2cac98e214c3", "message": "Sync with master", "committedDate": "2020-11-09T14:21:55Z", "type": "forcePushed"}, {"oid": "c3627a95329ea55a398040feab244c241206972c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c3627a95329ea55a398040feab244c241206972c", "message": "Sync with master", "committedDate": "2020-11-10T02:58:52Z", "type": "forcePushed"}, {"oid": "03b391656a20e963878cd5f582248b1ee9891cfb", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/03b391656a20e963878cd5f582248b1ee9891cfb", "message": "Sync with master", "committedDate": "2020-11-10T10:32:21Z", "type": "forcePushed"}, {"oid": "3f6200b754f599802200226e614038ad154b307d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3f6200b754f599802200226e614038ad154b307d", "message": "Sync with master", "committedDate": "2020-11-10T10:38:02Z", "type": "forcePushed"}, {"oid": "bcbd924db0f4bcb40f0859f9d55be1194a2dc835", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bcbd924db0f4bcb40f0859f9d55be1194a2dc835", "message": "Sync with master", "committedDate": "2020-11-23T04:30:45Z", "type": "forcePushed"}, {"oid": "e00e2fd6348b18282a83508156db05921ef80610", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e00e2fd6348b18282a83508156db05921ef80610", "message": "Sync with master", "committedDate": "2020-11-23T06:34:02Z", "type": "forcePushed"}, {"oid": "900a732e57fb51b48d9eabcb23eb01773475f64b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/900a732e57fb51b48d9eabcb23eb01773475f64b", "message": "Fix failure tests", "committedDate": "2020-12-17T18:29:21Z", "type": "forcePushed"}, {"oid": "13e5dd4449495c7db7971bcb877b0140411c5bcf", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/13e5dd4449495c7db7971bcb877b0140411c5bcf", "message": "Fix failure tests", "committedDate": "2021-01-04T04:31:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjMwNjcxNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r556306716", "bodyText": "The error-match-pattern can have no args, right? Note the second part of error-arg-list-match-pattern\nerror-match-pattern := error [error-type-reference] ( error-arg-list-match-pattern )\nerror-arg-list-match-pattern :=\n   error-message-match-pattern [, error-cause-match-pattern] [, error-field-match-patterns]\n   | [error-field-match-patterns]\n\nThe following results in a bad, sad error here.\nfunction matchError(any|error e) {\n    match e {\n        error() => {\n        }\n    }\n}", "author": "MaryamZi", "createdAt": "2021-01-13T07:17:10Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/BLangNodeTransformer.java", "diffHunk": "@@ -4041,15 +4066,61 @@ private BLangMatchPattern transformMatchPattern(Node matchPattern, Location matc\n                     return null;\n             }\n             return bLangVarBindingPattern;\n-        } else if (matchPattern.kind() == SyntaxKind.LIST_MATCH_PATTERN) {\n+        }\n+\n+        if (kind == SyntaxKind.ERROR_MATCH_PATTERN) {\n+            ErrorMatchPatternNode errorMatchPatternNode = (ErrorMatchPatternNode) matchPattern;\n+            BLangErrorMatchPattern bLangErrorMatchPattern =\n+                    (BLangErrorMatchPattern) TreeBuilder.createErrorMatchPattern();\n+            bLangErrorMatchPattern.pos = matchPatternPos;\n+\n+            NameReferenceNode nameReferenceNode;\n+            if (errorMatchPatternNode.typeReference().isPresent()) {\n+                nameReferenceNode = errorMatchPatternNode.typeReference().get();\n+                bLangErrorMatchPattern.errorTypeReference = (BLangUserDefinedType) createTypeNode(nameReferenceNode);\n+            }\n+\n+            Node node = errorMatchPatternNode.argListMatchPatternNode().get(0);", "originalCommit": "13e5dd4449495c7db7971bcb877b0140411c5bcf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjQ5MTk2NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r556491964", "bodyText": "Fixed", "author": "KavinduZoysa", "createdAt": "2021-01-13T12:42:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjMwNjcxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjMwOTA0Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r556309042", "bodyText": "Unnecessary change.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @since Swan Lake\n          \n          \n            \n             * @since 2.0.0", "author": "MaryamZi", "createdAt": "2021-01-13T07:23:05Z", "path": "compiler/ballerina-lang/src/main/java/org/ballerinalang/model/tree/matchpatterns/RestMatchPatternNode.java", "diffHunk": "@@ -22,9 +22,10 @@\n /**\n  * The interface with the APIs to implement the rest-match-pattern.\n  *\n- * @since 2.0.0\n+ * @since Swan Lake", "originalCommit": "13e5dd4449495c7db7971bcb877b0140411c5bcf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjQ5MjAyMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r556492022", "bodyText": "Fixed", "author": "KavinduZoysa", "createdAt": "2021-01-13T12:42:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjMwOTA0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjMxMjAxNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r556312015", "bodyText": "Shall we remove these unnecessary new lines? Please check other changes in this PR too.", "author": "MaryamZi", "createdAt": "2021-01-13T07:29:40Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/tree/matchpatterns/BLangErrorMatchPattern.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.tree.matchpatterns;\n+\n+import org.ballerinalang.model.tree.NodeKind;\n+import org.ballerinalang.model.tree.matchpatterns.ErrorCauseMatchPatternNode;\n+import org.ballerinalang.model.tree.matchpatterns.ErrorFieldMatchPatternsNode;\n+import org.ballerinalang.model.tree.matchpatterns.ErrorMatchPatternNode;\n+import org.ballerinalang.model.tree.matchpatterns.ErrorMessageMatchPatternNode;\n+import org.ballerinalang.model.tree.types.UserDefinedTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.BLangNodeVisitor;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangUserDefinedType;\n+\n+/**\n+ * Represent error-match-pattern.\n+ *\n+ * @since 2.0.0\n+ */\n+public class BLangErrorMatchPattern extends BLangMatchPattern implements ErrorMatchPatternNode {\n+\n+    public BLangErrorMessageMatchPattern errorMessageMatchPattern;\n+    public BLangErrorCauseMatchPattern errorCauseMatchPattern;\n+    public BLangErrorFieldMatchPatterns errorFieldMatchPatterns;\n+    public BLangUserDefinedType errorTypeReference;\n+\n+    @Override\n+    public UserDefinedTypeNode getErrorTypeReference() {\n+        return errorTypeReference;\n+    }\n+\n+    @Override\n+    public void setErrorTypeReference(UserDefinedTypeNode userDefinedTypeNode) {\n+        this.errorTypeReference = (BLangUserDefinedType) userDefinedTypeNode;\n+    }\n+\n+    @Override\n+    public ErrorMessageMatchPatternNode getErrorMessageMatchPattern() {\n+\n+        return errorMessageMatchPattern;\n+    }\n+\n+    @Override\n+    public void setErrorMessageMatchPattern(ErrorMessageMatchPatternNode errorMessageMatchPattern) {\n+", "originalCommit": "13e5dd4449495c7db7971bcb877b0140411c5bcf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjQ5MjA1OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r556492058", "bodyText": "Fixed", "author": "KavinduZoysa", "createdAt": "2021-01-13T12:42:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjMxMjAxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjMxNTEzNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r556315135", "bodyText": "Why do we need separate classes for BLangErrorCauseMatchPattern and BLangErrorMessageMatchPattern?", "author": "MaryamZi", "createdAt": "2021-01-13T07:36:18Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/tree/matchpatterns/BLangErrorCauseMatchPattern.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.tree.matchpatterns;\n+\n+import org.ballerinalang.model.tree.NodeKind;\n+import org.ballerinalang.model.tree.matchpatterns.ErrorCauseMatchPatternNode;\n+import org.ballerinalang.model.tree.matchpatterns.ErrorMatchPatternNode;\n+import org.ballerinalang.model.tree.matchpatterns.SimpleMatchPatternNode;\n+import org.wso2.ballerinalang.compiler.tree.BLangNodeVisitor;\n+\n+/**\n+ * Represent error-cause-match-pattern.\n+ *\n+ * @since 2.0.0\n+ */\n+public class BLangErrorCauseMatchPattern extends BLangMatchPattern implements ErrorCauseMatchPatternNode {", "originalCommit": "13e5dd4449495c7db7971bcb877b0140411c5bcf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjMxNTg1MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r556315851", "bodyText": "We can never have both, right? IMO, this opens up room for error, which we can minimize by not introducing separate classes for the cause (and message).", "author": "MaryamZi", "createdAt": "2021-01-13T07:37:55Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/tree/matchpatterns/BLangErrorCauseMatchPattern.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.tree.matchpatterns;\n+\n+import org.ballerinalang.model.tree.NodeKind;\n+import org.ballerinalang.model.tree.matchpatterns.ErrorCauseMatchPatternNode;\n+import org.ballerinalang.model.tree.matchpatterns.ErrorMatchPatternNode;\n+import org.ballerinalang.model.tree.matchpatterns.SimpleMatchPatternNode;\n+import org.wso2.ballerinalang.compiler.tree.BLangNodeVisitor;\n+\n+/**\n+ * Represent error-cause-match-pattern.\n+ *\n+ * @since 2.0.0\n+ */\n+public class BLangErrorCauseMatchPattern extends BLangMatchPattern implements ErrorCauseMatchPatternNode {\n+\n+    public BLangSimpleMatchPattern simpleMatchPattern;\n+    public BLangErrorMatchPattern errorMatchPattern;", "originalCommit": "13e5dd4449495c7db7971bcb877b0140411c5bcf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjMyODQyNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r556328424", "bodyText": "Even if we continue to have separate classes, wouldn't it be better to have a single field here?", "author": "MaryamZi", "createdAt": "2021-01-13T08:04:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjMxNTg1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjMxNzIxMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r556317212", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @since Swan Lake\n          \n          \n            \n             * @since 2.0.0", "author": "MaryamZi", "createdAt": "2021-01-13T07:40:54Z", "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/matchstmt/MatchStmtErrorMatchPatternTest.java", "diffHunk": "@@ -0,0 +1,95 @@\n+// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+//\n+// WSO2 Inc. licenses this file to you under the Apache License,\n+// Version 2.0 (the \"License\"); you may not use this file except\n+// in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.ballerinalang.test.statements.matchstmt;\n+\n+import org.ballerinalang.test.BCompileUtil;\n+import org.ballerinalang.test.BRunUtil;\n+import org.ballerinalang.test.CompileResult;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * Test cases to verify the behaviour of the error-match-pattern.\n+ *\n+ * @since Swan Lake", "originalCommit": "13e5dd4449495c7db7971bcb877b0140411c5bcf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjQ5MjE5OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r556492199", "bodyText": "Fixed", "author": "KavinduZoysa", "createdAt": "2021-01-13T12:43:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjMxNzIxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjMxNzQ2NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r556317465", "bodyText": "Why aren't we adding negative tests?", "author": "MaryamZi", "createdAt": "2021-01-13T07:41:32Z", "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/matchstmt/MatchStmtErrorMatchPatternTest.java", "diffHunk": "@@ -0,0 +1,95 @@\n+// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+//\n+// WSO2 Inc. licenses this file to you under the Apache License,\n+// Version 2.0 (the \"License\"); you may not use this file except\n+// in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.ballerinalang.test.statements.matchstmt;\n+\n+import org.ballerinalang.test.BCompileUtil;\n+import org.ballerinalang.test.BRunUtil;\n+import org.ballerinalang.test.CompileResult;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * Test cases to verify the behaviour of the error-match-pattern.\n+ *\n+ * @since Swan Lake\n+ */\n+@Test(groups = { \"disableOnOldParser\" })\n+public class MatchStmtErrorMatchPatternTest {\n+    private CompileResult result, restPatternResult;\n+\n+    @BeforeClass\n+    public void setup() {", "originalCommit": "13e5dd4449495c7db7971bcb877b0140411c5bcf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzg4MDAwOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r557880009", "bodyText": "Added", "author": "KavinduZoysa", "createdAt": "2021-01-15T06:02:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjMxNzQ2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjMzMTM0Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r556331347", "bodyText": "Here again, shouldn't this just be a list? Similar to what's done with MappingMatchPatternNode?", "author": "MaryamZi", "createdAt": "2021-01-13T08:10:12Z", "path": "compiler/ballerina-lang/src/main/java/org/ballerinalang/model/tree/matchpatterns/ErrorMatchPatternNode.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.model.tree.matchpatterns;\n+\n+import org.ballerinalang.model.tree.Node;\n+import org.ballerinalang.model.tree.types.UserDefinedTypeNode;\n+\n+/**\n+ * The interface with the APIs to implement the error-match-pattern.\n+ *\n+ * @since 2.0.0\n+ */\n+public interface ErrorMatchPatternNode extends Node {\n+\n+    UserDefinedTypeNode getErrorTypeReference();\n+\n+    void setErrorTypeReference(UserDefinedTypeNode userDefinedTypeNode);\n+\n+    ErrorMessageMatchPatternNode getErrorMessageMatchPattern();\n+\n+    void setErrorMessageMatchPattern(ErrorMessageMatchPatternNode errorMessageMatchPattern);\n+\n+    ErrorCauseMatchPatternNode getErrorCauseMatchPatternNode();\n+\n+    void setErrorCauseMatchPatternNode(ErrorCauseMatchPatternNode errorCauseMatchPatternNode);\n+\n+    ErrorFieldMatchPatternsNode getErrorFieldMatchPatternNode();\n+\n+    void setErrorFieldMatchPatternsNode(ErrorFieldMatchPatternsNode errorFieldMatchPatternsNode);", "originalCommit": "13e5dd4449495c7db7971bcb877b0140411c5bcf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM2MDgzMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r556360830", "bodyText": "Should only allow the capture binding pattern here. Can use createCaptureOrWildcardBP method to create capture binding pattern from var name\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            STNode variableName = parseBindingPattern();\n          \n          \n            \n                            STNode variableName = createCaptureOrWildcardBP(parseVariableName());", "author": "rdulmina", "createdAt": "2021-01-13T09:01:00Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -13605,7 +13605,7 @@ private STNode parseErrorArgListMatchPattern(ParserRuleContext context) {\n                 return parseMatchPattern();\n             case VAR_KEYWORD:\n                 STNode varKeyword = consume();\n-                STNode variableName = parseVariableName();\n+                STNode variableName = parseBindingPattern();", "originalCommit": "13e5dd4449495c7db7971bcb877b0140411c5bcf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjQ5MjI1OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r556492258", "bodyText": "Fixed", "author": "KavinduZoysa", "createdAt": "2021-01-13T12:43:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM2MDgzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjMzMzE0Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r556333143", "bodyText": "Here again, it can be only one of these, right?", "author": "MaryamZi", "createdAt": "2021-01-13T08:13:35Z", "path": "compiler/ballerina-lang/src/main/java/org/ballerinalang/model/tree/matchpatterns/SimpleMatchPatternNode.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.model.tree.matchpatterns;\n+\n+import org.ballerinalang.model.tree.Node;\n+\n+/**\n+ * The interface with the APIs to implement the simple-match-pattern.\n+ *\n+ * @since 2.0.0\n+ */\n+public interface SimpleMatchPatternNode extends Node {\n+\n+    ConstPatternNode getConstPattern();\n+\n+    void setConstPattern(ConstPatternNode constPattern);\n+\n+    WildCardMatchPatternNode getWildCardPattern();\n+\n+    void setWildCardPattern(WildCardMatchPatternNode wildCardPattern);\n+\n+    VarBindingPatternMatchPatternNode getVarBindingPatternMatchPattern();\n+\n+    void setVarBindingPatternMatchPattern(VarBindingPatternMatchPatternNode varBindingPatternMatchPattern);", "originalCommit": "13e5dd4449495c7db7971bcb877b0140411c5bcf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjMzNDIwMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r556334202", "bodyText": "Indentation is off.", "author": "MaryamZi", "createdAt": "2021-01-13T08:15:14Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -3569,13 +3574,229 @@ private BLangExpression createConditionForMatchPattern(BLangMatchPattern matchPa\n                         (BLangVarBindingPatternMatchPattern) matchPattern, matchExprVarRef);\n             case LIST_MATCH_PATTERN:\n                 return createConditionForListMatchPattern((BLangListMatchPattern) matchPattern, matchExprVarRef);\n-            default:\n+            case ERROR_MATCH_PATTERN:\n+                return createConditionForErrorMatchPattern((BLangErrorMatchPattern) matchPattern, matchExprVarRef);\n+                default:", "originalCommit": "13e5dd4449495c7db7971bcb877b0140411c5bcf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjQ5MjMwMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r556492303", "bodyText": "Fixed", "author": "KavinduZoysa", "createdAt": "2021-01-13T12:43:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjMzNDIwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM0MDk0Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r556340943", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void visit(BLangErrorMatchPattern errorMatchPattern) {}\n          \n          \n            \n                public void visit(BLangErrorMatchPattern errorMatchPattern) {\n          \n          \n            \n                }", "author": "MaryamZi", "createdAt": "2021-01-13T08:27:32Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java", "diffHunk": "@@ -1061,6 +1062,9 @@ public void visit(BLangCaptureBindingPattern captureBindingPattern) {\n         this.hasLastPatternInClause = true;\n     }\n \n+    @Override\n+    public void visit(BLangErrorMatchPattern errorMatchPattern) {}", "originalCommit": "13e5dd4449495c7db7971bcb877b0140411c5bcf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjQ5MjMyOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r556492328", "bodyText": "Fixed", "author": "KavinduZoysa", "createdAt": "2021-01-13T12:43:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM0MDk0Mw=="}], "type": "inlineReview"}, {"oid": "9853abc397a12b0b776712900efb73440ed1acc7", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9853abc397a12b0b776712900efb73440ed1acc7", "message": "Fix review suggestions", "committedDate": "2021-01-13T12:42:04Z", "type": "forcePushed"}, {"oid": "7df2787a3068fa44e15730878ececcfb9f44e61a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7df2787a3068fa44e15730878ececcfb9f44e61a", "message": "Fix review suggestions", "committedDate": "2021-01-14T03:52:36Z", "type": "forcePushed"}, {"oid": "f7292f733bf3ad46c9181ea085505c008c31ae34", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f7292f733bf3ad46c9181ea085505c008c31ae34", "message": "Fix review suggestions", "committedDate": "2021-01-15T05:58:27Z", "type": "forcePushed"}, {"oid": "4876aefb077197306dfa285cf8e12605f4ef1f2c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4876aefb077197306dfa285cf8e12605f4ef1f2c", "message": "Fix review suggestions", "committedDate": "2021-01-15T14:38:34Z", "type": "forcePushed"}, {"oid": "c0018fa8c13aec9a0833d86dfc486198bae7d511", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c0018fa8c13aec9a0833d86dfc486198bae7d511", "message": "Fix review suggestions", "committedDate": "2021-01-18T13:47:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTczODIxOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r559738218", "bodyText": "The following seem to fail here, when an invalid syntax is used (key-value pair instead of named arg).\npublic function main() {\n    error x = error(\"err\");\n\n    match err { // no undefined symbol error\n        error(\"err\", i: 1) => {\n            panic err;  // no undefined symbol error\n        }\n    }\n}\npublic function main() {\n    error x = error(\"err\");\n\n    match x {\n        error(\"err\", i: 1) => {\n            panic x;\n        }\n    }\n}\n[2021-01-18 23:54:05,828] SEVERE {b7a.log.crash} - null \njava.lang.NullPointerException\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.Types.resolvePatternTypeFromMatchExpr(Types.java:417)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SemanticAnalyzer.visit(SemanticAnalyzer.java:2908)\n\tat org.wso2.ballerinalang.compiler.tree.matchpatterns.BLangConstPattern.accept(BLangConstPattern.java:37)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SemanticAnalyzer.analyzeNode(SemanticAnalyzer.java:3461)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SemanticAnalyzer.analyzeNode(SemanticAnalyzer.java:3429)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SemanticAnalyzer.visit(SemanticAnalyzer.java:2849)\n\tat org.wso2.ballerinalang.compiler.tree.matchpatterns.BLangSimpleMatchPattern.accept(BLangSimpleMatchPattern.java:70)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SemanticAnalyzer.analyzeNode(SemanticAnalyzer.java:3461)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SemanticAnalyzer.analyzeNode(SemanticAnalyzer.java:3429)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SemanticAnalyzer.visit(SemanticAnalyzer.java:2868)\n\tat org.wso2.ballerinalang.compiler.tree.matchpatterns.BLangErrorCauseMatchPattern.accept(BLangErrorCauseMatchPattern.java:58)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SemanticAnalyzer.analyzeNode(SemanticAnalyzer.java:3461)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SemanticAnalyzer.analyzeNode(SemanticAnalyzer.java:3429)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SemanticAnalyzer.visit(SemanticAnalyzer.java:2831)\n\tat org.wso2.ballerinalang.compiler.tree.matchpatterns.BLangErrorMatchPattern.accept(BLangErrorMatchPattern.java:83)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SemanticAnalyzer.analyzeNode(SemanticAnalyzer.java:3461)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SemanticAnalyzer.analyzeNode(SemanticAnalyzer.java:3429)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SemanticAnalyzer.visit(SemanticAnalyzer.java:2528)\n\tat org.wso2.ballerinalang.compiler.tree.clauses.BLangMatchClause.accept(BLangMatchClause.java:54)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SemanticAnalyzer.analyzeNode(SemanticAnalyzer.java:3461)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SemanticAnalyzer.analyzeNode(SemanticAnalyzer.java:3429)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SemanticAnalyzer.visit(SemanticAnalyzer.java:2499)\n\tat org.wso2.ballerinalang.compiler.tree.statements.BLangMatchStatement.accept(BLangMatchStatement.java:73)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SemanticAnalyzer.analyzeNode(SemanticAnalyzer.java:3461)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SemanticAnalyzer.analyzeNode(SemanticAnalyzer.java:3429)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SemanticAnalyzer.analyzeStmt(SemanticAnalyzer.java:3425)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SemanticAnalyzer.visit(SemanticAnalyzer.java:433)\n\tat org.wso2.ballerinalang.compiler.tree.BLangBlockFunctionBody.accept(BLangBlockFunctionBody.java:58)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SemanticAnalyzer.analyzeNode(SemanticAnalyzer.java:3461)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SemanticAnalyzer.visit(SemanticAnalyzer.java:405)\n\tat org.wso2.ballerinalang.compiler.tree.BLangFunction.accept(BLangFunction.java:73)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SemanticAnalyzer.analyzeNode(SemanticAnalyzer.java:3461)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SemanticAnalyzer.analyzeNode(SemanticAnalyzer.java:3429)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SemanticAnalyzer.analyzeDef(SemanticAnalyzer.java:3421)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SemanticAnalyzer.visit(SemanticAnalyzer.java:300)\n\tat org.wso2.ballerinalang.compiler.tree.BLangPackage.accept(BLangPackage.java:163)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SemanticAnalyzer.analyze(SemanticAnalyzer.java:265)\n\tat io.ballerina.projects.internal.CompilerPhaseRunner.typeCheck(CompilerPhaseRunner.java:217)\n\tat io.ballerina.projects.internal.CompilerPhaseRunner.performTypeCheckPhases(CompilerPhaseRunner.java:115)\n\tat io.ballerina.projects.ModuleContext.compileInternal(ModuleContext.java:348)\n\tat io.ballerina.projects.ModuleCompilationState$1.compile(ModuleCompilationState.java:45)\n\tat io.ballerina.projects.ModuleCompilationState$1.generatePlatformSpecificCode(ModuleCompilationState.java:53)\n\tat io.ballerina.projects.ModuleContext.generatePlatformSpecificCode(ModuleContext.java:301)\n\tat io.ballerina.projects.JBallerinaBackend.performCodeGen(JBallerinaBackend.java:135)\n\tat io.ballerina.projects.JBallerinaBackend.<init>(JBallerinaBackend.java:121)\n\tat io.ballerina.projects.JBallerinaBackend.lambda$from$0(JBallerinaBackend.java:97)\n\tat java.base/java.util.HashMap.computeIfAbsent(HashMap.java:1133)\n\tat io.ballerina.projects.PackageCompilation.getCompilerBackend(PackageCompilation.java:127)\n\tat io.ballerina.projects.JBallerinaBackend.from(JBallerinaBackend.java:96)\n\tat io.ballerina.cli.task.CompileTask.execute(CompileTask.java:69)\n\tat io.ballerina.cli.TaskExecutor.executeTasks(TaskExecutor.java:40)\n\tat io.ballerina.cli.cmd.RunCommand.execute(RunCommand.java:154)\n\tat java.base/java.util.Optional.ifPresent(Optional.java:183)\n\tat io.ballerina.cli.launcher.Main.main(Main.java:58)", "author": "MaryamZi", "createdAt": "2021-01-18T18:24:57Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -395,16 +397,30 @@ BType resolvePatternTypeFromMatchExpr(BLangExpression matchExpr, BTupleType list\n         return symTable.noType;\n     }\n \n-    BType resolvePatternTypeFromMatchExpr(BLangExpression matchExpr, BLangExpression constPatternExpr) {\n+    public BType resolvePatternTypeFromMatchExpr(BLangErrorMatchPattern errorMatchPattern, BLangExpression matchExpr) {\n         if (matchExpr == null) {\n+            return errorMatchPattern.type;\n+        }\n+\n+        if (isAssignable(matchExpr.type, errorMatchPattern.type)) {\n+            return matchExpr.type;\n+        }\n+        if (isAssignable(errorMatchPattern.type, matchExpr.type)) {\n+            return errorMatchPattern.type;\n+        }\n+        return symTable.noType;\n+    }\n+\n+    public BType resolvePatternTypeFromMatchExpr(BLangConstPattern constPattern, BLangExpression constPatternExpr) {\n+        if (constPattern.matchExpr == null) {\n             if (constPatternExpr.getKind() == NodeKind.SIMPLE_VARIABLE_REF) {\n                 return ((BLangSimpleVarRef) constPatternExpr).symbol.type;", "originalCommit": "c0018fa8c13aec9a0833d86dfc486198bae7d511", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTc1MDQ0MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r559750440", "bodyText": "Do we need this comment?", "author": "MaryamZi", "createdAt": "2021-01-18T18:56:53Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/BLangNodeTransformer.java", "diffHunk": "@@ -4062,9 +4071,18 @@ private BLangMatchPattern transformMatchPattern(Node matchPattern) {\n             return bLangWildCardMatchPattern;\n         }\n \n+        if (kind == SyntaxKind.IDENTIFIER_TOKEN && ((IdentifierToken) matchPattern).text().equals(\"_\")) {\n+            // wildcard match", "originalCommit": "c0018fa8c13aec9a0833d86dfc486198bae7d511", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTkyMTk1Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r559921953", "bodyText": "Removed", "author": "KavinduZoysa", "createdAt": "2021-01-19T05:27:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTc1MDQ0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTc1Mjk2Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r559752966", "bodyText": "Shouldn't the type of the rest pattern var be a record of the rest of the types.\nFor example, in the following scenario, shouldn't b be true?\npublic function main() {\n    error x = error(\"err\", i = 1, j = 2, k = \"str\");\n\n    match x {\n        error(\"err\", i = 1, ...var rst) => {\n            boolean b = rst is record {|int j; string k;|};\n        }\n    }\n}", "author": "MaryamZi", "createdAt": "2021-01-18T19:03:44Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SemanticAnalyzer.java", "diffHunk": "@@ -2807,6 +2812,88 @@ public void visit(BLangCaptureBindingPattern captureBindingPattern) {\n         captureBindingPattern.declaredVars.put(name.value, captureBindingPattern.symbol);\n     }\n \n+    @Override\n+    public void visit(BLangErrorMatchPattern errorMatchPattern) {\n+        if (errorMatchPattern.errorTypeReference != null) {\n+            errorMatchPattern.type = symResolver.resolveTypeNode(errorMatchPattern.errorTypeReference, env);\n+        } else {\n+            errorMatchPattern.type = symTable.errorType;\n+        }\n+        errorMatchPattern.type = types.resolvePatternTypeFromMatchExpr(errorMatchPattern,\n+                    errorMatchPattern.matchExpr);\n+\n+        if (errorMatchPattern.errorMessageMatchPattern != null) {\n+            analyzeNode(errorMatchPattern.errorMessageMatchPattern, env);\n+            errorMatchPattern.declaredVars.putAll(errorMatchPattern.errorMessageMatchPattern.declaredVars);\n+        }\n+\n+        if (errorMatchPattern.errorCauseMatchPattern != null) {\n+            analyzeNode(errorMatchPattern.errorCauseMatchPattern, env);\n+            errorMatchPattern.declaredVars.putAll(errorMatchPattern.errorCauseMatchPattern.declaredVars);\n+        }\n+\n+        if (errorMatchPattern.errorFieldMatchPatterns != null) {\n+            analyzeNode(errorMatchPattern.errorFieldMatchPatterns, env);\n+            errorMatchPattern.declaredVars.putAll(errorMatchPattern.errorFieldMatchPatterns.declaredVars);\n+        }\n+    }\n+\n+    @Override\n+    public void visit(BLangSimpleMatchPattern simpleMatchPattern) {\n+        if (simpleMatchPattern.wildCardMatchPattern != null) {\n+            analyzeNode(simpleMatchPattern.wildCardMatchPattern, env);\n+            simpleMatchPattern.wildCardMatchPattern.isLastPattern = true;\n+            return;\n+        }\n+        if (simpleMatchPattern.constPattern != null) {\n+            analyzeNode(simpleMatchPattern.constPattern, env);\n+            return;\n+        }\n+        if (simpleMatchPattern.varVariableName != null) {\n+            analyzeNode(simpleMatchPattern.varVariableName, env);\n+            simpleMatchPattern.declaredVars.putAll(simpleMatchPattern.varVariableName.declaredVars);\n+        }\n+    }\n+\n+    @Override\n+    public void visit(BLangErrorMessageMatchPattern errorMessageMatchPattern) {\n+        BLangSimpleMatchPattern simpleMatchPattern = errorMessageMatchPattern.simpleMatchPattern;\n+        analyzeNode(simpleMatchPattern, env);\n+        errorMessageMatchPattern.declaredVars.putAll(simpleMatchPattern.declaredVars);\n+    }\n+\n+    @Override\n+    public void visit(BLangErrorCauseMatchPattern errorCauseMatchPattern) {\n+        if (errorCauseMatchPattern.simpleMatchPattern != null) {\n+            analyzeNode(errorCauseMatchPattern.simpleMatchPattern, env);\n+            errorCauseMatchPattern.declaredVars.putAll(errorCauseMatchPattern.simpleMatchPattern.declaredVars);\n+            return;\n+        }\n+        if (errorCauseMatchPattern.errorMatchPattern != null) {\n+            analyzeNode(errorCauseMatchPattern.errorMatchPattern, env);\n+            errorCauseMatchPattern.declaredVars.putAll(errorCauseMatchPattern.errorMatchPattern.declaredVars);\n+        }\n+    }\n+\n+    @Override\n+    public void visit(BLangErrorFieldMatchPatterns errorFieldMatchPatterns) {\n+        for (BLangNamedArgMatchPattern namedArgMatchPattern : errorFieldMatchPatterns.namedArgMatchPatterns) {\n+            analyzeNode(namedArgMatchPattern, env);\n+            errorFieldMatchPatterns.declaredVars.putAll(namedArgMatchPattern.declaredVars);\n+        }\n+        if (errorFieldMatchPatterns.restMatchPattern != null) {\n+            errorFieldMatchPatterns.restMatchPattern.type = new BMapType(TypeTags.MAP, symTable.anydataType, null);\n+            analyzeNode(errorFieldMatchPatterns.restMatchPattern, env);\n+            errorFieldMatchPatterns.declaredVars.putAll(errorFieldMatchPatterns.restMatchPattern.declaredVars);\n+        }", "originalCommit": "c0018fa8c13aec9a0833d86dfc486198bae7d511", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTkwMTIzMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r559901230", "bodyText": "Shouldn't we clone this?", "author": "MaryamZi", "createdAt": "2021-01-19T04:06:10Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/NodeCloner.java", "diffHunk": "@@ -770,6 +776,56 @@ public void visit(BLangRestMatchPattern source) {\n         clone.setIdentifier(source.getIdentifier());\n     }\n \n+    @Override\n+    public void visit(BLangErrorMatchPattern source) {\n+        BLangErrorMatchPattern clone = new BLangErrorMatchPattern();\n+        source.cloneRef = clone;\n+        clone.matchExpr = source.matchExpr;\n+        clone.errorMessageMatchPattern = source.errorMessageMatchPattern;\n+        clone.errorFieldMatchPatterns = source.errorFieldMatchPatterns;\n+        clone.errorCauseMatchPattern = source.errorCauseMatchPattern;\n+        clone.errorTypeReference = source.errorTypeReference;\n+    }\n+\n+    @Override\n+    public void visit(BLangErrorMessageMatchPattern source) {\n+        BLangErrorMessageMatchPattern clone = new BLangErrorMessageMatchPattern();\n+        source.cloneRef = clone;\n+        clone.simpleMatchPattern = source.simpleMatchPattern;\n+    }\n+\n+    @Override\n+    public void visit(BLangErrorCauseMatchPattern source) {\n+        BLangErrorCauseMatchPattern clone = new BLangErrorCauseMatchPattern();\n+        source.cloneRef = clone;\n+        clone.errorMatchPattern = source.errorMatchPattern;", "originalCommit": "c0018fa8c13aec9a0833d86dfc486198bae7d511", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTkzMDQzOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r559930438", "bodyText": "Fixed", "author": "KavinduZoysa", "createdAt": "2021-01-19T05:57:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTkwMTIzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTkwMzAxNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r559903014", "bodyText": "Shouldn't we check types instead?\nIf we have\ntype ErrorOne error<record {int code;}>;\ntype ErrorTwo error<record {int code;}>;\n\npublic function func(error err) {\n    match err {\n        error ErrorOne() => {\n        }\n        error ErrorTwo() => {\n        }\n    }\n}\nthe second pattern is unreachable, right?", "author": "MaryamZi", "createdAt": "2021-01-19T04:13:16Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java", "diffHunk": "@@ -906,11 +912,169 @@ private boolean checkSimilarMatchPatterns(BLangMatchPattern firstPattern, BLangM\n             case MAPPING_MATCH_PATTERN:\n                 return checkSimilarMappingMatchPattern((BLangMappingMatchPattern) firstPattern,\n                         (BLangMappingMatchPattern) secondPattern);\n+            case ERROR_MATCH_PATTERN:\n+                return checkSimilarErrorMatchPattern((BLangErrorMatchPattern) firstPattern,\n+                        (BLangErrorMatchPattern) secondPattern);\n             default:\n                 return false;\n         }\n     }\n \n+    private boolean checkSimilarErrorMatchPattern(BLangErrorMatchPattern firstErrorMatchPattern,\n+                                                  BLangErrorMatchPattern secondErrorMatchPattern) {\n+        if (!checkSimilarErrorTypeReference(firstErrorMatchPattern.errorTypeReference,\n+                secondErrorMatchPattern.errorTypeReference)) {\n+            return false;\n+        }\n+\n+        if (!checkSimilarErrorMessagePattern(firstErrorMatchPattern.errorMessageMatchPattern,\n+                secondErrorMatchPattern.errorMessageMatchPattern)) {\n+            return false;\n+        }\n+\n+        if (!checkSimilarErrorCauseMatchPattern(firstErrorMatchPattern.errorCauseMatchPattern,\n+                secondErrorMatchPattern.errorCauseMatchPattern)) {\n+            return false;\n+        }\n+\n+        if (!checkSimilarErrorFieldMatchPatterns(firstErrorMatchPattern.errorFieldMatchPatterns,\n+                secondErrorMatchPattern.errorFieldMatchPatterns)) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    private boolean checkSimilarErrorTypeReference(BLangUserDefinedType firstErrorTypeRef,\n+                                                   BLangUserDefinedType secondErrorTypeRef) {\n+        if ((firstErrorTypeRef != null && secondErrorTypeRef == null)\n+                || (firstErrorTypeRef == null && secondErrorTypeRef != null)) {\n+            return false;\n+        }\n+        if (firstErrorTypeRef == null) {\n+            return true;\n+        }\n+        return firstErrorTypeRef.typeName.value.equals(secondErrorTypeRef.typeName.value);", "originalCommit": "c0018fa8c13aec9a0833d86dfc486198bae7d511", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTkwNTUzMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r559905531", "bodyText": "Aren't the following two patterns similar patterns? The second is unreachable, right?\npublic function main() {\n    error x = error(\"err\", i = 1);\n\n    match x {\n        error (var y, i = 1) => {\n        }\n\n        error (var y, i = 1, ...var z) => {\n        }\n    }\n}", "author": "MaryamZi", "createdAt": "2021-01-19T04:24:06Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/CodeAnalyzer.java", "diffHunk": "@@ -906,11 +912,169 @@ private boolean checkSimilarMatchPatterns(BLangMatchPattern firstPattern, BLangM\n             case MAPPING_MATCH_PATTERN:\n                 return checkSimilarMappingMatchPattern((BLangMappingMatchPattern) firstPattern,\n                         (BLangMappingMatchPattern) secondPattern);\n+            case ERROR_MATCH_PATTERN:\n+                return checkSimilarErrorMatchPattern((BLangErrorMatchPattern) firstPattern,\n+                        (BLangErrorMatchPattern) secondPattern);\n             default:\n                 return false;\n         }\n     }\n \n+    private boolean checkSimilarErrorMatchPattern(BLangErrorMatchPattern firstErrorMatchPattern,\n+                                                  BLangErrorMatchPattern secondErrorMatchPattern) {\n+        if (!checkSimilarErrorTypeReference(firstErrorMatchPattern.errorTypeReference,\n+                secondErrorMatchPattern.errorTypeReference)) {\n+            return false;\n+        }\n+\n+        if (!checkSimilarErrorMessagePattern(firstErrorMatchPattern.errorMessageMatchPattern,\n+                secondErrorMatchPattern.errorMessageMatchPattern)) {\n+            return false;\n+        }\n+\n+        if (!checkSimilarErrorCauseMatchPattern(firstErrorMatchPattern.errorCauseMatchPattern,\n+                secondErrorMatchPattern.errorCauseMatchPattern)) {\n+            return false;\n+        }\n+\n+        if (!checkSimilarErrorFieldMatchPatterns(firstErrorMatchPattern.errorFieldMatchPatterns,\n+                secondErrorMatchPattern.errorFieldMatchPatterns)) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    private boolean checkSimilarErrorTypeReference(BLangUserDefinedType firstErrorTypeRef,\n+                                                   BLangUserDefinedType secondErrorTypeRef) {\n+        if ((firstErrorTypeRef != null && secondErrorTypeRef == null)\n+                || (firstErrorTypeRef == null && secondErrorTypeRef != null)) {\n+            return false;\n+        }\n+        if (firstErrorTypeRef == null) {\n+            return true;\n+        }\n+        return firstErrorTypeRef.typeName.value.equals(secondErrorTypeRef.typeName.value);\n+    }\n+\n+    private boolean checkSimilarErrorMessagePattern(BLangErrorMessageMatchPattern firstErrorMsgMatchPattern,\n+                                                    BLangErrorMessageMatchPattern secondErrorMsgMatchPattern) {\n+        if ((firstErrorMsgMatchPattern != null && secondErrorMsgMatchPattern == null)\n+                || (firstErrorMsgMatchPattern == null && secondErrorMsgMatchPattern != null)) {\n+            return false;\n+        }\n+        if (firstErrorMsgMatchPattern == null) {\n+            return true;\n+        }\n+        return checkSimilarSimpleMatchPattern(firstErrorMsgMatchPattern.simpleMatchPattern,\n+                secondErrorMsgMatchPattern.simpleMatchPattern);\n+    }\n+\n+    private boolean checkSimilarSimpleMatchPattern(BLangSimpleMatchPattern firstSimpleMatchPattern,\n+                                                   BLangSimpleMatchPattern secondSimpleMatchPattern) {\n+        if ((firstSimpleMatchPattern != null && secondSimpleMatchPattern == null)\n+                || (firstSimpleMatchPattern == null && secondSimpleMatchPattern != null)) {\n+            return false;\n+        }\n+        if (firstSimpleMatchPattern == null) {\n+            return true;\n+        }\n+        if (firstSimpleMatchPattern.constPattern != null && secondSimpleMatchPattern.constPattern != null) {\n+            if (!checkSimilarConstMatchPattern(firstSimpleMatchPattern.constPattern,\n+                    secondSimpleMatchPattern.constPattern)) {\n+                return false;\n+            }\n+        } else if (!(firstSimpleMatchPattern.constPattern == null && secondSimpleMatchPattern.constPattern == null)) {\n+            return false;\n+        }\n+\n+        if (firstSimpleMatchPattern.wildCardMatchPattern != null\n+                && secondSimpleMatchPattern.wildCardMatchPattern == null) {\n+            return false;\n+        }\n+        if (firstSimpleMatchPattern.wildCardMatchPattern == null\n+                && secondSimpleMatchPattern.wildCardMatchPattern != null) {\n+            return false;\n+        }\n+\n+        if (firstSimpleMatchPattern.varVariableName != null\n+                && secondSimpleMatchPattern.varVariableName == null) {\n+            return false;\n+        }\n+        if (firstSimpleMatchPattern.varVariableName == null\n+                && secondSimpleMatchPattern.varVariableName != null) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    private boolean checkSimilarErrorCauseMatchPattern(BLangErrorCauseMatchPattern firstErrorCauseMatchPattern,\n+                                                       BLangErrorCauseMatchPattern secondErrorCauseMatchPattern) {\n+        if ((firstErrorCauseMatchPattern != null && secondErrorCauseMatchPattern == null)\n+                || (firstErrorCauseMatchPattern == null && secondErrorCauseMatchPattern != null)) {\n+            return false;\n+        }\n+        if (firstErrorCauseMatchPattern == null) {\n+            return true;\n+        }\n+        if (!checkSimilarSimpleMatchPattern(firstErrorCauseMatchPattern.simpleMatchPattern,\n+                secondErrorCauseMatchPattern.simpleMatchPattern)) {\n+            return false;\n+        }\n+        return checkSimilarErrorMatchPattern(firstErrorCauseMatchPattern.errorMatchPattern,\n+                secondErrorCauseMatchPattern.errorMatchPattern);\n+    }\n+\n+    private boolean checkSimilarErrorFieldMatchPatterns(BLangErrorFieldMatchPatterns firstErrorFieldMatchPatterns,\n+                                                        BLangErrorFieldMatchPatterns secondErrorFieldMatchPatterns) {\n+        if ((firstErrorFieldMatchPatterns != null && secondErrorFieldMatchPatterns == null)\n+                || (firstErrorFieldMatchPatterns == null && secondErrorFieldMatchPatterns != null)) {\n+            return false;\n+        }\n+        if (firstErrorFieldMatchPatterns == null) {\n+            return true;\n+        }\n+        if (firstErrorFieldMatchPatterns.restMatchPattern != null\n+                && secondErrorFieldMatchPatterns.restMatchPattern == null) {\n+            return false;\n+        }\n+        if (firstErrorFieldMatchPatterns.restMatchPattern == null\n+                && secondErrorFieldMatchPatterns.restMatchPattern != null) {\n+            return false;\n+        }", "originalCommit": "c0018fa8c13aec9a0833d86dfc486198bae7d511", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTkwNjkxMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r559906910", "bodyText": "Shall we extract matchExpr.type and errorMatchPattern.type out to variables?", "author": "MaryamZi", "createdAt": "2021-01-19T04:29:52Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -395,16 +397,30 @@ BType resolvePatternTypeFromMatchExpr(BLangExpression matchExpr, BTupleType list\n         return symTable.noType;\n     }\n \n-    BType resolvePatternTypeFromMatchExpr(BLangExpression matchExpr, BLangExpression constPatternExpr) {\n+    public BType resolvePatternTypeFromMatchExpr(BLangErrorMatchPattern errorMatchPattern, BLangExpression matchExpr) {\n         if (matchExpr == null) {\n+            return errorMatchPattern.type;\n+        }\n+\n+        if (isAssignable(matchExpr.type, errorMatchPattern.type)) {", "originalCommit": "c0018fa8c13aec9a0833d86dfc486198bae7d511", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTkyMTkyNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26197#discussion_r559921925", "bodyText": "Fixed", "author": "KavinduZoysa", "createdAt": "2021-01-19T05:27:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTkwNjkxMA=="}], "type": "inlineReview"}, {"oid": "feaca421022ea2b840f8dfa1ca926746ac01c686", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/feaca421022ea2b840f8dfa1ca926746ac01c686", "message": "Add new nodes", "committedDate": "2021-01-19T05:26:37Z", "type": "commit"}, {"oid": "99694b514ee9fafa246a5bf8fae0faf65aa8d069", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/99694b514ee9fafa246a5bf8fae0faf65aa8d069", "message": "Change the transformer", "committedDate": "2021-01-19T05:26:37Z", "type": "commit"}, {"oid": "5196c1354762bdf5acc468a6d3d1ae16a5cb7533", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5196c1354762bdf5acc468a6d3d1ae16a5cb7533", "message": "Add compiler related changes", "committedDate": "2021-01-19T05:26:37Z", "type": "commit"}, {"oid": "adc3f9d6e70860d7718902011fbd1dfb526e9111", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/adc3f9d6e70860d7718902011fbd1dfb526e9111", "message": "Add tests", "committedDate": "2021-01-19T05:26:37Z", "type": "commit"}, {"oid": "2696d85c3265d75bb782d82a40584d402aed4754", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2696d85c3265d75bb782d82a40584d402aed4754", "message": "Fix failure tests", "committedDate": "2021-01-19T05:26:37Z", "type": "commit"}, {"oid": "78434ef1a89eb5fddfdd7b7c14f1cc9d7205ebf7", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/78434ef1a89eb5fddfdd7b7c14f1cc9d7205ebf7", "message": "Fix the suggestions", "committedDate": "2021-01-19T05:26:37Z", "type": "commit"}, {"oid": "2781eb3a92260b6895dd80a106bcf255d9fac403", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2781eb3a92260b6895dd80a106bcf255d9fac403", "message": "Refactor the code", "committedDate": "2021-01-19T05:26:37Z", "type": "commit"}, {"oid": "129f7ac8c263ca2c54ae19d1d2ac75ad6abfd46f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/129f7ac8c263ca2c54ae19d1d2ac75ad6abfd46f", "message": "Support for rest match pattern", "committedDate": "2021-01-19T05:26:37Z", "type": "commit"}, {"oid": "9def42fc52dc88ad4177131dfa718ab8f9393c1c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9def42fc52dc88ad4177131dfa718ab8f9393c1c", "message": "Add tests", "committedDate": "2021-01-19T05:26:37Z", "type": "commit"}, {"oid": "c058be7a0a012c5b1366f63887440de69f49d5db", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c058be7a0a012c5b1366f63887440de69f49d5db", "message": "Sync with master", "committedDate": "2021-01-19T05:26:37Z", "type": "commit"}, {"oid": "10293820c7a50636be688d3504f0958bdc2c945c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/10293820c7a50636be688d3504f0958bdc2c945c", "message": "Fix failure tests", "committedDate": "2021-01-19T05:26:37Z", "type": "commit"}, {"oid": "a727c9145b8f07c6a7e6cc797a2c5df7b3c9d6d9", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a727c9145b8f07c6a7e6cc797a2c5df7b3c9d6d9", "message": "Fix review suggestions", "committedDate": "2021-01-19T05:26:37Z", "type": "commit"}, {"oid": "bd47747f1f3a24ca40ac633800393eacf5aec69a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bd47747f1f3a24ca40ac633800393eacf5aec69a", "message": "Fix review suggestions", "committedDate": "2021-01-19T05:26:37Z", "type": "commit"}, {"oid": "a1dbab2319be35a2004c57b549fc0af0dd5bfc7a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a1dbab2319be35a2004c57b549fc0af0dd5bfc7a", "message": "Fix suggestions", "committedDate": "2021-01-19T05:26:37Z", "type": "forcePushed"}, {"oid": "d262cf8359935dd93813f72cc6a87cf62c6d0f07", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d262cf8359935dd93813f72cc6a87cf62c6d0f07", "message": "Fix suggestions", "committedDate": "2021-01-19T05:48:49Z", "type": "forcePushed"}, {"oid": "b77a2d14225496d99a7361530ca5be0e6975c18e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b77a2d14225496d99a7361530ca5be0e6975c18e", "message": "Fix suggestions", "committedDate": "2021-01-19T05:57:12Z", "type": "forcePushed"}, {"oid": "f0a11d6e9364abe16d4b0b6050b2308a35296a2a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f0a11d6e9364abe16d4b0b6050b2308a35296a2a", "message": "Fix suggestions", "committedDate": "2021-01-19T06:18:02Z", "type": "commit"}, {"oid": "f0a11d6e9364abe16d4b0b6050b2308a35296a2a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f0a11d6e9364abe16d4b0b6050b2308a35296a2a", "message": "Fix suggestions", "committedDate": "2021-01-19T06:18:02Z", "type": "forcePushed"}]}