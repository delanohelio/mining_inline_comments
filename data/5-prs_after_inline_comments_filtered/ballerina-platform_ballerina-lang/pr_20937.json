{"pr_number": 20937, "pr_title": "Support inferring types for mapping constructor expressions", "pr_createdAt": "2020-02-09T18:31:53Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/20937", "timeline": [{"oid": "e84b543a1cd067c62f27ae4a92150486326b016f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e84b543a1cd067c62f27ae4a92150486326b016f", "message": "Extract representative broad type identification to a separate method", "committedDate": "2020-01-29T15:26:47Z", "type": "commit"}, {"oid": "77b85118a7f5568f945a60a35f6c7e1a8ffb1aae", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/77b85118a7f5568f945a60a35f6c7e1a8ffb1aae", "message": "Allow mapping constr usage with any/anydata", "committedDate": "2020-01-30T06:24:37Z", "type": "commit"}, {"oid": "e9b65cde9e98b16780ac0b3e2e21980bcb218323", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e9b65cde9e98b16780ac0b3e2e21980bcb218323", "message": "Allow using var with a mapping constructor expr", "committedDate": "2020-01-30T17:13:11Z", "type": "commit"}, {"oid": "87db3e2cfc1b56272876f625b83ff9b74241d62d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/87db3e2cfc1b56272876f625b83ff9b74241d62d", "message": "Fix issue in ambiguous map type identification and add tests", "committedDate": "2020-01-31T04:18:40Z", "type": "commit"}, {"oid": "0248da141ead7f73845b31810f9dd845021e11cf", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0248da141ead7f73845b31810f9dd845021e11cf", "message": "Implement record type inf. logic for mapping-constr-expr", "committedDate": "2020-02-02T16:23:35Z", "type": "commit"}, {"oid": "3d4c6f3ebac242644e85ad1e34ae0f81545fe560", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3d4c6f3ebac242644e85ad1e34ae0f81545fe560", "message": "Merge branch 'fix-map-constr-inferring' of https://github.com/MaryamZi/ballerina into fix-mapping-constr-type-inferring", "committedDate": "2020-02-04T16:31:20Z", "type": "commit"}, {"oid": "b76536476ee4352aeca8f9e6226bfb37d33c518c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b76536476ee4352aeca8f9e6226bfb37d33c518c", "message": "Move out type def creation logic to a separate class", "committedDate": "2020-02-05T05:43:35Z", "type": "commit"}, {"oid": "7d4a0df24f546acb7417446ae54253ecd8261a83", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7d4a0df24f546acb7417446ae54253ecd8261a83", "message": "Fix literal keys not being considered for closed rec union compatability", "committedDate": "2020-02-05T09:12:59Z", "type": "commit"}, {"oid": "39cfb65b7c7601c7258e8e8633666226bb075d87", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/39cfb65b7c7601c7258e8e8633666226bb075d87", "message": "Merge branch 'fix-map-constr-inferring' of https://github.com/MaryamZi/ballerina into fix-mapping-constr-type-inferring", "committedDate": "2020-02-05T09:57:44Z", "type": "commit"}, {"oid": "ba43028a10d30490bf660eb08bdff1cb1cdeff04", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ba43028a10d30490bf660eb08bdff1cb1cdeff04", "message": "Merge branch 'fix-map-constr-inferring' of https://github.com/MaryamZi/ballerina into fix-mapping-constr-type-inferring", "committedDate": "2020-02-05T11:20:57Z", "type": "commit"}, {"oid": "9af86478a4d21521e60f6a85933fccf2c9d63e27", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9af86478a4d21521e60f6a85933fccf2c9d63e27", "message": "Merge branch 'master' of https://github.com/ballerina-lang/ballerina into fix-mapping-constr-type-inferring", "committedDate": "2020-02-07T16:25:26Z", "type": "commit"}, {"oid": "42f86b2ff25154f0652650d45f7007b98a735b1c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/42f86b2ff25154f0652650d45f7007b98a735b1c", "message": "Avoid duplicate logs when inferring type for invalid mapping-constr", "committedDate": "2020-02-10T08:53:13Z", "type": "commit"}, {"oid": "fe628eb8b2f79c8f7c92e2fd5b240ed59e87497a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fe628eb8b2f79c8f7c92e2fd5b240ed59e87497a", "message": "Merge branch 'master' of https://github.com/ballerina-lang/ballerina into fix-mapping-constr-type-inferring", "committedDate": "2020-02-11T04:03:52Z", "type": "commit"}, {"oid": "ad653c8a288a83240f30156e1f6d4b9f2c53a9a6", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ad653c8a288a83240f30156e1f6d4b9f2c53a9a6", "message": "Support inferring a record type in a select clause", "committedDate": "2020-02-11T11:29:01Z", "type": "commit"}, {"oid": "ad653c8a288a83240f30156e1f6d4b9f2c53a9a6", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ad653c8a288a83240f30156e1f6d4b9f2c53a9a6", "message": "Support inferring a record type in a select clause", "committedDate": "2020-02-11T11:29:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODAzNjMxNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20937#discussion_r378036314", "bodyText": "Maybe a function name like addTypeDefinition is more suitable here?", "author": "KRVPerera", "createdAt": "2020-02-12T04:32:50Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/util/TypeDefBuilderHelper.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.util;\n+\n+import org.ballerinalang.model.TreeBuilder;\n+import org.ballerinalang.model.elements.Flag;\n+import org.ballerinalang.model.elements.PackageID;\n+import org.wso2.ballerinalang.compiler.desugar.ASTBuilderUtil;\n+import org.wso2.ballerinalang.compiler.semantics.analyzer.TaintAnalyzer;\n+import org.wso2.ballerinalang.compiler.semantics.model.Scope;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolEnv;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolTable;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BAttachedFunction;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BInvokableTypeSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BRecordTypeSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BTypeSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BVarSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.SymTag;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.Symbols;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.TaintRecord;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BField;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BInvokableType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BRecordType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.tree.BLangFunction;\n+import org.wso2.ballerinalang.compiler.tree.BLangSimpleVariable;\n+import org.wso2.ballerinalang.compiler.tree.BLangTypeDefinition;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangRecordTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangStructureTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangType;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+import org.wso2.ballerinalang.util.Flags;\n+\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+/**\n+ * Helper class with util methods to create type definitions.\n+ *\n+ * @since 1.2.0\n+ */\n+public class TypeDefBuilderHelper {\n+\n+    public static BLangRecordTypeNode createRecordTypeNode(BRecordType recordType, PackageID packageID,\n+                                                           SymbolTable symTable, DiagnosticPos pos) {\n+        List<BLangSimpleVariable> fieldList = new ArrayList<>();\n+        for (BField field : recordType.fields) {\n+            BVarSymbol symbol = field.symbol;\n+            if (symbol == null) {\n+                symbol = new BVarSymbol(Flags.PUBLIC, field.name, packageID, symTable.pureType, null);\n+            }\n+\n+            BLangSimpleVariable fieldVar = ASTBuilderUtil.createVariable(field.pos, symbol.name.value, field.type,\n+                                                                         null, symbol);\n+            fieldList.add(fieldVar);\n+        }\n+        return createRecordTypeNode(fieldList, recordType, pos);\n+    }\n+\n+    public static BLangRecordTypeNode createRecordTypeNode(List<BLangSimpleVariable> typeDefFields,\n+                                                           BRecordType recordType, DiagnosticPos pos) {\n+        BLangRecordTypeNode recordTypeNode = (BLangRecordTypeNode) TreeBuilder.createRecordTypeNode();\n+        recordTypeNode.type = recordType;\n+        recordTypeNode.fields = typeDefFields;\n+        recordTypeNode.symbol = recordType.tsymbol;\n+        recordTypeNode.pos = pos;\n+\n+        return recordTypeNode;\n+    }\n+\n+    public static BLangFunction createInitFunctionForRecordType(BLangRecordTypeNode recordTypeNode, SymbolEnv env,\n+                                                                Names names, SymbolTable symTable) {\n+        BLangFunction initFunction = createInitFunctionForStructureType(recordTypeNode, env,\n+                                                                        Names.INIT_FUNCTION_SUFFIX, names, symTable);\n+        BRecordTypeSymbol recordSymbol = ((BRecordTypeSymbol) recordTypeNode.type.tsymbol);\n+        recordSymbol.initializerFunc = new BAttachedFunction(initFunction.symbol.name, initFunction.symbol,\n+                                                             (BInvokableType) initFunction.type);\n+        recordTypeNode.initFunction = initFunction;\n+        recordSymbol.scope.define(recordSymbol.initializerFunc.symbol.name, recordSymbol.initializerFunc.symbol);\n+        return initFunction;\n+    }\n+\n+    public static BLangFunction createInitFunctionForStructureType(BLangStructureTypeNode structureTypeNode,\n+                                                                   SymbolEnv env, Name suffix, Names names,\n+                                                                   SymbolTable symTable) {\n+        String structTypeName = structureTypeNode.type.tsymbol.name.value;\n+        BLangFunction initFunction = ASTBuilderUtil\n+                .createInitFunctionWithNilReturn(structureTypeNode.pos, structTypeName, suffix);\n+\n+        // Create the receiver and add receiver details to the node\n+        initFunction.receiver = ASTBuilderUtil.createReceiver(structureTypeNode.pos, structureTypeNode.type);\n+        BVarSymbol receiverSymbol = new BVarSymbol(Flags.asMask(EnumSet.noneOf(Flag.class)),\n+                                                   names.fromIdNode(initFunction.receiver.name),\n+                                                   env.enclPkg.symbol.pkgID, structureTypeNode.type, null);\n+        initFunction.receiver.symbol = receiverSymbol;\n+        initFunction.attachedFunction = true;\n+        initFunction.flagSet.add(Flag.ATTACHED);\n+\n+        // Create the function type\n+        initFunction.type = new BInvokableType(new ArrayList<>(), symTable.nilType, null);\n+\n+        // Create the function symbol\n+        Name funcSymbolName = names.fromString(Symbols.getAttachedFuncSymbolName(structTypeName, suffix.value));\n+        initFunction.symbol = Symbols\n+                .createFunctionSymbol(Flags.asMask(initFunction.flagSet), funcSymbolName, env.enclPkg.symbol.pkgID,\n+                                      initFunction.type, structureTypeNode.symbol, initFunction.body != null);\n+        initFunction.symbol.scope = new Scope(initFunction.symbol);\n+        initFunction.symbol.scope.define(receiverSymbol.name, receiverSymbol);\n+        initFunction.symbol.receiverSymbol = receiverSymbol;\n+        initFunction.name = ASTBuilderUtil.createIdentifier(structureTypeNode.pos, funcSymbolName.value);\n+\n+        // Create the function type symbol\n+        BInvokableTypeSymbol tsymbol = Symbols.createInvokableTypeSymbol(SymTag.FUNCTION_TYPE,\n+                                                                         initFunction.symbol.flags,\n+                                                                         env.enclPkg.packageID, initFunction.type,\n+                                                                         initFunction.symbol);\n+        tsymbol.params = initFunction.symbol.params;\n+        tsymbol.restParam = initFunction.symbol.restParam;\n+        tsymbol.returnType = initFunction.symbol.retType;\n+        initFunction.type.tsymbol = tsymbol;\n+\n+        receiverSymbol.owner = initFunction.symbol;\n+\n+        // Add return type as nil to the symbol\n+        initFunction.symbol.retType = symTable.nilType;\n+\n+        // Set the taint information to the constructed init function\n+        initFunction.symbol.taintTable = new HashMap<>();\n+        TaintRecord taintRecord = new TaintRecord(TaintRecord.TaintedStatus.UNTAINTED, new ArrayList<>());\n+        initFunction.symbol.taintTable.put(TaintAnalyzer.ALL_UNTAINTED_TABLE_ENTRY_INDEX, taintRecord);\n+\n+        return initFunction;\n+    }\n+\n+    public static void createTypeDefinition(BType type, BTypeSymbol symbol, BLangType typeNode, SymbolEnv env) {", "originalCommit": "ad653c8a288a83240f30156e1f6d4b9f2c53a9a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0MTM5OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20937#discussion_r378041399", "bodyText": "Looking at the algorithm I think instead of an array list this could be HashSet. Feel like we are iterating over possibleTypes several times for searching. For loop and contains.", "author": "KRVPerera", "createdAt": "2020-02-12T05:00:04Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -1004,31 +1000,66 @@ private void reportMissingRecordFieldDiagnostics(List<RecordLiteralNode.RecordFi\n         if (bType.tag == TypeTags.UNION) {\n             Set<BType> expTypes = ((BUnionType) bType).getMemberTypes();\n \n-            List<BType> possibleTypes =\n-                    expTypes.stream()\n-                            .filter(type -> type.tag == TypeTags.MAP ||\n-                                    (type.tag == TypeTags.RECORD &&\n-                                            (!((BRecordType) type).sealed ||\n-                                                    isCompatibleClosedRecordLiteral((BRecordType) type,\n-                                                            recordLiteral))))\n-                            .collect(Collectors.toList());\n+            List<BType> possibleTypes = new ArrayList<>();", "originalCommit": "ad653c8a288a83240f30156e1f6d4b9f2c53a9a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA2NDMzNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20937#discussion_r378064337", "bodyText": "IMO, possible types will often have only around 2-3 types. Given that, I'm wondering if there'll be a significant gain switching to a set?", "author": "MaryamZi", "createdAt": "2020-02-12T06:43:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0MTM5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0MzIzNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20937#discussion_r378043235", "bodyText": "Should the second loop start from the t1+1 item to reduce duplicate isAssignable calls?", "author": "KRVPerera", "createdAt": "2020-02-12T05:09:59Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -4766,4 +4807,141 @@ private boolean isConst(BLangExpression expression) {\n     private Name getCurrentCompUnit(BLangNode node) {\n         return names.fromString(node.pos.getSource().getCompilationUnitName());\n     }\n+\n+    private BType getRepresentativeBroadType(List<BLangExpression> exprs) {\n+        LinkedHashSet<BType> narrowTypes = new LinkedHashSet<>();\n+        LinkedHashSet<BType> broadTypesSet = new LinkedHashSet<>();\n+        BType[] inferredTypes = checkExprList(exprs, env);\n+        for (BType type : inferredTypes) {\n+            if (type.tag == TypeTags.SEMANTIC_ERROR) {\n+                return type;\n+            }\n+\n+            if (narrowTypes.stream().noneMatch(nType -> types.isSameType(type, nType))) {\n+                narrowTypes.add(type);\n+            }\n+        }\n+        BType broadType;\n+        for (BType t1 : narrowTypes) {\n+            broadType = t1;\n+            for (BType t2 : narrowTypes) {", "originalCommit": "ad653c8a288a83240f30156e1f6d4b9f2c53a9a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY1MDY1OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20937#discussion_r378650659", "bodyText": "I've updated the getRepresentativeBroadType() logic a bit with ddbbe63. Those changes should address these concerns.", "author": "MaryamZi", "createdAt": "2020-02-13T04:54:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0MzIzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0NDg2Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20937#discussion_r378044866", "bodyText": "Can we combine this for loop with below double for loops? Something like\ntypes.isSameType(t1, t2) --> continue:;\nt1.tag == TypeTags.SEMANTIC_ERROR) --> continue;\nt2.tag == TypeTags.SEMANTIC_ERROR --> continue;", "author": "KRVPerera", "createdAt": "2020-02-12T05:18:55Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -4766,4 +4807,141 @@ private boolean isConst(BLangExpression expression) {\n     private Name getCurrentCompUnit(BLangNode node) {\n         return names.fromString(node.pos.getSource().getCompilationUnitName());\n     }\n+\n+    private BType getRepresentativeBroadType(List<BLangExpression> exprs) {\n+        LinkedHashSet<BType> narrowTypes = new LinkedHashSet<>();\n+        LinkedHashSet<BType> broadTypesSet = new LinkedHashSet<>();\n+        BType[] inferredTypes = checkExprList(exprs, env);\n+        for (BType type : inferredTypes) {\n+            if (type.tag == TypeTags.SEMANTIC_ERROR) {\n+                return type;\n+            }\n+\n+            if (narrowTypes.stream().noneMatch(nType -> types.isSameType(type, nType))) {", "originalCommit": "ad653c8a288a83240f30156e1f6d4b9f2c53a9a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a393f3692ab87e349d7e175c20d970085e7b029a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a393f3692ab87e349d7e175c20d970085e7b029a", "message": "Address review suggestions", "committedDate": "2020-02-12T09:11:32Z", "type": "commit"}, {"oid": "ddbbe63c79182ad2ebb8bc31f2cee8e28c2b0125", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ddbbe63c79182ad2ebb8bc31f2cee8e28c2b0125", "message": "Refactor broad type extraction method and add a map test", "committedDate": "2020-02-12T17:36:44Z", "type": "commit"}]}