{"pr_number": 23479, "pr_title": "Add maping-binding-pattern support to Typed Binding Pattern", "pr_createdAt": "2020-05-25T11:46:42Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479", "timeline": [{"oid": "13e1e3aceda16e98d0c8c8d499001199c2c863bc", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/13e1e3aceda16e98d0c8c8d499001199c2c863bc", "message": "Add maping-binding-pattern support", "committedDate": "2020-05-25T11:35:02Z", "type": "commit"}, {"oid": "4c1b83eed0c1630c2a956072d78864a2b4332a76", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4c1b83eed0c1630c2a956072d78864a2b4332a76", "message": "Refactor Code", "committedDate": "2020-05-25T12:18:26Z", "type": "commit"}, {"oid": "f9df7de6510c02e8190e436e1ffef38f016581cc", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f9df7de6510c02e8190e436e1ffef38f016581cc", "message": "Refactor code", "committedDate": "2020-05-25T12:22:57Z", "type": "commit"}, {"oid": "a9e616c312e66de69a60a209f2af8be80c64dd5c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a9e616c312e66de69a60a209f2af8be80c64dd5c", "message": "Fix recovery for mappingbindingpattern", "committedDate": "2020-05-26T05:49:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MDcxNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r430840714", "bodyText": "Can we get rid of this remove operation? Is it possible to avoid adding, rather than removing", "author": "SupunS", "createdAt": "2020-05-27T03:44:26Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10208,6 +10212,149 @@ private Boolean isFollowTypedBindingPattern(SyntaxKind tokenKind) {\n         }\n     }\n \n+    /**\n+     * Parse mapping-binding-patterns.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPattern() {\n+        startContext(ParserRuleContext.MAPPING_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBrace = parseOpenBrace();\n+\n+        STNode mappingBindingPatternMember = parseMappingBindingPatternMember();\n+        bindingPatterns.add(mappingBindingPatternMember);\n+\n+        // parsing the main chunck of mapping-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode mappingBindingPatternRhs = null;\n+        while (!isEndOfMappingBindingPattern(token.kind) &&\n+                mappingBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            mappingBindingPatternRhs = parseMappingBindingpatternRhs(token.kind);\n+            if (mappingBindingPatternRhs == null) {\n+                break;\n+            }\n+\n+            bindingPatterns.add(mappingBindingPatternRhs);\n+            mappingBindingPatternMember = parseMappingBindingPatternMember();\n+            bindingPatterns.add(mappingBindingPatternMember);\n+            token = peek();\n+        }\n+\n+        STNode closeBrace = parseCloseBrace();\n+\n+        // seperating out the rest-binding-pattern\n+        STNode restBindingPattern;\n+        if (mappingBindingPatternMember.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(bindingPatterns.size() - 1);", "originalCommit": "a9e616c312e66de69a60a209f2af8be80c64dd5c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MTIyMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r430841223", "bodyText": "Should this be moved inside the loop?\nAccording to the grammar, list can be empty too", "author": "SupunS", "createdAt": "2020-05-27T03:46:37Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10208,6 +10212,149 @@ private Boolean isFollowTypedBindingPattern(SyntaxKind tokenKind) {\n         }\n     }\n \n+    /**\n+     * Parse mapping-binding-patterns.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPattern() {\n+        startContext(ParserRuleContext.MAPPING_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBrace = parseOpenBrace();\n+\n+        STNode mappingBindingPatternMember = parseMappingBindingPatternMember();\n+        bindingPatterns.add(mappingBindingPatternMember);", "originalCommit": "a9e616c312e66de69a60a209f2af8be80c64dd5c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MjA3MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r430842071", "bodyText": "since what this method does is parsing the next token followed by the member, how about parseMappingBindingPatternMemberEnd for method name?", "author": "SupunS", "createdAt": "2020-05-27T03:50:26Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10208,6 +10212,149 @@ private Boolean isFollowTypedBindingPattern(SyntaxKind tokenKind) {\n         }\n     }\n \n+    /**\n+     * Parse mapping-binding-patterns.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPattern() {\n+        startContext(ParserRuleContext.MAPPING_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBrace = parseOpenBrace();\n+\n+        STNode mappingBindingPatternMember = parseMappingBindingPatternMember();\n+        bindingPatterns.add(mappingBindingPatternMember);\n+\n+        // parsing the main chunck of mapping-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode mappingBindingPatternRhs = null;\n+        while (!isEndOfMappingBindingPattern(token.kind) &&\n+                mappingBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            mappingBindingPatternRhs = parseMappingBindingpatternRhs(token.kind);\n+            if (mappingBindingPatternRhs == null) {\n+                break;\n+            }\n+\n+            bindingPatterns.add(mappingBindingPatternRhs);\n+            mappingBindingPatternMember = parseMappingBindingPatternMember();\n+            bindingPatterns.add(mappingBindingPatternMember);\n+            token = peek();\n+        }\n+\n+        STNode closeBrace = parseCloseBrace();\n+\n+        // seperating out the rest-binding-pattern\n+        STNode restBindingPattern;\n+        if (mappingBindingPatternMember.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(bindingPatterns.size() - 1);\n+        } else {\n+            restBindingPattern = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createMappingBindingPatternNode(openBrace, bindingPatternsNode, restBindingPattern,\n+                closeBrace);\n+    }\n+\n+    /**\n+     * Parse mapping-binding-pattern entry.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPatternMember() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseFieldBindingPattern();\n+        }\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs() {\n+        return parseMappingBindingpatternRhs(peek().kind);\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs(SyntaxKind nextTokenKind) {", "originalCommit": "a9e616c312e66de69a60a209f2af8be80c64dd5c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MjE0MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r430842140", "bodyText": "MAPPING_BINDING_PATTERN_MEMBER_END", "author": "SupunS", "createdAt": "2020-05-27T03:50:46Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10208,6 +10212,149 @@ private Boolean isFollowTypedBindingPattern(SyntaxKind tokenKind) {\n         }\n     }\n \n+    /**\n+     * Parse mapping-binding-patterns.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPattern() {\n+        startContext(ParserRuleContext.MAPPING_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBrace = parseOpenBrace();\n+\n+        STNode mappingBindingPatternMember = parseMappingBindingPatternMember();\n+        bindingPatterns.add(mappingBindingPatternMember);\n+\n+        // parsing the main chunck of mapping-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode mappingBindingPatternRhs = null;\n+        while (!isEndOfMappingBindingPattern(token.kind) &&\n+                mappingBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            mappingBindingPatternRhs = parseMappingBindingpatternRhs(token.kind);\n+            if (mappingBindingPatternRhs == null) {\n+                break;\n+            }\n+\n+            bindingPatterns.add(mappingBindingPatternRhs);\n+            mappingBindingPatternMember = parseMappingBindingPatternMember();\n+            bindingPatterns.add(mappingBindingPatternMember);\n+            token = peek();\n+        }\n+\n+        STNode closeBrace = parseCloseBrace();\n+\n+        // seperating out the rest-binding-pattern\n+        STNode restBindingPattern;\n+        if (mappingBindingPatternMember.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(bindingPatterns.size() - 1);\n+        } else {\n+            restBindingPattern = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createMappingBindingPatternNode(openBrace, bindingPatternsNode, restBindingPattern,\n+                closeBrace);\n+    }\n+\n+    /**\n+     * Parse mapping-binding-pattern entry.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPatternMember() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseFieldBindingPattern();\n+        }\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs() {\n+        return parseMappingBindingpatternRhs(peek().kind);\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case COMMA_TOKEN:\n+                return parseComma();\n+            case CLOSE_BRACE_TOKEN:\n+                return null;\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.MAPPING_BINDING_PATTERN_END_OR_CONTINUE);", "originalCommit": "a9e616c312e66de69a60a209f2af8be80c64dd5c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MjY4NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r430842684", "bodyText": "Should only keep CLOSE_BRACE_TOKEN and EOF_TOKEN and remove others. Because only these two are the ones that we can treat as the 'end' for sure. Anything else should go to recovery.", "author": "SupunS", "createdAt": "2020-05-27T03:53:12Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10208,6 +10212,149 @@ private Boolean isFollowTypedBindingPattern(SyntaxKind tokenKind) {\n         }\n     }\n \n+    /**\n+     * Parse mapping-binding-patterns.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPattern() {\n+        startContext(ParserRuleContext.MAPPING_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBrace = parseOpenBrace();\n+\n+        STNode mappingBindingPatternMember = parseMappingBindingPatternMember();\n+        bindingPatterns.add(mappingBindingPatternMember);\n+\n+        // parsing the main chunck of mapping-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode mappingBindingPatternRhs = null;\n+        while (!isEndOfMappingBindingPattern(token.kind) &&\n+                mappingBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            mappingBindingPatternRhs = parseMappingBindingpatternRhs(token.kind);\n+            if (mappingBindingPatternRhs == null) {\n+                break;\n+            }\n+\n+            bindingPatterns.add(mappingBindingPatternRhs);\n+            mappingBindingPatternMember = parseMappingBindingPatternMember();\n+            bindingPatterns.add(mappingBindingPatternMember);\n+            token = peek();\n+        }\n+\n+        STNode closeBrace = parseCloseBrace();\n+\n+        // seperating out the rest-binding-pattern\n+        STNode restBindingPattern;\n+        if (mappingBindingPatternMember.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(bindingPatterns.size() - 1);\n+        } else {\n+            restBindingPattern = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createMappingBindingPatternNode(openBrace, bindingPatternsNode, restBindingPattern,\n+                closeBrace);\n+    }\n+\n+    /**\n+     * Parse mapping-binding-pattern entry.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPatternMember() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseFieldBindingPattern();\n+        }\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs() {\n+        return parseMappingBindingpatternRhs(peek().kind);\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case COMMA_TOKEN:\n+                return parseComma();\n+            case CLOSE_BRACE_TOKEN:\n+                return null;\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.MAPPING_BINDING_PATTERN_END_OR_CONTINUE);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseMappingBindingpatternRhs(solution.tokenKind);\n+        }\n+    }\n+\n+    /**\n+     * Parse field-binding-pattern.\n+     *\n+     * field-binding-pattern := field-name : binding-pattern | varname\n+     *\n+     * @return field-binding-pattern node\n+     */\n+    private STNode parseFieldBindingPattern() {\n+        startContext(ParserRuleContext.FIELD_BINDING_PATTERN);\n+        STNode fieldName = parseVariableName();\n+        STNode colon = STNodeFactory.createEmptyNode();\n+        STNode bindingPattern = STNodeFactory.createEmptyNode();\n+\n+        if (!isEndOfFieldBindingPattern(peek().kind)) {\n+            colon = parseColon();\n+            bindingPattern = parseBindingPattern();\n+        }\n+        endContext();\n+        return STNodeFactory.createFieldBindingPatternNode(fieldName,\n+                colon,\n+                bindingPattern);\n+    }\n+\n+    private boolean isEndOfMappingBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACE_TOKEN:\n+            case EOF_TOKEN:", "originalCommit": "a9e616c312e66de69a60a209f2af8be80c64dd5c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk1NDAxNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r430954014", "bodyText": "all keywords that follow a typed binding pattern should also be treated as end for sure right?", "author": "m36dot", "createdAt": "2020-05-27T08:43:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MjY4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MjkxMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r430842913", "bodyText": "replace with a switch case.", "author": "SupunS", "createdAt": "2020-05-27T03:54:24Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10208,6 +10212,149 @@ private Boolean isFollowTypedBindingPattern(SyntaxKind tokenKind) {\n         }\n     }\n \n+    /**\n+     * Parse mapping-binding-patterns.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPattern() {\n+        startContext(ParserRuleContext.MAPPING_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBrace = parseOpenBrace();\n+\n+        STNode mappingBindingPatternMember = parseMappingBindingPatternMember();\n+        bindingPatterns.add(mappingBindingPatternMember);\n+\n+        // parsing the main chunck of mapping-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode mappingBindingPatternRhs = null;\n+        while (!isEndOfMappingBindingPattern(token.kind) &&\n+                mappingBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            mappingBindingPatternRhs = parseMappingBindingpatternRhs(token.kind);\n+            if (mappingBindingPatternRhs == null) {\n+                break;\n+            }\n+\n+            bindingPatterns.add(mappingBindingPatternRhs);\n+            mappingBindingPatternMember = parseMappingBindingPatternMember();\n+            bindingPatterns.add(mappingBindingPatternMember);\n+            token = peek();\n+        }\n+\n+        STNode closeBrace = parseCloseBrace();\n+\n+        // seperating out the rest-binding-pattern\n+        STNode restBindingPattern;\n+        if (mappingBindingPatternMember.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(bindingPatterns.size() - 1);\n+        } else {\n+            restBindingPattern = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createMappingBindingPatternNode(openBrace, bindingPatternsNode, restBindingPattern,\n+                closeBrace);\n+    }\n+\n+    /**\n+     * Parse mapping-binding-pattern entry.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPatternMember() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseFieldBindingPattern();\n+        }\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs() {\n+        return parseMappingBindingpatternRhs(peek().kind);\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case COMMA_TOKEN:\n+                return parseComma();\n+            case CLOSE_BRACE_TOKEN:\n+                return null;\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.MAPPING_BINDING_PATTERN_END_OR_CONTINUE);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseMappingBindingpatternRhs(solution.tokenKind);\n+        }\n+    }\n+\n+    /**\n+     * Parse field-binding-pattern.\n+     *\n+     * field-binding-pattern := field-name : binding-pattern | varname\n+     *\n+     * @return field-binding-pattern node\n+     */\n+    private STNode parseFieldBindingPattern() {\n+        startContext(ParserRuleContext.FIELD_BINDING_PATTERN);\n+        STNode fieldName = parseVariableName();\n+        STNode colon = STNodeFactory.createEmptyNode();\n+        STNode bindingPattern = STNodeFactory.createEmptyNode();\n+\n+        if (!isEndOfFieldBindingPattern(peek().kind)) {\n+            colon = parseColon();\n+            bindingPattern = parseBindingPattern();\n+        }\n+        endContext();\n+        return STNodeFactory.createFieldBindingPatternNode(fieldName,\n+                colon,\n+                bindingPattern);\n+    }\n+\n+    private boolean isEndOfMappingBindingPattern(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case IN_KEYWORD:\n+            case CLOSE_BRACE_TOKEN:\n+            case EOF_TOKEN:\n+            case EQUAL_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean isEndOfFieldBindingPattern(SyntaxKind nextTokenKind) {\n+        if (isEndOfMappingBindingPattern(nextTokenKind) ||", "originalCommit": "a9e616c312e66de69a60a209f2af8be80c64dd5c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk2MzcyMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r430963723", "bodyText": "you can't have method calls in switch case right?", "author": "m36dot", "createdAt": "2020-05-27T08:58:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MjkxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAyMzYzMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r431023633", "bodyText": "I meant, we can have all cases inside the switch case. no need of a func-call.\nIts better in-terms of performance.", "author": "SupunS", "createdAt": "2020-05-27T10:41:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MjkxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0Mzk4Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r430843983", "bodyText": "Can we live without starting a context?", "author": "SupunS", "createdAt": "2020-05-27T03:59:15Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10208,6 +10212,149 @@ private Boolean isFollowTypedBindingPattern(SyntaxKind tokenKind) {\n         }\n     }\n \n+    /**\n+     * Parse mapping-binding-patterns.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPattern() {\n+        startContext(ParserRuleContext.MAPPING_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBrace = parseOpenBrace();\n+\n+        STNode mappingBindingPatternMember = parseMappingBindingPatternMember();\n+        bindingPatterns.add(mappingBindingPatternMember);\n+\n+        // parsing the main chunck of mapping-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode mappingBindingPatternRhs = null;\n+        while (!isEndOfMappingBindingPattern(token.kind) &&\n+                mappingBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            mappingBindingPatternRhs = parseMappingBindingpatternRhs(token.kind);\n+            if (mappingBindingPatternRhs == null) {\n+                break;\n+            }\n+\n+            bindingPatterns.add(mappingBindingPatternRhs);\n+            mappingBindingPatternMember = parseMappingBindingPatternMember();\n+            bindingPatterns.add(mappingBindingPatternMember);\n+            token = peek();\n+        }\n+\n+        STNode closeBrace = parseCloseBrace();\n+\n+        // seperating out the rest-binding-pattern\n+        STNode restBindingPattern;\n+        if (mappingBindingPatternMember.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(bindingPatterns.size() - 1);\n+        } else {\n+            restBindingPattern = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createMappingBindingPatternNode(openBrace, bindingPatternsNode, restBindingPattern,\n+                closeBrace);\n+    }\n+\n+    /**\n+     * Parse mapping-binding-pattern entry.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPatternMember() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseFieldBindingPattern();\n+        }\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs() {\n+        return parseMappingBindingpatternRhs(peek().kind);\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case COMMA_TOKEN:\n+                return parseComma();\n+            case CLOSE_BRACE_TOKEN:\n+                return null;\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.MAPPING_BINDING_PATTERN_END_OR_CONTINUE);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseMappingBindingpatternRhs(solution.tokenKind);\n+        }\n+    }\n+\n+    /**\n+     * Parse field-binding-pattern.\n+     *\n+     * field-binding-pattern := field-name : binding-pattern | varname\n+     *\n+     * @return field-binding-pattern node\n+     */\n+    private STNode parseFieldBindingPattern() {\n+        startContext(ParserRuleContext.FIELD_BINDING_PATTERN);", "originalCommit": "a9e616c312e66de69a60a209f2af8be80c64dd5c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg2MjgwMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r430862802", "bodyText": "hmm, should be possible but its much neater I think to start a context as I can easily recover fieldname : binding-pattern | fieldname", "author": "m36dot", "createdAt": "2020-05-27T05:20:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0Mzk4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAyNDg0Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r431024847", "bodyText": "Again, this would be solved if you use filed-name, in place of var-name, when parsing the first identifier.", "author": "SupunS", "createdAt": "2020-05-27T10:43:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0Mzk4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0NDIzNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r430844237", "bodyText": "MAPPING_BINDING_PATTERN_MEMBER", "author": "SupunS", "createdAt": "2020-05-27T04:00:20Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -397,14 +397,24 @@\n             { ParserRuleContext.CLOSE_PARENTHESIS, ParserRuleContext.TYPE_DESCRIPTOR };\n \n     private static final ParserRuleContext[] BINDING_PATTERN =\n-            { ParserRuleContext.CAPTURE_BINDING_PATTERN, ParserRuleContext.LIST_BINDING_PATTERN };\n+            { ParserRuleContext.CAPTURE_BINDING_PATTERN, ParserRuleContext.LIST_BINDING_PATTERN,\n+                    ParserRuleContext.MAPPING_BINDING_PATTERN};\n \n     private static final ParserRuleContext[] LIST_BINDING_PATTERN_CONTENTS =\n             { ParserRuleContext.REST_BINDING_PATTERN, ParserRuleContext.BINDING_PATTERN };\n \n+    private static final ParserRuleContext[] MAPPING_BINDING_PATTERN_CONTENTS =", "originalCommit": "a9e616c312e66de69a60a209f2af8be80c64dd5c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg1Njc3MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r430856770", "bodyText": "Next rule should be \"colon, comma, or close bracket\"", "author": "SupunS", "createdAt": "2020-05-27T04:56:28Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -3049,7 +3096,11 @@ private ParserRuleContext getNextRuleForVarName() {\n             return getNextRuleForTypedBindingPattern();\n         } else if (parentCtx == ParserRuleContext.REST_BINDING_PATTERN) {\n             return getNextRuleForTypedBindingPattern();\n-        } else if (isStatement(parentCtx) || parentCtx == ParserRuleContext.LISTENER_DECL ||\n+        } else if (parentCtx == ParserRuleContext.FIELD_BINDING_PATTERN) {\n+            return getNextRuleForTypedBindingPattern();", "originalCommit": "a9e616c312e66de69a60a209f2af8be80c64dd5c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg2MjQzNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r430862437", "bodyText": "thats what that method returns", "author": "m36dot", "createdAt": "2020-05-27T05:19:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg1Njc3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAxNzcwNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r431017707", "bodyText": "But thats a bit conceptually wrong. Here its like saying next rule for the type-binding pattern can be a colon. But no typed-binding pattern can be followed by a colon.\nI think the root cause is using var-name to represent field-name. Both of them are identifiers, but in different contexts.", "author": "SupunS", "createdAt": "2020-05-27T10:30:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg1Njc3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg1OTQzMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23479#discussion_r430859430", "bodyText": "Since this can be either field-name or variable-name, we shouldn't use parseVariableName().\nPlease refer to parseWaitField() and parseReceiveField(), those has a similar scenarios.", "author": "SupunS", "createdAt": "2020-05-27T05:07:23Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -10208,6 +10212,149 @@ private Boolean isFollowTypedBindingPattern(SyntaxKind tokenKind) {\n         }\n     }\n \n+    /**\n+     * Parse mapping-binding-patterns.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPattern() {\n+        startContext(ParserRuleContext.MAPPING_BINDING_PATTERN);\n+        ArrayList<STNode> bindingPatterns = new ArrayList<>();\n+        STNode openBrace = parseOpenBrace();\n+\n+        STNode mappingBindingPatternMember = parseMappingBindingPatternMember();\n+        bindingPatterns.add(mappingBindingPatternMember);\n+\n+        // parsing the main chunck of mapping-binding-pattern\n+        STToken token = peek(); // get next valid token\n+        STNode mappingBindingPatternRhs = null;\n+        while (!isEndOfMappingBindingPattern(token.kind) &&\n+                mappingBindingPatternMember.kind != SyntaxKind.REST_BINDING_PATTERN) {\n+            mappingBindingPatternRhs = parseMappingBindingpatternRhs(token.kind);\n+            if (mappingBindingPatternRhs == null) {\n+                break;\n+            }\n+\n+            bindingPatterns.add(mappingBindingPatternRhs);\n+            mappingBindingPatternMember = parseMappingBindingPatternMember();\n+            bindingPatterns.add(mappingBindingPatternMember);\n+            token = peek();\n+        }\n+\n+        STNode closeBrace = parseCloseBrace();\n+\n+        // seperating out the rest-binding-pattern\n+        STNode restBindingPattern;\n+        if (mappingBindingPatternMember.kind == SyntaxKind.REST_BINDING_PATTERN) {\n+            restBindingPattern = bindingPatterns.remove(bindingPatterns.size() - 1);\n+        } else {\n+            restBindingPattern = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode bindingPatternsNode = STNodeFactory.createNodeList(bindingPatterns);\n+        endContext();\n+        return STNodeFactory.createMappingBindingPatternNode(openBrace, bindingPatternsNode, restBindingPattern,\n+                closeBrace);\n+    }\n+\n+    /**\n+     * Parse mapping-binding-pattern entry.\n+     *\n+     * mapping-binding-pattern := { field-binding-patterns }\n+     * field-binding-patterns :=\n+     *    field-binding-pattern (, field-binding-pattern)* [, rest-binding-pattern]\n+     *    | [ rest-binding-pattern ]\n+     * field-binding-pattern :=\n+     *    field-name : binding-pattern\n+     *    | variable-name\n+     *\n+     * @return mapping-binding-pattern node\n+     */\n+    private STNode parseMappingBindingPatternMember() {\n+        STToken token = peek();\n+        switch (token.kind) {\n+            case ELLIPSIS_TOKEN:\n+                return parseRestBindingPattern();\n+            default:\n+                return parseFieldBindingPattern();\n+        }\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs() {\n+        return parseMappingBindingpatternRhs(peek().kind);\n+    }\n+\n+    private STNode parseMappingBindingpatternRhs(SyntaxKind nextTokenKind) {\n+        switch (nextTokenKind) {\n+            case COMMA_TOKEN:\n+                return parseComma();\n+            case CLOSE_BRACE_TOKEN:\n+                return null;\n+            default:\n+                Solution solution = recover(peek(), ParserRuleContext.MAPPING_BINDING_PATTERN_END_OR_CONTINUE);\n+\n+                // If the parser recovered by inserting a token, then try to re-parse the same\n+                // rule with the inserted token. This is done to pick the correct branch\n+                // to continue the parsing.\n+                if (solution.action == Action.REMOVE) {\n+                    return solution.recoveredNode;\n+                }\n+\n+                return parseMappingBindingpatternRhs(solution.tokenKind);\n+        }\n+    }\n+\n+    /**\n+     * Parse field-binding-pattern.\n+     *\n+     * field-binding-pattern := field-name : binding-pattern | varname\n+     *\n+     * @return field-binding-pattern node\n+     */\n+    private STNode parseFieldBindingPattern() {\n+        startContext(ParserRuleContext.FIELD_BINDING_PATTERN);\n+        STNode fieldName = parseVariableName();", "originalCommit": "a9e616c312e66de69a60a209f2af8be80c64dd5c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c2ce50ee2d02a6f5483fd7d773b46b9b61cbd9de", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c2ce50ee2d02a6f5483fd7d773b46b9b61cbd9de", "message": "Refactor code", "committedDate": "2020-05-27T09:58:48Z", "type": "commit"}, {"oid": "3ca49aa3c22a0e3a32938f10865cb44bfea8f577", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3ca49aa3c22a0e3a32938f10865cb44bfea8f577", "message": "Refactor Mapping binding Pattern", "committedDate": "2020-05-27T13:54:05Z", "type": "commit"}, {"oid": "60cd13078d9fb521b7792b73890dc5e3aa7fcb53", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/60cd13078d9fb521b7792b73890dc5e3aa7fcb53", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into mappingbindingpattern", "committedDate": "2020-05-27T13:54:36Z", "type": "commit"}, {"oid": "c2ce50ee2d02a6f5483fd7d773b46b9b61cbd9de", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c2ce50ee2d02a6f5483fd7d773b46b9b61cbd9de", "message": "Refactor code", "committedDate": "2020-05-27T09:58:48Z", "type": "forcePushed"}, {"oid": "bf37765019721e126529d5a02ae4975186ee5620", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bf37765019721e126529d5a02ae4975186ee5620", "message": "Refactor how Field binding pattern is parsed", "committedDate": "2020-05-28T04:52:38Z", "type": "commit"}, {"oid": "61d16c5c72b259abb613d3d9347c479fafdc71a9", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/61d16c5c72b259abb613d3d9347c479fafdc71a9", "message": "Change assert to incorporate mapping binding pattern in recovery", "committedDate": "2020-05-28T05:04:01Z", "type": "commit"}, {"oid": "47c117cb8e4c7754500432a9e1165f0096d2e52f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/47c117cb8e4c7754500432a9e1165f0096d2e52f", "message": "Fix merge conflicts", "committedDate": "2020-05-28T05:15:04Z", "type": "commit"}, {"oid": "4a70be8d4bc9c5a8450d75cd755dd4d7a3c0e886", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4a70be8d4bc9c5a8450d75cd755dd4d7a3c0e886", "message": "Fix spotbugs and checkstyle issues", "committedDate": "2020-05-28T06:27:57Z", "type": "commit"}]}