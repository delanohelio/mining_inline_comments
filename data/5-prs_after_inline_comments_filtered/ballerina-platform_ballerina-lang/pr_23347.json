{"pr_number": 23347, "pr_title": "Add singleton type descriptor support to new parser.", "pr_createdAt": "2020-05-19T05:40:15Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/23347", "timeline": [{"oid": "38b67ffc56e47efa3ea41a92505bf3661dba1064", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/38b67ffc56e47efa3ea41a92505bf3661dba1064", "message": "Singleton type desc support with recovery logic.", "committedDate": "2020-05-19T05:14:57Z", "type": "commit"}, {"oid": "1ec563e664c720b63a3b7901ec948f7071fbe2b2", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1ec563e664c720b63a3b7901ec948f7071fbe2b2", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into singleton-type\n\n\u0001 Conflicts:\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/ParserRuleContext.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/tree/STNodeFactory.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/NodeFactory.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/NodeTransformer.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/NodeVisitor.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/TreeModifier.java\n\u0001\tcompiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "committedDate": "2020-05-19T05:37:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA0NjI5MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23347#discussion_r427046290", "bodyText": "Better to pass the nodeKind as a parameter, coz you may be reaching here after recovering (inserting a token). Then the next tokenKind may not be same as peek().kind.", "author": "SupunS", "createdAt": "2020-05-19T05:55:08Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9343,4 +9350,55 @@ private STNode parseIntersectionTypeDescriptor(STNode leftTypeDesc, ParserRuleCo\n         STNode rightTypeDesc = parseTypeDescriptor(context);\n         return STNodeFactory.createIntersectionTypeDescriptorNode(leftTypeDesc, bitwiseAndToken, rightTypeDesc);\n     }\n+\n+    /**\n+     * Parse singleton type descriptor.\n+     * <p>singleton-type-descriptor := simple-const-expr\n+     * simple-const-expr :=\n+     *   nil-literal\n+     *   | boolean-literal\n+     *   | [Sign] int-literal\n+     *   | [Sign] floating-point-literal\n+     *   | string-literal\n+     *   | constant-reference-expr</p>\n+     */\n+    private STNode parseSingletonTypeDesc() {\n+        STNode simpleContExpr =  parseConstExpr();\n+        return STNodeFactory.createSingletonTypeDescriptorNode(simpleContExpr);\n+    }\n+\n+    private STNode parseSignedIntOrFloat() {\n+        STNode operator = parseUnaryOperator();\n+        STNode literal;\n+        STToken nextToken = peek();\n+        switch (nextToken.kind) {\n+            case HEX_INTEGER_LITERAL:\n+            case DECIMAL_FLOATING_POINT_LITERAL:\n+            case HEX_FLOATING_POINT_LITERAL:\n+                literal = consume();\n+                break;\n+            default:   //decimal integer literal\n+                literal = parseDecimalIntLiteral(ParserRuleContext.DECIMAL_INTEGER_LITERAL);\n+        }\n+        return STNodeFactory.createUnaryExpressionNode(operator, literal);\n+    }\n+\n+    private boolean isSingletonTypeDescStartToken() {\n+        STToken nextToken = peek();\n+        switch (nextToken.kind) {", "originalCommit": "1ec563e664c720b63a3b7901ec948f7071fbe2b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI3OTM4MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23347#discussion_r427279381", "bodyText": "done", "author": "rdulmina", "createdAt": "2020-05-19T12:55:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA0NjI5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA0NzE3Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23347#discussion_r427047173", "bodyText": "We come here trying to get the next expected token/context after close-parenthesis of a nil-literal. In that case the next token is an rhs of an expression. So this has to be ParserRuleContext.EXPRESSION_RHS", "author": "SupunS", "createdAt": "2020-05-19T05:57:50Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -2169,7 +2184,7 @@ private ParserRuleContext getNextRuleForCloseParenthsis() {\n             return ParserRuleContext.TYPEDESC_RHS;\n         } else if (parentCtx == ParserRuleContext.NIL_LITERAL) {\n             endContext();\n-            return ParserRuleContext.EXPRESSION_RHS;\n+            return getNextRuleForExpr();", "originalCommit": "1ec563e664c720b63a3b7901ec948f7071fbe2b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI3OTgzNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23347#discussion_r427279837", "bodyText": "@SupunS it returns EXPRESSION_RHS inside getNextRuleForExpr() method", "author": "rdulmina", "createdAt": "2020-05-19T12:56:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA0NzE3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzMxMTM2MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23347#discussion_r427311361", "bodyText": "ack", "author": "SupunS", "createdAt": "2020-05-19T13:41:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA0NzE3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1MTE3Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23347#discussion_r427051177", "bodyText": "There are situations where, a statement can start with an expression.\ne.g: sync-send/async-send action-stmt (https://ballerina.io/ballerina-spec/spec.html#send-action)\nfunction foo() {\n   5 -> w1;    // send value 5 to worker w1\n}\n\nSo I think here you'll have to look some more tokens ahead, and determine whether this is actually a singleton type start or whether this is an expression.\nAlso need to note, this ambiguity is there only for var-decl-stmt. This issue is not there for other places where a type-desc is expected.", "author": "SupunS", "createdAt": "2020-05-19T06:09:41Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9343,4 +9350,55 @@ private STNode parseIntersectionTypeDescriptor(STNode leftTypeDesc, ParserRuleCo\n         STNode rightTypeDesc = parseTypeDescriptor(context);\n         return STNodeFactory.createIntersectionTypeDescriptorNode(leftTypeDesc, bitwiseAndToken, rightTypeDesc);\n     }\n+\n+    /**\n+     * Parse singleton type descriptor.\n+     * <p>singleton-type-descriptor := simple-const-expr\n+     * simple-const-expr :=\n+     *   nil-literal\n+     *   | boolean-literal\n+     *   | [Sign] int-literal\n+     *   | [Sign] floating-point-literal\n+     *   | string-literal\n+     *   | constant-reference-expr</p>\n+     */\n+    private STNode parseSingletonTypeDesc() {\n+        STNode simpleContExpr =  parseConstExpr();\n+        return STNodeFactory.createSingletonTypeDescriptorNode(simpleContExpr);\n+    }\n+\n+    private STNode parseSignedIntOrFloat() {\n+        STNode operator = parseUnaryOperator();\n+        STNode literal;\n+        STToken nextToken = peek();\n+        switch (nextToken.kind) {\n+            case HEX_INTEGER_LITERAL:\n+            case DECIMAL_FLOATING_POINT_LITERAL:\n+            case HEX_FLOATING_POINT_LITERAL:\n+                literal = consume();\n+                break;\n+            default:   //decimal integer literal\n+                literal = parseDecimalIntLiteral(ParserRuleContext.DECIMAL_INTEGER_LITERAL);\n+        }\n+        return STNodeFactory.createUnaryExpressionNode(operator, literal);\n+    }\n+\n+    private boolean isSingletonTypeDescStartToken() {\n+        STToken nextToken = peek();\n+        switch (nextToken.kind) {\n+            case STRING_LITERAL:\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case DECIMAL_FLOATING_POINT_LITERAL:\n+            case HEX_FLOATING_POINT_LITERAL:\n+            case TRUE_KEYWORD:\n+            case FALSE_KEYWORD:\n+            case NULL_KEYWORD:\n+            case PLUS_TOKEN:\n+            case MINUS_TOKEN:\n+                return true;", "originalCommit": "1ec563e664c720b63a3b7901ec948f7071fbe2b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI3OTk1MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23347#discussion_r427279950", "bodyText": "Changed", "author": "rdulmina", "createdAt": "2020-05-19T12:56:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1MTE3Nw=="}], "type": "inlineReview"}, {"oid": "c087f9fbb64b038874098276293089a12fc6c852", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c087f9fbb64b038874098276293089a12fc6c852", "message": "Test cases for singleton type desc.", "committedDate": "2020-05-19T12:54:08Z", "type": "commit"}, {"oid": "0673c67ef7268dd7f9de0166f5065e1a0855d69b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0673c67ef7268dd7f9de0166f5065e1a0855d69b", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into singleton-type", "committedDate": "2020-05-19T12:54:32Z", "type": "commit"}, {"oid": "645121b4682eaf553907797e3f9729bb9b1fc8ca", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/645121b4682eaf553907797e3f9729bb9b1fc8ca", "message": "Removed extra new lines.", "committedDate": "2020-05-19T13:02:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzMwNTg2Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23347#discussion_r427305863", "bodyText": "This can be a problem if two consecutive tokens are equal.\nI feel you'll have to pass the peek-index as an argument here. I've done a similar thing in isValidExpressionStart() in: #23365", "author": "SupunS", "createdAt": "2020-05-19T13:34:16Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9343,4 +9360,85 @@ private STNode parseIntersectionTypeDescriptor(STNode leftTypeDesc, ParserRuleCo\n         STNode rightTypeDesc = parseTypeDescriptor(context);\n         return STNodeFactory.createIntersectionTypeDescriptorNode(leftTypeDesc, bitwiseAndToken, rightTypeDesc);\n     }\n+\n+    /**\n+     * Parse singleton type descriptor.\n+     * <p>singleton-type-descriptor := simple-const-expr\n+     * simple-const-expr :=\n+     *   nil-literal\n+     *   | boolean-literal\n+     *   | [Sign] int-literal\n+     *   | [Sign] floating-point-literal\n+     *   | string-literal\n+     *   | constant-reference-expr</p>\n+     */\n+    private STNode parseSingletonTypeDesc() {\n+        STNode simpleContExpr =  parseConstExpr();\n+        return STNodeFactory.createSingletonTypeDescriptorNode(simpleContExpr);\n+    }\n+\n+    private STNode parseSignedIntOrFloat() {\n+        STNode operator = parseUnaryOperator();\n+        STNode literal;\n+        STToken nextToken = peek();\n+        switch (nextToken.kind) {\n+            case HEX_INTEGER_LITERAL:\n+            case DECIMAL_FLOATING_POINT_LITERAL:\n+            case HEX_FLOATING_POINT_LITERAL:\n+                literal = consume();\n+                break;\n+            default:   //decimal integer literal\n+                literal = parseDecimalIntLiteral(ParserRuleContext.DECIMAL_INTEGER_LITERAL);\n+        }\n+        return STNodeFactory.createUnaryExpressionNode(operator, literal);\n+    }\n+\n+    private boolean isSingletonTypeDescStart(SyntaxKind tokenKind, boolean inTypeDescCtx) {\n+        STToken nextToken = peek();\n+        STToken nextNextToken, nextNextNextToken;\n+        if (tokenKind != nextToken.kind) { //this will be true if and only if we come here after recovering", "originalCommit": "645121b4682eaf553907797e3f9729bb9b1fc8ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzMwOTA4Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23347#discussion_r427309087", "bodyText": "Might need to check whether a basic-literal is followed by | or &. Because with type binding patterns, var name would not always be an identifier.", "author": "SupunS", "createdAt": "2020-05-19T13:38:42Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9343,4 +9360,85 @@ private STNode parseIntersectionTypeDescriptor(STNode leftTypeDesc, ParserRuleCo\n         STNode rightTypeDesc = parseTypeDescriptor(context);\n         return STNodeFactory.createIntersectionTypeDescriptorNode(leftTypeDesc, bitwiseAndToken, rightTypeDesc);\n     }\n+\n+    /**\n+     * Parse singleton type descriptor.\n+     * <p>singleton-type-descriptor := simple-const-expr\n+     * simple-const-expr :=\n+     *   nil-literal\n+     *   | boolean-literal\n+     *   | [Sign] int-literal\n+     *   | [Sign] floating-point-literal\n+     *   | string-literal\n+     *   | constant-reference-expr</p>\n+     */\n+    private STNode parseSingletonTypeDesc() {\n+        STNode simpleContExpr =  parseConstExpr();\n+        return STNodeFactory.createSingletonTypeDescriptorNode(simpleContExpr);\n+    }\n+\n+    private STNode parseSignedIntOrFloat() {\n+        STNode operator = parseUnaryOperator();\n+        STNode literal;\n+        STToken nextToken = peek();\n+        switch (nextToken.kind) {\n+            case HEX_INTEGER_LITERAL:\n+            case DECIMAL_FLOATING_POINT_LITERAL:\n+            case HEX_FLOATING_POINT_LITERAL:\n+                literal = consume();\n+                break;\n+            default:   //decimal integer literal\n+                literal = parseDecimalIntLiteral(ParserRuleContext.DECIMAL_INTEGER_LITERAL);\n+        }\n+        return STNodeFactory.createUnaryExpressionNode(operator, literal);\n+    }\n+\n+    private boolean isSingletonTypeDescStart(SyntaxKind tokenKind, boolean inTypeDescCtx) {\n+        STToken nextToken = peek();\n+        STToken nextNextToken, nextNextNextToken;\n+        if (tokenKind != nextToken.kind) { //this will be true if and only if we come here after recovering\n+            nextNextToken = nextToken;\n+            nextNextNextToken = peek(2);\n+        } else {\n+            nextNextToken = peek(2);\n+            nextNextNextToken = peek(3);\n+        }\n+        switch (tokenKind) {\n+            case STRING_LITERAL:\n+            case DECIMAL_INTEGER_LITERAL:\n+            case HEX_INTEGER_LITERAL:\n+            case DECIMAL_FLOATING_POINT_LITERAL:\n+            case HEX_FLOATING_POINT_LITERAL:\n+            case TRUE_KEYWORD:\n+            case FALSE_KEYWORD:\n+            case NULL_KEYWORD:\n+                if (inTypeDescCtx || nextNextToken.kind == SyntaxKind.IDENTIFIER_TOKEN) {\n+                    return true;\n+                }\n+                return false;", "originalCommit": "645121b4682eaf553907797e3f9729bb9b1fc8ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "897682b658dec4bf570a2b719cf6246a4b2a7dd0", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/897682b658dec4bf570a2b719cf6246a4b2a7dd0", "message": "Changed the parsing logic of singleton type desc.", "committedDate": "2020-05-19T15:27:06Z", "type": "commit"}, {"oid": "4f781a7aaeeb4495deb220d6b17cc78803efb742", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4f781a7aaeeb4495deb220d6b17cc78803efb742", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into singleton-type", "committedDate": "2020-05-19T15:58:22Z", "type": "commit"}, {"oid": "42c547a0c3558b5ecf77b63ff861ad4f3a01750c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/42c547a0c3558b5ecf77b63ff861ad4f3a01750c", "message": "Changed base node of singleton type desc.", "committedDate": "2020-05-20T03:58:29Z", "type": "commit"}, {"oid": "3bf4cb3c702f73ddcb25765d6c7061db630a7354", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3bf4cb3c702f73ddcb25765d6c7061db630a7354", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into singleton-type", "committedDate": "2020-05-20T05:32:24Z", "type": "commit"}]}