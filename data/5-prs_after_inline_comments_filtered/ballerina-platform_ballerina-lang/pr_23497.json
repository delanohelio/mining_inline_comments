{"pr_number": 23497, "pr_title": "Add byte array literal and xml attribute access expression parsing", "pr_createdAt": "2020-05-26T07:18:49Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/23497", "timeline": [{"oid": "94bac924431296071ff00306cc48ba168aa95184", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/94bac924431296071ff00306cc48ba168aa95184", "message": "Modify syntax tree descriptor and generate tree", "committedDate": "2020-05-25T13:47:45Z", "type": "commit"}, {"oid": "6d02aa84743f9b2deca567b5a2f3831561eab8fe", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6d02aa84743f9b2deca567b5a2f3831561eab8fe", "message": "Add byte array literal parsing", "committedDate": "2020-05-25T13:48:27Z", "type": "commit"}, {"oid": "355e7a486265ef0f019c1a8e2bdafa5d7ae2cc1a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/355e7a486265ef0f019c1a8e2bdafa5d7ae2cc1a", "message": "Add preceding syntax kind to lexer and fix few check styles", "committedDate": "2020-05-26T05:57:32Z", "type": "commit"}, {"oid": "f6e3cf0521b5c535e51d9fbcb03048352c3498e2", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f6e3cf0521b5c535e51d9fbcb03048352c3498e2", "message": "Add test cases for valid syntax", "committedDate": "2020-05-26T05:58:25Z", "type": "commit"}, {"oid": "548ccc1bd4db4932ec405061c5e4cc151e01bd92", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/548ccc1bd4db4932ec405061c5e4cc151e01bd92", "message": "Fix invalid token processing for byte literal in lexer", "committedDate": "2020-05-26T07:10:09Z", "type": "commit"}, {"oid": "004cea4e919e5fc8fb65016d170900892d7fa9aa", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/004cea4e919e5fc8fb65016d170900892d7fa9aa", "message": "Change byte array literal parsing", "committedDate": "2020-05-26T12:28:55Z", "type": "commit"}, {"oid": "0d47ad4b38e695d1c55b9e3c063faeaf8686bd72", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0d47ad4b38e695d1c55b9e3c063faeaf8686bd72", "message": "Add byte arrray content validation and refactor", "committedDate": "2020-05-27T05:57:01Z", "type": "forcePushed"}, {"oid": "1bceba5d7d2447d744b8697f353b72c375869baf", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1bceba5d7d2447d744b8697f353b72c375869baf", "message": "Add byte arrray content validation and refactor", "committedDate": "2020-05-27T06:12:57Z", "type": "commit"}, {"oid": "1bceba5d7d2447d744b8697f353b72c375869baf", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1bceba5d7d2447d744b8697f353b72c375869baf", "message": "Add byte arrray content validation and refactor", "committedDate": "2020-05-27T06:12:57Z", "type": "forcePushed"}, {"oid": "751bbc385525d85fb79cf42fc3d319e359a0f21d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/751bbc385525d85fb79cf42fc3d319e359a0f21d", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into incremental-parser\n\n\u0001 Conflicts:\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/LexerTerminals.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/ParserRuleContext.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/tree/STNodeFactory.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/NodeFactory.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/NodeTransformer.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/NodeVisitor.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/SyntaxKind.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/TreeModifier.java\n\u0001\tcompiler/ballerina-parser/src/test/java/io/ballerinalang/compiler/parser/test/ParserTestUtils.java\n\u0001\tcompiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "committedDate": "2020-05-27T06:37:00Z", "type": "commit"}, {"oid": "e0a9f3ef4f0d9d2aeee4d73d56155a133f1da240", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e0a9f3ef4f0d9d2aeee4d73d56155a133f1da240", "message": "Regenerate tree and fix test cases", "committedDate": "2020-05-27T07:46:54Z", "type": "commit"}, {"oid": "e4d2562505d698759b0ca797091e578fd6002491", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e4d2562505d698759b0ca797091e578fd6002491", "message": "Add xml attribute access expression support", "committedDate": "2020-05-27T09:30:09Z", "type": "commit"}, {"oid": "2300809c98e9168bfe029b8d62dd59ef8f2a89e4", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2300809c98e9168bfe029b8d62dd59ef8f2a89e4", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into incremental-parser", "committedDate": "2020-05-27T09:40:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk5MjI0Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23497#discussion_r430992246", "bodyText": "This was a mistake right?", "author": "lochana-chathura", "createdAt": "2020-05-27T09:45:04Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -9179,7 +9203,7 @@ private STNode parseStringTemplateExpression() {\n         STNode type = parseStringKeyword();\n         STNode startingBackTick = parseBacktickToken(ParserRuleContext.TEMPLATE_START);\n         STNode content = parseTemplateContent();\n-        STNode endingBackTick = parseBacktickToken(ParserRuleContext.TEMPLATE_START);\n+        STNode endingBackTick = parseBacktickToken(ParserRuleContext.TEMPLATE_END);", "originalCommit": "2300809c98e9168bfe029b8d62dd59ef8f2a89e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAzNzQ1Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23497#discussion_r431037453", "bodyText": "yes, seems so", "author": "SupunS", "createdAt": "2020-05-27T11:09:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk5MjI0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk5MzE3Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23497#discussion_r430993176", "bodyText": "here also a mistake?", "author": "lochana-chathura", "createdAt": "2020-05-27T09:46:34Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -917,7 +917,13 @@ protected Result seekMatch(ParserRuleContext currentCtx, int lookahead, int curr\n                     hasMatch = nextToken.kind == SyntaxKind.XML_KEYWORD;\n                     break;\n                 case STRING_KEYWORD:\n-                    hasMatch = nextToken.kind == SyntaxKind.XML_KEYWORD;\n+                    hasMatch = nextToken.kind == SyntaxKind.STRING_KEYWORD;\n+                    break;", "originalCommit": "2300809c98e9168bfe029b8d62dd59ef8f2a89e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0fbb1cf0199161125aaca5c14ba5b4afa74cd17e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0fbb1cf0199161125aaca5c14ba5b4afa74cd17e", "message": "Fix BLangNodeTransformer", "committedDate": "2020-05-27T10:01:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAzNTI1Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23497#discussion_r431035257", "bodyText": "I think we can skip this check, since base16 and base64 keywords only occurs in expressions.\nThen if one of those two, then we can commit to say its one of those two literals.", "author": "SupunS", "createdAt": "2020-05-27T11:05:05Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -4279,6 +4282,13 @@ private STNode parseTerminalExpression(SyntaxKind kind, STNode annots, boolean i\n                 return parseTransactionalExpression();\n             case SERVICE_KEYWORD:\n                 return parseServiceConstructorExpression(annots);\n+            case BASE16_KEYWORD:\n+            case BASE64_KEYWORD:\n+                nextNextToken = getNextNextToken(kind);\n+                if (nextNextToken.kind == SyntaxKind.BACKTICK_TOKEN) {", "originalCommit": "0fbb1cf0199161125aaca5c14ba5b4afa74cd17e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAzNjAyOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23497#discussion_r431036029", "bodyText": "Would something like \"field-access-identifier\" be a better word for both context and method name? because qualified-identifier is a bit generic..", "author": "SupunS", "createdAt": "2020-05-27T11:06:31Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -435,8 +434,8 @@ public STNode resumeParsing(ParserRuleContext context, Object... args) {\n                 return parseWaitFieldEnd();\n             case ANNOT_CHAINING_TOKEN:\n                 return parseAnnotChainingToken();\n-            case ANNOT_TAG_REFERENCE:\n-                return parseAnnotTagReference();\n+            case QUALIFIED_IDENTIFIER_OR_IDENTIFIER:\n+                return parseQualifiedIdentifierOrIdentifier();", "originalCommit": "0fbb1cf0199161125aaca5c14ba5b4afa74cd17e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA0MDUwMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23497#discussion_r431040500", "bodyText": "Shall we remove FIELD_OR_FUNC_NAME from parser rule context class as well?", "author": "SupunS", "createdAt": "2020-05-27T11:15:47Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -11161,16 +11189,26 @@ private STNode parseDoKeyword() {\n     }\n \n     /**\n-     * Parse optional field access expression.\n+     * Parse optional field access or xml optional attribute access expression.\n      * <p>\n-     * <code>optional-field-access-expr := expression ?. field-name</code>\n+     * <code>\n+     * optional-field-access-expr := expression ?. field-name\n+     * <br/>\n+     * xml-optional-attribute-access-expr := expression ?. xml-attribute-name\n+     * <br/>\n+     * xml-attribute-name := xml-qualified-name | qualified-identifier | identifier\n+     * <br/>\n+     * xml-qualified-name := xml-namespace-prefix : identifier\n+     * <br/>\n+     * xml-namespace-prefix := identifier\n+     * </code>\n      *\n-     * @param lhsExpr Preceding expression of the optional field access\n+     * @param lhsExpr Preceding expression of the optional access\n      * @return Parsed node\n      */\n     private STNode parseOptionalFieldAccessExpression(STNode lhsExpr) {\n         STNode optionalFieldAccessToken = parseOptionalChainingToken();\n-        STNode fieldName = parseIdentifier(ParserRuleContext.FIELD_OR_FUNC_NAME);\n+        STNode fieldName = parseQualifiedIdentifierOrIdentifier();", "originalCommit": "0fbb1cf0199161125aaca5c14ba5b4afa74cd17e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA0Mzg5MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23497#discussion_r431043891", "bodyText": "we would never reach here right? In that case i think its ok to not to have the second 'if' condition", "author": "SupunS", "createdAt": "2020-05-27T11:22:18Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -11897,4 +11935,104 @@ private STNode parseServiceConstructorExpression(STNode annots) {\n                 serviceKeyword,\n                 serviceBody);\n     }\n+\n+    /**\n+     * Parse base16 literal.\n+     * <p>\n+     * <code>\n+     * byte-array-literal := Base16Literal | Base64Literal\n+     * <br/>\n+     * Base16Literal := base16 WS ` HexGroup* WS `\n+     * <br/>\n+     * Base64Literal := base64 WS ` Base64Group* [PaddedBase64Group] WS `\n+     * </code>\n+     *\n+     * @param kind byte array literal kind\n+     * @return parsed node\n+     */\n+    private STNode parseByteArrayLiteral(SyntaxKind kind) {\n+        STNode type;\n+\n+        if (kind == SyntaxKind.BASE16_KEYWORD) {\n+            type = parseBase16Keyword();\n+        } else {\n+            type = parseBase64Keyword();\n+        }\n+\n+        STNode startingBackTick = parseBacktickToken(ParserRuleContext.TEMPLATE_START);\n+        STNode content = parseByteArrayContent(kind);\n+        STNode endingBackTick = parseBacktickToken(ParserRuleContext.TEMPLATE_END);\n+        return STNodeFactory.createByteArrayLiteralNode(type, startingBackTick, content, endingBackTick);\n+    }\n+\n+    /**\n+     * Parse <code>base16</code> keyword.\n+     *\n+     * @return base16 keyword node\n+     */\n+    private STNode parseBase16Keyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.BASE16_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.BASE16_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse <code>base64</code> keyword.\n+     *\n+     * @return base64 keyword node\n+     */\n+    private STNode parseBase64Keyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.BASE64_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.BASE64_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Validate and parse byte array literal content.\n+     * An error is reported, if the content is invalid.\n+     *\n+     * @param kind byte array literal kind\n+     * @return parsed node\n+     */\n+    private STNode parseByteArrayContent(SyntaxKind kind) {\n+        STNode content = null;\n+        boolean isValidContent = false;\n+        STToken nextToken = peek();\n+\n+        while (!isEndOfBacktickContent(nextToken.kind)) {\n+            STNode contentItem = parseTemplateItem();\n+\n+            if (content == null && contentItem.kind == SyntaxKind.TEMPLATE_STRING) {\n+                if (kind == SyntaxKind.BASE16_KEYWORD &&\n+                        BallerinaLexer.isValidBase16LiteralContent(contentItem.toString())) {\n+                    content = contentItem;\n+                    isValidContent = true;\n+                } else if (kind == SyntaxKind.BASE64_KEYWORD &&\n+                        BallerinaLexer.isValidBase64LiteralContent(contentItem.toString())) {\n+                    content = contentItem;\n+                    isValidContent = true;\n+                } else {\n+                    content = contentItem;", "originalCommit": "0fbb1cf0199161125aaca5c14ba5b4afa74cd17e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA0NjA2Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23497#discussion_r431046062", "bodyText": "Shall we simplify this logic?\n\nParse everything.\nif size >1 , then error. no need to check character-wise\nif size ==1, and if thats not an TEMPLATE_STRING, again error.\nif non of those above, then validate.", "author": "SupunS", "createdAt": "2020-05-27T11:26:53Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -11897,4 +11935,104 @@ private STNode parseServiceConstructorExpression(STNode annots) {\n                 serviceKeyword,\n                 serviceBody);\n     }\n+\n+    /**\n+     * Parse base16 literal.\n+     * <p>\n+     * <code>\n+     * byte-array-literal := Base16Literal | Base64Literal\n+     * <br/>\n+     * Base16Literal := base16 WS ` HexGroup* WS `\n+     * <br/>\n+     * Base64Literal := base64 WS ` Base64Group* [PaddedBase64Group] WS `\n+     * </code>\n+     *\n+     * @param kind byte array literal kind\n+     * @return parsed node\n+     */\n+    private STNode parseByteArrayLiteral(SyntaxKind kind) {\n+        STNode type;\n+\n+        if (kind == SyntaxKind.BASE16_KEYWORD) {\n+            type = parseBase16Keyword();\n+        } else {\n+            type = parseBase64Keyword();\n+        }\n+\n+        STNode startingBackTick = parseBacktickToken(ParserRuleContext.TEMPLATE_START);\n+        STNode content = parseByteArrayContent(kind);\n+        STNode endingBackTick = parseBacktickToken(ParserRuleContext.TEMPLATE_END);\n+        return STNodeFactory.createByteArrayLiteralNode(type, startingBackTick, content, endingBackTick);\n+    }\n+\n+    /**\n+     * Parse <code>base16</code> keyword.\n+     *\n+     * @return base16 keyword node\n+     */\n+    private STNode parseBase16Keyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.BASE16_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.BASE16_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Parse <code>base64</code> keyword.\n+     *\n+     * @return base64 keyword node\n+     */\n+    private STNode parseBase64Keyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.BASE64_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.BASE64_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    /**\n+     * Validate and parse byte array literal content.\n+     * An error is reported, if the content is invalid.\n+     *\n+     * @param kind byte array literal kind\n+     * @return parsed node\n+     */\n+    private STNode parseByteArrayContent(SyntaxKind kind) {\n+        STNode content = null;\n+        boolean isValidContent = false;\n+        STToken nextToken = peek();\n+\n+        while (!isEndOfBacktickContent(nextToken.kind)) {\n+            STNode contentItem = parseTemplateItem();\n+\n+            if (content == null && contentItem.kind == SyntaxKind.TEMPLATE_STRING) {", "originalCommit": "0fbb1cf0199161125aaca5c14ba5b4afa74cd17e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTE2ODM0MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23497#discussion_r431168341", "bodyText": "HBN?", "author": "lochana-chathura", "createdAt": "2020-05-27T14:18:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA0NjA2Mg=="}], "type": "inlineReview"}, {"oid": "7a138b12bbc446fa4cb8f3e5ee7f5c80e408617c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7a138b12bbc446fa4cb8f3e5ee7f5c80e408617c", "message": "Refactor code", "committedDate": "2020-05-27T13:49:09Z", "type": "commit"}, {"oid": "7a138b12bbc446fa4cb8f3e5ee7f5c80e408617c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7a138b12bbc446fa4cb8f3e5ee7f5c80e408617c", "message": "Refactor code", "committedDate": "2020-05-27T13:49:09Z", "type": "forcePushed"}]}