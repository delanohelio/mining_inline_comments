{"pr_number": 20749, "pr_title": "Fill-in missing values by list constructor", "pr_createdAt": "2020-01-27T09:16:11Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749", "timeline": [{"oid": "89204061f107109dd671044ca4b098913d14df03", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/89204061f107109dd671044ca4b098913d14df03", "message": "WIP: Fill-in missing values by list constructor\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-01-27T18:43:26Z", "type": "forcePushed"}, {"oid": "c9d74b4a73ccd6cfad0d7783f6a02b9ecede6535", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c9d74b4a73ccd6cfad0d7783f6a02b9ecede6535", "message": "Add XML array test with list ctor", "committedDate": "2020-01-28T06:09:52Z", "type": "forcePushed"}, {"oid": "ca163139d84d3f88a0c677f8533a7f92b938e8f6", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ca163139d84d3f88a0c677f8533a7f92b938e8f6", "message": "Fill-in missing values by list constructor\n\nRemoved explicit check in list constructor length to same length as the\narray definition. This strict check is loosened now to only check if\nlist constructor is creating a larger array than array definition. Test\ncases are added to test array creation in various data types.\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-01-28T10:27:58Z", "type": "forcePushed"}, {"oid": "bfea2e6ed3c01bef9d1ac8b0c18f1f469b872050", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bfea2e6ed3c01bef9d1ac8b0c18f1f469b872050", "message": "Fill-in missing values by list constructor\n\nRemoved explicit check in list constructor length to same length as the\narray definition. This strict check is loosened now to only check if\nlist constructor is creating a larger array than array definition. Test\ncases are added to test array creation in various data types.\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-01-28T11:03:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg4OTc1OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r371889759", "bodyText": "Shall we improve formatting?\n                    dlog.error(listConstructor.pos, DiagnosticCode.MISMATCHING_ARRAY_LITERAL_VALUES, \n                               arrayType.size, listConstructor.exprs.size());", "author": "MaryamZi", "createdAt": "2020-01-28T15:53:23Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -609,10 +609,14 @@ public void visit(BLangListConstructorExpr listConstructor) {\n             if (arrayType.state == BArrayState.OPEN_SEALED) {\n                 arrayType.size = listConstructor.exprs.size();\n                 arrayType.state = BArrayState.CLOSED_SEALED;\n-            } else if (arrayType.state != BArrayState.UNSEALED && arrayType.size != listConstructor.exprs.size()) {\n-                dlog.error(listConstructor.pos,\n-                        DiagnosticCode.MISMATCHING_ARRAY_LITERAL_VALUES, arrayType.size, listConstructor.exprs.size());\n-                return;\n+            } else if ((arrayType.state != BArrayState.UNSEALED) && (arrayType.size != listConstructor.exprs.size())) {\n+                if (arrayType.size < listConstructor.exprs.size()) {\n+                    dlog.error(listConstructor.pos,\n+                            DiagnosticCode.MISMATCHING_ARRAY_LITERAL_VALUES, arrayType.size, listConstructor.exprs.size\n+                            ());", "originalCommit": "bfea2e6ed3c01bef9d1ac8b0c18f1f469b872050", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEzNzE0MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r372137141", "bodyText": "Reaching 120 character limit. Check now.", "author": "KRVPerera", "createdAt": "2020-01-29T00:43:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg4OTc1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg5Mjg0Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r371892843", "bodyText": "Shall we write this test to panic on failure instead? e.g., https://github.com/ballerina-platform/ballerina-lang/pull/20679/files#diff-8ef02e76dc938bb93e61ae0143f646cdR1060\nThat way we could remove the Java side assertions.", "author": "MaryamZi", "createdAt": "2020-01-28T15:57:54Z", "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/expressions/listconstructor/ListConstructorExprTest.java", "diffHunk": "@@ -59,4 +59,11 @@ public void diagnosticsTest() {\n                 23, 34);\n         Assert.assertEquals(resultNegative.getErrorCount(), i);\n     }\n+\n+    @Test\n+    public void testListConstructorAutoFillExpr() {\n+        BValue[] returns = BRunUtil.invoke(result, \"testListConstructorAutoFillExpr\");", "originalCommit": "bfea2e6ed3c01bef9d1ac8b0c18f1f469b872050", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg5MzMxMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r371893310", "bodyText": "We can write these tests also in Ballerina right?", "author": "MaryamZi", "createdAt": "2020-01-28T15:58:38Z", "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/SealedArrayTest.java", "diffHunk": "@@ -53,6 +53,11 @@ public void testCreateIntegerSealedArray() {\n                 returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n         Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n \n+        returnValues = BRunUtil.invoke(compileResult, \"createIntAutoFilledSealedArray\");", "originalCommit": "bfea2e6ed3c01bef9d1ac8b0c18f1f469b872050", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk0OTQ3NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r371949474", "bodyText": "Using testerina asserts ? or with If conditions and panics?\nWhat is more suitable in the long term?", "author": "KRVPerera", "createdAt": "2020-01-28T17:30:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg5MzMxMA=="}], "type": "inlineReview"}, {"oid": "5fc28b9a058502c6955722be7fdd5144c48f5bf3", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5fc28b9a058502c6955722be7fdd5144c48f5bf3", "message": "Fill-in missing values by list constructor\n\nRemoved explicit check in list constructor length to same length as the\narray definition. This strict check is loosened now to only check if\nlist constructor is creating a larger array than array definition. Test\ncases are added to test array creation in various data types.\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-01-30T02:47:38Z", "type": "forcePushed"}, {"oid": "972f0eab1c92d3d4556b71e9cc3e9914297c5483", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/972f0eab1c92d3d4556b71e9cc3e9914297c5483", "message": "Fix abstract object list construction without error\n\nAbstract object creation through list constructor does not throw error\nand this was fixed and now before we initilize the list we check if the\nunderneath object type is an abstact object type\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-02T10:20:56Z", "type": "forcePushed"}, {"oid": "b61a710cde422553991fa45d129723eea51f8d7b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b61a710cde422553991fa45d129723eea51f8d7b", "message": "Refactor fill value check in compile TypeChecker", "committedDate": "2020-02-03T09:53:10Z", "type": "forcePushed"}, {"oid": "c20cc4b202e4b0ed29bb5ddbcb368a69c02cf573", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c20cc4b202e4b0ed29bb5ddbcb368a69c02cf573", "message": "Refactor fill value check in compile TypeChecker", "committedDate": "2020-02-05T07:24:34Z", "type": "forcePushed"}, {"oid": "26b29b9c62e479a206d8407c2b6e458bf64c111a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/26b29b9c62e479a206d8407c2b6e458bf64c111a", "message": "Add union auto fill test cases", "committedDate": "2020-02-05T09:54:59Z", "type": "forcePushed"}, {"oid": "e78f9a4ee679d83110031e2cba7adf2610ae5918", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e78f9a4ee679d83110031e2cba7adf2610ae5918", "message": "Handle array type for fill value", "committedDate": "2020-02-06T04:16:19Z", "type": "forcePushed"}, {"oid": "c6188a57538ce75774c88b14bc47f73fcc3d9aa3", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c6188a57538ce75774c88b14bc47f73fcc3d9aa3", "message": "Refactor and add utils to Types.java", "committedDate": "2020-02-06T15:47:33Z", "type": "forcePushed"}, {"oid": "10d9703486a07ea9bde5047466f1579f195136c5", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/10d9703486a07ea9bde5047466f1579f195136c5", "message": "Add todo note for sealed-array.bal", "committedDate": "2020-02-07T05:25:26Z", "type": "forcePushed"}, {"oid": "0253730d5baffb1fc794d77a4b8ebd88ee0ac176", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0253730d5baffb1fc794d77a4b8ebd88ee0ac176", "message": "Test object fillinh", "committedDate": "2020-02-07T08:42:45Z", "type": "forcePushed"}, {"oid": "bfd7d62ffded201fde0b3a6bad84de44c70a99c7", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bfd7d62ffded201fde0b3a6bad84de44c70a99c7", "message": "Fix build after conclict resolution", "committedDate": "2020-02-08T04:43:57Z", "type": "forcePushed"}, {"oid": "319dc5d9cbd357f840f2562ac95bdeb4263a721b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/319dc5d9cbd357f840f2562ac95bdeb4263a721b", "message": "Fix sealed singleton array initialization", "committedDate": "2020-02-08T04:49:35Z", "type": "forcePushed"}, {"oid": "19b5d638226b05c465049b3027cbe950c49679e3", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/19b5d638226b05c465049b3027cbe950c49679e3", "message": "Fix incorrect caching of fillvalue check", "committedDate": "2020-02-08T07:25:52Z", "type": "forcePushed"}, {"oid": "af33fdd90b72da50f6196405e906ac0359fdbdb8", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/af33fdd90b72da50f6196405e906ac0359fdbdb8", "message": "Fix sealed singleton array initialization", "committedDate": "2020-02-08T16:03:17Z", "type": "forcePushed"}, {"oid": "b14ad7424dd2446f6e2726093d844c71f9ab1024", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b14ad7424dd2446f6e2726093d844c71f9ab1024", "message": "Fix anydata array fill list-ctor related issues", "committedDate": "2020-02-10T04:25:38Z", "type": "forcePushed"}, {"oid": "5519773712e3c4a1f32511620b19da8d52e96bec", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5519773712e3c4a1f32511620b19da8d52e96bec", "message": "Check fill value before array initilization", "committedDate": "2020-02-10T16:13:40Z", "type": "forcePushed"}, {"oid": "c003414045f8ef10724fd7f140cf1b3454e7bfeb", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c003414045f8ef10724fd7f140cf1b3454e7bfeb", "message": "Add BRecord type fill value check", "committedDate": "2020-02-11T06:19:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ3MTM5OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r377471398", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Copyright (c) 2019, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n          \n          \n            \n             * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.", "author": "kalaiyarasiganeshalingam", "createdAt": "2020-02-11T07:14:20Z", "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/ArrayFillTestRuntime.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright (c) 2019, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.", "originalCommit": "c003414045f8ef10724fd7f140cf1b3454e7bfeb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ3MTU0OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r377471549", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * This will handle two types\n          \n          \n            \n                 * This will handle two types.", "author": "kalaiyarasiganeshalingam", "createdAt": "2020-02-11T07:15:05Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }\n+            if (!initFunction.symbol.getParameters().stream()\n+                    .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types", "originalCommit": "c003414045f8ef10724fd7f140cf1b3454e7bfeb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ3MTY3Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r377471677", "bodyText": "Remove extra lines", "author": "kalaiyarasiganeshalingam", "createdAt": "2020-02-11T07:15:43Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -4766,4 +4775,6 @@ private boolean isConst(BLangExpression expression) {\n     private Name getCurrentCompUnit(BLangNode node) {\n         return names.fromString(node.pos.getSource().getCompilationUnitName());\n     }\n+\n+", "originalCommit": "c003414045f8ef10724fd7f140cf1b3454e7bfeb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzUxMTczNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r377511735", "bodyText": "done", "author": "KRVPerera", "createdAt": "2020-02-11T09:12:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ3MTY3Nw=="}], "type": "inlineReview"}, {"oid": "4e72db66fcea5682a5011c9f48e9ac2c96076de1", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4e72db66fcea5682a5011c9f48e9ac2c96076de1", "message": "Fill only the needed elements in the array", "committedDate": "2020-02-11T07:18:25Z", "type": "forcePushed"}, {"oid": "1fbd4be112257964d55d15afde5dd462dca84696", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1fbd4be112257964d55d15afde5dd462dca84696", "message": "Fill only the needed elements in the array", "committedDate": "2020-02-11T07:51:26Z", "type": "forcePushed"}, {"oid": "f58c8c21da6ba8cb86457d3e7c52e863a15a3b68", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f58c8c21da6ba8cb86457d3e7c52e863a15a3b68", "message": "Add list-expr filler value check at compile time\n\nWhen we create a array of size x with list-expr if the user does not\nprovide x number of elements but some y (<x) in list-expr compiler\nneeds to auto fill x-y number of elements in the array\n\nPrevious check to prevent this when there is a size mismatch in\nlist-expr and array size (x != y) is removed and additional fill value\ncheck is added\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-11T08:39:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzUwMzI0Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r377503242", "bodyText": "If we move this logic to a function, we can improve the readability of the code. WDYT?", "author": "dulvinw", "createdAt": "2020-02-11T08:53:15Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -619,10 +619,18 @@ public void visit(BLangListConstructorExpr listConstructor) {\n             if (arrayType.state == BArrayState.OPEN_SEALED) {\n                 arrayType.size = listConstructor.exprs.size();\n                 arrayType.state = BArrayState.CLOSED_SEALED;\n-            } else if (arrayType.state != BArrayState.UNSEALED && arrayType.size != listConstructor.exprs.size()) {\n-                dlog.error(listConstructor.pos,\n-                        DiagnosticCode.MISMATCHING_ARRAY_LITERAL_VALUES, arrayType.size, listConstructor.exprs.size());\n-                return;\n+            } else if ((arrayType.state != BArrayState.UNSEALED) && (arrayType.size != listConstructor.exprs.size())) {", "originalCommit": "f58c8c21da6ba8cb86457d3e7c52e863a15a3b68", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzU1OTkzMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r377559932", "bodyText": "It will be like two functions ..\nif (isSealedArray(arrayType) && isSizeMismatch(arrayType, listConstructor.exprs)). Will this help ?", "author": "KRVPerera", "createdAt": "2020-02-11T10:48:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzUwMzI0Mg=="}], "type": "inlineReview"}, {"oid": "9f4bd3783fb1baa13f66660a4e9a7448e5ffab45", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9f4bd3783fb1baa13f66660a4e9a7448e5ffab45", "message": "Fix style", "committedDate": "2020-02-11T10:12:53Z", "type": "forcePushed"}, {"oid": "d7ffca3f2535a897d0e44911a0f4d7bff9869799", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d7ffca3f2535a897d0e44911a0f4d7bff9869799", "message": "Change license header to 2020\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-11T10:36:13Z", "type": "forcePushed"}, {"oid": "8c1d8da35d38db84786c9c1f2d6c088fc1779caa", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8c1d8da35d38db84786c9c1f2d6c088fc1779caa", "message": "Change license header to 2020\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-11T19:56:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjgwNTk2OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r376805968", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Optional<Boolean> hasFillerValue = Optional.empty();;\n          \n          \n            \n                private Optional<Boolean> hasFillerValue = Optional.empty();", "author": "MaryamZi", "createdAt": "2020-02-09T18:49:50Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java", "diffHunk": "@@ -71,6 +72,8 @@\n     private String[] stringValues;\n     private BString[] bStringValues;\n \n+    private Optional<Boolean> hasFillerValue = Optional.empty();;", "originalCommit": "14ed660461442578df396c6c3bb26b9062f823b1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjkzNTk1NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r376935955", "bodyText": "Not due to this changes but IIUC, if this method gets called we've been initializing the array to the default size even if the array is a closed, fixed-length one? Shouldn't we only use the default if there is no explicit size?", "author": "MaryamZi", "createdAt": "2020-02-10T09:07:49Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java", "diffHunk": "@@ -130,56 +133,60 @@ public ArrayValueImpl(BArrayType type) {\n         this.arrayType = type;\n         BArrayType arrayType = (BArrayType) type;\n         this.elementType = arrayType.getElementType();\n+        initArrayValues(elementType, false);\n         if (arrayType.getState() == ArrayState.CLOSED_SEALED) {\n             this.size = maxSize = arrayType.getSize();\n         }\n-        initArrayValues(this.elementType, false);\n     }\n \n     private void initArrayValues(BType elementType, boolean useBString) {\n+        int initialArraySize = Math.max(DEFAULT_ARRAY_SIZE, arrayType.getSize());", "originalCommit": "6a1ded361a9c36677290e97cd4a3ad1610dc21f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODEzOTEwNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r378139105", "bodyText": "Yes, I agree. For a fixed-length array (explicit size), there will be an unused allocated capacity due to this logic.", "author": "KRVPerera", "createdAt": "2020-02-12T09:45:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjkzNTk1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjkzOTA2Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r376939067", "bodyText": "Not sure if this is the correct error? This just says \"invalid usage of list constructor with type 'T'\" right? IMO, we should say something that implies there's no filler value and there's a size mismatch.", "author": "MaryamZi", "createdAt": "2020-02-10T09:14:37Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -619,16 +620,25 @@ public void visit(BLangListConstructorExpr listConstructor) {\n             if (arrayType.state == BArrayState.OPEN_SEALED) {\n                 arrayType.size = listConstructor.exprs.size();\n                 arrayType.state = BArrayState.CLOSED_SEALED;\n-            } else if (arrayType.state != BArrayState.UNSEALED && arrayType.size != listConstructor.exprs.size()) {\n-                dlog.error(listConstructor.pos,\n-                        DiagnosticCode.MISMATCHING_ARRAY_LITERAL_VALUES, arrayType.size, listConstructor.exprs.size());\n-                return;\n+            } else if ((arrayType.state != BArrayState.UNSEALED) && (arrayType.size != listConstructor.exprs.size())) {\n+                if (arrayType.size < listConstructor.exprs.size()) {\n+                    dlog.error(listConstructor.pos,\n+                               DiagnosticCode.MISMATCHING_ARRAY_LITERAL_VALUES, arrayType.size,\n+                               listConstructor.exprs.size());\n+                    return;\n+                }\n+                //TODO: check fillable values\n+                if (!types.hasFillerValue(arrayType.eType)) {\n+                    dlog.error(listConstructor.pos, DiagnosticCode.INVALID_LIST_CONSTRUCTOR, expType);", "originalCommit": "6a1ded361a9c36677290e97cd4a3ad1610dc21f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEwMzE2Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r379103163", "bodyText": "Check the error message on 281133b", "author": "KRVPerera", "createdAt": "2020-02-13T20:33:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjkzOTA2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk0MDQ1MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r376940450", "bodyText": "Shall we add the version?", "author": "MaryamZi", "createdAt": "2020-02-10T09:17:17Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -109,6 +110,31 @@\n     private Names names;\n     private int finiteTypeCount = 0;\n \n+    /**\n+     * Keep default values for basic types in String format.\n+     *", "originalCommit": "6a1ded361a9c36677290e97cd4a3ad1610dc21f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk0MDgxNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r376940817", "bodyText": "And shall we say filler instead of default?", "author": "MaryamZi", "createdAt": "2020-02-10T09:17:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk0MDQ1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg3OTc4NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r378879784", "bodyText": "added 1.1.2", "author": "KRVPerera", "createdAt": "2020-02-13T14:05:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk0MDQ1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk0MTA2Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r376941063", "bodyText": "Is type ever null?", "author": "MaryamZi", "createdAt": "2020-02-10T09:18:25Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,154 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {", "originalCommit": "6a1ded361a9c36677290e97cd4a3ad1610dc21f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgzNDQ3OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r377834478", "bodyText": "We only need to check if the return type is not nil right?", "author": "MaryamZi", "createdAt": "2020-02-11T18:59:55Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }", "originalCommit": "d7ffca3f2535a897d0e44911a0f4d7bff9869799", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE0Nzg4OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r378147889", "bodyText": "yes", "author": "KRVPerera", "createdAt": "2020-02-12T10:00:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgzNDQ3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgzNjQ2Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r377836466", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {\n          \n          \n            \n                                .allMatch(bVarSymbol -> bVarSymbol.defaultableParam)) {", "author": "MaryamZi", "createdAt": "2020-02-11T19:03:29Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }\n+            if (!initFunction.symbol.getParameters().stream()\n+                    .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {", "originalCommit": "d7ffca3f2535a897d0e44911a0f4d7bff9869799", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgzNzExOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r377837119", "bodyText": "Shall we avoid using streams btw?", "author": "MaryamZi", "createdAt": "2020-02-11T19:04:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgzNjQ2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg0NTQ5NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r377845495", "bodyText": "Do we need the null check for value space members? Can the value be null?", "author": "MaryamZi", "createdAt": "2020-02-11T19:19:58Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }\n+            if (!initFunction.symbol.getParameters().stream()\n+                    .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types.\n+     *  Singleton : As singleton can have one value that value should it self be a valid fill value\n+     *  Union :\n+     *          1. if nil is a member it is the fill values\n+     *          2. else all the values should belong to same type and the default value for that type\n+     *              should be a member of the union\n+     * @param type BFiniteType union or finite\n+     * @return\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        // For singleton types, that value is the implicit initial value\n+        if (type.valueSpace.size() == 1) {\n+            return true;\n+        }\n+\n+        // is first value null\n+        Iterator iterator = type.valueSpace.iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        if ((firstElement == null) || (firstElement.type.getKind() == TypeKind.NIL)) {", "originalCommit": "d7ffca3f2535a897d0e44911a0f4d7bff9869799", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODAzOTUwMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r378039502", "bodyText": "Also, instead of this can't our first check be isNullable like for union types before iterating through the value space?", "author": "MaryamZi", "createdAt": "2020-02-12T04:50:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg0NTQ5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE1MjY4OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r378152688", "bodyText": "let me check the null value.\nIsNullable for \"BFiniteType\" actually goes through every item in value space.\npublic boolean isNullable() {\n        return this.valueSpace.stream().anyMatch(v -> v.type.tag == TypeTags.NIL);\n}\nMay be we can remove nullable check in union type code inside loop and for first item. Let me check.", "author": "KRVPerera", "createdAt": "2020-02-12T10:09:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg0NTQ5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg0ODY2NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r377848664", "bodyText": "return getDefaultFillValue(expr.type);", "author": "MaryamZi", "createdAt": "2020-02-11T19:25:42Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }\n+            if (!initFunction.symbol.getParameters().stream()\n+                    .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types.\n+     *  Singleton : As singleton can have one value that value should it self be a valid fill value\n+     *  Union :\n+     *          1. if nil is a member it is the fill values\n+     *          2. else all the values should belong to same type and the default value for that type\n+     *              should be a member of the union\n+     * @param type BFiniteType union or finite\n+     * @return\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        // For singleton types, that value is the implicit initial value\n+        if (type.valueSpace.size() == 1) {\n+            return true;\n+        }\n+\n+        // is first value null\n+        Iterator iterator = type.valueSpace.iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        if ((firstElement == null) || (firstElement.type.getKind() == TypeKind.NIL)) {\n+            return true;\n+        }\n+\n+        boolean allMembersHaveSameType = true;\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value =  iterator.next();\n+            if (value == null) {\n+                return true;\n+            }\n+\n+            BType valueType = ((BLangExpression) value).type;\n+            if (valueType.getKind() == TypeKind.NIL) {\n+                return true;\n+            }\n+\n+            if (allMembersHaveSameType && !isSameType(valueType, firstElement.type)) {\n+                allMembersHaveSameType = false;\n+            }\n+\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        if (!allMembersHaveSameType) {\n+            return false;\n+        }\n+\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        // is first value is a valid fill value\n+        if (firstMember.getKind() == TypeKind.NIL) {\n+            return true;\n+        }\n+\n+        boolean allMembersHaveSameType = true;\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstMember);\n+        if (firstMember.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+\n+            Object value =  iterator.next();\n+            if (value == null) {\n+                return true;\n+            }\n+\n+            if (allMembersHaveSameType && !isSameType(firstMember, iterator.next())) {\n+                allMembersHaveSameType = false;\n+            }\n+\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        if (!allMembersHaveSameType) {\n+            return false;\n+        }\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BRecordType type) {\n+        for (BField field : type.fields) {\n+            if (field.symbol.defaultableParam) {\n+                continue;\n+            }\n+            if (!hasFillerValue(field.type)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean checkFillerValue(BArrayType type) {\n+        return hasFillerValue(type.eType);\n+    }\n+\n+    private String getDefaultFillValue(BLangExpression expr) {\n+        BType type = expr.type;\n+        return getDefaultFillValue(type);", "originalCommit": "d7ffca3f2535a897d0e44911a0f4d7bff9869799", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0MTE5MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r378041191", "bodyText": "Can't we just check !isSameType(valueType, firstElement.type) and return false here?", "author": "MaryamZi", "createdAt": "2020-02-12T04:59:04Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }\n+            if (!initFunction.symbol.getParameters().stream()\n+                    .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types.\n+     *  Singleton : As singleton can have one value that value should it self be a valid fill value\n+     *  Union :\n+     *          1. if nil is a member it is the fill values\n+     *          2. else all the values should belong to same type and the default value for that type\n+     *              should be a member of the union\n+     * @param type BFiniteType union or finite\n+     * @return\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        // For singleton types, that value is the implicit initial value\n+        if (type.valueSpace.size() == 1) {\n+            return true;\n+        }\n+\n+        // is first value null\n+        Iterator iterator = type.valueSpace.iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        if ((firstElement == null) || (firstElement.type.getKind() == TypeKind.NIL)) {\n+            return true;\n+        }\n+\n+        boolean allMembersHaveSameType = true;\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value =  iterator.next();\n+            if (value == null) {\n+                return true;\n+            }\n+\n+            BType valueType = ((BLangExpression) value).type;\n+            if (valueType.getKind() == TypeKind.NIL) {\n+                return true;\n+            }\n+\n+            if (allMembersHaveSameType && !isSameType(valueType, firstElement.type)) {\n+                allMembersHaveSameType = false;\n+            }", "originalCommit": "8c1d8da35d38db84786c9c1f2d6c088fc1779caa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODEzNTEzNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r378135135", "bodyText": "What if at the end or after this there is a nil value. Therefore I let the loop continue. If there is nil it is the fill value.", "author": "KRVPerera", "createdAt": "2020-02-12T09:38:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0MTE5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0Mjg5MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r378042891", "bodyText": "If this was true we would have already returned at https://github.com/ballerina-platform/ballerina-lang/pull/20749/files#diff-782094a79e6831ac57a34ad157af49c1R2678 right?", "author": "MaryamZi", "createdAt": "2020-02-12T05:08:10Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }\n+            if (!initFunction.symbol.getParameters().stream()\n+                    .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types.\n+     *  Singleton : As singleton can have one value that value should it self be a valid fill value\n+     *  Union :\n+     *          1. if nil is a member it is the fill values\n+     *          2. else all the values should belong to same type and the default value for that type\n+     *              should be a member of the union\n+     * @param type BFiniteType union or finite\n+     * @return\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        // For singleton types, that value is the implicit initial value\n+        if (type.valueSpace.size() == 1) {\n+            return true;\n+        }\n+\n+        // is first value null\n+        Iterator iterator = type.valueSpace.iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        if ((firstElement == null) || (firstElement.type.getKind() == TypeKind.NIL)) {\n+            return true;\n+        }\n+\n+        boolean allMembersHaveSameType = true;\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value =  iterator.next();\n+            if (value == null) {\n+                return true;\n+            }\n+\n+            BType valueType = ((BLangExpression) value).type;\n+            if (valueType.getKind() == TypeKind.NIL) {\n+                return true;\n+            }\n+\n+            if (allMembersHaveSameType && !isSameType(valueType, firstElement.type)) {\n+                allMembersHaveSameType = false;\n+            }\n+\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        if (!allMembersHaveSameType) {\n+            return false;\n+        }\n+\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        // is first value is a valid fill value\n+        if (firstMember.getKind() == TypeKind.NIL) {", "originalCommit": "8c1d8da35d38db84786c9c1f2d6c088fc1779caa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0Mjk2Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r378042966", "bodyText": "Again, can these be null?", "author": "MaryamZi", "createdAt": "2020-02-12T05:08:38Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }\n+            if (!initFunction.symbol.getParameters().stream()\n+                    .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types.\n+     *  Singleton : As singleton can have one value that value should it self be a valid fill value\n+     *  Union :\n+     *          1. if nil is a member it is the fill values\n+     *          2. else all the values should belong to same type and the default value for that type\n+     *              should be a member of the union\n+     * @param type BFiniteType union or finite\n+     * @return\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        // For singleton types, that value is the implicit initial value\n+        if (type.valueSpace.size() == 1) {\n+            return true;\n+        }\n+\n+        // is first value null\n+        Iterator iterator = type.valueSpace.iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        if ((firstElement == null) || (firstElement.type.getKind() == TypeKind.NIL)) {\n+            return true;\n+        }\n+\n+        boolean allMembersHaveSameType = true;\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value =  iterator.next();\n+            if (value == null) {\n+                return true;\n+            }\n+\n+            BType valueType = ((BLangExpression) value).type;\n+            if (valueType.getKind() == TypeKind.NIL) {\n+                return true;\n+            }\n+\n+            if (allMembersHaveSameType && !isSameType(valueType, firstElement.type)) {\n+                allMembersHaveSameType = false;\n+            }\n+\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        if (!allMembersHaveSameType) {\n+            return false;\n+        }\n+\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        // is first value is a valid fill value\n+        if (firstMember.getKind() == TypeKind.NIL) {\n+            return true;\n+        }\n+\n+        boolean allMembersHaveSameType = true;\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstMember);\n+        if (firstMember.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+\n+            Object value =  iterator.next();\n+            if (value == null) {", "originalCommit": "8c1d8da35d38db84786c9c1f2d6c088fc1779caa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODEzNTA3Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r378135076", "bodyText": "Let me remove. I think this should not be null", "author": "KRVPerera", "createdAt": "2020-02-12T09:38:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0Mjk2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0NDM2MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r378044361", "bodyText": "Is this set for record fields too? IINM, we usually check only a flag.", "author": "MaryamZi", "createdAt": "2020-02-12T05:16:15Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }\n+            if (!initFunction.symbol.getParameters().stream()\n+                    .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types.\n+     *  Singleton : As singleton can have one value that value should it self be a valid fill value\n+     *  Union :\n+     *          1. if nil is a member it is the fill values\n+     *          2. else all the values should belong to same type and the default value for that type\n+     *              should be a member of the union\n+     * @param type BFiniteType union or finite\n+     * @return\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        // For singleton types, that value is the implicit initial value\n+        if (type.valueSpace.size() == 1) {\n+            return true;\n+        }\n+\n+        // is first value null\n+        Iterator iterator = type.valueSpace.iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        if ((firstElement == null) || (firstElement.type.getKind() == TypeKind.NIL)) {\n+            return true;\n+        }\n+\n+        boolean allMembersHaveSameType = true;\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value =  iterator.next();\n+            if (value == null) {\n+                return true;\n+            }\n+\n+            BType valueType = ((BLangExpression) value).type;\n+            if (valueType.getKind() == TypeKind.NIL) {\n+                return true;\n+            }\n+\n+            if (allMembersHaveSameType && !isSameType(valueType, firstElement.type)) {\n+                allMembersHaveSameType = false;\n+            }\n+\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        if (!allMembersHaveSameType) {\n+            return false;\n+        }\n+\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        // is first value is a valid fill value\n+        if (firstMember.getKind() == TypeKind.NIL) {\n+            return true;\n+        }\n+\n+        boolean allMembersHaveSameType = true;\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstMember);\n+        if (firstMember.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+\n+            Object value =  iterator.next();\n+            if (value == null) {\n+                return true;\n+            }\n+\n+            if (allMembersHaveSameType && !isSameType(firstMember, iterator.next())) {\n+                allMembersHaveSameType = false;\n+            }\n+\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        if (!allMembersHaveSameType) {\n+            return false;\n+        }\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BRecordType type) {\n+        for (BField field : type.fields) {\n+            if (field.symbol.defaultableParam) {", "originalCommit": "8c1d8da35d38db84786c9c1f2d6c088fc1779caa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0NDc4NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r378044784", "bodyText": "IINM, this is not correct. According to the spec, fill member should be done only for lists.\ntype Foo record {\n   string s;\n};\n\nFoo[2] arr = [];\nThis should still fail IMO.", "author": "MaryamZi", "createdAt": "2020-02-12T05:18:26Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2563,196 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type == null) {\n+            return true;\n+        }\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (!hasFillerValue(initFunction.symbol.getReturnType())) {\n+                return false;\n+            }\n+            if (!initFunction.symbol.getParameters().stream()\n+                    .allMatch(bVarSymbol -> bVarSymbol.defaultableParam == true)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types.\n+     *  Singleton : As singleton can have one value that value should it self be a valid fill value\n+     *  Union :\n+     *          1. if nil is a member it is the fill values\n+     *          2. else all the values should belong to same type and the default value for that type\n+     *              should be a member of the union\n+     * @param type BFiniteType union or finite\n+     * @return\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        // For singleton types, that value is the implicit initial value\n+        if (type.valueSpace.size() == 1) {\n+            return true;\n+        }\n+\n+        // is first value null\n+        Iterator iterator = type.valueSpace.iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        if ((firstElement == null) || (firstElement.type.getKind() == TypeKind.NIL)) {\n+            return true;\n+        }\n+\n+        boolean allMembersHaveSameType = true;\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value =  iterator.next();\n+            if (value == null) {\n+                return true;\n+            }\n+\n+            BType valueType = ((BLangExpression) value).type;\n+            if (valueType.getKind() == TypeKind.NIL) {\n+                return true;\n+            }\n+\n+            if (allMembersHaveSameType && !isSameType(valueType, firstElement.type)) {\n+                allMembersHaveSameType = false;\n+            }\n+\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        if (!allMembersHaveSameType) {\n+            return false;\n+        }\n+\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        // is first value is a valid fill value\n+        if (firstMember.getKind() == TypeKind.NIL) {\n+            return true;\n+        }\n+\n+        boolean allMembersHaveSameType = true;\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstMember);\n+        if (firstMember.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+\n+            Object value =  iterator.next();\n+            if (value == null) {\n+                return true;\n+            }\n+\n+            if (allMembersHaveSameType && !isSameType(firstMember, iterator.next())) {\n+                allMembersHaveSameType = false;\n+            }\n+\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        if (!allMembersHaveSameType) {\n+            return false;\n+        }\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BRecordType type) {\n+        for (BField field : type.fields) {\n+            if (field.symbol.defaultableParam) {\n+                continue;\n+            }\n+            if (!hasFillerValue(field.type)) {", "originalCommit": "8c1d8da35d38db84786c9c1f2d6c088fc1779caa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMzNDAzMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r379334030", "bodyText": "Commit f21bca4\nshould address this.", "author": "KRVPerera", "createdAt": "2020-02-14T09:41:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0NDc4NA=="}], "type": "inlineReview"}, {"oid": "7e45bf2f4e93f2b9cd1ad9615ddb89a52cc12cba", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7e45bf2f4e93f2b9cd1ad9615ddb89a52cc12cba", "message": "Fix invalid logic", "committedDate": "2020-02-13T05:45:25Z", "type": "forcePushed"}, {"oid": "7b99ac91ded41ae1f8f9b3fdf55cf585c9370b51", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7b99ac91ded41ae1f8f9b3fdf55cf585c9370b51", "message": "Refactor fill value check for Union type\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-13T15:29:22Z", "type": "forcePushed"}, {"oid": "5dda7566d1f2b9bf2c0ccfd721319c6a99b40acb", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5dda7566d1f2b9bf2c0ccfd721319c6a99b40acb", "message": "Change error for list-expr usage without filler\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-14T04:43:26Z", "type": "forcePushed"}, {"oid": "f21bca4d1e537732576a0558486343c55dd1def9", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f21bca4d1e537732576a0558486343c55dd1def9", "message": "Fix filler value check logic for Records\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-14T09:37:59Z", "type": "forcePushed"}, {"oid": "c3c97829d04a244c24dec385c28f71566407be08", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c3c97829d04a244c24dec385c28f71566407be08", "message": "Incorporate code quality feedback on code review", "committedDate": "2020-02-14T10:41:04Z", "type": "forcePushed"}, {"oid": "3d15f2572961cd44fb9146eabfa3b3131e70de7e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3d15f2572961cd44fb9146eabfa3b3131e70de7e", "message": "Incorporate feedback on code review\n\nRemove extra null checks. Refacor the logic related to record type\nfilling.  Change the error message for type usage in list-expr without\nvalid filler values. Add a \"nullable\" cache to finitie type.", "committedDate": "2020-02-14T10:43:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDEzNzIwNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r380137205", "bodyText": "Comments are invalid now?", "author": "MaryamZi", "createdAt": "2020-02-17T11:49:35Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java", "diffHunk": "@@ -842,13 +850,15 @@ protected void rangeCheck(long index, int size) {\n     protected void fillerValueCheck(int index, int size) {\n         // if there has been values added beyond the current index, that means filler values\n         // has already been checked. Therefore no need to check again.\n-        if (this.size >= index) {", "originalCommit": "3d15f2572961cd44fb9146eabfa3b3131e70de7e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0MzQzMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r380143430", "bodyText": "Shouldn't the getter return an unmodifiable set too?", "author": "MaryamZi", "createdAt": "2020-02-17T12:04:15Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/model/types/BFiniteType.java", "diffHunk": "@@ -37,9 +37,11 @@\n  */\n public class BFiniteType extends BType implements FiniteType {\n \n-    public Set<BLangExpression> valueSpace;\n+    private Set<BLangExpression> valueSpace;", "originalCommit": "3d15f2572961cd44fb9146eabfa3b3131e70de7e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0NDg5Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r380144896", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @since 1.1.2\n          \n          \n            \n                 * @since 1.2.0", "author": "MaryamZi", "createdAt": "2020-02-17T12:07:38Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -109,6 +110,32 @@\n     private Names names;\n     private int finiteTypeCount = 0;\n \n+    /**\n+     * Keep filler value for basic types in String format.\n+     *\n+     * @since 1.1.2", "originalCommit": "3d15f2572961cd44fb9146eabfa3b3131e70de7e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0NzA1NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r380147055", "bodyText": "This can be\n    return (type.tsymbol.flags & Flags.ABSTRACT) != Flags.ABSTRACT;\nright?", "author": "MaryamZi", "createdAt": "2020-02-17T12:12:46Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2564,166 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }", "originalCommit": "3d15f2572961cd44fb9146eabfa3b3131e70de7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQ4NDg3OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r380484878", "bodyText": "Even if the object is not an abstract object we still need to do some checks or parameters in the initializer function. But I changed the logic giving importance to abstraction check. Can you check the new logic whether I got your point correctly? ff0acc0", "author": "KRVPerera", "createdAt": "2020-02-18T06:48:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0NzA1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0NzM1Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r380147352", "bodyText": "We can then remove this else and move out this block?", "author": "MaryamZi", "createdAt": "2020-02-17T12:13:27Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2564,166 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {", "originalCommit": "3d15f2572961cd44fb9146eabfa3b3131e70de7e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0Nzk3NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r380147975", "bodyText": "IINM, this can never be just error. It's either nil or a union with error. Just checking initFunction.symbol.getReturnType().getKind() != TypeKind.NIL should be enough?", "author": "MaryamZi", "createdAt": "2020-02-17T12:14:46Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2564,166 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {", "originalCommit": "3d15f2572961cd44fb9146eabfa3b3131e70de7e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE1NDIzNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r380154234", "bodyText": "IMO, we can remove this.", "author": "MaryamZi", "createdAt": "2020-02-17T12:28:54Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2564,166 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+                return false;\n+            }\n+            for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+                if (!bVarSymbol.defaultableParam) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types. Singleton : As singleton can have one value that value should it self be a valid fill\n+     * value Union : 1. if nil is a member it is the fill values 2. else all the values should belong to same type and\n+     * the default value for that type should be a member of the union precondition : value space should have at least\n+     * one element\n+     *\n+     * @param type BFiniteType union or finite\n+     * @return boolean whether type has a valid filler value or not\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+\n+        // For singleton types, that value is the implicit initial value\n+        if (type.getValueSpace().size() == 1) {\n+            return true;\n+        }\n+\n+        Iterator iterator = type.getValueSpace().iterator();\n+        if (!iterator.hasNext()) { // sanity check this cannot be\n+            return false;\n+        }", "originalCommit": "3d15f2572961cd44fb9146eabfa3b3131e70de7e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE1NTgzNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r380155835", "bodyText": "Can we extract out firstElement.type to a variable?", "author": "MaryamZi", "createdAt": "2020-02-17T12:32:39Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2564,166 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+                return false;\n+            }\n+        } else {\n+            if (initFunction.symbol.getReturnType().getKind() == TypeKind.ERROR) {\n+                return false;\n+            }\n+            if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+                return false;\n+            }\n+            for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+                if (!bVarSymbol.defaultableParam) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types. Singleton : As singleton can have one value that value should it self be a valid fill\n+     * value Union : 1. if nil is a member it is the fill values 2. else all the values should belong to same type and\n+     * the default value for that type should be a member of the union precondition : value space should have at least\n+     * one element\n+     *\n+     * @param type BFiniteType union or finite\n+     * @return boolean whether type has a valid filler value or not\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+\n+        // For singleton types, that value is the implicit initial value\n+        if (type.getValueSpace().size() == 1) {\n+            return true;\n+        }\n+\n+        Iterator iterator = type.getValueSpace().iterator();\n+        if (!iterator.hasNext()) { // sanity check this cannot be\n+            return false;\n+        }\n+        boolean defaultFillValuePresent = false;\n+\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value =  iterator.next();\n+            BType valueType = ((BLangExpression) value).type;\n+            if (!isSameType(valueType, firstElement.type)) {", "originalCommit": "3d15f2572961cd44fb9146eabfa3b3131e70de7e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ff0acc05501340c2064c3bb1b3211752955782ad", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ff0acc05501340c2064c3bb1b3211752955782ad", "message": "Incorporate code review feedback", "committedDate": "2020-02-17T20:56:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc2MTY2Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r381761662", "bodyText": "Can we validate if this works for constants?\nconst ZERO = 0;\n\ntype Foo ZERO|1|2;", "author": "MaryamZi", "createdAt": "2020-02-20T05:12:57Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2564,160 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+            return false;\n+        }\n+\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            return true;\n+        }\n+        if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+            return false;\n+        }\n+\n+        for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+            if (!bVarSymbol.defaultableParam) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types. Singleton : As singleton can have one value that value should it self be a valid fill\n+     * value Union : 1. if nil is a member it is the fill values 2. else all the values should belong to same type and\n+     * the default value for that type should be a member of the union precondition : value space should have at least\n+     * one element\n+     *\n+     * @param type BFiniteType union or finite\n+     * @return boolean whether type has a valid filler value or not\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+\n+        // For singleton types, that value is the implicit initial value\n+        if (type.getValueSpace().size() == 1) {\n+            return true;\n+        }\n+\n+        boolean defaultFillValuePresent = false;\n+\n+        Iterator iterator = type.getValueSpace().iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        BType firstElementType = firstElement.type;\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value =  iterator.next();\n+            BType valueType = ((BLangExpression) value).type;\n+            if (!isSameType(valueType, firstElementType)) {\n+                return false;\n+            }\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstMember);\n+        if (firstMember.toString().equals(defaultFillValue)) {", "originalCommit": "ff0acc05501340c2064c3bb1b3211752955782ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEwMDc1Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382100753", "bodyText": "fixed test case added\n7d525fc", "author": "KRVPerera", "createdAt": "2020-02-20T16:09:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc2MTY2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc2MjUwNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r381762506", "bodyText": "This fillerValueCheck() method is called for each and every add operation. So could this be an overhead?\nSince hasFillerValue needs to be calculated only once for a given type, can we move this flag to the array-type, and have it calculated only once during the initialisation of the type?", "author": "SupunS", "createdAt": "2020-02-20T05:14:41Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java", "diffHunk": "@@ -840,15 +848,15 @@ protected void rangeCheck(long index, int size) {\n \n     @Override\n     protected void fillerValueCheck(int index, int size) {\n-        // if there has been values added beyond the current index, that means filler values\n-        // has already been checked. Therefore no need to check again.\n-        if (this.size >= index) {\n-            return;\n+        if (!hasFillerValue.isPresent()) {", "originalCommit": "ff0acc05501340c2064c3bb1b3211752955782ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA4NTYxOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382085618", "bodyText": "fixed by c0998bf", "author": "KRVPerera", "createdAt": "2020-02-20T15:46:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc2MjUwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3MjYzNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r381772635", "bodyText": "Wondering if keeping this in the String format is the best approach? Can't we use the value itself and compare, based on the assumption that they will only be used for comparison with either literals or constant refs?", "author": "MaryamZi", "createdAt": "2020-02-20T05:35:35Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2537,4 +2564,160 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+            return false;\n+        }\n+\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            return true;\n+        }\n+        if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+            return false;\n+        }\n+\n+        for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+            if (!bVarSymbol.defaultableParam) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types. Singleton : As singleton can have one value that value should it self be a valid fill\n+     * value Union : 1. if nil is a member it is the fill values 2. else all the values should belong to same type and\n+     * the default value for that type should be a member of the union precondition : value space should have at least\n+     * one element\n+     *\n+     * @param type BFiniteType union or finite\n+     * @return boolean whether type has a valid filler value or not\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+\n+        // For singleton types, that value is the implicit initial value\n+        if (type.getValueSpace().size() == 1) {\n+            return true;\n+        }\n+\n+        boolean defaultFillValuePresent = false;\n+\n+        Iterator iterator = type.getValueSpace().iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        BType firstElementType = firstElement.type;\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value =  iterator.next();\n+            BType valueType = ((BLangExpression) value).type;\n+            if (!isSameType(valueType, firstElementType)) {\n+                return false;\n+            }\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        boolean defaultFillValuePresent = false;\n+\n+        // is first value is a valid fill value\n+        String defaultFillValue = getDefaultFillValue(firstMember);\n+        if (firstMember.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value = iterator.next();\n+\n+            if (!isSameType(firstMember, iterator.next())) {\n+                return false;\n+            }\n+\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BRecordType type) {\n+        for (BField field : type.fields) {\n+            if (Symbols.isFlagOn(field.symbol.flags, Flags.OPTIONAL)) {\n+                continue;\n+            }\n+            if (Symbols.isFlagOn(field.symbol.flags, Flags.REQUIRED)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean checkFillerValue(BArrayType type) {\n+        return hasFillerValue(type.eType);\n+    }\n+\n+    private String getDefaultFillValue(BLangExpression expr) {\n+        return getDefaultFillValue(expr.type);\n+    }\n+\n+    private String getDefaultFillValue(BType type) {", "originalCommit": "ff0acc05501340c2064c3bb1b3211752955782ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE0Nzk4NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382147985", "bodyText": "If the integer is '5' the valid fill value should be '0' for an int. Need to get the default value or implicit default value for int type which is zero.\nI have added a negative test case for this.\nTest Case:  https://github.com/ballerina-platform/ballerina-lang/pull/20749/files#diff-65f99a2264d6173185afec0d71e151c6R63\nError Message: https://github.com/ballerina-platform/ballerina-lang/pull/20749/files#diff-7319ccb85e364b3233fb96f11c424f29R212", "author": "KRVPerera", "createdAt": "2020-02-20T17:28:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3MjYzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQxNzkwNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382417905", "bodyText": "Note: The code is written similar to run-time check. \n  \n    \n      ballerina-lang/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java\n    \n    \n         Line 1787\n      in\n      7e0d467\n    \n    \n    \n    \n\n        \n          \n           if (firstElement instanceof String) { \n        \n    \n  \n\n\nThe plan is to replace string enum with objects and also in accordance with spec. This may require calling initialiser methods to create zero value objects for every type. Should handle all basic types. Finally, it will be like src.equals(target)", "author": "KRVPerera", "createdAt": "2020-02-21T06:35:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3MjYzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3NTQ3MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r381775470", "bodyText": "Shall we remove the extra lines?", "author": "MaryamZi", "createdAt": "2020-02-20T05:41:18Z", "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/SealedArrayTest.java", "diffHunk": "@@ -36,177 +36,117 @@\n  */\n public class SealedArrayTest {\n \n-    private CompileResult compileResult, resultNegative, semanticsNegative;\n+    private CompileResult compileResult, resultNegative, semanticsNegative, listExprNegative;\n \n     @BeforeClass\n     public void setup() {\n         compileResult = BCompileUtil.compile(\"test-src/statements/arrays/sealed-array.bal\");\n         resultNegative = BCompileUtil.compile(\"test-src/statements/arrays/sealed-array-negative.bal\");\n+        listExprNegative = BCompileUtil.compile(\"test-src/statements/arrays/sealed_array_listexpr_negative.bal\");\n         semanticsNegative = BCompileUtil.compile(\"test-src/statements/arrays/sealed-array-semantics-negative\" +\n                 \".bal\");\n     }\n \n     @Test\n     public void testCreateIntegerSealedArray() {\n-        BValue[] returnValues = BRunUtil.invoke(compileResult, \"createIntSealedArray\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createIntSealedArray\");\n \n-        returnValues = BRunUtil.invoke(compileResult, \"createIntSealedArrayWithLabel\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createIntAutoFilledSealedArray\");\n \n-        returnValues = BRunUtil.invoke(compileResult, \"createIntDefaultSealedArray\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(returnValues[0].stringValue(), \"[0, 0, 0, 0, 0]\", \"Length didn't match\");\n-        Assert.assertEquals(((BInteger) returnValues[1]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createIntSealedArrayWithLabel\");\n+\n+        BRunUtil.invoke(compileResult, \"createIntDefaultSealedArray\");\n     }\n \n     @Test\n     public void testCreateBooleanSealedArray() {\n-        BValue[] returnValues = BRunUtil.invoke(compileResult, \"createBoolSealedArray\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createBoolSealedArray\");\n \n-        returnValues = BRunUtil.invoke(compileResult, \"createBoolSealedArrayWithLabel\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createBoolAutoFilledSealedArray\");\n \n-        returnValues = BRunUtil.invoke(compileResult, \"createBoolDefaultSealedArray\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(returnValues[0].stringValue(),\n-                \"[false, false, false, false, false]\", \"Length didn't match\");\n-        Assert.assertEquals(((BInteger) returnValues[1]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createBoolSealedArrayWithLabel\");\n+\n+        BRunUtil.invoke(compileResult, \"createBoolDefaultSealedArray\");\n     }\n \n     @Test\n     public void testCreateFloatSealedArray() {\n-        BValue[] returnValues = BRunUtil.invoke(compileResult, \"createFloatSealedArray\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createFloatSealedArray\");\n \n-        returnValues = BRunUtil.invoke(compileResult, \"createFloatSealedArrayWithLabel\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(((BInteger) returnValues[0]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createFloatAutoFilledSealedArray\");\n \n-        returnValues = BRunUtil.invoke(compileResult, \"createFloatDefaultSealedArray\");\n-        Assert.assertFalse(\n-                returnValues == null || returnValues.length == 0 || returnValues[0] == null, \"Invalid Return Values.\");\n-        Assert.assertEquals(returnValues[0].stringValue(), \"[0.0, 0.0, 0.0, 0.0, 0.0]\", \"Length didn't match\");\n-        Assert.assertEquals(((BInteger) returnValues[1]).intValue(), 5, \"Length didn't match\");\n+        BRunUtil.invoke(compileResult, \"createFloatSealedArrayWithLabel\");\n+", "originalCommit": "ff0acc05501340c2064c3bb1b3211752955782ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA5ODI0MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382098241", "bodyText": "Fixed ab2afb7", "author": "KRVPerera", "createdAt": "2020-02-20T16:05:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3NTQ3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3NTU5Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r381775593", "bodyText": "Invalid comment?", "author": "MaryamZi", "createdAt": "2020-02-20T05:41:34Z", "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/SealedArrayTest.java", "diffHunk": "@@ -282,51 +222,99 @@ public void testNegativeSealedArrays() {\n         BAssertUtil.validateError(resultNegative, 0, \"variable 'sealedArray1' is not initialized\", 19, 5);\n     }\n \n+    // TODO : uncomment", "originalCommit": "ff0acc05501340c2064c3bb1b3211752955782ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA5NjkxNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382096914", "bodyText": "Fixed b76a0ff", "author": "KRVPerera", "createdAt": "2020-02-20T16:03:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3NTU5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3NTg1NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r381775854", "bodyText": "Can we have these in a single line?", "author": "MaryamZi", "createdAt": "2020-02-20T05:42:08Z", "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/SealedArrayTest.java", "diffHunk": "@@ -282,51 +222,99 @@ public void testNegativeSealedArrays() {\n         BAssertUtil.validateError(resultNegative, 0, \"variable 'sealedArray1' is not initialized\", 19, 5);\n     }\n \n+    // TODO : uncomment\n+    @Test()\n+    public void testNegativeAutoFillSealedArray() {\n+        Assert.assertEquals(listExprNegative.getErrorCount(), 11);\n+        BAssertUtil.validateError(listExprNegative, 0,\n+                                  \"invalid usage of list constructor: type 'Person[5]' does not have a filler value\",\n+                                  24,\n+                                  19);", "originalCommit": "ff0acc05501340c2064c3bb1b3211752955782ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA5NjgwMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382096800", "bodyText": "Fixed b76a0ff", "author": "KRVPerera", "createdAt": "2020-02-20T16:03:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3NTg1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3OTc4MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r381779781", "bodyText": "Incorrect version?", "author": "MaryamZi", "createdAt": "2020-02-20T05:50:11Z", "path": "tests/jballerina-unit-test/src/test/java/org/ballerinalang/test/statements/arrays/ArrayFillTestRuntime.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.test.statements.arrays;\n+\n+import org.ballerinalang.test.util.BCompileUtil;\n+import org.ballerinalang.test.util.CompileResult;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * Test cases for filling the elements of the array with its type's implicit initial value.\n+ *\n+ * @since 1.1.1", "originalCommit": "ff0acc05501340c2064c3bb1b3211752955782ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA5NjczMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382096733", "bodyText": "fixed b76a0ff", "author": "KRVPerera", "createdAt": "2020-02-20T16:03:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3OTc4MQ=="}], "type": "inlineReview"}, {"oid": "af14271c90a2a56d7fda35b055a4840553985ad9", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/af14271c90a2a56d7fda35b055a4840553985ad9", "message": "Refactor test cases for list-ctor-expression\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-20T15:43:49Z", "type": "forcePushed"}, {"oid": "17f429daf9d5785fbeee7d411c55b2c892bda422", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/17f429daf9d5785fbeee7d411c55b2c892bda422", "message": "Fix CheckStyle Audit import separation\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-20T17:15:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5NzE4MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382397181", "bodyText": "Do we need to check this here?\nIsn't fillValues always called after fillerValueCheck?", "author": "MaryamZi", "createdAt": "2020-02-21T04:55:12Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/values/ArrayValueImpl.java", "diffHunk": "@@ -808,8 +813,9 @@ protected void fillValues(int index) {\n             case TypeTags.BOOLEAN_TAG:\n                 return;\n             default:\n-                Arrays.fill(refValues, size, index, elementType.getZeroValue());\n-\n+                if (arrayType.hasFillerValue()) {", "originalCommit": "17f429daf9d5785fbeee7d411c55b2c892bda422", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQxNDg3Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382414876", "bodyText": "This is not true for code coming from desugar.\nAs an example.\n     AbstractPersonObject[5][] y = [];\n     AbstractPersonObject e1 = new Employee(\"John\", \"Doe\");\n     y[0] = [e1];\n     AbstractPersonObject[][5] r = [];\n     r[0] = [e1, e1, e1, e1, e1];\n\nr[0] = [e1, e1, e1, e1, e1] expands by first creating a sealed array. Then adding values.\nAbstractPersonObject[5] = [] \n\nThis is not allowed we cannot fill this by 5 AbstractPersonObject s. If user write this code it will give a compiler error . But since this is tool generated implementation we cannot error out this.\nfillerValueCheck error out only if there is a need for filling. Consecutive inserts should not fail too which is guranteed by index > size condition. Since this array size is already 5 as generated by desugar fillerValueCheck at runtime will not give an error.\nBir Dump:\nhttps://gist.github.com/KRVPerera/92dec4c3fd1eee166ba88dd891dd1163", "author": "KRVPerera", "createdAt": "2020-02-21T06:21:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5NzE4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQwNzM3Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382407373", "bodyText": "We seem to have methods with different namescheckFillerValue, hasFillerValue, etc. across the class for similar checks. Shall we revisit these and group them together?", "author": "MaryamZi", "createdAt": "2020-02-21T05:46:37Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -109,6 +110,35 @@\n     private Names names;\n     private int finiteTypeCount = 0;\n \n+    private boolean checkFillerValue(BUnionType type) {", "originalCommit": "17f429daf9d5785fbeee7d411c55b2c892bda422", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQxNjExMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382416111", "bodyText": "hasFillerValue is the public method which calls checkfillerValue helper methods sometime recursively. I will try to refactor.", "author": "KRVPerera", "createdAt": "2020-02-21T06:27:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQwNzM3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQwNzQ1NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r382407454", "bodyText": "What about when the value space has more than one value but are all of the same type?", "author": "MaryamZi", "createdAt": "2020-02-21T05:46:59Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2553,4 +2583,182 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        if (type.tag < TypeTags.RECORD) {\n+            return true;\n+        }\n+        switch (type.tag) {\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+            return false;\n+        }\n+\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            return true;\n+        }\n+        if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+            return false;\n+        }\n+\n+        for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+            if (!bVarSymbol.defaultableParam) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types. Singleton : As singleton can have one value that value should it self be a valid fill\n+     * value Union : 1. if nil is a member it is the fill values 2. else all the values should belong to same type and\n+     * the default value for that type should be a member of the union precondition : value space should have at least\n+     * one element\n+     *\n+     * @param type BFiniteType union or finite\n+     * @return boolean whether type has a valid filler value or not\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+\n+        // For singleton types, that value is the implicit initial value\n+        if (type.getValueSpace().size() == 1) {\n+            return true;\n+        }\n+\n+        boolean defaultFillValuePresent = false;\n+\n+        Iterator iterator = type.getValueSpace().iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        BType firstElementType = firstElement.type;\n+        String defaultFillValue = getDefaultFillValue(firstElement);\n+        if (defaultFillValue.equals(DefaultValues.UNKNOWN.getValue())) {\n+            return false;\n+        }\n+        if (firstElement.toString().equals(defaultFillValue)) {\n+            defaultFillValuePresent = true;\n+        }\n+\n+        while (iterator.hasNext()) {\n+            Object value = iterator.next();\n+            BType valueType = ((BLangExpression) value).type;\n+            if (!isSameType(valueType, firstElementType)) {\n+                return false;\n+            }\n+            if (!defaultFillValuePresent && value.toString().equals(defaultFillValue)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+        return defaultFillValuePresent;\n+    }\n+\n+    private String getDefaultFillValue(BType type) {\n+        switch(type.getKind()) {\n+            case INT:\n+            case BYTE:\n+                return DefaultValues.INTEGER.getValue();\n+            case STRING:\n+                return DefaultValues.STRING.getValue();\n+            case DECIMAL:\n+            case FLOAT:\n+                return DefaultValues.FLOAT.getValue();\n+            case BOOLEAN:\n+                return DefaultValues.BOOLEAN.getValue();\n+            case NIL:\n+                return DefaultValues.NIL.getValue();\n+            case ERROR:\n+            case TYPEDESC:\n+                return DefaultValues.UNKNOWN.getValue();\n+            default:\n+                if (type instanceof BFiniteType) {\n+                    return getDefaultFillValue((BFiniteType) type);\n+                }\n+                return DefaultValues.UNKNOWN.getValue();\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BRecordType type) {\n+        for (BField field : type.fields) {\n+            if (Symbols.isFlagOn(field.symbol.flags, Flags.OPTIONAL)) {\n+                continue;\n+            }\n+            if (Symbols.isFlagOn(field.symbol.flags, Flags.REQUIRED)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean checkFillerValue(BArrayType type) {\n+        if (type.size == -1) {\n+            return true;\n+        }\n+        return hasFillerValue(type.eType);\n+    }\n+\n+    private String getDefaultFillValue(BLangExpression expr) {\n+        return getDefaultFillValue(expr.type);\n+    }\n+\n+    private String getDefaultFillValue(BFiniteType finiteType) {\n+        if (finiteType.getValueSpace().size() == 1) {\n+            for (BLangExpression valueLiteral : finiteType.getValueSpace()) {\n+                if (!(valueLiteral instanceof BLangLiteral)) {\n+                    return DefaultValues.UNKNOWN.getValue();\n+                }\n+                return valueLiteral.toString();\n+            }\n+        }\n+        return DefaultValues.UNKNOWN.getValue();", "originalCommit": "17f429daf9d5785fbeee7d411c55b2c892bda422", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE0NjgxNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r383146816", "bodyText": "isNullable call", "author": "KRVPerera", "createdAt": "2020-02-24T09:13:26Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/model/types/BFiniteType.java", "diffHunk": "@@ -111,4 +114,11 @@ public boolean isAnydata() {\n         this.isAnyData = Optional.of(true);\n         return true;\n     }\n+\n+    public void addValue(BLangExpression value) {\n+        this.valueSpace.add(value);\n+        if (!nullable && (value.type.tag == TypeTags.NIL)) {", "originalCommit": "17f429daf9d5785fbeee7d411c55b2c892bda422", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "44c71470244d611e03adcc4f5fec68eccf5669bb", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/44c71470244d611e03adcc4f5fec68eccf5669bb", "message": "Add list-expr filler value check at compile time\n\nWhen we create a array of size x with list-expr if the user does not\nprovide x number of elements but some y (<x) in list-expr compiler\nneeds to auto fill x-y number of elements in the array\n\nPrevious check to prevent this when there is a size mismatch in\nlist-expr and array size (x != y) is removed and additional fill value\ncheck is added\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-25T09:50:31Z", "type": "commit"}, {"oid": "5463e66362a78d6e556e803b56f81121f729d195", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5463e66362a78d6e556e803b56f81121f729d195", "message": "Add run time support for list-expr auto filling\n\nAfter compile time fill value check is done run time needs to actually\nfill the values. Since previously we were not handling situation at\ncompile time object filling is enforced now at compile time\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-25T09:50:31Z", "type": "commit"}, {"oid": "304b6202f2fde0ebc346d1788fd44d51e65d5093", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/304b6202f2fde0ebc346d1788fd44d51e65d5093", "message": "Fix negative test cases to accept list-expr filling\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-25T09:50:32Z", "type": "commit"}, {"oid": "910f7fbd9babe3a83236bdcd0595f7aca1f94de1", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/910f7fbd9babe3a83236bdcd0595f7aca1f94de1", "message": "Add list-expr auto fill test cases\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-25T09:50:32Z", "type": "commit"}, {"oid": "6b5a6a9955abd5ec41010933ba5eb3ebaec897e8", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6b5a6a9955abd5ec41010933ba5eb3ebaec897e8", "message": "Update compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\r\n\r\nCode review suggestion to improve doc comment\n\nCo-Authored-By: kalaiyarasiganeshalingam <ashakalai31@gmail.com>", "committedDate": "2020-02-25T09:50:32Z", "type": "commit"}, {"oid": "159db5d3607b5960f1698dab1ed480b7c0363c72", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/159db5d3607b5960f1698dab1ed480b7c0363c72", "message": "Change license header to 2020\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-25T09:50:32Z", "type": "commit"}, {"oid": "5cf86031eacffe34b57eed9c33f94d27a7c6ff14", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5cf86031eacffe34b57eed9c33f94d27a7c6ff14", "message": "Incorporate feedback on code review\n\nRemove extra null checks. Refacor the logic related to record type\nfilling.  Change the error message for type usage in list-expr without\nvalid filler values. Add a \"nullable\" cache to finitie type.", "committedDate": "2020-02-25T09:50:32Z", "type": "commit"}, {"oid": "cacda240e52e7d7387d6681d50ef74df3e39cd3b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/cacda240e52e7d7387d6681d50ef74df3e39cd3b", "message": "Incorporate code review feedback", "committedDate": "2020-02-25T09:50:33Z", "type": "commit"}, {"oid": "a20ba46ac1072a72ea0ff2a761d2595dff440f5d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a20ba46ac1072a72ea0ff2a761d2595dff440f5d", "message": "Cache runtime filler value check in BArrayType\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-25T09:50:33Z", "type": "commit"}, {"oid": "f238554650314bf495aca1e84c4297d07c2eae98", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f238554650314bf495aca1e84c4297d07c2eae98", "message": "Fix filler value check for unions with constants\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-25T09:50:33Z", "type": "commit"}, {"oid": "8c19d9e17da81716ef0cb8a4124481f9990367d0", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8c19d9e17da81716ef0cb8a4124481f9990367d0", "message": "Remove multi-dim dynamic array filler-value check\n\nThis will not give syntax errors for multidimensional arrays with\ndynamic arrays which does not need filler values. This allow user to\ncreate fixed size (sealed) arrays with abstract objects but with inner\nmost dimension is dynamic array. Run time check will still run to make\nsure dynamic automatic array fill by compiler is not allowed. User must\ngive valid objects at runtime to these arrays.\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-25T09:50:33Z", "type": "commit"}, {"oid": "21889df2928eaeab2b33dd7a4548bc69e0eb77c4", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/21889df2928eaeab2b33dd7a4548bc69e0eb77c4", "message": "Improve filler-value check for BFiniteType\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-25T09:50:34Z", "type": "commit"}, {"oid": "a6821534b9d61b6259bceca2ca9fc8248d6eb71f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a6821534b9d61b6259bceca2ca9fc8248d6eb71f", "message": "Refactor test cases for list-ctor-expression\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-25T09:50:34Z", "type": "commit"}, {"oid": "1a5426f3a7cd14ef99f007fc7854f43774c836ef", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1a5426f3a7cd14ef99f007fc7854f43774c836ef", "message": "Fix CheckStyle Audit import separation\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-25T09:50:34Z", "type": "commit"}, {"oid": "90ccc20df850f617d1f355c1e786ef7ea9d0d9fd", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/90ccc20df850f617d1f355c1e786ef7ea9d0d9fd", "message": "Improve union type filler value check logic\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-25T09:50:34Z", "type": "forcePushed"}, {"oid": "2d67c3899c76d1080418067c6b3570f40011eb05", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2d67c3899c76d1080418067c6b3570f40011eb05", "message": "Improve union type filler value check logic\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-25T10:18:26Z", "type": "forcePushed"}, {"oid": "e493306b2169e6eb276e902de8689b1c2cce1b37", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e493306b2169e6eb276e902de8689b1c2cce1b37", "message": "Improve union type filler value check logic\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-25T10:37:38Z", "type": "commit"}, {"oid": "e493306b2169e6eb276e902de8689b1c2cce1b37", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e493306b2169e6eb276e902de8689b1c2cce1b37", "message": "Improve union type filler value check logic\n\nSigned-off-by: KRVPerera <rukshan.viduranga@gmail.com>", "committedDate": "2020-02-25T10:37:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI3MjA3MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r384272071", "bodyText": "The following should work right?\nconst FOO = \"foo\";\nconst BAR = \"bar\";\n\ntype FooBar FOO|BAR;\n\npublic function main() {\n    (map<FooBar>|map<string>)[2] x = [];\n}\nI guess it won't work with the isValueType check?", "author": "MaryamZi", "createdAt": "2020-02-26T04:43:18Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2553,4 +2565,150 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        switch (type.tag) {\n+            case TypeTags.INT:\n+            case TypeTags.BYTE:\n+            case TypeTags.FLOAT:\n+            case TypeTags.DECIMAL:\n+            case TypeTags.STRING:\n+            case TypeTags.BOOLEAN:\n+            case TypeTags.JSON:\n+            case TypeTags.XML:\n+            case TypeTags.TABLE:\n+            case TypeTags.NIL:\n+            case TypeTags.ANYDATA:\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+            return false;\n+        }\n+\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            return true;\n+        }\n+        if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+            return false;\n+        }\n+\n+        for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+            if (!bVarSymbol.defaultableParam) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types. Singleton : As singleton can have one value that value should it self be a valid fill\n+     * value Union : 1. if nil is a member it is the fill values 2. else all the values should belong to same type and\n+     * the default value for that type should be a member of the union precondition : value space should have at least\n+     * one element\n+     *\n+     * @param type BFiniteType union or finite\n+     * @return boolean whether type has a valid filler value or not\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        if (type.getValueSpace().size() == 1) { // For singleton types, that value is the implicit initial value\n+            return true;\n+        }\n+        Iterator iterator = type.getValueSpace().iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        boolean defaultFillValuePresent = isImplicitDefaultValue(firstElement);\n+\n+        while (iterator.hasNext()) {\n+            BLangExpression value = (BLangExpression) iterator.next();\n+            if (!isSameType(value.type, firstElement.type)) {\n+                return false;\n+            }\n+            if (!defaultFillValuePresent && isImplicitDefaultValue(value)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        while (iterator.hasNext()) {\n+            if (!isSameType(firstMember, iterator.next())) {\n+                return false;\n+            }\n+        }\n+        return isValueType(firstMember) && hasFillerValue(firstMember);", "originalCommit": "e493306b2169e6eb276e902de8689b1c2cce1b37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI4NjQyNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r384286427", "bodyText": "Shall we create an issue for this?", "author": "hasithaa", "createdAt": "2020-02-26T05:51:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI3MjA3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI5MzcwMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r384293702", "bodyText": "Created #21251", "author": "MaryamZi", "createdAt": "2020-02-26T06:20:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI3MjA3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI3NTg3MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r384275871", "bodyText": "How about constant refs?", "author": "MaryamZi", "createdAt": "2020-02-26T05:02:10Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2553,4 +2565,150 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        switch (type.tag) {\n+            case TypeTags.INT:\n+            case TypeTags.BYTE:\n+            case TypeTags.FLOAT:\n+            case TypeTags.DECIMAL:\n+            case TypeTags.STRING:\n+            case TypeTags.BOOLEAN:\n+            case TypeTags.JSON:\n+            case TypeTags.XML:\n+            case TypeTags.TABLE:\n+            case TypeTags.NIL:\n+            case TypeTags.ANYDATA:\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+            return false;\n+        }\n+\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            return true;\n+        }\n+        if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+            return false;\n+        }\n+\n+        for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+            if (!bVarSymbol.defaultableParam) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types. Singleton : As singleton can have one value that value should it self be a valid fill\n+     * value Union : 1. if nil is a member it is the fill values 2. else all the values should belong to same type and\n+     * the default value for that type should be a member of the union precondition : value space should have at least\n+     * one element\n+     *\n+     * @param type BFiniteType union or finite\n+     * @return boolean whether type has a valid filler value or not\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        if (type.getValueSpace().size() == 1) { // For singleton types, that value is the implicit initial value\n+            return true;\n+        }\n+        Iterator iterator = type.getValueSpace().iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        boolean defaultFillValuePresent = isImplicitDefaultValue(firstElement);\n+\n+        while (iterator.hasNext()) {\n+            BLangExpression value = (BLangExpression) iterator.next();\n+            if (!isSameType(value.type, firstElement.type)) {\n+                return false;\n+            }\n+            if (!defaultFillValuePresent && isImplicitDefaultValue(value)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        while (iterator.hasNext()) {\n+            if (!isSameType(firstMember, iterator.next())) {\n+                return false;\n+            }\n+        }\n+        return isValueType(firstMember) && hasFillerValue(firstMember);\n+    }\n+\n+    private boolean isImplicitDefaultValue(BLangExpression expression) {\n+        if ((expression.getKind() == NodeKind.LITERAL) || (expression.getKind() == NodeKind.NUMERIC_LITERAL)) {", "originalCommit": "e493306b2169e6eb276e902de8689b1c2cce1b37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI3NjAxOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r384276018", "bodyText": "Do we need this null check?", "author": "MaryamZi", "createdAt": "2020-02-26T05:03:02Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2553,4 +2565,150 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        switch (type.tag) {\n+            case TypeTags.INT:\n+            case TypeTags.BYTE:\n+            case TypeTags.FLOAT:\n+            case TypeTags.DECIMAL:\n+            case TypeTags.STRING:\n+            case TypeTags.BOOLEAN:\n+            case TypeTags.JSON:\n+            case TypeTags.XML:\n+            case TypeTags.TABLE:\n+            case TypeTags.NIL:\n+            case TypeTags.ANYDATA:\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+            return false;\n+        }\n+\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            return true;\n+        }\n+        if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+            return false;\n+        }\n+\n+        for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+            if (!bVarSymbol.defaultableParam) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types. Singleton : As singleton can have one value that value should it self be a valid fill\n+     * value Union : 1. if nil is a member it is the fill values 2. else all the values should belong to same type and\n+     * the default value for that type should be a member of the union precondition : value space should have at least\n+     * one element\n+     *\n+     * @param type BFiniteType union or finite\n+     * @return boolean whether type has a valid filler value or not\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        if (type.getValueSpace().size() == 1) { // For singleton types, that value is the implicit initial value\n+            return true;\n+        }\n+        Iterator iterator = type.getValueSpace().iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        boolean defaultFillValuePresent = isImplicitDefaultValue(firstElement);\n+\n+        while (iterator.hasNext()) {\n+            BLangExpression value = (BLangExpression) iterator.next();\n+            if (!isSameType(value.type, firstElement.type)) {\n+                return false;\n+            }\n+            if (!defaultFillValuePresent && isImplicitDefaultValue(value)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        while (iterator.hasNext()) {\n+            if (!isSameType(firstMember, iterator.next())) {\n+                return false;\n+            }\n+        }\n+        return isValueType(firstMember) && hasFillerValue(firstMember);\n+    }\n+\n+    private boolean isImplicitDefaultValue(BLangExpression expression) {\n+        if ((expression.getKind() == NodeKind.LITERAL) || (expression.getKind() == NodeKind.NUMERIC_LITERAL)) {\n+            BLangLiteral literalExpression = (BLangLiteral) expression;\n+            BType literalExprType = literalExpression.type;\n+            Object value = literalExpression.getValue();\n+            switch (literalExprType.getKind()) {\n+                case INT:\n+                case BYTE:\n+                    return value.equals(Long.valueOf(0));\n+                case STRING:\n+                    return value == null || value.equals(\"\");", "originalCommit": "e493306b2169e6eb276e902de8689b1c2cce1b37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI3NjEzOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20749#discussion_r384276138", "bodyText": "Shouldn't we check if value is null?", "author": "MaryamZi", "createdAt": "2020-02-26T05:03:31Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -2553,4 +2565,150 @@ public int hashCode() {\n     private interface TypeEqualityPredicate {\n         boolean test(BType source, BType target, Set<TypePair> unresolvedTypes);\n     }\n+\n+    public boolean hasFillerValue(BType type) {\n+        switch (type.tag) {\n+            case TypeTags.INT:\n+            case TypeTags.BYTE:\n+            case TypeTags.FLOAT:\n+            case TypeTags.DECIMAL:\n+            case TypeTags.STRING:\n+            case TypeTags.BOOLEAN:\n+            case TypeTags.JSON:\n+            case TypeTags.XML:\n+            case TypeTags.TABLE:\n+            case TypeTags.NIL:\n+            case TypeTags.ANYDATA:\n+            case TypeTags.MAP:\n+            case TypeTags.ANY:\n+                return true;\n+            case TypeTags.ARRAY:\n+                return checkFillerValue((BArrayType) type);\n+            case TypeTags.FINITE:\n+                return checkFillerValue((BFiniteType) type);\n+            case TypeTags.UNION:\n+                return checkFillerValue((BUnionType) type);\n+            case TypeTags.OBJECT:\n+                return checkFillerValue((BObjectType) type);\n+            case TypeTags.RECORD:\n+                return checkFillerValue((BRecordType) type);\n+            case TypeTags.TUPLE:\n+                BTupleType tupleType = (BTupleType) type;\n+                return tupleType.getTupleTypes().stream().allMatch(eleType -> hasFillerValue(eleType));\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean checkFillerValue(BObjectType type) {\n+        if ((type.tsymbol.flags & Flags.ABSTRACT) == Flags.ABSTRACT) {\n+            return false;\n+        }\n+\n+        BAttachedFunction initFunction = ((BObjectTypeSymbol) type.tsymbol).initializerFunc;\n+        if (initFunction == null) {\n+            return true;\n+        }\n+        if (initFunction.symbol.getReturnType().getKind() != TypeKind.NIL) {\n+            return false;\n+        }\n+\n+        for (BVarSymbol bVarSymbol : initFunction.symbol.getParameters()) {\n+            if (!bVarSymbol.defaultableParam) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * This will handle two types. Singleton : As singleton can have one value that value should it self be a valid fill\n+     * value Union : 1. if nil is a member it is the fill values 2. else all the values should belong to same type and\n+     * the default value for that type should be a member of the union precondition : value space should have at least\n+     * one element\n+     *\n+     * @param type BFiniteType union or finite\n+     * @return boolean whether type has a valid filler value or not\n+     */\n+    private boolean checkFillerValue(BFiniteType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        if (type.getValueSpace().size() == 1) { // For singleton types, that value is the implicit initial value\n+            return true;\n+        }\n+        Iterator iterator = type.getValueSpace().iterator();\n+        BLangExpression firstElement = (BLangExpression) iterator.next();\n+        boolean defaultFillValuePresent = isImplicitDefaultValue(firstElement);\n+\n+        while (iterator.hasNext()) {\n+            BLangExpression value = (BLangExpression) iterator.next();\n+            if (!isSameType(value.type, firstElement.type)) {\n+                return false;\n+            }\n+            if (!defaultFillValuePresent && isImplicitDefaultValue(value)) {\n+                defaultFillValuePresent = true;\n+            }\n+        }\n+\n+        return defaultFillValuePresent;\n+    }\n+\n+    private boolean checkFillerValue(BUnionType type) {\n+        if (type.isNullable()) {\n+            return true;\n+        }\n+        Iterator<BType> iterator = type.getMemberTypes().iterator();\n+        BType firstMember = iterator.next();\n+        while (iterator.hasNext()) {\n+            if (!isSameType(firstMember, iterator.next())) {\n+                return false;\n+            }\n+        }\n+        return isValueType(firstMember) && hasFillerValue(firstMember);\n+    }\n+\n+    private boolean isImplicitDefaultValue(BLangExpression expression) {\n+        if ((expression.getKind() == NodeKind.LITERAL) || (expression.getKind() == NodeKind.NUMERIC_LITERAL)) {\n+            BLangLiteral literalExpression = (BLangLiteral) expression;\n+            BType literalExprType = literalExpression.type;\n+            Object value = literalExpression.getValue();\n+            switch (literalExprType.getKind()) {\n+                case INT:\n+                case BYTE:\n+                    return value.equals(Long.valueOf(0));\n+                case STRING:\n+                    return value == null || value.equals(\"\");\n+                case DECIMAL:\n+                case FLOAT:\n+                    return value.equals(String.valueOf(0.0));\n+                case BOOLEAN:\n+                    return value.equals(Boolean.valueOf(false));\n+                case NIL:\n+                    return true;", "originalCommit": "e493306b2169e6eb276e902de8689b1c2cce1b37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}