{"pr_number": 22827, "pr_title": "Add floating point literal support", "pr_createdAt": "2020-04-22T06:25:10Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/22827", "timeline": [{"oid": "970b764e4cdd3e226ae5edd504ef91f80dcdcc50", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/970b764e4cdd3e226ae5edd504ef91f80dcdcc50", "message": "Add test cases", "committedDate": "2020-04-21T14:08:56Z", "type": "commit"}, {"oid": "668da066b8448b0fa418708c67c75d7c036aa691", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/668da066b8448b0fa418708c67c75d7c036aa691", "message": "Add floating point literal support", "committedDate": "2020-04-21T14:10:34Z", "type": "commit"}, {"oid": "6b9992670c0a0625df47fc027dbf87b1aad3a9c4", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6b9992670c0a0625df47fc027dbf87b1aad3a9c4", "message": "Add float literal starting with dot support", "committedDate": "2020-04-21T19:26:50Z", "type": "commit"}, {"oid": "c3ea87e63a8b5666f68220bc5756d0c60ff87551", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c3ea87e63a8b5666f68220bc5756d0c60ff87551", "message": "Add more test cases", "committedDate": "2020-04-21T19:28:54Z", "type": "commit"}, {"oid": "1ae5a969ba63d7d3eb05dbd834d61e30ddbf9b81", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1ae5a969ba63d7d3eb05dbd834d61e30ddbf9b81", "message": "Fix checkstyle", "committedDate": "2020-04-21T19:45:55Z", "type": "commit"}, {"oid": "4c0d56c2935ceb036f83d9e47add0e1b90921cc8", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4c0d56c2935ceb036f83d9e47add0e1b90921cc8", "message": "Fix parserMode for floats starting from dot", "committedDate": "2020-04-22T05:41:38Z", "type": "commit"}, {"oid": "76ba69fda0b2b2dc1cf63f1225dc053ed993273f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/76ba69fda0b2b2dc1cf63f1225dc053ed993273f", "message": "Merge branch 'incremental-parser' of https://github.com/ballerina-platform/ballerina-lang into float-literal-support", "committedDate": "2020-04-22T05:44:55Z", "type": "commit"}, {"oid": "464c32fb4574b8c7f8d66af2e47fdb31a1adc501", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/464c32fb4574b8c7f8d66af2e47fdb31a1adc501", "message": "Add error recovery support", "committedDate": "2020-04-22T06:07:13Z", "type": "commit"}, {"oid": "f5fa0281c557d76d04d6a32063c64b2f8ee109ae", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f5fa0281c557d76d04d6a32063c64b2f8ee109ae", "message": "Change BLOCK_STATEMENT to FUNCTION_BODY_BLOCK in added test cases", "committedDate": "2020-04-22T06:20:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcwNzYxNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22827#discussion_r412707615", "bodyText": "I added retreat() method to the charReader.java which does exactly the opposite of advance() method. If it is not acceptable I can mange to do above without calling reader.retreat();. But that will add few more lines, if blocks and a new variables to the processNumericLiteral() and processDecimalFloatLiteral(); methods", "author": "lochana-chathura", "createdAt": "2020-04-22T06:35:03Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "diffHunk": "@@ -414,15 +414,19 @@ private STNode processEndOfLine() {\n     }\n \n     /**\n-     * Process dot or ellipsis token.\n+     * Process dot, ellipsis or decimal floating point token.\n      * \n-     * @return Dot or ellipsis token\n+     * @return Dot, ellipsis or decimal floating point token\n      */\n-    private STToken parseDotOrEllipsis() {\n+    private STToken processDot() {\n         if (reader.peek() == LexerTerminals.DOT && reader.peek(1) == LexerTerminals.DOT) {\n             reader.advance(2);\n             return getSyntaxToken(SyntaxKind.ELLIPSIS_TOKEN);\n         }\n+        if (this.mode != ParserMode.IMPORT && isDigit(reader.peek())) {\n+            reader.retreat();\n+            return processDecimalFloatLiteral();\n+        }", "originalCommit": "f5fa0281c557d76d04d6a32063c64b2f8ee109ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgyNzE1NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22827#discussion_r412827155", "bodyText": "I feel the lexer shouldn't reach here for floating-points.\nHere we start parsing a token from a dot. But a floating-point numeric can never start from a dot right?", "author": "SupunS", "createdAt": "2020-04-22T09:34:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcwNzYxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg1MTM0Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22827#discussion_r412851347", "bodyText": "according to spec, DottedDecimalNumber := DecimalNumber . Digit*  | . Digit+ \nso starting from a . is possible right?. eg. .2", "author": "lochana-chathura", "createdAt": "2020-04-22T10:09:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcwNzYxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIyOTA5MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22827#discussion_r413229091", "bodyText": "Removed retreat() and refactored. :)", "author": "lochana-chathura", "createdAt": "2020-04-22T18:43:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcwNzYxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgyNTc4Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22827#discussion_r412825783", "bodyText": "lets use LexerTerminals.DOT everywhere posible", "author": "SupunS", "createdAt": "2020-04-22T09:32:26Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "diffHunk": "@@ -543,9 +555,133 @@ private STToken processNumericLiteral(int startChar) {\n \n     /**\n      * <p>\n-     * Process and returns a hex integer literal.\n+     * Process and returns a decimal floating point literal.\n      * </p>\n      * <code>\n+     * DecimalFloatingPointNumber :=\n+     *    DecimalNumber Exponent [FloatingPointTypeSuffix]\n+     *    | DottedDecimalNumber [Exponent] [FloatingPointTypeSuffix]\n+     *    | DecimalNumber FloatingPointTypeSuffix\n+     * <br/>\n+     * DottedDecimalNumber := DecimalNumber . Digit* | . Digit+\n+     * <br/>\n+     * FloatingPointTypeSuffix := DecimalTypeSuffix | FloatTypeSuffix\n+     * <br/>\n+     * DecimalTypeSuffix := d | D\n+     * <br/>\n+     * FloatTypeSuffix :=  f | F\n+     * </code>\n+     *\n+     * @return The decimal floating point literal.\n+     */\n+    private STToken processDecimalFloatLiteral() {\n+        boolean exponent = false;\n+        boolean dot = false;\n+        int nextChar;\n+        while (true) {\n+            nextChar = peek();\n+            switch (nextChar) {\n+                case 'f':\n+                case 'F':\n+                case 'd':\n+                case 'D':\n+                    reader.advance();\n+                    break;\n+                case 'e':\n+                case 'E':\n+                    if (!exponent) { // Check whether an exponent has been passed previously\n+                        if (processExponent()) {\n+                            exponent = true;\n+                            continue;\n+                        }\n+                    }\n+\n+                    processInvalidToken();\n+                    return readToken();\n+                case '.':", "originalCommit": "f5fa0281c557d76d04d6a32063c64b2f8ee109ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgzMjU2Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22827#discussion_r412832563", "bodyText": "Lets rename:\nexponent -> hasExponent\ndot -> hasDot", "author": "SupunS", "createdAt": "2020-04-22T09:42:16Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "diffHunk": "@@ -543,9 +555,133 @@ private STToken processNumericLiteral(int startChar) {\n \n     /**\n      * <p>\n-     * Process and returns a hex integer literal.\n+     * Process and returns a decimal floating point literal.\n      * </p>\n      * <code>\n+     * DecimalFloatingPointNumber :=\n+     *    DecimalNumber Exponent [FloatingPointTypeSuffix]\n+     *    | DottedDecimalNumber [Exponent] [FloatingPointTypeSuffix]\n+     *    | DecimalNumber FloatingPointTypeSuffix\n+     * <br/>\n+     * DottedDecimalNumber := DecimalNumber . Digit* | . Digit+\n+     * <br/>\n+     * FloatingPointTypeSuffix := DecimalTypeSuffix | FloatTypeSuffix\n+     * <br/>\n+     * DecimalTypeSuffix := d | D\n+     * <br/>\n+     * FloatTypeSuffix :=  f | F\n+     * </code>\n+     *\n+     * @return The decimal floating point literal.\n+     */\n+    private STToken processDecimalFloatLiteral() {\n+        boolean exponent = false;\n+        boolean dot = false;", "originalCommit": "f5fa0281c557d76d04d6a32063c64b2f8ee109ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg0MzM2MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22827#discussion_r412843361", "bodyText": "Can we avoid these if-conditions, and the flags?\nLooking at the grammar, there are three main components the decimalNumber,  the exponent, and the suffix. These always exists in order. For example: decimalNumber component always the first component. suffix always comes after the decimalNumber, and always before the suffix.\nSo, what I feel is, suppose we have three separate functions to process these three separate components, (say a(), b() and c() ) if we chain these three, then the complexity would be reduced.\nfor e.g: we start from a() and continue till we reach the exponent, and once we reach the exponent, call b(). But never return to a() and process again. Simply finish the processing and exit from b(). So a() never have to worry whether b() was successfully completed or not..", "author": "SupunS", "createdAt": "2020-04-22T09:57:43Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "diffHunk": "@@ -543,9 +555,133 @@ private STToken processNumericLiteral(int startChar) {\n \n     /**\n      * <p>\n-     * Process and returns a hex integer literal.\n+     * Process and returns a decimal floating point literal.\n      * </p>\n      * <code>\n+     * DecimalFloatingPointNumber :=\n+     *    DecimalNumber Exponent [FloatingPointTypeSuffix]\n+     *    | DottedDecimalNumber [Exponent] [FloatingPointTypeSuffix]\n+     *    | DecimalNumber FloatingPointTypeSuffix\n+     * <br/>\n+     * DottedDecimalNumber := DecimalNumber . Digit* | . Digit+\n+     * <br/>\n+     * FloatingPointTypeSuffix := DecimalTypeSuffix | FloatTypeSuffix\n+     * <br/>\n+     * DecimalTypeSuffix := d | D\n+     * <br/>\n+     * FloatTypeSuffix :=  f | F\n+     * </code>\n+     *\n+     * @return The decimal floating point literal.\n+     */\n+    private STToken processDecimalFloatLiteral() {\n+        boolean exponent = false;\n+        boolean dot = false;\n+        int nextChar;\n+        while (true) {\n+            nextChar = peek();\n+            switch (nextChar) {\n+                case 'f':\n+                case 'F':\n+                case 'd':\n+                case 'D':\n+                    reader.advance();\n+                    break;\n+                case 'e':\n+                case 'E':\n+                    if (!exponent) { // Check whether an exponent has been passed previously\n+                        if (processExponent()) {", "originalCommit": "f5fa0281c557d76d04d6a32063c64b2f8ee109ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg1MjQ3Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22827#discussion_r412852472", "bodyText": "I'll do that change.", "author": "lochana-chathura", "createdAt": "2020-04-22T10:11:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg0MzM2MQ=="}], "type": "inlineReview"}, {"oid": "a8fd96261bbd2f845b48d627dc9b841bf422cf99", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a8fd96261bbd2f845b48d627dc9b841bf422cf99", "message": "Refactor floating literal process", "committedDate": "2020-04-22T18:39:22Z", "type": "commit"}, {"oid": "7124776e7ea1bce1cf4e3b355626dd3ee90bec11", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7124776e7ea1bce1cf4e3b355626dd3ee90bec11", "message": "Merge branch 'incremental-parser' of https://github.com/ballerina-platform/ballerina-lang into float-literal-support\n\n\u0001 Conflicts:\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "committedDate": "2020-04-25T06:44:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI5NTYwNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22827#discussion_r415295607", "bodyText": "This code block looks like a duplicate of L#602-L#610. Can we use a single switch-case for both scenarios?", "author": "SupunS", "createdAt": "2020-04-26T12:11:21Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "diffHunk": "@@ -536,9 +547,162 @@ private STToken processNumericLiteral(int startChar) {\n \n     /**\n      * <p>\n-     * Process and returns a hex integer literal.\n+     * Process and returns a decimal floating point literal.\n+     * </p>\n+     * <code>\n+     * DecimalFloatingPointNumber :=\n+     *    DecimalNumber Exponent [FloatingPointTypeSuffix]\n+     *    | DottedDecimalNumber [Exponent] [FloatingPointTypeSuffix]\n+     *    | DecimalNumber FloatingPointTypeSuffix\n+     * <br/>\n+     * DottedDecimalNumber := DecimalNumber . Digit* | . Digit+\n+     * <br/>\n+     * FloatingPointTypeSuffix := DecimalTypeSuffix | FloatTypeSuffix\n+     * <br/>\n+     * DecimalTypeSuffix := d | D\n+     * <br/>\n+     * FloatTypeSuffix :=  f | F\n+     * </code>\n+     *\n+     * @param isDotStart Whether process starts from a dot\n+     * @return The decimal floating point literal.\n+     */\n+    private STToken processDecimalFloatLiteral(boolean isDotStart) {\n+        int nextChar = peek();\n+\n+        // Direct process to the dot switch case\n+        if (isDotStart) {\n+            nextChar = LexerTerminals.DOT;\n+        }\n+\n+        switch (nextChar) {\n+            case LexerTerminals.DOT:\n+                if (!isDotStart) { // Advance only if it is not already validated\n+                    reader.advance();\n+                }\n+                nextChar = peek();\n+                while (true) {\n+                    if (isDigit(nextChar)) {\n+                        reader.advance();\n+                        nextChar = peek();\n+                        continue;\n+                    }\n+                    break;\n+                }\n+                switch (nextChar) {\n+                    case 'e':\n+                    case 'E':\n+                        return processExponent(false);\n+                    case 'f':\n+                    case 'F':\n+                    case 'd':\n+                    case 'D':\n+                        return parseFloatingPointTypeSuffix();\n+                }", "originalCommit": "7124776e7ea1bce1cf4e3b355626dd3ee90bec11", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI5NjA3Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22827#discussion_r415296073", "bodyText": "while(isDigit(nextChar))", "author": "SupunS", "createdAt": "2020-04-26T12:13:48Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "diffHunk": "@@ -536,9 +547,162 @@ private STToken processNumericLiteral(int startChar) {\n \n     /**\n      * <p>\n-     * Process and returns a hex integer literal.\n+     * Process and returns a decimal floating point literal.\n+     * </p>\n+     * <code>\n+     * DecimalFloatingPointNumber :=\n+     *    DecimalNumber Exponent [FloatingPointTypeSuffix]\n+     *    | DottedDecimalNumber [Exponent] [FloatingPointTypeSuffix]\n+     *    | DecimalNumber FloatingPointTypeSuffix\n+     * <br/>\n+     * DottedDecimalNumber := DecimalNumber . Digit* | . Digit+\n+     * <br/>\n+     * FloatingPointTypeSuffix := DecimalTypeSuffix | FloatTypeSuffix\n+     * <br/>\n+     * DecimalTypeSuffix := d | D\n+     * <br/>\n+     * FloatTypeSuffix :=  f | F\n+     * </code>\n+     *\n+     * @param isDotStart Whether process starts from a dot\n+     * @return The decimal floating point literal.\n+     */\n+    private STToken processDecimalFloatLiteral(boolean isDotStart) {\n+        int nextChar = peek();\n+\n+        // Direct process to the dot switch case\n+        if (isDotStart) {\n+            nextChar = LexerTerminals.DOT;\n+        }\n+\n+        switch (nextChar) {\n+            case LexerTerminals.DOT:\n+                if (!isDotStart) { // Advance only if it is not already validated\n+                    reader.advance();\n+                }\n+                nextChar = peek();\n+                while (true) {\n+                    if (isDigit(nextChar)) {\n+                        reader.advance();\n+                        nextChar = peek();\n+                        continue;\n+                    }\n+                    break;\n+                }\n+                switch (nextChar) {\n+                    case 'e':\n+                    case 'E':\n+                        return processExponent(false);\n+                    case 'f':\n+                    case 'F':\n+                    case 'd':\n+                    case 'D':\n+                        return parseFloatingPointTypeSuffix();\n+                }\n+                break;\n+            case 'e':\n+            case 'E':\n+                return processExponent(false);\n+            case 'f':\n+            case 'F':\n+            case 'd':\n+            case 'D':\n+                return parseFloatingPointTypeSuffix();\n+        }\n+\n+        return getLiteral(SyntaxKind.DECIMAL_FLOATING_POINT_LITERAL);\n+    }\n+\n+    /**\n+     * <p>\n+     * Process an exponent or hex-exponent.\n+     * </p>\n+     * <code>\n+     * exponent := Exponent | HexExponent\n+     * <br/>\n+     * Exponent := ExponentIndicator [Sign] Digit+\n+     * <br/>\n+     * HexExponent := HexExponentIndicator [Sign] Digit+\n+     * <br/>\n+     * ExponentIndicator := e | E\n+     * <br/>\n+     * HexExponentIndicator := p | P\n+     * <br/>\n+     * Sign := + | -\n+     * <br/>\n+     * Digit := 0 .. 9\n+     * </code>\n+     *\n+     * @param isHex HexExponent or not\n+     * @return The decimal floating point literal.\n+     */\n+    private STToken processExponent(boolean isHex) {\n+        // Advance reader as exponent indicator is already validated\n+        reader.advance();\n+        int nextChar = peek();\n+\n+        // Capture if there is a sign\n+        if (nextChar == LexerTerminals.PLUS || nextChar == LexerTerminals.MINUS) {\n+            reader.advance();\n+            nextChar = peek();\n+        }\n+\n+        // Make sure at least one digit is present after the indicator\n+        if (!isDigit(nextChar)) {\n+            processInvalidToken();\n+            return readToken();\n+        }\n+\n+        while (true) {\n+            if (isDigit(nextChar)) {", "originalCommit": "7124776e7ea1bce1cf4e3b355626dd3ee90bec11", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI5NjM4Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22827#discussion_r415296383", "bodyText": "Should we log an error here?", "author": "SupunS", "createdAt": "2020-04-26T12:15:26Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "diffHunk": "@@ -536,9 +547,162 @@ private STToken processNumericLiteral(int startChar) {\n \n     /**\n      * <p>\n-     * Process and returns a hex integer literal.\n+     * Process and returns a decimal floating point literal.\n+     * </p>\n+     * <code>\n+     * DecimalFloatingPointNumber :=\n+     *    DecimalNumber Exponent [FloatingPointTypeSuffix]\n+     *    | DottedDecimalNumber [Exponent] [FloatingPointTypeSuffix]\n+     *    | DecimalNumber FloatingPointTypeSuffix\n+     * <br/>\n+     * DottedDecimalNumber := DecimalNumber . Digit* | . Digit+\n+     * <br/>\n+     * FloatingPointTypeSuffix := DecimalTypeSuffix | FloatTypeSuffix\n+     * <br/>\n+     * DecimalTypeSuffix := d | D\n+     * <br/>\n+     * FloatTypeSuffix :=  f | F\n+     * </code>\n+     *\n+     * @param isDotStart Whether process starts from a dot\n+     * @return The decimal floating point literal.\n+     */\n+    private STToken processDecimalFloatLiteral(boolean isDotStart) {\n+        int nextChar = peek();\n+\n+        // Direct process to the dot switch case\n+        if (isDotStart) {\n+            nextChar = LexerTerminals.DOT;\n+        }\n+\n+        switch (nextChar) {\n+            case LexerTerminals.DOT:\n+                if (!isDotStart) { // Advance only if it is not already validated\n+                    reader.advance();\n+                }\n+                nextChar = peek();\n+                while (true) {\n+                    if (isDigit(nextChar)) {\n+                        reader.advance();\n+                        nextChar = peek();\n+                        continue;\n+                    }\n+                    break;\n+                }\n+                switch (nextChar) {\n+                    case 'e':\n+                    case 'E':\n+                        return processExponent(false);\n+                    case 'f':\n+                    case 'F':\n+                    case 'd':\n+                    case 'D':\n+                        return parseFloatingPointTypeSuffix();\n+                }\n+                break;\n+            case 'e':\n+            case 'E':\n+                return processExponent(false);\n+            case 'f':\n+            case 'F':\n+            case 'd':\n+            case 'D':\n+                return parseFloatingPointTypeSuffix();\n+        }\n+\n+        return getLiteral(SyntaxKind.DECIMAL_FLOATING_POINT_LITERAL);\n+    }\n+\n+    /**\n+     * <p>\n+     * Process an exponent or hex-exponent.\n+     * </p>\n+     * <code>\n+     * exponent := Exponent | HexExponent\n+     * <br/>\n+     * Exponent := ExponentIndicator [Sign] Digit+\n+     * <br/>\n+     * HexExponent := HexExponentIndicator [Sign] Digit+\n+     * <br/>\n+     * ExponentIndicator := e | E\n+     * <br/>\n+     * HexExponentIndicator := p | P\n+     * <br/>\n+     * Sign := + | -\n+     * <br/>\n+     * Digit := 0 .. 9\n+     * </code>\n+     *\n+     * @param isHex HexExponent or not\n+     * @return The decimal floating point literal.\n+     */\n+    private STToken processExponent(boolean isHex) {\n+        // Advance reader as exponent indicator is already validated\n+        reader.advance();\n+        int nextChar = peek();\n+\n+        // Capture if there is a sign\n+        if (nextChar == LexerTerminals.PLUS || nextChar == LexerTerminals.MINUS) {\n+            reader.advance();\n+            nextChar = peek();\n+        }\n+\n+        // Make sure at least one digit is present after the indicator\n+        if (!isDigit(nextChar)) {\n+            processInvalidToken();", "originalCommit": "7124776e7ea1bce1cf4e3b355626dd3ee90bec11", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI5NzU0Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22827#discussion_r415297546", "bodyText": "Add a comment saying that we wouldn't be reaching here, if the floating-point starts with a dot.\nOtherwise, anyone who will check this code later, might think this was a mistake :)", "author": "SupunS", "createdAt": "2020-04-26T12:21:07Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "diffHunk": "@@ -494,24 +499,31 @@ private STToken processEqualOperator() {\n     private STToken processNumericLiteral(int startChar) {\n         int nextChar = peek();\n         if (isHexIndicator(startChar, nextChar)) {\n-            return processHexIntLiteral();\n+            return processHexLiteral();\n         }\n \n         int len = 1;\n         while (true) {\n             switch (nextChar) {\n-                case '.':\n+                case LexerTerminals.DOT:\n                 case 'e':\n                 case 'E':\n+                case 'f':\n+                case 'F':\n+                case 'd':\n+                case 'D':\n                     // In sem-var mode, only decimal integer literals are supported\n                     if (this.mode == ParserMode.IMPORT) {\n                         break;\n                     }\n \n-                    // TODO: handle float\n-                    reader.advance();\n-                    processInvalidToken();\n-                    return readToken();\n+                    // Integer part of the float cannot have a leading zero\n+                    if (startChar == '0' && len > 1) {\n+                        processInvalidToken();\n+                        return readToken();\n+                    }\n+\n+                    return processDecimalFloatLiteral(false);", "originalCommit": "7124776e7ea1bce1cf4e3b355626dd3ee90bec11", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI5OTQwMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22827#discussion_r415299403", "bodyText": "can we get rid of this isDotStart flag? Why does this method needs to know whether the numeric started with a dot?", "author": "SupunS", "createdAt": "2020-04-26T12:30:33Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "diffHunk": "@@ -536,9 +547,162 @@ private STToken processNumericLiteral(int startChar) {\n \n     /**\n      * <p>\n-     * Process and returns a hex integer literal.\n+     * Process and returns a decimal floating point literal.\n+     * </p>\n+     * <code>\n+     * DecimalFloatingPointNumber :=\n+     *    DecimalNumber Exponent [FloatingPointTypeSuffix]\n+     *    | DottedDecimalNumber [Exponent] [FloatingPointTypeSuffix]\n+     *    | DecimalNumber FloatingPointTypeSuffix\n+     * <br/>\n+     * DottedDecimalNumber := DecimalNumber . Digit* | . Digit+\n+     * <br/>\n+     * FloatingPointTypeSuffix := DecimalTypeSuffix | FloatTypeSuffix\n+     * <br/>\n+     * DecimalTypeSuffix := d | D\n+     * <br/>\n+     * FloatTypeSuffix :=  f | F\n+     * </code>\n+     *\n+     * @param isDotStart Whether process starts from a dot\n+     * @return The decimal floating point literal.\n+     */\n+    private STToken processDecimalFloatLiteral(boolean isDotStart) {\n+        int nextChar = peek();\n+\n+        // Direct process to the dot switch case\n+        if (isDotStart) {\n+            nextChar = LexerTerminals.DOT;\n+        }", "originalCommit": "7124776e7ea1bce1cf4e3b355626dd3ee90bec11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTMwMDI2MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22827#discussion_r415300260", "bodyText": "What if this method always accepts the starting char as the input? Will that solve this complexity?", "author": "SupunS", "createdAt": "2020-04-26T12:34:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTI5OTQwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTMwMTAyMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22827#discussion_r415301020", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            while (true) {\n          \n          \n            \n                                if (isHexDigit(nextChar)) {\n          \n          \n            \n                            while (isHexDigit(nextChar)) {", "author": "SupunS", "createdAt": "2020-04-26T12:38:11Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "diffHunk": "@@ -547,22 +711,64 @@ private STToken processNumericLiteral(int startChar) {\n      * <br/>\n      * HexDigit := Digit | a .. f | A .. F\n      * <br/>\n+     * HexFloatingPointLiteral := HexIndicator HexFloatingPointNumber\n+     * <br/>\n+     * HexFloatingPointNumber := HexNumber HexExponent | DottedHexNumber [HexExponent]\n+     * <br/>\n+     * DottedHexNumber := HexDigit+ . HexDigit* | . HexDigit+\n      * </code>\n-     * \n-     * @return\n+     *\n+     * @return The hex literal.\n      */\n-    private STToken processHexIntLiteral() {\n+    private STToken processHexLiteral() {\n         reader.advance();\n+\n+        // Make sure at least one hex-digit present if processing started from a dot\n+        if (peek() == LexerTerminals.DOT) {\n+            if (!isHexDigit(reader.peek(1))) {\n+                reader.advance();\n+                processInvalidToken();\n+                return readToken();\n+            }\n+        }\n+\n+        int nextChar;\n         while (isHexDigit(peek())) {\n             reader.advance();\n         }\n+        nextChar = peek();\n \n-        return getLiteral(SyntaxKind.HEX_INTEGER_LITERAL);\n+        switch (nextChar) {\n+            case LexerTerminals.DOT:\n+                reader.advance();\n+                nextChar = peek();\n+                while (true) {\n+                    if (isHexDigit(nextChar)) {", "originalCommit": "7124776e7ea1bce1cf4e3b355626dd3ee90bec11", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1ab171d4843da8c18499ddb9cb742fcb60ec069d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1ab171d4843da8c18499ddb9cb742fcb60ec069d", "message": "Merge branch 'incremental-parser' of https://github.com/ballerina-platform/ballerina-lang into float-literal-support", "committedDate": "2020-04-27T05:08:01Z", "type": "commit"}, {"oid": "3016312bfe3eb8a2d18099cbf3f6379ef3244934", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3016312bfe3eb8a2d18099cbf3f6379ef3244934", "message": "Refactor floating literal processing", "committedDate": "2020-04-27T07:02:45Z", "type": "forcePushed"}, {"oid": "bdfffac16ed4824607bc42f9f0eea6151c618f29", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bdfffac16ed4824607bc42f9f0eea6151c618f29", "message": "Refactor floating literal processing", "committedDate": "2020-04-27T07:09:28Z", "type": "forcePushed"}, {"oid": "0c057ffc4cad13fc885de020fd67f0d73f4a946d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0c057ffc4cad13fc885de020fd67f0d73f4a946d", "message": "Refactor floating literal processing", "committedDate": "2020-04-27T07:12:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU2OTE4Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22827#discussion_r415569182", "bodyText": "Saw a bug here. SIMPLE_NAME_REFERENCE added and fixed.", "author": "lochana-chathura", "createdAt": "2020-04-27T07:18:09Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3047,6 +3051,7 @@ private boolean isValidLVExpr(STNode expression) {\n         switch (expression.kind) {\n             case IDENTIFIER_TOKEN:\n             case QUALIFIED_NAME_REFERENCE:\n+            case SIMPLE_NAME_REFERENCE:", "originalCommit": "0c057ffc4cad13fc885de020fd67f0d73f4a946d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f58bc440d3c1187742c07b370b1313a49b23fae8", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f58bc440d3c1187742c07b370b1313a49b23fae8", "message": "Refactor floating literal processing", "committedDate": "2020-04-27T07:24:19Z", "type": "forcePushed"}, {"oid": "b9e1b2e23af7aa5c2b680e453dd720ac30685970", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b9e1b2e23af7aa5c2b680e453dd720ac30685970", "message": "Refactor floating literal processing", "committedDate": "2020-04-27T07:29:29Z", "type": "commit"}, {"oid": "b9e1b2e23af7aa5c2b680e453dd720ac30685970", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b9e1b2e23af7aa5c2b680e453dd720ac30685970", "message": "Refactor floating literal processing", "committedDate": "2020-04-27T07:29:29Z", "type": "forcePushed"}, {"oid": "fe4c9c8256009cde1c1a0288e7b393b3ddfde09f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fe4c9c8256009cde1c1a0288e7b393b3ddfde09f", "message": "Merge branch 'incremental-parser' of https://github.com/ballerina-platform/ballerina-lang into float-literal-support\n\n\u0001 Conflicts:\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "committedDate": "2020-04-27T11:19:18Z", "type": "commit"}, {"oid": "f0cb502a9126b9498108a065a0d3ae2c755cb6bf", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f0cb502a9126b9498108a065a0d3ae2c755cb6bf", "message": "Fix small merging issue", "committedDate": "2020-04-27T12:15:17Z", "type": "commit"}, {"oid": "f0cb502a9126b9498108a065a0d3ae2c755cb6bf", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f0cb502a9126b9498108a065a0d3ae2c755cb6bf", "message": "Fix small merging issue", "committedDate": "2020-04-27T12:15:17Z", "type": "forcePushed"}]}