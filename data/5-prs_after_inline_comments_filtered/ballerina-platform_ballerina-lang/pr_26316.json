{"pr_number": 26316, "pr_title": "[Formatter] Add several node implementations", "pr_createdAt": "2020-10-12T11:58:37Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/26316", "timeline": [{"oid": "40a79e627785317d1a46ddfcdd20d65e2e246e25", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/40a79e627785317d1a46ddfcdd20d65e2e246e25", "message": "Fix review comments of PR26161", "committedDate": "2020-10-02T05:01:37Z", "type": "commit"}, {"oid": "9ae8d917a6a1cabce3c3c7dedcf3540b74103030", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9ae8d917a6a1cabce3c3c7dedcf3540b74103030", "message": "Generate the overriden methods", "committedDate": "2020-10-02T05:15:48Z", "type": "commit"}, {"oid": "fa5871cb2ba5b3b9def2208d782f94d305b5ba73", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fa5871cb2ba5b3b9def2208d782f94d305b5ba73", "message": "Add several node implementations\n\nNilLiteralNode, StartActionNode, FlushActionNode, FailStatementNode, ContinueStatementNode, TrapExpressionNode, LetExpressionNode, LetVariableDeclarationNode, FromClauseNode, WhereClauseNode, LetClauseNode, QueryPipelineNode, WildcardBindingPatternNode, AsyncSendActionNode, SyncSendActionNode, ReceiveActionNode, ReceiveFieldsNode, WaitActionNode, QueryActionNode, TransactionStatementNode, RollbackStatementNode, RetryStatementNode, CommitActionNode, LimitClauseNode, JoinClauseNode, BreakStatementNode", "committedDate": "2020-10-12T08:28:49Z", "type": "commit"}, {"oid": "81330a2ede4dfaf5c68da3c18352254e103d9c0f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/81330a2ede4dfaf5c68da3c18352254e103d9c0f", "message": "Add several node implementations\n\nXMLNamespaceDeclarationNode, ModuleXMLNamespaceDeclarationNode, XMLSimpleNameNode, XMLEmptyElementNode, XMLTextNode, XMLComment, XMLProcessingInstruction, LocalTypeDefinitionStatementNode, ForkStatementNode, UnaryExpressionNode, DefaultableParameterNode, AnnotationDeclarationNode, KeySpecifierNode, StreamTypeDescriptorNode, StreamTypeParamsNode, InterpolationNode, MethodDeclarationNode, DoubleGTTokenNode, TrippleGTTokenNode, OrderKeyNode", "committedDate": "2020-10-12T11:49:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzMwMjE1Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26316#discussion_r503302152", "bodyText": "Only used in else path. Can move it there.", "author": "SupunS", "createdAt": "2020-10-12T13:38:07Z", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -1328,270 +1452,1389 @@ public ListBindingPatternNode transform(ListBindingPatternNode listBindingPatter\n             listBindingPatternNode = listBindingPatternNode.modify().withRestBindingPattern(restBindingPattern).apply();\n         }\n \n-        return listBindingPatternNode.modify()\n-                .withOpenBracket(openBracket)\n-                .withBindingPatterns(bindingPatternNodes)\n-                .withCloseBracket(closeBracket)\n-                .apply();\n+        return listBindingPatternNode.modify()\n+                .withOpenBracket(openBracket)\n+                .withBindingPatterns(bindingPatternNodes)\n+                .withCloseBracket(closeBracket)\n+                .apply();\n+    }\n+\n+    @Override\n+    public RestBindingPatternNode transform(RestBindingPatternNode restBindingPatternNode) {\n+        Token ellipsisToken = formatToken(restBindingPatternNode.ellipsisToken(), 0, 0);\n+        SimpleNameReferenceNode variableName = formatNode(restBindingPatternNode.variableName(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return restBindingPatternNode.modify()\n+                .withEllipsisToken(ellipsisToken)\n+                .withVariableName(variableName)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TableTypeDescriptorNode transform(TableTypeDescriptorNode tableTypeDescriptorNode) {\n+        Token tableKeywordToken = formatToken(tableTypeDescriptorNode.tableKeywordToken(), 0, 0);\n+        Node rowTypeParameterNode = formatNode(tableTypeDescriptorNode.rowTypeParameterNode(), 1, 0);\n+        Node keyConstraintNode = formatNode(tableTypeDescriptorNode.keyConstraintNode(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return tableTypeDescriptorNode.modify()\n+                .withTableKeywordToken(tableKeywordToken)\n+                .withRowTypeParameterNode(rowTypeParameterNode)\n+                .withKeyConstraintNode(keyConstraintNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public KeyTypeConstraintNode transform(KeyTypeConstraintNode keyTypeConstraintNode) {\n+        Token keyKeywordToken = formatToken(keyTypeConstraintNode.keyKeywordToken(), 0, 0);\n+        Node typeParameterNode = formatNode(keyTypeConstraintNode.typeParameterNode(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return keyTypeConstraintNode.modify()\n+                .withKeyKeywordToken(keyKeywordToken)\n+                .withTypeParameterNode(typeParameterNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MatchStatementNode transform(MatchStatementNode matchStatementNode) {\n+        boolean hasOnFailClause = matchStatementNode.onFailClause().isPresent();\n+        Token matchKeyword = formatToken(matchStatementNode.matchKeyword(), 1, 0);\n+        ExpressionNode condition = formatNode(matchStatementNode.condition(), 1, 0);\n+        Token openBrace = formatToken(matchStatementNode.openBrace(), 0, 1);\n+        indent();\n+        NodeList<MatchClauseNode> matchClauses = formatNodeList(matchStatementNode.matchClauses(), 0, 1, 0, 1);\n+        unindent();\n+        Token closeBrace;\n+\n+        if (hasOnFailClause) {\n+            closeBrace = formatToken(matchStatementNode.closeBrace(), 1, 0);\n+            OnFailClauseNode onFailClause = formatNode(matchStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            matchStatementNode = matchStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        } else {\n+            closeBrace = formatToken(matchStatementNode.closeBrace(), this.trailingWS, this.trailingNL);\n+        }\n+\n+        return matchStatementNode.modify()\n+                .withMatchKeyword(matchKeyword)\n+                .withCondition(condition)\n+                .withOpenBrace(openBrace)\n+                .withMatchClauses(matchClauses)\n+                .withCloseBrace(closeBrace)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MatchClauseNode transform(MatchClauseNode matchClauseNode) {\n+        SeparatedNodeList<Node> matchPatterns = formatSeparatedNodeList(matchClauseNode.matchPatterns(),\n+                0, 0, 0, 0, 1, 0);\n+\n+        if (matchClauseNode.matchGuard().isPresent()) {\n+            MatchGuardNode matchGuard = formatNode(matchClauseNode.matchGuard().get(), 1, 0);\n+            matchClauseNode = matchClauseNode.modify().withMatchGuard(matchGuard).apply();\n+        }\n+\n+        Token rightDoubleArrow = formatToken(matchClauseNode.rightDoubleArrow(), 1, 0);\n+        BlockStatementNode blockStatement = formatNode(matchClauseNode.blockStatement(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return matchClauseNode.modify()\n+                .withMatchPatterns(matchPatterns)\n+                .withRightDoubleArrow(rightDoubleArrow)\n+                .withBlockStatement(blockStatement)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MatchGuardNode transform(MatchGuardNode matchGuardNode) {\n+        Token ifKeyword = formatToken(matchGuardNode.ifKeyword(), 1, 0);\n+        ExpressionNode expression = formatNode(matchGuardNode.expression(), this.trailingWS, this.trailingNL);\n+\n+        return matchGuardNode.modify()\n+                .withIfKeyword(ifKeyword)\n+                .withExpression(expression)\n+                .apply();\n+    }\n+\n+    @Override\n+    public LockStatementNode transform(LockStatementNode lockStatementNode) {\n+        Token lockKeyword = formatToken(lockStatementNode.lockKeyword(), 1, 0);\n+        StatementNode blockStatement;\n+\n+        if (lockStatementNode.onFailClause().isPresent()) {\n+            blockStatement = formatNode(lockStatementNode.blockStatement(), 1, 0);\n+            OnFailClauseNode onFailClause = formatNode(lockStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            lockStatementNode = lockStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        } else {\n+            blockStatement = formatNode(lockStatementNode.blockStatement(), this.trailingWS, this.trailingNL);\n+        }\n+\n+        return lockStatementNode.modify()\n+                .withLockKeyword(lockKeyword)\n+                .withBlockStatement(blockStatement)\n+                .apply();\n+    }\n+\n+    @Override\n+    public FieldAccessExpressionNode transform(FieldAccessExpressionNode fieldAccessExpressionNode) {\n+        ExpressionNode expression = formatNode(fieldAccessExpressionNode.expression(), 0, 0);\n+        Token dotToken = formatToken(fieldAccessExpressionNode.dotToken(), 0, 0);\n+        NameReferenceNode fieldName = formatNode(fieldAccessExpressionNode.fieldName(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return fieldAccessExpressionNode.modify()\n+                .withExpression(expression)\n+                .withDotToken(dotToken)\n+                .withFieldName(fieldName)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MetadataNode transform(MetadataNode metadataNode) {\n+        NodeList<AnnotationNode> annotations = formatNodeList(metadataNode.annotations(), 0, 1, 0, 1);\n+\n+        if (metadataNode.documentationString().isPresent()) {\n+            Node documentationString = formatNode(metadataNode.documentationString().get(),\n+                    this.trailingWS, this.trailingNL);\n+            metadataNode = metadataNode.modify().withDocumentationString(documentationString).apply();\n+        }\n+\n+        return metadataNode.modify()\n+                .withAnnotations(annotations)\n+                .apply();\n+    }\n+\n+    @Override\n+    public EnumDeclarationNode transform(EnumDeclarationNode enumDeclarationNode) {\n+        if (enumDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(enumDeclarationNode.metadata().get(), 0, 1);\n+            enumDeclarationNode = enumDeclarationNode.modify()\n+                    .withMetadata(metadata).apply();\n+        }\n+\n+        Token qualifier = formatToken(enumDeclarationNode.qualifier(), 1, 0);\n+        Token enumKeywordToken = formatToken(enumDeclarationNode.enumKeywordToken(), 1, 0);\n+        IdentifierToken identifier = formatNode(enumDeclarationNode.identifier(), 1, 0);\n+        Token openBraceToken = formatToken(enumDeclarationNode.openBraceToken(), 0, 1);\n+        indent();\n+        SeparatedNodeList<Node> enumMemberList = formatSeparatedNodeList(enumDeclarationNode.enumMemberList(),\n+                0, 0, 0, 1, 0, 1);\n+        unindent();\n+        Token closeBraceToken = formatToken(enumDeclarationNode.closeBraceToken(), this.trailingWS, this.trailingNL);\n+\n+        return enumDeclarationNode.modify()\n+                .withQualifier(qualifier)\n+                .withEnumKeywordToken(enumKeywordToken)\n+                .withIdentifier(identifier)\n+                .withOpenBraceToken(openBraceToken)\n+                .withEnumMemberList(enumMemberList)\n+                .withCloseBraceToken(closeBraceToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public EnumMemberNode transform(EnumMemberNode enumMemberNode) {\n+        if (enumMemberNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(enumMemberNode.metadata().get(), 0, 1);\n+            enumMemberNode = enumMemberNode.modify().withMetadata(metadata).apply();\n+        }\n+        IdentifierToken identifier;", "originalCommit": "81330a2ede4dfaf5c68da3c18352254e103d9c0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzcwNjIxOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26316#discussion_r503706219", "bodyText": "This is modified in the if path as well.", "author": "IrushiL", "createdAt": "2020-10-13T06:52:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzMwMjE1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzMwMzEwMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26316#discussion_r503303100", "bodyText": "Shouldn't there be a newline between doc-lines?", "author": "SupunS", "createdAt": "2020-10-12T13:39:40Z", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -1328,270 +1452,1389 @@ public ListBindingPatternNode transform(ListBindingPatternNode listBindingPatter\n             listBindingPatternNode = listBindingPatternNode.modify().withRestBindingPattern(restBindingPattern).apply();\n         }\n \n-        return listBindingPatternNode.modify()\n-                .withOpenBracket(openBracket)\n-                .withBindingPatterns(bindingPatternNodes)\n-                .withCloseBracket(closeBracket)\n-                .apply();\n+        return listBindingPatternNode.modify()\n+                .withOpenBracket(openBracket)\n+                .withBindingPatterns(bindingPatternNodes)\n+                .withCloseBracket(closeBracket)\n+                .apply();\n+    }\n+\n+    @Override\n+    public RestBindingPatternNode transform(RestBindingPatternNode restBindingPatternNode) {\n+        Token ellipsisToken = formatToken(restBindingPatternNode.ellipsisToken(), 0, 0);\n+        SimpleNameReferenceNode variableName = formatNode(restBindingPatternNode.variableName(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return restBindingPatternNode.modify()\n+                .withEllipsisToken(ellipsisToken)\n+                .withVariableName(variableName)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TableTypeDescriptorNode transform(TableTypeDescriptorNode tableTypeDescriptorNode) {\n+        Token tableKeywordToken = formatToken(tableTypeDescriptorNode.tableKeywordToken(), 0, 0);\n+        Node rowTypeParameterNode = formatNode(tableTypeDescriptorNode.rowTypeParameterNode(), 1, 0);\n+        Node keyConstraintNode = formatNode(tableTypeDescriptorNode.keyConstraintNode(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return tableTypeDescriptorNode.modify()\n+                .withTableKeywordToken(tableKeywordToken)\n+                .withRowTypeParameterNode(rowTypeParameterNode)\n+                .withKeyConstraintNode(keyConstraintNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public KeyTypeConstraintNode transform(KeyTypeConstraintNode keyTypeConstraintNode) {\n+        Token keyKeywordToken = formatToken(keyTypeConstraintNode.keyKeywordToken(), 0, 0);\n+        Node typeParameterNode = formatNode(keyTypeConstraintNode.typeParameterNode(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return keyTypeConstraintNode.modify()\n+                .withKeyKeywordToken(keyKeywordToken)\n+                .withTypeParameterNode(typeParameterNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MatchStatementNode transform(MatchStatementNode matchStatementNode) {\n+        boolean hasOnFailClause = matchStatementNode.onFailClause().isPresent();\n+        Token matchKeyword = formatToken(matchStatementNode.matchKeyword(), 1, 0);\n+        ExpressionNode condition = formatNode(matchStatementNode.condition(), 1, 0);\n+        Token openBrace = formatToken(matchStatementNode.openBrace(), 0, 1);\n+        indent();\n+        NodeList<MatchClauseNode> matchClauses = formatNodeList(matchStatementNode.matchClauses(), 0, 1, 0, 1);\n+        unindent();\n+        Token closeBrace;\n+\n+        if (hasOnFailClause) {\n+            closeBrace = formatToken(matchStatementNode.closeBrace(), 1, 0);\n+            OnFailClauseNode onFailClause = formatNode(matchStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            matchStatementNode = matchStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        } else {\n+            closeBrace = formatToken(matchStatementNode.closeBrace(), this.trailingWS, this.trailingNL);\n+        }\n+\n+        return matchStatementNode.modify()\n+                .withMatchKeyword(matchKeyword)\n+                .withCondition(condition)\n+                .withOpenBrace(openBrace)\n+                .withMatchClauses(matchClauses)\n+                .withCloseBrace(closeBrace)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MatchClauseNode transform(MatchClauseNode matchClauseNode) {\n+        SeparatedNodeList<Node> matchPatterns = formatSeparatedNodeList(matchClauseNode.matchPatterns(),\n+                0, 0, 0, 0, 1, 0);\n+\n+        if (matchClauseNode.matchGuard().isPresent()) {\n+            MatchGuardNode matchGuard = formatNode(matchClauseNode.matchGuard().get(), 1, 0);\n+            matchClauseNode = matchClauseNode.modify().withMatchGuard(matchGuard).apply();\n+        }\n+\n+        Token rightDoubleArrow = formatToken(matchClauseNode.rightDoubleArrow(), 1, 0);\n+        BlockStatementNode blockStatement = formatNode(matchClauseNode.blockStatement(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return matchClauseNode.modify()\n+                .withMatchPatterns(matchPatterns)\n+                .withRightDoubleArrow(rightDoubleArrow)\n+                .withBlockStatement(blockStatement)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MatchGuardNode transform(MatchGuardNode matchGuardNode) {\n+        Token ifKeyword = formatToken(matchGuardNode.ifKeyword(), 1, 0);\n+        ExpressionNode expression = formatNode(matchGuardNode.expression(), this.trailingWS, this.trailingNL);\n+\n+        return matchGuardNode.modify()\n+                .withIfKeyword(ifKeyword)\n+                .withExpression(expression)\n+                .apply();\n+    }\n+\n+    @Override\n+    public LockStatementNode transform(LockStatementNode lockStatementNode) {\n+        Token lockKeyword = formatToken(lockStatementNode.lockKeyword(), 1, 0);\n+        StatementNode blockStatement;\n+\n+        if (lockStatementNode.onFailClause().isPresent()) {\n+            blockStatement = formatNode(lockStatementNode.blockStatement(), 1, 0);\n+            OnFailClauseNode onFailClause = formatNode(lockStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            lockStatementNode = lockStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        } else {\n+            blockStatement = formatNode(lockStatementNode.blockStatement(), this.trailingWS, this.trailingNL);\n+        }\n+\n+        return lockStatementNode.modify()\n+                .withLockKeyword(lockKeyword)\n+                .withBlockStatement(blockStatement)\n+                .apply();\n+    }\n+\n+    @Override\n+    public FieldAccessExpressionNode transform(FieldAccessExpressionNode fieldAccessExpressionNode) {\n+        ExpressionNode expression = formatNode(fieldAccessExpressionNode.expression(), 0, 0);\n+        Token dotToken = formatToken(fieldAccessExpressionNode.dotToken(), 0, 0);\n+        NameReferenceNode fieldName = formatNode(fieldAccessExpressionNode.fieldName(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return fieldAccessExpressionNode.modify()\n+                .withExpression(expression)\n+                .withDotToken(dotToken)\n+                .withFieldName(fieldName)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MetadataNode transform(MetadataNode metadataNode) {\n+        NodeList<AnnotationNode> annotations = formatNodeList(metadataNode.annotations(), 0, 1, 0, 1);\n+\n+        if (metadataNode.documentationString().isPresent()) {\n+            Node documentationString = formatNode(metadataNode.documentationString().get(),\n+                    this.trailingWS, this.trailingNL);\n+            metadataNode = metadataNode.modify().withDocumentationString(documentationString).apply();\n+        }\n+\n+        return metadataNode.modify()\n+                .withAnnotations(annotations)\n+                .apply();\n+    }\n+\n+    @Override\n+    public EnumDeclarationNode transform(EnumDeclarationNode enumDeclarationNode) {\n+        if (enumDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(enumDeclarationNode.metadata().get(), 0, 1);\n+            enumDeclarationNode = enumDeclarationNode.modify()\n+                    .withMetadata(metadata).apply();\n+        }\n+\n+        Token qualifier = formatToken(enumDeclarationNode.qualifier(), 1, 0);\n+        Token enumKeywordToken = formatToken(enumDeclarationNode.enumKeywordToken(), 1, 0);\n+        IdentifierToken identifier = formatNode(enumDeclarationNode.identifier(), 1, 0);\n+        Token openBraceToken = formatToken(enumDeclarationNode.openBraceToken(), 0, 1);\n+        indent();\n+        SeparatedNodeList<Node> enumMemberList = formatSeparatedNodeList(enumDeclarationNode.enumMemberList(),\n+                0, 0, 0, 1, 0, 1);\n+        unindent();\n+        Token closeBraceToken = formatToken(enumDeclarationNode.closeBraceToken(), this.trailingWS, this.trailingNL);\n+\n+        return enumDeclarationNode.modify()\n+                .withQualifier(qualifier)\n+                .withEnumKeywordToken(enumKeywordToken)\n+                .withIdentifier(identifier)\n+                .withOpenBraceToken(openBraceToken)\n+                .withEnumMemberList(enumMemberList)\n+                .withCloseBraceToken(closeBraceToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public EnumMemberNode transform(EnumMemberNode enumMemberNode) {\n+        if (enumMemberNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(enumMemberNode.metadata().get(), 0, 1);\n+            enumMemberNode = enumMemberNode.modify().withMetadata(metadata).apply();\n+        }\n+        IdentifierToken identifier;\n+\n+        if (enumMemberNode.equalToken().isPresent()) {\n+            identifier = formatNode(enumMemberNode.identifier(), 1, 0);\n+            Token equalToken = formatToken(enumMemberNode.equalToken().get(), 1, 0);\n+            ExpressionNode constExprNode = formatNode(enumMemberNode.constExprNode().get(),\n+                    this.trailingWS, this.trailingNL);\n+\n+            return enumMemberNode.modify()\n+                    .withIdentifier(identifier)\n+                    .withEqualToken(equalToken)\n+                    .withConstExprNode(constExprNode)\n+                    .apply();\n+        } else {\n+            identifier = formatNode(enumMemberNode.identifier(), this.trailingWS, this.trailingNL);\n+\n+            return enumMemberNode.modify()\n+                    .withIdentifier(identifier)\n+                    .apply();\n+        }\n+    }\n+\n+    @Override\n+    public MarkdownDocumentationNode transform(MarkdownDocumentationNode markdownDocumentationNode) {\n+        NodeList<Node> documentationLines = formatNodeList(markdownDocumentationNode.documentationLines(),\n+                0, 0, this.trailingWS, this.trailingNL);", "originalCommit": "81330a2ede4dfaf5c68da3c18352254e103d9c0f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzMwNjczNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26316#discussion_r503306737", "bodyText": "namespaceuri --> namespaceUri", "author": "SupunS", "createdAt": "2020-10-12T13:45:16Z", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -1328,270 +1452,1389 @@ public ListBindingPatternNode transform(ListBindingPatternNode listBindingPatter\n             listBindingPatternNode = listBindingPatternNode.modify().withRestBindingPattern(restBindingPattern).apply();\n         }\n \n-        return listBindingPatternNode.modify()\n-                .withOpenBracket(openBracket)\n-                .withBindingPatterns(bindingPatternNodes)\n-                .withCloseBracket(closeBracket)\n-                .apply();\n+        return listBindingPatternNode.modify()\n+                .withOpenBracket(openBracket)\n+                .withBindingPatterns(bindingPatternNodes)\n+                .withCloseBracket(closeBracket)\n+                .apply();\n+    }\n+\n+    @Override\n+    public RestBindingPatternNode transform(RestBindingPatternNode restBindingPatternNode) {\n+        Token ellipsisToken = formatToken(restBindingPatternNode.ellipsisToken(), 0, 0);\n+        SimpleNameReferenceNode variableName = formatNode(restBindingPatternNode.variableName(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return restBindingPatternNode.modify()\n+                .withEllipsisToken(ellipsisToken)\n+                .withVariableName(variableName)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TableTypeDescriptorNode transform(TableTypeDescriptorNode tableTypeDescriptorNode) {\n+        Token tableKeywordToken = formatToken(tableTypeDescriptorNode.tableKeywordToken(), 0, 0);\n+        Node rowTypeParameterNode = formatNode(tableTypeDescriptorNode.rowTypeParameterNode(), 1, 0);\n+        Node keyConstraintNode = formatNode(tableTypeDescriptorNode.keyConstraintNode(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return tableTypeDescriptorNode.modify()\n+                .withTableKeywordToken(tableKeywordToken)\n+                .withRowTypeParameterNode(rowTypeParameterNode)\n+                .withKeyConstraintNode(keyConstraintNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public KeyTypeConstraintNode transform(KeyTypeConstraintNode keyTypeConstraintNode) {\n+        Token keyKeywordToken = formatToken(keyTypeConstraintNode.keyKeywordToken(), 0, 0);\n+        Node typeParameterNode = formatNode(keyTypeConstraintNode.typeParameterNode(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return keyTypeConstraintNode.modify()\n+                .withKeyKeywordToken(keyKeywordToken)\n+                .withTypeParameterNode(typeParameterNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MatchStatementNode transform(MatchStatementNode matchStatementNode) {\n+        boolean hasOnFailClause = matchStatementNode.onFailClause().isPresent();\n+        Token matchKeyword = formatToken(matchStatementNode.matchKeyword(), 1, 0);\n+        ExpressionNode condition = formatNode(matchStatementNode.condition(), 1, 0);\n+        Token openBrace = formatToken(matchStatementNode.openBrace(), 0, 1);\n+        indent();\n+        NodeList<MatchClauseNode> matchClauses = formatNodeList(matchStatementNode.matchClauses(), 0, 1, 0, 1);\n+        unindent();\n+        Token closeBrace;\n+\n+        if (hasOnFailClause) {\n+            closeBrace = formatToken(matchStatementNode.closeBrace(), 1, 0);\n+            OnFailClauseNode onFailClause = formatNode(matchStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            matchStatementNode = matchStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        } else {\n+            closeBrace = formatToken(matchStatementNode.closeBrace(), this.trailingWS, this.trailingNL);\n+        }\n+\n+        return matchStatementNode.modify()\n+                .withMatchKeyword(matchKeyword)\n+                .withCondition(condition)\n+                .withOpenBrace(openBrace)\n+                .withMatchClauses(matchClauses)\n+                .withCloseBrace(closeBrace)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MatchClauseNode transform(MatchClauseNode matchClauseNode) {\n+        SeparatedNodeList<Node> matchPatterns = formatSeparatedNodeList(matchClauseNode.matchPatterns(),\n+                0, 0, 0, 0, 1, 0);\n+\n+        if (matchClauseNode.matchGuard().isPresent()) {\n+            MatchGuardNode matchGuard = formatNode(matchClauseNode.matchGuard().get(), 1, 0);\n+            matchClauseNode = matchClauseNode.modify().withMatchGuard(matchGuard).apply();\n+        }\n+\n+        Token rightDoubleArrow = formatToken(matchClauseNode.rightDoubleArrow(), 1, 0);\n+        BlockStatementNode blockStatement = formatNode(matchClauseNode.blockStatement(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return matchClauseNode.modify()\n+                .withMatchPatterns(matchPatterns)\n+                .withRightDoubleArrow(rightDoubleArrow)\n+                .withBlockStatement(blockStatement)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MatchGuardNode transform(MatchGuardNode matchGuardNode) {\n+        Token ifKeyword = formatToken(matchGuardNode.ifKeyword(), 1, 0);\n+        ExpressionNode expression = formatNode(matchGuardNode.expression(), this.trailingWS, this.trailingNL);\n+\n+        return matchGuardNode.modify()\n+                .withIfKeyword(ifKeyword)\n+                .withExpression(expression)\n+                .apply();\n+    }\n+\n+    @Override\n+    public LockStatementNode transform(LockStatementNode lockStatementNode) {\n+        Token lockKeyword = formatToken(lockStatementNode.lockKeyword(), 1, 0);\n+        StatementNode blockStatement;\n+\n+        if (lockStatementNode.onFailClause().isPresent()) {\n+            blockStatement = formatNode(lockStatementNode.blockStatement(), 1, 0);\n+            OnFailClauseNode onFailClause = formatNode(lockStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            lockStatementNode = lockStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        } else {\n+            blockStatement = formatNode(lockStatementNode.blockStatement(), this.trailingWS, this.trailingNL);\n+        }\n+\n+        return lockStatementNode.modify()\n+                .withLockKeyword(lockKeyword)\n+                .withBlockStatement(blockStatement)\n+                .apply();\n+    }\n+\n+    @Override\n+    public FieldAccessExpressionNode transform(FieldAccessExpressionNode fieldAccessExpressionNode) {\n+        ExpressionNode expression = formatNode(fieldAccessExpressionNode.expression(), 0, 0);\n+        Token dotToken = formatToken(fieldAccessExpressionNode.dotToken(), 0, 0);\n+        NameReferenceNode fieldName = formatNode(fieldAccessExpressionNode.fieldName(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return fieldAccessExpressionNode.modify()\n+                .withExpression(expression)\n+                .withDotToken(dotToken)\n+                .withFieldName(fieldName)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MetadataNode transform(MetadataNode metadataNode) {\n+        NodeList<AnnotationNode> annotations = formatNodeList(metadataNode.annotations(), 0, 1, 0, 1);\n+\n+        if (metadataNode.documentationString().isPresent()) {\n+            Node documentationString = formatNode(metadataNode.documentationString().get(),\n+                    this.trailingWS, this.trailingNL);\n+            metadataNode = metadataNode.modify().withDocumentationString(documentationString).apply();\n+        }\n+\n+        return metadataNode.modify()\n+                .withAnnotations(annotations)\n+                .apply();\n+    }\n+\n+    @Override\n+    public EnumDeclarationNode transform(EnumDeclarationNode enumDeclarationNode) {\n+        if (enumDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(enumDeclarationNode.metadata().get(), 0, 1);\n+            enumDeclarationNode = enumDeclarationNode.modify()\n+                    .withMetadata(metadata).apply();\n+        }\n+\n+        Token qualifier = formatToken(enumDeclarationNode.qualifier(), 1, 0);\n+        Token enumKeywordToken = formatToken(enumDeclarationNode.enumKeywordToken(), 1, 0);\n+        IdentifierToken identifier = formatNode(enumDeclarationNode.identifier(), 1, 0);\n+        Token openBraceToken = formatToken(enumDeclarationNode.openBraceToken(), 0, 1);\n+        indent();\n+        SeparatedNodeList<Node> enumMemberList = formatSeparatedNodeList(enumDeclarationNode.enumMemberList(),\n+                0, 0, 0, 1, 0, 1);\n+        unindent();\n+        Token closeBraceToken = formatToken(enumDeclarationNode.closeBraceToken(), this.trailingWS, this.trailingNL);\n+\n+        return enumDeclarationNode.modify()\n+                .withQualifier(qualifier)\n+                .withEnumKeywordToken(enumKeywordToken)\n+                .withIdentifier(identifier)\n+                .withOpenBraceToken(openBraceToken)\n+                .withEnumMemberList(enumMemberList)\n+                .withCloseBraceToken(closeBraceToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public EnumMemberNode transform(EnumMemberNode enumMemberNode) {\n+        if (enumMemberNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(enumMemberNode.metadata().get(), 0, 1);\n+            enumMemberNode = enumMemberNode.modify().withMetadata(metadata).apply();\n+        }\n+        IdentifierToken identifier;\n+\n+        if (enumMemberNode.equalToken().isPresent()) {\n+            identifier = formatNode(enumMemberNode.identifier(), 1, 0);\n+            Token equalToken = formatToken(enumMemberNode.equalToken().get(), 1, 0);\n+            ExpressionNode constExprNode = formatNode(enumMemberNode.constExprNode().get(),\n+                    this.trailingWS, this.trailingNL);\n+\n+            return enumMemberNode.modify()\n+                    .withIdentifier(identifier)\n+                    .withEqualToken(equalToken)\n+                    .withConstExprNode(constExprNode)\n+                    .apply();\n+        } else {\n+            identifier = formatNode(enumMemberNode.identifier(), this.trailingWS, this.trailingNL);\n+\n+            return enumMemberNode.modify()\n+                    .withIdentifier(identifier)\n+                    .apply();\n+        }\n+    }\n+\n+    @Override\n+    public MarkdownDocumentationNode transform(MarkdownDocumentationNode markdownDocumentationNode) {\n+        NodeList<Node> documentationLines = formatNodeList(markdownDocumentationNode.documentationLines(),\n+                0, 0, this.trailingWS, this.trailingNL);\n+\n+        return markdownDocumentationNode.modify()\n+                .withDocumentationLines(documentationLines)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MarkdownDocumentationLineNode transform(MarkdownDocumentationLineNode markdownDocumentationLineNode) {\n+        Token hashToken = formatToken(markdownDocumentationLineNode.hashToken(), 0, 0);\n+        NodeList<Node> documentElements = formatNodeList(markdownDocumentationLineNode.documentElements(),\n+                0, 0, this.trailingWS, this.trailingNL);\n+\n+        return markdownDocumentationLineNode.modify()\n+                .withDocumentElements(documentElements)\n+                .withHashToken(hashToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MarkdownParameterDocumentationLineNode transform(\n+            MarkdownParameterDocumentationLineNode markdownParameterDocumentationLineNode) {\n+        Token hashToken = formatToken(markdownParameterDocumentationLineNode.hashToken(), 1, 0);\n+        Token plusToken = formatToken(markdownParameterDocumentationLineNode.plusToken(), 1, 0);\n+        Token parameterName = formatToken(markdownParameterDocumentationLineNode.parameterName(), 1, 0);\n+        Token minusToken = formatToken(markdownParameterDocumentationLineNode.minusToken(), 0, 0);\n+        NodeList<Node> documentElements = formatNodeList(markdownParameterDocumentationLineNode.documentElements(),\n+                0, 0, this.trailingWS, this.trailingNL);\n+\n+        return markdownParameterDocumentationLineNode.modify()\n+                .withHashToken(hashToken)\n+                .withPlusToken(plusToken)\n+                .withParameterName(parameterName)\n+                .withMinusToken(minusToken)\n+                .withDocumentElements(documentElements)\n+                .apply();\n+    }\n+\n+    @Override\n+    public DocumentationReferenceNode transform(DocumentationReferenceNode documentationReferenceNode) {\n+        if (documentationReferenceNode.referenceType().isPresent()) {\n+            Token referenceType = formatToken(documentationReferenceNode.referenceType().get(), 1, 0);\n+            documentationReferenceNode = documentationReferenceNode.modify().withReferenceType(referenceType).apply();\n+        }\n+\n+        Token startBacktick = formatToken(documentationReferenceNode.startBacktick(), 0, 0);\n+        Node backtickContent = formatNode(documentationReferenceNode.backtickContent(), 0, 0);\n+        Token endBacktick = formatToken(documentationReferenceNode.endBacktick(), this.trailingWS, this.trailingNL);\n+\n+        return documentationReferenceNode.modify()\n+                .withStartBacktick(startBacktick)\n+                .withBacktickContent(backtickContent)\n+                .withEndBacktick(endBacktick)\n+                .apply();\n+    }\n+\n+    @Override\n+    public PositionalArgumentNode transform(PositionalArgumentNode positionalArgumentNode) {\n+\n+        return super.transform(positionalArgumentNode);\n+    }\n+\n+    @Override\n+    public MappingBindingPatternNode transform(MappingBindingPatternNode mappingBindingPatternNode) {\n+\n+        return super.transform(mappingBindingPatternNode);\n+    }\n+\n+    @Override\n+    public FieldBindingPatternFullNode transform(FieldBindingPatternFullNode fieldBindingPatternFullNode) {\n+\n+        return super.transform(fieldBindingPatternFullNode);\n+    }\n+\n+    @Override\n+    public FieldBindingPatternVarnameNode transform(FieldBindingPatternVarnameNode fieldBindingPatternVarnameNode) {\n+\n+        return super.transform(fieldBindingPatternVarnameNode);\n+    }\n+\n+    @Override\n+    public TypeTestExpressionNode transform(TypeTestExpressionNode typeTestExpressionNode) {\n+\n+        return super.transform(typeTestExpressionNode);\n+    }\n+\n+    @Override\n+    public ListenerDeclarationNode transform(ListenerDeclarationNode listenerDeclarationNode) {\n+\n+        return super.transform(listenerDeclarationNode);\n+    }\n+\n+    @Override\n+    public ArrayTypeDescriptorNode transform(ArrayTypeDescriptorNode arrayTypeDescriptorNode) {\n+\n+        return super.transform(arrayTypeDescriptorNode);\n+    }\n+\n+    @Override\n+    public MethodCallExpressionNode transform(MethodCallExpressionNode methodCallExpressionNode) {\n+\n+        return super.transform(methodCallExpressionNode);\n+    }\n+\n+    @Override\n+    public NilLiteralNode transform(NilLiteralNode nilLiteralNode) {\n+        Token openParenToken = formatToken(nilLiteralNode.openParenToken(), 0, 0);\n+        Token closeParenToken = formatToken(nilLiteralNode.closeParenToken(), this.trailingWS, this.trailingNL);\n+\n+        return nilLiteralNode.modify()\n+                .withOpenParenToken(openParenToken)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public XMLNamespaceDeclarationNode transform(XMLNamespaceDeclarationNode xMLNamespaceDeclarationNode) {\n+        Token xmlnsKeyword = formatToken(xMLNamespaceDeclarationNode.xmlnsKeyword(), 1, 0);\n+        ExpressionNode namespaceuri;", "originalCommit": "81330a2ede4dfaf5c68da3c18352254e103d9c0f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzMwODQ1NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26316#discussion_r503308455", "bodyText": "It's ok to assume asKeyword().isPresent() implies namespacePrefix().isPresent(). Then we can merge the two if-blocks.", "author": "SupunS", "createdAt": "2020-10-12T13:48:03Z", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -1328,270 +1452,1389 @@ public ListBindingPatternNode transform(ListBindingPatternNode listBindingPatter\n             listBindingPatternNode = listBindingPatternNode.modify().withRestBindingPattern(restBindingPattern).apply();\n         }\n \n-        return listBindingPatternNode.modify()\n-                .withOpenBracket(openBracket)\n-                .withBindingPatterns(bindingPatternNodes)\n-                .withCloseBracket(closeBracket)\n-                .apply();\n+        return listBindingPatternNode.modify()\n+                .withOpenBracket(openBracket)\n+                .withBindingPatterns(bindingPatternNodes)\n+                .withCloseBracket(closeBracket)\n+                .apply();\n+    }\n+\n+    @Override\n+    public RestBindingPatternNode transform(RestBindingPatternNode restBindingPatternNode) {\n+        Token ellipsisToken = formatToken(restBindingPatternNode.ellipsisToken(), 0, 0);\n+        SimpleNameReferenceNode variableName = formatNode(restBindingPatternNode.variableName(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return restBindingPatternNode.modify()\n+                .withEllipsisToken(ellipsisToken)\n+                .withVariableName(variableName)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TableTypeDescriptorNode transform(TableTypeDescriptorNode tableTypeDescriptorNode) {\n+        Token tableKeywordToken = formatToken(tableTypeDescriptorNode.tableKeywordToken(), 0, 0);\n+        Node rowTypeParameterNode = formatNode(tableTypeDescriptorNode.rowTypeParameterNode(), 1, 0);\n+        Node keyConstraintNode = formatNode(tableTypeDescriptorNode.keyConstraintNode(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return tableTypeDescriptorNode.modify()\n+                .withTableKeywordToken(tableKeywordToken)\n+                .withRowTypeParameterNode(rowTypeParameterNode)\n+                .withKeyConstraintNode(keyConstraintNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public KeyTypeConstraintNode transform(KeyTypeConstraintNode keyTypeConstraintNode) {\n+        Token keyKeywordToken = formatToken(keyTypeConstraintNode.keyKeywordToken(), 0, 0);\n+        Node typeParameterNode = formatNode(keyTypeConstraintNode.typeParameterNode(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return keyTypeConstraintNode.modify()\n+                .withKeyKeywordToken(keyKeywordToken)\n+                .withTypeParameterNode(typeParameterNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MatchStatementNode transform(MatchStatementNode matchStatementNode) {\n+        boolean hasOnFailClause = matchStatementNode.onFailClause().isPresent();\n+        Token matchKeyword = formatToken(matchStatementNode.matchKeyword(), 1, 0);\n+        ExpressionNode condition = formatNode(matchStatementNode.condition(), 1, 0);\n+        Token openBrace = formatToken(matchStatementNode.openBrace(), 0, 1);\n+        indent();\n+        NodeList<MatchClauseNode> matchClauses = formatNodeList(matchStatementNode.matchClauses(), 0, 1, 0, 1);\n+        unindent();\n+        Token closeBrace;\n+\n+        if (hasOnFailClause) {\n+            closeBrace = formatToken(matchStatementNode.closeBrace(), 1, 0);\n+            OnFailClauseNode onFailClause = formatNode(matchStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            matchStatementNode = matchStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        } else {\n+            closeBrace = formatToken(matchStatementNode.closeBrace(), this.trailingWS, this.trailingNL);\n+        }\n+\n+        return matchStatementNode.modify()\n+                .withMatchKeyword(matchKeyword)\n+                .withCondition(condition)\n+                .withOpenBrace(openBrace)\n+                .withMatchClauses(matchClauses)\n+                .withCloseBrace(closeBrace)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MatchClauseNode transform(MatchClauseNode matchClauseNode) {\n+        SeparatedNodeList<Node> matchPatterns = formatSeparatedNodeList(matchClauseNode.matchPatterns(),\n+                0, 0, 0, 0, 1, 0);\n+\n+        if (matchClauseNode.matchGuard().isPresent()) {\n+            MatchGuardNode matchGuard = formatNode(matchClauseNode.matchGuard().get(), 1, 0);\n+            matchClauseNode = matchClauseNode.modify().withMatchGuard(matchGuard).apply();\n+        }\n+\n+        Token rightDoubleArrow = formatToken(matchClauseNode.rightDoubleArrow(), 1, 0);\n+        BlockStatementNode blockStatement = formatNode(matchClauseNode.blockStatement(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return matchClauseNode.modify()\n+                .withMatchPatterns(matchPatterns)\n+                .withRightDoubleArrow(rightDoubleArrow)\n+                .withBlockStatement(blockStatement)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MatchGuardNode transform(MatchGuardNode matchGuardNode) {\n+        Token ifKeyword = formatToken(matchGuardNode.ifKeyword(), 1, 0);\n+        ExpressionNode expression = formatNode(matchGuardNode.expression(), this.trailingWS, this.trailingNL);\n+\n+        return matchGuardNode.modify()\n+                .withIfKeyword(ifKeyword)\n+                .withExpression(expression)\n+                .apply();\n+    }\n+\n+    @Override\n+    public LockStatementNode transform(LockStatementNode lockStatementNode) {\n+        Token lockKeyword = formatToken(lockStatementNode.lockKeyword(), 1, 0);\n+        StatementNode blockStatement;\n+\n+        if (lockStatementNode.onFailClause().isPresent()) {\n+            blockStatement = formatNode(lockStatementNode.blockStatement(), 1, 0);\n+            OnFailClauseNode onFailClause = formatNode(lockStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            lockStatementNode = lockStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        } else {\n+            blockStatement = formatNode(lockStatementNode.blockStatement(), this.trailingWS, this.trailingNL);\n+        }\n+\n+        return lockStatementNode.modify()\n+                .withLockKeyword(lockKeyword)\n+                .withBlockStatement(blockStatement)\n+                .apply();\n+    }\n+\n+    @Override\n+    public FieldAccessExpressionNode transform(FieldAccessExpressionNode fieldAccessExpressionNode) {\n+        ExpressionNode expression = formatNode(fieldAccessExpressionNode.expression(), 0, 0);\n+        Token dotToken = formatToken(fieldAccessExpressionNode.dotToken(), 0, 0);\n+        NameReferenceNode fieldName = formatNode(fieldAccessExpressionNode.fieldName(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return fieldAccessExpressionNode.modify()\n+                .withExpression(expression)\n+                .withDotToken(dotToken)\n+                .withFieldName(fieldName)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MetadataNode transform(MetadataNode metadataNode) {\n+        NodeList<AnnotationNode> annotations = formatNodeList(metadataNode.annotations(), 0, 1, 0, 1);\n+\n+        if (metadataNode.documentationString().isPresent()) {\n+            Node documentationString = formatNode(metadataNode.documentationString().get(),\n+                    this.trailingWS, this.trailingNL);\n+            metadataNode = metadataNode.modify().withDocumentationString(documentationString).apply();\n+        }\n+\n+        return metadataNode.modify()\n+                .withAnnotations(annotations)\n+                .apply();\n+    }\n+\n+    @Override\n+    public EnumDeclarationNode transform(EnumDeclarationNode enumDeclarationNode) {\n+        if (enumDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(enumDeclarationNode.metadata().get(), 0, 1);\n+            enumDeclarationNode = enumDeclarationNode.modify()\n+                    .withMetadata(metadata).apply();\n+        }\n+\n+        Token qualifier = formatToken(enumDeclarationNode.qualifier(), 1, 0);\n+        Token enumKeywordToken = formatToken(enumDeclarationNode.enumKeywordToken(), 1, 0);\n+        IdentifierToken identifier = formatNode(enumDeclarationNode.identifier(), 1, 0);\n+        Token openBraceToken = formatToken(enumDeclarationNode.openBraceToken(), 0, 1);\n+        indent();\n+        SeparatedNodeList<Node> enumMemberList = formatSeparatedNodeList(enumDeclarationNode.enumMemberList(),\n+                0, 0, 0, 1, 0, 1);\n+        unindent();\n+        Token closeBraceToken = formatToken(enumDeclarationNode.closeBraceToken(), this.trailingWS, this.trailingNL);\n+\n+        return enumDeclarationNode.modify()\n+                .withQualifier(qualifier)\n+                .withEnumKeywordToken(enumKeywordToken)\n+                .withIdentifier(identifier)\n+                .withOpenBraceToken(openBraceToken)\n+                .withEnumMemberList(enumMemberList)\n+                .withCloseBraceToken(closeBraceToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public EnumMemberNode transform(EnumMemberNode enumMemberNode) {\n+        if (enumMemberNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(enumMemberNode.metadata().get(), 0, 1);\n+            enumMemberNode = enumMemberNode.modify().withMetadata(metadata).apply();\n+        }\n+        IdentifierToken identifier;\n+\n+        if (enumMemberNode.equalToken().isPresent()) {\n+            identifier = formatNode(enumMemberNode.identifier(), 1, 0);\n+            Token equalToken = formatToken(enumMemberNode.equalToken().get(), 1, 0);\n+            ExpressionNode constExprNode = formatNode(enumMemberNode.constExprNode().get(),\n+                    this.trailingWS, this.trailingNL);\n+\n+            return enumMemberNode.modify()\n+                    .withIdentifier(identifier)\n+                    .withEqualToken(equalToken)\n+                    .withConstExprNode(constExprNode)\n+                    .apply();\n+        } else {\n+            identifier = formatNode(enumMemberNode.identifier(), this.trailingWS, this.trailingNL);\n+\n+            return enumMemberNode.modify()\n+                    .withIdentifier(identifier)\n+                    .apply();\n+        }\n+    }\n+\n+    @Override\n+    public MarkdownDocumentationNode transform(MarkdownDocumentationNode markdownDocumentationNode) {\n+        NodeList<Node> documentationLines = formatNodeList(markdownDocumentationNode.documentationLines(),\n+                0, 0, this.trailingWS, this.trailingNL);\n+\n+        return markdownDocumentationNode.modify()\n+                .withDocumentationLines(documentationLines)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MarkdownDocumentationLineNode transform(MarkdownDocumentationLineNode markdownDocumentationLineNode) {\n+        Token hashToken = formatToken(markdownDocumentationLineNode.hashToken(), 0, 0);\n+        NodeList<Node> documentElements = formatNodeList(markdownDocumentationLineNode.documentElements(),\n+                0, 0, this.trailingWS, this.trailingNL);\n+\n+        return markdownDocumentationLineNode.modify()\n+                .withDocumentElements(documentElements)\n+                .withHashToken(hashToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MarkdownParameterDocumentationLineNode transform(\n+            MarkdownParameterDocumentationLineNode markdownParameterDocumentationLineNode) {\n+        Token hashToken = formatToken(markdownParameterDocumentationLineNode.hashToken(), 1, 0);\n+        Token plusToken = formatToken(markdownParameterDocumentationLineNode.plusToken(), 1, 0);\n+        Token parameterName = formatToken(markdownParameterDocumentationLineNode.parameterName(), 1, 0);\n+        Token minusToken = formatToken(markdownParameterDocumentationLineNode.minusToken(), 0, 0);\n+        NodeList<Node> documentElements = formatNodeList(markdownParameterDocumentationLineNode.documentElements(),\n+                0, 0, this.trailingWS, this.trailingNL);\n+\n+        return markdownParameterDocumentationLineNode.modify()\n+                .withHashToken(hashToken)\n+                .withPlusToken(plusToken)\n+                .withParameterName(parameterName)\n+                .withMinusToken(minusToken)\n+                .withDocumentElements(documentElements)\n+                .apply();\n+    }\n+\n+    @Override\n+    public DocumentationReferenceNode transform(DocumentationReferenceNode documentationReferenceNode) {\n+        if (documentationReferenceNode.referenceType().isPresent()) {\n+            Token referenceType = formatToken(documentationReferenceNode.referenceType().get(), 1, 0);\n+            documentationReferenceNode = documentationReferenceNode.modify().withReferenceType(referenceType).apply();\n+        }\n+\n+        Token startBacktick = formatToken(documentationReferenceNode.startBacktick(), 0, 0);\n+        Node backtickContent = formatNode(documentationReferenceNode.backtickContent(), 0, 0);\n+        Token endBacktick = formatToken(documentationReferenceNode.endBacktick(), this.trailingWS, this.trailingNL);\n+\n+        return documentationReferenceNode.modify()\n+                .withStartBacktick(startBacktick)\n+                .withBacktickContent(backtickContent)\n+                .withEndBacktick(endBacktick)\n+                .apply();\n+    }\n+\n+    @Override\n+    public PositionalArgumentNode transform(PositionalArgumentNode positionalArgumentNode) {\n+\n+        return super.transform(positionalArgumentNode);\n+    }\n+\n+    @Override\n+    public MappingBindingPatternNode transform(MappingBindingPatternNode mappingBindingPatternNode) {\n+\n+        return super.transform(mappingBindingPatternNode);\n+    }\n+\n+    @Override\n+    public FieldBindingPatternFullNode transform(FieldBindingPatternFullNode fieldBindingPatternFullNode) {\n+\n+        return super.transform(fieldBindingPatternFullNode);\n+    }\n+\n+    @Override\n+    public FieldBindingPatternVarnameNode transform(FieldBindingPatternVarnameNode fieldBindingPatternVarnameNode) {\n+\n+        return super.transform(fieldBindingPatternVarnameNode);\n+    }\n+\n+    @Override\n+    public TypeTestExpressionNode transform(TypeTestExpressionNode typeTestExpressionNode) {\n+\n+        return super.transform(typeTestExpressionNode);\n+    }\n+\n+    @Override\n+    public ListenerDeclarationNode transform(ListenerDeclarationNode listenerDeclarationNode) {\n+\n+        return super.transform(listenerDeclarationNode);\n+    }\n+\n+    @Override\n+    public ArrayTypeDescriptorNode transform(ArrayTypeDescriptorNode arrayTypeDescriptorNode) {\n+\n+        return super.transform(arrayTypeDescriptorNode);\n+    }\n+\n+    @Override\n+    public MethodCallExpressionNode transform(MethodCallExpressionNode methodCallExpressionNode) {\n+\n+        return super.transform(methodCallExpressionNode);\n+    }\n+\n+    @Override\n+    public NilLiteralNode transform(NilLiteralNode nilLiteralNode) {\n+        Token openParenToken = formatToken(nilLiteralNode.openParenToken(), 0, 0);\n+        Token closeParenToken = formatToken(nilLiteralNode.closeParenToken(), this.trailingWS, this.trailingNL);\n+\n+        return nilLiteralNode.modify()\n+                .withOpenParenToken(openParenToken)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public XMLNamespaceDeclarationNode transform(XMLNamespaceDeclarationNode xMLNamespaceDeclarationNode) {\n+        Token xmlnsKeyword = formatToken(xMLNamespaceDeclarationNode.xmlnsKeyword(), 1, 0);\n+        ExpressionNode namespaceuri;\n+\n+        if (xMLNamespaceDeclarationNode.asKeyword().isPresent()) {\n+            Token asKeyword = formatToken(xMLNamespaceDeclarationNode.asKeyword().get(), 1, 0);\n+            xMLNamespaceDeclarationNode = xMLNamespaceDeclarationNode.modify()\n+                    .withAsKeyword(asKeyword).apply();\n+        }\n+\n+        if (xMLNamespaceDeclarationNode.namespacePrefix().isPresent()) {", "originalCommit": "81330a2ede4dfaf5c68da3c18352254e103d9c0f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzMxMDUxMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26316#discussion_r503310513", "bodyText": "Looks like theres a bug in the syntax-tree. xmlns-prefix should be optional. Shall we create an issue?", "author": "SupunS", "createdAt": "2020-10-12T13:51:14Z", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -1328,270 +1452,1389 @@ public ListBindingPatternNode transform(ListBindingPatternNode listBindingPatter\n             listBindingPatternNode = listBindingPatternNode.modify().withRestBindingPattern(restBindingPattern).apply();\n         }\n \n-        return listBindingPatternNode.modify()\n-                .withOpenBracket(openBracket)\n-                .withBindingPatterns(bindingPatternNodes)\n-                .withCloseBracket(closeBracket)\n-                .apply();\n+        return listBindingPatternNode.modify()\n+                .withOpenBracket(openBracket)\n+                .withBindingPatterns(bindingPatternNodes)\n+                .withCloseBracket(closeBracket)\n+                .apply();\n+    }\n+\n+    @Override\n+    public RestBindingPatternNode transform(RestBindingPatternNode restBindingPatternNode) {\n+        Token ellipsisToken = formatToken(restBindingPatternNode.ellipsisToken(), 0, 0);\n+        SimpleNameReferenceNode variableName = formatNode(restBindingPatternNode.variableName(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return restBindingPatternNode.modify()\n+                .withEllipsisToken(ellipsisToken)\n+                .withVariableName(variableName)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TableTypeDescriptorNode transform(TableTypeDescriptorNode tableTypeDescriptorNode) {\n+        Token tableKeywordToken = formatToken(tableTypeDescriptorNode.tableKeywordToken(), 0, 0);\n+        Node rowTypeParameterNode = formatNode(tableTypeDescriptorNode.rowTypeParameterNode(), 1, 0);\n+        Node keyConstraintNode = formatNode(tableTypeDescriptorNode.keyConstraintNode(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return tableTypeDescriptorNode.modify()\n+                .withTableKeywordToken(tableKeywordToken)\n+                .withRowTypeParameterNode(rowTypeParameterNode)\n+                .withKeyConstraintNode(keyConstraintNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public KeyTypeConstraintNode transform(KeyTypeConstraintNode keyTypeConstraintNode) {\n+        Token keyKeywordToken = formatToken(keyTypeConstraintNode.keyKeywordToken(), 0, 0);\n+        Node typeParameterNode = formatNode(keyTypeConstraintNode.typeParameterNode(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return keyTypeConstraintNode.modify()\n+                .withKeyKeywordToken(keyKeywordToken)\n+                .withTypeParameterNode(typeParameterNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MatchStatementNode transform(MatchStatementNode matchStatementNode) {\n+        boolean hasOnFailClause = matchStatementNode.onFailClause().isPresent();\n+        Token matchKeyword = formatToken(matchStatementNode.matchKeyword(), 1, 0);\n+        ExpressionNode condition = formatNode(matchStatementNode.condition(), 1, 0);\n+        Token openBrace = formatToken(matchStatementNode.openBrace(), 0, 1);\n+        indent();\n+        NodeList<MatchClauseNode> matchClauses = formatNodeList(matchStatementNode.matchClauses(), 0, 1, 0, 1);\n+        unindent();\n+        Token closeBrace;\n+\n+        if (hasOnFailClause) {\n+            closeBrace = formatToken(matchStatementNode.closeBrace(), 1, 0);\n+            OnFailClauseNode onFailClause = formatNode(matchStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            matchStatementNode = matchStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        } else {\n+            closeBrace = formatToken(matchStatementNode.closeBrace(), this.trailingWS, this.trailingNL);\n+        }\n+\n+        return matchStatementNode.modify()\n+                .withMatchKeyword(matchKeyword)\n+                .withCondition(condition)\n+                .withOpenBrace(openBrace)\n+                .withMatchClauses(matchClauses)\n+                .withCloseBrace(closeBrace)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MatchClauseNode transform(MatchClauseNode matchClauseNode) {\n+        SeparatedNodeList<Node> matchPatterns = formatSeparatedNodeList(matchClauseNode.matchPatterns(),\n+                0, 0, 0, 0, 1, 0);\n+\n+        if (matchClauseNode.matchGuard().isPresent()) {\n+            MatchGuardNode matchGuard = formatNode(matchClauseNode.matchGuard().get(), 1, 0);\n+            matchClauseNode = matchClauseNode.modify().withMatchGuard(matchGuard).apply();\n+        }\n+\n+        Token rightDoubleArrow = formatToken(matchClauseNode.rightDoubleArrow(), 1, 0);\n+        BlockStatementNode blockStatement = formatNode(matchClauseNode.blockStatement(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return matchClauseNode.modify()\n+                .withMatchPatterns(matchPatterns)\n+                .withRightDoubleArrow(rightDoubleArrow)\n+                .withBlockStatement(blockStatement)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MatchGuardNode transform(MatchGuardNode matchGuardNode) {\n+        Token ifKeyword = formatToken(matchGuardNode.ifKeyword(), 1, 0);\n+        ExpressionNode expression = formatNode(matchGuardNode.expression(), this.trailingWS, this.trailingNL);\n+\n+        return matchGuardNode.modify()\n+                .withIfKeyword(ifKeyword)\n+                .withExpression(expression)\n+                .apply();\n+    }\n+\n+    @Override\n+    public LockStatementNode transform(LockStatementNode lockStatementNode) {\n+        Token lockKeyword = formatToken(lockStatementNode.lockKeyword(), 1, 0);\n+        StatementNode blockStatement;\n+\n+        if (lockStatementNode.onFailClause().isPresent()) {\n+            blockStatement = formatNode(lockStatementNode.blockStatement(), 1, 0);\n+            OnFailClauseNode onFailClause = formatNode(lockStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            lockStatementNode = lockStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        } else {\n+            blockStatement = formatNode(lockStatementNode.blockStatement(), this.trailingWS, this.trailingNL);\n+        }\n+\n+        return lockStatementNode.modify()\n+                .withLockKeyword(lockKeyword)\n+                .withBlockStatement(blockStatement)\n+                .apply();\n+    }\n+\n+    @Override\n+    public FieldAccessExpressionNode transform(FieldAccessExpressionNode fieldAccessExpressionNode) {\n+        ExpressionNode expression = formatNode(fieldAccessExpressionNode.expression(), 0, 0);\n+        Token dotToken = formatToken(fieldAccessExpressionNode.dotToken(), 0, 0);\n+        NameReferenceNode fieldName = formatNode(fieldAccessExpressionNode.fieldName(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return fieldAccessExpressionNode.modify()\n+                .withExpression(expression)\n+                .withDotToken(dotToken)\n+                .withFieldName(fieldName)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MetadataNode transform(MetadataNode metadataNode) {\n+        NodeList<AnnotationNode> annotations = formatNodeList(metadataNode.annotations(), 0, 1, 0, 1);\n+\n+        if (metadataNode.documentationString().isPresent()) {\n+            Node documentationString = formatNode(metadataNode.documentationString().get(),\n+                    this.trailingWS, this.trailingNL);\n+            metadataNode = metadataNode.modify().withDocumentationString(documentationString).apply();\n+        }\n+\n+        return metadataNode.modify()\n+                .withAnnotations(annotations)\n+                .apply();\n+    }\n+\n+    @Override\n+    public EnumDeclarationNode transform(EnumDeclarationNode enumDeclarationNode) {\n+        if (enumDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(enumDeclarationNode.metadata().get(), 0, 1);\n+            enumDeclarationNode = enumDeclarationNode.modify()\n+                    .withMetadata(metadata).apply();\n+        }\n+\n+        Token qualifier = formatToken(enumDeclarationNode.qualifier(), 1, 0);\n+        Token enumKeywordToken = formatToken(enumDeclarationNode.enumKeywordToken(), 1, 0);\n+        IdentifierToken identifier = formatNode(enumDeclarationNode.identifier(), 1, 0);\n+        Token openBraceToken = formatToken(enumDeclarationNode.openBraceToken(), 0, 1);\n+        indent();\n+        SeparatedNodeList<Node> enumMemberList = formatSeparatedNodeList(enumDeclarationNode.enumMemberList(),\n+                0, 0, 0, 1, 0, 1);\n+        unindent();\n+        Token closeBraceToken = formatToken(enumDeclarationNode.closeBraceToken(), this.trailingWS, this.trailingNL);\n+\n+        return enumDeclarationNode.modify()\n+                .withQualifier(qualifier)\n+                .withEnumKeywordToken(enumKeywordToken)\n+                .withIdentifier(identifier)\n+                .withOpenBraceToken(openBraceToken)\n+                .withEnumMemberList(enumMemberList)\n+                .withCloseBraceToken(closeBraceToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public EnumMemberNode transform(EnumMemberNode enumMemberNode) {\n+        if (enumMemberNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(enumMemberNode.metadata().get(), 0, 1);\n+            enumMemberNode = enumMemberNode.modify().withMetadata(metadata).apply();\n+        }\n+        IdentifierToken identifier;\n+\n+        if (enumMemberNode.equalToken().isPresent()) {\n+            identifier = formatNode(enumMemberNode.identifier(), 1, 0);\n+            Token equalToken = formatToken(enumMemberNode.equalToken().get(), 1, 0);\n+            ExpressionNode constExprNode = formatNode(enumMemberNode.constExprNode().get(),\n+                    this.trailingWS, this.trailingNL);\n+\n+            return enumMemberNode.modify()\n+                    .withIdentifier(identifier)\n+                    .withEqualToken(equalToken)\n+                    .withConstExprNode(constExprNode)\n+                    .apply();\n+        } else {\n+            identifier = formatNode(enumMemberNode.identifier(), this.trailingWS, this.trailingNL);\n+\n+            return enumMemberNode.modify()\n+                    .withIdentifier(identifier)\n+                    .apply();\n+        }\n+    }\n+\n+    @Override\n+    public MarkdownDocumentationNode transform(MarkdownDocumentationNode markdownDocumentationNode) {\n+        NodeList<Node> documentationLines = formatNodeList(markdownDocumentationNode.documentationLines(),\n+                0, 0, this.trailingWS, this.trailingNL);\n+\n+        return markdownDocumentationNode.modify()\n+                .withDocumentationLines(documentationLines)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MarkdownDocumentationLineNode transform(MarkdownDocumentationLineNode markdownDocumentationLineNode) {\n+        Token hashToken = formatToken(markdownDocumentationLineNode.hashToken(), 0, 0);\n+        NodeList<Node> documentElements = formatNodeList(markdownDocumentationLineNode.documentElements(),\n+                0, 0, this.trailingWS, this.trailingNL);\n+\n+        return markdownDocumentationLineNode.modify()\n+                .withDocumentElements(documentElements)\n+                .withHashToken(hashToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MarkdownParameterDocumentationLineNode transform(\n+            MarkdownParameterDocumentationLineNode markdownParameterDocumentationLineNode) {\n+        Token hashToken = formatToken(markdownParameterDocumentationLineNode.hashToken(), 1, 0);\n+        Token plusToken = formatToken(markdownParameterDocumentationLineNode.plusToken(), 1, 0);\n+        Token parameterName = formatToken(markdownParameterDocumentationLineNode.parameterName(), 1, 0);\n+        Token minusToken = formatToken(markdownParameterDocumentationLineNode.minusToken(), 0, 0);\n+        NodeList<Node> documentElements = formatNodeList(markdownParameterDocumentationLineNode.documentElements(),\n+                0, 0, this.trailingWS, this.trailingNL);\n+\n+        return markdownParameterDocumentationLineNode.modify()\n+                .withHashToken(hashToken)\n+                .withPlusToken(plusToken)\n+                .withParameterName(parameterName)\n+                .withMinusToken(minusToken)\n+                .withDocumentElements(documentElements)\n+                .apply();\n+    }\n+\n+    @Override\n+    public DocumentationReferenceNode transform(DocumentationReferenceNode documentationReferenceNode) {\n+        if (documentationReferenceNode.referenceType().isPresent()) {\n+            Token referenceType = formatToken(documentationReferenceNode.referenceType().get(), 1, 0);\n+            documentationReferenceNode = documentationReferenceNode.modify().withReferenceType(referenceType).apply();\n+        }\n+\n+        Token startBacktick = formatToken(documentationReferenceNode.startBacktick(), 0, 0);\n+        Node backtickContent = formatNode(documentationReferenceNode.backtickContent(), 0, 0);\n+        Token endBacktick = formatToken(documentationReferenceNode.endBacktick(), this.trailingWS, this.trailingNL);\n+\n+        return documentationReferenceNode.modify()\n+                .withStartBacktick(startBacktick)\n+                .withBacktickContent(backtickContent)\n+                .withEndBacktick(endBacktick)\n+                .apply();\n+    }\n+\n+    @Override\n+    public PositionalArgumentNode transform(PositionalArgumentNode positionalArgumentNode) {\n+\n+        return super.transform(positionalArgumentNode);\n+    }\n+\n+    @Override\n+    public MappingBindingPatternNode transform(MappingBindingPatternNode mappingBindingPatternNode) {\n+\n+        return super.transform(mappingBindingPatternNode);\n+    }\n+\n+    @Override\n+    public FieldBindingPatternFullNode transform(FieldBindingPatternFullNode fieldBindingPatternFullNode) {\n+\n+        return super.transform(fieldBindingPatternFullNode);\n+    }\n+\n+    @Override\n+    public FieldBindingPatternVarnameNode transform(FieldBindingPatternVarnameNode fieldBindingPatternVarnameNode) {\n+\n+        return super.transform(fieldBindingPatternVarnameNode);\n+    }\n+\n+    @Override\n+    public TypeTestExpressionNode transform(TypeTestExpressionNode typeTestExpressionNode) {\n+\n+        return super.transform(typeTestExpressionNode);\n+    }\n+\n+    @Override\n+    public ListenerDeclarationNode transform(ListenerDeclarationNode listenerDeclarationNode) {\n+\n+        return super.transform(listenerDeclarationNode);\n+    }\n+\n+    @Override\n+    public ArrayTypeDescriptorNode transform(ArrayTypeDescriptorNode arrayTypeDescriptorNode) {\n+\n+        return super.transform(arrayTypeDescriptorNode);\n+    }\n+\n+    @Override\n+    public MethodCallExpressionNode transform(MethodCallExpressionNode methodCallExpressionNode) {\n+\n+        return super.transform(methodCallExpressionNode);\n+    }\n+\n+    @Override\n+    public NilLiteralNode transform(NilLiteralNode nilLiteralNode) {\n+        Token openParenToken = formatToken(nilLiteralNode.openParenToken(), 0, 0);\n+        Token closeParenToken = formatToken(nilLiteralNode.closeParenToken(), this.trailingWS, this.trailingNL);\n+\n+        return nilLiteralNode.modify()\n+                .withOpenParenToken(openParenToken)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public XMLNamespaceDeclarationNode transform(XMLNamespaceDeclarationNode xMLNamespaceDeclarationNode) {\n+        Token xmlnsKeyword = formatToken(xMLNamespaceDeclarationNode.xmlnsKeyword(), 1, 0);\n+        ExpressionNode namespaceuri;\n+\n+        if (xMLNamespaceDeclarationNode.asKeyword().isPresent()) {\n+            Token asKeyword = formatToken(xMLNamespaceDeclarationNode.asKeyword().get(), 1, 0);\n+            xMLNamespaceDeclarationNode = xMLNamespaceDeclarationNode.modify()\n+                    .withAsKeyword(asKeyword).apply();\n+        }\n+\n+        if (xMLNamespaceDeclarationNode.namespacePrefix().isPresent()) {\n+            namespaceuri = formatNode(xMLNamespaceDeclarationNode.namespaceuri(), 1, 0);\n+            IdentifierToken namespacePrefix = formatNode(xMLNamespaceDeclarationNode.namespacePrefix().get(), 0, 0);\n+            xMLNamespaceDeclarationNode = xMLNamespaceDeclarationNode.modify()\n+                    .withNamespacePrefix(namespacePrefix).apply();\n+        } else {\n+            namespaceuri = formatNode(xMLNamespaceDeclarationNode.namespaceuri(), 0, 0);\n+        }\n+\n+        Token semicolonToken = formatToken(xMLNamespaceDeclarationNode.semicolonToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return xMLNamespaceDeclarationNode.modify()\n+                .withXmlnsKeyword(xmlnsKeyword)\n+                .withNamespaceuri(namespaceuri)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ModuleXMLNamespaceDeclarationNode transform(\n+            ModuleXMLNamespaceDeclarationNode moduleXMLNamespaceDeclarationNode) {\n+        Token xmlnsKeyword = formatToken(moduleXMLNamespaceDeclarationNode.xmlnsKeyword(), 1, 0);\n+        ExpressionNode namespaceuri = formatNode(moduleXMLNamespaceDeclarationNode.namespaceuri(), 1, 0);\n+        Token asKeyword = formatToken(moduleXMLNamespaceDeclarationNode.asKeyword(), 1, 0);", "originalCommit": "81330a2ede4dfaf5c68da3c18352254e103d9c0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzcxMzcwNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26316#discussion_r503713704", "bodyText": "#26328", "author": "IrushiL", "createdAt": "2020-10-13T07:07:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzMxMDUxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzMxMjcwOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26316#discussion_r503312708", "bodyText": "We might have to trim/cleanup the ws/newlines inside the text-content. Let's track this in an issue.", "author": "SupunS", "createdAt": "2020-10-12T13:54:30Z", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -1328,270 +1452,1389 @@ public ListBindingPatternNode transform(ListBindingPatternNode listBindingPatter\n             listBindingPatternNode = listBindingPatternNode.modify().withRestBindingPattern(restBindingPattern).apply();\n         }\n \n-        return listBindingPatternNode.modify()\n-                .withOpenBracket(openBracket)\n-                .withBindingPatterns(bindingPatternNodes)\n-                .withCloseBracket(closeBracket)\n-                .apply();\n+        return listBindingPatternNode.modify()\n+                .withOpenBracket(openBracket)\n+                .withBindingPatterns(bindingPatternNodes)\n+                .withCloseBracket(closeBracket)\n+                .apply();\n+    }\n+\n+    @Override\n+    public RestBindingPatternNode transform(RestBindingPatternNode restBindingPatternNode) {\n+        Token ellipsisToken = formatToken(restBindingPatternNode.ellipsisToken(), 0, 0);\n+        SimpleNameReferenceNode variableName = formatNode(restBindingPatternNode.variableName(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return restBindingPatternNode.modify()\n+                .withEllipsisToken(ellipsisToken)\n+                .withVariableName(variableName)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TableTypeDescriptorNode transform(TableTypeDescriptorNode tableTypeDescriptorNode) {\n+        Token tableKeywordToken = formatToken(tableTypeDescriptorNode.tableKeywordToken(), 0, 0);\n+        Node rowTypeParameterNode = formatNode(tableTypeDescriptorNode.rowTypeParameterNode(), 1, 0);\n+        Node keyConstraintNode = formatNode(tableTypeDescriptorNode.keyConstraintNode(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return tableTypeDescriptorNode.modify()\n+                .withTableKeywordToken(tableKeywordToken)\n+                .withRowTypeParameterNode(rowTypeParameterNode)\n+                .withKeyConstraintNode(keyConstraintNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public KeyTypeConstraintNode transform(KeyTypeConstraintNode keyTypeConstraintNode) {\n+        Token keyKeywordToken = formatToken(keyTypeConstraintNode.keyKeywordToken(), 0, 0);\n+        Node typeParameterNode = formatNode(keyTypeConstraintNode.typeParameterNode(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return keyTypeConstraintNode.modify()\n+                .withKeyKeywordToken(keyKeywordToken)\n+                .withTypeParameterNode(typeParameterNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MatchStatementNode transform(MatchStatementNode matchStatementNode) {\n+        boolean hasOnFailClause = matchStatementNode.onFailClause().isPresent();\n+        Token matchKeyword = formatToken(matchStatementNode.matchKeyword(), 1, 0);\n+        ExpressionNode condition = formatNode(matchStatementNode.condition(), 1, 0);\n+        Token openBrace = formatToken(matchStatementNode.openBrace(), 0, 1);\n+        indent();\n+        NodeList<MatchClauseNode> matchClauses = formatNodeList(matchStatementNode.matchClauses(), 0, 1, 0, 1);\n+        unindent();\n+        Token closeBrace;\n+\n+        if (hasOnFailClause) {\n+            closeBrace = formatToken(matchStatementNode.closeBrace(), 1, 0);\n+            OnFailClauseNode onFailClause = formatNode(matchStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            matchStatementNode = matchStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        } else {\n+            closeBrace = formatToken(matchStatementNode.closeBrace(), this.trailingWS, this.trailingNL);\n+        }\n+\n+        return matchStatementNode.modify()\n+                .withMatchKeyword(matchKeyword)\n+                .withCondition(condition)\n+                .withOpenBrace(openBrace)\n+                .withMatchClauses(matchClauses)\n+                .withCloseBrace(closeBrace)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MatchClauseNode transform(MatchClauseNode matchClauseNode) {\n+        SeparatedNodeList<Node> matchPatterns = formatSeparatedNodeList(matchClauseNode.matchPatterns(),\n+                0, 0, 0, 0, 1, 0);\n+\n+        if (matchClauseNode.matchGuard().isPresent()) {\n+            MatchGuardNode matchGuard = formatNode(matchClauseNode.matchGuard().get(), 1, 0);\n+            matchClauseNode = matchClauseNode.modify().withMatchGuard(matchGuard).apply();\n+        }\n+\n+        Token rightDoubleArrow = formatToken(matchClauseNode.rightDoubleArrow(), 1, 0);\n+        BlockStatementNode blockStatement = formatNode(matchClauseNode.blockStatement(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return matchClauseNode.modify()\n+                .withMatchPatterns(matchPatterns)\n+                .withRightDoubleArrow(rightDoubleArrow)\n+                .withBlockStatement(blockStatement)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MatchGuardNode transform(MatchGuardNode matchGuardNode) {\n+        Token ifKeyword = formatToken(matchGuardNode.ifKeyword(), 1, 0);\n+        ExpressionNode expression = formatNode(matchGuardNode.expression(), this.trailingWS, this.trailingNL);\n+\n+        return matchGuardNode.modify()\n+                .withIfKeyword(ifKeyword)\n+                .withExpression(expression)\n+                .apply();\n+    }\n+\n+    @Override\n+    public LockStatementNode transform(LockStatementNode lockStatementNode) {\n+        Token lockKeyword = formatToken(lockStatementNode.lockKeyword(), 1, 0);\n+        StatementNode blockStatement;\n+\n+        if (lockStatementNode.onFailClause().isPresent()) {\n+            blockStatement = formatNode(lockStatementNode.blockStatement(), 1, 0);\n+            OnFailClauseNode onFailClause = formatNode(lockStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            lockStatementNode = lockStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        } else {\n+            blockStatement = formatNode(lockStatementNode.blockStatement(), this.trailingWS, this.trailingNL);\n+        }\n+\n+        return lockStatementNode.modify()\n+                .withLockKeyword(lockKeyword)\n+                .withBlockStatement(blockStatement)\n+                .apply();\n+    }\n+\n+    @Override\n+    public FieldAccessExpressionNode transform(FieldAccessExpressionNode fieldAccessExpressionNode) {\n+        ExpressionNode expression = formatNode(fieldAccessExpressionNode.expression(), 0, 0);\n+        Token dotToken = formatToken(fieldAccessExpressionNode.dotToken(), 0, 0);\n+        NameReferenceNode fieldName = formatNode(fieldAccessExpressionNode.fieldName(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return fieldAccessExpressionNode.modify()\n+                .withExpression(expression)\n+                .withDotToken(dotToken)\n+                .withFieldName(fieldName)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MetadataNode transform(MetadataNode metadataNode) {\n+        NodeList<AnnotationNode> annotations = formatNodeList(metadataNode.annotations(), 0, 1, 0, 1);\n+\n+        if (metadataNode.documentationString().isPresent()) {\n+            Node documentationString = formatNode(metadataNode.documentationString().get(),\n+                    this.trailingWS, this.trailingNL);\n+            metadataNode = metadataNode.modify().withDocumentationString(documentationString).apply();\n+        }\n+\n+        return metadataNode.modify()\n+                .withAnnotations(annotations)\n+                .apply();\n+    }\n+\n+    @Override\n+    public EnumDeclarationNode transform(EnumDeclarationNode enumDeclarationNode) {\n+        if (enumDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(enumDeclarationNode.metadata().get(), 0, 1);\n+            enumDeclarationNode = enumDeclarationNode.modify()\n+                    .withMetadata(metadata).apply();\n+        }\n+\n+        Token qualifier = formatToken(enumDeclarationNode.qualifier(), 1, 0);\n+        Token enumKeywordToken = formatToken(enumDeclarationNode.enumKeywordToken(), 1, 0);\n+        IdentifierToken identifier = formatNode(enumDeclarationNode.identifier(), 1, 0);\n+        Token openBraceToken = formatToken(enumDeclarationNode.openBraceToken(), 0, 1);\n+        indent();\n+        SeparatedNodeList<Node> enumMemberList = formatSeparatedNodeList(enumDeclarationNode.enumMemberList(),\n+                0, 0, 0, 1, 0, 1);\n+        unindent();\n+        Token closeBraceToken = formatToken(enumDeclarationNode.closeBraceToken(), this.trailingWS, this.trailingNL);\n+\n+        return enumDeclarationNode.modify()\n+                .withQualifier(qualifier)\n+                .withEnumKeywordToken(enumKeywordToken)\n+                .withIdentifier(identifier)\n+                .withOpenBraceToken(openBraceToken)\n+                .withEnumMemberList(enumMemberList)\n+                .withCloseBraceToken(closeBraceToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public EnumMemberNode transform(EnumMemberNode enumMemberNode) {\n+        if (enumMemberNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(enumMemberNode.metadata().get(), 0, 1);\n+            enumMemberNode = enumMemberNode.modify().withMetadata(metadata).apply();\n+        }\n+        IdentifierToken identifier;\n+\n+        if (enumMemberNode.equalToken().isPresent()) {\n+            identifier = formatNode(enumMemberNode.identifier(), 1, 0);\n+            Token equalToken = formatToken(enumMemberNode.equalToken().get(), 1, 0);\n+            ExpressionNode constExprNode = formatNode(enumMemberNode.constExprNode().get(),\n+                    this.trailingWS, this.trailingNL);\n+\n+            return enumMemberNode.modify()\n+                    .withIdentifier(identifier)\n+                    .withEqualToken(equalToken)\n+                    .withConstExprNode(constExprNode)\n+                    .apply();\n+        } else {\n+            identifier = formatNode(enumMemberNode.identifier(), this.trailingWS, this.trailingNL);\n+\n+            return enumMemberNode.modify()\n+                    .withIdentifier(identifier)\n+                    .apply();\n+        }\n+    }\n+\n+    @Override\n+    public MarkdownDocumentationNode transform(MarkdownDocumentationNode markdownDocumentationNode) {\n+        NodeList<Node> documentationLines = formatNodeList(markdownDocumentationNode.documentationLines(),\n+                0, 0, this.trailingWS, this.trailingNL);\n+\n+        return markdownDocumentationNode.modify()\n+                .withDocumentationLines(documentationLines)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MarkdownDocumentationLineNode transform(MarkdownDocumentationLineNode markdownDocumentationLineNode) {\n+        Token hashToken = formatToken(markdownDocumentationLineNode.hashToken(), 0, 0);\n+        NodeList<Node> documentElements = formatNodeList(markdownDocumentationLineNode.documentElements(),\n+                0, 0, this.trailingWS, this.trailingNL);\n+\n+        return markdownDocumentationLineNode.modify()\n+                .withDocumentElements(documentElements)\n+                .withHashToken(hashToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MarkdownParameterDocumentationLineNode transform(\n+            MarkdownParameterDocumentationLineNode markdownParameterDocumentationLineNode) {\n+        Token hashToken = formatToken(markdownParameterDocumentationLineNode.hashToken(), 1, 0);\n+        Token plusToken = formatToken(markdownParameterDocumentationLineNode.plusToken(), 1, 0);\n+        Token parameterName = formatToken(markdownParameterDocumentationLineNode.parameterName(), 1, 0);\n+        Token minusToken = formatToken(markdownParameterDocumentationLineNode.minusToken(), 0, 0);\n+        NodeList<Node> documentElements = formatNodeList(markdownParameterDocumentationLineNode.documentElements(),\n+                0, 0, this.trailingWS, this.trailingNL);\n+\n+        return markdownParameterDocumentationLineNode.modify()\n+                .withHashToken(hashToken)\n+                .withPlusToken(plusToken)\n+                .withParameterName(parameterName)\n+                .withMinusToken(minusToken)\n+                .withDocumentElements(documentElements)\n+                .apply();\n+    }\n+\n+    @Override\n+    public DocumentationReferenceNode transform(DocumentationReferenceNode documentationReferenceNode) {\n+        if (documentationReferenceNode.referenceType().isPresent()) {\n+            Token referenceType = formatToken(documentationReferenceNode.referenceType().get(), 1, 0);\n+            documentationReferenceNode = documentationReferenceNode.modify().withReferenceType(referenceType).apply();\n+        }\n+\n+        Token startBacktick = formatToken(documentationReferenceNode.startBacktick(), 0, 0);\n+        Node backtickContent = formatNode(documentationReferenceNode.backtickContent(), 0, 0);\n+        Token endBacktick = formatToken(documentationReferenceNode.endBacktick(), this.trailingWS, this.trailingNL);\n+\n+        return documentationReferenceNode.modify()\n+                .withStartBacktick(startBacktick)\n+                .withBacktickContent(backtickContent)\n+                .withEndBacktick(endBacktick)\n+                .apply();\n+    }\n+\n+    @Override\n+    public PositionalArgumentNode transform(PositionalArgumentNode positionalArgumentNode) {\n+\n+        return super.transform(positionalArgumentNode);\n+    }\n+\n+    @Override\n+    public MappingBindingPatternNode transform(MappingBindingPatternNode mappingBindingPatternNode) {\n+\n+        return super.transform(mappingBindingPatternNode);\n+    }\n+\n+    @Override\n+    public FieldBindingPatternFullNode transform(FieldBindingPatternFullNode fieldBindingPatternFullNode) {\n+\n+        return super.transform(fieldBindingPatternFullNode);\n+    }\n+\n+    @Override\n+    public FieldBindingPatternVarnameNode transform(FieldBindingPatternVarnameNode fieldBindingPatternVarnameNode) {\n+\n+        return super.transform(fieldBindingPatternVarnameNode);\n+    }\n+\n+    @Override\n+    public TypeTestExpressionNode transform(TypeTestExpressionNode typeTestExpressionNode) {\n+\n+        return super.transform(typeTestExpressionNode);\n+    }\n+\n+    @Override\n+    public ListenerDeclarationNode transform(ListenerDeclarationNode listenerDeclarationNode) {\n+\n+        return super.transform(listenerDeclarationNode);\n+    }\n+\n+    @Override\n+    public ArrayTypeDescriptorNode transform(ArrayTypeDescriptorNode arrayTypeDescriptorNode) {\n+\n+        return super.transform(arrayTypeDescriptorNode);\n+    }\n+\n+    @Override\n+    public MethodCallExpressionNode transform(MethodCallExpressionNode methodCallExpressionNode) {\n+\n+        return super.transform(methodCallExpressionNode);\n+    }\n+\n+    @Override\n+    public NilLiteralNode transform(NilLiteralNode nilLiteralNode) {\n+        Token openParenToken = formatToken(nilLiteralNode.openParenToken(), 0, 0);\n+        Token closeParenToken = formatToken(nilLiteralNode.closeParenToken(), this.trailingWS, this.trailingNL);\n+\n+        return nilLiteralNode.modify()\n+                .withOpenParenToken(openParenToken)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public XMLNamespaceDeclarationNode transform(XMLNamespaceDeclarationNode xMLNamespaceDeclarationNode) {\n+        Token xmlnsKeyword = formatToken(xMLNamespaceDeclarationNode.xmlnsKeyword(), 1, 0);\n+        ExpressionNode namespaceuri;\n+\n+        if (xMLNamespaceDeclarationNode.asKeyword().isPresent()) {\n+            Token asKeyword = formatToken(xMLNamespaceDeclarationNode.asKeyword().get(), 1, 0);\n+            xMLNamespaceDeclarationNode = xMLNamespaceDeclarationNode.modify()\n+                    .withAsKeyword(asKeyword).apply();\n+        }\n+\n+        if (xMLNamespaceDeclarationNode.namespacePrefix().isPresent()) {\n+            namespaceuri = formatNode(xMLNamespaceDeclarationNode.namespaceuri(), 1, 0);\n+            IdentifierToken namespacePrefix = formatNode(xMLNamespaceDeclarationNode.namespacePrefix().get(), 0, 0);\n+            xMLNamespaceDeclarationNode = xMLNamespaceDeclarationNode.modify()\n+                    .withNamespacePrefix(namespacePrefix).apply();\n+        } else {\n+            namespaceuri = formatNode(xMLNamespaceDeclarationNode.namespaceuri(), 0, 0);\n+        }\n+\n+        Token semicolonToken = formatToken(xMLNamespaceDeclarationNode.semicolonToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return xMLNamespaceDeclarationNode.modify()\n+                .withXmlnsKeyword(xmlnsKeyword)\n+                .withNamespaceuri(namespaceuri)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ModuleXMLNamespaceDeclarationNode transform(\n+            ModuleXMLNamespaceDeclarationNode moduleXMLNamespaceDeclarationNode) {\n+        Token xmlnsKeyword = formatToken(moduleXMLNamespaceDeclarationNode.xmlnsKeyword(), 1, 0);\n+        ExpressionNode namespaceuri = formatNode(moduleXMLNamespaceDeclarationNode.namespaceuri(), 1, 0);\n+        Token asKeyword = formatToken(moduleXMLNamespaceDeclarationNode.asKeyword(), 1, 0);\n+        IdentifierToken namespacePrefix = formatNode(moduleXMLNamespaceDeclarationNode.namespacePrefix(), 0, 0);\n+        Token semicolonToken = formatToken(moduleXMLNamespaceDeclarationNode.semicolonToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return moduleXMLNamespaceDeclarationNode.modify()\n+                .withNamespacePrefix(namespacePrefix)\n+                .withNamespaceuri(namespaceuri)\n+                .withXmlnsKeyword(xmlnsKeyword)\n+                .withAsKeyword(asKeyword)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public XmlTypeDescriptorNode transform(XmlTypeDescriptorNode xmlTypeDescriptorNode) {\n+\n+        return super.transform(xmlTypeDescriptorNode);\n+    }\n+\n+    @Override\n+    public XMLElementNode transform(XMLElementNode xMLElementNode) {\n+\n+        return super.transform(xMLElementNode);\n+    }\n+\n+    @Override\n+    public XMLStartTagNode transform(XMLStartTagNode xMLStartTagNode) {\n+\n+        return super.transform(xMLStartTagNode);\n+    }\n+\n+    @Override\n+    public XMLEndTagNode transform(XMLEndTagNode xMLEndTagNode) {\n+\n+        return super.transform(xMLEndTagNode);\n+    }\n+\n+    @Override\n+    public XMLSimpleNameNode transform(XMLSimpleNameNode xMLSimpleNameNode) {\n+        Token name = formatToken(xMLSimpleNameNode.name(), this.trailingWS, this.trailingNL);\n+\n+        return xMLSimpleNameNode.modify()\n+                .withName(name)\n+                .apply();\n+    }\n+\n+    @Override\n+    public XMLQualifiedNameNode transform(XMLQualifiedNameNode xMLQualifiedNameNode) {\n+\n+        return super.transform(xMLQualifiedNameNode);\n+    }\n+\n+    @Override\n+    public XMLEmptyElementNode transform(XMLEmptyElementNode xMLEmptyElementNode) {\n+        Token ltToken = formatToken(xMLEmptyElementNode.ltToken(), 0, 0);\n+        XMLNameNode name;\n+        if (xMLEmptyElementNode.attributes().isEmpty()) {\n+            name = formatNode(xMLEmptyElementNode.name(), 0, 0);\n+        } else {\n+            name = formatNode(xMLEmptyElementNode.name(), 1, 0);\n+        }\n+\n+        NodeList<XMLAttributeNode> attributes = formatNodeList(xMLEmptyElementNode.attributes(), 1, 0, 0, 0);\n+        Token slashToken = formatToken(xMLEmptyElementNode.slashToken(), 0, 0);\n+        Token getToken = formatToken(xMLEmptyElementNode.getToken(), this.trailingWS, this.trailingNL);\n+\n+        return xMLEmptyElementNode.modify()\n+                .withLtToken(ltToken)\n+                .withName(name)\n+                .withAttributes(attributes)\n+                .withSlashToken(slashToken)\n+                .withGetToken(getToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public XMLTextNode transform(XMLTextNode xMLTextNode) {\n+        Token content = formatToken(xMLTextNode.content(), this.trailingWS, this.trailingNL);", "originalCommit": "81330a2ede4dfaf5c68da3c18352254e103d9c0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc0MDcxNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26316#discussion_r503740714", "bodyText": "We ideally shouldn't alter the value of an XML tag right?", "author": "IrushiL", "createdAt": "2020-10-13T07:53:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzMxMjcwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzMyMTYzMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26316#discussion_r503321631", "bodyText": "I think the trailing WS/NL should change depending on the existence of the orderDirection", "author": "SupunS", "createdAt": "2020-10-12T14:08:39Z", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -1328,270 +1452,1389 @@ public ListBindingPatternNode transform(ListBindingPatternNode listBindingPatter\n             listBindingPatternNode = listBindingPatternNode.modify().withRestBindingPattern(restBindingPattern).apply();\n         }\n \n-        return listBindingPatternNode.modify()\n-                .withOpenBracket(openBracket)\n-                .withBindingPatterns(bindingPatternNodes)\n-                .withCloseBracket(closeBracket)\n-                .apply();\n+        return listBindingPatternNode.modify()\n+                .withOpenBracket(openBracket)\n+                .withBindingPatterns(bindingPatternNodes)\n+                .withCloseBracket(closeBracket)\n+                .apply();\n+    }\n+\n+    @Override\n+    public RestBindingPatternNode transform(RestBindingPatternNode restBindingPatternNode) {\n+        Token ellipsisToken = formatToken(restBindingPatternNode.ellipsisToken(), 0, 0);\n+        SimpleNameReferenceNode variableName = formatNode(restBindingPatternNode.variableName(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return restBindingPatternNode.modify()\n+                .withEllipsisToken(ellipsisToken)\n+                .withVariableName(variableName)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TableTypeDescriptorNode transform(TableTypeDescriptorNode tableTypeDescriptorNode) {\n+        Token tableKeywordToken = formatToken(tableTypeDescriptorNode.tableKeywordToken(), 0, 0);\n+        Node rowTypeParameterNode = formatNode(tableTypeDescriptorNode.rowTypeParameterNode(), 1, 0);\n+        Node keyConstraintNode = formatNode(tableTypeDescriptorNode.keyConstraintNode(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return tableTypeDescriptorNode.modify()\n+                .withTableKeywordToken(tableKeywordToken)\n+                .withRowTypeParameterNode(rowTypeParameterNode)\n+                .withKeyConstraintNode(keyConstraintNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public KeyTypeConstraintNode transform(KeyTypeConstraintNode keyTypeConstraintNode) {\n+        Token keyKeywordToken = formatToken(keyTypeConstraintNode.keyKeywordToken(), 0, 0);\n+        Node typeParameterNode = formatNode(keyTypeConstraintNode.typeParameterNode(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return keyTypeConstraintNode.modify()\n+                .withKeyKeywordToken(keyKeywordToken)\n+                .withTypeParameterNode(typeParameterNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MatchStatementNode transform(MatchStatementNode matchStatementNode) {\n+        boolean hasOnFailClause = matchStatementNode.onFailClause().isPresent();\n+        Token matchKeyword = formatToken(matchStatementNode.matchKeyword(), 1, 0);\n+        ExpressionNode condition = formatNode(matchStatementNode.condition(), 1, 0);\n+        Token openBrace = formatToken(matchStatementNode.openBrace(), 0, 1);\n+        indent();\n+        NodeList<MatchClauseNode> matchClauses = formatNodeList(matchStatementNode.matchClauses(), 0, 1, 0, 1);\n+        unindent();\n+        Token closeBrace;\n+\n+        if (hasOnFailClause) {\n+            closeBrace = formatToken(matchStatementNode.closeBrace(), 1, 0);\n+            OnFailClauseNode onFailClause = formatNode(matchStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            matchStatementNode = matchStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        } else {\n+            closeBrace = formatToken(matchStatementNode.closeBrace(), this.trailingWS, this.trailingNL);\n+        }\n+\n+        return matchStatementNode.modify()\n+                .withMatchKeyword(matchKeyword)\n+                .withCondition(condition)\n+                .withOpenBrace(openBrace)\n+                .withMatchClauses(matchClauses)\n+                .withCloseBrace(closeBrace)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MatchClauseNode transform(MatchClauseNode matchClauseNode) {\n+        SeparatedNodeList<Node> matchPatterns = formatSeparatedNodeList(matchClauseNode.matchPatterns(),\n+                0, 0, 0, 0, 1, 0);\n+\n+        if (matchClauseNode.matchGuard().isPresent()) {\n+            MatchGuardNode matchGuard = formatNode(matchClauseNode.matchGuard().get(), 1, 0);\n+            matchClauseNode = matchClauseNode.modify().withMatchGuard(matchGuard).apply();\n+        }\n+\n+        Token rightDoubleArrow = formatToken(matchClauseNode.rightDoubleArrow(), 1, 0);\n+        BlockStatementNode blockStatement = formatNode(matchClauseNode.blockStatement(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return matchClauseNode.modify()\n+                .withMatchPatterns(matchPatterns)\n+                .withRightDoubleArrow(rightDoubleArrow)\n+                .withBlockStatement(blockStatement)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MatchGuardNode transform(MatchGuardNode matchGuardNode) {\n+        Token ifKeyword = formatToken(matchGuardNode.ifKeyword(), 1, 0);\n+        ExpressionNode expression = formatNode(matchGuardNode.expression(), this.trailingWS, this.trailingNL);\n+\n+        return matchGuardNode.modify()\n+                .withIfKeyword(ifKeyword)\n+                .withExpression(expression)\n+                .apply();\n+    }\n+\n+    @Override\n+    public LockStatementNode transform(LockStatementNode lockStatementNode) {\n+        Token lockKeyword = formatToken(lockStatementNode.lockKeyword(), 1, 0);\n+        StatementNode blockStatement;\n+\n+        if (lockStatementNode.onFailClause().isPresent()) {\n+            blockStatement = formatNode(lockStatementNode.blockStatement(), 1, 0);\n+            OnFailClauseNode onFailClause = formatNode(lockStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            lockStatementNode = lockStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        } else {\n+            blockStatement = formatNode(lockStatementNode.blockStatement(), this.trailingWS, this.trailingNL);\n+        }\n+\n+        return lockStatementNode.modify()\n+                .withLockKeyword(lockKeyword)\n+                .withBlockStatement(blockStatement)\n+                .apply();\n+    }\n+\n+    @Override\n+    public FieldAccessExpressionNode transform(FieldAccessExpressionNode fieldAccessExpressionNode) {\n+        ExpressionNode expression = formatNode(fieldAccessExpressionNode.expression(), 0, 0);\n+        Token dotToken = formatToken(fieldAccessExpressionNode.dotToken(), 0, 0);\n+        NameReferenceNode fieldName = formatNode(fieldAccessExpressionNode.fieldName(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return fieldAccessExpressionNode.modify()\n+                .withExpression(expression)\n+                .withDotToken(dotToken)\n+                .withFieldName(fieldName)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MetadataNode transform(MetadataNode metadataNode) {\n+        NodeList<AnnotationNode> annotations = formatNodeList(metadataNode.annotations(), 0, 1, 0, 1);\n+\n+        if (metadataNode.documentationString().isPresent()) {\n+            Node documentationString = formatNode(metadataNode.documentationString().get(),\n+                    this.trailingWS, this.trailingNL);\n+            metadataNode = metadataNode.modify().withDocumentationString(documentationString).apply();\n+        }\n+\n+        return metadataNode.modify()\n+                .withAnnotations(annotations)\n+                .apply();\n+    }\n+\n+    @Override\n+    public EnumDeclarationNode transform(EnumDeclarationNode enumDeclarationNode) {\n+        if (enumDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(enumDeclarationNode.metadata().get(), 0, 1);\n+            enumDeclarationNode = enumDeclarationNode.modify()\n+                    .withMetadata(metadata).apply();\n+        }\n+\n+        Token qualifier = formatToken(enumDeclarationNode.qualifier(), 1, 0);\n+        Token enumKeywordToken = formatToken(enumDeclarationNode.enumKeywordToken(), 1, 0);\n+        IdentifierToken identifier = formatNode(enumDeclarationNode.identifier(), 1, 0);\n+        Token openBraceToken = formatToken(enumDeclarationNode.openBraceToken(), 0, 1);\n+        indent();\n+        SeparatedNodeList<Node> enumMemberList = formatSeparatedNodeList(enumDeclarationNode.enumMemberList(),\n+                0, 0, 0, 1, 0, 1);\n+        unindent();\n+        Token closeBraceToken = formatToken(enumDeclarationNode.closeBraceToken(), this.trailingWS, this.trailingNL);\n+\n+        return enumDeclarationNode.modify()\n+                .withQualifier(qualifier)\n+                .withEnumKeywordToken(enumKeywordToken)\n+                .withIdentifier(identifier)\n+                .withOpenBraceToken(openBraceToken)\n+                .withEnumMemberList(enumMemberList)\n+                .withCloseBraceToken(closeBraceToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public EnumMemberNode transform(EnumMemberNode enumMemberNode) {\n+        if (enumMemberNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(enumMemberNode.metadata().get(), 0, 1);\n+            enumMemberNode = enumMemberNode.modify().withMetadata(metadata).apply();\n+        }\n+        IdentifierToken identifier;\n+\n+        if (enumMemberNode.equalToken().isPresent()) {\n+            identifier = formatNode(enumMemberNode.identifier(), 1, 0);\n+            Token equalToken = formatToken(enumMemberNode.equalToken().get(), 1, 0);\n+            ExpressionNode constExprNode = formatNode(enumMemberNode.constExprNode().get(),\n+                    this.trailingWS, this.trailingNL);\n+\n+            return enumMemberNode.modify()\n+                    .withIdentifier(identifier)\n+                    .withEqualToken(equalToken)\n+                    .withConstExprNode(constExprNode)\n+                    .apply();\n+        } else {\n+            identifier = formatNode(enumMemberNode.identifier(), this.trailingWS, this.trailingNL);\n+\n+            return enumMemberNode.modify()\n+                    .withIdentifier(identifier)\n+                    .apply();\n+        }\n+    }\n+\n+    @Override\n+    public MarkdownDocumentationNode transform(MarkdownDocumentationNode markdownDocumentationNode) {\n+        NodeList<Node> documentationLines = formatNodeList(markdownDocumentationNode.documentationLines(),\n+                0, 0, this.trailingWS, this.trailingNL);\n+\n+        return markdownDocumentationNode.modify()\n+                .withDocumentationLines(documentationLines)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MarkdownDocumentationLineNode transform(MarkdownDocumentationLineNode markdownDocumentationLineNode) {\n+        Token hashToken = formatToken(markdownDocumentationLineNode.hashToken(), 0, 0);\n+        NodeList<Node> documentElements = formatNodeList(markdownDocumentationLineNode.documentElements(),\n+                0, 0, this.trailingWS, this.trailingNL);\n+\n+        return markdownDocumentationLineNode.modify()\n+                .withDocumentElements(documentElements)\n+                .withHashToken(hashToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MarkdownParameterDocumentationLineNode transform(\n+            MarkdownParameterDocumentationLineNode markdownParameterDocumentationLineNode) {\n+        Token hashToken = formatToken(markdownParameterDocumentationLineNode.hashToken(), 1, 0);\n+        Token plusToken = formatToken(markdownParameterDocumentationLineNode.plusToken(), 1, 0);\n+        Token parameterName = formatToken(markdownParameterDocumentationLineNode.parameterName(), 1, 0);\n+        Token minusToken = formatToken(markdownParameterDocumentationLineNode.minusToken(), 0, 0);\n+        NodeList<Node> documentElements = formatNodeList(markdownParameterDocumentationLineNode.documentElements(),\n+                0, 0, this.trailingWS, this.trailingNL);\n+\n+        return markdownParameterDocumentationLineNode.modify()\n+                .withHashToken(hashToken)\n+                .withPlusToken(plusToken)\n+                .withParameterName(parameterName)\n+                .withMinusToken(minusToken)\n+                .withDocumentElements(documentElements)\n+                .apply();\n+    }\n+\n+    @Override\n+    public DocumentationReferenceNode transform(DocumentationReferenceNode documentationReferenceNode) {\n+        if (documentationReferenceNode.referenceType().isPresent()) {\n+            Token referenceType = formatToken(documentationReferenceNode.referenceType().get(), 1, 0);\n+            documentationReferenceNode = documentationReferenceNode.modify().withReferenceType(referenceType).apply();\n+        }\n+\n+        Token startBacktick = formatToken(documentationReferenceNode.startBacktick(), 0, 0);\n+        Node backtickContent = formatNode(documentationReferenceNode.backtickContent(), 0, 0);\n+        Token endBacktick = formatToken(documentationReferenceNode.endBacktick(), this.trailingWS, this.trailingNL);\n+\n+        return documentationReferenceNode.modify()\n+                .withStartBacktick(startBacktick)\n+                .withBacktickContent(backtickContent)\n+                .withEndBacktick(endBacktick)\n+                .apply();\n+    }\n+\n+    @Override\n+    public PositionalArgumentNode transform(PositionalArgumentNode positionalArgumentNode) {\n+\n+        return super.transform(positionalArgumentNode);\n+    }\n+\n+    @Override\n+    public MappingBindingPatternNode transform(MappingBindingPatternNode mappingBindingPatternNode) {\n+\n+        return super.transform(mappingBindingPatternNode);\n+    }\n+\n+    @Override\n+    public FieldBindingPatternFullNode transform(FieldBindingPatternFullNode fieldBindingPatternFullNode) {\n+\n+        return super.transform(fieldBindingPatternFullNode);\n+    }\n+\n+    @Override\n+    public FieldBindingPatternVarnameNode transform(FieldBindingPatternVarnameNode fieldBindingPatternVarnameNode) {\n+\n+        return super.transform(fieldBindingPatternVarnameNode);\n+    }\n+\n+    @Override\n+    public TypeTestExpressionNode transform(TypeTestExpressionNode typeTestExpressionNode) {\n+\n+        return super.transform(typeTestExpressionNode);\n+    }\n+\n+    @Override\n+    public ListenerDeclarationNode transform(ListenerDeclarationNode listenerDeclarationNode) {\n+\n+        return super.transform(listenerDeclarationNode);\n+    }\n+\n+    @Override\n+    public ArrayTypeDescriptorNode transform(ArrayTypeDescriptorNode arrayTypeDescriptorNode) {\n+\n+        return super.transform(arrayTypeDescriptorNode);\n+    }\n+\n+    @Override\n+    public MethodCallExpressionNode transform(MethodCallExpressionNode methodCallExpressionNode) {\n+\n+        return super.transform(methodCallExpressionNode);\n+    }\n+\n+    @Override\n+    public NilLiteralNode transform(NilLiteralNode nilLiteralNode) {\n+        Token openParenToken = formatToken(nilLiteralNode.openParenToken(), 0, 0);\n+        Token closeParenToken = formatToken(nilLiteralNode.closeParenToken(), this.trailingWS, this.trailingNL);\n+\n+        return nilLiteralNode.modify()\n+                .withOpenParenToken(openParenToken)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public XMLNamespaceDeclarationNode transform(XMLNamespaceDeclarationNode xMLNamespaceDeclarationNode) {\n+        Token xmlnsKeyword = formatToken(xMLNamespaceDeclarationNode.xmlnsKeyword(), 1, 0);\n+        ExpressionNode namespaceuri;\n+\n+        if (xMLNamespaceDeclarationNode.asKeyword().isPresent()) {\n+            Token asKeyword = formatToken(xMLNamespaceDeclarationNode.asKeyword().get(), 1, 0);\n+            xMLNamespaceDeclarationNode = xMLNamespaceDeclarationNode.modify()\n+                    .withAsKeyword(asKeyword).apply();\n+        }\n+\n+        if (xMLNamespaceDeclarationNode.namespacePrefix().isPresent()) {\n+            namespaceuri = formatNode(xMLNamespaceDeclarationNode.namespaceuri(), 1, 0);\n+            IdentifierToken namespacePrefix = formatNode(xMLNamespaceDeclarationNode.namespacePrefix().get(), 0, 0);\n+            xMLNamespaceDeclarationNode = xMLNamespaceDeclarationNode.modify()\n+                    .withNamespacePrefix(namespacePrefix).apply();\n+        } else {\n+            namespaceuri = formatNode(xMLNamespaceDeclarationNode.namespaceuri(), 0, 0);\n+        }\n+\n+        Token semicolonToken = formatToken(xMLNamespaceDeclarationNode.semicolonToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return xMLNamespaceDeclarationNode.modify()\n+                .withXmlnsKeyword(xmlnsKeyword)\n+                .withNamespaceuri(namespaceuri)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ModuleXMLNamespaceDeclarationNode transform(\n+            ModuleXMLNamespaceDeclarationNode moduleXMLNamespaceDeclarationNode) {\n+        Token xmlnsKeyword = formatToken(moduleXMLNamespaceDeclarationNode.xmlnsKeyword(), 1, 0);\n+        ExpressionNode namespaceuri = formatNode(moduleXMLNamespaceDeclarationNode.namespaceuri(), 1, 0);\n+        Token asKeyword = formatToken(moduleXMLNamespaceDeclarationNode.asKeyword(), 1, 0);\n+        IdentifierToken namespacePrefix = formatNode(moduleXMLNamespaceDeclarationNode.namespacePrefix(), 0, 0);\n+        Token semicolonToken = formatToken(moduleXMLNamespaceDeclarationNode.semicolonToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return moduleXMLNamespaceDeclarationNode.modify()\n+                .withNamespacePrefix(namespacePrefix)\n+                .withNamespaceuri(namespaceuri)\n+                .withXmlnsKeyword(xmlnsKeyword)\n+                .withAsKeyword(asKeyword)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public XmlTypeDescriptorNode transform(XmlTypeDescriptorNode xmlTypeDescriptorNode) {\n+\n+        return super.transform(xmlTypeDescriptorNode);\n+    }\n+\n+    @Override\n+    public XMLElementNode transform(XMLElementNode xMLElementNode) {\n+\n+        return super.transform(xMLElementNode);\n+    }\n+\n+    @Override\n+    public XMLStartTagNode transform(XMLStartTagNode xMLStartTagNode) {\n+\n+        return super.transform(xMLStartTagNode);\n+    }\n+\n+    @Override\n+    public XMLEndTagNode transform(XMLEndTagNode xMLEndTagNode) {\n+\n+        return super.transform(xMLEndTagNode);\n+    }\n+\n+    @Override\n+    public XMLSimpleNameNode transform(XMLSimpleNameNode xMLSimpleNameNode) {\n+        Token name = formatToken(xMLSimpleNameNode.name(), this.trailingWS, this.trailingNL);\n+\n+        return xMLSimpleNameNode.modify()\n+                .withName(name)\n+                .apply();\n+    }\n+\n+    @Override\n+    public XMLQualifiedNameNode transform(XMLQualifiedNameNode xMLQualifiedNameNode) {\n+\n+        return super.transform(xMLQualifiedNameNode);\n+    }\n+\n+    @Override\n+    public XMLEmptyElementNode transform(XMLEmptyElementNode xMLEmptyElementNode) {\n+        Token ltToken = formatToken(xMLEmptyElementNode.ltToken(), 0, 0);\n+        XMLNameNode name;\n+        if (xMLEmptyElementNode.attributes().isEmpty()) {\n+            name = formatNode(xMLEmptyElementNode.name(), 0, 0);\n+        } else {\n+            name = formatNode(xMLEmptyElementNode.name(), 1, 0);\n+        }\n+\n+        NodeList<XMLAttributeNode> attributes = formatNodeList(xMLEmptyElementNode.attributes(), 1, 0, 0, 0);\n+        Token slashToken = formatToken(xMLEmptyElementNode.slashToken(), 0, 0);\n+        Token getToken = formatToken(xMLEmptyElementNode.getToken(), this.trailingWS, this.trailingNL);\n+\n+        return xMLEmptyElementNode.modify()\n+                .withLtToken(ltToken)\n+                .withName(name)\n+                .withAttributes(attributes)\n+                .withSlashToken(slashToken)\n+                .withGetToken(getToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public XMLTextNode transform(XMLTextNode xMLTextNode) {\n+        Token content = formatToken(xMLTextNode.content(), this.trailingWS, this.trailingNL);\n+\n+        return xMLTextNode.modify()\n+                .withContent(content)\n+                .apply();\n+    }\n+\n+    @Override\n+    public XMLAttributeNode transform(XMLAttributeNode xMLAttributeNode) {\n+\n+        return super.transform(xMLAttributeNode);\n+    }\n+\n+    @Override\n+    public XMLAttributeValue transform(XMLAttributeValue xMLAttributeValue) {\n+\n+        return super.transform(xMLAttributeValue);\n+    }\n+\n+    @Override\n+    public XMLComment transform(XMLComment xMLComment) {\n+        Token commentStart = formatToken(xMLComment.commentStart(), 0, 0);\n+        NodeList<Node> content = formatNodeList(xMLComment.content(), 1, 0, 0, 0);\n+        Token commentEnd = formatToken(xMLComment.commentEnd(), this.trailingWS, this.trailingNL);\n+\n+        return xMLComment.modify()\n+                .withCommentStart(commentStart)\n+                .withContent(content)\n+                .withCommentEnd(commentEnd)\n+                .apply();\n+    }\n+\n+    @Override\n+    public XMLProcessingInstruction transform(XMLProcessingInstruction xMLProcessingInstruction) {\n+        Token piStart = formatToken(xMLProcessingInstruction.piStart(), 0, 0);\n+        XMLNameNode target = formatNode(xMLProcessingInstruction.target(), 1, 0);\n+        NodeList<Node> data = formatNodeList(xMLProcessingInstruction.data(), 1, 0, 0, 0);\n+        Token piEnd = formatToken(xMLProcessingInstruction.piEnd(), this.trailingWS, this.trailingNL);\n+\n+        return xMLProcessingInstruction.modify()\n+                .withTarget(target)\n+                .withPiStart(piStart)\n+                .withData(data)\n+                .withPiEnd(piEnd)\n+                .apply();\n+    }\n+\n+    @Override\n+    public XMLFilterExpressionNode transform(XMLFilterExpressionNode xMLFilterExpressionNode) {\n+\n+        return super.transform(xMLFilterExpressionNode);\n+    }\n+\n+    @Override\n+    public XMLStepExpressionNode transform(XMLStepExpressionNode xMLStepExpressionNode) {\n+\n+        return super.transform(xMLStepExpressionNode);\n+    }\n+\n+    @Override\n+    public XMLNamePatternChainingNode transform(XMLNamePatternChainingNode xMLNamePatternChainingNode) {\n+\n+        return super.transform(xMLNamePatternChainingNode);\n+    }\n+\n+    @Override\n+    public XMLAtomicNamePatternNode transform(XMLAtomicNamePatternNode xMLAtomicNamePatternNode) {\n+\n+        return super.transform(xMLAtomicNamePatternNode);\n+    }\n+\n+    @Override\n+    public TemplateExpressionNode transform(TemplateExpressionNode templateExpressionNode) {\n+\n+        return super.transform(templateExpressionNode);\n+    }\n+\n+    @Override\n+    public ByteArrayLiteralNode transform(ByteArrayLiteralNode byteArrayLiteralNode) {\n+\n+        return super.transform(byteArrayLiteralNode);\n+    }\n+\n+    @Override\n+    public TypeReferenceNode transform(TypeReferenceNode typeReferenceNode) {\n+\n+        return super.transform(typeReferenceNode);\n+    }\n+\n+    @Override\n+    public MappingMatchPatternNode transform(MappingMatchPatternNode mappingMatchPatternNode) {\n+\n+        return super.transform(mappingMatchPatternNode);\n+    }\n+\n+    @Override\n+    public StartActionNode transform(StartActionNode startActionNode) {\n+        NodeList<AnnotationNode> annotations = formatNodeList(startActionNode.annotations(), 0, 1, 0, 1);\n+        Token startKeyword = formatToken(startActionNode.startKeyword(), 1, 0);\n+        ExpressionNode expression = formatNode(startActionNode.expression(), this.trailingWS, this.trailingNL);\n+\n+        return startActionNode.modify()\n+                .withAnnotations(annotations)\n+                .withStartKeyword(startKeyword)\n+                .withExpression(expression)\n+                .apply();\n+    }\n+\n+    @Override\n+    public FlushActionNode transform(FlushActionNode flushActionNode) {\n+        Token flushKeyword = formatToken(flushActionNode.flushKeyword(), 1, 0);\n+        NameReferenceNode peerWorker = formatNode(flushActionNode.peerWorker(), this.trailingWS, this.trailingNL);\n+\n+        return flushActionNode.modify()\n+                .withFlushKeyword(flushKeyword)\n+                .withPeerWorker(peerWorker)\n+                .apply();\n+    }\n+\n+    @Override\n+    public NamedWorkerDeclarationNode transform(NamedWorkerDeclarationNode namedWorkerDeclarationNode) {\n+\n+        return super.transform(namedWorkerDeclarationNode);\n+    }\n+\n+    @Override\n+    public FailStatementNode transform(FailStatementNode failStatementNode) {\n+        Token failKeyword = formatToken(failStatementNode.failKeyword(), 1, 0);\n+        ExpressionNode expression = formatNode(failStatementNode.expression(), 0, 0);\n+        Token semicolonToken = formatToken(failStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return failStatementNode.modify()\n+                .withFailKeyword(failKeyword)\n+                .withExpression(expression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ContinueStatementNode transform(ContinueStatementNode continueStatementNode) {\n+        Token continueToken = formatToken(continueStatementNode.continueToken(), 0, 0);\n+        Token semicolonToken = formatToken(continueStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return continueStatementNode.modify()\n+                .withContinueToken(continueToken)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public LocalTypeDefinitionStatementNode transform(\n+            LocalTypeDefinitionStatementNode localTypeDefinitionStatementNode) {\n+        NodeList<AnnotationNode> annotations = formatNodeList(localTypeDefinitionStatementNode.annotations(),\n+                1, 0, 1, 0);\n+        Token typeKeyword = formatToken(localTypeDefinitionStatementNode.typeKeyword(), 1, 0);\n+        Node typeName = formatNode(localTypeDefinitionStatementNode.typeName(), 1, 0);\n+        Node typeDescriptor = formatNode(localTypeDefinitionStatementNode.typeDescriptor(), 1, 0);\n+        Token semicolonToken = formatToken(localTypeDefinitionStatementNode.semicolonToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return localTypeDefinitionStatementNode.modify()\n+                .withAnnotations(annotations)\n+                .withTypeKeyword(typeKeyword)\n+                .withTypeName(typeName)\n+                .withTypeDescriptor(typeDescriptor)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ForkStatementNode transform(ForkStatementNode forkStatementNode) {\n+        Token forkKeyword = formatToken(forkStatementNode.forkKeyword(), 1, 0);\n+        Token openBraceToken = formatToken(forkStatementNode.openBraceToken(), 0, 1);\n+        indent();\n+        NodeList<NamedWorkerDeclarationNode> namedWorkerDeclarations =\n+                formatNodeList(forkStatementNode.namedWorkerDeclarations(), 0, 1, 0, 1);\n+        unindent();\n+        Token closeBraceToken = formatToken(forkStatementNode.closeBraceToken(), this.trailingWS, this.trailingNL);\n+\n+        return forkStatementNode.modify()\n+                .withForkKeyword(forkKeyword)\n+                .withOpenBraceToken(openBraceToken)\n+                .withNamedWorkerDeclarations(namedWorkerDeclarations)\n+                .withCloseBraceToken(closeBraceToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TypeofExpressionNode transform(TypeofExpressionNode typeofExpressionNode) {\n+\n+        return super.transform(typeofExpressionNode);\n+    }\n+\n+    @Override\n+    public UnaryExpressionNode transform(UnaryExpressionNode unaryExpressionNode) {\n+        Token unaryOperator = formatToken(unaryExpressionNode.unaryOperator(), 0, 0);\n+        ExpressionNode expression = formatNode(unaryExpressionNode.expression(), this.trailingWS, this.trailingNL);\n+\n+        return unaryExpressionNode.modify()\n+                .withUnaryOperator(unaryOperator)\n+                .withExpression(expression)\n+                .apply();\n+    }\n+\n+    @Override\n+    public DefaultableParameterNode transform(DefaultableParameterNode defaultableParameterNode) {\n+        NodeList<AnnotationNode> annotations = formatNodeList(defaultableParameterNode.annotations(), 1, 0, 1, 0);\n+        Node typeName = formatNode(defaultableParameterNode.typeName(), 1, 0);\n+\n+        if (defaultableParameterNode.paramName().isPresent()) {\n+            Token paramName = formatToken(defaultableParameterNode.paramName().get(), 1, 0);\n+            defaultableParameterNode = defaultableParameterNode.modify().withParamName(paramName).apply();\n+        }\n+\n+        Token equalsToken = formatToken(defaultableParameterNode.equalsToken(), 1, 0);\n+        Node expression = formatNode(defaultableParameterNode.expression(), this.trailingWS, this.trailingNL);\n+\n+        return defaultableParameterNode.modify()\n+                .withAnnotations(annotations)\n+                .withTypeName(typeName)\n+                .withEqualsToken(equalsToken)\n+                .withExpression(expression)\n+                .apply();\n+    }\n+\n+    @Override\n+    public RestParameterNode transform(RestParameterNode restParameterNode) {\n+\n+        return super.transform(restParameterNode);\n+    }\n+\n+    @Override\n+    public SpreadFieldNode transform(SpreadFieldNode spreadFieldNode) {\n+\n+        return super.transform(spreadFieldNode);\n+    }\n+\n+    @Override\n+    public NamedArgumentNode transform(NamedArgumentNode namedArgumentNode) {\n+\n+        return super.transform(namedArgumentNode);\n+    }\n+\n+    @Override\n+    public RestArgumentNode transform(RestArgumentNode restArgumentNode) {\n+\n+        return super.transform(restArgumentNode);\n+    }\n+\n+    @Override\n+    public ObjectTypeDescriptorNode transform(ObjectTypeDescriptorNode objectTypeDescriptorNode) {\n+\n+        return super.transform(objectTypeDescriptorNode);\n+    }\n+\n+    @Override\n+    public ObjectConstructorExpressionNode transform(ObjectConstructorExpressionNode objectConstructorExpressionNode) {\n+\n+        return super.transform(objectConstructorExpressionNode);\n+    }\n+\n+    @Override\n+    public ObjectFieldNode transform(ObjectFieldNode objectFieldNode) {\n+\n+        return super.transform(objectFieldNode);\n+    }\n+\n+    @Override\n+    public RecordRestDescriptorNode transform(RecordRestDescriptorNode recordRestDescriptorNode) {\n+\n+        return super.transform(recordRestDescriptorNode);\n+    }\n+\n+    @Override\n+    public AnnotationDeclarationNode transform(AnnotationDeclarationNode annotationDeclarationNode) {\n+        if (annotationDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(annotationDeclarationNode.metadata().get(), 0, 1);\n+            annotationDeclarationNode = annotationDeclarationNode.modify().withMetadata(metadata).apply();\n+        }\n+\n+        Token visibilityQualifier = formatToken(annotationDeclarationNode.visibilityQualifier(), 1, 0);\n+        Token constKeyword = formatToken(annotationDeclarationNode.constKeyword(), 1, 0);\n+        Token annotationKeyword = formatToken(annotationDeclarationNode.annotationKeyword(), 1, 0);\n+        Node typeDescriptor = formatNode(annotationDeclarationNode.typeDescriptor(), 1, 0);\n+        Token annotationTag = formatToken(annotationDeclarationNode.annotationTag(), 1, 0);\n+        Token onKeyword = formatToken(annotationDeclarationNode.onKeyword(), 1, 0);\n+        SeparatedNodeList<Node> attachPoints = formatSeparatedNodeList(annotationDeclarationNode.attachPoints(),\n+                1, 0, 1, 0);\n+        Token semicolonToken = formatToken(annotationDeclarationNode.semicolonToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return annotationDeclarationNode.modify()\n+                .withVisibilityQualifier(visibilityQualifier)\n+                .withConstKeyword(constKeyword)\n+                .withAnnotationKeyword(annotationKeyword)\n+                .withTypeDescriptor(typeDescriptor)\n+                .withAnnotationTag(annotationTag)\n+                .withOnKeyword(onKeyword)\n+                .withAttachPoints(attachPoints)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public AnnotationAttachPointNode transform(AnnotationAttachPointNode annotationAttachPointNode) {\n+\n+        return super.transform(annotationAttachPointNode);\n+    }\n+\n+    @Override\n+    public NamedWorkerDeclarator transform(NamedWorkerDeclarator namedWorkerDeclarator) {\n+\n+        return super.transform(namedWorkerDeclarator);\n+    }\n+\n+    @Override\n+    public TrapExpressionNode transform(TrapExpressionNode trapExpressionNode) {\n+        Token trapKeyword = formatToken(trapExpressionNode.trapKeyword(), 1, 0);\n+        ExpressionNode expression = formatNode(trapExpressionNode.expression(), this.trailingWS, this.trailingNL);\n+\n+        return trapExpressionNode.modify()\n+                .withTrapKeyword(trapKeyword)\n+                .withExpression(expression)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TableConstructorExpressionNode transform(TableConstructorExpressionNode tableConstructorExpressionNode) {\n+\n+        return super.transform(tableConstructorExpressionNode);\n+    }\n+\n+    @Override\n+    public KeySpecifierNode transform(KeySpecifierNode keySpecifierNode) {\n+        Token keyKeyword = formatToken(keySpecifierNode.keyKeyword(), 0, 0);\n+        Token openParenToken = formatToken(keySpecifierNode.openParenToken(), 0, 0);\n+        SeparatedNodeList<IdentifierToken> fieldNames = formatSeparatedNodeList(keySpecifierNode.fieldNames(),\n+                1, 0, 0, 0);\n+        Token closeParenToken = formatToken(keySpecifierNode.closeParenToken(), this.trailingWS, this.trailingNL);\n+\n+        return keySpecifierNode.modify()\n+                .withKeyKeyword(keyKeyword)\n+                .withOpenParenToken(openParenToken)\n+                .withFieldNames(fieldNames)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ErrorTypeParamsNode transform(ErrorTypeParamsNode errorTypeParamsNode) {\n+\n+        return super.transform(errorTypeParamsNode);\n+    }\n+\n+    @Override\n+    public StreamTypeDescriptorNode transform(StreamTypeDescriptorNode streamTypeDescriptorNode) {\n+        Token streamKeywordToken;\n+\n+        if (streamTypeDescriptorNode.streamTypeParamsNode().isPresent()) {\n+            streamKeywordToken = formatToken(streamTypeDescriptorNode.streamKeywordToken(), 0, 0);\n+            Node streamTypeParamsNode = formatNode(streamTypeDescriptorNode.streamTypeParamsNode().get(),\n+                    this.trailingWS, this.trailingNL);\n+            streamTypeDescriptorNode = streamTypeDescriptorNode.modify()\n+                    .withStreamTypeParamsNode(streamTypeParamsNode).apply();\n+        } else {\n+            streamKeywordToken = formatToken(streamTypeDescriptorNode.streamKeywordToken(),\n+                    this.trailingWS, this.trailingNL);\n+        }\n+\n+        return streamTypeDescriptorNode.modify()\n+                .withStreamKeywordToken(streamKeywordToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public StreamTypeParamsNode transform(StreamTypeParamsNode streamTypeParamsNode) {\n+        Token ltToken = formatToken(streamTypeParamsNode.ltToken(), 0, 0);\n+        Node leftTypeDescNode = formatNode(streamTypeParamsNode.leftTypeDescNode(), 0, 0);\n+        Token gtToken = formatToken(streamTypeParamsNode.gtToken(), this.trailingWS, this.trailingNL);\n+\n+        if (streamTypeParamsNode.commaToken().isPresent() && streamTypeParamsNode.rightTypeDescNode().isPresent()) {\n+            Token commaToken = formatToken(streamTypeParamsNode.commaToken().get(), 1, 0);\n+            Node rightTypeDescNode = formatNode(streamTypeParamsNode.rightTypeDescNode().get(), 0, 0);\n+            streamTypeParamsNode = streamTypeParamsNode.modify()\n+                    .withCommaToken(commaToken)\n+                    .withRightTypeDescNode(rightTypeDescNode)\n+                    .apply();\n+        }\n+\n+        return streamTypeParamsNode.modify()\n+                .withLtToken(ltToken)\n+                .withLeftTypeDescNode(leftTypeDescNode)\n+                .withGtToken(gtToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TypedescTypeDescriptorNode transform(TypedescTypeDescriptorNode typedescTypeDescriptorNode) {\n+\n+        return super.transform(typedescTypeDescriptorNode);\n+    }\n+\n+    @Override\n+    public LetExpressionNode transform(LetExpressionNode letExpressionNode) {\n+        Token letKeyword = formatToken(letExpressionNode.letKeyword(), 1, 0);\n+        SeparatedNodeList<LetVariableDeclarationNode> letVarDeclarations =\n+                formatSeparatedNodeList(letExpressionNode.letVarDeclarations(), 1, 0, 0, 1);\n+        Token inKeyword = formatToken(letExpressionNode.inKeyword(), 1, 0);\n+        ExpressionNode expression = formatNode(letExpressionNode.expression(), this.trailingWS, this.trailingNL);\n+\n+        return letExpressionNode.modify()\n+                .withLetKeyword(letKeyword)\n+                .withLetVarDeclarations(letVarDeclarations)\n+                .withInKeyword(inKeyword)\n+                .withExpression(expression)\n+                .apply();\n+    }\n+\n+    @Override\n+    public LetVariableDeclarationNode transform(LetVariableDeclarationNode letVariableDeclarationNode) {\n+        NodeList<AnnotationNode> annotations = formatNodeList(letVariableDeclarationNode.annotations(), 0, 1, 0, 1);\n+        TypedBindingPatternNode typedBindingPattern = formatNode(letVariableDeclarationNode.typedBindingPattern(),\n+                1, 0);\n+        Token equalsToken = formatToken(letVariableDeclarationNode.equalsToken(), 1, 0);\n+        ExpressionNode expression = formatNode(letVariableDeclarationNode.expression(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return letVariableDeclarationNode.modify()\n+                .withAnnotations(annotations)\n+                .withTypedBindingPattern(typedBindingPattern)\n+                .withEqualsToken(equalsToken)\n+                .withExpression(expression)\n+                .apply();\n+    }\n+\n+    @Override\n+    public InterpolationNode transform(InterpolationNode interpolationNode) {\n+        Token interpolationStartToken = formatToken(interpolationNode.interpolationStartToken(), 0, 0);\n+        ExpressionNode expression = formatNode(interpolationNode.expression(), 0, 0);\n+        Token interpolationEndToken = formatToken(interpolationNode.interpolationEndToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return interpolationNode.modify()\n+                .withInterpolationStartToken(interpolationStartToken)\n+                .withExpression(expression)\n+                .withInterpolationEndToken(interpolationEndToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExplicitAnonymousFunctionExpressionNode transform(\n+            ExplicitAnonymousFunctionExpressionNode explicitAnonymousFunctionExpressionNode) {\n+\n+        return super.transform(explicitAnonymousFunctionExpressionNode);\n+    }\n+\n+    @Override\n+    public ImplicitNewExpressionNode transform(ImplicitNewExpressionNode implicitNewExpressionNode) {\n+\n+        return super.transform(implicitNewExpressionNode);\n+    }\n+\n+    @Override\n+    public QueryConstructTypeNode transform(QueryConstructTypeNode queryConstructTypeNode) {\n+\n+        return super.transform(queryConstructTypeNode);\n+    }\n+\n+    @Override\n+    public FromClauseNode transform(FromClauseNode fromClauseNode) {\n+        Token fromKeyword = formatToken(fromClauseNode.fromKeyword(), 1, 0);\n+        TypedBindingPatternNode typedBindingPattern = formatNode(fromClauseNode.typedBindingPattern(), 1, 0);\n+        Token inKeyword = formatToken(fromClauseNode.inKeyword(), 1, 0);\n+        ExpressionNode expression = formatNode(fromClauseNode.expression(), this.trailingWS, this.trailingNL);\n+\n+        return fromClauseNode.modify()\n+                .withFromKeyword(fromKeyword)\n+                .withTypedBindingPattern(typedBindingPattern)\n+                .withInKeyword(inKeyword)\n+                .withExpression(expression)\n+                .apply();\n+    }\n+\n+    @Override\n+    public WhereClauseNode transform(WhereClauseNode whereClauseNode) {\n+        Token whereKeyword = formatToken(whereClauseNode.whereKeyword(), 1, 0);\n+        ExpressionNode expression = formatNode(whereClauseNode.expression(), this.trailingWS, this.trailingNL);\n+\n+        return whereClauseNode.modify()\n+                .withWhereKeyword(whereKeyword)\n+                .withExpression(expression)\n+                .apply();\n+    }\n+\n+    @Override\n+    public LetClauseNode transform(LetClauseNode letClauseNode) {\n+        Token letKeyword = formatToken(letClauseNode.letKeyword(), 1, 0);\n+        SeparatedNodeList<LetVariableDeclarationNode> letVarDeclarations =\n+                formatSeparatedNodeList(letClauseNode.letVarDeclarations(), 1, 0, this.trailingWS, this.trailingNL);\n+\n+        return letClauseNode.modify()\n+                .withLetKeyword(letKeyword)\n+                .withLetVarDeclarations(letVarDeclarations)\n+                .apply();\n+    }\n+\n+    @Override\n+    public QueryPipelineNode transform(QueryPipelineNode queryPipelineNode) {\n+        FromClauseNode fromClause = formatNode(queryPipelineNode.fromClause(), 0, 1);\n+        NodeList<IntermediateClauseNode> intermediateClauses = formatNodeList(queryPipelineNode.intermediateClauses(),\n+                0, 1, this.trailingWS, this.trailingNL);\n+\n+        return queryPipelineNode.modify()\n+                .withFromClause(fromClause)\n+                .withIntermediateClauses(intermediateClauses)\n+                .apply();\n+    }\n+\n+    @Override\n+    public SelectClauseNode transform(SelectClauseNode selectClauseNode) {\n+\n+        return super.transform(selectClauseNode);\n+    }\n+\n+    @Override\n+    public QueryExpressionNode transform(QueryExpressionNode queryExpressionNode) {\n+\n+        return super.transform(queryExpressionNode);\n+    }\n+\n+    @Override\n+    public ImplicitAnonymousFunctionParameters transform(\n+            ImplicitAnonymousFunctionParameters implicitAnonymousFunctionParameters) {\n+\n+        return super.transform(implicitAnonymousFunctionParameters);\n+    }\n+\n+    @Override\n+    public ImplicitAnonymousFunctionExpressionNode transform(\n+            ImplicitAnonymousFunctionExpressionNode implicitAnonymousFunctionExpressionNode) {\n+\n+        return super.transform(implicitAnonymousFunctionExpressionNode);\n+    }\n+\n+    @Override\n+    public MethodDeclarationNode transform(MethodDeclarationNode methodDeclarationNode) {\n+        if (methodDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(methodDeclarationNode.metadata().get(), 0, 1);\n+            methodDeclarationNode = methodDeclarationNode.modify().withMetadata(metadata).apply();\n+        }\n+\n+        NodeList<Token> qualifierList = formatNodeList(methodDeclarationNode.qualifierList(), 1, 0, 1, 0);\n+        Token functionKeyword = formatToken(methodDeclarationNode.functionKeyword(), 1, 0);\n+        IdentifierToken methodName = formatNode(methodDeclarationNode.methodName(), 0, 0);\n+        FunctionSignatureNode methodSignature = formatNode(methodDeclarationNode.methodSignature(), 0, 0);\n+        Token semicolon = formatToken(methodDeclarationNode.semicolon(), this.trailingWS, this.trailingNL);\n+\n+        return methodDeclarationNode.modify()\n+                .withQualifierList(qualifierList)\n+                .withFunctionKeyword(functionKeyword)\n+                .withMethodName(methodName)\n+                .withMethodSignature(methodSignature)\n+                .withSemicolon(semicolon)\n+                .apply();\n+    }\n+\n+    @Override\n+    public WildcardBindingPatternNode transform(WildcardBindingPatternNode wildcardBindingPatternNode) {\n+        Token underscoreToken = formatToken(wildcardBindingPatternNode.underscoreToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return wildcardBindingPatternNode.modify()\n+                .withUnderscoreToken(underscoreToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ErrorBindingPatternNode transform(ErrorBindingPatternNode errorBindingPatternNode) {\n+\n+        return super.transform(errorBindingPatternNode);\n+    }\n+\n+    @Override\n+    public NamedArgBindingPatternNode transform(NamedArgBindingPatternNode namedArgBindingPatternNode) {\n+\n+        return super.transform(namedArgBindingPatternNode);\n+    }\n+\n+    @Override\n+    public AsyncSendActionNode transform(AsyncSendActionNode asyncSendActionNode) {\n+        ExpressionNode expression = formatNode(asyncSendActionNode.expression(), 1, 0);\n+        Token rightArrowToken = formatToken(asyncSendActionNode.rightArrowToken(), 1, 0);\n+        SimpleNameReferenceNode peerWorker = formatNode(asyncSendActionNode.peerWorker(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return asyncSendActionNode.modify()\n+                .withExpression(expression)\n+                .withRightArrowToken(rightArrowToken)\n+                .withPeerWorker(peerWorker)\n+                .apply();\n+    }\n+\n+    @Override\n+    public SyncSendActionNode transform(SyncSendActionNode syncSendActionNode) {\n+        ExpressionNode expression = formatNode(syncSendActionNode.expression(), 1, 0);\n+        Token syncSendToken = formatToken(syncSendActionNode.syncSendToken(), 1, 0);\n+        SimpleNameReferenceNode peerWorker = formatNode(syncSendActionNode.peerWorker(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return syncSendActionNode.modify()\n+                .withExpression(expression)\n+                .withSyncSendToken(syncSendToken)\n+                .withPeerWorker(peerWorker)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ReceiveActionNode transform(ReceiveActionNode receiveActionNode) {\n+        Token leftArrow = formatToken(receiveActionNode.leftArrow(), 1, 0);\n+        SimpleNameReferenceNode receiveWorkers = formatNode(receiveActionNode.receiveWorkers(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return receiveActionNode.modify()\n+                .withLeftArrow(leftArrow)\n+                .withReceiveWorkers(receiveWorkers)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ReceiveFieldsNode transform(ReceiveFieldsNode receiveFieldsNode) {\n+        Token openBrace = formatToken(receiveFieldsNode.openBrace(), 0, 1);\n+        indent();\n+        SeparatedNodeList<NameReferenceNode> receiveFields = formatSeparatedNodeList(receiveFieldsNode.receiveFields(),\n+                0, 1, 0, 1);\n+        Token closeBrace = formatToken(receiveFieldsNode.closeBrace(), 0, 1);\n+        unindent();\n+\n+        return receiveFieldsNode.modify()\n+                .withOpenBrace(openBrace)\n+                .withReceiveFields(receiveFields)\n+                .withCloseBrace(closeBrace)\n+                .apply();\n+    }\n+\n+    @Override\n+    public RestDescriptorNode transform(RestDescriptorNode restDescriptorNode) {\n+\n+        return super.transform(restDescriptorNode);\n+    }\n+\n+    @Override\n+    public DoubleGTTokenNode transform(DoubleGTTokenNode doubleGTTokenNode) {\n+        Token openGTToken = formatToken(doubleGTTokenNode.openGTToken(), 0, 0);\n+        Token endGTToken = formatToken(doubleGTTokenNode.endGTToken(), this.trailingWS, this.trailingNL);\n+\n+        return doubleGTTokenNode.modify()\n+                .withOpenGTToken(openGTToken)\n+                .withEndGTToken(endGTToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TrippleGTTokenNode transform(TrippleGTTokenNode trippleGTTokenNode) {\n+        Token openGTToken = formatToken(trippleGTTokenNode.openGTToken(), 0, 0);\n+        Token middleGTToken = formatToken(trippleGTTokenNode.middleGTToken(), 0, 0);\n+        Token endGTToken = formatToken(trippleGTTokenNode.endGTToken(), this.trailingWS, this.trailingNL);\n+\n+        return trippleGTTokenNode.modify()\n+                .withOpenGTToken(openGTToken)\n+                .withMiddleGTToken(middleGTToken)\n+                .withEndGTToken(endGTToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public WaitActionNode transform(WaitActionNode waitActionNode) {\n+        Token waitKeyword = formatToken(waitActionNode.waitKeyword(), 1, 0);\n+        Node waitFutureExpr = formatNode(waitActionNode.waitFutureExpr(), this.trailingWS, this.trailingNL);\n+\n+        return waitActionNode.modify()\n+                .withWaitKeyword(waitKeyword)\n+                .withWaitFutureExpr(waitFutureExpr)\n+                .apply();\n+    }\n+\n+    @Override\n+    public WaitFieldsListNode transform(WaitFieldsListNode waitFieldsListNode) {\n+\n+        return super.transform(waitFieldsListNode);\n+    }\n+\n+    @Override\n+    public WaitFieldNode transform(WaitFieldNode waitFieldNode) {\n+\n+        return super.transform(waitFieldNode);\n+    }\n+\n+    @Override\n+    public AnnotAccessExpressionNode transform(AnnotAccessExpressionNode annotAccessExpressionNode) {\n+\n+        return super.transform(annotAccessExpressionNode);\n     }\n \n     @Override\n-    public RestBindingPatternNode transform(RestBindingPatternNode restBindingPatternNode) {\n-        Token ellipsisToken = formatToken(restBindingPatternNode.ellipsisToken(), 0, 0);\n-        SimpleNameReferenceNode variableName = formatNode(restBindingPatternNode.variableName(),\n-                this.trailingWS, this.trailingNL);\n+    public QueryActionNode transform(QueryActionNode queryActionNode) {\n \n-        return restBindingPatternNode.modify()\n-                .withEllipsisToken(ellipsisToken)\n-                .withVariableName(variableName)\n-                .apply();\n+        return super.transform(queryActionNode);\n     }\n \n     @Override\n-    public TableTypeDescriptorNode transform(TableTypeDescriptorNode tableTypeDescriptorNode) {\n-        Token tableKeywordToken = formatToken(tableTypeDescriptorNode.tableKeywordToken(), 0, 0);\n-        Node rowTypeParameterNode = formatNode(tableTypeDescriptorNode.rowTypeParameterNode(), 1, 0);\n-        Node keyConstraintNode = formatNode(tableTypeDescriptorNode.keyConstraintNode(), 1, 0);\n+    public OptionalFieldAccessExpressionNode transform(\n+            OptionalFieldAccessExpressionNode optionalFieldAccessExpressionNode) {\n \n-        return tableTypeDescriptorNode.modify()\n-                .withTableKeywordToken(tableKeywordToken)\n-                .withRowTypeParameterNode(rowTypeParameterNode)\n-                .withKeyConstraintNode(keyConstraintNode)\n-                .apply();\n+        return super.transform(optionalFieldAccessExpressionNode);\n     }\n \n     @Override\n-    public KeyTypeConstraintNode transform(KeyTypeConstraintNode keyTypeConstraintNode) {\n-        Token keyKeywordToken = formatToken(keyTypeConstraintNode.keyKeywordToken(), 0, 0);\n-        Node typeParameterNode = formatNode(keyTypeConstraintNode.typeParameterNode(),\n-                this.trailingWS, this.trailingNL);\n+    public ConditionalExpressionNode transform(ConditionalExpressionNode conditionalExpressionNode) {\n \n-        return keyTypeConstraintNode.modify()\n-                .withKeyKeywordToken(keyKeywordToken)\n-                .withTypeParameterNode(typeParameterNode)\n-                .apply();\n+        return super.transform(conditionalExpressionNode);\n     }\n \n     @Override\n-    public MatchStatementNode transform(MatchStatementNode matchStatementNode) {\n-        boolean hasOnFailClause = matchStatementNode.onFailClause().isPresent();\n-        Token matchKeyword = formatToken(matchStatementNode.matchKeyword(), 1, 0);\n-        ExpressionNode condition = formatNode(matchStatementNode.condition(), 1, 0);\n-        Token openBrace = formatToken(matchStatementNode.openBrace(), 0, 1);\n-        indent();\n-        NodeList<MatchClauseNode> matchClauses = formatNodeList(matchStatementNode.matchClauses(), 0, 1, 0, 1);\n-        unindent();\n-        Token closeBrace;\n+    public TransactionStatementNode transform(TransactionStatementNode transactionStatementNode) {\n+        Token transactionKeyword = formatToken(transactionStatementNode.transactionKeyword(), 1, 0);\n+        BlockStatementNode blockStatement;\n \n-        if (hasOnFailClause) {\n-            closeBrace = formatToken(matchStatementNode.closeBrace(), 1, 0);\n-            OnFailClauseNode onFailClause = formatNode(matchStatementNode.onFailClause().get(),\n+        if (transactionStatementNode.onFailClause().isPresent()) {\n+            blockStatement = formatNode(transactionStatementNode.blockStatement(), 1, 0);\n+            OnFailClauseNode onFailClause = formatNode(transactionStatementNode.onFailClause().get(),\n                     this.trailingWS, this.trailingNL);\n-            matchStatementNode = matchStatementNode.modify().withOnFailClause(onFailClause).apply();\n+            transactionStatementNode = transactionStatementNode.modify().withOnFailClause(onFailClause).apply();\n         } else {\n-            closeBrace = formatToken(matchStatementNode.closeBrace(), this.trailingWS, this.trailingNL);\n+            blockStatement = formatNode(transactionStatementNode.blockStatement(), this.trailingWS, this.trailingNL);\n         }\n \n-        return matchStatementNode.modify()\n-                .withMatchKeyword(matchKeyword)\n-                .withCondition(condition)\n-                .withOpenBrace(openBrace)\n-                .withMatchClauses(matchClauses)\n-                .withCloseBrace(closeBrace)\n+        return transactionStatementNode.modify()\n+                .withTransactionKeyword(transactionKeyword)\n+                .withBlockStatement(blockStatement)\n                 .apply();\n     }\n \n     @Override\n-    public MatchClauseNode transform(MatchClauseNode matchClauseNode) {\n-        SeparatedNodeList<Node> matchPatterns = formatSeparatedNodeList(matchClauseNode.matchPatterns(),\n-                0, 0, 0, 0, 1, 0);\n+    public RollbackStatementNode transform(RollbackStatementNode rollbackStatementNode) {\n+        Token rollbackKeyword;\n \n-        if (matchClauseNode.matchGuard().isPresent()) {\n-            MatchGuardNode matchGuard = formatNode(matchClauseNode.matchGuard().get(), 1, 0);\n-            matchClauseNode = matchClauseNode.modify().withMatchGuard(matchGuard).apply();\n+        if (rollbackStatementNode.expression().isPresent()) {\n+            rollbackKeyword = formatToken(rollbackStatementNode.rollbackKeyword(), 1, 0);\n+            ExpressionNode expression = formatNode(rollbackStatementNode.expression().get(), 0, 0);\n+            rollbackStatementNode = rollbackStatementNode.modify().withExpression(expression).apply();\n+        } else {\n+            rollbackKeyword = formatToken(rollbackStatementNode.rollbackKeyword(), 0, 0);\n         }\n \n-        Token rightDoubleArrow = formatToken(matchClauseNode.rightDoubleArrow(), 1, 0);\n-        BlockStatementNode blockStatement = formatNode(matchClauseNode.blockStatement(),\n-                this.trailingWS, this.trailingNL);\n+        Token semicolon = formatToken(rollbackStatementNode.semicolon(), this.trailingWS, this.trailingNL);\n \n-        return matchClauseNode.modify()\n-                .withMatchPatterns(matchPatterns)\n-                .withRightDoubleArrow(rightDoubleArrow)\n-                .withBlockStatement(blockStatement)\n+        return rollbackStatementNode.modify()\n+                .withRollbackKeyword(rollbackKeyword)\n+                .withSemicolon(semicolon)\n                 .apply();\n     }\n \n     @Override\n-    public MatchGuardNode transform(MatchGuardNode matchGuardNode) {\n-        Token ifKeyword = formatToken(matchGuardNode.ifKeyword(), 1, 0);\n-        ExpressionNode expression = formatNode(matchGuardNode.expression(), this.trailingWS, this.trailingNL);\n+    public RetryStatementNode transform(RetryStatementNode retryStatementNode) {\n+        Token retryKeyword;\n+        if (retryStatementNode.typeParameter().isPresent() || retryStatementNode.arguments().isPresent()) {\n+            retryKeyword = formatToken(retryStatementNode.retryKeyword(), 0, 0);\n+        } else {\n+            retryKeyword = formatToken(retryStatementNode.retryKeyword(), 1, 0);\n+        }\n \n-        return matchGuardNode.modify()\n-                .withIfKeyword(ifKeyword)\n-                .withExpression(expression)\n-                .apply();\n-    }\n+        if (retryStatementNode.typeParameter().isPresent()) {\n+            TypeParameterNode typeParameter = formatNode(retryStatementNode.typeParameter().get(), 1, 0);\n+            retryStatementNode = retryStatementNode.modify().withTypeParameter(typeParameter).apply();\n+        }\n \n-    @Override\n-    public LockStatementNode transform(LockStatementNode lockStatementNode) {\n-        Token lockKeyword = formatToken(lockStatementNode.lockKeyword(), 1, 0);\n-        StatementNode blockStatement;\n+        if (retryStatementNode.arguments().isPresent()) {\n+            ParenthesizedArgList arguments = formatNode(retryStatementNode.arguments().get(), 1, 0);\n+            retryStatementNode = retryStatementNode.modify().withArguments(arguments).apply();\n+        }\n+        StatementNode retryBody;\n \n-        if (lockStatementNode.onFailClause().isPresent()) {\n-            blockStatement = formatNode(lockStatementNode.blockStatement(), 1, 0);\n-            OnFailClauseNode onFailClause = formatNode(lockStatementNode.onFailClause().get(),\n+        if (retryStatementNode.onFailClause().isPresent()) {\n+            retryBody = formatNode(retryStatementNode.retryBody(), 1, 0);\n+            OnFailClauseNode onFailClause = formatNode(retryStatementNode.onFailClause().get(),\n                     this.trailingWS, this.trailingNL);\n-            lockStatementNode = lockStatementNode.modify().withOnFailClause(onFailClause).apply();\n+            retryStatementNode = retryStatementNode.modify().withOnFailClause(onFailClause).apply();\n         } else {\n-            blockStatement = formatNode(lockStatementNode.blockStatement(), this.trailingWS, this.trailingNL);\n+            retryBody = formatNode(retryStatementNode.retryBody(), this.trailingWS, this.trailingNL);\n         }\n \n-        return lockStatementNode.modify()\n-                .withLockKeyword(lockKeyword)\n-                .withBlockStatement(blockStatement)\n+        return retryStatementNode.modify()\n+                .withRetryKeyword(retryKeyword)\n+                .withRetryBody(retryBody)\n                 .apply();\n     }\n \n     @Override\n-    public FieldAccessExpressionNode transform(FieldAccessExpressionNode fieldAccessExpressionNode) {\n-        ExpressionNode expression = formatNode(fieldAccessExpressionNode.expression(), 0, 0);\n-        Token dotToken = formatToken(fieldAccessExpressionNode.dotToken(), 0, 0);\n-        NameReferenceNode fieldName = formatNode(fieldAccessExpressionNode.fieldName(),\n-                this.trailingWS, this.trailingNL);\n+    public CommitActionNode transform(CommitActionNode commitActionNode) {\n+        Token commitKeyword = formatToken(commitActionNode.commitKeyword(), this.trailingWS, this.trailingNL);\n \n-        return fieldAccessExpressionNode.modify()\n-                .withExpression(expression)\n-                .withDotToken(dotToken)\n-                .withFieldName(fieldName)\n+        return commitActionNode.modify()\n+                .withCommitKeyword(commitKeyword)\n                 .apply();\n     }\n \n     @Override\n-    public MetadataNode transform(MetadataNode metadataNode) {\n-        NodeList<AnnotationNode> annotations = formatNodeList(metadataNode.annotations(), 0, 1, 0, 1);\n+    public TransactionalExpressionNode transform(TransactionalExpressionNode transactionalExpressionNode) {\n \n-        if (metadataNode.documentationString().isPresent()) {\n-            Node documentationString = formatNode(metadataNode.documentationString().get(),\n-                    this.trailingWS, this.trailingNL);\n-            metadataNode = metadataNode.modify().withDocumentationString(documentationString).apply();\n-        }\n+        return super.transform(transactionalExpressionNode);\n+    }\n \n-        return metadataNode.modify()\n-                .withAnnotations(annotations)\n+    @Override\n+    public ServiceConstructorExpressionNode transform(\n+            ServiceConstructorExpressionNode serviceConstructorExpressionNode) {\n+\n+        return super.transform(serviceConstructorExpressionNode);\n+    }\n+\n+    @Override\n+    public TypeReferenceTypeDescNode transform(TypeReferenceTypeDescNode typeReferenceTypeDescNode) {\n+\n+        return super.transform(typeReferenceTypeDescNode);\n+    }\n+\n+    @Override\n+    public DistinctTypeDescriptorNode transform(DistinctTypeDescriptorNode distinctTypeDescriptorNode) {\n+\n+        return super.transform(distinctTypeDescriptorNode);\n+    }\n+\n+    @Override\n+    public OnConflictClauseNode transform(OnConflictClauseNode onConflictClauseNode) {\n+\n+        return super.transform(onConflictClauseNode);\n+    }\n+\n+    @Override\n+    public LimitClauseNode transform(LimitClauseNode limitClauseNode) {\n+        Token limitKeyword = formatToken(limitClauseNode.limitKeyword(), 1, 0);\n+        ExpressionNode expression = formatNode(limitClauseNode.expression(), this.trailingWS, this.trailingNL);\n+\n+        return limitClauseNode.modify()\n+                .withLimitKeyword(limitKeyword)\n+                .withExpression(expression)\n                 .apply();\n     }\n \n     @Override\n-    public EnumDeclarationNode transform(EnumDeclarationNode enumDeclarationNode) {\n-        if (enumDeclarationNode.metadata().isPresent()) {\n-            MetadataNode metadata = formatNode(enumDeclarationNode.metadata().get(), 0, 1);\n-            enumDeclarationNode = enumDeclarationNode.modify()\n-                    .withMetadata(metadata).apply();\n+    public JoinClauseNode transform(JoinClauseNode joinClauseNode) {\n+        if (joinClauseNode.outerKeyword().isPresent()) {\n+            Token outerKeyword = formatToken(joinClauseNode.outerKeyword().get(), 1, 0);\n+            joinClauseNode = joinClauseNode.modify()\n+                    .withOuterKeyword(outerKeyword).apply();\n         }\n \n-        Token qualifier = formatToken(enumDeclarationNode.qualifier(), 1, 0);\n-        Token enumKeywordToken = formatToken(enumDeclarationNode.enumKeywordToken(), 1, 0);\n-        IdentifierToken identifier = formatNode(enumDeclarationNode.identifier(), 1, 0);\n-        Token openBraceToken = formatToken(enumDeclarationNode.openBraceToken(), 0, 1);\n-        indent();\n-        SeparatedNodeList<Node> enumMemberList = formatSeparatedNodeList(enumDeclarationNode.enumMemberList(),\n-                0, 0, 0, 1, 0, 1);\n-        unindent();\n-        Token closeBraceToken = formatToken(enumDeclarationNode.closeBraceToken(), this.trailingWS, this.trailingNL);\n+        Token joinKeyword = formatToken(joinClauseNode.joinKeyword(), 1, 0);\n+        TypedBindingPatternNode typedBindingPattern = formatNode(joinClauseNode.typedBindingPattern(), 1, 0);\n+        Token inKeyword = formatToken(joinClauseNode.inKeyword(), 1, 0);\n+        ExpressionNode expression = formatNode(joinClauseNode.expression(), 1, 0);\n+        OnClauseNode joinOnCondition = formatNode(joinClauseNode.joinOnCondition(), this.trailingWS, this.trailingNL);\n \n-        return enumDeclarationNode.modify()\n-                .withQualifier(qualifier)\n-                .withEnumKeywordToken(enumKeywordToken)\n-                .withIdentifier(identifier)\n-                .withOpenBraceToken(openBraceToken)\n-                .withEnumMemberList(enumMemberList)\n-                .withCloseBraceToken(closeBraceToken)\n+        return joinClauseNode.modify()\n+                .withJoinKeyword(joinKeyword)\n+                .withTypedBindingPattern(typedBindingPattern)\n+                .withInKeyword(inKeyword)\n+                .withExpression(expression)\n+                .withJoinOnCondition(joinOnCondition)\n                 .apply();\n     }\n \n     @Override\n-    public EnumMemberNode transform(EnumMemberNode enumMemberNode) {\n-        if (enumMemberNode.metadata().isPresent()) {\n-            MetadataNode metadata = formatNode(enumMemberNode.metadata().get(), 0, 1);\n-            enumMemberNode = enumMemberNode.modify().withMetadata(metadata).apply();\n-        }\n-        IdentifierToken identifier;\n+    public OnClauseNode transform(OnClauseNode onClauseNode) {\n \n-        if (enumMemberNode.equalToken().isPresent()) {\n-            identifier = formatNode(enumMemberNode.identifier(), 1, 0);\n-            Token equalToken = formatToken(enumMemberNode.equalToken().get(), 1, 0);\n-            ExpressionNode constExprNode = formatNode(enumMemberNode.constExprNode().get(),\n-                    this.trailingWS, this.trailingNL);\n+        return super.transform(onClauseNode);\n+    }\n \n-            return enumMemberNode.modify()\n-                    .withIdentifier(identifier)\n-                    .withEqualToken(equalToken)\n-                    .withConstExprNode(constExprNode)\n-                    .apply();\n-        } else {\n-            identifier = formatNode(enumMemberNode.identifier(), this.trailingWS, this.trailingNL);\n+    @Override\n+    public ListMatchPatternNode transform(ListMatchPatternNode listMatchPatternNode) {\n \n-            return enumMemberNode.modify()\n-                    .withIdentifier(identifier)\n-                    .apply();\n-        }\n+        return super.transform(listMatchPatternNode);\n     }\n \n     @Override\n-    public MarkdownDocumentationNode transform(MarkdownDocumentationNode markdownDocumentationNode) {\n-        NodeList<Node> documentationLines = formatNodeList(markdownDocumentationNode.documentationLines(), 0, 0, 0, 1);\n+    public RestMatchPatternNode transform(RestMatchPatternNode restMatchPatternNode) {\n \n-        return markdownDocumentationNode.modify()\n-                .withDocumentationLines(documentationLines)\n-                .apply();\n+        return super.transform(restMatchPatternNode);\n     }\n \n     @Override\n-    public MarkdownDocumentationLineNode transform(MarkdownDocumentationLineNode markdownDocumentationLineNode) {\n-        Token hashToken = formatToken(markdownDocumentationLineNode.hashToken(), 0, 0);\n-        NodeList<Node> documentElements = formatNodeList(markdownDocumentationLineNode.documentElements(), 0, 0, 0, 1);\n+    public FieldMatchPatternNode transform(FieldMatchPatternNode fieldMatchPatternNode) {\n \n-        return markdownDocumentationLineNode.modify()\n-                .withDocumentElements(documentElements)\n-                .withHashToken(hashToken)\n-                .apply();\n+        return super.transform(fieldMatchPatternNode);\n     }\n \n     @Override\n-    public MarkdownParameterDocumentationLineNode transform(\n-            MarkdownParameterDocumentationLineNode markdownParameterDocumentationLineNode) {\n-        Token hashToken = formatToken(markdownParameterDocumentationLineNode.hashToken(), 1, 0);\n-        Token plusToken = formatToken(markdownParameterDocumentationLineNode.plusToken(), 1, 0);\n-        Token parameterName = formatToken(markdownParameterDocumentationLineNode.parameterName(), 1, 0);\n-        Token minusToken = formatToken(markdownParameterDocumentationLineNode.minusToken(), 0, 0);\n-        NodeList<Node> documentElements =\n-                formatNodeList(markdownParameterDocumentationLineNode.documentElements(), 0, 0, 0, 1);\n+    public FunctionalMatchPatternNode transform(FunctionalMatchPatternNode functionalMatchPatternNode) {\n \n-        return markdownParameterDocumentationLineNode.modify()\n-                .withHashToken(hashToken)\n-                .withPlusToken(plusToken)\n-                .withParameterName(parameterName)\n-                .withMinusToken(minusToken)\n-                .withDocumentElements(documentElements)\n-                .apply();\n+        return super.transform(functionalMatchPatternNode);\n     }\n \n     @Override\n-    public DocumentationReferenceNode transform(DocumentationReferenceNode documentationReferenceNode) {\n-        if (documentationReferenceNode.referenceType().isPresent()) {\n-            Token referenceType = formatToken(documentationReferenceNode.referenceType().get(), 1, 0);\n-            documentationReferenceNode = documentationReferenceNode.modify().withReferenceType(referenceType).apply();\n+    public NamedArgMatchPatternNode transform(NamedArgMatchPatternNode namedArgMatchPatternNode) {\n+\n+        return super.transform(namedArgMatchPatternNode);\n+    }\n+\n+    @Override\n+    public OrderByClauseNode transform(OrderByClauseNode orderByClauseNode) {\n+\n+        return super.transform(orderByClauseNode);\n+    }\n+\n+    @Override\n+    public OrderKeyNode transform(OrderKeyNode orderKeyNode) {\n+        ExpressionNode expression = formatNode(orderKeyNode.expression(), 1, 0);", "originalCommit": "81330a2ede4dfaf5c68da3c18352254e103d9c0f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzMzMjgzMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26316#discussion_r503332830", "bodyText": "This also seems to be a bug in syntax-tree. Both constKeyword and typeDescriptor needs to be optional. Lets create an issue", "author": "SupunS", "createdAt": "2020-10-12T14:26:02Z", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -1328,270 +1452,1389 @@ public ListBindingPatternNode transform(ListBindingPatternNode listBindingPatter\n             listBindingPatternNode = listBindingPatternNode.modify().withRestBindingPattern(restBindingPattern).apply();\n         }\n \n-        return listBindingPatternNode.modify()\n-                .withOpenBracket(openBracket)\n-                .withBindingPatterns(bindingPatternNodes)\n-                .withCloseBracket(closeBracket)\n-                .apply();\n+        return listBindingPatternNode.modify()\n+                .withOpenBracket(openBracket)\n+                .withBindingPatterns(bindingPatternNodes)\n+                .withCloseBracket(closeBracket)\n+                .apply();\n+    }\n+\n+    @Override\n+    public RestBindingPatternNode transform(RestBindingPatternNode restBindingPatternNode) {\n+        Token ellipsisToken = formatToken(restBindingPatternNode.ellipsisToken(), 0, 0);\n+        SimpleNameReferenceNode variableName = formatNode(restBindingPatternNode.variableName(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return restBindingPatternNode.modify()\n+                .withEllipsisToken(ellipsisToken)\n+                .withVariableName(variableName)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TableTypeDescriptorNode transform(TableTypeDescriptorNode tableTypeDescriptorNode) {\n+        Token tableKeywordToken = formatToken(tableTypeDescriptorNode.tableKeywordToken(), 0, 0);\n+        Node rowTypeParameterNode = formatNode(tableTypeDescriptorNode.rowTypeParameterNode(), 1, 0);\n+        Node keyConstraintNode = formatNode(tableTypeDescriptorNode.keyConstraintNode(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return tableTypeDescriptorNode.modify()\n+                .withTableKeywordToken(tableKeywordToken)\n+                .withRowTypeParameterNode(rowTypeParameterNode)\n+                .withKeyConstraintNode(keyConstraintNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public KeyTypeConstraintNode transform(KeyTypeConstraintNode keyTypeConstraintNode) {\n+        Token keyKeywordToken = formatToken(keyTypeConstraintNode.keyKeywordToken(), 0, 0);\n+        Node typeParameterNode = formatNode(keyTypeConstraintNode.typeParameterNode(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return keyTypeConstraintNode.modify()\n+                .withKeyKeywordToken(keyKeywordToken)\n+                .withTypeParameterNode(typeParameterNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MatchStatementNode transform(MatchStatementNode matchStatementNode) {\n+        boolean hasOnFailClause = matchStatementNode.onFailClause().isPresent();\n+        Token matchKeyword = formatToken(matchStatementNode.matchKeyword(), 1, 0);\n+        ExpressionNode condition = formatNode(matchStatementNode.condition(), 1, 0);\n+        Token openBrace = formatToken(matchStatementNode.openBrace(), 0, 1);\n+        indent();\n+        NodeList<MatchClauseNode> matchClauses = formatNodeList(matchStatementNode.matchClauses(), 0, 1, 0, 1);\n+        unindent();\n+        Token closeBrace;\n+\n+        if (hasOnFailClause) {\n+            closeBrace = formatToken(matchStatementNode.closeBrace(), 1, 0);\n+            OnFailClauseNode onFailClause = formatNode(matchStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            matchStatementNode = matchStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        } else {\n+            closeBrace = formatToken(matchStatementNode.closeBrace(), this.trailingWS, this.trailingNL);\n+        }\n+\n+        return matchStatementNode.modify()\n+                .withMatchKeyword(matchKeyword)\n+                .withCondition(condition)\n+                .withOpenBrace(openBrace)\n+                .withMatchClauses(matchClauses)\n+                .withCloseBrace(closeBrace)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MatchClauseNode transform(MatchClauseNode matchClauseNode) {\n+        SeparatedNodeList<Node> matchPatterns = formatSeparatedNodeList(matchClauseNode.matchPatterns(),\n+                0, 0, 0, 0, 1, 0);\n+\n+        if (matchClauseNode.matchGuard().isPresent()) {\n+            MatchGuardNode matchGuard = formatNode(matchClauseNode.matchGuard().get(), 1, 0);\n+            matchClauseNode = matchClauseNode.modify().withMatchGuard(matchGuard).apply();\n+        }\n+\n+        Token rightDoubleArrow = formatToken(matchClauseNode.rightDoubleArrow(), 1, 0);\n+        BlockStatementNode blockStatement = formatNode(matchClauseNode.blockStatement(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return matchClauseNode.modify()\n+                .withMatchPatterns(matchPatterns)\n+                .withRightDoubleArrow(rightDoubleArrow)\n+                .withBlockStatement(blockStatement)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MatchGuardNode transform(MatchGuardNode matchGuardNode) {\n+        Token ifKeyword = formatToken(matchGuardNode.ifKeyword(), 1, 0);\n+        ExpressionNode expression = formatNode(matchGuardNode.expression(), this.trailingWS, this.trailingNL);\n+\n+        return matchGuardNode.modify()\n+                .withIfKeyword(ifKeyword)\n+                .withExpression(expression)\n+                .apply();\n+    }\n+\n+    @Override\n+    public LockStatementNode transform(LockStatementNode lockStatementNode) {\n+        Token lockKeyword = formatToken(lockStatementNode.lockKeyword(), 1, 0);\n+        StatementNode blockStatement;\n+\n+        if (lockStatementNode.onFailClause().isPresent()) {\n+            blockStatement = formatNode(lockStatementNode.blockStatement(), 1, 0);\n+            OnFailClauseNode onFailClause = formatNode(lockStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            lockStatementNode = lockStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        } else {\n+            blockStatement = formatNode(lockStatementNode.blockStatement(), this.trailingWS, this.trailingNL);\n+        }\n+\n+        return lockStatementNode.modify()\n+                .withLockKeyword(lockKeyword)\n+                .withBlockStatement(blockStatement)\n+                .apply();\n+    }\n+\n+    @Override\n+    public FieldAccessExpressionNode transform(FieldAccessExpressionNode fieldAccessExpressionNode) {\n+        ExpressionNode expression = formatNode(fieldAccessExpressionNode.expression(), 0, 0);\n+        Token dotToken = formatToken(fieldAccessExpressionNode.dotToken(), 0, 0);\n+        NameReferenceNode fieldName = formatNode(fieldAccessExpressionNode.fieldName(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return fieldAccessExpressionNode.modify()\n+                .withExpression(expression)\n+                .withDotToken(dotToken)\n+                .withFieldName(fieldName)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MetadataNode transform(MetadataNode metadataNode) {\n+        NodeList<AnnotationNode> annotations = formatNodeList(metadataNode.annotations(), 0, 1, 0, 1);\n+\n+        if (metadataNode.documentationString().isPresent()) {\n+            Node documentationString = formatNode(metadataNode.documentationString().get(),\n+                    this.trailingWS, this.trailingNL);\n+            metadataNode = metadataNode.modify().withDocumentationString(documentationString).apply();\n+        }\n+\n+        return metadataNode.modify()\n+                .withAnnotations(annotations)\n+                .apply();\n+    }\n+\n+    @Override\n+    public EnumDeclarationNode transform(EnumDeclarationNode enumDeclarationNode) {\n+        if (enumDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(enumDeclarationNode.metadata().get(), 0, 1);\n+            enumDeclarationNode = enumDeclarationNode.modify()\n+                    .withMetadata(metadata).apply();\n+        }\n+\n+        Token qualifier = formatToken(enumDeclarationNode.qualifier(), 1, 0);\n+        Token enumKeywordToken = formatToken(enumDeclarationNode.enumKeywordToken(), 1, 0);\n+        IdentifierToken identifier = formatNode(enumDeclarationNode.identifier(), 1, 0);\n+        Token openBraceToken = formatToken(enumDeclarationNode.openBraceToken(), 0, 1);\n+        indent();\n+        SeparatedNodeList<Node> enumMemberList = formatSeparatedNodeList(enumDeclarationNode.enumMemberList(),\n+                0, 0, 0, 1, 0, 1);\n+        unindent();\n+        Token closeBraceToken = formatToken(enumDeclarationNode.closeBraceToken(), this.trailingWS, this.trailingNL);\n+\n+        return enumDeclarationNode.modify()\n+                .withQualifier(qualifier)\n+                .withEnumKeywordToken(enumKeywordToken)\n+                .withIdentifier(identifier)\n+                .withOpenBraceToken(openBraceToken)\n+                .withEnumMemberList(enumMemberList)\n+                .withCloseBraceToken(closeBraceToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public EnumMemberNode transform(EnumMemberNode enumMemberNode) {\n+        if (enumMemberNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(enumMemberNode.metadata().get(), 0, 1);\n+            enumMemberNode = enumMemberNode.modify().withMetadata(metadata).apply();\n+        }\n+        IdentifierToken identifier;\n+\n+        if (enumMemberNode.equalToken().isPresent()) {\n+            identifier = formatNode(enumMemberNode.identifier(), 1, 0);\n+            Token equalToken = formatToken(enumMemberNode.equalToken().get(), 1, 0);\n+            ExpressionNode constExprNode = formatNode(enumMemberNode.constExprNode().get(),\n+                    this.trailingWS, this.trailingNL);\n+\n+            return enumMemberNode.modify()\n+                    .withIdentifier(identifier)\n+                    .withEqualToken(equalToken)\n+                    .withConstExprNode(constExprNode)\n+                    .apply();\n+        } else {\n+            identifier = formatNode(enumMemberNode.identifier(), this.trailingWS, this.trailingNL);\n+\n+            return enumMemberNode.modify()\n+                    .withIdentifier(identifier)\n+                    .apply();\n+        }\n+    }\n+\n+    @Override\n+    public MarkdownDocumentationNode transform(MarkdownDocumentationNode markdownDocumentationNode) {\n+        NodeList<Node> documentationLines = formatNodeList(markdownDocumentationNode.documentationLines(),\n+                0, 0, this.trailingWS, this.trailingNL);\n+\n+        return markdownDocumentationNode.modify()\n+                .withDocumentationLines(documentationLines)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MarkdownDocumentationLineNode transform(MarkdownDocumentationLineNode markdownDocumentationLineNode) {\n+        Token hashToken = formatToken(markdownDocumentationLineNode.hashToken(), 0, 0);\n+        NodeList<Node> documentElements = formatNodeList(markdownDocumentationLineNode.documentElements(),\n+                0, 0, this.trailingWS, this.trailingNL);\n+\n+        return markdownDocumentationLineNode.modify()\n+                .withDocumentElements(documentElements)\n+                .withHashToken(hashToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MarkdownParameterDocumentationLineNode transform(\n+            MarkdownParameterDocumentationLineNode markdownParameterDocumentationLineNode) {\n+        Token hashToken = formatToken(markdownParameterDocumentationLineNode.hashToken(), 1, 0);\n+        Token plusToken = formatToken(markdownParameterDocumentationLineNode.plusToken(), 1, 0);\n+        Token parameterName = formatToken(markdownParameterDocumentationLineNode.parameterName(), 1, 0);\n+        Token minusToken = formatToken(markdownParameterDocumentationLineNode.minusToken(), 0, 0);\n+        NodeList<Node> documentElements = formatNodeList(markdownParameterDocumentationLineNode.documentElements(),\n+                0, 0, this.trailingWS, this.trailingNL);\n+\n+        return markdownParameterDocumentationLineNode.modify()\n+                .withHashToken(hashToken)\n+                .withPlusToken(plusToken)\n+                .withParameterName(parameterName)\n+                .withMinusToken(minusToken)\n+                .withDocumentElements(documentElements)\n+                .apply();\n+    }\n+\n+    @Override\n+    public DocumentationReferenceNode transform(DocumentationReferenceNode documentationReferenceNode) {\n+        if (documentationReferenceNode.referenceType().isPresent()) {\n+            Token referenceType = formatToken(documentationReferenceNode.referenceType().get(), 1, 0);\n+            documentationReferenceNode = documentationReferenceNode.modify().withReferenceType(referenceType).apply();\n+        }\n+\n+        Token startBacktick = formatToken(documentationReferenceNode.startBacktick(), 0, 0);\n+        Node backtickContent = formatNode(documentationReferenceNode.backtickContent(), 0, 0);\n+        Token endBacktick = formatToken(documentationReferenceNode.endBacktick(), this.trailingWS, this.trailingNL);\n+\n+        return documentationReferenceNode.modify()\n+                .withStartBacktick(startBacktick)\n+                .withBacktickContent(backtickContent)\n+                .withEndBacktick(endBacktick)\n+                .apply();\n+    }\n+\n+    @Override\n+    public PositionalArgumentNode transform(PositionalArgumentNode positionalArgumentNode) {\n+\n+        return super.transform(positionalArgumentNode);\n+    }\n+\n+    @Override\n+    public MappingBindingPatternNode transform(MappingBindingPatternNode mappingBindingPatternNode) {\n+\n+        return super.transform(mappingBindingPatternNode);\n+    }\n+\n+    @Override\n+    public FieldBindingPatternFullNode transform(FieldBindingPatternFullNode fieldBindingPatternFullNode) {\n+\n+        return super.transform(fieldBindingPatternFullNode);\n+    }\n+\n+    @Override\n+    public FieldBindingPatternVarnameNode transform(FieldBindingPatternVarnameNode fieldBindingPatternVarnameNode) {\n+\n+        return super.transform(fieldBindingPatternVarnameNode);\n+    }\n+\n+    @Override\n+    public TypeTestExpressionNode transform(TypeTestExpressionNode typeTestExpressionNode) {\n+\n+        return super.transform(typeTestExpressionNode);\n+    }\n+\n+    @Override\n+    public ListenerDeclarationNode transform(ListenerDeclarationNode listenerDeclarationNode) {\n+\n+        return super.transform(listenerDeclarationNode);\n+    }\n+\n+    @Override\n+    public ArrayTypeDescriptorNode transform(ArrayTypeDescriptorNode arrayTypeDescriptorNode) {\n+\n+        return super.transform(arrayTypeDescriptorNode);\n+    }\n+\n+    @Override\n+    public MethodCallExpressionNode transform(MethodCallExpressionNode methodCallExpressionNode) {\n+\n+        return super.transform(methodCallExpressionNode);\n+    }\n+\n+    @Override\n+    public NilLiteralNode transform(NilLiteralNode nilLiteralNode) {\n+        Token openParenToken = formatToken(nilLiteralNode.openParenToken(), 0, 0);\n+        Token closeParenToken = formatToken(nilLiteralNode.closeParenToken(), this.trailingWS, this.trailingNL);\n+\n+        return nilLiteralNode.modify()\n+                .withOpenParenToken(openParenToken)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public XMLNamespaceDeclarationNode transform(XMLNamespaceDeclarationNode xMLNamespaceDeclarationNode) {\n+        Token xmlnsKeyword = formatToken(xMLNamespaceDeclarationNode.xmlnsKeyword(), 1, 0);\n+        ExpressionNode namespaceuri;\n+\n+        if (xMLNamespaceDeclarationNode.asKeyword().isPresent()) {\n+            Token asKeyword = formatToken(xMLNamespaceDeclarationNode.asKeyword().get(), 1, 0);\n+            xMLNamespaceDeclarationNode = xMLNamespaceDeclarationNode.modify()\n+                    .withAsKeyword(asKeyword).apply();\n+        }\n+\n+        if (xMLNamespaceDeclarationNode.namespacePrefix().isPresent()) {\n+            namespaceuri = formatNode(xMLNamespaceDeclarationNode.namespaceuri(), 1, 0);\n+            IdentifierToken namespacePrefix = formatNode(xMLNamespaceDeclarationNode.namespacePrefix().get(), 0, 0);\n+            xMLNamespaceDeclarationNode = xMLNamespaceDeclarationNode.modify()\n+                    .withNamespacePrefix(namespacePrefix).apply();\n+        } else {\n+            namespaceuri = formatNode(xMLNamespaceDeclarationNode.namespaceuri(), 0, 0);\n+        }\n+\n+        Token semicolonToken = formatToken(xMLNamespaceDeclarationNode.semicolonToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return xMLNamespaceDeclarationNode.modify()\n+                .withXmlnsKeyword(xmlnsKeyword)\n+                .withNamespaceuri(namespaceuri)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ModuleXMLNamespaceDeclarationNode transform(\n+            ModuleXMLNamespaceDeclarationNode moduleXMLNamespaceDeclarationNode) {\n+        Token xmlnsKeyword = formatToken(moduleXMLNamespaceDeclarationNode.xmlnsKeyword(), 1, 0);\n+        ExpressionNode namespaceuri = formatNode(moduleXMLNamespaceDeclarationNode.namespaceuri(), 1, 0);\n+        Token asKeyword = formatToken(moduleXMLNamespaceDeclarationNode.asKeyword(), 1, 0);\n+        IdentifierToken namespacePrefix = formatNode(moduleXMLNamespaceDeclarationNode.namespacePrefix(), 0, 0);\n+        Token semicolonToken = formatToken(moduleXMLNamespaceDeclarationNode.semicolonToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return moduleXMLNamespaceDeclarationNode.modify()\n+                .withNamespacePrefix(namespacePrefix)\n+                .withNamespaceuri(namespaceuri)\n+                .withXmlnsKeyword(xmlnsKeyword)\n+                .withAsKeyword(asKeyword)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public XmlTypeDescriptorNode transform(XmlTypeDescriptorNode xmlTypeDescriptorNode) {\n+\n+        return super.transform(xmlTypeDescriptorNode);\n+    }\n+\n+    @Override\n+    public XMLElementNode transform(XMLElementNode xMLElementNode) {\n+\n+        return super.transform(xMLElementNode);\n+    }\n+\n+    @Override\n+    public XMLStartTagNode transform(XMLStartTagNode xMLStartTagNode) {\n+\n+        return super.transform(xMLStartTagNode);\n+    }\n+\n+    @Override\n+    public XMLEndTagNode transform(XMLEndTagNode xMLEndTagNode) {\n+\n+        return super.transform(xMLEndTagNode);\n+    }\n+\n+    @Override\n+    public XMLSimpleNameNode transform(XMLSimpleNameNode xMLSimpleNameNode) {\n+        Token name = formatToken(xMLSimpleNameNode.name(), this.trailingWS, this.trailingNL);\n+\n+        return xMLSimpleNameNode.modify()\n+                .withName(name)\n+                .apply();\n+    }\n+\n+    @Override\n+    public XMLQualifiedNameNode transform(XMLQualifiedNameNode xMLQualifiedNameNode) {\n+\n+        return super.transform(xMLQualifiedNameNode);\n+    }\n+\n+    @Override\n+    public XMLEmptyElementNode transform(XMLEmptyElementNode xMLEmptyElementNode) {\n+        Token ltToken = formatToken(xMLEmptyElementNode.ltToken(), 0, 0);\n+        XMLNameNode name;\n+        if (xMLEmptyElementNode.attributes().isEmpty()) {\n+            name = formatNode(xMLEmptyElementNode.name(), 0, 0);\n+        } else {\n+            name = formatNode(xMLEmptyElementNode.name(), 1, 0);\n+        }\n+\n+        NodeList<XMLAttributeNode> attributes = formatNodeList(xMLEmptyElementNode.attributes(), 1, 0, 0, 0);\n+        Token slashToken = formatToken(xMLEmptyElementNode.slashToken(), 0, 0);\n+        Token getToken = formatToken(xMLEmptyElementNode.getToken(), this.trailingWS, this.trailingNL);\n+\n+        return xMLEmptyElementNode.modify()\n+                .withLtToken(ltToken)\n+                .withName(name)\n+                .withAttributes(attributes)\n+                .withSlashToken(slashToken)\n+                .withGetToken(getToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public XMLTextNode transform(XMLTextNode xMLTextNode) {\n+        Token content = formatToken(xMLTextNode.content(), this.trailingWS, this.trailingNL);\n+\n+        return xMLTextNode.modify()\n+                .withContent(content)\n+                .apply();\n+    }\n+\n+    @Override\n+    public XMLAttributeNode transform(XMLAttributeNode xMLAttributeNode) {\n+\n+        return super.transform(xMLAttributeNode);\n+    }\n+\n+    @Override\n+    public XMLAttributeValue transform(XMLAttributeValue xMLAttributeValue) {\n+\n+        return super.transform(xMLAttributeValue);\n+    }\n+\n+    @Override\n+    public XMLComment transform(XMLComment xMLComment) {\n+        Token commentStart = formatToken(xMLComment.commentStart(), 0, 0);\n+        NodeList<Node> content = formatNodeList(xMLComment.content(), 1, 0, 0, 0);\n+        Token commentEnd = formatToken(xMLComment.commentEnd(), this.trailingWS, this.trailingNL);\n+\n+        return xMLComment.modify()\n+                .withCommentStart(commentStart)\n+                .withContent(content)\n+                .withCommentEnd(commentEnd)\n+                .apply();\n+    }\n+\n+    @Override\n+    public XMLProcessingInstruction transform(XMLProcessingInstruction xMLProcessingInstruction) {\n+        Token piStart = formatToken(xMLProcessingInstruction.piStart(), 0, 0);\n+        XMLNameNode target = formatNode(xMLProcessingInstruction.target(), 1, 0);\n+        NodeList<Node> data = formatNodeList(xMLProcessingInstruction.data(), 1, 0, 0, 0);\n+        Token piEnd = formatToken(xMLProcessingInstruction.piEnd(), this.trailingWS, this.trailingNL);\n+\n+        return xMLProcessingInstruction.modify()\n+                .withTarget(target)\n+                .withPiStart(piStart)\n+                .withData(data)\n+                .withPiEnd(piEnd)\n+                .apply();\n+    }\n+\n+    @Override\n+    public XMLFilterExpressionNode transform(XMLFilterExpressionNode xMLFilterExpressionNode) {\n+\n+        return super.transform(xMLFilterExpressionNode);\n+    }\n+\n+    @Override\n+    public XMLStepExpressionNode transform(XMLStepExpressionNode xMLStepExpressionNode) {\n+\n+        return super.transform(xMLStepExpressionNode);\n+    }\n+\n+    @Override\n+    public XMLNamePatternChainingNode transform(XMLNamePatternChainingNode xMLNamePatternChainingNode) {\n+\n+        return super.transform(xMLNamePatternChainingNode);\n+    }\n+\n+    @Override\n+    public XMLAtomicNamePatternNode transform(XMLAtomicNamePatternNode xMLAtomicNamePatternNode) {\n+\n+        return super.transform(xMLAtomicNamePatternNode);\n+    }\n+\n+    @Override\n+    public TemplateExpressionNode transform(TemplateExpressionNode templateExpressionNode) {\n+\n+        return super.transform(templateExpressionNode);\n+    }\n+\n+    @Override\n+    public ByteArrayLiteralNode transform(ByteArrayLiteralNode byteArrayLiteralNode) {\n+\n+        return super.transform(byteArrayLiteralNode);\n+    }\n+\n+    @Override\n+    public TypeReferenceNode transform(TypeReferenceNode typeReferenceNode) {\n+\n+        return super.transform(typeReferenceNode);\n+    }\n+\n+    @Override\n+    public MappingMatchPatternNode transform(MappingMatchPatternNode mappingMatchPatternNode) {\n+\n+        return super.transform(mappingMatchPatternNode);\n+    }\n+\n+    @Override\n+    public StartActionNode transform(StartActionNode startActionNode) {\n+        NodeList<AnnotationNode> annotations = formatNodeList(startActionNode.annotations(), 0, 1, 0, 1);\n+        Token startKeyword = formatToken(startActionNode.startKeyword(), 1, 0);\n+        ExpressionNode expression = formatNode(startActionNode.expression(), this.trailingWS, this.trailingNL);\n+\n+        return startActionNode.modify()\n+                .withAnnotations(annotations)\n+                .withStartKeyword(startKeyword)\n+                .withExpression(expression)\n+                .apply();\n+    }\n+\n+    @Override\n+    public FlushActionNode transform(FlushActionNode flushActionNode) {\n+        Token flushKeyword = formatToken(flushActionNode.flushKeyword(), 1, 0);\n+        NameReferenceNode peerWorker = formatNode(flushActionNode.peerWorker(), this.trailingWS, this.trailingNL);\n+\n+        return flushActionNode.modify()\n+                .withFlushKeyword(flushKeyword)\n+                .withPeerWorker(peerWorker)\n+                .apply();\n+    }\n+\n+    @Override\n+    public NamedWorkerDeclarationNode transform(NamedWorkerDeclarationNode namedWorkerDeclarationNode) {\n+\n+        return super.transform(namedWorkerDeclarationNode);\n+    }\n+\n+    @Override\n+    public FailStatementNode transform(FailStatementNode failStatementNode) {\n+        Token failKeyword = formatToken(failStatementNode.failKeyword(), 1, 0);\n+        ExpressionNode expression = formatNode(failStatementNode.expression(), 0, 0);\n+        Token semicolonToken = formatToken(failStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return failStatementNode.modify()\n+                .withFailKeyword(failKeyword)\n+                .withExpression(expression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ContinueStatementNode transform(ContinueStatementNode continueStatementNode) {\n+        Token continueToken = formatToken(continueStatementNode.continueToken(), 0, 0);\n+        Token semicolonToken = formatToken(continueStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return continueStatementNode.modify()\n+                .withContinueToken(continueToken)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public LocalTypeDefinitionStatementNode transform(\n+            LocalTypeDefinitionStatementNode localTypeDefinitionStatementNode) {\n+        NodeList<AnnotationNode> annotations = formatNodeList(localTypeDefinitionStatementNode.annotations(),\n+                1, 0, 1, 0);\n+        Token typeKeyword = formatToken(localTypeDefinitionStatementNode.typeKeyword(), 1, 0);\n+        Node typeName = formatNode(localTypeDefinitionStatementNode.typeName(), 1, 0);\n+        Node typeDescriptor = formatNode(localTypeDefinitionStatementNode.typeDescriptor(), 1, 0);\n+        Token semicolonToken = formatToken(localTypeDefinitionStatementNode.semicolonToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return localTypeDefinitionStatementNode.modify()\n+                .withAnnotations(annotations)\n+                .withTypeKeyword(typeKeyword)\n+                .withTypeName(typeName)\n+                .withTypeDescriptor(typeDescriptor)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ForkStatementNode transform(ForkStatementNode forkStatementNode) {\n+        Token forkKeyword = formatToken(forkStatementNode.forkKeyword(), 1, 0);\n+        Token openBraceToken = formatToken(forkStatementNode.openBraceToken(), 0, 1);\n+        indent();\n+        NodeList<NamedWorkerDeclarationNode> namedWorkerDeclarations =\n+                formatNodeList(forkStatementNode.namedWorkerDeclarations(), 0, 1, 0, 1);\n+        unindent();\n+        Token closeBraceToken = formatToken(forkStatementNode.closeBraceToken(), this.trailingWS, this.trailingNL);\n+\n+        return forkStatementNode.modify()\n+                .withForkKeyword(forkKeyword)\n+                .withOpenBraceToken(openBraceToken)\n+                .withNamedWorkerDeclarations(namedWorkerDeclarations)\n+                .withCloseBraceToken(closeBraceToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TypeofExpressionNode transform(TypeofExpressionNode typeofExpressionNode) {\n+\n+        return super.transform(typeofExpressionNode);\n+    }\n+\n+    @Override\n+    public UnaryExpressionNode transform(UnaryExpressionNode unaryExpressionNode) {\n+        Token unaryOperator = formatToken(unaryExpressionNode.unaryOperator(), 0, 0);\n+        ExpressionNode expression = formatNode(unaryExpressionNode.expression(), this.trailingWS, this.trailingNL);\n+\n+        return unaryExpressionNode.modify()\n+                .withUnaryOperator(unaryOperator)\n+                .withExpression(expression)\n+                .apply();\n+    }\n+\n+    @Override\n+    public DefaultableParameterNode transform(DefaultableParameterNode defaultableParameterNode) {\n+        NodeList<AnnotationNode> annotations = formatNodeList(defaultableParameterNode.annotations(), 1, 0, 1, 0);\n+        Node typeName = formatNode(defaultableParameterNode.typeName(), 1, 0);\n+\n+        if (defaultableParameterNode.paramName().isPresent()) {\n+            Token paramName = formatToken(defaultableParameterNode.paramName().get(), 1, 0);\n+            defaultableParameterNode = defaultableParameterNode.modify().withParamName(paramName).apply();\n+        }\n+\n+        Token equalsToken = formatToken(defaultableParameterNode.equalsToken(), 1, 0);\n+        Node expression = formatNode(defaultableParameterNode.expression(), this.trailingWS, this.trailingNL);\n+\n+        return defaultableParameterNode.modify()\n+                .withAnnotations(annotations)\n+                .withTypeName(typeName)\n+                .withEqualsToken(equalsToken)\n+                .withExpression(expression)\n+                .apply();\n+    }\n+\n+    @Override\n+    public RestParameterNode transform(RestParameterNode restParameterNode) {\n+\n+        return super.transform(restParameterNode);\n+    }\n+\n+    @Override\n+    public SpreadFieldNode transform(SpreadFieldNode spreadFieldNode) {\n+\n+        return super.transform(spreadFieldNode);\n+    }\n+\n+    @Override\n+    public NamedArgumentNode transform(NamedArgumentNode namedArgumentNode) {\n+\n+        return super.transform(namedArgumentNode);\n+    }\n+\n+    @Override\n+    public RestArgumentNode transform(RestArgumentNode restArgumentNode) {\n+\n+        return super.transform(restArgumentNode);\n+    }\n+\n+    @Override\n+    public ObjectTypeDescriptorNode transform(ObjectTypeDescriptorNode objectTypeDescriptorNode) {\n+\n+        return super.transform(objectTypeDescriptorNode);\n+    }\n+\n+    @Override\n+    public ObjectConstructorExpressionNode transform(ObjectConstructorExpressionNode objectConstructorExpressionNode) {\n+\n+        return super.transform(objectConstructorExpressionNode);\n+    }\n+\n+    @Override\n+    public ObjectFieldNode transform(ObjectFieldNode objectFieldNode) {\n+\n+        return super.transform(objectFieldNode);\n+    }\n+\n+    @Override\n+    public RecordRestDescriptorNode transform(RecordRestDescriptorNode recordRestDescriptorNode) {\n+\n+        return super.transform(recordRestDescriptorNode);\n+    }\n+\n+    @Override\n+    public AnnotationDeclarationNode transform(AnnotationDeclarationNode annotationDeclarationNode) {\n+        if (annotationDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(annotationDeclarationNode.metadata().get(), 0, 1);\n+            annotationDeclarationNode = annotationDeclarationNode.modify().withMetadata(metadata).apply();\n+        }\n+\n+        Token visibilityQualifier = formatToken(annotationDeclarationNode.visibilityQualifier(), 1, 0);\n+        Token constKeyword = formatToken(annotationDeclarationNode.constKeyword(), 1, 0);\n+        Token annotationKeyword = formatToken(annotationDeclarationNode.annotationKeyword(), 1, 0);\n+        Node typeDescriptor = formatNode(annotationDeclarationNode.typeDescriptor(), 1, 0);", "originalCommit": "81330a2ede4dfaf5c68da3c18352254e103d9c0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzcxMzc3Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26316#discussion_r503713777", "bodyText": "#26328", "author": "IrushiL", "createdAt": "2020-10-13T07:07:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzMzMjgzMA=="}], "type": "inlineReview"}]}