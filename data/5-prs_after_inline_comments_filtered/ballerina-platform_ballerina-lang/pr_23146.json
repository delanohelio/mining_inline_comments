{"pr_number": 23146, "pr_title": "Implement the new-expr for the incremental parser.", "pr_createdAt": "2020-05-07T11:25:32Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146", "timeline": [{"oid": "49599a52b4339be13bced910e57c9b8f54700429", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/49599a52b4339be13bced910e57c9b8f54700429", "message": "new-expr implementation", "committedDate": "2020-05-07T11:23:42Z", "type": "commit"}, {"oid": "8ae4c6e850b7ecb589b3f16e8966ac7109266ee3", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8ae4c6e850b7ecb589b3f16e8966ac7109266ee3", "message": "Refactor BallerinaParser.java", "committedDate": "2020-05-07T11:28:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ5MDc2Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r421490762", "bodyText": "if none of the above, should it be treated as simply new?\ni.e.: foo(new);,  where function foo(T x) {...}", "author": "SupunS", "createdAt": "2020-05-07T13:10:30Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3172,6 +3180,127 @@ private STNode parseActionOrExpressionInLhs(SyntaxKind nextTokenKind, STNode lhs\n         return parseExpressionRhs(nextTokenKind, DEFAULT_OP_PRECEDENCE, lhsExpr, false, true);\n     }\n \n+    /**\n+     * <p>\n+     * Parse a new expression.\n+     * </p>\n+     * <code>\n+     *  new-expr := explicit-new-expr | implicit-new-expr\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     *  implicit-new-expr := new [( arg-list )]\n+     * </code>\n+     *\n+     * @return Parsed NewExpression node.\n+     */\n+    private STNode parseNewExpression() {\n+        startContext(ParserRuleContext.NEW_EXPRESSION);\n+        STNode newKeyword = parseNewKeyword();\n+        STNode newExpression = parseNewExpression(newKeyword);\n+        endContext();\n+        return newExpression;\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse `new` keyword.\n+     * </p>\n+     *\n+     * @return Parsed NEW_KEYWORD Token.\n+     */\n+    private STNode parseNewKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.NEW_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.NEW_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    private STNode parseNewExpression(STNode newKeyword) {\n+        STNode token = peek();\n+        return parseNewExpression(token.kind, newKeyword);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an implicit or explicit expression.\n+     * </p>\n+     * @param kind next token kind.\n+     * @param newKeyword parsed node for `new` keyword.\n+     * @return Parsed new-expression node.\n+     */\n+    private STNode parseNewExpression(SyntaxKind kind, STNode newKeyword) {\n+        switch (kind) {\n+            case OPEN_PAREN_TOKEN:\n+                return parseImplicitNewExpression(newKeyword);\n+            case SEMICOLON_TOKEN:\n+                return STNodeFactory.createImplicitNewExpression(newKeyword, STNodeFactory.createEmptyNode());\n+            case IDENTIFIER_TOKEN:\n+            case OBJECT_KEYWORD:\n+                // TODO: Support `stream` keyword once introduced\n+                return parseExplicitNewExpression(newKeyword);\n+            default:\n+                Solution sol = recover(peek(), ParserRuleContext.NEW_EXPRESSION, newKeyword);", "originalCommit": "8ae4c6e850b7ecb589b3f16e8966ac7109266ee3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUwOTE0OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r421509149", "bodyText": "btw, IMO this context not NEW_EXPRESSION, its more like NEW_KEYWORD_RHS", "author": "SupunS", "createdAt": "2020-05-07T13:36:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ5MDc2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUxOTE3OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r422519178", "bodyText": "fixed with 07c06fd for comment 2. Need to analyse how to handle comment one :)", "author": "dulvinw", "createdAt": "2020-05-09T16:51:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ5MDc2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY3MjM0Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r423672342", "bodyText": "Resolved the comment 1 scenario as well", "author": "dulvinw", "createdAt": "2020-05-12T11:51:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ5MDc2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ5MzE1NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r421493155", "bodyText": "Need to validate whether this is a object-type-desc or a type-reference", "author": "SupunS", "createdAt": "2020-05-07T13:14:13Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3172,6 +3180,127 @@ private STNode parseActionOrExpressionInLhs(SyntaxKind nextTokenKind, STNode lhs\n         return parseExpressionRhs(nextTokenKind, DEFAULT_OP_PRECEDENCE, lhsExpr, false, true);\n     }\n \n+    /**\n+     * <p>\n+     * Parse a new expression.\n+     * </p>\n+     * <code>\n+     *  new-expr := explicit-new-expr | implicit-new-expr\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     *  implicit-new-expr := new [( arg-list )]\n+     * </code>\n+     *\n+     * @return Parsed NewExpression node.\n+     */\n+    private STNode parseNewExpression() {\n+        startContext(ParserRuleContext.NEW_EXPRESSION);\n+        STNode newKeyword = parseNewKeyword();\n+        STNode newExpression = parseNewExpression(newKeyword);\n+        endContext();\n+        return newExpression;\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse `new` keyword.\n+     * </p>\n+     *\n+     * @return Parsed NEW_KEYWORD Token.\n+     */\n+    private STNode parseNewKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.NEW_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.NEW_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    private STNode parseNewExpression(STNode newKeyword) {\n+        STNode token = peek();\n+        return parseNewExpression(token.kind, newKeyword);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an implicit or explicit expression.\n+     * </p>\n+     * @param kind next token kind.\n+     * @param newKeyword parsed node for `new` keyword.\n+     * @return Parsed new-expression node.\n+     */\n+    private STNode parseNewExpression(SyntaxKind kind, STNode newKeyword) {\n+        switch (kind) {\n+            case OPEN_PAREN_TOKEN:\n+                return parseImplicitNewExpression(newKeyword);\n+            case SEMICOLON_TOKEN:\n+                return STNodeFactory.createImplicitNewExpression(newKeyword, STNodeFactory.createEmptyNode());\n+            case IDENTIFIER_TOKEN:\n+            case OBJECT_KEYWORD:\n+                // TODO: Support `stream` keyword once introduced\n+                return parseExplicitNewExpression(newKeyword);\n+            default:\n+                Solution sol = recover(peek(), ParserRuleContext.NEW_EXPRESSION, newKeyword);\n+                return parseNewExpression(sol.recoveredNode.kind, newKeyword);\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an Explicit New expression.\n+     * </p>\n+     * <code>\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     * </code>\n+     *\n+     * @param newKeyword Parsed `new` keyword.\n+     * @return the Parsed Explicit New Expression.\n+     */\n+    private STNode parseExplicitNewExpression(STNode newKeyword) {\n+        startContext(ParserRuleContext.EXPLICIT_NEW_RHS);\n+        STNode typeDescriptor = parseTypeDescriptor();", "originalCommit": "8ae4c6e850b7ecb589b3f16e8966ac7109266ee3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUxNjcyNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r422516727", "bodyText": "Since I come to this stage with only OBJECT_KEYWORD i didn't think i need to do that. But since the discussion we had to enable all the types and then validate, to give a meaningful error, I think i have to change the logic here", "author": "dulvinw", "createdAt": "2020-05-09T16:28:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ5MzE1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ5NTg0MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r421495841", "bodyText": "unused method?", "author": "SupunS", "createdAt": "2020-05-07T13:18:07Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3172,6 +3180,127 @@ private STNode parseActionOrExpressionInLhs(SyntaxKind nextTokenKind, STNode lhs\n         return parseExpressionRhs(nextTokenKind, DEFAULT_OP_PRECEDENCE, lhsExpr, false, true);\n     }\n \n+    /**\n+     * <p>\n+     * Parse a new expression.\n+     * </p>\n+     * <code>\n+     *  new-expr := explicit-new-expr | implicit-new-expr\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     *  implicit-new-expr := new [( arg-list )]\n+     * </code>\n+     *\n+     * @return Parsed NewExpression node.\n+     */\n+    private STNode parseNewExpression() {\n+        startContext(ParserRuleContext.NEW_EXPRESSION);\n+        STNode newKeyword = parseNewKeyword();\n+        STNode newExpression = parseNewExpression(newKeyword);\n+        endContext();\n+        return newExpression;\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse `new` keyword.\n+     * </p>\n+     *\n+     * @return Parsed NEW_KEYWORD Token.\n+     */\n+    private STNode parseNewKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.NEW_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.NEW_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    private STNode parseNewExpression(STNode newKeyword) {\n+        STNode token = peek();\n+        return parseNewExpression(token.kind, newKeyword);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an implicit or explicit expression.\n+     * </p>\n+     * @param kind next token kind.\n+     * @param newKeyword parsed node for `new` keyword.\n+     * @return Parsed new-expression node.\n+     */\n+    private STNode parseNewExpression(SyntaxKind kind, STNode newKeyword) {\n+        switch (kind) {\n+            case OPEN_PAREN_TOKEN:\n+                return parseImplicitNewExpression(newKeyword);\n+            case SEMICOLON_TOKEN:\n+                return STNodeFactory.createImplicitNewExpression(newKeyword, STNodeFactory.createEmptyNode());\n+            case IDENTIFIER_TOKEN:\n+            case OBJECT_KEYWORD:\n+                // TODO: Support `stream` keyword once introduced\n+                return parseExplicitNewExpression(newKeyword);\n+            default:\n+                Solution sol = recover(peek(), ParserRuleContext.NEW_EXPRESSION, newKeyword);\n+                return parseNewExpression(sol.recoveredNode.kind, newKeyword);\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an Explicit New expression.\n+     * </p>\n+     * <code>\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     * </code>\n+     *\n+     * @param newKeyword Parsed `new` keyword.\n+     * @return the Parsed Explicit New Expression.\n+     */\n+    private STNode parseExplicitNewExpression(STNode newKeyword) {\n+        startContext(ParserRuleContext.EXPLICIT_NEW_RHS);\n+        STNode typeDescriptor = parseTypeDescriptor();\n+        STNode parenthesizedArgsList = parseParenthesizedArgList();\n+        endContext();\n+\n+        return STNodeFactory.createExplicitNewExpression(newKeyword, typeDescriptor, parenthesizedArgsList);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an <code>implicit-new-expr</code> with arguments.\n+     * </p>\n+     *\n+     * @param newKeyword Parsed `new` keyword.\n+     * @return Parsed implicit-new-expr.\n+     */\n+    private STNode parseImplicitNewExpression(STNode newKeyword) {\n+        STNode implicitNewArgList = parseParenthesizedArgList();\n+\n+        return STNodeFactory.createImplicitNewExpression(newKeyword, implicitNewArgList);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse the parenthesized argument list for a <code>new-expr</code>.\n+     * </p>\n+     *\n+     * @return Parsed parenthesized rhs of <code>new-expr</code>.\n+     */\n+    private STNode parseParenthesizedArgList() {\n+        startContext(ParserRuleContext.NEW_RHS);\n+        STNode openParan = parseOpenParenthesis();\n+        STNode arguments = parseArgsList();\n+        STNode closeParan = parseCloseParenthesis();\n+        endContext();\n+\n+        return STNodeFactory.createParenthesizedArgList(openParan, arguments, closeParan);\n+    }\n+\n+    private STNode parseActionOrExpressionInLhs(STNode lhsExpr) {", "originalCommit": "8ae4c6e850b7ecb589b3f16e8966ac7109266ee3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUxNjk3OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r422516979", "bodyText": "Yes I have checked in by mistake. I'll remove :)", "author": "dulvinw", "createdAt": "2020-05-09T16:30:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ5NTg0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUxOTE2OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r422519168", "bodyText": "fixed with 07c06fd", "author": "dulvinw", "createdAt": "2020-05-09T16:51:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ5NTg0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ5NTk5NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r421495994", "bodyText": "extra newline", "author": "SupunS", "createdAt": "2020-05-07T13:18:21Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3172,6 +3180,127 @@ private STNode parseActionOrExpressionInLhs(SyntaxKind nextTokenKind, STNode lhs\n         return parseExpressionRhs(nextTokenKind, DEFAULT_OP_PRECEDENCE, lhsExpr, false, true);\n     }\n \n+    /**\n+     * <p>\n+     * Parse a new expression.\n+     * </p>\n+     * <code>\n+     *  new-expr := explicit-new-expr | implicit-new-expr\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     *  implicit-new-expr := new [( arg-list )]\n+     * </code>\n+     *\n+     * @return Parsed NewExpression node.\n+     */\n+    private STNode parseNewExpression() {\n+        startContext(ParserRuleContext.NEW_EXPRESSION);\n+        STNode newKeyword = parseNewKeyword();\n+        STNode newExpression = parseNewExpression(newKeyword);\n+        endContext();\n+        return newExpression;\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse `new` keyword.\n+     * </p>\n+     *\n+     * @return Parsed NEW_KEYWORD Token.\n+     */\n+    private STNode parseNewKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.NEW_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.NEW_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    private STNode parseNewExpression(STNode newKeyword) {\n+        STNode token = peek();\n+        return parseNewExpression(token.kind, newKeyword);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an implicit or explicit expression.\n+     * </p>\n+     * @param kind next token kind.\n+     * @param newKeyword parsed node for `new` keyword.\n+     * @return Parsed new-expression node.\n+     */\n+    private STNode parseNewExpression(SyntaxKind kind, STNode newKeyword) {\n+        switch (kind) {\n+            case OPEN_PAREN_TOKEN:\n+                return parseImplicitNewExpression(newKeyword);\n+            case SEMICOLON_TOKEN:\n+                return STNodeFactory.createImplicitNewExpression(newKeyword, STNodeFactory.createEmptyNode());\n+            case IDENTIFIER_TOKEN:\n+            case OBJECT_KEYWORD:\n+                // TODO: Support `stream` keyword once introduced\n+                return parseExplicitNewExpression(newKeyword);\n+            default:\n+                Solution sol = recover(peek(), ParserRuleContext.NEW_EXPRESSION, newKeyword);\n+                return parseNewExpression(sol.recoveredNode.kind, newKeyword);\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an Explicit New expression.\n+     * </p>\n+     * <code>\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     * </code>\n+     *\n+     * @param newKeyword Parsed `new` keyword.\n+     * @return the Parsed Explicit New Expression.\n+     */\n+    private STNode parseExplicitNewExpression(STNode newKeyword) {\n+        startContext(ParserRuleContext.EXPLICIT_NEW_RHS);\n+        STNode typeDescriptor = parseTypeDescriptor();\n+        STNode parenthesizedArgsList = parseParenthesizedArgList();\n+        endContext();\n+\n+        return STNodeFactory.createExplicitNewExpression(newKeyword, typeDescriptor, parenthesizedArgsList);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an <code>implicit-new-expr</code> with arguments.\n+     * </p>\n+     *\n+     * @param newKeyword Parsed `new` keyword.\n+     * @return Parsed implicit-new-expr.\n+     */\n+    private STNode parseImplicitNewExpression(STNode newKeyword) {\n+        STNode implicitNewArgList = parseParenthesizedArgList();\n+", "originalCommit": "8ae4c6e850b7ecb589b3f16e8966ac7109266ee3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUxOTE0OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r422519148", "bodyText": "fixed with 07c06fd", "author": "dulvinw", "createdAt": "2020-05-09T16:51:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ5NTk5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUwMDkyMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r421500920", "bodyText": "Need to add NEW_KEYWORD to the EXPRESSION_START array. Otherwise, if theres an error before the new, expression, then error handler will not know to treat new as a expression.\ni.e: Check something like: T x  new(); where the equal sign is missing before new expression.", "author": "SupunS", "createdAt": "2020-05-07T13:25:15Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -1020,6 +1023,8 @@ protected Result seekMatch(ParserRuleContext currentCtx, int lookahead, int curr\n                 case STRING_KEYWORD:\n                     hasMatch = nextToken.kind == SyntaxKind.XML_KEYWORD;\n                     break;\n+                case NEW_EXPRESSION:", "originalCommit": "8ae4c6e850b7ecb589b3f16e8966ac7109266ee3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUxOTEzMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r422519133", "bodyText": "fixed with 07c06fd", "author": "dulvinw", "createdAt": "2020-05-09T16:51:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUwMDkyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUwMzUxNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r421503515", "bodyText": "You are starting a context for NEW_RHS and EXPLICIT_NEW_RHS here, but its never ended.", "author": "SupunS", "createdAt": "2020-05-07T13:28:53Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -1343,6 +1350,8 @@ protected ParserRuleContext getNextRule(ParserRuleContext currentCtx, int nextLo\n             case KEY_SPECIFIER:\n             case ERROR_TYPE_DESCRIPTOR:\n             case LET_VAR_DECL:\n+            case NEW_RHS:\n+            case EXPLICIT_NEW_RHS:", "originalCommit": "8ae4c6e850b7ecb589b3f16e8966ac7109266ee3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUxOTEyMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r422519121", "bodyText": "fixed with 07c06fd", "author": "dulvinw", "createdAt": "2020-05-09T16:51:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUwMzUxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUwNjIwOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r421506208", "bodyText": "Shall we have a different name instead of NEW_RHS. When we say new-rhs, what comes to mind is all possible alternatives after new keyword. i.e: (open-paren | identifier | expr-rhs)", "author": "SupunS", "createdAt": "2020-05-07T13:32:41Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3172,6 +3180,127 @@ private STNode parseActionOrExpressionInLhs(SyntaxKind nextTokenKind, STNode lhs\n         return parseExpressionRhs(nextTokenKind, DEFAULT_OP_PRECEDENCE, lhsExpr, false, true);\n     }\n \n+    /**\n+     * <p>\n+     * Parse a new expression.\n+     * </p>\n+     * <code>\n+     *  new-expr := explicit-new-expr | implicit-new-expr\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     *  implicit-new-expr := new [( arg-list )]\n+     * </code>\n+     *\n+     * @return Parsed NewExpression node.\n+     */\n+    private STNode parseNewExpression() {\n+        startContext(ParserRuleContext.NEW_EXPRESSION);\n+        STNode newKeyword = parseNewKeyword();\n+        STNode newExpression = parseNewExpression(newKeyword);\n+        endContext();\n+        return newExpression;\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse `new` keyword.\n+     * </p>\n+     *\n+     * @return Parsed NEW_KEYWORD Token.\n+     */\n+    private STNode parseNewKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.NEW_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.NEW_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    private STNode parseNewExpression(STNode newKeyword) {\n+        STNode token = peek();\n+        return parseNewExpression(token.kind, newKeyword);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an implicit or explicit expression.\n+     * </p>\n+     * @param kind next token kind.\n+     * @param newKeyword parsed node for `new` keyword.\n+     * @return Parsed new-expression node.\n+     */\n+    private STNode parseNewExpression(SyntaxKind kind, STNode newKeyword) {\n+        switch (kind) {\n+            case OPEN_PAREN_TOKEN:\n+                return parseImplicitNewExpression(newKeyword);\n+            case SEMICOLON_TOKEN:\n+                return STNodeFactory.createImplicitNewExpression(newKeyword, STNodeFactory.createEmptyNode());\n+            case IDENTIFIER_TOKEN:\n+            case OBJECT_KEYWORD:\n+                // TODO: Support `stream` keyword once introduced\n+                return parseExplicitNewExpression(newKeyword);\n+            default:\n+                Solution sol = recover(peek(), ParserRuleContext.NEW_EXPRESSION, newKeyword);\n+                return parseNewExpression(sol.recoveredNode.kind, newKeyword);\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an Explicit New expression.\n+     * </p>\n+     * <code>\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     * </code>\n+     *\n+     * @param newKeyword Parsed `new` keyword.\n+     * @return the Parsed Explicit New Expression.\n+     */\n+    private STNode parseExplicitNewExpression(STNode newKeyword) {\n+        startContext(ParserRuleContext.EXPLICIT_NEW_RHS);\n+        STNode typeDescriptor = parseTypeDescriptor();\n+        STNode parenthesizedArgsList = parseParenthesizedArgList();\n+        endContext();\n+\n+        return STNodeFactory.createExplicitNewExpression(newKeyword, typeDescriptor, parenthesizedArgsList);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an <code>implicit-new-expr</code> with arguments.\n+     * </p>\n+     *\n+     * @param newKeyword Parsed `new` keyword.\n+     * @return Parsed implicit-new-expr.\n+     */\n+    private STNode parseImplicitNewExpression(STNode newKeyword) {\n+        STNode implicitNewArgList = parseParenthesizedArgList();\n+\n+        return STNodeFactory.createImplicitNewExpression(newKeyword, implicitNewArgList);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse the parenthesized argument list for a <code>new-expr</code>.\n+     * </p>\n+     *\n+     * @return Parsed parenthesized rhs of <code>new-expr</code>.\n+     */\n+    private STNode parseParenthesizedArgList() {\n+        startContext(ParserRuleContext.NEW_RHS);", "originalCommit": "8ae4c6e850b7ecb589b3f16e8966ac7109266ee3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUxNjg1Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r422516853", "bodyText": "I'll use new-expr-args? @SupunS", "author": "dulvinw", "createdAt": "2020-05-09T16:29:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUwNjIwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUxOTMzOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r422519338", "bodyText": "fixed with 07c06fd using new-expr-args. Let me know if I should use something else", "author": "dulvinw", "createdAt": "2020-05-09T16:53:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUwNjIwOA=="}], "type": "inlineReview"}, {"oid": "07c06fd6383897a3e52cca4bea15067bc9d33505", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/07c06fd6383897a3e52cca4bea15067bc9d33505", "message": "Fix Review Suggestions", "committedDate": "2020-05-09T16:50:23Z", "type": "commit"}, {"oid": "e5fd17021244dafa29b6bc66c1fde9792106b9e8", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e5fd17021244dafa29b6bc66c1fde9792106b9e8", "message": "Merge branch 'incremental-parser' of https://github.com/ballerina-platform/ballerina-lang into new-expression-22998-new\n\n# Conflicts:\n#\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "committedDate": "2020-05-09T16:55:49Z", "type": "commit"}, {"oid": "1a29b54a855c8e9ca7ff445fcb71ce32ae9ed91c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1a29b54a855c8e9ca7ff445fcb71ce32ae9ed91c", "message": "Add checkstyle fixes", "committedDate": "2020-05-10T12:40:59Z", "type": "commit"}, {"oid": "7ab53170f6245d10381885dcd6f178f10225ff73", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7ab53170f6245d10381885dcd6f178f10225ff73", "message": "Add missing files", "committedDate": "2020-05-10T18:27:02Z", "type": "commit"}, {"oid": "7ab53170f6245d10381885dcd6f178f10225ff73", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7ab53170f6245d10381885dcd6f178f10225ff73", "message": "Add missing files", "committedDate": "2020-05-10T18:27:02Z", "type": "forcePushed"}, {"oid": "2c7aaee5e2f5a88c95eb004ad8905463af37e771", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2c7aaee5e2f5a88c95eb004ad8905463af37e771", "message": "Add node transformer and tests.", "committedDate": "2020-05-12T10:06:53Z", "type": "commit"}, {"oid": "58934e8bdc63ac5e2e1794f0b5c02f478b690b16", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/58934e8bdc63ac5e2e1794f0b5c02f478b690b16", "message": "Fix test", "committedDate": "2020-05-12T10:13:59Z", "type": "commit"}, {"oid": "44aa7e514ec19518c839fe28e2fecc4a25150bc3", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/44aa7e514ec19518c839fe28e2fecc4a25150bc3", "message": "Merge branch 'incremental-parser' of https://github.com/ballerina-platform/ballerina-lang into new-expression-22998-new", "committedDate": "2020-05-12T10:22:27Z", "type": "commit"}, {"oid": "b1ad40b44afb4c5792127e96ed5ef1706147ab95", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b1ad40b44afb4c5792127e96ed5ef1706147ab95", "message": "Fix Tests", "committedDate": "2020-05-12T11:47:59Z", "type": "commit"}, {"oid": "5e8aad69b94e8bc3dd3b15a8d862d785bd3b86b6", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5e8aad69b94e8bc3dd3b15a8d862d785bd3b86b6", "message": "Merge branch 'incremental-parser' of https://github.com/ballerina-platform/ballerina-lang into new-expression-22998-new", "committedDate": "2020-05-12T11:49:51Z", "type": "commit"}, {"oid": "fbd75bf691e8e0b2af223fb4a004cbdb38232f7f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fbd75bf691e8e0b2af223fb4a004cbdb38232f7f", "message": "Fix Checkstyle", "committedDate": "2020-05-12T12:20:20Z", "type": "commit"}, {"oid": "7fefff93efc037821b671f5ac9b72118bdcfcfce", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7fefff93efc037821b671f5ac9b72118bdcfcfce", "message": "Merge branch 'incremental-parser' of https://github.com/ballerina-platform/ballerina-lang into new-expression-22998-new", "committedDate": "2020-05-12T12:22:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY4NzQ5Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r423687497", "bodyText": "Lets create an issue for this", "author": "SupunS", "createdAt": "2020-05-12T12:19:31Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3481,6 +3489,116 @@ private STNode parseActionOrExpressionInLhs(SyntaxKind nextTokenKind, STNode lhs\n         return parseExpressionRhs(nextTokenKind, DEFAULT_OP_PRECEDENCE, lhsExpr, false, true);\n     }\n \n+    /**\n+     * <p>\n+     * Parse a new expression.\n+     * </p>\n+     * <code>\n+     *  new-expr := explicit-new-expr | implicit-new-expr\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     *  implicit-new-expr := new [( arg-list )]\n+     * </code>\n+     *\n+     * @return Parsed NewExpression node.\n+     */\n+    private STNode parseNewExpression() {\n+        STNode newKeyword = parseNewKeyword();\n+        return parseNewKeywordRhs(newKeyword);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse `new` keyword.\n+     * </p>\n+     *\n+     * @return Parsed NEW_KEYWORD Token.\n+     */\n+    private STNode parseNewKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.NEW_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.NEW_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    private STNode parseNewKeywordRhs(STNode newKeyword) {\n+        STNode token = peek();\n+        return parseNewKeywordRhs(token.kind, newKeyword);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an implicit or explicit expression.\n+     * </p>\n+     * @param kind next token kind.\n+     * @param newKeyword parsed node for `new` keyword.\n+     * @return Parsed new-expression node.\n+     */\n+    private STNode parseNewKeywordRhs(SyntaxKind kind, STNode newKeyword) {\n+        switch (kind) {\n+            case OPEN_PAREN_TOKEN:\n+                return parseImplicitNewRhs(newKeyword);\n+            case SEMICOLON_TOKEN:\n+                break;\n+            case IDENTIFIER_TOKEN:\n+            case OBJECT_KEYWORD:\n+                // TODO: Support `stream` keyword once introduced", "originalCommit": "5e8aad69b94e8bc3dd3b15a8d862d785bd3b86b6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY4ODUzMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r423688533", "bodyText": "Shall we rename EXPLICIT_NEW_RHS to TYPE_DESC_IN_NEW_EXPR, to be aligned with the convention we used in other places?", "author": "SupunS", "createdAt": "2020-05-12T12:21:21Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3481,6 +3489,116 @@ private STNode parseActionOrExpressionInLhs(SyntaxKind nextTokenKind, STNode lhs\n         return parseExpressionRhs(nextTokenKind, DEFAULT_OP_PRECEDENCE, lhsExpr, false, true);\n     }\n \n+    /**\n+     * <p>\n+     * Parse a new expression.\n+     * </p>\n+     * <code>\n+     *  new-expr := explicit-new-expr | implicit-new-expr\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     *  implicit-new-expr := new [( arg-list )]\n+     * </code>\n+     *\n+     * @return Parsed NewExpression node.\n+     */\n+    private STNode parseNewExpression() {\n+        STNode newKeyword = parseNewKeyword();\n+        return parseNewKeywordRhs(newKeyword);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse `new` keyword.\n+     * </p>\n+     *\n+     * @return Parsed NEW_KEYWORD Token.\n+     */\n+    private STNode parseNewKeyword() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.NEW_KEYWORD) {\n+            return consume();\n+        } else {\n+            Solution sol = recover(token, ParserRuleContext.NEW_KEYWORD);\n+            return sol.recoveredNode;\n+        }\n+    }\n+\n+    private STNode parseNewKeywordRhs(STNode newKeyword) {\n+        STNode token = peek();\n+        return parseNewKeywordRhs(token.kind, newKeyword);\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an implicit or explicit expression.\n+     * </p>\n+     * @param kind next token kind.\n+     * @param newKeyword parsed node for `new` keyword.\n+     * @return Parsed new-expression node.\n+     */\n+    private STNode parseNewKeywordRhs(SyntaxKind kind, STNode newKeyword) {\n+        switch (kind) {\n+            case OPEN_PAREN_TOKEN:\n+                return parseImplicitNewRhs(newKeyword);\n+            case SEMICOLON_TOKEN:\n+                break;\n+            case IDENTIFIER_TOKEN:\n+            case OBJECT_KEYWORD:\n+                // TODO: Support `stream` keyword once introduced\n+                return parseExplicitNewRhs(newKeyword);\n+            default:\n+                break;\n+        }\n+\n+        return STNodeFactory.createImplicitNewExpression(newKeyword, STNodeFactory.createEmptyNode());\n+    }\n+\n+    /**\n+     * <p>\n+     * Parse an Explicit New expression.\n+     * </p>\n+     * <code>\n+     *  explicit-new-expr := new type-descriptor ( arg-list )\n+     * </code>\n+     *\n+     * @param newKeyword Parsed `new` keyword.\n+     * @return the Parsed Explicit New Expression.\n+     */\n+    private STNode parseExplicitNewRhs(STNode newKeyword) {\n+        STNode typeDescriptor = parseTypeDescriptor(ParserRuleContext.EXPLICIT_NEW_RHS);", "originalCommit": "5e8aad69b94e8bc3dd3b15a8d862d785bd3b86b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzgzODEyOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r423838129", "bodyText": "fixed in 401f175", "author": "dulvinw", "createdAt": "2020-05-12T15:43:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY4ODUzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY5MTI5OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r423691298", "bodyText": "I don't think we need it here.\nThis should be added to all the places where other TYPE_DESC_IN_** contexts are added.", "author": "SupunS", "createdAt": "2020-05-12T12:25:57Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -1920,6 +1933,7 @@ protected ParserRuleContext getNextRule(ParserRuleContext currentCtx, int nextLo\n             case ARG_LIST_START:\n                 return ParserRuleContext.ARG_LIST;\n             case ARG_LIST_END:\n+            case EXPLICIT_NEW_RHS:", "originalCommit": "7fefff93efc037821b671f5ac9b72118bdcfcfce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzgzODA1Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r423838057", "bodyText": "fixed in 401f175", "author": "dulvinw", "createdAt": "2020-05-12T15:43:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY5MTI5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY5MTY1MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r423691650", "bodyText": "Same as above", "author": "SupunS", "createdAt": "2020-05-12T12:26:33Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -2390,6 +2404,8 @@ private ParserRuleContext getNextRuleForCloseBrace(int nextLookahead) {\n             case INTERPOLATION:\n                 endContext();\n                 return ParserRuleContext.TEMPLATE_MEMBER;\n+            case EXPLICIT_NEW_RHS:", "originalCommit": "7fefff93efc037821b671f5ac9b72118bdcfcfce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzgzODAwNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r423838005", "bodyText": "fixed in 401f175", "author": "dulvinw", "createdAt": "2020-05-12T15:43:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY5MTY1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY5MjAzOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r423692038", "bodyText": "better to rename NEW_EXPR  --> NEW_KEYWORD_RHS", "author": "SupunS", "createdAt": "2020-05-12T12:27:14Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -323,6 +323,10 @@\n             { ParserRuleContext.END_OF_TYPE_DESC, ParserRuleContext.ARRAY_TYPE_DESCRIPTOR,\n                     ParserRuleContext.OPTIONAL_TYPE_DESCRIPTOR, ParserRuleContext.PIPE };\n \n+    private static final ParserRuleContext[] NEW_EXPR =", "originalCommit": "7fefff93efc037821b671f5ac9b72118bdcfcfce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzgzNzk0MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r423837940", "bodyText": "fixed in 401f175", "author": "dulvinw", "createdAt": "2020-05-12T15:43:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY5MjAzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY5NDE2MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r423694161", "bodyText": "This Should be ARG_LIST_START. Its also matches against the ( , but it handles the arg-contexts", "author": "SupunS", "createdAt": "2020-05-12T12:30:39Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -2390,6 +2404,8 @@ private ParserRuleContext getNextRuleForCloseBrace(int nextLookahead) {\n             case INTERPOLATION:\n                 endContext();\n                 return ParserRuleContext.TEMPLATE_MEMBER;\n+            case EXPLICIT_NEW_RHS:\n+                return ParserRuleContext.OPEN_PARENTHESIS;", "originalCommit": "7fefff93efc037821b671f5ac9b72118bdcfcfce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzgzNzg0NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23146#discussion_r423837845", "bodyText": "fixed in 401f175", "author": "dulvinw", "createdAt": "2020-05-12T15:43:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY5NDE2MQ=="}], "type": "inlineReview"}, {"oid": "99ceaabf2695c475fe63b7f29f2d2815a1464159", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/99ceaabf2695c475fe63b7f29f2d2815a1464159", "message": "Merge branch 'incremental-parser' of https://github.com/ballerina-platform/ballerina-lang into new-expression-22998-new", "committedDate": "2020-05-12T15:02:48Z", "type": "commit"}, {"oid": "052e7ee9b5acaa6900bffd7bb15720b0cb367abd", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/052e7ee9b5acaa6900bffd7bb15720b0cb367abd", "message": "Fix review suggestions", "committedDate": "2020-05-12T15:54:50Z", "type": "commit"}, {"oid": "052e7ee9b5acaa6900bffd7bb15720b0cb367abd", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/052e7ee9b5acaa6900bffd7bb15720b0cb367abd", "message": "Fix review suggestions", "committedDate": "2020-05-12T15:54:50Z", "type": "forcePushed"}]}