{"pr_number": 24515, "pr_title": "Add BFM support in new parser", "pr_createdAt": "2020-06-30T15:22:03Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/24515", "timeline": [{"oid": "3d2a396f3e29ac17d7f3b76f1e4645e6c3a39b8d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3d2a396f3e29ac17d7f3b76f1e4645e6c3a39b8d", "message": "Add first stage parsing for ballerina flavored markdown", "committedDate": "2020-06-27T18:12:11Z", "type": "commit"}, {"oid": "aad57c48bfa86ed0aab1bced6dac05b931045399", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/aad57c48bfa86ed0aab1bced6dac05b931045399", "message": "Revamp first stage parsing for ballerina flavored markdown", "committedDate": "2020-06-29T09:31:22Z", "type": "commit"}, {"oid": "b9d700233c402b3a337ea7ff63bab05811e3b4aa", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b9d700233c402b3a337ea7ff63bab05811e3b4aa", "message": "Modify syntax tree to support BFM", "committedDate": "2020-06-29T10:55:57Z", "type": "commit"}, {"oid": "171570874d2bfa080f4d200bee729b46310d91c9", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/171570874d2bfa080f4d200bee729b46310d91c9", "message": "Add second stage parsing for BFM", "committedDate": "2020-06-30T05:28:00Z", "type": "commit"}, {"oid": "af6412851d9728b93e378a03d7142c73faee3384", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/af6412851d9728b93e378a03d7142c73faee3384", "message": "Modify syntax tree to support code references in BFM", "committedDate": "2020-06-30T07:37:32Z", "type": "commit"}, {"oid": "51e4a2f7893a481dc564465114f0cc302952624a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/51e4a2f7893a481dc564465114f0cc302952624a", "message": "Add code reference support in BFM", "committedDate": "2020-06-30T07:38:56Z", "type": "commit"}, {"oid": "b1c2e3f2e9160d2d577347de251d1c278c672531", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b1c2e3f2e9160d2d577347de251d1c278c672531", "message": "Add deprecation support in BFM", "committedDate": "2020-06-30T08:49:15Z", "type": "commit"}, {"oid": "a69329b74f22954d8db5f04a24aa562229e745aa", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a69329b74f22954d8db5f04a24aa562229e745aa", "message": "Add test cases", "committedDate": "2020-06-30T14:53:12Z", "type": "commit"}, {"oid": "875d60ed66553e95a88934a5b2a3de625b5f4431", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/875d60ed66553e95a88934a5b2a3de625b5f4431", "message": "Modify ST", "committedDate": "2020-07-01T07:24:47Z", "type": "commit"}, {"oid": "1eaf6ef3cb60ef0f4000ad7062a7ba513c095068", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1eaf6ef3cb60ef0f4000ad7062a7ba513c095068", "message": "Change BFM parsing", "committedDate": "2020-07-01T13:29:30Z", "type": "commit"}, {"oid": "45220b9485503ddd743ae716736a6592ae39d630", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/45220b9485503ddd743ae716736a6592ae39d630", "message": "Refactor code and add few test cases", "committedDate": "2020-07-02T13:21:47Z", "type": "commit"}, {"oid": "0576bce67ff40211aff9b2198b76beaf24ce039f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0576bce67ff40211aff9b2198b76beaf24ce039f", "message": "Fix ST issue", "committedDate": "2020-07-02T18:35:38Z", "type": "commit"}, {"oid": "53f17a327b60fae5c0c20bf3faff4265eacdd485", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/53f17a327b60fae5c0c20bf3faff4265eacdd485", "message": "Change ST for BFM", "committedDate": "2020-07-03T11:13:17Z", "type": "commit"}, {"oid": "5148becc64d9f696888a8ad1ef73054803f64327", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5148becc64d9f696888a8ad1ef73054803f64327", "message": "Change BFM parsing and update test cases accordingly", "committedDate": "2020-07-03T12:39:47Z", "type": "commit"}, {"oid": "e7ce07dd53b113c16396ca32a77c4362113ed45a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e7ce07dd53b113c16396ca32a77c4362113ed45a", "message": "Change node transformer logic for documentationStringNode and fix lexer bug", "committedDate": "2020-07-03T15:54:02Z", "type": "commit"}, {"oid": "f6ff682a4e9e7ca9f4acc3c973f4c72fa30afd2c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f6ff682a4e9e7ca9f4acc3c973f4c72fa30afd2c", "message": "Improve inline double and triple backtick documentation support and add test cases", "committedDate": "2020-07-03T18:51:50Z", "type": "commit"}, {"oid": "f20b7271f32e0d721d6d50f09a737de3c29f9008", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f20b7271f32e0d721d6d50f09a737de3c29f9008", "message": "Revamp erroneous documentation parsing", "committedDate": "2020-07-04T17:01:07Z", "type": "commit"}, {"oid": "5aa465bed7433a8f136c0c27093480968810bf03", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5aa465bed7433a8f136c0c27093480968810bf03", "message": "Add erroneous documentation test cases", "committedDate": "2020-07-04T17:02:43Z", "type": "commit"}, {"oid": "f60717c0bf82daeb76dc997442bffe4bd1ac1c36", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f60717c0bf82daeb76dc997442bffe4bd1ac1c36", "message": "Refactor code", "committedDate": "2020-07-04T18:30:13Z", "type": "commit"}, {"oid": "a480833551874fe49d368834b9e896ef136d5cb5", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a480833551874fe49d368834b9e896ef136d5cb5", "message": "Extend node transformer logic to support all kind of documentation lines", "committedDate": "2020-07-04T18:52:45Z", "type": "commit"}, {"oid": "7870b4863033e7973ecee7095e1990545c751f41", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7870b4863033e7973ecee7095e1990545c751f41", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into doc-support\n\n\u0001 Conflicts:\n\u0001\tcompiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/BLangNodeTransformer.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/tree/STNodeFactory.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/tree/STNodeTransformer.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/tree/STNodeVisitor.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/tree/STTreeModifier.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/NodeFactory.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/NodeTransformer.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/NodeVisitor.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/TreeModifier.java\n\u0001\tcompiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "committedDate": "2020-07-04T19:27:50Z", "type": "commit"}, {"oid": "9775ea63b12965f7d9a643f26779760ccb6441de", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9775ea63b12965f7d9a643f26779760ccb6441de", "message": "Regenerate tree after merging", "committedDate": "2020-07-04T19:51:14Z", "type": "commit"}, {"oid": "fc2ae7cdfa7390040663c73f0ce475e7fd2751a1", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fc2ae7cdfa7390040663c73f0ce475e7fd2751a1", "message": "Fix node transformer checkstyle", "committedDate": "2020-07-04T20:07:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk2NzUwMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24515#discussion_r449967500", "bodyText": "Not related to your changes..\nshall we replace the for-loop inside stringToRefType with a switch case?", "author": "SupunS", "createdAt": "2020-07-06T03:34:52Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/BLangNodeTransformer.java", "diffHunk": "@@ -4211,61 +4197,30 @@ private BLangMarkdownDocumentation createMarkdownDocumentationAttachment(Optiona\n         return doc;\n     }\n \n-    private String trimLeftAtMostOne(String text) {\n-        int countToStrip = 0;\n-        if (!text.isEmpty() && Character.isWhitespace(text.charAt(0))) {\n-            countToStrip = 1;\n-        }\n-        return text.substring(countToStrip);\n-    }\n-\n-    private boolean addReferences(String text, LinkedList<BLangMarkdownReferenceDocumentation> references,\n-                                  boolean startsInsideQuotes) {\n-//              _\n-//             / \\ non-tick (in single quote)\n-//             v /\n-//            --4<----.                 _____\n-//      tick /         \\non-tick       /     \\ non-tick\n-//          v     tick  \\       tick  v tick  \\        tick\n-//     .-> 0-------------->1--------->2--------->3-----------------.\n-//    /   ^ \\                        ^ \\                           |\n-//    |   | |                        | |                           |\n-//    |   \\_/non-tick (un-quoted)    \\_/non-tick (in double quote) |\n-//    \\____________________________________________________________/\n-//\n-// note this state machine is only design to distinguish single tick and double tick quoted string\n-// for simplicity are assuming three tick case is just a subset of double tick case\n-\n-        int length = text.length();\n-        int state = startsInsideQuotes ? 2 : 0;\n-        int lastWhiteSpace = 0;\n-        int secondToLastWhiteSpace = 0;\n-\n-        //                0  1  2  3  4\n-        int[][] table = {{0, 4, 2, 2, 4},  // non-tick\n-                         {1, 2, 3, 0, 0}}; // tick\n-\n-        for (int i = 0; i < length; i++) {\n-            char c = text.charAt(i);\n-            int isTick = c == '`' ? 1 : 0;\n-            int newState = table[isTick][state];\n-\n-            if (newState == 0 && c == ' ') {\n-                secondToLastWhiteSpace = lastWhiteSpace;\n-                lastWhiteSpace = i;\n-            }\n+    private String addReferencesAndReturnDocumentationText(LinkedList<BLangMarkdownReferenceDocumentation> references,\n+                                                           NodeList<Node> docElements) {\n+        StringBuilder docText = new StringBuilder();\n+        for (Node element : docElements) {\n+            docText.append(element.toString());\n \n-            if (state == 4 && newState == 0) { // we are coming out of a single quoted string\n-                BLangMarkdownReferenceDocumentation ref = new BLangMarkdownReferenceDocumentation();\n-                ref.type = DocumentationReferenceType.BACKTICK_CONTENT;\n-                if (secondToLastWhiteSpace + 1 < lastWhiteSpace) {\n-                    ref.type = stringToRefType(text.substring(secondToLastWhiteSpace + 1, lastWhiteSpace));\n-                }\n-                references.add(ref);\n+            // Add references if available\n+            if (element.kind() == SyntaxKind.DOCUMENTATION_REFERENCE) {\n+                BLangMarkdownReferenceDocumentation bLangRefDoc = new BLangMarkdownReferenceDocumentation();\n+\n+                bLangRefDoc.type = DocumentationReferenceType.BACKTICK_CONTENT;\n+                ((DocumentationReferenceNode) element).referenceType().ifPresent(\n+                        refType -> bLangRefDoc.type = stringToRefType(refType.text())\n+                );\n+                references.add(bLangRefDoc);\n             }\n-            state = newState;\n         }\n-        return state == 2 || state == 3;\n+\n+        String text = docText.toString();\n+        if (text.endsWith(\"\\n\")) {\n+            text = text.substring(0, text.length() - 1);\n+        }\n+\n+        return text;\n     }\n \n     private DocumentationReferenceType stringToRefType(String refTypeName) {", "originalCommit": "fc2ae7cdfa7390040663c73f0ce475e7fd2751a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk3MDk3OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24515#discussion_r449970979", "bodyText": "how about something like processDocumentationCodeContent to be consistent with the naming conventions?", "author": "SupunS", "createdAt": "2020-07-06T03:53:45Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "diffHunk": "@@ -1550,4 +1561,271 @@ private STToken readTokenInBracedContentInInterpolation() {\n \n         return readToken();\n     }\n+\n+    /*\n+     * ------------------------------------------------------------------------------------------------------------\n+     * DOCUMENTATION Mode\n+     * ------------------------------------------------------------------------------------------------------------\n+     */\n+\n+    private STToken readDocumentationToken() {\n+        reader.mark();\n+        int nextChar = peek();\n+        switch (nextChar) {\n+            case LexerTerminals.PLUS:\n+                reader.advance();\n+                switchMode(ParserMode.DOCUMENTATION_PARAMETER);\n+                return getDocumentationSyntaxToken(SyntaxKind.PLUS_TOKEN);\n+            case LexerTerminals.BACKTICK:\n+                if (reader.peek(1) != LexerTerminals.BACKTICK) {\n+                    reader.advance();\n+                    switchMode(ParserMode.DOCUMENTATION_BACKTICK_CONTENT);\n+                    return getSyntaxToken(SyntaxKind.BACKTICK_TOKEN);\n+                }\n+                // Fall through\n+            default:\n+                while (!reader.isEOF()) {\n+                    switch (nextChar) {\n+                        case LexerTerminals.NEWLINE:\n+                        case LexerTerminals.CARRIAGE_RETURN:\n+                            endMode();\n+                            break;\n+                        case LexerTerminals.BACKTICK:\n+                            if (reader.peek(1) != LexerTerminals.BACKTICK) {\n+                                break;\n+                            } else if (reader.peek(2) != LexerTerminals.BACKTICK) {\n+                                // Double backtick detected\n+                                reader.advance(2);\n+                                advanceReaderForBacktickContent(false);\n+                            } else {\n+                                // Triple backtick detected\n+                                reader.advance(3);\n+                                advanceReaderForBacktickContent(true);\n+                            }\n+                            nextChar = peek();\n+                            continue;\n+                        default:\n+                            if (isIdentifierInitialChar(nextChar)) {\n+                                // Look ahead and see if next characters belong to a documentation reference.\n+                                // If they do, switch the mode immediately and return.\n+                                // Otherwise advance the reader for checked characters.\n+                                int readerAdvanceCount = lookAheadForDocumentationReference(nextChar);\n+                                if (readerAdvanceCount == 0) {\n+                                    switchMode(ParserMode.DOCUMENTATION_REFERENCE_TYPE);\n+                                    if (getLexeme().equals(\"\")) {\n+                                        // Reaching here means,\n+                                        // first immediate character also belong to a documentation reference.\n+                                        return readDocumentationReferenceTypeToken();\n+                                    }\n+                                    break;\n+                                }\n+                                reader.advance(readerAdvanceCount);\n+                            } else {\n+                                reader.advance();\n+                            }\n+                            nextChar = peek();\n+                            continue;\n+                    }\n+                    break;\n+                }\n+        }\n+\n+        return getTemplateString(SyntaxKind.DOCUMENTATION_DESCRIPTION);\n+    }\n+\n+    private void advanceReaderForBacktickContent(boolean isTripleBacktick) {", "originalCommit": "fc2ae7cdfa7390040663c73f0ce475e7fd2751a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk3NDY4Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24515#discussion_r449974687", "bodyText": "should we check for TAB also?", "author": "SupunS", "createdAt": "2020-07-06T04:13:07Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "diffHunk": "@@ -1550,4 +1561,271 @@ private STToken readTokenInBracedContentInInterpolation() {\n \n         return readToken();\n     }\n+\n+    /*\n+     * ------------------------------------------------------------------------------------------------------------\n+     * DOCUMENTATION Mode\n+     * ------------------------------------------------------------------------------------------------------------\n+     */\n+\n+    private STToken readDocumentationToken() {\n+        reader.mark();\n+        int nextChar = peek();\n+        switch (nextChar) {\n+            case LexerTerminals.PLUS:\n+                reader.advance();\n+                switchMode(ParserMode.DOCUMENTATION_PARAMETER);\n+                return getDocumentationSyntaxToken(SyntaxKind.PLUS_TOKEN);\n+            case LexerTerminals.BACKTICK:\n+                if (reader.peek(1) != LexerTerminals.BACKTICK) {\n+                    reader.advance();\n+                    switchMode(ParserMode.DOCUMENTATION_BACKTICK_CONTENT);\n+                    return getSyntaxToken(SyntaxKind.BACKTICK_TOKEN);\n+                }\n+                // Fall through\n+            default:\n+                while (!reader.isEOF()) {\n+                    switch (nextChar) {\n+                        case LexerTerminals.NEWLINE:\n+                        case LexerTerminals.CARRIAGE_RETURN:\n+                            endMode();\n+                            break;\n+                        case LexerTerminals.BACKTICK:\n+                            if (reader.peek(1) != LexerTerminals.BACKTICK) {\n+                                break;\n+                            } else if (reader.peek(2) != LexerTerminals.BACKTICK) {\n+                                // Double backtick detected\n+                                reader.advance(2);\n+                                advanceReaderForBacktickContent(false);\n+                            } else {\n+                                // Triple backtick detected\n+                                reader.advance(3);\n+                                advanceReaderForBacktickContent(true);\n+                            }\n+                            nextChar = peek();\n+                            continue;\n+                        default:\n+                            if (isIdentifierInitialChar(nextChar)) {\n+                                // Look ahead and see if next characters belong to a documentation reference.\n+                                // If they do, switch the mode immediately and return.\n+                                // Otherwise advance the reader for checked characters.\n+                                int readerAdvanceCount = lookAheadForDocumentationReference(nextChar);\n+                                if (readerAdvanceCount == 0) {\n+                                    switchMode(ParserMode.DOCUMENTATION_REFERENCE_TYPE);\n+                                    if (getLexeme().equals(\"\")) {\n+                                        // Reaching here means,\n+                                        // first immediate character also belong to a documentation reference.\n+                                        return readDocumentationReferenceTypeToken();\n+                                    }\n+                                    break;\n+                                }\n+                                reader.advance(readerAdvanceCount);\n+                            } else {\n+                                reader.advance();\n+                            }\n+                            nextChar = peek();\n+                            continue;\n+                    }\n+                    break;\n+                }\n+        }\n+\n+        return getTemplateString(SyntaxKind.DOCUMENTATION_DESCRIPTION);\n+    }\n+\n+    private void advanceReaderForBacktickContent(boolean isTripleBacktick) {\n+        int nextChar = peek();\n+        while (!reader.isEOF()) {\n+            switch (nextChar) {\n+                case LexerTerminals.BACKTICK:\n+                    // Look for a double backtick or a triple backtick\n+                    // depend on the `isTripleBacktick` boolean value.\n+                    if (isTripleBacktick) {\n+                        reader.advance();\n+                        if (peek() != LexerTerminals.BACKTICK) {\n+                            nextChar = peek();\n+                            continue;\n+                        }\n+                    }\n+                    reader.advance();\n+                    if (peek() != LexerTerminals.BACKTICK) {\n+                        nextChar = peek();\n+                        continue;\n+                    }\n+                    reader.advance();\n+                    if (peek() != LexerTerminals.BACKTICK) {\n+                        return;\n+                    }\n+                    nextChar = peek();\n+                    continue;\n+                case LexerTerminals.NEWLINE:\n+                    // Reaching here means ending backticks were not found within the same line.\n+                    // Therefore, look ahead see if next line is a documentation line and if so,\n+                    // look for a ending in that line. Otherwise terminate backtick content at the new line.\n+                    int lookAheadCount = 1;\n+                    int lookAheadChar = reader.peek(lookAheadCount);\n+                    while (lookAheadChar == LexerTerminals.SPACE || lookAheadChar == LexerTerminals.TAB) {\n+                        lookAheadCount++;\n+                        lookAheadChar = reader.peek(lookAheadCount);\n+                    }\n+                    if (lookAheadChar != LexerTerminals.HASH) {\n+                        return;\n+                    }\n+                    reader.advance(lookAheadCount);\n+                    nextChar = peek();\n+                    continue;\n+                default:\n+                    reader.advance();\n+                    nextChar = peek();\n+            }\n+        }\n+    }\n+\n+    private int lookAheadForDocumentationReference(int nextChar) {\n+        int lookAheadChar = nextChar;\n+        int lookAheadCount = 0;\n+        String identifier = \"\";\n+\n+        while (isIdentifierInitialChar(lookAheadChar)) {\n+            identifier = identifier.concat(String.valueOf((char) lookAheadChar));\n+            lookAheadCount++;\n+            lookAheadChar = reader.peek(lookAheadCount);\n+        }\n+\n+        switch (identifier) {\n+            case LexerTerminals.TYPE:\n+            case LexerTerminals.SERVICE:\n+            case LexerTerminals.VARIABLE:\n+            case LexerTerminals.VAR:\n+            case LexerTerminals.ANNOTATION:\n+            case LexerTerminals.MODULE:\n+            case LexerTerminals.FUNCTION:\n+            case LexerTerminals.PARAMETER:\n+                // Look ahead for a single backtick.\n+                // There could be spaces in between.\n+                while (true) {\n+                    switch (lookAheadChar) {\n+                        case LexerTerminals.SPACE:", "originalCommit": "fc2ae7cdfa7390040663c73f0ce475e7fd2751a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk3NTg0OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24515#discussion_r449975848", "bodyText": "Is it possible to merge this section with the lookAheadForDocumentationReference method?\ni.e:  lookAheadForDocumentationReference will process all the tokens and returns the token, instead of the lookahead count", "author": "SupunS", "createdAt": "2020-07-06T04:19:20Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "diffHunk": "@@ -1550,4 +1561,271 @@ private STToken readTokenInBracedContentInInterpolation() {\n \n         return readToken();\n     }\n+\n+    /*\n+     * ------------------------------------------------------------------------------------------------------------\n+     * DOCUMENTATION Mode\n+     * ------------------------------------------------------------------------------------------------------------\n+     */\n+\n+    private STToken readDocumentationToken() {\n+        reader.mark();\n+        int nextChar = peek();\n+        switch (nextChar) {\n+            case LexerTerminals.PLUS:\n+                reader.advance();\n+                switchMode(ParserMode.DOCUMENTATION_PARAMETER);\n+                return getDocumentationSyntaxToken(SyntaxKind.PLUS_TOKEN);\n+            case LexerTerminals.BACKTICK:\n+                if (reader.peek(1) != LexerTerminals.BACKTICK) {\n+                    reader.advance();\n+                    switchMode(ParserMode.DOCUMENTATION_BACKTICK_CONTENT);\n+                    return getSyntaxToken(SyntaxKind.BACKTICK_TOKEN);\n+                }\n+                // Fall through\n+            default:\n+                while (!reader.isEOF()) {\n+                    switch (nextChar) {\n+                        case LexerTerminals.NEWLINE:\n+                        case LexerTerminals.CARRIAGE_RETURN:\n+                            endMode();\n+                            break;\n+                        case LexerTerminals.BACKTICK:\n+                            if (reader.peek(1) != LexerTerminals.BACKTICK) {\n+                                break;\n+                            } else if (reader.peek(2) != LexerTerminals.BACKTICK) {\n+                                // Double backtick detected\n+                                reader.advance(2);\n+                                advanceReaderForBacktickContent(false);\n+                            } else {\n+                                // Triple backtick detected\n+                                reader.advance(3);\n+                                advanceReaderForBacktickContent(true);\n+                            }\n+                            nextChar = peek();\n+                            continue;\n+                        default:\n+                            if (isIdentifierInitialChar(nextChar)) {\n+                                // Look ahead and see if next characters belong to a documentation reference.\n+                                // If they do, switch the mode immediately and return.\n+                                // Otherwise advance the reader for checked characters.\n+                                int readerAdvanceCount = lookAheadForDocumentationReference(nextChar);\n+                                if (readerAdvanceCount == 0) {\n+                                    switchMode(ParserMode.DOCUMENTATION_REFERENCE_TYPE);\n+                                    if (getLexeme().equals(\"\")) {\n+                                        // Reaching here means,\n+                                        // first immediate character also belong to a documentation reference.\n+                                        return readDocumentationReferenceTypeToken();\n+                                    }\n+                                    break;\n+                                }\n+                                reader.advance(readerAdvanceCount);", "originalCommit": "fc2ae7cdfa7390040663c73f0ce475e7fd2751a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk3NzU1NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24515#discussion_r449977555", "bodyText": "Can we handle this without throwing an exception?", "author": "SupunS", "createdAt": "2020-07-06T04:27:51Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12619,6 +12597,345 @@ private STNode parseListMatchPatternMemberRhs(SyntaxKind nextTokenKind) {\n         }\n     }\n \n+    // --------------------------------- Documentation ---------------------------------\n+\n+    /*\n+     * This section parses documentation.\n+     * Ballerina flavored markdown (BFM) is supported by the documentation.\n+     *\n+     * During the parsing, parser will never go to the error handler.\n+     * In case of an error, all the tokens belong to the same documentation line,\n+     * are parsed as a single invalid documentation line node.\n+     * Refer {@link #parseInvalidDocumentationLine}\n+     */\n+\n+    /**\n+     * Parse documentation string.\n+     * <p>\n+     * <code>\n+     * DocumentationString :=\n+     *          ( DocumentationLine\n+     *          | ReferenceDocumentationLine\n+     *          | DeprecationDocumentationLine\n+     *          | ParameterDocumentationLine\n+     *          | ReturnParameterDocumentationLine\n+     *          | InvalidDocumentationLine ) +\n+     * </code>\n+     * <p>\n+     * Refer {@link BallerinaLexer#readDocumentationToken}\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseDocumentationString() {\n+        List<STNode> docLines = new ArrayList<>();\n+        STToken nextToken = peek();\n+        while (!isEndOfDocumentation(nextToken.kind)) {\n+            docLines.add(parseSingleDocumentationLine());\n+            nextToken = peek();\n+        }\n+\n+        STNode documentationLines = STNodeFactory.createNodeList(docLines);\n+        return STNodeFactory.createDocumentationStringNode(documentationLines);\n+    }\n+\n+    private boolean isEndOfDocumentation(SyntaxKind kind) {\n+        switch (kind) {\n+            case HASH_TOKEN:\n+            case DOCUMENTATION_DESCRIPTION:\n+            case PLUS_TOKEN:\n+            case PARAMETER_NAME:\n+            case MINUS_TOKEN:\n+            case BACKTICK_TOKEN:\n+            case BACKTICK_CONTENT:\n+                return false;\n+            default:\n+                return !isDocumentReferenceType(kind);\n+        }\n+    }\n+\n+    private boolean isDocumentReferenceType(SyntaxKind kind) {\n+        switch (kind) {\n+            case TYPE_DOC_REFERENCE_TOKEN:\n+            case SERVICE_DOC_REFERENCE_TOKEN:\n+            case VARIABLE_DOC_REFERENCE_TOKEN:\n+            case VAR_DOC_REFERENCE_TOKEN:\n+            case ANNOTATION_DOC_REFERENCE_TOKEN:\n+            case MODULE_DOC_REFERENCE_TOKEN:\n+            case FUNCTION_DOC_REFERENCE_TOKEN:\n+            case PARAMETER_DOC_REFERENCE_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Parse a single documentation line.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseSingleDocumentationLine() {\n+        STNode hashToken = parseHashToken();\n+        STToken nextToken = peek();\n+        switch (nextToken.kind) {\n+            case PLUS_TOKEN:\n+                return parseParameterDocumentationLine(hashToken);\n+            case DOCUMENTATION_DESCRIPTION:\n+            case HASH_TOKEN:\n+            case BACKTICK_TOKEN:\n+            default:\n+                return parseDocumentationLine(hashToken);\n+        }\n+    }\n+\n+    /**\n+     * Parse documentation line, deprecation documentation line and reference documentation line.\n+     *\n+     * @param hashToken Hash token at the beginning of the line\n+     * @return Parsed node\n+     */\n+    private STNode parseDocumentationLine(STNode hashToken) {\n+        List<STNode> docElements = new ArrayList<>();\n+        boolean isErroneous = appendDocumentationElements(docElements);\n+        if (isErroneous) {\n+            return parseInvalidDocumentationLine(hashToken, docElements);\n+        }\n+\n+        STNode docElementList = STNodeFactory.createNodeList(docElements);\n+\n+        switch (docElements.size()) {\n+            case 0:\n+                // When documentation line is only a `#` token\n+                return createDocumentationLineNode(hashToken, docElementList);\n+            case 1:\n+                STNode docElement = docElements.get(0);\n+                if (docElement.kind == SyntaxKind.DOCUMENTATION_DESCRIPTION) {\n+                    if (((STToken) docElement).text().startsWith(\"# Deprecated\")) {\n+                        return createDeprecationDocumentationLineNode(hashToken, docElementList);\n+                    }\n+                    return createDocumentationLineNode(hashToken, docElementList);\n+                }\n+                // Else fall through\n+            default:\n+                return createReferenceDocumentationLineNode(hashToken, docElementList);\n+        }\n+    }\n+\n+    private boolean appendDocumentationElements(List<STNode> docElements) {\n+        boolean isErroneous = false;\n+        STNode docElement;\n+        SyntaxKind nextTokenKind = peek().kind;\n+        while (!isEndOfIntermediateDocumentation(nextTokenKind)) {\n+            if (nextTokenKind == SyntaxKind.DOCUMENTATION_DESCRIPTION) {\n+                docElement = consume();\n+                docElements.add(docElement);\n+\n+            } else if (isDocumentReferenceType(nextTokenKind) || nextTokenKind == SyntaxKind.BACKTICK_TOKEN) {\n+                if (appendDocumentationReference(docElements)) {\n+                    isErroneous = true;\n+                }\n+            } else {\n+                docElement = consume();\n+                docElements.add(docElement);\n+                isErroneous = true;\n+            }\n+            nextTokenKind = peek().kind;\n+        }\n+        return isErroneous;\n+    }\n+\n+    private boolean appendDocumentationReference(List<STNode> docElements) {\n+        STNode referenceType = STNodeFactory.createEmptyNode();\n+        if (isDocumentReferenceType(peek().kind)) {\n+            referenceType = consume();\n+        }\n+\n+        STNode startBacktick = parseDocumentationBacktickToken();\n+        STNode backtickContent = parseBacktickContent();\n+        STNode endBacktick = parseDocumentationBacktickToken();\n+\n+        boolean isErroneous;\n+        if (hasMissingDocumentationTokens(startBacktick, backtickContent, endBacktick)) {\n+            isErroneous = true;\n+            appendNonMissingDocumentationTokens(docElements, referenceType, startBacktick, backtickContent,\n+                    endBacktick);\n+        } else {\n+            STNode docElement = STNodeFactory.createDocumentationReferenceNode(referenceType, startBacktick,\n+                    backtickContent, endBacktick);\n+            docElements.add(docElement);\n+            isErroneous = false;\n+        }\n+\n+        return isErroneous;\n+    }\n+\n+    private boolean hasMissingDocumentationTokens(STNode ... nodes) {\n+        for (STNode node : nodes) {\n+            if (node != null && node.isMissing()) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private void appendNonMissingDocumentationTokens(List<STNode> docElements, STNode ... nodes) {\n+        for (STNode node : nodes) {\n+            if (node != null && !node.isMissing()) {\n+                docElements.add(node);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Parse parameter documentation line and return parameter documentation line.\n+     *\n+     * @param hashToken Hash token at the beginning of the line\n+     * @return Parsed node\n+     */\n+    private STNode parseParameterDocumentationLine(STNode hashToken) {\n+        STNode plusToken = consume();\n+        STNode parameterName = parseParameterName();\n+        STNode minusToken = parseDashToken();\n+\n+        List<STNode> docElements = new ArrayList<>();\n+        if (hasMissingDocumentationTokens(parameterName, minusToken)) {\n+            appendNonMissingDocumentationTokens(docElements, plusToken, parameterName, minusToken);\n+            return parseInvalidDocumentationLine(hashToken, docElements);\n+        }\n+\n+        boolean isErroneous = appendDocumentationElements(docElements);\n+        if (isErroneous) {\n+            return parseInvalidDocumentationLine(hashToken, docElements);\n+        }\n+\n+        STNode docElementList = STNodeFactory.createNodeList(docElements);\n+\n+        SyntaxKind kind;\n+        if (((STToken) parameterName).text().equals(\"return\")) {\n+            kind = SyntaxKind.RETURN_PARAMETER_DOCUMENTATION_LINE;\n+        } else {\n+            kind = SyntaxKind.PARAMETER_DOCUMENTATION_LINE;\n+        }\n+\n+        return STNodeFactory.createParameterDocumentationLineNode(kind, hashToken, plusToken, parameterName, minusToken,\n+                docElementList);\n+    }\n+\n+    /**\n+     * Parse invalid documentation line node.\n+     *\n+     * @param hashToken Hash token at the beginning of the line\n+     * @param docElements List to add the invalid tokens\n+     * @return Parsed node\n+     */\n+    private STNode parseInvalidDocumentationLine(STNode hashToken, List<STNode> docElements) {\n+        STToken invalidToken = peek();\n+        while (!isEndOfIntermediateDocumentation(invalidToken.kind)) {\n+            docElements.add(consume());\n+            invalidToken = peek();\n+        }\n+\n+        STNode docElementList = STNodeFactory.createNodeList(docElements);\n+        return createInvalidDocumentationLineNode(hashToken, docElementList);\n+    }\n+\n+    private boolean isEndOfIntermediateDocumentation(SyntaxKind kind) {\n+        if (kind == SyntaxKind.HASH_TOKEN) {\n+            return true;\n+        }\n+        return isEndOfDocumentation(kind);\n+    }\n+\n+    /**\n+     * Parse hash token.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseHashToken() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.HASH_TOKEN) {\n+            return consume();\n+        } else {\n+            throw new IllegalStateException(\"documentation always start with a `#`\");", "originalCommit": "fc2ae7cdfa7390040663c73f0ce475e7fd2751a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk3ODExNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24515#discussion_r449978117", "bodyText": "what if we send a 'return' keyword token from the lexer?", "author": "SupunS", "createdAt": "2020-07-06T04:30:25Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12619,6 +12597,345 @@ private STNode parseListMatchPatternMemberRhs(SyntaxKind nextTokenKind) {\n         }\n     }\n \n+    // --------------------------------- Documentation ---------------------------------\n+\n+    /*\n+     * This section parses documentation.\n+     * Ballerina flavored markdown (BFM) is supported by the documentation.\n+     *\n+     * During the parsing, parser will never go to the error handler.\n+     * In case of an error, all the tokens belong to the same documentation line,\n+     * are parsed as a single invalid documentation line node.\n+     * Refer {@link #parseInvalidDocumentationLine}\n+     */\n+\n+    /**\n+     * Parse documentation string.\n+     * <p>\n+     * <code>\n+     * DocumentationString :=\n+     *          ( DocumentationLine\n+     *          | ReferenceDocumentationLine\n+     *          | DeprecationDocumentationLine\n+     *          | ParameterDocumentationLine\n+     *          | ReturnParameterDocumentationLine\n+     *          | InvalidDocumentationLine ) +\n+     * </code>\n+     * <p>\n+     * Refer {@link BallerinaLexer#readDocumentationToken}\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseDocumentationString() {\n+        List<STNode> docLines = new ArrayList<>();\n+        STToken nextToken = peek();\n+        while (!isEndOfDocumentation(nextToken.kind)) {\n+            docLines.add(parseSingleDocumentationLine());\n+            nextToken = peek();\n+        }\n+\n+        STNode documentationLines = STNodeFactory.createNodeList(docLines);\n+        return STNodeFactory.createDocumentationStringNode(documentationLines);\n+    }\n+\n+    private boolean isEndOfDocumentation(SyntaxKind kind) {\n+        switch (kind) {\n+            case HASH_TOKEN:\n+            case DOCUMENTATION_DESCRIPTION:\n+            case PLUS_TOKEN:\n+            case PARAMETER_NAME:\n+            case MINUS_TOKEN:\n+            case BACKTICK_TOKEN:\n+            case BACKTICK_CONTENT:\n+                return false;\n+            default:\n+                return !isDocumentReferenceType(kind);\n+        }\n+    }\n+\n+    private boolean isDocumentReferenceType(SyntaxKind kind) {\n+        switch (kind) {\n+            case TYPE_DOC_REFERENCE_TOKEN:\n+            case SERVICE_DOC_REFERENCE_TOKEN:\n+            case VARIABLE_DOC_REFERENCE_TOKEN:\n+            case VAR_DOC_REFERENCE_TOKEN:\n+            case ANNOTATION_DOC_REFERENCE_TOKEN:\n+            case MODULE_DOC_REFERENCE_TOKEN:\n+            case FUNCTION_DOC_REFERENCE_TOKEN:\n+            case PARAMETER_DOC_REFERENCE_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Parse a single documentation line.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseSingleDocumentationLine() {\n+        STNode hashToken = parseHashToken();\n+        STToken nextToken = peek();\n+        switch (nextToken.kind) {\n+            case PLUS_TOKEN:\n+                return parseParameterDocumentationLine(hashToken);\n+            case DOCUMENTATION_DESCRIPTION:\n+            case HASH_TOKEN:\n+            case BACKTICK_TOKEN:\n+            default:\n+                return parseDocumentationLine(hashToken);\n+        }\n+    }\n+\n+    /**\n+     * Parse documentation line, deprecation documentation line and reference documentation line.\n+     *\n+     * @param hashToken Hash token at the beginning of the line\n+     * @return Parsed node\n+     */\n+    private STNode parseDocumentationLine(STNode hashToken) {\n+        List<STNode> docElements = new ArrayList<>();\n+        boolean isErroneous = appendDocumentationElements(docElements);\n+        if (isErroneous) {\n+            return parseInvalidDocumentationLine(hashToken, docElements);\n+        }\n+\n+        STNode docElementList = STNodeFactory.createNodeList(docElements);\n+\n+        switch (docElements.size()) {\n+            case 0:\n+                // When documentation line is only a `#` token\n+                return createDocumentationLineNode(hashToken, docElementList);\n+            case 1:\n+                STNode docElement = docElements.get(0);\n+                if (docElement.kind == SyntaxKind.DOCUMENTATION_DESCRIPTION) {\n+                    if (((STToken) docElement).text().startsWith(\"# Deprecated\")) {\n+                        return createDeprecationDocumentationLineNode(hashToken, docElementList);\n+                    }\n+                    return createDocumentationLineNode(hashToken, docElementList);\n+                }\n+                // Else fall through\n+            default:\n+                return createReferenceDocumentationLineNode(hashToken, docElementList);\n+        }\n+    }\n+\n+    private boolean appendDocumentationElements(List<STNode> docElements) {\n+        boolean isErroneous = false;\n+        STNode docElement;\n+        SyntaxKind nextTokenKind = peek().kind;\n+        while (!isEndOfIntermediateDocumentation(nextTokenKind)) {\n+            if (nextTokenKind == SyntaxKind.DOCUMENTATION_DESCRIPTION) {\n+                docElement = consume();\n+                docElements.add(docElement);\n+\n+            } else if (isDocumentReferenceType(nextTokenKind) || nextTokenKind == SyntaxKind.BACKTICK_TOKEN) {\n+                if (appendDocumentationReference(docElements)) {\n+                    isErroneous = true;\n+                }\n+            } else {\n+                docElement = consume();\n+                docElements.add(docElement);\n+                isErroneous = true;\n+            }\n+            nextTokenKind = peek().kind;\n+        }\n+        return isErroneous;\n+    }\n+\n+    private boolean appendDocumentationReference(List<STNode> docElements) {\n+        STNode referenceType = STNodeFactory.createEmptyNode();\n+        if (isDocumentReferenceType(peek().kind)) {\n+            referenceType = consume();\n+        }\n+\n+        STNode startBacktick = parseDocumentationBacktickToken();\n+        STNode backtickContent = parseBacktickContent();\n+        STNode endBacktick = parseDocumentationBacktickToken();\n+\n+        boolean isErroneous;\n+        if (hasMissingDocumentationTokens(startBacktick, backtickContent, endBacktick)) {\n+            isErroneous = true;\n+            appendNonMissingDocumentationTokens(docElements, referenceType, startBacktick, backtickContent,\n+                    endBacktick);\n+        } else {\n+            STNode docElement = STNodeFactory.createDocumentationReferenceNode(referenceType, startBacktick,\n+                    backtickContent, endBacktick);\n+            docElements.add(docElement);\n+            isErroneous = false;\n+        }\n+\n+        return isErroneous;\n+    }\n+\n+    private boolean hasMissingDocumentationTokens(STNode ... nodes) {\n+        for (STNode node : nodes) {\n+            if (node != null && node.isMissing()) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private void appendNonMissingDocumentationTokens(List<STNode> docElements, STNode ... nodes) {\n+        for (STNode node : nodes) {\n+            if (node != null && !node.isMissing()) {\n+                docElements.add(node);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Parse parameter documentation line and return parameter documentation line.\n+     *\n+     * @param hashToken Hash token at the beginning of the line\n+     * @return Parsed node\n+     */\n+    private STNode parseParameterDocumentationLine(STNode hashToken) {\n+        STNode plusToken = consume();\n+        STNode parameterName = parseParameterName();\n+        STNode minusToken = parseDashToken();\n+\n+        List<STNode> docElements = new ArrayList<>();\n+        if (hasMissingDocumentationTokens(parameterName, minusToken)) {\n+            appendNonMissingDocumentationTokens(docElements, plusToken, parameterName, minusToken);\n+            return parseInvalidDocumentationLine(hashToken, docElements);\n+        }\n+\n+        boolean isErroneous = appendDocumentationElements(docElements);\n+        if (isErroneous) {\n+            return parseInvalidDocumentationLine(hashToken, docElements);\n+        }\n+\n+        STNode docElementList = STNodeFactory.createNodeList(docElements);\n+\n+        SyntaxKind kind;\n+        if (((STToken) parameterName).text().equals(\"return\")) {", "originalCommit": "fc2ae7cdfa7390040663c73f0ce475e7fd2751a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk3ODg2Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24515#discussion_r449978867", "bodyText": "appendDocumentationElements -> parseDocumentationElements", "author": "SupunS", "createdAt": "2020-07-06T04:34:29Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12619,6 +12597,345 @@ private STNode parseListMatchPatternMemberRhs(SyntaxKind nextTokenKind) {\n         }\n     }\n \n+    // --------------------------------- Documentation ---------------------------------\n+\n+    /*\n+     * This section parses documentation.\n+     * Ballerina flavored markdown (BFM) is supported by the documentation.\n+     *\n+     * During the parsing, parser will never go to the error handler.\n+     * In case of an error, all the tokens belong to the same documentation line,\n+     * are parsed as a single invalid documentation line node.\n+     * Refer {@link #parseInvalidDocumentationLine}\n+     */\n+\n+    /**\n+     * Parse documentation string.\n+     * <p>\n+     * <code>\n+     * DocumentationString :=\n+     *          ( DocumentationLine\n+     *          | ReferenceDocumentationLine\n+     *          | DeprecationDocumentationLine\n+     *          | ParameterDocumentationLine\n+     *          | ReturnParameterDocumentationLine\n+     *          | InvalidDocumentationLine ) +\n+     * </code>\n+     * <p>\n+     * Refer {@link BallerinaLexer#readDocumentationToken}\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseDocumentationString() {\n+        List<STNode> docLines = new ArrayList<>();\n+        STToken nextToken = peek();\n+        while (!isEndOfDocumentation(nextToken.kind)) {\n+            docLines.add(parseSingleDocumentationLine());\n+            nextToken = peek();\n+        }\n+\n+        STNode documentationLines = STNodeFactory.createNodeList(docLines);\n+        return STNodeFactory.createDocumentationStringNode(documentationLines);\n+    }\n+\n+    private boolean isEndOfDocumentation(SyntaxKind kind) {\n+        switch (kind) {\n+            case HASH_TOKEN:\n+            case DOCUMENTATION_DESCRIPTION:\n+            case PLUS_TOKEN:\n+            case PARAMETER_NAME:\n+            case MINUS_TOKEN:\n+            case BACKTICK_TOKEN:\n+            case BACKTICK_CONTENT:\n+                return false;\n+            default:\n+                return !isDocumentReferenceType(kind);\n+        }\n+    }\n+\n+    private boolean isDocumentReferenceType(SyntaxKind kind) {\n+        switch (kind) {\n+            case TYPE_DOC_REFERENCE_TOKEN:\n+            case SERVICE_DOC_REFERENCE_TOKEN:\n+            case VARIABLE_DOC_REFERENCE_TOKEN:\n+            case VAR_DOC_REFERENCE_TOKEN:\n+            case ANNOTATION_DOC_REFERENCE_TOKEN:\n+            case MODULE_DOC_REFERENCE_TOKEN:\n+            case FUNCTION_DOC_REFERENCE_TOKEN:\n+            case PARAMETER_DOC_REFERENCE_TOKEN:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * Parse a single documentation line.\n+     *\n+     * @return Parsed node\n+     */\n+    private STNode parseSingleDocumentationLine() {\n+        STNode hashToken = parseHashToken();\n+        STToken nextToken = peek();\n+        switch (nextToken.kind) {\n+            case PLUS_TOKEN:\n+                return parseParameterDocumentationLine(hashToken);\n+            case DOCUMENTATION_DESCRIPTION:\n+            case HASH_TOKEN:\n+            case BACKTICK_TOKEN:\n+            default:\n+                return parseDocumentationLine(hashToken);\n+        }\n+    }\n+\n+    /**\n+     * Parse documentation line, deprecation documentation line and reference documentation line.\n+     *\n+     * @param hashToken Hash token at the beginning of the line\n+     * @return Parsed node\n+     */\n+    private STNode parseDocumentationLine(STNode hashToken) {\n+        List<STNode> docElements = new ArrayList<>();\n+        boolean isErroneous = appendDocumentationElements(docElements);\n+        if (isErroneous) {\n+            return parseInvalidDocumentationLine(hashToken, docElements);\n+        }\n+\n+        STNode docElementList = STNodeFactory.createNodeList(docElements);\n+\n+        switch (docElements.size()) {\n+            case 0:\n+                // When documentation line is only a `#` token\n+                return createDocumentationLineNode(hashToken, docElementList);\n+            case 1:\n+                STNode docElement = docElements.get(0);\n+                if (docElement.kind == SyntaxKind.DOCUMENTATION_DESCRIPTION) {\n+                    if (((STToken) docElement).text().startsWith(\"# Deprecated\")) {\n+                        return createDeprecationDocumentationLineNode(hashToken, docElementList);\n+                    }\n+                    return createDocumentationLineNode(hashToken, docElementList);\n+                }\n+                // Else fall through\n+            default:\n+                return createReferenceDocumentationLineNode(hashToken, docElementList);\n+        }\n+    }\n+\n+    private boolean appendDocumentationElements(List<STNode> docElements) {", "originalCommit": "fc2ae7cdfa7390040663c73f0ce475e7fd2751a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f0c2cd74981d35e3cdaea56ffc0cc0cbc61180ce", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f0c2cd74981d35e3cdaea56ffc0cc0cbc61180ce", "message": "Add requested changes", "committedDate": "2020-07-06T13:09:34Z", "type": "forcePushed"}, {"oid": "44cf43f17b787d90edf4fd3ae7c7ec9452aff5ca", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/44cf43f17b787d90edf4fd3ae7c7ec9452aff5ca", "message": "Add requested changes", "committedDate": "2020-07-06T13:12:52Z", "type": "forcePushed"}, {"oid": "0d1e06968cb8c28dbf86e05b4997ee182ea77ecf", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0d1e06968cb8c28dbf86e05b4997ee182ea77ecf", "message": "Add requested changes", "committedDate": "2020-07-06T13:16:38Z", "type": "commit"}, {"oid": "0d1e06968cb8c28dbf86e05b4997ee182ea77ecf", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0d1e06968cb8c28dbf86e05b4997ee182ea77ecf", "message": "Add requested changes", "committedDate": "2020-07-06T13:16:38Z", "type": "forcePushed"}, {"oid": "67cea276a4c428249b85f5d9b898ea68e69c1682", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/67cea276a4c428249b85f5d9b898ea68e69c1682", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into doc-support\n\n\u0001 Conflicts:\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/tree/STNodeFactory.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/tree/STNodeTransformer.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/tree/STNodeVisitor.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/tree/STTreeModifier.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/NodeFactory.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/NodeTransformer.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/NodeVisitor.java\n\u0001\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/syntax/tree/TreeModifier.java\n\u0001\tcompiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "committedDate": "2020-07-06T13:47:20Z", "type": "commit"}, {"oid": "f36bd32b135cc904769f139cfbe9cfa29f194f1a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f36bd32b135cc904769f139cfbe9cfa29f194f1a", "message": "Regenerate tree after merging", "committedDate": "2020-07-06T14:22:01Z", "type": "forcePushed"}, {"oid": "2a192d7aafea6893bf817121f6fe456715eeb2f7", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2a192d7aafea6893bf817121f6fe456715eeb2f7", "message": "Regenerate tree after merging", "committedDate": "2020-07-06T15:18:58Z", "type": "commit"}, {"oid": "2a192d7aafea6893bf817121f6fe456715eeb2f7", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2a192d7aafea6893bf817121f6fe456715eeb2f7", "message": "Regenerate tree after merging", "committedDate": "2020-07-06T15:18:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU5MDYzMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24515#discussion_r450590631", "bodyText": "Can you explain whats happening in tis snippet?\nI think you'l have to consider windows environments as well, since in windows, theres a carriage return (\\r) for newlines.", "author": "SupunS", "createdAt": "2020-07-07T03:25:00Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/BLangNodeTransformer.java", "diffHunk": "@@ -4216,70 +4202,58 @@ private BLangMarkdownDocumentation createMarkdownDocumentationAttachment(Optiona\n         return doc;\n     }\n \n-    private String trimLeftAtMostOne(String text) {\n-        int countToStrip = 0;\n-        if (!text.isEmpty() && Character.isWhitespace(text.charAt(0))) {\n-            countToStrip = 1;\n-        }\n-        return text.substring(countToStrip);\n-    }\n-\n-    private boolean addReferences(String text, LinkedList<BLangMarkdownReferenceDocumentation> references,\n-                                  boolean startsInsideQuotes) {\n-//              _\n-//             / \\ non-tick (in single quote)\n-//             v /\n-//            --4<----.                 _____\n-//      tick /         \\non-tick       /     \\ non-tick\n-//          v     tick  \\       tick  v tick  \\        tick\n-//     .-> 0-------------->1--------->2--------->3-----------------.\n-//    /   ^ \\                        ^ \\                           |\n-//    |   | |                        | |                           |\n-//    |   \\_/non-tick (un-quoted)    \\_/non-tick (in double quote) |\n-//    \\____________________________________________________________/\n-//\n-// note this state machine is only design to distinguish single tick and double tick quoted string\n-// for simplicity are assuming three tick case is just a subset of double tick case\n-\n-        int length = text.length();\n-        int state = startsInsideQuotes ? 2 : 0;\n-        int lastWhiteSpace = 0;\n-        int secondToLastWhiteSpace = 0;\n-\n-        //                0  1  2  3  4\n-        int[][] table = {{0, 4, 2, 2, 4},  // non-tick\n-                         {1, 2, 3, 0, 0}}; // tick\n-\n-        for (int i = 0; i < length; i++) {\n-            char c = text.charAt(i);\n-            int isTick = c == '`' ? 1 : 0;\n-            int newState = table[isTick][state];\n-\n-            if (newState == 0 && c == ' ') {\n-                secondToLastWhiteSpace = lastWhiteSpace;\n-                lastWhiteSpace = i;\n-            }\n+    private String addReferencesAndReturnDocumentationText(LinkedList<BLangMarkdownReferenceDocumentation> references,\n+                                                           NodeList<Node> docElements) {\n+        StringBuilder docText = new StringBuilder();\n+        for (Node element : docElements) {\n+            docText.append(element.toString());\n \n-            if (state == 4 && newState == 0) { // we are coming out of a single quoted string\n-                BLangMarkdownReferenceDocumentation ref = new BLangMarkdownReferenceDocumentation();\n-                ref.type = DocumentationReferenceType.BACKTICK_CONTENT;\n-                if (secondToLastWhiteSpace + 1 < lastWhiteSpace) {\n-                    ref.type = stringToRefType(text.substring(secondToLastWhiteSpace + 1, lastWhiteSpace));\n-                }\n-                references.add(ref);\n+            // Add references if available\n+            if (element.kind() == SyntaxKind.DOCUMENTATION_REFERENCE) {\n+                BLangMarkdownReferenceDocumentation bLangRefDoc = new BLangMarkdownReferenceDocumentation();\n+                DocumentationReferenceNode docReferenceNode = (DocumentationReferenceNode) element;\n+\n+                Token backtickContent = docReferenceNode.backtickContent();\n+                bLangRefDoc.referenceName = backtickContent.isMissing() ? \"\" : backtickContent.text();\n+\n+                bLangRefDoc.type = DocumentationReferenceType.BACKTICK_CONTENT;\n+                docReferenceNode.referenceType().ifPresent(\n+                        refType -> bLangRefDoc.type = stringToRefType(refType.text())\n+                );\n+\n+                references.add(bLangRefDoc);\n             }\n-            state = newState;\n         }\n-        return state == 2 || state == 3;\n+\n+        String text = docText.toString();\n+        if (text.endsWith(\"\\n\")) {\n+            text = text.substring(0, text.length() - 1);\n+        }", "originalCommit": "2a192d7aafea6893bf817121f6fe456715eeb2f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU5ODg4MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24515#discussion_r450598880", "bodyText": "To get the full text containing in the NodeList<Node> docElements. I loop through it and append all docElement.toString()s. In the last docElement there will be a \\n in its last children's trailing minutiae which should not be included in the documentation line text.\nyeah few parser tests too are falling in windows build. That's should be due  to above reason. I'll fix", "author": "lochana-chathura", "createdAt": "2020-07-07T04:02:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU5MDYzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYwMDQ5OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24515#discussion_r450600499", "bodyText": "I think the issue is using element.toString(). That can cause issues  since toString() includes minutiae such as newlines, invalid tokens etc. We should use .text() method in the Token class", "author": "SupunS", "createdAt": "2020-07-07T04:10:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU5MDYzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYyNjY0MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24515#discussion_r450626640", "bodyText": "We will have a problem for lines having documentation reference. e.g  text of annotation `field a` documentation will be annotation`field a`documentation   if we use .text(), as white spaces there are captured as trivia. Shall I use toString() anyway? and replace \\r\\n and  \\n with \"\" at the end", "author": "lochana-chathura", "createdAt": "2020-07-07T05:55:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU5MDYzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYyODUyNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24515#discussion_r450628525", "bodyText": "ah ok. +1.\nBut please make sure it won't include other minutiae such as invalid nodes, comments, etc.", "author": "SupunS", "createdAt": "2020-07-07T06:01:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU5MDYzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU5MTI3Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24515#discussion_r450591272", "bodyText": "Shall we use the constant LexerTerminals.RETURN.\nBTW, usually we swap the arguments as a practice to make the .equals() is called on the constant..\neg: \"return\".equals(getLexeme()) or LexerTerminals.RETURN.equals(getLexeme())\nThat way we can avoid any possible NPE.  i.e: even if getLexeme() returns a null, it will not throw a NPE", "author": "SupunS", "createdAt": "2020-07-07T03:27:47Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "diffHunk": "@@ -1550,4 +1567,296 @@ private STToken readTokenInBracedContentInInterpolation() {\n \n         return readToken();\n     }\n+\n+    /*\n+     * ------------------------------------------------------------------------------------------------------------\n+     * DOCUMENTATION Mode\n+     * ------------------------------------------------------------------------------------------------------------\n+     */\n+\n+    private STToken readDocumentationToken() {\n+        int nextChar = peek();\n+        if (nextChar == LexerTerminals.PLUS) {\n+            reader.advance();\n+            switchMode(ParserMode.DOCUMENTATION_PARAMETER);\n+            return getDocumentationSyntaxToken(SyntaxKind.PLUS_TOKEN);\n+        }\n+        return readDocumentationInternalToken();\n+    }\n+\n+    /*\n+     * ------------------------------------------------------------------------------------------------------------\n+     * DOCUMENTATION_INTERNAL Mode\n+     * ------------------------------------------------------------------------------------------------------------\n+     */\n+\n+    private STToken readDocumentationInternalToken() {\n+        reader.mark();\n+        int nextChar = peek();\n+        switch (nextChar) {\n+            case LexerTerminals.BACKTICK:\n+                if (reader.peek(1) != LexerTerminals.BACKTICK) {\n+                    reader.advance();\n+                    switchMode(ParserMode.DOCUMENTATION_BACKTICK_CONTENT);\n+                    return getDocumentationSyntaxToken(SyntaxKind.BACKTICK_TOKEN);\n+                }\n+                // Fall through\n+            default:\n+                while (!reader.isEOF()) {\n+                    switch (nextChar) {\n+                        case LexerTerminals.NEWLINE:\n+                        case LexerTerminals.CARRIAGE_RETURN:\n+                            endMode();\n+                            break;\n+                        case LexerTerminals.BACKTICK:\n+                            if (reader.peek(1) != LexerTerminals.BACKTICK) {\n+                                break;\n+                            } else if (reader.peek(2) != LexerTerminals.BACKTICK) {\n+                                // Double backtick detected\n+                                reader.advance(2);\n+                                processDocumentationCodeContent(false);\n+                            } else {\n+                                // Triple backtick detected\n+                                reader.advance(3);\n+                                processDocumentationCodeContent(true);\n+                            }\n+                            nextChar = peek();\n+                            continue;\n+                        default:\n+                            if (isIdentifierInitialChar(nextChar)) {\n+                                boolean hasDocumentationReference = processDocumentationReference(nextChar);\n+                                if (hasDocumentationReference) {\n+                                    switchMode(ParserMode.DOCUMENTATION_REFERENCE_TYPE);\n+                                    break;\n+                                }\n+                            } else {\n+                                reader.advance();\n+                            }\n+                            nextChar = peek();\n+                            continue;\n+                    }\n+                    break;\n+                }\n+        }\n+\n+        if (getLexeme().isEmpty()) {\n+            // Reaching here means,\n+            // first immediate character itself belong to a documentation reference.\n+            return readDocumentationReferenceTypeToken();\n+        }\n+        return getTemplateString(SyntaxKind.DOCUMENTATION_DESCRIPTION);\n+    }\n+\n+    private void processDocumentationCodeContent(boolean isTripleBacktick) {\n+        int nextChar = peek();\n+        while (!reader.isEOF()) {\n+            switch (nextChar) {\n+                case LexerTerminals.BACKTICK:\n+                    // Look for a double backtick or a triple backtick\n+                    // depend on the `isTripleBacktick` boolean value.\n+                    if (isTripleBacktick) {\n+                        reader.advance();\n+                        if (peek() != LexerTerminals.BACKTICK) {\n+                            nextChar = peek();\n+                            continue;\n+                        }\n+                    }\n+                    reader.advance();\n+                    if (peek() != LexerTerminals.BACKTICK) {\n+                        nextChar = peek();\n+                        continue;\n+                    }\n+                    reader.advance();\n+                    if (peek() != LexerTerminals.BACKTICK) {\n+                        return;\n+                    }\n+                    nextChar = peek();\n+                    continue;\n+                case LexerTerminals.NEWLINE:\n+                    // Reaching here means ending backticks were not found within the same line.\n+                    // Therefore, look ahead and see if next line is a documentation line and if so,\n+                    // look for a ending in that line. Otherwise terminate backtick content at the new line.\n+                    int lookAheadCount = 1;\n+                    int lookAheadChar = reader.peek(lookAheadCount);\n+                    while (lookAheadChar == LexerTerminals.SPACE || lookAheadChar == LexerTerminals.TAB) {\n+                        lookAheadCount++;\n+                        lookAheadChar = reader.peek(lookAheadCount);\n+                    }\n+                    if (lookAheadChar != LexerTerminals.HASH) {\n+                        return;\n+                    }\n+                    reader.advance(lookAheadCount);\n+                    nextChar = peek();\n+                    continue;\n+                default:\n+                    reader.advance();\n+                    nextChar = peek();\n+            }\n+        }\n+    }\n+\n+    private boolean processDocumentationReference(int nextChar) {\n+        // Look ahead and see if next characters belong to a documentation reference.\n+        // If they do, do not advance the reader and return.\n+        // Otherwise advance the reader for checked characters and return\n+\n+        int lookAheadChar = nextChar;\n+        int lookAheadCount = 0;\n+        String identifier = \"\";\n+\n+        while (isIdentifierInitialChar(lookAheadChar)) {\n+            identifier = identifier.concat(String.valueOf((char) lookAheadChar));\n+            lookAheadCount++;\n+            lookAheadChar = reader.peek(lookAheadCount);\n+        }\n+\n+        switch (identifier) {\n+            case LexerTerminals.TYPE:\n+            case LexerTerminals.SERVICE:\n+            case LexerTerminals.VARIABLE:\n+            case LexerTerminals.VAR:\n+            case LexerTerminals.ANNOTATION:\n+            case LexerTerminals.MODULE:\n+            case LexerTerminals.FUNCTION:\n+            case LexerTerminals.PARAMETER:\n+                // Look ahead for a single backtick.\n+                // There could be spaces or tabs in between.\n+                while (true) {\n+                    switch (lookAheadChar) {\n+                        case LexerTerminals.SPACE:\n+                        case LexerTerminals.TAB:\n+                            lookAheadCount++;\n+                            lookAheadChar = reader.peek(lookAheadCount);\n+                            continue;\n+                        case LexerTerminals.BACKTICK:\n+                            // Make sure backtick is a single backtick\n+                            if (reader.peek(lookAheadCount + 1) != LexerTerminals.BACKTICK) {\n+                                // Reaching here means checked characters belong to a documentation reference.\n+                                // Hence return.\n+                                return true;\n+                            }\n+                            // Fall through\n+                        default:\n+                            break;\n+                    }\n+                    break;\n+                }\n+                // Fall through\n+            default:\n+                //\n+                reader.advance(lookAheadCount);\n+                return false;\n+        }\n+    }\n+\n+    /*\n+     * ------------------------------------------------------------------------------------------------------------\n+     * DOCUMENTATION_PARAMETER Mode\n+     * ------------------------------------------------------------------------------------------------------------\n+     */\n+\n+    private STToken readDocumentationParameterToken() {\n+        reader.mark();\n+        int nextChar = peek();\n+        if (isIdentifierInitialChar(nextChar)) {\n+            STToken token;\n+            reader.advance();\n+            while (isIdentifierInitialChar(peek())) {\n+                reader.advance();\n+            }\n+            if (getLexeme().equals(\"return\")) {", "originalCommit": "2a192d7aafea6893bf817121f6fe456715eeb2f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "546210f2dbd2dceffcee582dce76ddcd609d5936", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/546210f2dbd2dceffcee582dce76ddcd609d5936", "message": "Fix end of line test cases failing for windows environment", "committedDate": "2020-07-07T07:34:56Z", "type": "commit"}, {"oid": "e9af7200f82b1e920fcbaecc733e0cf722a0272c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e9af7200f82b1e920fcbaecc733e0cf722a0272c", "message": "Fix documentation line text for non-whitespace trivia in node transformer", "committedDate": "2020-07-07T07:51:13Z", "type": "commit"}, {"oid": "ca03791c204a618a9356c98d9fddfcf260b39022", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ca03791c204a618a9356c98d9fddfcf260b39022", "message": "Fix end of line and refactor", "committedDate": "2020-07-07T12:29:00Z", "type": "forcePushed"}, {"oid": "14563ec0b5437c3cbb0a44709f98221982ca66a1", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/14563ec0b5437c3cbb0a44709f98221982ca66a1", "message": "Fix end of line and refactor", "committedDate": "2020-07-07T15:05:56Z", "type": "commit"}, {"oid": "a8a32a3751257dac305295ac350bbcf6def88eb2", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a8a32a3751257dac305295ac350bbcf6def88eb2", "message": "Comment out failing LS tests", "committedDate": "2020-07-07T15:06:36Z", "type": "commit"}, {"oid": "a8a32a3751257dac305295ac350bbcf6def88eb2", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a8a32a3751257dac305295ac350bbcf6def88eb2", "message": "Comment out failing LS tests", "committedDate": "2020-07-07T15:06:36Z", "type": "forcePushed"}]}