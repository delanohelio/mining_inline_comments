{"pr_number": 25122, "pr_title": "Change the formatter implementation to use the new parser", "pr_createdAt": "2020-08-04T07:02:27Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkxMjY2OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r464912668", "bodyText": "@IrushiL ; Does this have to be 2020?\nThere were some other classes too", "author": "keizer619", "createdAt": "2020-08-04T09:12:29Z", "path": "misc/formatter/modules/formatter-cli/src/main/java/org/ballerinalang/formatter/cli/FormatCmd.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Copyright (c) 2019, WSO2 Inc. (http://wso2.com) All Rights Reserved.", "originalCommit": "1b72faad13b973766a11b0c45bcb8d94015a18b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM5MTg3OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r468391878", "bodyText": "Thanks, will change this.", "author": "IrushiL", "createdAt": "2020-08-11T07:50:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkxMjY2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE0ODA1NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r466148055", "bodyText": "Why this is commented everywhere?", "author": "suganyasuven", "createdAt": "2020-08-06T05:04:33Z", "path": "misc/formatter/modules/formatter-cli/src/test/java/org/ballerinalang/formatter/cli/FormatCmdTest.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Copyright (c) 2019, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.ballerinalang.formatter.cli;\n+\n+import org.ballerinalang.tool.BLauncherException;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Format CLI tool test suit for testing tool's exceptions.\n+ */\n+public class FormatCmdTest {\n+    private static final Path RES_DIR = Paths.get(\"src/test/resources/\").toAbsolutePath();\n+\n+    @Test(description = \"Test to check the exception for too many argument provided.\")\n+    public void formatCLITooManyArgumentsTest() {\n+        Path sourceRoot = RES_DIR.resolve(\"notAProject\");\n+        List<String> argList = new ArrayList<>();\n+        argList.add(\"pkg2\");\n+        argList.add(\"asd\");\n+        try {\n+//            FormatUtil.execute(argList, false, false, sourceRoot);", "originalCommit": "1b72faad13b973766a11b0c45bcb8d94015a18b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODM5MTUzNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r468391535", "bodyText": "This is still under implementation.", "author": "IrushiL", "createdAt": "2020-08-11T07:50:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE0ODA1NQ=="}], "type": "inlineReview"}, {"oid": "e8d42da874537ec9fb41c669f1741f85cd5311ed", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e8d42da874537ec9fb41c669f1741f85cd5311ed", "message": "Update the license headers", "committedDate": "2020-08-11T08:01:48Z", "type": "forcePushed"}, {"oid": "c016e817e2675ff24f30f9d1d4a4ab625d0db7f4", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c016e817e2675ff24f30f9d1d4a4ab625d0db7f4", "message": "add initial tree modifier", "committedDate": "2020-08-11T20:05:07Z", "type": "commit"}, {"oid": "9fda7e956166dabaeb2612840f14203337041b8b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9fda7e956166dabaeb2612840f14203337041b8b", "message": "Initial commit.", "committedDate": "2020-08-11T20:05:07Z", "type": "commit"}, {"oid": "406ed59e785b5080a09706bf30e791e24c649f1b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/406ed59e785b5080a09706bf30e791e24c649f1b", "message": "add the empty minutiae list from abstract node factory", "committedDate": "2020-08-11T20:05:07Z", "type": "commit"}, {"oid": "723d30b67be1337d912cbd11205c4715b41b1265", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/723d30b67be1337d912cbd11205c4715b41b1265", "message": "Add function arguments formatting support", "committedDate": "2020-08-11T20:05:07Z", "type": "commit"}, {"oid": "63983517d05c838a135727123e1f1439f302d9b6", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/63983517d05c838a135727123e1f1439f302d9b6", "message": "Add function visibility qualifier formatting support", "committedDate": "2020-08-11T20:05:07Z", "type": "commit"}, {"oid": "d5b34b24e15e8605f2cffa68592c5bff546401f9", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d5b34b24e15e8605f2cffa68592c5bff546401f9", "message": "Add function parameter formatting support", "committedDate": "2020-08-11T20:05:07Z", "type": "commit"}, {"oid": "55636add217289cb4e48fbbcdf3c14e36f8fca9f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/55636add217289cb4e48fbbcdf3c14e36f8fca9f", "message": "Fix function keyword formatting", "committedDate": "2020-08-11T20:05:07Z", "type": "commit"}, {"oid": "4013110d86fdb010c54ecdd17ee270d74224d80d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4013110d86fdb010c54ecdd17ee270d74224d80d", "message": "Add import node formatting support", "committedDate": "2020-08-11T20:05:07Z", "type": "commit"}, {"oid": "c6851d7566cc37bda917b8631cb8ec0e299d1770", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c6851d7566cc37bda917b8631cb8ec0e299d1770", "message": "Fix qualified name reference node formatting issue.\nAdded ParenthesizedArgList formatting support", "committedDate": "2020-08-11T20:05:07Z", "type": "commit"}, {"oid": "0f299ca4d6e83563fdc13b4be50ed27a5e2b357c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0f299ca4d6e83563fdc13b4be50ed27a5e2b357c", "message": "Add variable declaration node.", "committedDate": "2020-08-11T20:05:07Z", "type": "commit"}, {"oid": "7cda6c93d32208a3627a07aad590d1f289f121b8", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7cda6c93d32208a3627a07aad590d1f289f121b8", "message": "Fix getToken method call.", "committedDate": "2020-08-11T20:05:08Z", "type": "commit"}, {"oid": "9d85d3d02203e04870f4a57601b28abf8cf9cb81", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9d85d3d02203e04870f4a57601b28abf8cf9cb81", "message": "Add RemoteMethodCallActionNode.", "committedDate": "2020-08-11T20:05:08Z", "type": "commit"}, {"oid": "f44529cc214e5e90459b0ab4ae5808674b32aa5f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f44529cc214e5e90459b0ab4ae5808674b32aa5f", "message": "Add TypedBindingPatternNode.", "committedDate": "2020-08-11T20:05:08Z", "type": "commit"}, {"oid": "73ff4d2e64a58571789bd9f648d27193a02e0b4d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/73ff4d2e64a58571789bd9f648d27193a02e0b4d", "message": "Add BindingPatternNodes.", "committedDate": "2020-08-11T20:05:08Z", "type": "commit"}, {"oid": "b72d2ba4c7eb6f932aa9ee4effc5d8632a4388d4", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b72d2ba4c7eb6f932aa9ee4effc5d8632a4388d4", "message": "Add simple name reference node.", "committedDate": "2020-08-11T20:05:08Z", "type": "commit"}, {"oid": "f6e1bef97ac6eee63aeb10e24bbc797be9942cc4", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f6e1bef97ac6eee63aeb10e24bbc797be9942cc4", "message": "Fix semicolon newline issue.", "committedDate": "2020-08-11T20:05:08Z", "type": "commit"}, {"oid": "d253d70a9c0305b4d88814fbcaebd1978edbe811", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d253d70a9c0305b4d88814fbcaebd1978edbe811", "message": "Add IfElseStatementNode.", "committedDate": "2020-08-11T20:05:08Z", "type": "commit"}, {"oid": "14a6172658f65858016b02721e6050293dc923d2", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/14a6172658f65858016b02721e6050293dc923d2", "message": "Add BracedExpressionNode.", "committedDate": "2020-08-11T20:05:08Z", "type": "commit"}, {"oid": "2b900f74a79e977accfcac97b378ceb6503b8dc2", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2b900f74a79e977accfcac97b378ceb6503b8dc2", "message": "Add TypeTestExpressionNode.", "committedDate": "2020-08-11T20:05:08Z", "type": "commit"}, {"oid": "18650d691ab8a0bcd45f811860f327bb14d2b6f8", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/18650d691ab8a0bcd45f811860f327bb14d2b6f8", "message": "Add ErrorTypeDescriptorNode.", "committedDate": "2020-08-11T20:05:08Z", "type": "commit"}, {"oid": "31ddee8fc298bbacad9947d58e51aba083fd7ce2", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/31ddee8fc298bbacad9947d58e51aba083fd7ce2", "message": "Add BlockStatementNode.", "committedDate": "2020-08-11T20:05:08Z", "type": "commit"}, {"oid": "eff97f8f931d603f0325360498d0ba3f61c479a8", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/eff97f8f931d603f0325360498d0ba3f61c479a8", "message": "Add getParent method", "committedDate": "2020-08-11T20:05:08Z", "type": "commit"}, {"oid": "fff49295eb285855473fdc344da0a3904169b204", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fff49295eb285855473fdc344da0a3904169b204", "message": "Fix error", "committedDate": "2020-08-11T20:05:08Z", "type": "commit"}, {"oid": "b522465eefb5987072ed22226db5bb2773cf788e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b522465eefb5987072ed22226db5bb2773cf788e", "message": "Add module variable declaration node", "committedDate": "2020-08-11T20:05:08Z", "type": "commit"}, {"oid": "fd573b61ef35418eae9ac432e0e1b371e4b417c6", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fd573b61ef35418eae9ac432e0e1b371e4b417c6", "message": "Add get start column method", "committedDate": "2020-08-11T20:05:08Z", "type": "commit"}, {"oid": "69478c0f8c484995aa12e4826703d020d2159d92", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/69478c0f8c484995aa12e4826703d020d2159d92", "message": "Add new node kind support for formatting", "committedDate": "2020-08-11T20:05:09Z", "type": "commit"}, {"oid": "418a79ddccc4d1d28128719c940444eb7ec03713", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/418a79ddccc4d1d28128719c940444eb7ec03713", "message": "Add new nodes", "committedDate": "2020-08-11T20:05:09Z", "type": "commit"}, {"oid": "a7ee02e576f47ce4bcd3eb6ee4328a5eeb5dc4c8", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a7ee02e576f47ce4bcd3eb6ee4328a5eeb5dc4c8", "message": "Add test files", "committedDate": "2020-08-11T20:05:09Z", "type": "commit"}, {"oid": "c7d7c0d98b63cd9682c96b00fece7a0c7aac1c71", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c7d7c0d98b63cd9682c96b00fece7a0c7aac1c71", "message": "Add new nodes", "committedDate": "2020-08-11T20:05:09Z", "type": "commit"}, {"oid": "79d7825cbfa38c650ea1423a7dfa8c4d0fe24f14", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/79d7825cbfa38c650ea1423a7dfa8c4d0fe24f14", "message": "Add the formatter core", "committedDate": "2020-08-11T20:05:09Z", "type": "commit"}, {"oid": "3cc9caaf7489c97c369867f48b93295c024b0c5e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3cc9caaf7489c97c369867f48b93295c024b0c5e", "message": "Add the formatter core APIs", "committedDate": "2020-08-11T20:05:09Z", "type": "commit"}, {"oid": "45b0af4f27336db647feb409a8c6816d29b46092", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/45b0af4f27336db647feb409a8c6816d29b46092", "message": "Add the formatter core test suite", "committedDate": "2020-08-11T20:05:09Z", "type": "commit"}, {"oid": "ffa71196c3043441e547dae49ad3d74c22c99114", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ffa71196c3043441e547dae49ad3d74c22c99114", "message": "Add leading new line to function definition", "committedDate": "2020-08-11T20:05:09Z", "type": "commit"}, {"oid": "fa1422fdb1dd426a48732cfc00b5a6d873e0f7f6", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fa1422fdb1dd426a48732cfc00b5a6d873e0f7f6", "message": "Add the formatter cli", "committedDate": "2020-08-11T20:05:09Z", "type": "commit"}, {"oid": "dd98c472775d2233ff79d46718d4c851ac167547", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/dd98c472775d2233ff79d46718d4c851ac167547", "message": "Remove formatter from the language server", "committedDate": "2020-08-11T20:05:10Z", "type": "commit"}, {"oid": "a79966e367113c7cc3fe0ef9a3200a5e2c3458ca", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a79966e367113c7cc3fe0ef9a3200a5e2c3458ca", "message": "Fix formatting issues", "committedDate": "2020-08-11T20:05:10Z", "type": "commit"}, {"oid": "711b6c3c96aede00a07cafb74e7cad7b0be1d521", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/711b6c3c96aede00a07cafb74e7cad7b0be1d521", "message": "Improve the test suite structure", "committedDate": "2020-08-11T20:05:10Z", "type": "commit"}, {"oid": "30a521b10a33dcbb05652b1abdd7a85e37992cab", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/30a521b10a33dcbb05652b1abdd7a85e37992cab", "message": "Add nil type formatting", "committedDate": "2020-08-11T20:05:10Z", "type": "commit"}, {"oid": "696decbda417b88b919a3fefbc63ada994e4e7dc", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/696decbda417b88b919a3fefbc63ada994e4e7dc", "message": "Fix the comment dropping issue", "committedDate": "2020-08-11T20:05:10Z", "type": "commit"}, {"oid": "5bc076b27acb0e77137815d191e823586def80e6", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5bc076b27acb0e77137815d191e823586def80e6", "message": "Add the union type transformer", "committedDate": "2020-08-11T20:05:10Z", "type": "commit"}, {"oid": "ae6a4d7b4132d195bfec84402e17cc01cc8d0316", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ae6a4d7b4132d195bfec84402e17cc01cc8d0316", "message": "Add the XML transformers", "committedDate": "2020-08-11T20:05:10Z", "type": "commit"}, {"oid": "c1363eebc316795c6c9375404671531bc53fbed7", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c1363eebc316795c6c9375404671531bc53fbed7", "message": "Add template expression transformation and other fixes", "committedDate": "2020-08-11T20:05:10Z", "type": "commit"}, {"oid": "a3789a1755792275600d0d0f6972099eb2e3697d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a3789a1755792275600d0d0f6972099eb2e3697d", "message": "Add byte array literal transformation", "committedDate": "2020-08-11T20:05:10Z", "type": "commit"}, {"oid": "febdc51a7cb8e2ad0bc8d13167ff481413b259bd", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/febdc51a7cb8e2ad0bc8d13167ff481413b259bd", "message": "Add new node transformers", "committedDate": "2020-08-11T20:05:10Z", "type": "commit"}, {"oid": "37a41cde3cca1edeff5840339ac5919283ff745e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/37a41cde3cca1edeff5840339ac5919283ff745e", "message": "Fail test cases on compilation errors", "committedDate": "2020-08-11T20:05:10Z", "type": "commit"}, {"oid": "812de374e58f55e86c675860d4d1c5c64b8e3d43", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/812de374e58f55e86c675860d4d1c5c64b8e3d43", "message": "Refactor the code", "committedDate": "2020-08-11T20:05:10Z", "type": "commit"}, {"oid": "8cbc0da4a67e50a2b78abdcb680f0ba397e20a1c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8cbc0da4a67e50a2b78abdcb680f0ba397e20a1c", "message": "Update the license headers", "committedDate": "2020-08-11T20:05:10Z", "type": "commit"}, {"oid": "a671db81e16a811e7cf1f5a13830adb87f3b7340", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a671db81e16a811e7cf1f5a13830adb87f3b7340", "message": "Fix the API changes", "committedDate": "2020-08-11T20:05:11Z", "type": "commit"}, {"oid": "6b4fd22b79e5719a07c8b6dd2499f593bad7262f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6b4fd22b79e5719a07c8b6dd2499f593bad7262f", "message": "Refactor and complete test framework", "committedDate": "2020-08-11T20:05:11Z", "type": "commit"}, {"oid": "6b4fd22b79e5719a07c8b6dd2499f593bad7262f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6b4fd22b79e5719a07c8b6dd2499f593bad7262f", "message": "Refactor and complete test framework", "committedDate": "2020-08-11T20:05:11Z", "type": "forcePushed"}, {"oid": "d66ad69ee6bcd77f3c712b6d550e6c0207fd1ade", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d66ad69ee6bcd77f3c712b6d550e6c0207fd1ade", "message": "Implementation of the formatter CLI tool", "committedDate": "2020-08-11T23:43:08Z", "type": "commit"}, {"oid": "fa9b25d798e56f84c703525e5cce98ff757f7d62", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fa9b25d798e56f84c703525e5cce98ff757f7d62", "message": "Refactor dependencies in formatter CLI", "committedDate": "2020-08-11T23:54:29Z", "type": "commit"}, {"oid": "fb76e00c3d3a8755e41d17a5ce6d6b31b8e5eef1", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fb76e00c3d3a8755e41d17a5ce6d6b31b8e5eef1", "message": "Improvements to formatter APIs", "committedDate": "2020-08-12T00:39:50Z", "type": "commit"}, {"oid": "1180e9947470e963cc92f649e3e0096c09f34dd5", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1180e9947470e963cc92f649e3e0096c09f34dd5", "message": "Fix an API change", "committedDate": "2020-08-12T00:45:40Z", "type": "commit"}, {"oid": "e7e19c051e00c96639d8193a84f3c9264c9e1b61", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e7e19c051e00c96639d8193a84f3c9264c9e1b61", "message": "Refactoring the test cases", "committedDate": "2020-08-12T06:05:07Z", "type": "commit"}, {"oid": "85029404a6672a4d0d0d519148be5b133324530f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/85029404a6672a4d0d0d519148be5b133324530f", "message": "Fix the wondows issue", "committedDate": "2020-08-12T06:53:11Z", "type": "commit"}, {"oid": "9666bd40db5961231e8a04a755f680a17d3ac014", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9666bd40db5961231e8a04a755f680a17d3ac014", "message": "Improvements to the formatter CLI", "committedDate": "2020-08-12T07:17:24Z", "type": "commit"}, {"oid": "0fc8ed4f0e71d1519a4dd45d3fae63a3dc5b8865", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0fc8ed4f0e71d1519a4dd45d3fae63a3dc5b8865", "message": "Remove the previous ballerina formatter module", "committedDate": "2020-08-12T07:21:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1NjMyMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469056323", "bodyText": "If there a bal files inside nested directories of the module directory, then the file path gets changed?", "author": "hemikak", "createdAt": "2020-08-12T07:21:37Z", "path": "misc/formatter/modules/formatter-cli/src/main/java/org/ballerinalang/formatter/cli/FormatUtil.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.cli;\n+\n+import org.ballerinalang.compiler.CompilerPhase;\n+import org.ballerinalang.formatter.core.Formatter;\n+import org.ballerinalang.tool.BLauncherCmd;\n+import org.ballerinalang.tool.LauncherUtils;\n+import org.wso2.ballerinalang.compiler.Compiler;\n+import org.wso2.ballerinalang.compiler.tree.BLangCompilationUnit;\n+import org.wso2.ballerinalang.compiler.tree.BLangPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangTestablePackage;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.CompilerOptions;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintStream;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+import static org.ballerinalang.compiler.CompilerOptionName.COMPILER_PHASE;\n+import static org.ballerinalang.compiler.CompilerOptionName.EXPERIMENTAL_FEATURES_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.LOCK_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.NEW_PARSER_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.OFFLINE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PRESERVE_WHITESPACE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PROJECT_DIR;\n+import static org.ballerinalang.compiler.CompilerOptionName.SKIP_TESTS;\n+import static org.ballerinalang.compiler.CompilerOptionName.TEST_ENABLED;\n+\n+/**\n+ * Util class for compilation and format execution for formatting CLI tool.\n+ */\n+class FormatUtil {\n+    static final String CMD_NAME = \"format\";\n+    private static final PrintStream outStream = System.err;\n+    private static EmptyPrintStream emptyPrintStream;\n+\n+    /**\n+     * Execute formatter.\n+     *\n+     * @param argList        argument list from the console\n+     * @param helpFlag       flag to get the help page\n+     * @param dryRun         run the whole formatting\n+     * @param sourceRootPath execution path\n+     */\n+    static void execute(List<String> argList, boolean helpFlag, boolean dryRun, Path sourceRootPath) {\n+        if (helpFlag) {\n+            String commandUsageInfo = BLauncherCmd.getCommandUsageInfo(CMD_NAME);\n+            outStream.println(commandUsageInfo);\n+            return;\n+        }\n+\n+        if (argList != null && argList.size() > 1) {\n+            throw LauncherUtils.createLauncherException(Messages.getArgumentError());\n+        }\n+\n+        String moduleName;\n+        String ballerinaFilePath;\n+\n+        try {\n+            // If parameters are available user has given either the module name or the ballerina file path.\n+            // Else user is in a ballerina project and expecting to format the whole ballerina project\n+            if (argList != null && !argList.isEmpty()) {\n+                if (FormatUtil.isBalFile(argList.get(0))) {\n+                    ballerinaFilePath = argList.get(0);\n+                    Path filePath = Paths.get(ballerinaFilePath);\n+\n+                    // If the file doesn't exist or is a directory.\n+                    if (!filePath.toFile().exists() || filePath.toFile().isDirectory()) {\n+                        throw LauncherUtils.createLauncherException(Messages.getNoBallerinaFile(ballerinaFilePath));\n+                    }\n+\n+                    String source = new String(Files.readAllBytes(filePath), StandardCharsets.UTF_8);\n+                    // Format and get the generated formatted source code content.\n+                    String formattedSourceCode = Formatter.format(source);\n+\n+                    if (doChangesAvailable(source, formattedSourceCode)) {\n+                        if (!dryRun) {\n+                            // Write the formatted content back to the file.\n+                            FormatUtil.writeFile(filePath.toAbsolutePath().toString(), formattedSourceCode);\n+                            outStream.println(Messages.getModifiedFiles() + System.lineSeparator() + ballerinaFilePath);\n+                            outStream.println(System.lineSeparator() + Messages.getSuccessMessage());\n+                        } else {\n+                            outStream.println(Messages.getFilesToModify() + System.lineSeparator() + ballerinaFilePath);\n+                        }\n+                    } else {\n+                        outStream.println(Messages.getNoChanges());\n+                    }\n+                } else if (Paths.get(argList.get(0)).toFile().isFile()) {\n+                    // If file is a regular file but not a ballerina source file\n+                    // throw the following exception.\n+                    throw LauncherUtils.createLauncherException(Messages.getNotABallerinaFile());\n+                } else {\n+                    moduleName = argList.get(0);\n+\n+                    // Check whether the module dir exists.\n+                    if (!FormatUtil.isModuleExist(moduleName, sourceRootPath)) {\n+                        // If module directory doesn't exist and contains a \".\"\n+                        // throw a exception to say file or module doesn't exist.\n+                        // Else throw a exception to say module doesn't exist.\n+                        if (moduleName.contains(\".\")) {\n+                            throw LauncherUtils.createLauncherException(Messages\n+                                    .getNoBallerinaModuleOrFile(moduleName));\n+                        } else {\n+                            throw LauncherUtils.createLauncherException(Messages.getNoModuleFound(moduleName));\n+                        }\n+                    }\n+\n+                    // Check whether the given directory is not in a ballerina project.\n+                    if (FormatUtil.notABallerinaProject(sourceRootPath)) {\n+                        throw LauncherUtils.createLauncherException(Messages.getNotBallerinaProject());\n+                    }\n+                    BLangPackage bLangPackage = FormatUtil\n+                            .compileModule(sourceRootPath, getModuleName(moduleName));\n+\n+                    // Iterate and format the ballerina package.\n+                    List<String> formattedFiles = iterateAndFormat(bLangPackage, sourceRootPath, dryRun);\n+                    generateChangeReport(formattedFiles, dryRun);\n+                }\n+            } else {\n+                List<BLangPackage> packages = FormatUtil.compileProject(sourceRootPath);\n+                List<String> formattedFiles = new ArrayList<>();\n+                // Iterate and format all the ballerina packages.\n+                for (BLangPackage bLangPackage : packages) {\n+                    formattedFiles.addAll(iterateAndFormat(bLangPackage, sourceRootPath, dryRun));\n+                }\n+\n+                generateChangeReport(formattedFiles, dryRun);\n+            }\n+        } catch (IOException | NullPointerException e) {\n+            throw LauncherUtils.createLauncherException(Messages.getException());\n+        }\n+    }\n+\n+    private static void generateChangeReport(List<String> formattedFiles, boolean dryRun) {\n+        if (!formattedFiles.isEmpty()) {\n+            StringBuilder fileList = new StringBuilder();\n+            if (dryRun) {\n+                fileList.append(Messages.getFilesToModify()).append(System.lineSeparator());\n+            } else {\n+                fileList.append(Messages.getModifiedFiles()).append(System.lineSeparator());\n+            }\n+            for (String file : formattedFiles) {\n+                fileList.append(file).append(System.lineSeparator());\n+            }\n+            outStream.println(fileList.toString());\n+            if (!dryRun) {\n+                outStream.println(Messages.getSuccessMessage());\n+            }\n+        } else {\n+            outStream.println(Messages.getNoChanges());\n+        }\n+    }\n+\n+    private static String getModuleName(String moduleName) {\n+        String pattern = Pattern.quote(File.separator);\n+        String[] splitedTokens = moduleName.split(pattern);\n+        return splitedTokens[splitedTokens.length - 1];\n+    }\n+\n+    /**\n+     * Compile whole ballerina project.\n+     *\n+     * @param sourceRoot source root\n+     * @return {@link List<BLangPackage>} list of BLangPackages\n+     */\n+    private static List<BLangPackage> compileProject(Path sourceRoot) throws UnsupportedEncodingException {\n+        emptyPrintStream = new EmptyPrintStream();\n+        CompilerContext context = getCompilerContext(sourceRoot);\n+        Compiler compiler = Compiler.getInstance(context);\n+        // Set an EmptyPrintStream to hide unnecessary outputs from compiler.\n+        compiler.setOutStream(emptyPrintStream);\n+        return compiler.compilePackages(false);\n+    }\n+\n+    /**\n+     * Compile only a ballerina module.\n+     *\n+     * @param sourceRoot source root\n+     * @param moduleName name of the module to be compiled\n+     * @return {@link BLangPackage} ballerina package\n+     */\n+    private static BLangPackage compileModule(Path sourceRoot, String moduleName) throws UnsupportedEncodingException {\n+        emptyPrintStream = new EmptyPrintStream();\n+        CompilerContext context = getCompilerContext(sourceRoot);\n+        Compiler compiler = Compiler.getInstance(context);\n+        // Set an EmptyPrintStream to hide unnecessary outputs from compiler.\n+        compiler.setOutStream(emptyPrintStream);\n+        return compiler.compile(moduleName);\n+    }\n+\n+    private static void formatAndWrite(BLangCompilationUnit compilationUnit, Path sourceRootPath,\n+                                       List<String> formattedFiles, boolean dryRun) throws IOException {\n+        String fileName = sourceRootPath.toString() + File.separator\n+                + \"src\"\n+                + File.separator\n+                + compilationUnit.getPosition().getSource().getPackageName()\n+                + File.separator\n+                + compilationUnit.getPosition().getSource().getCompilationUnitName();", "originalCommit": "85029404a6672a4d0d0d519148be5b133324530f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA5ODg3Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469098872", "bodyText": "This formatAndWrite function is called iteratively for each BLangCompilationUnit. The getCompilationUnits() function used to obtain the compilation units resolves the .bal files residing inside subdirectories as well.", "author": "IrushiL", "createdAt": "2020-08-12T08:37:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1NjMyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1NzU0OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469057549", "bodyText": "Dry run is hidden ? Why ?", "author": "hemikak", "createdAt": "2020-08-12T07:23:55Z", "path": "misc/formatter/modules/formatter-cli/src/main/java/org/ballerinalang/formatter/cli/FormatCmd.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.cli;\n+\n+import org.ballerinalang.tool.BLauncherCmd;\n+import picocli.CommandLine;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+/**\n+ * Class to implement \"format\" command for ballerina.\n+ * Ex: ballerina format [ballerinaFile | ModuleName] [-d | --dry-run]\n+ */\n+@CommandLine.Command(name = \"format\", description = \"format given Ballerina source file\")\n+public class FormatCmd implements BLauncherCmd {\n+    private static final String USER_DIR = \"user.dir\";\n+    private static final String NOT_SUPPORTED_MESSAGE = \"user.dir\";\n+\n+    @CommandLine.Parameters\n+    private List<String> argList;\n+\n+    @CommandLine.Option(names = {\"-h\", \"--help\"}, hidden = true)\n+    private boolean helpFlag;\n+\n+    @CommandLine.Option(names = {\"-d\", \"--dry-run\"}, hidden = true)", "originalCommit": "85029404a6672a4d0d0d519148be5b133324530f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4MTg3NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469081874", "bodyText": "Removed the hidden attribute.", "author": "IrushiL", "createdAt": "2020-08-12T08:09:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1NzU0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1NzY4OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469057688", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    // throw a exception to say file or module doesn't exist.\n          \n          \n            \n                                    // throw an exception to say file or module doesn't exist.", "author": "azinneera", "createdAt": "2020-08-12T07:24:12Z", "path": "misc/formatter/modules/formatter-cli/src/main/java/org/ballerinalang/formatter/cli/FormatUtil.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.cli;\n+\n+import org.ballerinalang.compiler.CompilerPhase;\n+import org.ballerinalang.formatter.core.Formatter;\n+import org.ballerinalang.tool.BLauncherCmd;\n+import org.ballerinalang.tool.LauncherUtils;\n+import org.wso2.ballerinalang.compiler.Compiler;\n+import org.wso2.ballerinalang.compiler.tree.BLangCompilationUnit;\n+import org.wso2.ballerinalang.compiler.tree.BLangPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangTestablePackage;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.CompilerOptions;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintStream;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+import static org.ballerinalang.compiler.CompilerOptionName.COMPILER_PHASE;\n+import static org.ballerinalang.compiler.CompilerOptionName.EXPERIMENTAL_FEATURES_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.LOCK_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.NEW_PARSER_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.OFFLINE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PRESERVE_WHITESPACE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PROJECT_DIR;\n+import static org.ballerinalang.compiler.CompilerOptionName.SKIP_TESTS;\n+import static org.ballerinalang.compiler.CompilerOptionName.TEST_ENABLED;\n+\n+/**\n+ * Util class for compilation and format execution for formatting CLI tool.\n+ */\n+class FormatUtil {\n+    static final String CMD_NAME = \"format\";\n+    private static final PrintStream outStream = System.err;\n+    private static EmptyPrintStream emptyPrintStream;\n+\n+    /**\n+     * Execute formatter.\n+     *\n+     * @param argList        argument list from the console\n+     * @param helpFlag       flag to get the help page\n+     * @param dryRun         run the whole formatting\n+     * @param sourceRootPath execution path\n+     */\n+    static void execute(List<String> argList, boolean helpFlag, boolean dryRun, Path sourceRootPath) {\n+        if (helpFlag) {\n+            String commandUsageInfo = BLauncherCmd.getCommandUsageInfo(CMD_NAME);\n+            outStream.println(commandUsageInfo);\n+            return;\n+        }\n+\n+        if (argList != null && argList.size() > 1) {\n+            throw LauncherUtils.createLauncherException(Messages.getArgumentError());\n+        }\n+\n+        String moduleName;\n+        String ballerinaFilePath;\n+\n+        try {\n+            // If parameters are available user has given either the module name or the ballerina file path.\n+            // Else user is in a ballerina project and expecting to format the whole ballerina project\n+            if (argList != null && !argList.isEmpty()) {\n+                if (FormatUtil.isBalFile(argList.get(0))) {\n+                    ballerinaFilePath = argList.get(0);\n+                    Path filePath = Paths.get(ballerinaFilePath);\n+\n+                    // If the file doesn't exist or is a directory.\n+                    if (!filePath.toFile().exists() || filePath.toFile().isDirectory()) {\n+                        throw LauncherUtils.createLauncherException(Messages.getNoBallerinaFile(ballerinaFilePath));\n+                    }\n+\n+                    String source = new String(Files.readAllBytes(filePath), StandardCharsets.UTF_8);\n+                    // Format and get the generated formatted source code content.\n+                    String formattedSourceCode = Formatter.format(source);\n+\n+                    if (doChangesAvailable(source, formattedSourceCode)) {\n+                        if (!dryRun) {\n+                            // Write the formatted content back to the file.\n+                            FormatUtil.writeFile(filePath.toAbsolutePath().toString(), formattedSourceCode);\n+                            outStream.println(Messages.getModifiedFiles() + System.lineSeparator() + ballerinaFilePath);\n+                            outStream.println(System.lineSeparator() + Messages.getSuccessMessage());\n+                        } else {\n+                            outStream.println(Messages.getFilesToModify() + System.lineSeparator() + ballerinaFilePath);\n+                        }\n+                    } else {\n+                        outStream.println(Messages.getNoChanges());\n+                    }\n+                } else if (Paths.get(argList.get(0)).toFile().isFile()) {\n+                    // If file is a regular file but not a ballerina source file\n+                    // throw the following exception.\n+                    throw LauncherUtils.createLauncherException(Messages.getNotABallerinaFile());\n+                } else {\n+                    moduleName = argList.get(0);\n+\n+                    // Check whether the module dir exists.\n+                    if (!FormatUtil.isModuleExist(moduleName, sourceRootPath)) {\n+                        // If module directory doesn't exist and contains a \".\"\n+                        // throw a exception to say file or module doesn't exist.", "originalCommit": "85029404a6672a4d0d0d519148be5b133324530f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4MTcxNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469081714", "bodyText": "Done", "author": "IrushiL", "createdAt": "2020-08-12T08:09:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1NzY4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1NzkxNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469057917", "bodyText": "Should tests run ?", "author": "hemikak", "createdAt": "2020-08-12T07:24:39Z", "path": "misc/formatter/modules/formatter-cli/src/main/java/org/ballerinalang/formatter/cli/FormatUtil.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.cli;\n+\n+import org.ballerinalang.compiler.CompilerPhase;\n+import org.ballerinalang.formatter.core.Formatter;\n+import org.ballerinalang.tool.BLauncherCmd;\n+import org.ballerinalang.tool.LauncherUtils;\n+import org.wso2.ballerinalang.compiler.Compiler;\n+import org.wso2.ballerinalang.compiler.tree.BLangCompilationUnit;\n+import org.wso2.ballerinalang.compiler.tree.BLangPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangTestablePackage;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.CompilerOptions;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintStream;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+import static org.ballerinalang.compiler.CompilerOptionName.COMPILER_PHASE;\n+import static org.ballerinalang.compiler.CompilerOptionName.EXPERIMENTAL_FEATURES_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.LOCK_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.NEW_PARSER_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.OFFLINE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PRESERVE_WHITESPACE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PROJECT_DIR;\n+import static org.ballerinalang.compiler.CompilerOptionName.SKIP_TESTS;\n+import static org.ballerinalang.compiler.CompilerOptionName.TEST_ENABLED;\n+\n+/**\n+ * Util class for compilation and format execution for formatting CLI tool.\n+ */\n+class FormatUtil {\n+    static final String CMD_NAME = \"format\";\n+    private static final PrintStream outStream = System.err;\n+    private static EmptyPrintStream emptyPrintStream;\n+\n+    /**\n+     * Execute formatter.\n+     *\n+     * @param argList        argument list from the console\n+     * @param helpFlag       flag to get the help page\n+     * @param dryRun         run the whole formatting\n+     * @param sourceRootPath execution path\n+     */\n+    static void execute(List<String> argList, boolean helpFlag, boolean dryRun, Path sourceRootPath) {\n+        if (helpFlag) {\n+            String commandUsageInfo = BLauncherCmd.getCommandUsageInfo(CMD_NAME);\n+            outStream.println(commandUsageInfo);\n+            return;\n+        }\n+\n+        if (argList != null && argList.size() > 1) {\n+            throw LauncherUtils.createLauncherException(Messages.getArgumentError());\n+        }\n+\n+        String moduleName;\n+        String ballerinaFilePath;\n+\n+        try {\n+            // If parameters are available user has given either the module name or the ballerina file path.\n+            // Else user is in a ballerina project and expecting to format the whole ballerina project\n+            if (argList != null && !argList.isEmpty()) {\n+                if (FormatUtil.isBalFile(argList.get(0))) {\n+                    ballerinaFilePath = argList.get(0);\n+                    Path filePath = Paths.get(ballerinaFilePath);\n+\n+                    // If the file doesn't exist or is a directory.\n+                    if (!filePath.toFile().exists() || filePath.toFile().isDirectory()) {\n+                        throw LauncherUtils.createLauncherException(Messages.getNoBallerinaFile(ballerinaFilePath));\n+                    }\n+\n+                    String source = new String(Files.readAllBytes(filePath), StandardCharsets.UTF_8);\n+                    // Format and get the generated formatted source code content.\n+                    String formattedSourceCode = Formatter.format(source);\n+\n+                    if (doChangesAvailable(source, formattedSourceCode)) {\n+                        if (!dryRun) {\n+                            // Write the formatted content back to the file.\n+                            FormatUtil.writeFile(filePath.toAbsolutePath().toString(), formattedSourceCode);\n+                            outStream.println(Messages.getModifiedFiles() + System.lineSeparator() + ballerinaFilePath);\n+                            outStream.println(System.lineSeparator() + Messages.getSuccessMessage());\n+                        } else {\n+                            outStream.println(Messages.getFilesToModify() + System.lineSeparator() + ballerinaFilePath);\n+                        }\n+                    } else {\n+                        outStream.println(Messages.getNoChanges());\n+                    }\n+                } else if (Paths.get(argList.get(0)).toFile().isFile()) {\n+                    // If file is a regular file but not a ballerina source file\n+                    // throw the following exception.\n+                    throw LauncherUtils.createLauncherException(Messages.getNotABallerinaFile());\n+                } else {\n+                    moduleName = argList.get(0);\n+\n+                    // Check whether the module dir exists.\n+                    if (!FormatUtil.isModuleExist(moduleName, sourceRootPath)) {\n+                        // If module directory doesn't exist and contains a \".\"\n+                        // throw a exception to say file or module doesn't exist.\n+                        // Else throw a exception to say module doesn't exist.\n+                        if (moduleName.contains(\".\")) {\n+                            throw LauncherUtils.createLauncherException(Messages\n+                                    .getNoBallerinaModuleOrFile(moduleName));\n+                        } else {\n+                            throw LauncherUtils.createLauncherException(Messages.getNoModuleFound(moduleName));\n+                        }\n+                    }\n+\n+                    // Check whether the given directory is not in a ballerina project.\n+                    if (FormatUtil.notABallerinaProject(sourceRootPath)) {\n+                        throw LauncherUtils.createLauncherException(Messages.getNotBallerinaProject());\n+                    }\n+                    BLangPackage bLangPackage = FormatUtil\n+                            .compileModule(sourceRootPath, getModuleName(moduleName));\n+\n+                    // Iterate and format the ballerina package.\n+                    List<String> formattedFiles = iterateAndFormat(bLangPackage, sourceRootPath, dryRun);\n+                    generateChangeReport(formattedFiles, dryRun);\n+                }\n+            } else {\n+                List<BLangPackage> packages = FormatUtil.compileProject(sourceRootPath);\n+                List<String> formattedFiles = new ArrayList<>();\n+                // Iterate and format all the ballerina packages.\n+                for (BLangPackage bLangPackage : packages) {\n+                    formattedFiles.addAll(iterateAndFormat(bLangPackage, sourceRootPath, dryRun));\n+                }\n+\n+                generateChangeReport(formattedFiles, dryRun);\n+            }\n+        } catch (IOException | NullPointerException e) {\n+            throw LauncherUtils.createLauncherException(Messages.getException());\n+        }\n+    }\n+\n+    private static void generateChangeReport(List<String> formattedFiles, boolean dryRun) {\n+        if (!formattedFiles.isEmpty()) {\n+            StringBuilder fileList = new StringBuilder();\n+            if (dryRun) {\n+                fileList.append(Messages.getFilesToModify()).append(System.lineSeparator());\n+            } else {\n+                fileList.append(Messages.getModifiedFiles()).append(System.lineSeparator());\n+            }\n+            for (String file : formattedFiles) {\n+                fileList.append(file).append(System.lineSeparator());\n+            }\n+            outStream.println(fileList.toString());\n+            if (!dryRun) {\n+                outStream.println(Messages.getSuccessMessage());\n+            }\n+        } else {\n+            outStream.println(Messages.getNoChanges());\n+        }\n+    }\n+\n+    private static String getModuleName(String moduleName) {\n+        String pattern = Pattern.quote(File.separator);\n+        String[] splitedTokens = moduleName.split(pattern);\n+        return splitedTokens[splitedTokens.length - 1];\n+    }\n+\n+    /**\n+     * Compile whole ballerina project.\n+     *\n+     * @param sourceRoot source root\n+     * @return {@link List<BLangPackage>} list of BLangPackages\n+     */\n+    private static List<BLangPackage> compileProject(Path sourceRoot) throws UnsupportedEncodingException {\n+        emptyPrintStream = new EmptyPrintStream();\n+        CompilerContext context = getCompilerContext(sourceRoot);\n+        Compiler compiler = Compiler.getInstance(context);\n+        // Set an EmptyPrintStream to hide unnecessary outputs from compiler.\n+        compiler.setOutStream(emptyPrintStream);\n+        return compiler.compilePackages(false);\n+    }\n+\n+    /**\n+     * Compile only a ballerina module.\n+     *\n+     * @param sourceRoot source root\n+     * @param moduleName name of the module to be compiled\n+     * @return {@link BLangPackage} ballerina package\n+     */\n+    private static BLangPackage compileModule(Path sourceRoot, String moduleName) throws UnsupportedEncodingException {\n+        emptyPrintStream = new EmptyPrintStream();\n+        CompilerContext context = getCompilerContext(sourceRoot);\n+        Compiler compiler = Compiler.getInstance(context);\n+        // Set an EmptyPrintStream to hide unnecessary outputs from compiler.\n+        compiler.setOutStream(emptyPrintStream);\n+        return compiler.compile(moduleName);\n+    }\n+\n+    private static void formatAndWrite(BLangCompilationUnit compilationUnit, Path sourceRootPath,\n+                                       List<String> formattedFiles, boolean dryRun) throws IOException {\n+        String fileName = sourceRootPath.toString() + File.separator\n+                + \"src\"\n+                + File.separator\n+                + compilationUnit.getPosition().getSource().getPackageName()\n+                + File.separator\n+                + compilationUnit.getPosition().getSource().getCompilationUnitName();\n+\n+        // Format and get the formatted source.\n+        String formattedSource = Formatter.format(new String(Files.readAllBytes(Paths.get(fileName)),\n+                StandardCharsets.UTF_8));\n+\n+        if (doChangesAvailable(formattedSource, formattedSource)) {\n+            if (!dryRun) {\n+                // Write formatted content to the file.\n+                FormatUtil.writeFile(fileName, formattedSource);\n+            }\n+            formattedFiles.add(fileName);\n+        }\n+    }\n+\n+    private static List<String> iterateAndFormat(BLangPackage bLangPackage, Path sourceRootPath, boolean dryRun)\n+            throws IOException {\n+        List<String> formattedFiles = new ArrayList<>();\n+\n+        // Iterate compilation units and format.\n+        for (BLangCompilationUnit compilationUnit : bLangPackage.getCompilationUnits()) {\n+            formatAndWrite(compilationUnit, sourceRootPath, formattedFiles, dryRun);\n+        }\n+\n+        // Iterate testable packages and format.\n+        for (BLangTestablePackage testablePackage : bLangPackage.getTestablePkgs()) {\n+            for (BLangCompilationUnit compilationUnit : testablePackage.getCompilationUnits()) {\n+                formatAndWrite(compilationUnit, sourceRootPath, formattedFiles, dryRun);\n+            }\n+        }\n+\n+        return formattedFiles;\n+    }\n+\n+    /**\n+     * Get prepared compiler context.\n+     *\n+     * @param sourceRootPath ballerina compilable source root path\n+     * @return {@link CompilerContext} compiler context\n+     */\n+    private static CompilerContext getCompilerContext(Path sourceRootPath) {\n+        CompilerPhase compilerPhase = CompilerPhase.DEFINE;\n+        CompilerContext context = new CompilerContext();\n+        CompilerOptions options = CompilerOptions.getInstance(context);\n+        options.put(PROJECT_DIR, sourceRootPath.toString());\n+        options.put(OFFLINE, Boolean.toString(false));\n+        options.put(COMPILER_PHASE, compilerPhase.toString());\n+        options.put(SKIP_TESTS, Boolean.toString(false));\n+        options.put(TEST_ENABLED, \"true\");", "originalCommit": "85029404a6672a4d0d0d519148be5b133324530f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4MTQ3OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469081478", "bodyText": "Since this is for the formatting purpose, running tests is not required.", "author": "IrushiL", "createdAt": "2020-08-12T08:08:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1NzkxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1ODYwOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469058609", "bodyText": "Better function name would be isBallerinaProject instead of negative reply.", "author": "hemikak", "createdAt": "2020-08-12T07:26:02Z", "path": "misc/formatter/modules/formatter-cli/src/main/java/org/ballerinalang/formatter/cli/FormatUtil.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.cli;\n+\n+import org.ballerinalang.compiler.CompilerPhase;\n+import org.ballerinalang.formatter.core.Formatter;\n+import org.ballerinalang.tool.BLauncherCmd;\n+import org.ballerinalang.tool.LauncherUtils;\n+import org.wso2.ballerinalang.compiler.Compiler;\n+import org.wso2.ballerinalang.compiler.tree.BLangCompilationUnit;\n+import org.wso2.ballerinalang.compiler.tree.BLangPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangTestablePackage;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.CompilerOptions;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintStream;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+import static org.ballerinalang.compiler.CompilerOptionName.COMPILER_PHASE;\n+import static org.ballerinalang.compiler.CompilerOptionName.EXPERIMENTAL_FEATURES_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.LOCK_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.NEW_PARSER_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.OFFLINE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PRESERVE_WHITESPACE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PROJECT_DIR;\n+import static org.ballerinalang.compiler.CompilerOptionName.SKIP_TESTS;\n+import static org.ballerinalang.compiler.CompilerOptionName.TEST_ENABLED;\n+\n+/**\n+ * Util class for compilation and format execution for formatting CLI tool.\n+ */\n+class FormatUtil {\n+    static final String CMD_NAME = \"format\";\n+    private static final PrintStream outStream = System.err;\n+    private static EmptyPrintStream emptyPrintStream;\n+\n+    /**\n+     * Execute formatter.\n+     *\n+     * @param argList        argument list from the console\n+     * @param helpFlag       flag to get the help page\n+     * @param dryRun         run the whole formatting\n+     * @param sourceRootPath execution path\n+     */\n+    static void execute(List<String> argList, boolean helpFlag, boolean dryRun, Path sourceRootPath) {\n+        if (helpFlag) {\n+            String commandUsageInfo = BLauncherCmd.getCommandUsageInfo(CMD_NAME);\n+            outStream.println(commandUsageInfo);\n+            return;\n+        }\n+\n+        if (argList != null && argList.size() > 1) {\n+            throw LauncherUtils.createLauncherException(Messages.getArgumentError());\n+        }\n+\n+        String moduleName;\n+        String ballerinaFilePath;\n+\n+        try {\n+            // If parameters are available user has given either the module name or the ballerina file path.\n+            // Else user is in a ballerina project and expecting to format the whole ballerina project\n+            if (argList != null && !argList.isEmpty()) {\n+                if (FormatUtil.isBalFile(argList.get(0))) {\n+                    ballerinaFilePath = argList.get(0);\n+                    Path filePath = Paths.get(ballerinaFilePath);\n+\n+                    // If the file doesn't exist or is a directory.\n+                    if (!filePath.toFile().exists() || filePath.toFile().isDirectory()) {\n+                        throw LauncherUtils.createLauncherException(Messages.getNoBallerinaFile(ballerinaFilePath));\n+                    }\n+\n+                    String source = new String(Files.readAllBytes(filePath), StandardCharsets.UTF_8);\n+                    // Format and get the generated formatted source code content.\n+                    String formattedSourceCode = Formatter.format(source);\n+\n+                    if (doChangesAvailable(source, formattedSourceCode)) {\n+                        if (!dryRun) {\n+                            // Write the formatted content back to the file.\n+                            FormatUtil.writeFile(filePath.toAbsolutePath().toString(), formattedSourceCode);\n+                            outStream.println(Messages.getModifiedFiles() + System.lineSeparator() + ballerinaFilePath);\n+                            outStream.println(System.lineSeparator() + Messages.getSuccessMessage());\n+                        } else {\n+                            outStream.println(Messages.getFilesToModify() + System.lineSeparator() + ballerinaFilePath);\n+                        }\n+                    } else {\n+                        outStream.println(Messages.getNoChanges());\n+                    }\n+                } else if (Paths.get(argList.get(0)).toFile().isFile()) {\n+                    // If file is a regular file but not a ballerina source file\n+                    // throw the following exception.\n+                    throw LauncherUtils.createLauncherException(Messages.getNotABallerinaFile());\n+                } else {\n+                    moduleName = argList.get(0);\n+\n+                    // Check whether the module dir exists.\n+                    if (!FormatUtil.isModuleExist(moduleName, sourceRootPath)) {\n+                        // If module directory doesn't exist and contains a \".\"\n+                        // throw a exception to say file or module doesn't exist.\n+                        // Else throw a exception to say module doesn't exist.\n+                        if (moduleName.contains(\".\")) {\n+                            throw LauncherUtils.createLauncherException(Messages\n+                                    .getNoBallerinaModuleOrFile(moduleName));\n+                        } else {\n+                            throw LauncherUtils.createLauncherException(Messages.getNoModuleFound(moduleName));\n+                        }\n+                    }\n+\n+                    // Check whether the given directory is not in a ballerina project.\n+                    if (FormatUtil.notABallerinaProject(sourceRootPath)) {\n+                        throw LauncherUtils.createLauncherException(Messages.getNotBallerinaProject());\n+                    }\n+                    BLangPackage bLangPackage = FormatUtil\n+                            .compileModule(sourceRootPath, getModuleName(moduleName));\n+\n+                    // Iterate and format the ballerina package.\n+                    List<String> formattedFiles = iterateAndFormat(bLangPackage, sourceRootPath, dryRun);\n+                    generateChangeReport(formattedFiles, dryRun);\n+                }\n+            } else {\n+                List<BLangPackage> packages = FormatUtil.compileProject(sourceRootPath);\n+                List<String> formattedFiles = new ArrayList<>();\n+                // Iterate and format all the ballerina packages.\n+                for (BLangPackage bLangPackage : packages) {\n+                    formattedFiles.addAll(iterateAndFormat(bLangPackage, sourceRootPath, dryRun));\n+                }\n+\n+                generateChangeReport(formattedFiles, dryRun);\n+            }\n+        } catch (IOException | NullPointerException e) {\n+            throw LauncherUtils.createLauncherException(Messages.getException());\n+        }\n+    }\n+\n+    private static void generateChangeReport(List<String> formattedFiles, boolean dryRun) {\n+        if (!formattedFiles.isEmpty()) {\n+            StringBuilder fileList = new StringBuilder();\n+            if (dryRun) {\n+                fileList.append(Messages.getFilesToModify()).append(System.lineSeparator());\n+            } else {\n+                fileList.append(Messages.getModifiedFiles()).append(System.lineSeparator());\n+            }\n+            for (String file : formattedFiles) {\n+                fileList.append(file).append(System.lineSeparator());\n+            }\n+            outStream.println(fileList.toString());\n+            if (!dryRun) {\n+                outStream.println(Messages.getSuccessMessage());\n+            }\n+        } else {\n+            outStream.println(Messages.getNoChanges());\n+        }\n+    }\n+\n+    private static String getModuleName(String moduleName) {\n+        String pattern = Pattern.quote(File.separator);\n+        String[] splitedTokens = moduleName.split(pattern);\n+        return splitedTokens[splitedTokens.length - 1];\n+    }\n+\n+    /**\n+     * Compile whole ballerina project.\n+     *\n+     * @param sourceRoot source root\n+     * @return {@link List<BLangPackage>} list of BLangPackages\n+     */\n+    private static List<BLangPackage> compileProject(Path sourceRoot) throws UnsupportedEncodingException {\n+        emptyPrintStream = new EmptyPrintStream();\n+        CompilerContext context = getCompilerContext(sourceRoot);\n+        Compiler compiler = Compiler.getInstance(context);\n+        // Set an EmptyPrintStream to hide unnecessary outputs from compiler.\n+        compiler.setOutStream(emptyPrintStream);\n+        return compiler.compilePackages(false);\n+    }\n+\n+    /**\n+     * Compile only a ballerina module.\n+     *\n+     * @param sourceRoot source root\n+     * @param moduleName name of the module to be compiled\n+     * @return {@link BLangPackage} ballerina package\n+     */\n+    private static BLangPackage compileModule(Path sourceRoot, String moduleName) throws UnsupportedEncodingException {\n+        emptyPrintStream = new EmptyPrintStream();\n+        CompilerContext context = getCompilerContext(sourceRoot);\n+        Compiler compiler = Compiler.getInstance(context);\n+        // Set an EmptyPrintStream to hide unnecessary outputs from compiler.\n+        compiler.setOutStream(emptyPrintStream);\n+        return compiler.compile(moduleName);\n+    }\n+\n+    private static void formatAndWrite(BLangCompilationUnit compilationUnit, Path sourceRootPath,\n+                                       List<String> formattedFiles, boolean dryRun) throws IOException {\n+        String fileName = sourceRootPath.toString() + File.separator\n+                + \"src\"\n+                + File.separator\n+                + compilationUnit.getPosition().getSource().getPackageName()\n+                + File.separator\n+                + compilationUnit.getPosition().getSource().getCompilationUnitName();\n+\n+        // Format and get the formatted source.\n+        String formattedSource = Formatter.format(new String(Files.readAllBytes(Paths.get(fileName)),\n+                StandardCharsets.UTF_8));\n+\n+        if (doChangesAvailable(formattedSource, formattedSource)) {\n+            if (!dryRun) {\n+                // Write formatted content to the file.\n+                FormatUtil.writeFile(fileName, formattedSource);\n+            }\n+            formattedFiles.add(fileName);\n+        }\n+    }\n+\n+    private static List<String> iterateAndFormat(BLangPackage bLangPackage, Path sourceRootPath, boolean dryRun)\n+            throws IOException {\n+        List<String> formattedFiles = new ArrayList<>();\n+\n+        // Iterate compilation units and format.\n+        for (BLangCompilationUnit compilationUnit : bLangPackage.getCompilationUnits()) {\n+            formatAndWrite(compilationUnit, sourceRootPath, formattedFiles, dryRun);\n+        }\n+\n+        // Iterate testable packages and format.\n+        for (BLangTestablePackage testablePackage : bLangPackage.getTestablePkgs()) {\n+            for (BLangCompilationUnit compilationUnit : testablePackage.getCompilationUnits()) {\n+                formatAndWrite(compilationUnit, sourceRootPath, formattedFiles, dryRun);\n+            }\n+        }\n+\n+        return formattedFiles;\n+    }\n+\n+    /**\n+     * Get prepared compiler context.\n+     *\n+     * @param sourceRootPath ballerina compilable source root path\n+     * @return {@link CompilerContext} compiler context\n+     */\n+    private static CompilerContext getCompilerContext(Path sourceRootPath) {\n+        CompilerPhase compilerPhase = CompilerPhase.DEFINE;\n+        CompilerContext context = new CompilerContext();\n+        CompilerOptions options = CompilerOptions.getInstance(context);\n+        options.put(PROJECT_DIR, sourceRootPath.toString());\n+        options.put(OFFLINE, Boolean.toString(false));\n+        options.put(COMPILER_PHASE, compilerPhase.toString());\n+        options.put(SKIP_TESTS, Boolean.toString(false));\n+        options.put(TEST_ENABLED, \"true\");\n+        options.put(LOCK_ENABLED, Boolean.toString(false));\n+        options.put(EXPERIMENTAL_FEATURES_ENABLED, Boolean.toString(true));\n+        options.put(PRESERVE_WHITESPACE, Boolean.toString(true));\n+        options.put(NEW_PARSER_ENABLED, Boolean.toString(false));\n+\n+        return context;\n+    }\n+\n+    /**\n+     * Check whether the given module name exists.\n+     *\n+     * @param module      module name\n+     * @param projectRoot path of the ballerina project root\n+     * @return {@link Boolean} true or false\n+     */\n+    private static boolean isModuleExist(String module, Path projectRoot) {\n+        Path modulePath;\n+        if (module.startsWith(\"src/\")) {\n+            modulePath = projectRoot.resolve(module);\n+        } else {\n+            modulePath = projectRoot.resolve(\"src\").resolve(module);\n+        }\n+\n+        return modulePath.toFile().isDirectory();\n+    }\n+\n+    /**\n+     * Check whether the given path isn't a source root of a ballerina project.\n+     *\n+     * @param path - path where the command is executed from\n+     * @return {@link boolean} true or false\n+     */\n+    private static boolean notABallerinaProject(Path path) {", "originalCommit": "85029404a6672a4d0d0d519148be5b133324530f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4MTA0MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469081040", "bodyText": "Done", "author": "IrushiL", "createdAt": "2020-08-12T08:07:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1ODYwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1ODkwOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469058908", "bodyText": "Shall we append the original exception e as well? That would  give more information on the error.", "author": "azinneera", "createdAt": "2020-08-12T07:26:40Z", "path": "misc/formatter/modules/formatter-cli/src/main/java/org/ballerinalang/formatter/cli/FormatUtil.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.cli;\n+\n+import org.ballerinalang.compiler.CompilerPhase;\n+import org.ballerinalang.formatter.core.Formatter;\n+import org.ballerinalang.tool.BLauncherCmd;\n+import org.ballerinalang.tool.LauncherUtils;\n+import org.wso2.ballerinalang.compiler.Compiler;\n+import org.wso2.ballerinalang.compiler.tree.BLangCompilationUnit;\n+import org.wso2.ballerinalang.compiler.tree.BLangPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangTestablePackage;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.CompilerOptions;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintStream;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+import static org.ballerinalang.compiler.CompilerOptionName.COMPILER_PHASE;\n+import static org.ballerinalang.compiler.CompilerOptionName.EXPERIMENTAL_FEATURES_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.LOCK_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.NEW_PARSER_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.OFFLINE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PRESERVE_WHITESPACE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PROJECT_DIR;\n+import static org.ballerinalang.compiler.CompilerOptionName.SKIP_TESTS;\n+import static org.ballerinalang.compiler.CompilerOptionName.TEST_ENABLED;\n+\n+/**\n+ * Util class for compilation and format execution for formatting CLI tool.\n+ */\n+class FormatUtil {\n+    static final String CMD_NAME = \"format\";\n+    private static final PrintStream outStream = System.err;\n+    private static EmptyPrintStream emptyPrintStream;\n+\n+    /**\n+     * Execute formatter.\n+     *\n+     * @param argList        argument list from the console\n+     * @param helpFlag       flag to get the help page\n+     * @param dryRun         run the whole formatting\n+     * @param sourceRootPath execution path\n+     */\n+    static void execute(List<String> argList, boolean helpFlag, boolean dryRun, Path sourceRootPath) {\n+        if (helpFlag) {\n+            String commandUsageInfo = BLauncherCmd.getCommandUsageInfo(CMD_NAME);\n+            outStream.println(commandUsageInfo);\n+            return;\n+        }\n+\n+        if (argList != null && argList.size() > 1) {\n+            throw LauncherUtils.createLauncherException(Messages.getArgumentError());\n+        }\n+\n+        String moduleName;\n+        String ballerinaFilePath;\n+\n+        try {\n+            // If parameters are available user has given either the module name or the ballerina file path.\n+            // Else user is in a ballerina project and expecting to format the whole ballerina project\n+            if (argList != null && !argList.isEmpty()) {\n+                if (FormatUtil.isBalFile(argList.get(0))) {\n+                    ballerinaFilePath = argList.get(0);\n+                    Path filePath = Paths.get(ballerinaFilePath);\n+\n+                    // If the file doesn't exist or is a directory.\n+                    if (!filePath.toFile().exists() || filePath.toFile().isDirectory()) {\n+                        throw LauncherUtils.createLauncherException(Messages.getNoBallerinaFile(ballerinaFilePath));\n+                    }\n+\n+                    String source = new String(Files.readAllBytes(filePath), StandardCharsets.UTF_8);\n+                    // Format and get the generated formatted source code content.\n+                    String formattedSourceCode = Formatter.format(source);\n+\n+                    if (doChangesAvailable(source, formattedSourceCode)) {\n+                        if (!dryRun) {\n+                            // Write the formatted content back to the file.\n+                            FormatUtil.writeFile(filePath.toAbsolutePath().toString(), formattedSourceCode);\n+                            outStream.println(Messages.getModifiedFiles() + System.lineSeparator() + ballerinaFilePath);\n+                            outStream.println(System.lineSeparator() + Messages.getSuccessMessage());\n+                        } else {\n+                            outStream.println(Messages.getFilesToModify() + System.lineSeparator() + ballerinaFilePath);\n+                        }\n+                    } else {\n+                        outStream.println(Messages.getNoChanges());\n+                    }\n+                } else if (Paths.get(argList.get(0)).toFile().isFile()) {\n+                    // If file is a regular file but not a ballerina source file\n+                    // throw the following exception.\n+                    throw LauncherUtils.createLauncherException(Messages.getNotABallerinaFile());\n+                } else {\n+                    moduleName = argList.get(0);\n+\n+                    // Check whether the module dir exists.\n+                    if (!FormatUtil.isModuleExist(moduleName, sourceRootPath)) {\n+                        // If module directory doesn't exist and contains a \".\"\n+                        // throw a exception to say file or module doesn't exist.\n+                        // Else throw a exception to say module doesn't exist.\n+                        if (moduleName.contains(\".\")) {\n+                            throw LauncherUtils.createLauncherException(Messages\n+                                    .getNoBallerinaModuleOrFile(moduleName));\n+                        } else {\n+                            throw LauncherUtils.createLauncherException(Messages.getNoModuleFound(moduleName));\n+                        }\n+                    }\n+\n+                    // Check whether the given directory is not in a ballerina project.\n+                    if (FormatUtil.notABallerinaProject(sourceRootPath)) {\n+                        throw LauncherUtils.createLauncherException(Messages.getNotBallerinaProject());\n+                    }\n+                    BLangPackage bLangPackage = FormatUtil\n+                            .compileModule(sourceRootPath, getModuleName(moduleName));\n+\n+                    // Iterate and format the ballerina package.\n+                    List<String> formattedFiles = iterateAndFormat(bLangPackage, sourceRootPath, dryRun);\n+                    generateChangeReport(formattedFiles, dryRun);\n+                }\n+            } else {\n+                List<BLangPackage> packages = FormatUtil.compileProject(sourceRootPath);\n+                List<String> formattedFiles = new ArrayList<>();\n+                // Iterate and format all the ballerina packages.\n+                for (BLangPackage bLangPackage : packages) {\n+                    formattedFiles.addAll(iterateAndFormat(bLangPackage, sourceRootPath, dryRun));\n+                }\n+\n+                generateChangeReport(formattedFiles, dryRun);\n+            }\n+        } catch (IOException | NullPointerException e) {\n+            throw LauncherUtils.createLauncherException(Messages.getException());", "originalCommit": "85029404a6672a4d0d0d519148be5b133324530f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA3OTg3MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469079870", "bodyText": "Done", "author": "IrushiL", "createdAt": "2020-08-12T08:05:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1ODkwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1ODkzNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469058937", "bodyText": "Does areChangesAvailable makes sense instead of doChangesAvailable ?", "author": "hemikak", "createdAt": "2020-08-12T07:26:44Z", "path": "misc/formatter/modules/formatter-cli/src/main/java/org/ballerinalang/formatter/cli/FormatUtil.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.cli;\n+\n+import org.ballerinalang.compiler.CompilerPhase;\n+import org.ballerinalang.formatter.core.Formatter;\n+import org.ballerinalang.tool.BLauncherCmd;\n+import org.ballerinalang.tool.LauncherUtils;\n+import org.wso2.ballerinalang.compiler.Compiler;\n+import org.wso2.ballerinalang.compiler.tree.BLangCompilationUnit;\n+import org.wso2.ballerinalang.compiler.tree.BLangPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangTestablePackage;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.CompilerOptions;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintStream;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+import static org.ballerinalang.compiler.CompilerOptionName.COMPILER_PHASE;\n+import static org.ballerinalang.compiler.CompilerOptionName.EXPERIMENTAL_FEATURES_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.LOCK_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.NEW_PARSER_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.OFFLINE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PRESERVE_WHITESPACE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PROJECT_DIR;\n+import static org.ballerinalang.compiler.CompilerOptionName.SKIP_TESTS;\n+import static org.ballerinalang.compiler.CompilerOptionName.TEST_ENABLED;\n+\n+/**\n+ * Util class for compilation and format execution for formatting CLI tool.\n+ */\n+class FormatUtil {\n+    static final String CMD_NAME = \"format\";\n+    private static final PrintStream outStream = System.err;\n+    private static EmptyPrintStream emptyPrintStream;\n+\n+    /**\n+     * Execute formatter.\n+     *\n+     * @param argList        argument list from the console\n+     * @param helpFlag       flag to get the help page\n+     * @param dryRun         run the whole formatting\n+     * @param sourceRootPath execution path\n+     */\n+    static void execute(List<String> argList, boolean helpFlag, boolean dryRun, Path sourceRootPath) {\n+        if (helpFlag) {\n+            String commandUsageInfo = BLauncherCmd.getCommandUsageInfo(CMD_NAME);\n+            outStream.println(commandUsageInfo);\n+            return;\n+        }\n+\n+        if (argList != null && argList.size() > 1) {\n+            throw LauncherUtils.createLauncherException(Messages.getArgumentError());\n+        }\n+\n+        String moduleName;\n+        String ballerinaFilePath;\n+\n+        try {\n+            // If parameters are available user has given either the module name or the ballerina file path.\n+            // Else user is in a ballerina project and expecting to format the whole ballerina project\n+            if (argList != null && !argList.isEmpty()) {\n+                if (FormatUtil.isBalFile(argList.get(0))) {\n+                    ballerinaFilePath = argList.get(0);\n+                    Path filePath = Paths.get(ballerinaFilePath);\n+\n+                    // If the file doesn't exist or is a directory.\n+                    if (!filePath.toFile().exists() || filePath.toFile().isDirectory()) {\n+                        throw LauncherUtils.createLauncherException(Messages.getNoBallerinaFile(ballerinaFilePath));\n+                    }\n+\n+                    String source = new String(Files.readAllBytes(filePath), StandardCharsets.UTF_8);\n+                    // Format and get the generated formatted source code content.\n+                    String formattedSourceCode = Formatter.format(source);\n+\n+                    if (doChangesAvailable(source, formattedSourceCode)) {\n+                        if (!dryRun) {\n+                            // Write the formatted content back to the file.\n+                            FormatUtil.writeFile(filePath.toAbsolutePath().toString(), formattedSourceCode);\n+                            outStream.println(Messages.getModifiedFiles() + System.lineSeparator() + ballerinaFilePath);\n+                            outStream.println(System.lineSeparator() + Messages.getSuccessMessage());\n+                        } else {\n+                            outStream.println(Messages.getFilesToModify() + System.lineSeparator() + ballerinaFilePath);\n+                        }\n+                    } else {\n+                        outStream.println(Messages.getNoChanges());\n+                    }\n+                } else if (Paths.get(argList.get(0)).toFile().isFile()) {\n+                    // If file is a regular file but not a ballerina source file\n+                    // throw the following exception.\n+                    throw LauncherUtils.createLauncherException(Messages.getNotABallerinaFile());\n+                } else {\n+                    moduleName = argList.get(0);\n+\n+                    // Check whether the module dir exists.\n+                    if (!FormatUtil.isModuleExist(moduleName, sourceRootPath)) {\n+                        // If module directory doesn't exist and contains a \".\"\n+                        // throw a exception to say file or module doesn't exist.\n+                        // Else throw a exception to say module doesn't exist.\n+                        if (moduleName.contains(\".\")) {\n+                            throw LauncherUtils.createLauncherException(Messages\n+                                    .getNoBallerinaModuleOrFile(moduleName));\n+                        } else {\n+                            throw LauncherUtils.createLauncherException(Messages.getNoModuleFound(moduleName));\n+                        }\n+                    }\n+\n+                    // Check whether the given directory is not in a ballerina project.\n+                    if (FormatUtil.notABallerinaProject(sourceRootPath)) {\n+                        throw LauncherUtils.createLauncherException(Messages.getNotBallerinaProject());\n+                    }\n+                    BLangPackage bLangPackage = FormatUtil\n+                            .compileModule(sourceRootPath, getModuleName(moduleName));\n+\n+                    // Iterate and format the ballerina package.\n+                    List<String> formattedFiles = iterateAndFormat(bLangPackage, sourceRootPath, dryRun);\n+                    generateChangeReport(formattedFiles, dryRun);\n+                }\n+            } else {\n+                List<BLangPackage> packages = FormatUtil.compileProject(sourceRootPath);\n+                List<String> formattedFiles = new ArrayList<>();\n+                // Iterate and format all the ballerina packages.\n+                for (BLangPackage bLangPackage : packages) {\n+                    formattedFiles.addAll(iterateAndFormat(bLangPackage, sourceRootPath, dryRun));\n+                }\n+\n+                generateChangeReport(formattedFiles, dryRun);\n+            }\n+        } catch (IOException | NullPointerException e) {\n+            throw LauncherUtils.createLauncherException(Messages.getException());\n+        }\n+    }\n+\n+    private static void generateChangeReport(List<String> formattedFiles, boolean dryRun) {\n+        if (!formattedFiles.isEmpty()) {\n+            StringBuilder fileList = new StringBuilder();\n+            if (dryRun) {\n+                fileList.append(Messages.getFilesToModify()).append(System.lineSeparator());\n+            } else {\n+                fileList.append(Messages.getModifiedFiles()).append(System.lineSeparator());\n+            }\n+            for (String file : formattedFiles) {\n+                fileList.append(file).append(System.lineSeparator());\n+            }\n+            outStream.println(fileList.toString());\n+            if (!dryRun) {\n+                outStream.println(Messages.getSuccessMessage());\n+            }\n+        } else {\n+            outStream.println(Messages.getNoChanges());\n+        }\n+    }\n+\n+    private static String getModuleName(String moduleName) {\n+        String pattern = Pattern.quote(File.separator);\n+        String[] splitedTokens = moduleName.split(pattern);\n+        return splitedTokens[splitedTokens.length - 1];\n+    }\n+\n+    /**\n+     * Compile whole ballerina project.\n+     *\n+     * @param sourceRoot source root\n+     * @return {@link List<BLangPackage>} list of BLangPackages\n+     */\n+    private static List<BLangPackage> compileProject(Path sourceRoot) throws UnsupportedEncodingException {\n+        emptyPrintStream = new EmptyPrintStream();\n+        CompilerContext context = getCompilerContext(sourceRoot);\n+        Compiler compiler = Compiler.getInstance(context);\n+        // Set an EmptyPrintStream to hide unnecessary outputs from compiler.\n+        compiler.setOutStream(emptyPrintStream);\n+        return compiler.compilePackages(false);\n+    }\n+\n+    /**\n+     * Compile only a ballerina module.\n+     *\n+     * @param sourceRoot source root\n+     * @param moduleName name of the module to be compiled\n+     * @return {@link BLangPackage} ballerina package\n+     */\n+    private static BLangPackage compileModule(Path sourceRoot, String moduleName) throws UnsupportedEncodingException {\n+        emptyPrintStream = new EmptyPrintStream();\n+        CompilerContext context = getCompilerContext(sourceRoot);\n+        Compiler compiler = Compiler.getInstance(context);\n+        // Set an EmptyPrintStream to hide unnecessary outputs from compiler.\n+        compiler.setOutStream(emptyPrintStream);\n+        return compiler.compile(moduleName);\n+    }\n+\n+    private static void formatAndWrite(BLangCompilationUnit compilationUnit, Path sourceRootPath,\n+                                       List<String> formattedFiles, boolean dryRun) throws IOException {\n+        String fileName = sourceRootPath.toString() + File.separator\n+                + \"src\"\n+                + File.separator\n+                + compilationUnit.getPosition().getSource().getPackageName()\n+                + File.separator\n+                + compilationUnit.getPosition().getSource().getCompilationUnitName();\n+\n+        // Format and get the formatted source.\n+        String formattedSource = Formatter.format(new String(Files.readAllBytes(Paths.get(fileName)),\n+                StandardCharsets.UTF_8));\n+\n+        if (doChangesAvailable(formattedSource, formattedSource)) {\n+            if (!dryRun) {\n+                // Write formatted content to the file.\n+                FormatUtil.writeFile(fileName, formattedSource);\n+            }\n+            formattedFiles.add(fileName);\n+        }\n+    }\n+\n+    private static List<String> iterateAndFormat(BLangPackage bLangPackage, Path sourceRootPath, boolean dryRun)\n+            throws IOException {\n+        List<String> formattedFiles = new ArrayList<>();\n+\n+        // Iterate compilation units and format.\n+        for (BLangCompilationUnit compilationUnit : bLangPackage.getCompilationUnits()) {\n+            formatAndWrite(compilationUnit, sourceRootPath, formattedFiles, dryRun);\n+        }\n+\n+        // Iterate testable packages and format.\n+        for (BLangTestablePackage testablePackage : bLangPackage.getTestablePkgs()) {\n+            for (BLangCompilationUnit compilationUnit : testablePackage.getCompilationUnits()) {\n+                formatAndWrite(compilationUnit, sourceRootPath, formattedFiles, dryRun);\n+            }\n+        }\n+\n+        return formattedFiles;\n+    }\n+\n+    /**\n+     * Get prepared compiler context.\n+     *\n+     * @param sourceRootPath ballerina compilable source root path\n+     * @return {@link CompilerContext} compiler context\n+     */\n+    private static CompilerContext getCompilerContext(Path sourceRootPath) {\n+        CompilerPhase compilerPhase = CompilerPhase.DEFINE;\n+        CompilerContext context = new CompilerContext();\n+        CompilerOptions options = CompilerOptions.getInstance(context);\n+        options.put(PROJECT_DIR, sourceRootPath.toString());\n+        options.put(OFFLINE, Boolean.toString(false));\n+        options.put(COMPILER_PHASE, compilerPhase.toString());\n+        options.put(SKIP_TESTS, Boolean.toString(false));\n+        options.put(TEST_ENABLED, \"true\");\n+        options.put(LOCK_ENABLED, Boolean.toString(false));\n+        options.put(EXPERIMENTAL_FEATURES_ENABLED, Boolean.toString(true));\n+        options.put(PRESERVE_WHITESPACE, Boolean.toString(true));\n+        options.put(NEW_PARSER_ENABLED, Boolean.toString(false));\n+\n+        return context;\n+    }\n+\n+    /**\n+     * Check whether the given module name exists.\n+     *\n+     * @param module      module name\n+     * @param projectRoot path of the ballerina project root\n+     * @return {@link Boolean} true or false\n+     */\n+    private static boolean isModuleExist(String module, Path projectRoot) {\n+        Path modulePath;\n+        if (module.startsWith(\"src/\")) {\n+            modulePath = projectRoot.resolve(module);\n+        } else {\n+            modulePath = projectRoot.resolve(\"src\").resolve(module);\n+        }\n+\n+        return modulePath.toFile().isDirectory();\n+    }\n+\n+    /**\n+     * Check whether the given path isn't a source root of a ballerina project.\n+     *\n+     * @param path - path where the command is executed from\n+     * @return {@link boolean} true or false\n+     */\n+    private static boolean notABallerinaProject(Path path) {\n+        Path cachePath = path.resolve(\"Ballerina.toml\");\n+        return !cachePath.toFile().exists();\n+    }\n+\n+    /**\n+     * Write content to a file.\n+     *\n+     * @param filePath - path of the file to add the content\n+     * @param content  - content to be added to the file\n+     * @throws IOException - throws and IO exception\n+     */\n+    private static void writeFile(String filePath, String content) throws IOException {\n+        OutputStreamWriter fileWriter = null;\n+        try {\n+            try (FileOutputStream fileStream = new FileOutputStream(new File(filePath))) {\n+                fileWriter = new OutputStreamWriter(fileStream, StandardCharsets.UTF_8);\n+            }\n+            fileWriter.write(content);\n+        } finally {\n+            if (fileWriter != null) {\n+                fileWriter.close();\n+            }\n+        }\n+    }\n+\n+    private static boolean doChangesAvailable(String originalSource, String formattedSource) {", "originalCommit": "85029404a6672a4d0d0d519148be5b133324530f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA3OTc4OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469079788", "bodyText": "Done", "author": "IrushiL", "createdAt": "2020-08-12T08:05:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1ODkzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1OTg2Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469059862", "bodyText": "Will this work in windows ? Using resolve function would help. Paths.get(\"src\").resolve(\"test\").resolve(\"resources\").toAbsolutePath()", "author": "hemikak", "createdAt": "2020-08-12T07:28:30Z", "path": "misc/formatter/modules/formatter-cli/src/test/java/org/ballerinalang/formatter/cli/FormatCmdTest.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.ballerinalang.formatter.cli;\n+\n+import org.ballerinalang.tool.BLauncherException;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Format CLI tool test suit for testing tool's exceptions.\n+ */\n+public class FormatCmdTest {\n+    private static final Path RES_DIR = Paths.get(\"src/test/resources/\").toAbsolutePath();", "originalCommit": "85029404a6672a4d0d0d519148be5b133324530f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA2MjI0OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469062248", "bodyText": "Check for other similar places", "author": "hemikak", "createdAt": "2020-08-12T07:32:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1OTg2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA3NzEwMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469077103", "bodyText": "Done", "author": "IrushiL", "createdAt": "2020-08-12T08:00:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA1OTg2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA2MDM2OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469060369", "bodyText": "Is this TODO still valid ?", "author": "hemikak", "createdAt": "2020-08-12T07:29:28Z", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/Formatter.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerinalang.compiler.syntax.tree.ModulePartNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxTree;\n+import io.ballerinalang.compiler.text.LineRange;\n+import io.ballerinalang.compiler.text.TextDocument;\n+import io.ballerinalang.compiler.text.TextDocuments;\n+\n+/**\n+ * Class that exposes the formatting APIs.\n+ */\n+public class Formatter {\n+\n+    // TODO: Add test cases for syntax error scenarios as well", "originalCommit": "85029404a6672a4d0d0d519148be5b133324530f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA3Njk0OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469076948", "bodyText": "Yes, but moved it into FormatterTest class since it is more applicable there.", "author": "IrushiL", "createdAt": "2020-08-12T08:00:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA2MDM2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA2MjU1OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469062559", "bodyText": "You can use Paths.get().resolve().... instead of using File.separator", "author": "hemikak", "createdAt": "2020-08-12T07:33:31Z", "path": "misc/formatter/modules/formatter-cli/src/main/java/org/ballerinalang/formatter/cli/FormatUtil.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.cli;\n+\n+import org.ballerinalang.compiler.CompilerPhase;\n+import org.ballerinalang.formatter.core.Formatter;\n+import org.ballerinalang.tool.BLauncherCmd;\n+import org.ballerinalang.tool.LauncherUtils;\n+import org.wso2.ballerinalang.compiler.Compiler;\n+import org.wso2.ballerinalang.compiler.tree.BLangCompilationUnit;\n+import org.wso2.ballerinalang.compiler.tree.BLangPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangTestablePackage;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.CompilerOptions;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintStream;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+import static org.ballerinalang.compiler.CompilerOptionName.COMPILER_PHASE;\n+import static org.ballerinalang.compiler.CompilerOptionName.EXPERIMENTAL_FEATURES_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.LOCK_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.NEW_PARSER_ENABLED;\n+import static org.ballerinalang.compiler.CompilerOptionName.OFFLINE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PRESERVE_WHITESPACE;\n+import static org.ballerinalang.compiler.CompilerOptionName.PROJECT_DIR;\n+import static org.ballerinalang.compiler.CompilerOptionName.SKIP_TESTS;\n+import static org.ballerinalang.compiler.CompilerOptionName.TEST_ENABLED;\n+\n+/**\n+ * Util class for compilation and format execution for formatting CLI tool.\n+ */\n+class FormatUtil {\n+    static final String CMD_NAME = \"format\";\n+    private static final PrintStream outStream = System.err;\n+    private static EmptyPrintStream emptyPrintStream;\n+\n+    /**\n+     * Execute formatter.\n+     *\n+     * @param argList        argument list from the console\n+     * @param helpFlag       flag to get the help page\n+     * @param dryRun         run the whole formatting\n+     * @param sourceRootPath execution path\n+     */\n+    static void execute(List<String> argList, boolean helpFlag, boolean dryRun, Path sourceRootPath) {\n+        if (helpFlag) {\n+            String commandUsageInfo = BLauncherCmd.getCommandUsageInfo(CMD_NAME);\n+            outStream.println(commandUsageInfo);\n+            return;\n+        }\n+\n+        if (argList != null && argList.size() > 1) {\n+            throw LauncherUtils.createLauncherException(Messages.getArgumentError());\n+        }\n+\n+        String moduleName;\n+        String ballerinaFilePath;\n+\n+        try {\n+            // If parameters are available user has given either the module name or the ballerina file path.\n+            // Else user is in a ballerina project and expecting to format the whole ballerina project\n+            if (argList != null && !argList.isEmpty()) {\n+                if (FormatUtil.isBalFile(argList.get(0))) {\n+                    ballerinaFilePath = argList.get(0);\n+                    Path filePath = Paths.get(ballerinaFilePath);\n+\n+                    // If the file doesn't exist or is a directory.\n+                    if (!filePath.toFile().exists() || filePath.toFile().isDirectory()) {\n+                        throw LauncherUtils.createLauncherException(Messages.getNoBallerinaFile(ballerinaFilePath));\n+                    }\n+\n+                    String source = new String(Files.readAllBytes(filePath), StandardCharsets.UTF_8);\n+                    // Format and get the generated formatted source code content.\n+                    String formattedSourceCode = Formatter.format(source);\n+\n+                    if (doChangesAvailable(source, formattedSourceCode)) {\n+                        if (!dryRun) {\n+                            // Write the formatted content back to the file.\n+                            FormatUtil.writeFile(filePath.toAbsolutePath().toString(), formattedSourceCode);\n+                            outStream.println(Messages.getModifiedFiles() + System.lineSeparator() + ballerinaFilePath);\n+                            outStream.println(System.lineSeparator() + Messages.getSuccessMessage());\n+                        } else {\n+                            outStream.println(Messages.getFilesToModify() + System.lineSeparator() + ballerinaFilePath);\n+                        }\n+                    } else {\n+                        outStream.println(Messages.getNoChanges());\n+                    }\n+                } else if (Paths.get(argList.get(0)).toFile().isFile()) {\n+                    // If file is a regular file but not a ballerina source file\n+                    // throw the following exception.\n+                    throw LauncherUtils.createLauncherException(Messages.getNotABallerinaFile());\n+                } else {\n+                    moduleName = argList.get(0);\n+\n+                    // Check whether the module dir exists.\n+                    if (!FormatUtil.isModuleExist(moduleName, sourceRootPath)) {\n+                        // If module directory doesn't exist and contains a \".\"\n+                        // throw a exception to say file or module doesn't exist.\n+                        // Else throw a exception to say module doesn't exist.\n+                        if (moduleName.contains(\".\")) {\n+                            throw LauncherUtils.createLauncherException(Messages\n+                                    .getNoBallerinaModuleOrFile(moduleName));\n+                        } else {\n+                            throw LauncherUtils.createLauncherException(Messages.getNoModuleFound(moduleName));\n+                        }\n+                    }\n+\n+                    // Check whether the given directory is not in a ballerina project.\n+                    if (FormatUtil.notABallerinaProject(sourceRootPath)) {\n+                        throw LauncherUtils.createLauncherException(Messages.getNotBallerinaProject());\n+                    }\n+                    BLangPackage bLangPackage = FormatUtil\n+                            .compileModule(sourceRootPath, getModuleName(moduleName));\n+\n+                    // Iterate and format the ballerina package.\n+                    List<String> formattedFiles = iterateAndFormat(bLangPackage, sourceRootPath, dryRun);\n+                    generateChangeReport(formattedFiles, dryRun);\n+                }\n+            } else {\n+                List<BLangPackage> packages = FormatUtil.compileProject(sourceRootPath);\n+                List<String> formattedFiles = new ArrayList<>();\n+                // Iterate and format all the ballerina packages.\n+                for (BLangPackage bLangPackage : packages) {\n+                    formattedFiles.addAll(iterateAndFormat(bLangPackage, sourceRootPath, dryRun));\n+                }\n+\n+                generateChangeReport(formattedFiles, dryRun);\n+            }\n+        } catch (IOException | NullPointerException e) {\n+            throw LauncherUtils.createLauncherException(Messages.getException());\n+        }\n+    }\n+\n+    private static void generateChangeReport(List<String> formattedFiles, boolean dryRun) {\n+        if (!formattedFiles.isEmpty()) {\n+            StringBuilder fileList = new StringBuilder();\n+            if (dryRun) {\n+                fileList.append(Messages.getFilesToModify()).append(System.lineSeparator());\n+            } else {\n+                fileList.append(Messages.getModifiedFiles()).append(System.lineSeparator());\n+            }\n+            for (String file : formattedFiles) {\n+                fileList.append(file).append(System.lineSeparator());\n+            }\n+            outStream.println(fileList.toString());\n+            if (!dryRun) {\n+                outStream.println(Messages.getSuccessMessage());\n+            }\n+        } else {\n+            outStream.println(Messages.getNoChanges());\n+        }\n+    }\n+\n+    private static String getModuleName(String moduleName) {\n+        String pattern = Pattern.quote(File.separator);\n+        String[] splitedTokens = moduleName.split(pattern);\n+        return splitedTokens[splitedTokens.length - 1];\n+    }\n+\n+    /**\n+     * Compile whole ballerina project.\n+     *\n+     * @param sourceRoot source root\n+     * @return {@link List<BLangPackage>} list of BLangPackages\n+     */\n+    private static List<BLangPackage> compileProject(Path sourceRoot) throws UnsupportedEncodingException {\n+        emptyPrintStream = new EmptyPrintStream();\n+        CompilerContext context = getCompilerContext(sourceRoot);\n+        Compiler compiler = Compiler.getInstance(context);\n+        // Set an EmptyPrintStream to hide unnecessary outputs from compiler.\n+        compiler.setOutStream(emptyPrintStream);\n+        return compiler.compilePackages(false);\n+    }\n+\n+    /**\n+     * Compile only a ballerina module.\n+     *\n+     * @param sourceRoot source root\n+     * @param moduleName name of the module to be compiled\n+     * @return {@link BLangPackage} ballerina package\n+     */\n+    private static BLangPackage compileModule(Path sourceRoot, String moduleName) throws UnsupportedEncodingException {\n+        emptyPrintStream = new EmptyPrintStream();\n+        CompilerContext context = getCompilerContext(sourceRoot);\n+        Compiler compiler = Compiler.getInstance(context);\n+        // Set an EmptyPrintStream to hide unnecessary outputs from compiler.\n+        compiler.setOutStream(emptyPrintStream);\n+        return compiler.compile(moduleName);\n+    }\n+\n+    private static void formatAndWrite(BLangCompilationUnit compilationUnit, Path sourceRootPath,\n+                                       List<String> formattedFiles, boolean dryRun) throws IOException {\n+        String fileName = sourceRootPath.toString() + File.separator", "originalCommit": "85029404a6672a4d0d0d519148be5b133324530f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA3NTk4NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469075984", "bodyText": "Done", "author": "IrushiL", "createdAt": "2020-08-12T07:58:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA2MjU1OQ=="}], "type": "inlineReview"}, {"oid": "bd11e18d02f89bd7c4083018f0ceaba728cbf5eb", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bd11e18d02f89bd7c4083018f0ceaba728cbf5eb", "message": "Address review comments", "committedDate": "2020-08-12T07:57:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4MjY5Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469082697", "bodyText": "Method never used", "author": "pramodya1994", "createdAt": "2020-08-12T08:10:57Z", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/Formatter.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerinalang.compiler.syntax.tree.ModulePartNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxTree;\n+import io.ballerinalang.compiler.text.LineRange;\n+import io.ballerinalang.compiler.text.TextDocument;\n+import io.ballerinalang.compiler.text.TextDocuments;\n+\n+/**\n+ * Class that exposes the formatting APIs.\n+ */\n+public class Formatter {\n+\n+    /**\n+     * Formats the provided source string and returns back the formatted source string.\n+     *\n+     * @param source A Ballerina source in string form\n+     * @return A modified source string after formatting changes\n+     */\n+    public static String format(String source) {\n+        return format(source, new FormattingOptions());\n+    }\n+\n+    /**\n+     * Formats a line range of the provided SyntaxTree. All the nodes falling within the line range\n+     * specified will be formatted.\n+     *\n+     * @param syntaxTree The complete SyntaxTree, of which a part is to be formatted\n+     * @param range LineRange which specifies the range to be formatted\n+     * @return The modified SyntaxTree after formatting changes\n+     */\n+    public static SyntaxTree format(SyntaxTree syntaxTree, LineRange range) {", "originalCommit": "bd11e18d02f89bd7c4083018f0ceaba728cbf5eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4MzY1NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469083655", "bodyText": "This is an API exposed by the formatter core.", "author": "IrushiL", "createdAt": "2020-08-12T08:12:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4MjY5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4MjkzNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469082936", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static String format(String source, FormattingOptions options) {\n          \n          \n            \n                private static String format(String source, FormattingOptions options) {", "author": "pramodya1994", "createdAt": "2020-08-12T08:11:28Z", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/Formatter.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerinalang.compiler.syntax.tree.ModulePartNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxTree;\n+import io.ballerinalang.compiler.text.LineRange;\n+import io.ballerinalang.compiler.text.TextDocument;\n+import io.ballerinalang.compiler.text.TextDocuments;\n+\n+/**\n+ * Class that exposes the formatting APIs.\n+ */\n+public class Formatter {\n+\n+    /**\n+     * Formats the provided source string and returns back the formatted source string.\n+     *\n+     * @param source A Ballerina source in string form\n+     * @return A modified source string after formatting changes\n+     */\n+    public static String format(String source) {\n+        return format(source, new FormattingOptions());\n+    }\n+\n+    /**\n+     * Formats a line range of the provided SyntaxTree. All the nodes falling within the line range\n+     * specified will be formatted.\n+     *\n+     * @param syntaxTree The complete SyntaxTree, of which a part is to be formatted\n+     * @param range LineRange which specifies the range to be formatted\n+     * @return The modified SyntaxTree after formatting changes\n+     */\n+    public static SyntaxTree format(SyntaxTree syntaxTree, LineRange range) {\n+        return format(syntaxTree, range, new FormattingOptions());\n+    }\n+\n+    /**\n+     * Formats the provided SyntaxTree and returns back a formatted SyntaxTree.\n+     *\n+     * @param syntaxTree The SyntaxTree which is to be formatted\n+     * @return The modified SyntaxTree after formatting changes\n+     */\n+    public static SyntaxTree format(SyntaxTree syntaxTree) {\n+        return format(syntaxTree, new FormattingOptions());\n+    }\n+\n+    /**\n+     * Formats the provided source string while using the formatting options provided.\n+     *\n+     * @param source A Ballerina source in string form\n+     * @param options Formatting options that are to be used when formatting\n+     * @return A modified source string after formatting changes\n+     */\n+    public static String format(String source, FormattingOptions options) {", "originalCommit": "bd11e18d02f89bd7c4083018f0ceaba728cbf5eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4NDAxOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469084019", "bodyText": "This is an API exposed by the formatter core, it is to be used by other modules such as the lang-sever and the formatter CLI.", "author": "IrushiL", "createdAt": "2020-08-12T08:13:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4MjkzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4MzI2Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469083266", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static SyntaxTree format(SyntaxTree syntaxTree, LineRange range, FormattingOptions options) {\n          \n          \n            \n                private static SyntaxTree format(SyntaxTree syntaxTree, LineRange range, FormattingOptions options) {", "author": "pramodya1994", "createdAt": "2020-08-12T08:12:01Z", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/Formatter.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerinalang.compiler.syntax.tree.ModulePartNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxTree;\n+import io.ballerinalang.compiler.text.LineRange;\n+import io.ballerinalang.compiler.text.TextDocument;\n+import io.ballerinalang.compiler.text.TextDocuments;\n+\n+/**\n+ * Class that exposes the formatting APIs.\n+ */\n+public class Formatter {\n+\n+    /**\n+     * Formats the provided source string and returns back the formatted source string.\n+     *\n+     * @param source A Ballerina source in string form\n+     * @return A modified source string after formatting changes\n+     */\n+    public static String format(String source) {\n+        return format(source, new FormattingOptions());\n+    }\n+\n+    /**\n+     * Formats a line range of the provided SyntaxTree. All the nodes falling within the line range\n+     * specified will be formatted.\n+     *\n+     * @param syntaxTree The complete SyntaxTree, of which a part is to be formatted\n+     * @param range LineRange which specifies the range to be formatted\n+     * @return The modified SyntaxTree after formatting changes\n+     */\n+    public static SyntaxTree format(SyntaxTree syntaxTree, LineRange range) {\n+        return format(syntaxTree, range, new FormattingOptions());\n+    }\n+\n+    /**\n+     * Formats the provided SyntaxTree and returns back a formatted SyntaxTree.\n+     *\n+     * @param syntaxTree The SyntaxTree which is to be formatted\n+     * @return The modified SyntaxTree after formatting changes\n+     */\n+    public static SyntaxTree format(SyntaxTree syntaxTree) {\n+        return format(syntaxTree, new FormattingOptions());\n+    }\n+\n+    /**\n+     * Formats the provided source string while using the formatting options provided.\n+     *\n+     * @param source A Ballerina source in string form\n+     * @param options Formatting options that are to be used when formatting\n+     * @return A modified source string after formatting changes\n+     */\n+    public static String format(String source, FormattingOptions options) {\n+        TextDocument textDocument = TextDocuments.from(source);\n+        SyntaxTree syntaxTree = SyntaxTree.from(textDocument);\n+        FormattingTreeModifier treeModifier = new FormattingTreeModifier();\n+        ModulePartNode newModulePart = treeModifier.transform((ModulePartNode) syntaxTree.rootNode());\n+        if (options != null) {\n+            treeModifier.setFormattingOptions(options);\n+        }\n+        return syntaxTree.modifyWith(newModulePart).toSourceCode();\n+    }\n+\n+    /**\n+     * Formats a line range of the provided SyntaxTree while using the formatting options provided. All the\n+     * nodes falling within the line range provided will be formatted.\n+     *\n+     * @param syntaxTree The complete SyntaxTree, of which a part is to be formatted\n+     * @param range LineRange which needs to be formatted\n+     * @param options Formatting options that are to be used when formatting\n+     * @return The modified SyntaxTree after formatting changes\n+     */\n+    public static SyntaxTree format(SyntaxTree syntaxTree, LineRange range, FormattingOptions options) {", "originalCommit": "bd11e18d02f89bd7c4083018f0ceaba728cbf5eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4NDE0OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469084148", "bodyText": "This is an API exposed by the formatter core, it is to be used by other modules such as the lang-sever and the formatter CLI.", "author": "IrushiL", "createdAt": "2020-08-12T08:13:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4MzI2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4MzUwMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469083500", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static SyntaxTree format(SyntaxTree syntaxTree, FormattingOptions options) {\n          \n          \n            \n                private static SyntaxTree format(SyntaxTree syntaxTree, FormattingOptions options) {", "author": "pramodya1994", "createdAt": "2020-08-12T08:12:27Z", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/Formatter.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core;\n+\n+import io.ballerinalang.compiler.syntax.tree.ModulePartNode;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxTree;\n+import io.ballerinalang.compiler.text.LineRange;\n+import io.ballerinalang.compiler.text.TextDocument;\n+import io.ballerinalang.compiler.text.TextDocuments;\n+\n+/**\n+ * Class that exposes the formatting APIs.\n+ */\n+public class Formatter {\n+\n+    /**\n+     * Formats the provided source string and returns back the formatted source string.\n+     *\n+     * @param source A Ballerina source in string form\n+     * @return A modified source string after formatting changes\n+     */\n+    public static String format(String source) {\n+        return format(source, new FormattingOptions());\n+    }\n+\n+    /**\n+     * Formats a line range of the provided SyntaxTree. All the nodes falling within the line range\n+     * specified will be formatted.\n+     *\n+     * @param syntaxTree The complete SyntaxTree, of which a part is to be formatted\n+     * @param range LineRange which specifies the range to be formatted\n+     * @return The modified SyntaxTree after formatting changes\n+     */\n+    public static SyntaxTree format(SyntaxTree syntaxTree, LineRange range) {\n+        return format(syntaxTree, range, new FormattingOptions());\n+    }\n+\n+    /**\n+     * Formats the provided SyntaxTree and returns back a formatted SyntaxTree.\n+     *\n+     * @param syntaxTree The SyntaxTree which is to be formatted\n+     * @return The modified SyntaxTree after formatting changes\n+     */\n+    public static SyntaxTree format(SyntaxTree syntaxTree) {\n+        return format(syntaxTree, new FormattingOptions());\n+    }\n+\n+    /**\n+     * Formats the provided source string while using the formatting options provided.\n+     *\n+     * @param source A Ballerina source in string form\n+     * @param options Formatting options that are to be used when formatting\n+     * @return A modified source string after formatting changes\n+     */\n+    public static String format(String source, FormattingOptions options) {\n+        TextDocument textDocument = TextDocuments.from(source);\n+        SyntaxTree syntaxTree = SyntaxTree.from(textDocument);\n+        FormattingTreeModifier treeModifier = new FormattingTreeModifier();\n+        ModulePartNode newModulePart = treeModifier.transform((ModulePartNode) syntaxTree.rootNode());\n+        if (options != null) {\n+            treeModifier.setFormattingOptions(options);\n+        }\n+        return syntaxTree.modifyWith(newModulePart).toSourceCode();\n+    }\n+\n+    /**\n+     * Formats a line range of the provided SyntaxTree while using the formatting options provided. All the\n+     * nodes falling within the line range provided will be formatted.\n+     *\n+     * @param syntaxTree The complete SyntaxTree, of which a part is to be formatted\n+     * @param range LineRange which needs to be formatted\n+     * @param options Formatting options that are to be used when formatting\n+     * @return The modified SyntaxTree after formatting changes\n+     */\n+    public static SyntaxTree format(SyntaxTree syntaxTree, LineRange range, FormattingOptions options) {\n+        FormattingTreeModifier treeModifier = new FormattingTreeModifier();\n+        ModulePartNode modulePartNode = syntaxTree.rootNode();\n+        treeModifier.setLineRange(range);\n+        if (options != null) {\n+            treeModifier.setFormattingOptions(options);\n+        }\n+        return syntaxTree.modifyWith(treeModifier.transform(modulePartNode));\n+    }\n+\n+    /**\n+     * Formats the provided SyntaxTree while using the formatting options provided.\n+     *\n+     * @param syntaxTree The SyntaxTree which is to be formatted\n+     * @param options Formatting options that are to be used when formatting\n+     * @return The modified SyntaxTree after formatting changes\n+     */\n+    public static SyntaxTree format(SyntaxTree syntaxTree, FormattingOptions options) {", "originalCommit": "bd11e18d02f89bd7c4083018f0ceaba728cbf5eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4NDIxMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469084213", "bodyText": "This is an API exposed by the formatter core, it is to be used by other modules such as the lang-sever and the formatter CLI.", "author": "IrushiL", "createdAt": "2020-08-12T08:13:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA4MzUwMA=="}], "type": "inlineReview"}, {"oid": "2cd5c53f28192688cf2a96e1d6fbdd66cd64d6e1", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2cd5c53f28192688cf2a96e1d6fbdd66cd64d6e1", "message": "Merge branch 'master' into formatterImpl", "committedDate": "2020-08-12T08:39:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEwNTc4OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469105789", "bodyText": "Why do we have a test class for each expression or construct type. Can we simply rely on a file structure to organize the test cases and run from a single test runner.", "author": "hevayo", "createdAt": "2020-08-12T08:49:39Z", "path": "misc/formatter/modules/formatter-core/src/test/java/org/ballerinalang/formatter/core/expressions/StringTemplateExpressionsTest.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://wso2.com) All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.ballerinalang.formatter.core.expressions;\n+\n+import org.ballerinalang.formatter.core.FormatterTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * Test the formatting of string template expressions.\n+ *\n+ * @since 2.0.0\n+ */\n+public class StringTemplateExpressionsTest extends FormatterTest {", "originalCommit": "2cd5c53f28192688cf2a96e1d6fbdd66cd64d6e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEzMjI5Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25122#discussion_r469132292", "bodyText": "Here the test classes extend a single test runner but there are test classes added for each subcategory since some of these subcategories contain a lot of test cases. But since this results in a large number of test classes, I will try to refactor this in the future.", "author": "IrushiL", "createdAt": "2020-08-12T09:34:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEwNTc4OQ=="}], "type": "inlineReview"}]}