{"pr_number": 21187, "pr_title": "Implement Failover in WebSocket", "pr_createdAt": "2020-02-20T14:25:02Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187", "timeline": [{"oid": "436222ca898db5bd5d35273a4986ca2be30260e8", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/436222ca898db5bd5d35273a4986ca2be30260e8", "message": "Merge branch\ng On branch master", "committedDate": "2020-02-07T09:18:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY5MzYyMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397693620", "bodyText": "Shall we give a proper name. For now lets call it ExtendedHashakeListener", "author": "shafreenAnfar", "createdAt": "2020-03-25T08:56:25Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/websocket/client/listener/HandshakeListener.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.net.http.websocket.client.listener;\n+\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.net.http.websocket.server.WebSocketConnectionInfo;\n+import org.wso2.transport.http.netty.contract.websocket.ClientHandshakeListener;\n+\n+/**\n+ * Interface for the client handshake listener.\n+ *\n+ * @since 1.2.0\n+ */\n+public interface HandshakeListener extends ClientHandshakeListener {", "originalCommit": "37544470b0fdd1aca5315a64b5f32301e19817de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY5Njk0Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397696946", "bodyText": "Do we need this class base class should be WebSocketHandshakeListener right", "author": "shafreenAnfar", "createdAt": "2020-03-25T09:02:09Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/websocket/client/listener/ClientHandshakeListener.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.net.http.websocket.client.listener;\n+\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.net.http.websocket.WebSocketResourceDispatcher;\n+import org.ballerinalang.net.http.websocket.WebSocketUtil;\n+import org.ballerinalang.net.http.websocket.server.WebSocketConnectionInfo;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketConnection;\n+import org.wso2.transport.http.netty.message.HttpCarbonResponse;\n+\n+/**\n+ * Handshake listener of WebSocket client.\n+ *\n+ * @since 1.2.0\n+ */\n+public class ClientHandshakeListener implements HandshakeListener {", "originalCommit": "37544470b0fdd1aca5315a64b5f32301e19817de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzczNDQxOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397734418", "bodyText": "Yes as the dispatchOnError() used to close the connection between client and server(terminate the connector thread) but WebSocketHandshakeListener is a base class for RetryHandshakeListener and FailoverHandshakeListener. Therefore we can't call that dispatchOnError() in the base class. So, I implemented this class to handle dispatchOnError() for normal webSocketClient.", "author": "kalaiyarasiganeshalingam", "createdAt": "2020-03-25T10:03:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY5Njk0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzcxODg2MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397718861", "bodyText": "I think now it is a good time to move these listener creations to their respective endpoint classes :)", "author": "shafreenAnfar", "createdAt": "2020-03-25T09:38:31Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/websocket/client/InitEndpoint.java", "diffHunk": "@@ -59,140 +57,62 @@ public static void initEndpoint(ObjectValue webSocketClient) {\n                 HttpConstants.CLIENT_ENDPOINT_CONFIG);\n         Strand strand = Scheduler.getStrand();\n         String remoteUrl = webSocketClient.getStringValue(WebSocketConstants.CLIENT_URL_CONFIG);\n-        WebSocketService wsService = validateAndCreateWebSocketService(clientEndpointConfig, strand);\n+        WebSocketService wsService = WebSocketUtil.validateAndCreateWebSocketService(strand, clientEndpointConfig);\n         HttpWsConnectorFactory connectorFactory = HttpUtil.createHttpWsConnectionFactory();\n         WebSocketClientConnectorConfig clientConnectorConfig = new WebSocketClientConnectorConfig(remoteUrl);\n         String scheme = URI.create(remoteUrl).getScheme();\n-        populateClientConnectorConfig(clientEndpointConfig, clientConnectorConfig, scheme);\n-        // Create the client connector.\n+        WebSocketUtil.populateClientConnectorConfig(clientEndpointConfig, clientConnectorConfig, scheme);\n+        // Creates the client connector\n         WebSocketClientConnector clientConnector = connectorFactory.createWsClientConnector(clientConnectorConfig);\n-        WebSocketClientConnectorListener clientConnectorListener = new WebSocketClientConnectorListener();\n-        // Add the client connector as a native data when the client is not a failover client\n-        // because when using one URL, there is no need to create the client connector again.\n+        webSocketClient.addNativeData(WebSocketConstants.CONNECTOR_FACTORY, connectorFactory);\n+        // Add the client connector as a native data\n+        // because there is no need to create the client connector again when using one URL\n         webSocketClient.addNativeData(WebSocketConstants.CLIENT_CONNECTOR, clientConnector);\n-        webSocketClient.addNativeData(WebSocketConstants.CLIENT_LISTENER, clientConnectorListener);\n-        if (WebSocketUtil.hasRetryConfig(webSocketClient)) {\n-            @SuppressWarnings(WebSocketConstants.UNCHECKED)\n-            MapValue<String, Object> retryConfig = (MapValue<String, Object>) clientEndpointConfig.getMapValue(\n-                    WebSocketConstants.RETRY_CONFIG);\n-            RetryContext retryConnectorConfig = new RetryContext();\n-            populateRetryConnectorConfig(retryConfig, retryConnectorConfig);\n-            webSocketClient.addNativeData(WebSocketConstants.RETRY_CONFIG, retryConnectorConfig);\n-            CountDownLatch countDownLatch = new CountDownLatch(1);\n-            webSocketClient.addNativeData(WebSocketConstants.COUNT_DOWN_LATCH, countDownLatch);\n-            WebSocketUtil.establishWebSocketConnection(webSocketClient, wsService);\n-            // Set the count Down latch for initial connection\n-            waitForHandshake(countDownLatch);\n-        } else {\n-            WebSocketUtil.establishWebSocketConnection(webSocketClient, wsService);\n-        }\n-\n-    }\n-\n-    private static void waitForHandshake(CountDownLatch countDownLatch) {\n-        try {\n-            // Wait to call countDown()\n-            countDownLatch.await();\n-        } catch (InterruptedException e) {\n-            Thread.currentThread().interrupt();\n-            throw new WebSocketException(WebSocketConstants.ERROR_MESSAGE + e.getMessage());\n-        }\n-    }\n-\n-    private static void populateClientConnectorConfig(MapValue<String, Object> clientEndpointConfig,\n-                                                      WebSocketClientConnectorConfig clientConnectorConfig,\n-                                                      String scheme) {\n-        clientConnectorConfig.setAutoRead(false); // Frames are read sequentially in ballerina.\n-        clientConnectorConfig.setSubProtocols(WebSocketUtil.findNegotiableSubProtocols(clientEndpointConfig));\n-        @SuppressWarnings(WebSocketConstants.UNCHECKED)\n-        MapValue<String, Object> headerValues = (MapValue<String, Object>) clientEndpointConfig.getMapValue(\n-                WebSocketConstants.CLIENT_CUSTOM_HEADERS_CONFIG);\n-        if (headerValues != null) {\n-            clientConnectorConfig.addHeaders(getCustomHeaders(headerValues));\n-        }\n-\n-        long idleTimeoutInSeconds = WebSocketUtil.findTimeoutInSeconds(clientEndpointConfig,\n-                WebSocketConstants.ANNOTATION_ATTR_IDLE_TIMEOUT, 0);\n-        if (idleTimeoutInSeconds > 0) {\n-            clientConnectorConfig.setIdleTimeoutInMillis((int) (idleTimeoutInSeconds * 1000));\n-        }\n-\n-        clientConnectorConfig.setMaxFrameSize(WebSocketUtil.findMaxFrameSize(clientEndpointConfig));\n-\n-        MapValue secureSocket = clientEndpointConfig.getMapValue(HttpConstants.ENDPOINT_CONFIG_SECURE_SOCKET);\n-        if (secureSocket != null) {\n-            HttpUtil.populateSSLConfiguration(clientConnectorConfig, secureSocket);\n-        } else if (scheme.equals(WebSocketConstants.WSS_SCHEME)) {\n-            clientConnectorConfig.useJavaDefaults();\n+        if (webSocketClient.getType().getName().equalsIgnoreCase(WebSocketConstants.WEBSOCKET_CLIENT)) {\n+            if (WebSocketUtil.hasRetryContext(webSocketClient)) {\n+                @SuppressWarnings(WebSocketConstants.UNCHECKED)\n+                MapValue<String, Object> retryConfig = (MapValue<String, Object>) clientEndpointConfig.getMapValue(\n+                        WebSocketConstants.RETRY_CONTEXT);\n+                RetryContext retryConnectorConfig = new RetryContext();\n+                populateRetryConnectorConfig(retryConfig, retryConnectorConfig);\n+                webSocketClient.addNativeData(WebSocketConstants.RETRY_CONTEXT, retryConnectorConfig);\n+                webSocketClient.addNativeData(WebSocketConstants.CLIENT_LISTENER, new RetryConnectorListener(\n+                        new ClientConnectorListener()));", "originalCommit": "37544470b0fdd1aca5315a64b5f32301e19817de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg0NzY1Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397847653", "bodyText": "I have created the retryClient as per the offline discussion.", "author": "kalaiyarasiganeshalingam", "createdAt": "2020-03-25T13:22:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzcxODg2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzczMzc3Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397733776", "bodyText": "This also we can move to respective Endpoints and pass it along inside WebSocketClient native data right.", "author": "shafreenAnfar", "createdAt": "2020-03-25T10:02:20Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/websocket/WebSocketUtil.java", "diffHunk": "@@ -224,54 +246,160 @@ private static ErrorValue createErrorCause(String message, String reason, BPacka\n     }\n \n     /**\n-     * Establish connection with the endpoint.\n+     * Reconnect when the WebSocket connection is lost.\n+     *\n+     * @param webSocketClient - webSocket client\n+     * @param wsService - webSocket service\n+     * @return If attempts reconnection, then return true\n+     */\n+    public static boolean reconnect(ObjectValue webSocketClient, WebSocketService wsService) {\n+        RetryContext retryConnectorConfig = (RetryContext) webSocketClient.getNativeData(WebSocketConstants.\n+                RETRY_CONTEXT);\n+        int maxAttempts = retryConnectorConfig.getMaxAttempts();\n+        int noOfReconnectAttempts = retryConnectorConfig.getReconnectAttempts();\n+        if (noOfReconnectAttempts < maxAttempts || maxAttempts == 0) {\n+            retryConnectorConfig.setReconnectAttempts(noOfReconnectAttempts + 1);\n+            if (logger.isDebugEnabled()) {\n+                Date date = new Date();\n+                SimpleDateFormat formatter = new SimpleDateFormat(\"dd-MM-yyyy HH:mm:ss\");\n+                String time = formatter.format(date.getTime());\n+                logger.debug(WebSocketConstants.LOG_MESSAGE, time, \"reconnecting...\");\n+            }\n+            createDelay(calculateWaitingTime(retryConnectorConfig.getInterval(), retryConnectorConfig.getMaxInterval(),\n+                    retryConnectorConfig.getBackOfFactor(), noOfReconnectAttempts));\n+            establishWebSocketConnection((WebSocketClientConnector) webSocketClient.getNativeData(WebSocketConstants.\n+                    CLIENT_CONNECTOR), webSocketClient, wsService);\n+            return true;\n+        }\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(WebSocketConstants.LOG_MESSAGE, \"Maximum retry attempts but couldn't connect to the server: \",\n+                    webSocketClient.getStringValue(WebSocketConstants.CLIENT_URL_CONFIG));\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Failover when webSocket connection lost.\n      *\n-     * @param webSocketClient - the WebSocket client.\n-     * @param wsService - the WebSocket service.\n+     * @param webSocketClient - webSocket client\n+     * @param wsService - webSocket service\n+     * @return if attempts failover, return true\n      */\n-    public static void establishWebSocketConnection(ObjectValue webSocketClient, WebSocketService wsService) {\n-        WebSocketClientConnectorListener clientConnectorListener = (WebSocketClientConnectorListener) webSocketClient.\n-                getNativeData(WebSocketConstants.CLIENT_LISTENER);\n-        WebSocketClientConnector clientConnector = (WebSocketClientConnector) webSocketClient.\n-                getNativeData(WebSocketConstants.CLIENT_CONNECTOR);\n+    public static boolean failover(ObjectValue webSocketClient, WebSocketService wsService) {\n+        FailoverContext failoverContext = (FailoverContext) webSocketClient.\n+                getNativeData(WebSocketConstants.FAILOVER_CONTEXT);\n+        int currentIndex = failoverContext.getCurrentIndex();\n+        List targets = failoverContext.getTargetUrls();\n+        // Sets next url index\n+        currentIndex++;\n+        // Checks current url index equals to target size or not. if equal, set the currentIndex = 0\n+        if (currentIndex == targets.size()) {\n+            currentIndex = 0;\n+        }\n+        // Checks the current url index equals with previous connected url index or not\n+        // If it isn't equal, call the initialiseWebSocketConnection()\n+        // if it equals, return false\n+        if (currentIndex != failoverContext.getInitialIndex()) {\n+            failoverContext.setCurrentIndex(currentIndex);\n+            createDelay(failoverContext.getFailoverInterval());\n+            establishWebSocketConnection(createWebSocketClientConnector(targets.get(currentIndex).toString(),\n+                       webSocketClient), webSocketClient, wsService);\n+            return true;\n+        }\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(WebSocketConstants.LOG_MESSAGE, \"Couldn't connect to one of the server in the targets: \",\n+                    targets);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Establishes connection with the endpoint.\n+     *\n+     * @param clientConnector -  the webSocket client connector\n+     * @param webSocketClient - the WebSocket client\n+     * @param wsService - the WebSocket service\n+     */\n+    public static void establishWebSocketConnection(WebSocketClientConnector clientConnector,\n+                                                    ObjectValue webSocketClient, WebSocketService wsService) {\n         boolean readyOnConnect = webSocketClient.getMapValue(CLIENT_ENDPOINT_CONFIG).getBooleanValue(\n                 WebSocketConstants.CLIENT_READY_ON_CONNECT);\n         ClientHandshakeFuture handshakeFuture = clientConnector.connect();\n-        handshakeFuture.setWebSocketConnectorListener(clientConnectorListener);\n         CountDownLatch countDownLatch = new CountDownLatch(1);\n-        if (WebSocketUtil.hasRetryConfig(webSocketClient)) {\n-            handshakeFuture.setClientHandshakeListener(new WebSocketClientHandshakeListenerForRetry(webSocketClient,\n-                    wsService, clientConnectorListener, readyOnConnect, countDownLatch,\n-                    (RetryContext) webSocketClient.getNativeData(WebSocketConstants.RETRY_CONFIG)));\n+        setListenersToHandshakeFuture(handshakeFuture, webSocketClient, wsService, countDownLatch, readyOnConnect);\n+        // Sets the countDown latch for every handshake\n+        waitForHandshake(webSocketClient, countDownLatch, wsService);\n+    }\n+\n+    /**\n+     * Sets listeners to the handshake future.\n+     *\n+     * @param handshakeFuture - the handshake future\n+     * @param webSocketClient - the WebSocket client\n+     * @param wsService - the WebSocket service\n+     * @param countDownLatch - the countdown latch\n+     * @param readyOnConnect - the ready on connect\n+     */\n+    private static void setListenersToHandshakeFuture(ClientHandshakeFuture handshakeFuture,\n+                                                      ObjectValue webSocketClient, WebSocketService wsService,\n+                                                      CountDownLatch countDownLatch, boolean readyOnConnect) {\n+        ConnectorListener connectorListener = (ConnectorListener) webSocketClient.getNativeData(\n+                WebSocketConstants.CLIENT_LISTENER);\n+        handshakeFuture.setWebSocketConnectorListener(connectorListener);\n+        WebSocketHandshakeListener webSocketHandshakeListener = new WebSocketHandshakeListener(webSocketClient,", "originalCommit": "37544470b0fdd1aca5315a64b5f32301e19817de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzgyMjQ5OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397822499", "bodyText": "Every handshake needs to set the coundownLatch as it handles the handshake's timeout. therefore we can't move this to respective Endpoints.", "author": "kalaiyarasiganeshalingam", "createdAt": "2020-03-25T12:41:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzczMzc3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMxMDkyOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r398310928", "bodyText": "Yeah, can't we create handshake listener's along with the count down listeners in the respective init endpoint classes ?", "author": "shafreenAnfar", "createdAt": "2020-03-26T04:26:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzczMzc3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTE5NDAxNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r399194016", "bodyText": "we can change the readyOnConnect value by calling the ready() and store the some connection properties into the webSocketClient and use it in the iteration connection.\nTherefore these values are also dynamic. So, we can't move this to respective Endpoints.", "author": "kalaiyarasiganeshalingam", "createdAt": "2020-03-27T11:17:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzczMzc3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk2MDY2MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397960660", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return validated target URLs array\n          \n          \n            \n                 * @return - validated target URLs array", "author": "praneesha", "createdAt": "2020-03-25T15:46:39Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/websocket/client/FailoverInitEndpoint.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.net.http.websocket.client;\n+\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.net.http.websocket.WebSocketConstants;\n+import org.ballerinalang.net.http.websocket.WebSocketException;\n+import org.ballerinalang.net.http.websocket.WebSocketUtil;\n+import org.ballerinalang.net.http.websocket.client.listener.ClientConnectorListener;\n+import org.ballerinalang.net.http.websocket.client.listener.FailoverConnectorListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Initializes the Failover WebSocket Client.\n+ *\n+ * @since 1.2.0\n+ */\n+public class FailoverInitEndpoint {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(FailoverInitEndpoint.class);\n+    private static final String FAILOVER_INTERVAL = \"failoverIntervalInMillis\";\n+\n+    public static void initEndpoint(ObjectValue failoverClient) {\n+        @SuppressWarnings(WebSocketConstants.UNCHECKED)\n+        MapValue<String, Object> clientEndpointConfig = (MapValue<String, Object>) failoverClient.getMapValue(\n+                WebSocketConstants.CLIENT_ENDPOINT_CONFIG);\n+        List<String> newTargetUrls = getValidUrls(clientEndpointConfig.getArrayValue(WebSocketConstants.TARGET_URLS));\n+        // Sets the failover config values.\n+        failoverClient.set(WebSocketConstants.CLIENT_URL_CONFIG, newTargetUrls.get(0));\n+        FailoverContext failoverContext = new FailoverContext();\n+        populateFailoverContext(clientEndpointConfig, failoverContext, newTargetUrls);\n+        failoverClient.addNativeData(WebSocketConstants.FAILOVER_CONTEXT, failoverContext);\n+        failoverClient.addNativeData(WebSocketConstants.CLIENT_LISTENER, new FailoverConnectorListener(\n+                new ClientConnectorListener()));\n+        InitEndpoint.initEndpoint(failoverClient);\n+    }\n+\n+    /**\n+     * Populates the failover config.\n+     *\n+     * @param failoverConfig - a failover config\n+     * @param failoverClientConnectorConfig - a failover client connector config\n+     * @param targetUrls - target URLs\n+     */\n+    private static void populateFailoverContext(MapValue<String, Object> failoverConfig,\n+                                                FailoverContext failoverClientConnectorConfig,\n+                                                List<String> targetUrls) {\n+        failoverClientConnectorConfig.setFailoverInterval(WebSocketUtil.getIntValue(failoverConfig, FAILOVER_INTERVAL,\n+                1000));\n+        failoverClientConnectorConfig.setTargetUrls(targetUrls);\n+    }\n+\n+    /**\n+     * Checks whether the URL has a valid format or not. If it isn't in the valid format, removes that from the URL set.\n+     *\n+     * @param targets - target URLs array\n+     * @return validated target URLs array", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk2MDkzMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397960933", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // Sets the count Down latch for initial connection\n          \n          \n            \n                    // Sets the count down latch for the initial connection.", "author": "praneesha", "createdAt": "2020-03-25T15:46:58Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/websocket/client/InitEndpoint.java", "diffHunk": "@@ -47,152 +42,33 @@\n  */\n public class InitEndpoint {\n \n-    private static final Logger logger = LoggerFactory.getLogger(InitEndpoint.class);\n-    private static final String INTERVAL_IN_MILLIS = \"intervalInMillis\";\n-    private static final String MAX_WAIT_INTERVAL = \"maxWaitIntervalInMillis\";\n-    private static final String MAX_COUNT = \"maxCount\";\n-    private static final String BACK_OF_FACTOR = \"backOffFactor\";\n-\n     public static void initEndpoint(ObjectValue webSocketClient) {\n         @SuppressWarnings(WebSocketConstants.UNCHECKED)\n         MapValue<String, Object> clientEndpointConfig = (MapValue<String, Object>) webSocketClient.getMapValue(\n                 HttpConstants.CLIENT_ENDPOINT_CONFIG);\n         Strand strand = Scheduler.getStrand();\n         String remoteUrl = webSocketClient.getStringValue(WebSocketConstants.CLIENT_URL_CONFIG);\n-        WebSocketService wsService = validateAndCreateWebSocketService(clientEndpointConfig, strand);\n+        WebSocketService wsService = WebSocketUtil.validateAndCreateWebSocketService(strand, clientEndpointConfig);\n         HttpWsConnectorFactory connectorFactory = HttpUtil.createHttpWsConnectionFactory();\n         WebSocketClientConnectorConfig clientConnectorConfig = new WebSocketClientConnectorConfig(remoteUrl);\n         String scheme = URI.create(remoteUrl).getScheme();\n-        populateClientConnectorConfig(clientEndpointConfig, clientConnectorConfig, scheme);\n-        // Create the client connector.\n+        WebSocketUtil.populateClientConnectorConfig(clientEndpointConfig, clientConnectorConfig, scheme);\n+        // Creates the client connector\n         WebSocketClientConnector clientConnector = connectorFactory.createWsClientConnector(clientConnectorConfig);\n-        WebSocketClientConnectorListener clientConnectorListener = new WebSocketClientConnectorListener();\n-        // Add the client connector as a native data when the client is not a failover client\n-        // because when using one URL, there is no need to create the client connector again.\n+        webSocketClient.addNativeData(WebSocketConstants.CONNECTOR_FACTORY, connectorFactory);\n+        // Add the client connector as a native data\n+        // because there is no need to create the client connector again when using one URL\n         webSocketClient.addNativeData(WebSocketConstants.CLIENT_CONNECTOR, clientConnector);\n-        webSocketClient.addNativeData(WebSocketConstants.CLIENT_LISTENER, clientConnectorListener);\n-        if (WebSocketUtil.hasRetryConfig(webSocketClient)) {\n-            @SuppressWarnings(WebSocketConstants.UNCHECKED)\n-            MapValue<String, Object> retryConfig = (MapValue<String, Object>) clientEndpointConfig.getMapValue(\n-                    WebSocketConstants.RETRY_CONFIG);\n-            RetryContext retryConnectorConfig = new RetryContext();\n-            populateRetryConnectorConfig(retryConfig, retryConnectorConfig);\n-            webSocketClient.addNativeData(WebSocketConstants.RETRY_CONFIG, retryConnectorConfig);\n-            CountDownLatch countDownLatch = new CountDownLatch(1);\n-            webSocketClient.addNativeData(WebSocketConstants.COUNT_DOWN_LATCH, countDownLatch);\n-            WebSocketUtil.establishWebSocketConnection(webSocketClient, wsService);\n-            // Set the count Down latch for initial connection\n-            waitForHandshake(countDownLatch);\n-        } else {\n-            WebSocketUtil.establishWebSocketConnection(webSocketClient, wsService);\n-        }\n-\n-    }\n-\n-    private static void waitForHandshake(CountDownLatch countDownLatch) {\n-        try {\n-            // Wait to call countDown()\n-            countDownLatch.await();\n-        } catch (InterruptedException e) {\n-            Thread.currentThread().interrupt();\n-            throw new WebSocketException(WebSocketConstants.ERROR_MESSAGE + e.getMessage());\n-        }\n-    }\n-\n-    private static void populateClientConnectorConfig(MapValue<String, Object> clientEndpointConfig,\n-                                                      WebSocketClientConnectorConfig clientConnectorConfig,\n-                                                      String scheme) {\n-        clientConnectorConfig.setAutoRead(false); // Frames are read sequentially in ballerina.\n-        clientConnectorConfig.setSubProtocols(WebSocketUtil.findNegotiableSubProtocols(clientEndpointConfig));\n-        @SuppressWarnings(WebSocketConstants.UNCHECKED)\n-        MapValue<String, Object> headerValues = (MapValue<String, Object>) clientEndpointConfig.getMapValue(\n-                WebSocketConstants.CLIENT_CUSTOM_HEADERS_CONFIG);\n-        if (headerValues != null) {\n-            clientConnectorConfig.addHeaders(getCustomHeaders(headerValues));\n-        }\n-\n-        long idleTimeoutInSeconds = WebSocketUtil.findTimeoutInSeconds(clientEndpointConfig,\n-                WebSocketConstants.ANNOTATION_ATTR_IDLE_TIMEOUT, 0);\n-        if (idleTimeoutInSeconds > 0) {\n-            clientConnectorConfig.setIdleTimeoutInMillis((int) (idleTimeoutInSeconds * 1000));\n-        }\n-\n-        clientConnectorConfig.setMaxFrameSize(WebSocketUtil.findMaxFrameSize(clientEndpointConfig));\n-\n-        MapValue secureSocket = clientEndpointConfig.getMapValue(HttpConstants.ENDPOINT_CONFIG_SECURE_SOCKET);\n-        if (secureSocket != null) {\n-            HttpUtil.populateSSLConfiguration(clientConnectorConfig, secureSocket);\n-        } else if (scheme.equals(WebSocketConstants.WSS_SCHEME)) {\n-            clientConnectorConfig.useJavaDefaults();\n+        if (webSocketClient.getNativeData(WebSocketConstants.CLIENT_LISTENER) == null) {\n+            webSocketClient.addNativeData(WebSocketConstants.CLIENT_LISTENER, new ClientConnectorListener());\n         }\n-        clientConnectorConfig.setWebSocketCompressionEnabled(\n-                clientEndpointConfig.getBooleanValue(WebSocketConstants.COMPRESSION_ENABLED_CONFIG));\n+        CountDownLatch countDownLatch = new CountDownLatch(1);\n+        webSocketClient.addNativeData(WebSocketConstants.COUNT_DOWN_LATCH, countDownLatch);\n+        WebSocketUtil.establishWebSocketConnection(clientConnector, webSocketClient, wsService);\n+        // Sets the count Down latch for initial connection", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk2MTE5Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397961197", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Handshake listener of WebSocket client.\n          \n          \n            \n             * Handshake listener of the WebSocket client.", "author": "praneesha", "createdAt": "2020-03-25T15:47:18Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/websocket/client/listener/ClientHandshakeListener.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.net.http.websocket.client.listener;\n+\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.net.http.websocket.WebSocketResourceDispatcher;\n+import org.ballerinalang.net.http.websocket.WebSocketUtil;\n+import org.ballerinalang.net.http.websocket.server.WebSocketConnectionInfo;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketConnection;\n+import org.wso2.transport.http.netty.message.HttpCarbonResponse;\n+\n+/**\n+ * Handshake listener of WebSocket client.", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk2MTU2OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397961569", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Handshake listener of webSocket failover client.\n          \n          \n            \n             * Handshake listener of the WebSocket failover client.", "author": "praneesha", "createdAt": "2020-03-25T15:47:44Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/websocket/client/listener/FailoverHandshakeListener.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.net.http.websocket.client.listener;\n+\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.net.http.websocket.WebSocketConstants;\n+import org.ballerinalang.net.http.websocket.WebSocketResourceDispatcher;\n+import org.ballerinalang.net.http.websocket.WebSocketService;\n+import org.ballerinalang.net.http.websocket.WebSocketUtil;\n+import org.ballerinalang.net.http.websocket.client.FailoverContext;\n+import org.ballerinalang.net.http.websocket.server.WebSocketConnectionInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketConnection;\n+import org.wso2.transport.http.netty.message.HttpCarbonResponse;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Handshake listener of webSocket failover client.", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk2NzA5NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397967094", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // Creates the client connector\n          \n          \n            \n                    // Creates the client connector.", "author": "praneesha", "createdAt": "2020-03-25T15:54:22Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/websocket/client/InitEndpoint.java", "diffHunk": "@@ -47,152 +42,33 @@\n  */\n public class InitEndpoint {\n \n-    private static final Logger logger = LoggerFactory.getLogger(InitEndpoint.class);\n-    private static final String INTERVAL_IN_MILLIS = \"intervalInMillis\";\n-    private static final String MAX_WAIT_INTERVAL = \"maxWaitIntervalInMillis\";\n-    private static final String MAX_COUNT = \"maxCount\";\n-    private static final String BACK_OF_FACTOR = \"backOffFactor\";\n-\n     public static void initEndpoint(ObjectValue webSocketClient) {\n         @SuppressWarnings(WebSocketConstants.UNCHECKED)\n         MapValue<String, Object> clientEndpointConfig = (MapValue<String, Object>) webSocketClient.getMapValue(\n                 HttpConstants.CLIENT_ENDPOINT_CONFIG);\n         Strand strand = Scheduler.getStrand();\n         String remoteUrl = webSocketClient.getStringValue(WebSocketConstants.CLIENT_URL_CONFIG);\n-        WebSocketService wsService = validateAndCreateWebSocketService(clientEndpointConfig, strand);\n+        WebSocketService wsService = WebSocketUtil.validateAndCreateWebSocketService(strand, clientEndpointConfig);\n         HttpWsConnectorFactory connectorFactory = HttpUtil.createHttpWsConnectionFactory();\n         WebSocketClientConnectorConfig clientConnectorConfig = new WebSocketClientConnectorConfig(remoteUrl);\n         String scheme = URI.create(remoteUrl).getScheme();\n-        populateClientConnectorConfig(clientEndpointConfig, clientConnectorConfig, scheme);\n-        // Create the client connector.\n+        WebSocketUtil.populateClientConnectorConfig(clientEndpointConfig, clientConnectorConfig, scheme);\n+        // Creates the client connector", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk2NzQzNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397967434", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // because there is no need to create the client connector again when using one URL\n          \n          \n            \n                    // because there is no need to create the client connector again when using one URL.", "author": "praneesha", "createdAt": "2020-03-25T15:54:45Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/websocket/client/InitEndpoint.java", "diffHunk": "@@ -47,152 +42,33 @@\n  */\n public class InitEndpoint {\n \n-    private static final Logger logger = LoggerFactory.getLogger(InitEndpoint.class);\n-    private static final String INTERVAL_IN_MILLIS = \"intervalInMillis\";\n-    private static final String MAX_WAIT_INTERVAL = \"maxWaitIntervalInMillis\";\n-    private static final String MAX_COUNT = \"maxCount\";\n-    private static final String BACK_OF_FACTOR = \"backOffFactor\";\n-\n     public static void initEndpoint(ObjectValue webSocketClient) {\n         @SuppressWarnings(WebSocketConstants.UNCHECKED)\n         MapValue<String, Object> clientEndpointConfig = (MapValue<String, Object>) webSocketClient.getMapValue(\n                 HttpConstants.CLIENT_ENDPOINT_CONFIG);\n         Strand strand = Scheduler.getStrand();\n         String remoteUrl = webSocketClient.getStringValue(WebSocketConstants.CLIENT_URL_CONFIG);\n-        WebSocketService wsService = validateAndCreateWebSocketService(clientEndpointConfig, strand);\n+        WebSocketService wsService = WebSocketUtil.validateAndCreateWebSocketService(strand, clientEndpointConfig);\n         HttpWsConnectorFactory connectorFactory = HttpUtil.createHttpWsConnectionFactory();\n         WebSocketClientConnectorConfig clientConnectorConfig = new WebSocketClientConnectorConfig(remoteUrl);\n         String scheme = URI.create(remoteUrl).getScheme();\n-        populateClientConnectorConfig(clientEndpointConfig, clientConnectorConfig, scheme);\n-        // Create the client connector.\n+        WebSocketUtil.populateClientConnectorConfig(clientEndpointConfig, clientConnectorConfig, scheme);\n+        // Creates the client connector\n         WebSocketClientConnector clientConnector = connectorFactory.createWsClientConnector(clientConnectorConfig);\n-        WebSocketClientConnectorListener clientConnectorListener = new WebSocketClientConnectorListener();\n-        // Add the client connector as a native data when the client is not a failover client\n-        // because when using one URL, there is no need to create the client connector again.\n+        webSocketClient.addNativeData(WebSocketConstants.CONNECTOR_FACTORY, connectorFactory);\n+        // Add the client connector as a native data\n+        // because there is no need to create the client connector again when using one URL", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk2ODIzMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397968230", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // Cannot reach this point as onHandshake and onOpen is not supported for WebSocket client service\n          \n          \n            \n                    // Cannot reach this point as `onHandshake` and `onOpen` are not supported by WebSocket client services.", "author": "praneesha", "createdAt": "2020-03-25T15:55:48Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/websocket/client/listener/FailoverConnectorListener.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ *  Copyright (c) 2017, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package org.ballerinalang.net.http.websocket.client.listener;\n+\n+import org.ballerinalang.net.http.websocket.WebSocketConstants;\n+import org.ballerinalang.net.http.websocket.WebSocketUtil;\n+import org.ballerinalang.net.http.websocket.server.WebSocketConnectionInfo;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketBinaryMessage;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketCloseMessage;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketConnection;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketControlMessage;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketHandshaker;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketTextMessage;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Ballerina Connector listener of WebSocket failover.\n+ *\n+ * @since 1.2.0\n+ */\n+public class FailoverConnectorListener implements ExtendedConnectorListener {\n+\n+    private WebSocketConnectionInfo connectionInfo = null;\n+    private ExtendedConnectorListener connectorListener;\n+\n+    public FailoverConnectorListener(ExtendedConnectorListener connectorListener) {\n+        this.connectorListener = connectorListener;\n+    }\n+\n+    @Override\n+    public void setConnectionInfo(WebSocketConnectionInfo connectionInfo) {\n+        connectorListener.setConnectionInfo(connectionInfo);\n+        this.connectionInfo = connectionInfo;\n+    }\n+\n+    @Override\n+    public void onHandshake(WebSocketHandshaker webSocketHandshaker) {\n+        // Cannot reach this point as onHandshake and onOpen is not supported for WebSocket client service", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk2ODM3MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397968371", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // When the connection is lost, do the failover to the remaining server URLs\n          \n          \n            \n                    // When the connection is lost, do the failover to the remaining server URLs.", "author": "praneesha", "createdAt": "2020-03-25T15:55:58Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/websocket/client/listener/FailoverConnectorListener.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ *  Copyright (c) 2017, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package org.ballerinalang.net.http.websocket.client.listener;\n+\n+import org.ballerinalang.net.http.websocket.WebSocketConstants;\n+import org.ballerinalang.net.http.websocket.WebSocketUtil;\n+import org.ballerinalang.net.http.websocket.server.WebSocketConnectionInfo;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketBinaryMessage;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketCloseMessage;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketConnection;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketControlMessage;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketHandshaker;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketTextMessage;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Ballerina Connector listener of WebSocket failover.\n+ *\n+ * @since 1.2.0\n+ */\n+public class FailoverConnectorListener implements ExtendedConnectorListener {\n+\n+    private WebSocketConnectionInfo connectionInfo = null;\n+    private ExtendedConnectorListener connectorListener;\n+\n+    public FailoverConnectorListener(ExtendedConnectorListener connectorListener) {\n+        this.connectorListener = connectorListener;\n+    }\n+\n+    @Override\n+    public void setConnectionInfo(WebSocketConnectionInfo connectionInfo) {\n+        connectorListener.setConnectionInfo(connectionInfo);\n+        this.connectionInfo = connectionInfo;\n+    }\n+\n+    @Override\n+    public void onHandshake(WebSocketHandshaker webSocketHandshaker) {\n+        // Cannot reach this point as onHandshake and onOpen is not supported for WebSocket client service\n+    }\n+\n+    @Override\n+    public void onMessage(WebSocketTextMessage textMessage) {\n+        connectorListener.onMessage(textMessage);\n+    }\n+\n+    @Override\n+    public void onMessage(WebSocketBinaryMessage binaryMessage) {\n+        connectorListener.onMessage(binaryMessage);\n+    }\n+\n+    @Override\n+    public void onMessage(WebSocketControlMessage controlMessage) {\n+        connectorListener.onMessage(controlMessage);\n+    }\n+\n+    @Override\n+    public void onMessage(WebSocketCloseMessage webSocketCloseMessage) {\n+        int statusCode = webSocketCloseMessage.getCloseCode();\n+        if (!(statusCode == WebSocketConstants.STATUS_CODE_ABNORMAL_CLOSURE &&\n+                WebSocketUtil.failover(connectionInfo.getWebSocketEndpoint(), connectionInfo.getService()))) {\n+            connectorListener.onMessage(webSocketCloseMessage);\n+        }\n+    }\n+\n+    @Override\n+    public void onClose(WebSocketConnection webSocketConnection) {\n+        connectorListener.onClose(webSocketConnection);\n+    }\n+\n+    @Override\n+    public void onError(WebSocketConnection webSocketConnection, Throwable throwable) {\n+        // When the connection is lost, do the failover to the remaining server URLs", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk2ODczNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397968735", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // Sets failover context variable's value\n          \n          \n            \n                    // Sets the value of the failover context variable.", "author": "praneesha", "createdAt": "2020-03-25T15:56:25Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/websocket/client/listener/FailoverHandshakeListener.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.net.http.websocket.client.listener;\n+\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.net.http.websocket.WebSocketConstants;\n+import org.ballerinalang.net.http.websocket.WebSocketResourceDispatcher;\n+import org.ballerinalang.net.http.websocket.WebSocketService;\n+import org.ballerinalang.net.http.websocket.WebSocketUtil;\n+import org.ballerinalang.net.http.websocket.client.FailoverContext;\n+import org.ballerinalang.net.http.websocket.server.WebSocketConnectionInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketConnection;\n+import org.wso2.transport.http.netty.message.HttpCarbonResponse;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Handshake listener of webSocket failover client.\n+ *\n+ * @since 1.2.0\n+ */\n+public class FailoverHandshakeListener implements ExtendedHandshakeListener {\n+\n+    private final WebSocketService wsService;\n+    private ExtendedHandshakeListener handshakeListener;\n+    private static final Logger logger = LoggerFactory.getLogger(FailoverHandshakeListener.class);\n+\n+    public FailoverHandshakeListener(ExtendedHandshakeListener handshakeListener, WebSocketService wsService) {\n+        this.handshakeListener = handshakeListener;\n+        this.wsService = wsService;\n+    }\n+\n+    @Override\n+    public void onSuccess(WebSocketConnection webSocketConnection, HttpCarbonResponse response) {\n+        handshakeListener.onSuccess(webSocketConnection, response);\n+        FailoverContext failoverContext = (FailoverContext) getWebSocketClient().getNativeData(WebSocketConstants.\n+                FAILOVER_CONTEXT);\n+        int currentIndex = failoverContext.getCurrentIndex();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(WebSocketConstants.LOG_MESSAGE, WebSocketConstants.CONNECTED_TO,\n+                    failoverContext.getTargetUrls().get(failoverContext.getCurrentIndex()));\n+        }\n+        // Sets failover context variable's value", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk2ODg3Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397968873", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // When the connection is lost, do the failover to the remaining server URLs\n          \n          \n            \n                    // When the connection is lost, do the failover to the remaining server URLs.", "author": "praneesha", "createdAt": "2020-03-25T15:56:32Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/websocket/client/listener/FailoverHandshakeListener.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.net.http.websocket.client.listener;\n+\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.net.http.websocket.WebSocketConstants;\n+import org.ballerinalang.net.http.websocket.WebSocketResourceDispatcher;\n+import org.ballerinalang.net.http.websocket.WebSocketService;\n+import org.ballerinalang.net.http.websocket.WebSocketUtil;\n+import org.ballerinalang.net.http.websocket.client.FailoverContext;\n+import org.ballerinalang.net.http.websocket.server.WebSocketConnectionInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketConnection;\n+import org.wso2.transport.http.netty.message.HttpCarbonResponse;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Handshake listener of webSocket failover client.\n+ *\n+ * @since 1.2.0\n+ */\n+public class FailoverHandshakeListener implements ExtendedHandshakeListener {\n+\n+    private final WebSocketService wsService;\n+    private ExtendedHandshakeListener handshakeListener;\n+    private static final Logger logger = LoggerFactory.getLogger(FailoverHandshakeListener.class);\n+\n+    public FailoverHandshakeListener(ExtendedHandshakeListener handshakeListener, WebSocketService wsService) {\n+        this.handshakeListener = handshakeListener;\n+        this.wsService = wsService;\n+    }\n+\n+    @Override\n+    public void onSuccess(WebSocketConnection webSocketConnection, HttpCarbonResponse response) {\n+        handshakeListener.onSuccess(webSocketConnection, response);\n+        FailoverContext failoverContext = (FailoverContext) getWebSocketClient().getNativeData(WebSocketConstants.\n+                FAILOVER_CONTEXT);\n+        int currentIndex = failoverContext.getCurrentIndex();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(WebSocketConstants.LOG_MESSAGE, WebSocketConstants.CONNECTED_TO,\n+                    failoverContext.getTargetUrls().get(failoverContext.getCurrentIndex()));\n+        }\n+        // Sets failover context variable's value\n+        failoverContext.setInitialIndex(currentIndex);\n+        failoverContext.setFirstConnectionEstablished();\n+    }\n+\n+    @Override\n+    public void onError(Throwable throwable, HttpCarbonResponse response) {\n+        handshakeListener.onError(throwable, response);\n+        ObjectValue webSocketClient = getWebSocketClient();\n+        // When the connection is lost, do the failover to the remaining server URLs", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk2OTUwNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397969505", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        // Calls the countDown() to initial connection's countDown latch\n          \n          \n            \n                        // Calls the `countDown()` function to initialize the count down latch of the connection.", "author": "praneesha", "createdAt": "2020-03-25T15:57:17Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/websocket/client/listener/FailoverHandshakeListener.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.net.http.websocket.client.listener;\n+\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.net.http.websocket.WebSocketConstants;\n+import org.ballerinalang.net.http.websocket.WebSocketResourceDispatcher;\n+import org.ballerinalang.net.http.websocket.WebSocketService;\n+import org.ballerinalang.net.http.websocket.WebSocketUtil;\n+import org.ballerinalang.net.http.websocket.client.FailoverContext;\n+import org.ballerinalang.net.http.websocket.server.WebSocketConnectionInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketConnection;\n+import org.wso2.transport.http.netty.message.HttpCarbonResponse;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Handshake listener of webSocket failover client.\n+ *\n+ * @since 1.2.0\n+ */\n+public class FailoverHandshakeListener implements ExtendedHandshakeListener {\n+\n+    private final WebSocketService wsService;\n+    private ExtendedHandshakeListener handshakeListener;\n+    private static final Logger logger = LoggerFactory.getLogger(FailoverHandshakeListener.class);\n+\n+    public FailoverHandshakeListener(ExtendedHandshakeListener handshakeListener, WebSocketService wsService) {\n+        this.handshakeListener = handshakeListener;\n+        this.wsService = wsService;\n+    }\n+\n+    @Override\n+    public void onSuccess(WebSocketConnection webSocketConnection, HttpCarbonResponse response) {\n+        handshakeListener.onSuccess(webSocketConnection, response);\n+        FailoverContext failoverContext = (FailoverContext) getWebSocketClient().getNativeData(WebSocketConstants.\n+                FAILOVER_CONTEXT);\n+        int currentIndex = failoverContext.getCurrentIndex();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(WebSocketConstants.LOG_MESSAGE, WebSocketConstants.CONNECTED_TO,\n+                    failoverContext.getTargetUrls().get(failoverContext.getCurrentIndex()));\n+        }\n+        // Sets failover context variable's value\n+        failoverContext.setInitialIndex(currentIndex);\n+        failoverContext.setFirstConnectionEstablished();\n+    }\n+\n+    @Override\n+    public void onError(Throwable throwable, HttpCarbonResponse response) {\n+        handshakeListener.onError(throwable, response);\n+        ObjectValue webSocketClient = getWebSocketClient();\n+        // When the connection is lost, do the failover to the remaining server URLs\n+        if (!(throwable instanceof IOException && WebSocketUtil.failover(webSocketClient, wsService))) {\n+            // Calls the countDown() to initial connection's countDown latch", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk2OTc4Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397969783", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Handshake listener for retry WebSocket client.\n          \n          \n            \n             * Handshake listener for retrying of the WebSocket client.", "author": "praneesha", "createdAt": "2020-03-25T15:57:39Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/websocket/client/listener/RetryHandshakeListener.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.net.http.websocket.client.listener;\n+\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.net.http.websocket.WebSocketConstants;\n+import org.ballerinalang.net.http.websocket.WebSocketResourceDispatcher;\n+import org.ballerinalang.net.http.websocket.WebSocketService;\n+import org.ballerinalang.net.http.websocket.WebSocketUtil;\n+import org.ballerinalang.net.http.websocket.client.RetryContext;\n+import org.ballerinalang.net.http.websocket.server.WebSocketConnectionInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketConnection;\n+import org.wso2.transport.http.netty.message.HttpCarbonResponse;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Handshake listener for retry WebSocket client.", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk3MDA5MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397970090", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * WebSocketHandshakeListener implements {@link ExtendedHandshakeListener} interface directly.\n          \n          \n            \n             * The `WebSocketHandshakeListener` implements the `{@link ExtendedHandshakeListener}` interface directly.", "author": "praneesha", "createdAt": "2020-03-25T15:58:02Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/websocket/client/listener/WebSocketHandshakeListener.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.net.http.websocket.client.listener;\n+\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.net.http.HttpConstants;\n+import org.ballerinalang.net.http.HttpUtil;\n+import org.ballerinalang.net.http.websocket.WebSocketConstants;\n+import org.ballerinalang.net.http.websocket.WebSocketService;\n+import org.ballerinalang.net.http.websocket.WebSocketUtil;\n+import org.ballerinalang.net.http.websocket.client.FailoverContext;\n+import org.ballerinalang.net.http.websocket.client.RetryContext;\n+import org.ballerinalang.net.http.websocket.observability.WebSocketObservabilityUtil;\n+import org.ballerinalang.net.http.websocket.server.WebSocketConnectionInfo;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketConnection;\n+import org.wso2.transport.http.netty.message.HttpCarbonResponse;\n+\n+import java.util.concurrent.CountDownLatch;\n+\n+import static org.ballerinalang.net.http.HttpConstants.CLIENT_ENDPOINT_CONFIG;\n+\n+/**\n+ * WebSocketHandshakeListener implements {@link ExtendedHandshakeListener} interface directly.", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk3MDU0MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397970541", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        // Calls the countDown() to initial connection's countDown latch\n          \n          \n            \n                        // Calls the `countDown()` function to initialize the count down latch of the connection.", "author": "praneesha", "createdAt": "2020-03-25T15:58:34Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/websocket/client/listener/WebSocketHandshakeListener.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.net.http.websocket.client.listener;\n+\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.net.http.HttpConstants;\n+import org.ballerinalang.net.http.HttpUtil;\n+import org.ballerinalang.net.http.websocket.WebSocketConstants;\n+import org.ballerinalang.net.http.websocket.WebSocketService;\n+import org.ballerinalang.net.http.websocket.WebSocketUtil;\n+import org.ballerinalang.net.http.websocket.client.FailoverContext;\n+import org.ballerinalang.net.http.websocket.client.RetryContext;\n+import org.ballerinalang.net.http.websocket.observability.WebSocketObservabilityUtil;\n+import org.ballerinalang.net.http.websocket.server.WebSocketConnectionInfo;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketConnection;\n+import org.wso2.transport.http.netty.message.HttpCarbonResponse;\n+\n+import java.util.concurrent.CountDownLatch;\n+\n+import static org.ballerinalang.net.http.HttpConstants.CLIENT_ENDPOINT_CONFIG;\n+\n+/**\n+ * WebSocketHandshakeListener implements {@link ExtendedHandshakeListener} interface directly.\n+ *\n+ * @since 1.2.0\n+ */\n+public class WebSocketHandshakeListener implements ExtendedHandshakeListener {\n+\n+    private final WebSocketService wsService;\n+    private final ExtendedConnectorListener connectorListener;\n+    private final ObjectValue webSocketClient;\n+    private CountDownLatch countDownLatch;\n+    private WebSocketConnectionInfo connectionInfo;\n+        private boolean readyOnConnect;\n+\n+    public WebSocketHandshakeListener(ObjectValue webSocketClient, WebSocketService wsService,\n+                                      ExtendedConnectorListener connectorListener,\n+                                      CountDownLatch countDownLatch, boolean readyOnConnect) {\n+        this.webSocketClient = webSocketClient;\n+        this.wsService = wsService;\n+        this.connectorListener = connectorListener;\n+        this.countDownLatch = countDownLatch;\n+        this.readyOnConnect = readyOnConnect;\n+    }\n+    @Override\n+    public void onSuccess(WebSocketConnection webSocketConnection, HttpCarbonResponse carbonResponse) {\n+        ObjectValue webSocketConnector;\n+        webSocketClient.set(WebSocketConstants.CLIENT_RESPONSE_FIELD, HttpUtil.createResponseStruct(carbonResponse));\n+        if (isFirstConnectionEstablished(webSocketClient)) {\n+            webSocketConnector = (ObjectValue) webSocketClient.get(WebSocketConstants.CLIENT_CONNECTOR_FIELD);\n+            webSocketClient.set(WebSocketConstants.LISTENER_ID_FIELD, webSocketConnection.getChannelId());\n+        } else {\n+            webSocketConnector = createWebSocketConnector(readyOnConnect);\n+            WebSocketUtil.populateWebSocketEndpoint(webSocketConnection, webSocketClient);\n+            // Calls the countDown() to initial connection's countDown latch", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk3MTIyMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397971220", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // Sets readyOnConnect's value to the created webSocketConnector's isReady field\n          \n          \n            \n                    // Sets the value of `readyOnConnect` to the created `isReady' field of the webSocketConnector.", "author": "praneesha", "createdAt": "2020-03-25T15:59:25Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/websocket/client/listener/WebSocketHandshakeListener.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.net.http.websocket.client.listener;\n+\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.net.http.HttpConstants;\n+import org.ballerinalang.net.http.HttpUtil;\n+import org.ballerinalang.net.http.websocket.WebSocketConstants;\n+import org.ballerinalang.net.http.websocket.WebSocketService;\n+import org.ballerinalang.net.http.websocket.WebSocketUtil;\n+import org.ballerinalang.net.http.websocket.client.FailoverContext;\n+import org.ballerinalang.net.http.websocket.client.RetryContext;\n+import org.ballerinalang.net.http.websocket.observability.WebSocketObservabilityUtil;\n+import org.ballerinalang.net.http.websocket.server.WebSocketConnectionInfo;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketConnection;\n+import org.wso2.transport.http.netty.message.HttpCarbonResponse;\n+\n+import java.util.concurrent.CountDownLatch;\n+\n+import static org.ballerinalang.net.http.HttpConstants.CLIENT_ENDPOINT_CONFIG;\n+\n+/**\n+ * WebSocketHandshakeListener implements {@link ExtendedHandshakeListener} interface directly.\n+ *\n+ * @since 1.2.0\n+ */\n+public class WebSocketHandshakeListener implements ExtendedHandshakeListener {\n+\n+    private final WebSocketService wsService;\n+    private final ExtendedConnectorListener connectorListener;\n+    private final ObjectValue webSocketClient;\n+    private CountDownLatch countDownLatch;\n+    private WebSocketConnectionInfo connectionInfo;\n+        private boolean readyOnConnect;\n+\n+    public WebSocketHandshakeListener(ObjectValue webSocketClient, WebSocketService wsService,\n+                                      ExtendedConnectorListener connectorListener,\n+                                      CountDownLatch countDownLatch, boolean readyOnConnect) {\n+        this.webSocketClient = webSocketClient;\n+        this.wsService = wsService;\n+        this.connectorListener = connectorListener;\n+        this.countDownLatch = countDownLatch;\n+        this.readyOnConnect = readyOnConnect;\n+    }\n+    @Override\n+    public void onSuccess(WebSocketConnection webSocketConnection, HttpCarbonResponse carbonResponse) {\n+        ObjectValue webSocketConnector;\n+        webSocketClient.set(WebSocketConstants.CLIENT_RESPONSE_FIELD, HttpUtil.createResponseStruct(carbonResponse));\n+        if (isFirstConnectionEstablished(webSocketClient)) {\n+            webSocketConnector = (ObjectValue) webSocketClient.get(WebSocketConstants.CLIENT_CONNECTOR_FIELD);\n+            webSocketClient.set(WebSocketConstants.LISTENER_ID_FIELD, webSocketConnection.getChannelId());\n+        } else {\n+            webSocketConnector = createWebSocketConnector(readyOnConnect);\n+            WebSocketUtil.populateWebSocketEndpoint(webSocketConnection, webSocketClient);\n+            // Calls the countDown() to initial connection's countDown latch\n+            WebSocketUtil.countDownForHandshake(webSocketClient);\n+        }\n+        if (readyOnConnect) {\n+            WebSocketUtil.readFirstFrame(webSocketConnection, webSocketConnector);\n+        }\n+        setWebSocketOpenConnectionInfo(webSocketConnection, webSocketConnector, webSocketClient, wsService);\n+        connectorListener.setConnectionInfo(connectionInfo);\n+        countDownLatch.countDown();\n+        WebSocketObservabilityUtil.observeConnection(connectionInfo);\n+    }\n+\n+    @Override\n+    public void onError(Throwable t, HttpCarbonResponse response) {\n+        if (response != null) {\n+            webSocketClient.set(WebSocketConstants.CLIENT_RESPONSE_FIELD, HttpUtil.createResponseStruct(response));\n+        }\n+        ObjectValue webSocketConnector = BallerinaValues.createObjectValue(WebSocketConstants.PROTOCOL_HTTP_PKG_ID,\n+                WebSocketConstants.WEBSOCKET_CONNECTOR);\n+        setWebSocketOpenConnectionInfo(null, webSocketConnector, webSocketClient, wsService);\n+        webSocketConnector.addNativeData(WebSocketConstants.NATIVE_DATA_WEBSOCKET_CONNECTION_INFO, connectionInfo);\n+        webSocketClient.set(WebSocketConstants.CLIENT_CONNECTOR_FIELD, webSocketConnector);\n+        countDownLatch.countDown();\n+    }\n+\n+    @Override\n+    public ObjectValue getWebSocketClient() {\n+        return webSocketClient;\n+    }\n+\n+    @Override\n+    public WebSocketConnectionInfo getWebSocketConnectionInfo() {\n+        return connectionInfo;\n+    }\n+\n+    private void setWebSocketOpenConnectionInfo(WebSocketConnection webSocketConnection,\n+                                                ObjectValue webSocketConnector,\n+                                                ObjectValue webSocketClient, WebSocketService wsService) {\n+        this.connectionInfo = new WebSocketConnectionInfo(wsService, webSocketConnection, webSocketClient);\n+        webSocketConnector.addNativeData(WebSocketConstants.NATIVE_DATA_WEBSOCKET_CONNECTION_INFO, connectionInfo);\n+        webSocketClient.set(WebSocketConstants.CLIENT_CONNECTOR_FIELD, webSocketConnector);\n+    }\n+\n+    private static ObjectValue createWebSocketConnector(boolean readyOnConnect) {\n+        ObjectValue webSocketConnector = BallerinaValues.createObjectValue(HttpConstants.PROTOCOL_HTTP_PKG_ID,\n+                WebSocketConstants.WEBSOCKET_CONNECTOR);\n+        // Sets readyOnConnect's value to the created webSocketConnector's isReady field", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk3MTgxOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397971818", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // It uses to check whether readNextFrame function already called or not When call the ready() function\n          \n          \n            \n                    // It checks whether the `readNextFrame` function is already called or not when the `ready()` function is called.", "author": "praneesha", "createdAt": "2020-03-25T16:00:08Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/websocket/client/listener/WebSocketHandshakeListener.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.net.http.websocket.client.listener;\n+\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.net.http.HttpConstants;\n+import org.ballerinalang.net.http.HttpUtil;\n+import org.ballerinalang.net.http.websocket.WebSocketConstants;\n+import org.ballerinalang.net.http.websocket.WebSocketService;\n+import org.ballerinalang.net.http.websocket.WebSocketUtil;\n+import org.ballerinalang.net.http.websocket.client.FailoverContext;\n+import org.ballerinalang.net.http.websocket.client.RetryContext;\n+import org.ballerinalang.net.http.websocket.observability.WebSocketObservabilityUtil;\n+import org.ballerinalang.net.http.websocket.server.WebSocketConnectionInfo;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketConnection;\n+import org.wso2.transport.http.netty.message.HttpCarbonResponse;\n+\n+import java.util.concurrent.CountDownLatch;\n+\n+import static org.ballerinalang.net.http.HttpConstants.CLIENT_ENDPOINT_CONFIG;\n+\n+/**\n+ * WebSocketHandshakeListener implements {@link ExtendedHandshakeListener} interface directly.\n+ *\n+ * @since 1.2.0\n+ */\n+public class WebSocketHandshakeListener implements ExtendedHandshakeListener {\n+\n+    private final WebSocketService wsService;\n+    private final ExtendedConnectorListener connectorListener;\n+    private final ObjectValue webSocketClient;\n+    private CountDownLatch countDownLatch;\n+    private WebSocketConnectionInfo connectionInfo;\n+        private boolean readyOnConnect;\n+\n+    public WebSocketHandshakeListener(ObjectValue webSocketClient, WebSocketService wsService,\n+                                      ExtendedConnectorListener connectorListener,\n+                                      CountDownLatch countDownLatch, boolean readyOnConnect) {\n+        this.webSocketClient = webSocketClient;\n+        this.wsService = wsService;\n+        this.connectorListener = connectorListener;\n+        this.countDownLatch = countDownLatch;\n+        this.readyOnConnect = readyOnConnect;\n+    }\n+    @Override\n+    public void onSuccess(WebSocketConnection webSocketConnection, HttpCarbonResponse carbonResponse) {\n+        ObjectValue webSocketConnector;\n+        webSocketClient.set(WebSocketConstants.CLIENT_RESPONSE_FIELD, HttpUtil.createResponseStruct(carbonResponse));\n+        if (isFirstConnectionEstablished(webSocketClient)) {\n+            webSocketConnector = (ObjectValue) webSocketClient.get(WebSocketConstants.CLIENT_CONNECTOR_FIELD);\n+            webSocketClient.set(WebSocketConstants.LISTENER_ID_FIELD, webSocketConnection.getChannelId());\n+        } else {\n+            webSocketConnector = createWebSocketConnector(readyOnConnect);\n+            WebSocketUtil.populateWebSocketEndpoint(webSocketConnection, webSocketClient);\n+            // Calls the countDown() to initial connection's countDown latch\n+            WebSocketUtil.countDownForHandshake(webSocketClient);\n+        }\n+        if (readyOnConnect) {\n+            WebSocketUtil.readFirstFrame(webSocketConnection, webSocketConnector);\n+        }\n+        setWebSocketOpenConnectionInfo(webSocketConnection, webSocketConnector, webSocketClient, wsService);\n+        connectorListener.setConnectionInfo(connectionInfo);\n+        countDownLatch.countDown();\n+        WebSocketObservabilityUtil.observeConnection(connectionInfo);\n+    }\n+\n+    @Override\n+    public void onError(Throwable t, HttpCarbonResponse response) {\n+        if (response != null) {\n+            webSocketClient.set(WebSocketConstants.CLIENT_RESPONSE_FIELD, HttpUtil.createResponseStruct(response));\n+        }\n+        ObjectValue webSocketConnector = BallerinaValues.createObjectValue(WebSocketConstants.PROTOCOL_HTTP_PKG_ID,\n+                WebSocketConstants.WEBSOCKET_CONNECTOR);\n+        setWebSocketOpenConnectionInfo(null, webSocketConnector, webSocketClient, wsService);\n+        webSocketConnector.addNativeData(WebSocketConstants.NATIVE_DATA_WEBSOCKET_CONNECTION_INFO, connectionInfo);\n+        webSocketClient.set(WebSocketConstants.CLIENT_CONNECTOR_FIELD, webSocketConnector);\n+        countDownLatch.countDown();\n+    }\n+\n+    @Override\n+    public ObjectValue getWebSocketClient() {\n+        return webSocketClient;\n+    }\n+\n+    @Override\n+    public WebSocketConnectionInfo getWebSocketConnectionInfo() {\n+        return connectionInfo;\n+    }\n+\n+    private void setWebSocketOpenConnectionInfo(WebSocketConnection webSocketConnection,\n+                                                ObjectValue webSocketConnector,\n+                                                ObjectValue webSocketClient, WebSocketService wsService) {\n+        this.connectionInfo = new WebSocketConnectionInfo(wsService, webSocketConnection, webSocketClient);\n+        webSocketConnector.addNativeData(WebSocketConstants.NATIVE_DATA_WEBSOCKET_CONNECTION_INFO, connectionInfo);\n+        webSocketClient.set(WebSocketConstants.CLIENT_CONNECTOR_FIELD, webSocketConnector);\n+    }\n+\n+    private static ObjectValue createWebSocketConnector(boolean readyOnConnect) {\n+        ObjectValue webSocketConnector = BallerinaValues.createObjectValue(HttpConstants.PROTOCOL_HTTP_PKG_ID,\n+                WebSocketConstants.WEBSOCKET_CONNECTOR);\n+        // Sets readyOnConnect's value to the created webSocketConnector's isReady field\n+        // It uses to check whether readNextFrame function already called or not When call the ready() function", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk3MjAwMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397972002", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Tests failover support of the WebSocket client.\n          \n          \n            \n             * Tests the failover support of the WebSocket client.", "author": "praneesha", "createdAt": "2020-03-25T16:00:23Z", "path": "tests/jballerina-integration-test/src/test/java/org/ballerinalang/test/service/websocket/FailoverClientTest.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package org.ballerinalang.test.service.websocket;\n+\n+import io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;\n+import org.ballerinalang.test.context.BallerinaTestException;\n+import org.ballerinalang.test.util.websocket.client.WebSocketTestClient;\n+import org.ballerinalang.test.util.websocket.server.WebSocketRemoteServer;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.net.URISyntaxException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Tests failover support of the WebSocket client.", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMzMDk1Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r398330953", "bodyText": "Why is this function called setCallback? Can we use a better name? It doesn't seem to set any callbacks.", "author": "riyafa", "createdAt": "2020-03-26T05:49:15Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/actions/websocketconnector/WebSocketConnector.java", "diffHunk": "@@ -127,8 +127,25 @@ public static Object pong(ObjectValue wsConnection, ArrayValue binaryData) {\n                                                     WebSocketObservabilityConstants.ERROR_TYPE_MESSAGE_SENT,\n                                                     WebSocketObservabilityConstants.MESSAGE_TYPE_PONG,\n                                                     e.getMessage());\n-            callback.notifyFailure(WebSocketUtil.createErrorByType(e));\n+            setCallback(connectionInfo, callback, e);\n         }\n         return null;\n     }\n+\n+    public static void setCallback(WebSocketConnectionInfo connectionInfo, NonBlockingCallback callback,", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA0MDI4OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r399040289", "bodyText": "Changed it", "author": "kalaiyarasiganeshalingam", "createdAt": "2020-03-27T05:17:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMzMDk1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMzMTkyOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r398331929", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static boolean isClientSupportResiliency(WebSocketConnectionInfo connectionInfo) {\n          \n          \n            \n                private static boolean hasSupportForResiliency(WebSocketConnectionInfo connectionInfo) {", "author": "riyafa", "createdAt": "2020-03-26T05:53:03Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/actions/websocketconnector/WebSocketConnector.java", "diffHunk": "@@ -127,8 +127,25 @@ public static Object pong(ObjectValue wsConnection, ArrayValue binaryData) {\n                                                     WebSocketObservabilityConstants.ERROR_TYPE_MESSAGE_SENT,\n                                                     WebSocketObservabilityConstants.MESSAGE_TYPE_PONG,\n                                                     e.getMessage());\n-            callback.notifyFailure(WebSocketUtil.createErrorByType(e));\n+            setCallback(connectionInfo, callback, e);\n         }\n         return null;\n     }\n+\n+    public static void setCallback(WebSocketConnectionInfo connectionInfo, NonBlockingCallback callback,\n+                                   Throwable error) {\n+        if (isClientSupportResiliency(connectionInfo)) {\n+            ErrorHandlerUtils.printError(error);\n+            callback.notifySuccess();\n+        } else {\n+            callback.notifyFailure(WebSocketUtil.createErrorByType(error));\n+        }\n+    }\n+\n+    private static boolean isClientSupportResiliency(WebSocketConnectionInfo connectionInfo) {", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMzMzExMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r398333113", "bodyText": "Why do we handle resiliency cases differently?", "author": "riyafa", "createdAt": "2020-03-26T05:57:20Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/actions/websocketconnector/WebSocketConnector.java", "diffHunk": "@@ -127,8 +127,25 @@ public static Object pong(ObjectValue wsConnection, ArrayValue binaryData) {\n                                                     WebSocketObservabilityConstants.ERROR_TYPE_MESSAGE_SENT,\n                                                     WebSocketObservabilityConstants.MESSAGE_TYPE_PONG,\n                                                     e.getMessage());\n-            callback.notifyFailure(WebSocketUtil.createErrorByType(e));\n+            setCallback(connectionInfo, callback, e);\n         }\n         return null;\n     }\n+\n+    public static void setCallback(WebSocketConnectionInfo connectionInfo, NonBlockingCallback callback,\n+                                   Throwable error) {\n+        if (isClientSupportResiliency(connectionInfo)) {", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTAzNTg0MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r399035840", "bodyText": "In other places, we checked whether client supports retry|not  or failover|not but here, we are checking that client supports retry|failover|not. So, I handled like this.", "author": "kalaiyarasiganeshalingam", "createdAt": "2020-03-27T04:57:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMzMzExMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMzMzM0MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r398333340", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Service validator for the failover WebSocket.\n          \n          \n            \n             * Service validator for WebSocket failover.", "author": "riyafa", "createdAt": "2020-03-26T05:58:04Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/compiler/websocket/WebSocketFailoverClientResourceValidator.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.ballerinalang.net.http.compiler.websocket;\n+\n+import org.ballerinalang.net.http.websocket.WebSocketConstants;\n+import org.ballerinalang.util.diagnostic.Diagnostic;\n+import org.ballerinalang.util.diagnostic.DiagnosticLog;\n+import org.wso2.ballerinalang.compiler.tree.BLangFunction;\n+\n+/**\n+ * Service validator for the failover WebSocket.", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMzNTQ3OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r398335479", "bodyText": "Shall we not use static imports?", "author": "riyafa", "createdAt": "2020-03-26T06:05:39Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/compiler/websocket/WebSocketFailoverClientServiceCompilerPlugin.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.ballerinalang.net.http.compiler.websocket;\n+\n+import org.ballerinalang.compiler.plugins.AbstractCompilerPlugin;\n+import org.ballerinalang.compiler.plugins.SupportedResourceParamTypes;\n+import org.ballerinalang.model.tree.AnnotationAttachmentNode;\n+import org.ballerinalang.model.tree.ServiceNode;\n+import org.ballerinalang.net.http.websocket.WebSocketConstants;\n+import org.ballerinalang.util.diagnostic.DiagnosticLog;\n+import org.wso2.ballerinalang.compiler.tree.BLangFunction;\n+\n+import java.util.List;\n+\n+import static org.ballerinalang.net.http.websocket.WebSocketConstants.FAILOVER_WEBSOCKET_CLIENT;", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMzNTg2MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r398335861", "bodyText": "Shall we have this constant in the relevant class?", "author": "riyafa", "createdAt": "2020-03-26T06:07:11Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/websocket/WebSocketConstants.java", "diffHunk": "@@ -79,13 +79,22 @@\n     public static final String CLIENT_READY_ON_CONNECT = \"readyOnConnect\";\n     public static final String WEBSOCKET_UPGRADE_SERVICE_CONFIG = \"upgradeService\";\n \n-    public static final String RETRY_CONFIG = \"retryConfig\";\n+    public static final String RETRY_CONTEXT = \"retryConfig\";\n     public static final String COUNT_DOWN_LATCH = \"countDownLatch\";\n     public static final String CLIENT_LISTENER = \"clientListener\";\n     public static final String CLIENT_CONNECTOR = \"clientConnector\";\n     public static final String LOG_MESSAGE = \"{} {}\";\n     public static final String ERROR_MESSAGE = \"Error occurred: \";\n \n+    public static final String CLIENT_ENDPOINT_CONFIG = \"config\";\n+    public static final String TARGET_URLS = \"targetUrls\";\n+    public static final String FAILOVER_CONTEXT = \"failoverContext\";\n+    public static final String CONNECTOR_FACTORY = \"connectorFactory\";\n+    public static final String FAILOVER_WEBSOCKET_CLIENT = \"WebSocketFailoverClient\";\n+    public static final String CONNECTED_TO = \"Connected to \";", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTAzOTkwNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r399039906", "bodyText": "We are using in both classes now(#21187 615a022) So I'm keeping here.", "author": "kalaiyarasiganeshalingam", "createdAt": "2020-03-27T05:15:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMzNTg2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA0NjEyMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r399046121", "bodyText": "I meant this comment? #21187 (comment)\nApplies to LOG_MESSAGE constant as well from above", "author": "riyafa", "createdAt": "2020-03-27T05:41:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMzNTg2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMzNTk3OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r398335978", "bodyText": "Shall we have the message related constants in the relevant class?", "author": "riyafa", "createdAt": "2020-03-26T06:07:35Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/websocket/WebSocketConstants.java", "diffHunk": "@@ -79,13 +79,22 @@\n     public static final String CLIENT_READY_ON_CONNECT = \"readyOnConnect\";\n     public static final String WEBSOCKET_UPGRADE_SERVICE_CONFIG = \"upgradeService\";\n \n-    public static final String RETRY_CONFIG = \"retryConfig\";\n+    public static final String RETRY_CONTEXT = \"retryConfig\";\n     public static final String COUNT_DOWN_LATCH = \"countDownLatch\";\n     public static final String CLIENT_LISTENER = \"clientListener\";\n     public static final String CLIENT_CONNECTOR = \"clientConnector\";\n     public static final String LOG_MESSAGE = \"{} {}\";\n     public static final String ERROR_MESSAGE = \"Error occurred: \";", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODM1MzA4MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r398353081", "bodyText": "Between if this going to be a utility function used by other classes we can move it to the WebSocketUtil class.", "author": "riyafa", "createdAt": "2020-03-26T07:02:19Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/actions/websocketconnector/WebSocketConnector.java", "diffHunk": "@@ -127,8 +127,25 @@ public static Object pong(ObjectValue wsConnection, ArrayValue binaryData) {\n                                                     WebSocketObservabilityConstants.ERROR_TYPE_MESSAGE_SENT,\n                                                     WebSocketObservabilityConstants.MESSAGE_TYPE_PONG,\n                                                     e.getMessage());\n-            callback.notifyFailure(WebSocketUtil.createErrorByType(e));\n+            setCallback(connectionInfo, callback, e);\n         }\n         return null;\n     }\n+\n+    public static void setCallback(WebSocketConnectionInfo connectionInfo, NonBlockingCallback callback,", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTIwNDUwOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r399204509", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Test(description = \"Tests the failover webSocket client by starting the both server in the target URLs.\")\n          \n          \n            \n                @Test(description = \"Tests the failover webSocket client by starting two servers in the target URLs.\")", "author": "riyafa", "createdAt": "2020-03-27T11:39:03Z", "path": "tests/jballerina-integration-test/src/test/java/org/ballerinalang/test/service/websocket/FailoverClientTest.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package org.ballerinalang.test.service.websocket;\n+\n+import io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;\n+import org.ballerinalang.test.context.BallerinaTestException;\n+import org.ballerinalang.test.util.websocket.client.WebSocketTestClient;\n+import org.ballerinalang.test.util.websocket.server.WebSocketRemoteServer;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.net.URISyntaxException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Tests the failover support of the WebSocket client.\n+ */\n+@Test(groups = {\"websocket-test\"})\n+public class FailoverClientTest extends WebSocketTestCommons {\n+\n+    private static final String URL = \"ws://localhost:21032\";\n+    private static final int FIRST_SERVER_PORT = 15300;\n+    private static final int SECOND_SERVER_PORT = 15200;\n+    private static final int THIRD_SERVER_PORT = 15400;\n+    private static final String MESSAGE = \"hi all\";\n+    private WebSocketRemoteServer firstRemoteServer;\n+    private WebSocketRemoteServer secondRemoteServer;\n+    private WebSocketRemoteServer thirdRemoteServer;\n+\n+    @Test(description = \"Tests the failover webSocket client by starting the second server in the target URLs.\")\n+    public void testTextFrameWithSecondServer() throws URISyntaxException, InterruptedException,\n+            BallerinaTestException {\n+        secondRemoteServer = initiateServer(SECOND_SERVER_PORT);\n+        WebSocketTestClient client = initiateClient(URL);\n+        sendTextDataAndAssert(client);\n+        closeConnection(client, secondRemoteServer);\n+    }\n+\n+    @Test(description = \"Tests the failover webSocket client by starting the first server in the target URLs.\")\n+    public void testBinaryFrameWithFirstServer() throws URISyntaxException, InterruptedException,\n+            BallerinaTestException {\n+        firstRemoteServer = initiateServer(FIRST_SERVER_PORT);\n+        WebSocketTestClient client = initiateClient(URL);\n+        sendBinaryDataAndAssert(client);\n+        closeConnection(client, firstRemoteServer);\n+    }\n+\n+    @Test(description = \"Tests the failover webSocket client by starting the third server in the target URLs.\")\n+    public void testBinaryFrameWithThirdServer() throws URISyntaxException, InterruptedException,\n+            BallerinaTestException {\n+        thirdRemoteServer = initiateServer(THIRD_SERVER_PORT);\n+        WebSocketTestClient client = initiateClient(URL);\n+        sendBinaryDataAndAssert(client);\n+        closeConnection(client, thirdRemoteServer);\n+    }\n+\n+    @Test(description = \"Tests the failover webSocket client by not starting any of the servers in the targets URLs\")\n+    public void testFailingFailover() throws URISyntaxException, InterruptedException {\n+        CountDownLatch countDownLatch = new CountDownLatch(1);\n+        WebSocketTestClient client = initiateClient(URL);\n+        client.setCountDownLatch(countDownLatch);\n+        countDownLatch.await(TIMEOUT_IN_SECS, TimeUnit.SECONDS);\n+        CloseWebSocketFrame closeWebSocketFrame = client.getReceivedCloseFrame();\n+        Assert.assertNotNull(closeWebSocketFrame);\n+        Assert.assertEquals(closeWebSocketFrame.statusCode(), 1011);\n+        Assert.assertTrue(closeWebSocketFrame.reasonText().contains(\"Unexpected condition\"));\n+        closeWebSocketFrame.release();\n+    }\n+\n+    @Test(description = \"Tests the failover client when getting a handshake timeout\")\n+    public void testHandshakeTimeout() throws URISyntaxException, InterruptedException, BallerinaTestException {\n+        WebSocketTestClient client = initiateClient(\"ws://localhost:21034\");\n+        firstRemoteServer = initiateServer(FIRST_SERVER_PORT);\n+        CountDownLatch countDownLatch = new CountDownLatch(1);\n+        countDownLatch.await(TIMEOUT_IN_SECS, TimeUnit.SECONDS);\n+        sendTextDataAndAssert(client);\n+        closeConnection(client, firstRemoteServer);\n+    }\n+\n+    @Test(description = \"Tests the failover webSocket client by starting the both server in the target URLs.\")", "originalCommit": "a9e39ae1b647dccab97f8595717e52d3ee6952b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTIwNDY2Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r399204666", "bodyText": "same as above", "author": "riyafa", "createdAt": "2020-03-27T11:39:23Z", "path": "tests/jballerina-integration-test/src/test/java/org/ballerinalang/test/service/websocket/FailoverClientTest.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package org.ballerinalang.test.service.websocket;\n+\n+import io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;\n+import org.ballerinalang.test.context.BallerinaTestException;\n+import org.ballerinalang.test.util.websocket.client.WebSocketTestClient;\n+import org.ballerinalang.test.util.websocket.server.WebSocketRemoteServer;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.net.URISyntaxException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Tests the failover support of the WebSocket client.\n+ */\n+@Test(groups = {\"websocket-test\"})\n+public class FailoverClientTest extends WebSocketTestCommons {\n+\n+    private static final String URL = \"ws://localhost:21032\";\n+    private static final int FIRST_SERVER_PORT = 15300;\n+    private static final int SECOND_SERVER_PORT = 15200;\n+    private static final int THIRD_SERVER_PORT = 15400;\n+    private static final String MESSAGE = \"hi all\";\n+    private WebSocketRemoteServer firstRemoteServer;\n+    private WebSocketRemoteServer secondRemoteServer;\n+    private WebSocketRemoteServer thirdRemoteServer;\n+\n+    @Test(description = \"Tests the failover webSocket client by starting the second server in the target URLs.\")\n+    public void testTextFrameWithSecondServer() throws URISyntaxException, InterruptedException,\n+            BallerinaTestException {\n+        secondRemoteServer = initiateServer(SECOND_SERVER_PORT);\n+        WebSocketTestClient client = initiateClient(URL);\n+        sendTextDataAndAssert(client);\n+        closeConnection(client, secondRemoteServer);\n+    }\n+\n+    @Test(description = \"Tests the failover webSocket client by starting the first server in the target URLs.\")\n+    public void testBinaryFrameWithFirstServer() throws URISyntaxException, InterruptedException,\n+            BallerinaTestException {\n+        firstRemoteServer = initiateServer(FIRST_SERVER_PORT);\n+        WebSocketTestClient client = initiateClient(URL);\n+        sendBinaryDataAndAssert(client);\n+        closeConnection(client, firstRemoteServer);\n+    }\n+\n+    @Test(description = \"Tests the failover webSocket client by starting the third server in the target URLs.\")\n+    public void testBinaryFrameWithThirdServer() throws URISyntaxException, InterruptedException,\n+            BallerinaTestException {\n+        thirdRemoteServer = initiateServer(THIRD_SERVER_PORT);\n+        WebSocketTestClient client = initiateClient(URL);\n+        sendBinaryDataAndAssert(client);\n+        closeConnection(client, thirdRemoteServer);\n+    }\n+\n+    @Test(description = \"Tests the failover webSocket client by not starting any of the servers in the targets URLs\")\n+    public void testFailingFailover() throws URISyntaxException, InterruptedException {\n+        CountDownLatch countDownLatch = new CountDownLatch(1);\n+        WebSocketTestClient client = initiateClient(URL);\n+        client.setCountDownLatch(countDownLatch);\n+        countDownLatch.await(TIMEOUT_IN_SECS, TimeUnit.SECONDS);\n+        CloseWebSocketFrame closeWebSocketFrame = client.getReceivedCloseFrame();\n+        Assert.assertNotNull(closeWebSocketFrame);\n+        Assert.assertEquals(closeWebSocketFrame.statusCode(), 1011);\n+        Assert.assertTrue(closeWebSocketFrame.reasonText().contains(\"Unexpected condition\"));\n+        closeWebSocketFrame.release();\n+    }\n+\n+    @Test(description = \"Tests the failover client when getting a handshake timeout\")\n+    public void testHandshakeTimeout() throws URISyntaxException, InterruptedException, BallerinaTestException {\n+        WebSocketTestClient client = initiateClient(\"ws://localhost:21034\");\n+        firstRemoteServer = initiateServer(FIRST_SERVER_PORT);\n+        CountDownLatch countDownLatch = new CountDownLatch(1);\n+        countDownLatch.await(TIMEOUT_IN_SECS, TimeUnit.SECONDS);\n+        sendTextDataAndAssert(client);\n+        closeConnection(client, firstRemoteServer);\n+    }\n+\n+    @Test(description = \"Tests the failover webSocket client by starting the both server in the target URLs.\")\n+    public void testFailoverWithBothServer() throws URISyntaxException, InterruptedException,\n+            BallerinaTestException {\n+        secondRemoteServer = initiateServer(SECOND_SERVER_PORT);\n+        firstRemoteServer = initiateServer(FIRST_SERVER_PORT);\n+        WebSocketTestClient client = initiateClient(URL);\n+        sendTextDataAndAssert(client);\n+        firstRemoteServer.stop();\n+        sendTextDataAndAssert(client);\n+        sendBinaryDataAndAssert(client);\n+        closeConnection(client, secondRemoteServer);\n+    }\n+\n+    @Test(description = \"Tests the failover webSocket client by starting the both server in the target URLs.\")", "originalCommit": "a9e39ae1b647dccab97f8595717e52d3ee6952b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTIwNjMwNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r399206305", "bodyText": "how is timeout checked here?", "author": "riyafa", "createdAt": "2020-03-27T11:42:37Z", "path": "tests/jballerina-integration-test/src/test/java/org/ballerinalang/test/service/websocket/FailoverClientTest.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package org.ballerinalang.test.service.websocket;\n+\n+import io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;\n+import org.ballerinalang.test.context.BallerinaTestException;\n+import org.ballerinalang.test.util.websocket.client.WebSocketTestClient;\n+import org.ballerinalang.test.util.websocket.server.WebSocketRemoteServer;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.net.URISyntaxException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Tests the failover support of the WebSocket client.\n+ */\n+@Test(groups = {\"websocket-test\"})\n+public class FailoverClientTest extends WebSocketTestCommons {\n+\n+    private static final String URL = \"ws://localhost:21032\";\n+    private static final int FIRST_SERVER_PORT = 15300;\n+    private static final int SECOND_SERVER_PORT = 15200;\n+    private static final int THIRD_SERVER_PORT = 15400;\n+    private static final String MESSAGE = \"hi all\";\n+    private WebSocketRemoteServer firstRemoteServer;\n+    private WebSocketRemoteServer secondRemoteServer;\n+    private WebSocketRemoteServer thirdRemoteServer;\n+\n+    @Test(description = \"Tests the failover webSocket client by starting the second server in the target URLs.\")\n+    public void testTextFrameWithSecondServer() throws URISyntaxException, InterruptedException,\n+            BallerinaTestException {\n+        secondRemoteServer = initiateServer(SECOND_SERVER_PORT);\n+        WebSocketTestClient client = initiateClient(URL);\n+        sendTextDataAndAssert(client);\n+        closeConnection(client, secondRemoteServer);\n+    }\n+\n+    @Test(description = \"Tests the failover webSocket client by starting the first server in the target URLs.\")\n+    public void testBinaryFrameWithFirstServer() throws URISyntaxException, InterruptedException,\n+            BallerinaTestException {\n+        firstRemoteServer = initiateServer(FIRST_SERVER_PORT);\n+        WebSocketTestClient client = initiateClient(URL);\n+        sendBinaryDataAndAssert(client);\n+        closeConnection(client, firstRemoteServer);\n+    }\n+\n+    @Test(description = \"Tests the failover webSocket client by starting the third server in the target URLs.\")\n+    public void testBinaryFrameWithThirdServer() throws URISyntaxException, InterruptedException,\n+            BallerinaTestException {\n+        thirdRemoteServer = initiateServer(THIRD_SERVER_PORT);\n+        WebSocketTestClient client = initiateClient(URL);\n+        sendBinaryDataAndAssert(client);\n+        closeConnection(client, thirdRemoteServer);\n+    }\n+\n+    @Test(description = \"Tests the failover webSocket client by not starting any of the servers in the targets URLs\")\n+    public void testFailingFailover() throws URISyntaxException, InterruptedException {\n+        CountDownLatch countDownLatch = new CountDownLatch(1);\n+        WebSocketTestClient client = initiateClient(URL);\n+        client.setCountDownLatch(countDownLatch);\n+        countDownLatch.await(TIMEOUT_IN_SECS, TimeUnit.SECONDS);\n+        CloseWebSocketFrame closeWebSocketFrame = client.getReceivedCloseFrame();\n+        Assert.assertNotNull(closeWebSocketFrame);\n+        Assert.assertEquals(closeWebSocketFrame.statusCode(), 1011);\n+        Assert.assertTrue(closeWebSocketFrame.reasonText().contains(\"Unexpected condition\"));\n+        closeWebSocketFrame.release();\n+    }\n+\n+    @Test(description = \"Tests the failover client when getting a handshake timeout\")\n+    public void testHandshakeTimeout() throws URISyntaxException, InterruptedException, BallerinaTestException {\n+        WebSocketTestClient client = initiateClient(\"ws://localhost:21034\");\n+        firstRemoteServer = initiateServer(FIRST_SERVER_PORT);\n+        CountDownLatch countDownLatch = new CountDownLatch(1);\n+        countDownLatch.await(TIMEOUT_IN_SECS, TimeUnit.SECONDS);\n+        sendTextDataAndAssert(client);", "originalCommit": "a9e39ae1b647dccab97f8595717e52d3ee6952b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTkyNjAyNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r399926024", "bodyText": "Here, we are waiting until handshake timeout. The timeout error is an IOError. Therefore we need to do the failover.", "author": "kalaiyarasiganeshalingam", "createdAt": "2020-03-30T04:52:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTIwNjMwNQ=="}], "type": "inlineReview"}, {"oid": "3f1da2e03281f20d579c8e9d6faf667035cc29b5", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3f1da2e03281f20d579c8e9d6faf667035cc29b5", "message": "revert the commit", "committedDate": "2020-03-31T12:50:47Z", "type": "commit"}, {"oid": "2a1f2619d0fbf331ae875dfad5ece929cf7e5ea0", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2a1f2619d0fbf331ae875dfad5ece929cf7e5ea0", "message": "Merge master", "committedDate": "2020-03-31T12:58:30Z", "type": "commit"}, {"oid": "0694fd668a2c985cf7b06d9951cfa9ddb4a3feca", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0694fd668a2c985cf7b06d9951cfa9ddb4a3feca", "message": "Implement failover in webSocket\n\nRemove additional changes\n\nRemove additional changes\n\nRemove additional changes", "committedDate": "2020-03-31T14:21:42Z", "type": "commit"}, {"oid": "2c828e11ef653a7f692749512bb62c5b6dc23036", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2c828e11ef653a7f692749512bb62c5b6dc23036", "message": "Fix conflict", "committedDate": "2020-03-31T15:02:48Z", "type": "commit"}, {"oid": "1d88bf18858fc74cfdd8221803c9e4d4cbf9dac8", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1d88bf18858fc74cfdd8221803c9e4d4cbf9dac8", "message": "Fix language server core test\n\nFix language server core test\n\nFix language server core test\n\nAdd test inthe testng\n\nRemove unwanted changes", "committedDate": "2020-04-01T03:44:09Z", "type": "commit"}, {"oid": "9a9ec9beae6a6dbfd9f257a4c511c0a8fced6e96", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9a9ec9beae6a6dbfd9f257a4c511c0a8fced6e96", "message": "Merge https://github.com/ballerina-platform/ballerina-lang into webSocket_failover", "committedDate": "2020-04-01T06:00:35Z", "type": "commit"}, {"oid": "6017edc7a58857b54d20f0df6df3003a2e9fb621", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6017edc7a58857b54d20f0df6df3003a2e9fb621", "message": "Fix language server tests", "committedDate": "2020-04-01T06:37:09Z", "type": "commit"}]}