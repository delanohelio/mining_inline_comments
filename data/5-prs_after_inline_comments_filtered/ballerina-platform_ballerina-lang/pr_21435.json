{"pr_number": 21435, "pr_title": "jBallerina Compiler Backend Rewrite", "pr_createdAt": "2020-03-03T10:33:44Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/21435", "timeline": [{"oid": "9786d8b31c53298ece180051a3716b4691965d52", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9786d8b31c53298ece180051a3716b4691965d52", "message": "Merge pull request #21411 from Kishanthan/jbal-with-latest-master\n\nUse a seperate classloader for interop validation", "committedDate": "2020-03-02T14:44:06Z", "type": "commit"}, {"oid": "6e9551c5a39b650d4e684aeb7b88ebee5e5ac85c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6e9551c5a39b650d4e684aeb7b88ebee5e5ac85c", "message": "Merge pull request #21412 from warunalakshitha/jbal_rewrite\n\nFix code gen error tests", "committedDate": "2020-03-02T15:18:53Z", "type": "commit"}, {"oid": "cfc4da1aa7595bbeb46bd33e28544db1045be3bf", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/cfc4da1aa7595bbeb46bd33e28544db1045be3bf", "message": "Merge branch 'jbal-be-rewrite' of github.com:ballerina-platform/ballerina-lang into jbal-be-rewrite", "committedDate": "2020-03-03T05:09:32Z", "type": "commit"}, {"oid": "9a2733b6db433061d5ff2e720e320880057cb8a3", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9a2733b6db433061d5ff2e720e320880057cb8a3", "message": "Skip non entry modules being desugared for jInterop validation", "committedDate": "2020-03-03T06:00:26Z", "type": "commit"}, {"oid": "65d88352670c81e82539ed721173a93cee904a8a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/65d88352670c81e82539ed721173a93cee904a8a", "message": "Use a random port to avoid conflicts", "committedDate": "2020-03-03T06:01:06Z", "type": "commit"}, {"oid": "261d6cc5bd920f381a0d414b86ddad0814445c0b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/261d6cc5bd920f381a0d414b86ddad0814445c0b", "message": "Merge pull request #21419 from manuranga/jbal-be-rewrite\n\nJbal be rewrite", "committedDate": "2020-03-03T06:01:48Z", "type": "commit"}, {"oid": "f696800b271e453549871a7a40ea901446eb5223", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f696800b271e453549871a7a40ea901446eb5223", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-with-latest-master", "committedDate": "2020-03-03T06:02:09Z", "type": "commit"}, {"oid": "973abbea9d8b08c46a4c445b2afa960d872ec6e0", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/973abbea9d8b08c46a4c445b2afa960d872ec6e0", "message": "Fix compilation issue", "committedDate": "2020-03-03T06:16:09Z", "type": "commit"}, {"oid": "be1291a09631b265171ef63edeeb6c97a3241b5f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/be1291a09631b265171ef63edeeb6c97a3241b5f", "message": "Merge pull request #21424 from Kishanthan/jbal-with-latest-master\n\nSkip non entry modules being desugared for jInterop validation", "committedDate": "2020-03-03T06:18:07Z", "type": "commit"}, {"oid": "759fd0ef149296a59b7d15f94967c4fb49543e27", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/759fd0ef149296a59b7d15f94967c4fb49543e27", "message": "Disable failing tests on jBallerina", "committedDate": "2020-03-03T06:29:04Z", "type": "commit"}, {"oid": "3c485aac3792e23a8ac476ce19e030dd20058205", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3c485aac3792e23a8ac476ce19e030dd20058205", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-with-latest-master", "committedDate": "2020-03-03T06:29:22Z", "type": "commit"}, {"oid": "afd579efc8ccc5167b13ec2803b13347645cbc2c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/afd579efc8ccc5167b13ec2803b13347645cbc2c", "message": "Merge pull request #21425 from Kishanthan/jbal-with-latest-master\n\nDisable failing tests on jBallerina", "committedDate": "2020-03-03T06:32:01Z", "type": "commit"}, {"oid": "19412bbd07a89650331b8a6c111d3cd23618a67b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/19412bbd07a89650331b8a6c111d3cd23618a67b", "message": "Fix check styles issues", "committedDate": "2020-03-03T06:35:11Z", "type": "commit"}, {"oid": "8188a46e3512d598645faf44e6458b72e9afed92", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8188a46e3512d598645faf44e6458b72e9afed92", "message": "Merge branch 'jbal-be-rewrite' of github.com:ballerina-platform/ballerina-lang into jbal-be-rewrite", "committedDate": "2020-03-03T06:38:46Z", "type": "commit"}, {"oid": "122dfe87b011569768627a27c068eff51886cada", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/122dfe87b011569768627a27c068eff51886cada", "message": "Merge pull request #21427 from manuranga/jbal-be-rewrite\n\nFix check styles issues", "committedDate": "2020-03-03T06:39:27Z", "type": "commit"}, {"oid": "de7674bffa639cf83eaf6fe87a74baf2bcd1399a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/de7674bffa639cf83eaf6fe87a74baf2bcd1399a", "message": "Fix checkstyle issues in unit tests", "committedDate": "2020-03-03T06:58:09Z", "type": "commit"}, {"oid": "ead11d1d646b38566c090d3acfd6de37a5274f60", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ead11d1d646b38566c090d3acfd6de37a5274f60", "message": "Merge pull request #21429 from Kishanthan/jbal-with-latest-master\n\nFix checkstyle issues in unit tests", "committedDate": "2020-03-03T07:02:17Z", "type": "commit"}, {"oid": "7a736b6079a0b5d67dd613fea16519608d3d522d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7a736b6079a0b5d67dd613fea16519608d3d522d", "message": "Move bstring test to a separate module", "committedDate": "2020-03-03T08:17:28Z", "type": "commit"}, {"oid": "acaf69fe5daad2ad8f6d2e8ac8fee565e131d216", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/acaf69fe5daad2ad8f6d2e8ac8fee565e131d216", "message": "Disable failing integration tests on jBallerina", "committedDate": "2020-03-03T09:50:14Z", "type": "commit"}, {"oid": "9ba4aa5f0887b57f6b56e6a10f11715c6d0dfd56", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9ba4aa5f0887b57f6b56e6a10f11715c6d0dfd56", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-with-latest-master", "committedDate": "2020-03-03T09:50:30Z", "type": "commit"}, {"oid": "06d3daf55813f2d979e6b5448bf90874718f0754", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/06d3daf55813f2d979e6b5448bf90874718f0754", "message": "Disable failing integration tests on jBallerina", "committedDate": "2020-03-03T10:19:55Z", "type": "commit"}, {"oid": "b3a77ff10e0c6fb2a65a230906ecd2017e3fb204", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b3a77ff10e0c6fb2a65a230906ecd2017e3fb204", "message": "Merge pull request #21432 from Kishanthan/jbal-with-latest-master\n\nDisable failing integration tests on jBallerina", "committedDate": "2020-03-03T10:20:58Z", "type": "commit"}, {"oid": "4f339dbfa4f2cbca9766c7bb39957f9e20e46256", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4f339dbfa4f2cbca9766c7bb39957f9e20e46256", "message": "Merge with master", "committedDate": "2020-03-03T10:27:45Z", "type": "commit"}, {"oid": "52083b7c0fe1b51022749456d1bc72c724dcde58", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/52083b7c0fe1b51022749456d1bc72c724dcde58", "message": "Merge pull request #21434 from Kishanthan/jbal-with-latest-master\n\nMerge with master", "committedDate": "2020-03-03T10:32:56Z", "type": "commit"}, {"oid": "aa4eb2a34acfd004952b2ed641ed1264507c6c65", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/aa4eb2a34acfd004952b2ed641ed1264507c6c65", "message": "Disable testerina failing tests on jBallerina", "committedDate": "2020-03-03T11:15:46Z", "type": "commit"}, {"oid": "9631e7c2ee446d64402430535229680315e8cbe6", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9631e7c2ee446d64402430535229680315e8cbe6", "message": "Disable testerina failing tests on jBallerina", "committedDate": "2020-03-03T11:18:08Z", "type": "commit"}, {"oid": "c1f551d024a3ed2f8497cee8b7f05a8e955a4527", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c1f551d024a3ed2f8497cee8b7f05a8e955a4527", "message": "Merge pull request #21437 from Kishanthan/jbal-with-latest-master\n\nDisable testerina failing tests on jBallerina", "committedDate": "2020-03-03T11:19:07Z", "type": "commit"}, {"oid": "a99a796a7980891b8c1124c03efc0db5aac2adac", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a99a796a7980891b8c1124c03efc0db5aac2adac", "message": "Pass interop class path via gradle", "committedDate": "2020-03-03T11:27:33Z", "type": "commit"}, {"oid": "96e943d52cb9ad90db7eafe20bb3f2d049137239", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/96e943d52cb9ad90db7eafe20bb3f2d049137239", "message": "Merge pull request #21438 from manuranga/jbal-be-rewrite\n\nJbal gradle build changes", "committedDate": "2020-03-03T11:33:51Z", "type": "commit"}, {"oid": "bcb8b2442ec8f3bd7d81ece846bf6ede2315d379", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bcb8b2442ec8f3bd7d81ece846bf6ede2315d379", "message": "Fix class not found issue in interop", "committedDate": "2020-03-03T11:43:16Z", "type": "commit"}, {"oid": "9f0193f0dd120be0a4b3b45fcfbbbc054c66c945", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9f0193f0dd120be0a4b3b45fcfbbbc054c66c945", "message": "Fix style issue", "committedDate": "2020-03-03T11:44:51Z", "type": "commit"}, {"oid": "e65ce40cd32ef5aed79376dbf3923069dbf15eaf", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e65ce40cd32ef5aed79376dbf3923069dbf15eaf", "message": "Merge pull request #21444 from manuranga/jbal-be-rewrite\n\nFix build issues", "committedDate": "2020-03-03T11:50:00Z", "type": "commit"}, {"oid": "0b988000f3d2eaa2fdfb3840881da3e4167b09bd", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0b988000f3d2eaa2fdfb3840881da3e4167b09bd", "message": "Fix style issue", "committedDate": "2020-03-03T11:52:32Z", "type": "commit"}, {"oid": "3fe3a2bb853044f89191ad1ee6d66e3da918fe26", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3fe3a2bb853044f89191ad1ee6d66e3da918fe26", "message": "Merge pull request #21445 from manuranga/jbal-be-rewrite\n\nFix style issue", "committedDate": "2020-03-03T11:54:33Z", "type": "commit"}, {"oid": "56e3c340757fd61942217b9f8db5c93d8c1cccaa", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/56e3c340757fd61942217b9f8db5c93d8c1cccaa", "message": "Fix interop class not found", "committedDate": "2020-03-03T12:10:12Z", "type": "commit"}, {"oid": "06ce3bfbc111df05434e26079b1fbabc654f74da", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/06ce3bfbc111df05434e26079b1fbabc654f74da", "message": "Merge pull request #21446 from manuranga/jbal-be-rewrite\n\nFix interop class not found", "committedDate": "2020-03-03T12:11:41Z", "type": "commit"}, {"oid": "0b9b149af2d45627ff1c64d0fa7a6d63532c5a8c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0b9b149af2d45627ff1c64d0fa7a6d63532c5a8c", "message": "Change the class loader in tests to system class loader", "committedDate": "2020-03-03T12:42:27Z", "type": "commit"}, {"oid": "1e037301f42357d603f104e14589b6e11e32951d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1e037301f42357d603f104e14589b6e11e32951d", "message": "Fix spotbug reported issue", "committedDate": "2020-03-03T12:52:44Z", "type": "commit"}, {"oid": "82df207efdc85acd9646a1aae1461f7d1f7bbc5f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/82df207efdc85acd9646a1aae1461f7d1f7bbc5f", "message": "Merge pull request #21447 from manuranga/jbal-be-rewrite\n\nChange the class loader in tests to system class loader", "committedDate": "2020-03-03T12:54:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzAyMDU2OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21435#discussion_r387020568", "bodyText": "Shall we add a new line in all places?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            package org.wso2.ballerinalang.compiler.bir;\n          \n          \n            \n            \n          \n          \n            \n            package org.wso2.ballerinalang.compiler.bir;", "author": "riyafa", "createdAt": "2020-03-03T13:33:51Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/BackendDriver.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.bir;", "originalCommit": "82df207efdc85acd9646a1aae1461f7d1f7bbc5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzNjA4OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21435#discussion_r387436089", "bodyText": "Why don't  we use a switch statement here?", "author": "riyafa", "createdAt": "2020-03-04T03:51:47Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmCastGen.java", "diffHunk": "@@ -0,0 +1,1096 @@\n+/*\n+ *  Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.bir.codegen;\n+\n+import org.ballerinalang.compiler.BLangCompilerException;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.MethodVisitor;\n+import org.wso2.ballerinalang.compiler.bir.codegen.JvmMethodGen.BalToJVMIndexMap;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JType;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JTypeTags;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRVariableDcl;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarScope;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BFiniteType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BMapType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BUnionType;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.TypeTags;\n+\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.ASTORE;\n+import static org.objectweb.asm.Opcodes.CHECKCAST;\n+import static org.objectweb.asm.Opcodes.D2F;\n+import static org.objectweb.asm.Opcodes.D2I;\n+import static org.objectweb.asm.Opcodes.D2L;\n+import static org.objectweb.asm.Opcodes.DUP;\n+import static org.objectweb.asm.Opcodes.F2D;\n+import static org.objectweb.asm.Opcodes.I2B;\n+import static org.objectweb.asm.Opcodes.I2C;\n+import static org.objectweb.asm.Opcodes.I2D;\n+import static org.objectweb.asm.Opcodes.I2F;\n+import static org.objectweb.asm.Opcodes.I2L;\n+import static org.objectweb.asm.Opcodes.I2S;\n+import static org.objectweb.asm.Opcodes.IFNE;\n+import static org.objectweb.asm.Opcodes.IFNULL;\n+import static org.objectweb.asm.Opcodes.INSTANCEOF;\n+import static org.objectweb.asm.Opcodes.INVOKEINTERFACE;\n+import static org.objectweb.asm.Opcodes.INVOKESPECIAL;\n+import static org.objectweb.asm.Opcodes.INVOKESTATIC;\n+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n+import static org.objectweb.asm.Opcodes.L2D;\n+import static org.objectweb.asm.Opcodes.L2F;\n+import static org.objectweb.asm.Opcodes.L2I;\n+import static org.objectweb.asm.Opcodes.NEW;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ARRAY_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BHANDLE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BOOLEAN_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BTYPE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DECIMAL_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DOUBLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ERROR_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUNCTION_POINTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUTURE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.HANDLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.INT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.LONG_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MAP_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.NUMBER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.REF_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.SIMPLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STREAM_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TABLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPEDESC_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPE_CHECKER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPE_CONVERTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.XML_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.B_STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.I_STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.addBoxInsn;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmLabelGen.LabelGenerator;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.symbolTable;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen.loadType;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.interop.InteropMethodGen.getSignatureForJType;\n+\n+/**\n+ * Check cast methods generation for JVM bytecode generation.\n+ *\n+ * @since 1.2.0\n+ */\n+public class JvmCastGen {\n+\n+    static void generatePlatformCheckCast(MethodVisitor mv, BalToJVMIndexMap indexMap, BType sourceType,\n+                                          BType targetType) {\n+\n+        if (sourceType.tag == JTypeTags.JTYPE) {\n+            // If a target type is bir type, then we can guarantee source type is a jvm type, hence the cast\n+            generateJToBCheckCast(mv, indexMap, (JType) sourceType, targetType);\n+        } else {\n+            // else target type is jvm and source type is bir\n+            generateBToJCheckCast(mv, sourceType, (JType) targetType);\n+        }\n+    }\n+\n+    public static void generateBToJCheckCast(MethodVisitor mv, BType sourceType, JType targetType) {\n+\n+        if (targetType.jTag == JTypeTags.JBYTE) {", "originalCommit": "82df207efdc85acd9646a1aae1461f7d1f7bbc5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzNjc0MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21435#discussion_r387436740", "bodyText": "Shall we use switch statement?", "author": "riyafa", "createdAt": "2020-03-04T03:54:56Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmCastGen.java", "diffHunk": "@@ -0,0 +1,1096 @@\n+/*\n+ *  Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.bir.codegen;\n+\n+import org.ballerinalang.compiler.BLangCompilerException;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.MethodVisitor;\n+import org.wso2.ballerinalang.compiler.bir.codegen.JvmMethodGen.BalToJVMIndexMap;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JType;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JTypeTags;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRVariableDcl;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarScope;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BFiniteType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BMapType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BUnionType;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.TypeTags;\n+\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.ASTORE;\n+import static org.objectweb.asm.Opcodes.CHECKCAST;\n+import static org.objectweb.asm.Opcodes.D2F;\n+import static org.objectweb.asm.Opcodes.D2I;\n+import static org.objectweb.asm.Opcodes.D2L;\n+import static org.objectweb.asm.Opcodes.DUP;\n+import static org.objectweb.asm.Opcodes.F2D;\n+import static org.objectweb.asm.Opcodes.I2B;\n+import static org.objectweb.asm.Opcodes.I2C;\n+import static org.objectweb.asm.Opcodes.I2D;\n+import static org.objectweb.asm.Opcodes.I2F;\n+import static org.objectweb.asm.Opcodes.I2L;\n+import static org.objectweb.asm.Opcodes.I2S;\n+import static org.objectweb.asm.Opcodes.IFNE;\n+import static org.objectweb.asm.Opcodes.IFNULL;\n+import static org.objectweb.asm.Opcodes.INSTANCEOF;\n+import static org.objectweb.asm.Opcodes.INVOKEINTERFACE;\n+import static org.objectweb.asm.Opcodes.INVOKESPECIAL;\n+import static org.objectweb.asm.Opcodes.INVOKESTATIC;\n+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n+import static org.objectweb.asm.Opcodes.L2D;\n+import static org.objectweb.asm.Opcodes.L2F;\n+import static org.objectweb.asm.Opcodes.L2I;\n+import static org.objectweb.asm.Opcodes.NEW;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ARRAY_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BHANDLE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BOOLEAN_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BTYPE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DECIMAL_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DOUBLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ERROR_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUNCTION_POINTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUTURE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.HANDLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.INT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.LONG_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MAP_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.NUMBER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.REF_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.SIMPLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STREAM_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TABLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPEDESC_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPE_CHECKER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPE_CONVERTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.XML_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.B_STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.I_STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.addBoxInsn;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmLabelGen.LabelGenerator;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.symbolTable;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen.loadType;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.interop.InteropMethodGen.getSignatureForJType;\n+\n+/**\n+ * Check cast methods generation for JVM bytecode generation.\n+ *\n+ * @since 1.2.0\n+ */\n+public class JvmCastGen {\n+\n+    static void generatePlatformCheckCast(MethodVisitor mv, BalToJVMIndexMap indexMap, BType sourceType,\n+                                          BType targetType) {\n+\n+        if (sourceType.tag == JTypeTags.JTYPE) {\n+            // If a target type is bir type, then we can guarantee source type is a jvm type, hence the cast\n+            generateJToBCheckCast(mv, indexMap, (JType) sourceType, targetType);\n+        } else {\n+            // else target type is jvm and source type is bir\n+            generateBToJCheckCast(mv, sourceType, (JType) targetType);\n+        }\n+    }\n+\n+    public static void generateBToJCheckCast(MethodVisitor mv, BType sourceType, JType targetType) {\n+\n+        if (targetType.jTag == JTypeTags.JBYTE) {\n+            generateCheckCastBToJByte(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JCHAR) {\n+            generateCheckCastBToJChar(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JSHORT) {\n+            generateCheckCastBToJShort(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JINT) {\n+            generateCheckCastBToJInt(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JLONG) {\n+            generateCheckCastBToJLong(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JFLOAT) {\n+            generateCheckCastBToJFloat(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JDOUBLE) {\n+            generateCheckCastBToJDouble(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JREF) {\n+            if (((JType.JRefType) targetType).typeValue.equals(B_STRING_VALUE)) {\n+                generateCheckCastBToJString(mv, sourceType);\n+            } else {\n+                generateCheckCastBToJRef(mv, sourceType, targetType);\n+            }\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JARRAY) {\n+            generateCheckCastBToJRef(mv, sourceType, targetType);\n+            return;\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java %s'\",\n+                    sourceType, targetType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJString(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.STRING) {\n+            mv.visitMethodInsn(INVOKESTATIC, STRING_UTILS, \"fromString\",\n+                    String.format(\"(L%s;)L%s;\", STRING_VALUE, B_STRING_VALUE), false);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java byte'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJByte(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {\n+            // do nothing\n+        } else if (sourceType.tag == TypeTags.INT) {", "originalCommit": "82df207efdc85acd9646a1aae1461f7d1f7bbc5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzNjg3OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21435#discussion_r387436879", "bodyText": "Shall we use a constant for hardcoded method name?", "author": "riyafa", "createdAt": "2020-03-04T03:55:32Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmCastGen.java", "diffHunk": "@@ -0,0 +1,1096 @@\n+/*\n+ *  Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.bir.codegen;\n+\n+import org.ballerinalang.compiler.BLangCompilerException;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.MethodVisitor;\n+import org.wso2.ballerinalang.compiler.bir.codegen.JvmMethodGen.BalToJVMIndexMap;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JType;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JTypeTags;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRVariableDcl;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarScope;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BFiniteType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BMapType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BUnionType;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.TypeTags;\n+\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.ASTORE;\n+import static org.objectweb.asm.Opcodes.CHECKCAST;\n+import static org.objectweb.asm.Opcodes.D2F;\n+import static org.objectweb.asm.Opcodes.D2I;\n+import static org.objectweb.asm.Opcodes.D2L;\n+import static org.objectweb.asm.Opcodes.DUP;\n+import static org.objectweb.asm.Opcodes.F2D;\n+import static org.objectweb.asm.Opcodes.I2B;\n+import static org.objectweb.asm.Opcodes.I2C;\n+import static org.objectweb.asm.Opcodes.I2D;\n+import static org.objectweb.asm.Opcodes.I2F;\n+import static org.objectweb.asm.Opcodes.I2L;\n+import static org.objectweb.asm.Opcodes.I2S;\n+import static org.objectweb.asm.Opcodes.IFNE;\n+import static org.objectweb.asm.Opcodes.IFNULL;\n+import static org.objectweb.asm.Opcodes.INSTANCEOF;\n+import static org.objectweb.asm.Opcodes.INVOKEINTERFACE;\n+import static org.objectweb.asm.Opcodes.INVOKESPECIAL;\n+import static org.objectweb.asm.Opcodes.INVOKESTATIC;\n+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n+import static org.objectweb.asm.Opcodes.L2D;\n+import static org.objectweb.asm.Opcodes.L2F;\n+import static org.objectweb.asm.Opcodes.L2I;\n+import static org.objectweb.asm.Opcodes.NEW;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ARRAY_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BHANDLE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BOOLEAN_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BTYPE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DECIMAL_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DOUBLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ERROR_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUNCTION_POINTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUTURE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.HANDLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.INT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.LONG_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MAP_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.NUMBER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.REF_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.SIMPLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STREAM_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TABLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPEDESC_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPE_CHECKER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPE_CONVERTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.XML_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.B_STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.I_STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.addBoxInsn;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmLabelGen.LabelGenerator;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.symbolTable;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen.loadType;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.interop.InteropMethodGen.getSignatureForJType;\n+\n+/**\n+ * Check cast methods generation for JVM bytecode generation.\n+ *\n+ * @since 1.2.0\n+ */\n+public class JvmCastGen {\n+\n+    static void generatePlatformCheckCast(MethodVisitor mv, BalToJVMIndexMap indexMap, BType sourceType,\n+                                          BType targetType) {\n+\n+        if (sourceType.tag == JTypeTags.JTYPE) {\n+            // If a target type is bir type, then we can guarantee source type is a jvm type, hence the cast\n+            generateJToBCheckCast(mv, indexMap, (JType) sourceType, targetType);\n+        } else {\n+            // else target type is jvm and source type is bir\n+            generateBToJCheckCast(mv, sourceType, (JType) targetType);\n+        }\n+    }\n+\n+    public static void generateBToJCheckCast(MethodVisitor mv, BType sourceType, JType targetType) {\n+\n+        if (targetType.jTag == JTypeTags.JBYTE) {\n+            generateCheckCastBToJByte(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JCHAR) {\n+            generateCheckCastBToJChar(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JSHORT) {\n+            generateCheckCastBToJShort(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JINT) {\n+            generateCheckCastBToJInt(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JLONG) {\n+            generateCheckCastBToJLong(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JFLOAT) {\n+            generateCheckCastBToJFloat(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JDOUBLE) {\n+            generateCheckCastBToJDouble(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JREF) {\n+            if (((JType.JRefType) targetType).typeValue.equals(B_STRING_VALUE)) {\n+                generateCheckCastBToJString(mv, sourceType);\n+            } else {\n+                generateCheckCastBToJRef(mv, sourceType, targetType);\n+            }\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JARRAY) {\n+            generateCheckCastBToJRef(mv, sourceType, targetType);\n+            return;\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java %s'\",\n+                    sourceType, targetType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJString(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.STRING) {\n+            mv.visitMethodInsn(INVOKESTATIC, STRING_UTILS, \"fromString\",", "originalCommit": "82df207efdc85acd9646a1aae1461f7d1f7bbc5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzNzAxNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21435#discussion_r387437014", "bodyText": "Shall we use switch statements in all places instead of if-else-if statements?", "author": "riyafa", "createdAt": "2020-03-04T03:56:11Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmCastGen.java", "diffHunk": "@@ -0,0 +1,1096 @@\n+/*\n+ *  Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.bir.codegen;\n+\n+import org.ballerinalang.compiler.BLangCompilerException;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.MethodVisitor;\n+import org.wso2.ballerinalang.compiler.bir.codegen.JvmMethodGen.BalToJVMIndexMap;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JType;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JTypeTags;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRVariableDcl;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarScope;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BFiniteType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BMapType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BUnionType;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.TypeTags;\n+\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.ASTORE;\n+import static org.objectweb.asm.Opcodes.CHECKCAST;\n+import static org.objectweb.asm.Opcodes.D2F;\n+import static org.objectweb.asm.Opcodes.D2I;\n+import static org.objectweb.asm.Opcodes.D2L;\n+import static org.objectweb.asm.Opcodes.DUP;\n+import static org.objectweb.asm.Opcodes.F2D;\n+import static org.objectweb.asm.Opcodes.I2B;\n+import static org.objectweb.asm.Opcodes.I2C;\n+import static org.objectweb.asm.Opcodes.I2D;\n+import static org.objectweb.asm.Opcodes.I2F;\n+import static org.objectweb.asm.Opcodes.I2L;\n+import static org.objectweb.asm.Opcodes.I2S;\n+import static org.objectweb.asm.Opcodes.IFNE;\n+import static org.objectweb.asm.Opcodes.IFNULL;\n+import static org.objectweb.asm.Opcodes.INSTANCEOF;\n+import static org.objectweb.asm.Opcodes.INVOKEINTERFACE;\n+import static org.objectweb.asm.Opcodes.INVOKESPECIAL;\n+import static org.objectweb.asm.Opcodes.INVOKESTATIC;\n+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n+import static org.objectweb.asm.Opcodes.L2D;\n+import static org.objectweb.asm.Opcodes.L2F;\n+import static org.objectweb.asm.Opcodes.L2I;\n+import static org.objectweb.asm.Opcodes.NEW;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ARRAY_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BHANDLE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BOOLEAN_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BTYPE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DECIMAL_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DOUBLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ERROR_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUNCTION_POINTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUTURE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.HANDLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.INT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.LONG_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MAP_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.NUMBER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.REF_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.SIMPLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STREAM_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TABLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPEDESC_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPE_CHECKER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPE_CONVERTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.XML_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.B_STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.I_STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.addBoxInsn;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmLabelGen.LabelGenerator;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.symbolTable;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen.loadType;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.interop.InteropMethodGen.getSignatureForJType;\n+\n+/**\n+ * Check cast methods generation for JVM bytecode generation.\n+ *\n+ * @since 1.2.0\n+ */\n+public class JvmCastGen {\n+\n+    static void generatePlatformCheckCast(MethodVisitor mv, BalToJVMIndexMap indexMap, BType sourceType,\n+                                          BType targetType) {\n+\n+        if (sourceType.tag == JTypeTags.JTYPE) {\n+            // If a target type is bir type, then we can guarantee source type is a jvm type, hence the cast\n+            generateJToBCheckCast(mv, indexMap, (JType) sourceType, targetType);\n+        } else {\n+            // else target type is jvm and source type is bir\n+            generateBToJCheckCast(mv, sourceType, (JType) targetType);\n+        }\n+    }\n+\n+    public static void generateBToJCheckCast(MethodVisitor mv, BType sourceType, JType targetType) {\n+\n+        if (targetType.jTag == JTypeTags.JBYTE) {\n+            generateCheckCastBToJByte(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JCHAR) {\n+            generateCheckCastBToJChar(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JSHORT) {\n+            generateCheckCastBToJShort(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JINT) {\n+            generateCheckCastBToJInt(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JLONG) {\n+            generateCheckCastBToJLong(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JFLOAT) {\n+            generateCheckCastBToJFloat(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JDOUBLE) {\n+            generateCheckCastBToJDouble(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JREF) {\n+            if (((JType.JRefType) targetType).typeValue.equals(B_STRING_VALUE)) {\n+                generateCheckCastBToJString(mv, sourceType);\n+            } else {\n+                generateCheckCastBToJRef(mv, sourceType, targetType);\n+            }\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JARRAY) {\n+            generateCheckCastBToJRef(mv, sourceType, targetType);\n+            return;\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java %s'\",\n+                    sourceType, targetType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJString(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.STRING) {\n+            mv.visitMethodInsn(INVOKESTATIC, STRING_UTILS, \"fromString\",\n+                    String.format(\"(L%s;)L%s;\", STRING_VALUE, B_STRING_VALUE), false);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java byte'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJByte(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {\n+            // do nothing\n+        } else if (sourceType.tag == TypeTags.INT) {\n+            mv.visitInsn(L2I);\n+            mv.visitInsn(I2B);\n+        } else if (sourceType.tag == TypeTags.FLOAT) {\n+            mv.visitInsn(D2I);\n+            mv.visitInsn(I2B);\n+        } else if (sourceType.tag == TypeTags.HANDLE) {\n+            mv.visitMethodInsn(INVOKEVIRTUAL, HANDLE_VALUE, \"getValue\", \"()Ljava/lang/Object;\", false);\n+        } else if (sourceType.tag == TypeTags.FINITE) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToByte\", String.format(\"(L%s;)I\", OBJECT), false);\n+            mv.visitInsn(I2B);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java byte'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJChar(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {", "originalCommit": "82df207efdc85acd9646a1aae1461f7d1f7bbc5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzNzE0Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21435#discussion_r387437147", "bodyText": "Shall we use constants for the hardcoded values in all places?", "author": "riyafa", "createdAt": "2020-03-04T03:56:55Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmCastGen.java", "diffHunk": "@@ -0,0 +1,1096 @@\n+/*\n+ *  Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.bir.codegen;\n+\n+import org.ballerinalang.compiler.BLangCompilerException;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.MethodVisitor;\n+import org.wso2.ballerinalang.compiler.bir.codegen.JvmMethodGen.BalToJVMIndexMap;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JType;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JTypeTags;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRVariableDcl;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarScope;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BFiniteType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BMapType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BUnionType;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.TypeTags;\n+\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.ASTORE;\n+import static org.objectweb.asm.Opcodes.CHECKCAST;\n+import static org.objectweb.asm.Opcodes.D2F;\n+import static org.objectweb.asm.Opcodes.D2I;\n+import static org.objectweb.asm.Opcodes.D2L;\n+import static org.objectweb.asm.Opcodes.DUP;\n+import static org.objectweb.asm.Opcodes.F2D;\n+import static org.objectweb.asm.Opcodes.I2B;\n+import static org.objectweb.asm.Opcodes.I2C;\n+import static org.objectweb.asm.Opcodes.I2D;\n+import static org.objectweb.asm.Opcodes.I2F;\n+import static org.objectweb.asm.Opcodes.I2L;\n+import static org.objectweb.asm.Opcodes.I2S;\n+import static org.objectweb.asm.Opcodes.IFNE;\n+import static org.objectweb.asm.Opcodes.IFNULL;\n+import static org.objectweb.asm.Opcodes.INSTANCEOF;\n+import static org.objectweb.asm.Opcodes.INVOKEINTERFACE;\n+import static org.objectweb.asm.Opcodes.INVOKESPECIAL;\n+import static org.objectweb.asm.Opcodes.INVOKESTATIC;\n+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n+import static org.objectweb.asm.Opcodes.L2D;\n+import static org.objectweb.asm.Opcodes.L2F;\n+import static org.objectweb.asm.Opcodes.L2I;\n+import static org.objectweb.asm.Opcodes.NEW;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ARRAY_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BHANDLE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BOOLEAN_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BTYPE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DECIMAL_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DOUBLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ERROR_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUNCTION_POINTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUTURE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.HANDLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.INT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.LONG_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MAP_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.NUMBER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.REF_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.SIMPLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STREAM_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TABLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPEDESC_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPE_CHECKER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPE_CONVERTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.XML_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.B_STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.I_STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.addBoxInsn;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmLabelGen.LabelGenerator;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.symbolTable;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen.loadType;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.interop.InteropMethodGen.getSignatureForJType;\n+\n+/**\n+ * Check cast methods generation for JVM bytecode generation.\n+ *\n+ * @since 1.2.0\n+ */\n+public class JvmCastGen {\n+\n+    static void generatePlatformCheckCast(MethodVisitor mv, BalToJVMIndexMap indexMap, BType sourceType,\n+                                          BType targetType) {\n+\n+        if (sourceType.tag == JTypeTags.JTYPE) {\n+            // If a target type is bir type, then we can guarantee source type is a jvm type, hence the cast\n+            generateJToBCheckCast(mv, indexMap, (JType) sourceType, targetType);\n+        } else {\n+            // else target type is jvm and source type is bir\n+            generateBToJCheckCast(mv, sourceType, (JType) targetType);\n+        }\n+    }\n+\n+    public static void generateBToJCheckCast(MethodVisitor mv, BType sourceType, JType targetType) {\n+\n+        if (targetType.jTag == JTypeTags.JBYTE) {\n+            generateCheckCastBToJByte(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JCHAR) {\n+            generateCheckCastBToJChar(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JSHORT) {\n+            generateCheckCastBToJShort(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JINT) {\n+            generateCheckCastBToJInt(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JLONG) {\n+            generateCheckCastBToJLong(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JFLOAT) {\n+            generateCheckCastBToJFloat(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JDOUBLE) {\n+            generateCheckCastBToJDouble(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JREF) {\n+            if (((JType.JRefType) targetType).typeValue.equals(B_STRING_VALUE)) {\n+                generateCheckCastBToJString(mv, sourceType);\n+            } else {\n+                generateCheckCastBToJRef(mv, sourceType, targetType);\n+            }\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JARRAY) {\n+            generateCheckCastBToJRef(mv, sourceType, targetType);\n+            return;\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java %s'\",\n+                    sourceType, targetType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJString(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.STRING) {\n+            mv.visitMethodInsn(INVOKESTATIC, STRING_UTILS, \"fromString\",\n+                    String.format(\"(L%s;)L%s;\", STRING_VALUE, B_STRING_VALUE), false);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java byte'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJByte(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {\n+            // do nothing\n+        } else if (sourceType.tag == TypeTags.INT) {\n+            mv.visitInsn(L2I);\n+            mv.visitInsn(I2B);\n+        } else if (sourceType.tag == TypeTags.FLOAT) {\n+            mv.visitInsn(D2I);\n+            mv.visitInsn(I2B);\n+        } else if (sourceType.tag == TypeTags.HANDLE) {\n+            mv.visitMethodInsn(INVOKEVIRTUAL, HANDLE_VALUE, \"getValue\", \"()Ljava/lang/Object;\", false);\n+        } else if (sourceType.tag == TypeTags.FINITE) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToByte\", String.format(\"(L%s;)I\", OBJECT), false);\n+            mv.visitInsn(I2B);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java byte'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJChar(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {\n+            mv.visitInsn(I2C);\n+        } else if (sourceType.tag == TypeTags.INT) {\n+            mv.visitInsn(L2I);\n+            mv.visitInsn(I2C);\n+        } else if (sourceType.tag == TypeTags.FLOAT) {\n+            mv.visitInsn(D2I);\n+            mv.visitInsn(I2C);\n+        } else if (sourceType.tag == TypeTags.HANDLE) {\n+            mv.visitMethodInsn(INVOKEVIRTUAL, HANDLE_VALUE, \"getValue\", \"()Ljava/lang/Object;\", false);\n+        } else if (sourceType.tag == TypeTags.FINITE) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToInt\", String.format(\"(L%s;)J\", OBJECT), false);\n+            mv.visitInsn(L2I);\n+            mv.visitInsn(I2C);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java char'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJShort(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {\n+            mv.visitInsn(I2S);\n+        } else if (sourceType.tag == TypeTags.INT) {\n+            mv.visitInsn(L2I);\n+            mv.visitInsn(I2S);\n+        } else if (sourceType.tag == TypeTags.FLOAT) {\n+            mv.visitInsn(D2I);\n+            mv.visitInsn(I2S);\n+        } else if (sourceType.tag == TypeTags.HANDLE) {\n+            mv.visitMethodInsn(INVOKEVIRTUAL, HANDLE_VALUE, \"getValue\", \"()Ljava/lang/Object;\", false);", "originalCommit": "82df207efdc85acd9646a1aae1461f7d1f7bbc5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ0NTQ1Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21435#discussion_r387445456", "bodyText": "why?, I personally find it easier to read when I can see the value.", "author": "manuranga", "createdAt": "2020-03-04T04:39:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzNzE0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ0NTg2Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21435#discussion_r387445866", "bodyText": "If we change the name of the method in the future we would need to change only a constant instead of grepping to change all files which can create mistakes. It is a best practice to define method names as constants", "author": "riyafa", "createdAt": "2020-03-04T04:41:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzNzE0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzUxMTAzMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21435#discussion_r387511031", "bodyText": "Code is read more often than changed, so it better if its easier to read, not easier to modify. In my opinion you need to question the this kind of best practices than blindly trust them.", "author": "manuranga", "createdAt": "2020-03-04T08:26:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQzNzE0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ1Mjc0NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21435#discussion_r387452745", "bodyText": "This add(0, is used in multiple places. A new reader might not know what 0 signifies. If we define a constant for 0 it would add clarity.", "author": "riyafa", "createdAt": "2020-03-04T05:15:48Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/BIRGen.java", "diffHunk": "@@ -460,6 +461,7 @@ public void visit(BLangFunction astFunc) {\n         // Special %0 location for storing return values\n         birFunc.returnVariable = new BIRVariableDcl(astFunc.pos, astFunc.symbol.type.getReturnType(),\n                 this.env.nextLocalVarId(names), VarScope.FUNCTION, VarKind.RETURN, null);\n+        birFunc.localVars.add(0, birFunc.returnVariable);", "originalCommit": "82df207efdc85acd9646a1aae1461f7d1f7bbc5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0e80a5ea0a350948f0a831379c9b4065a9880af4", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0e80a5ea0a350948f0a831379c9b4065a9880af4", "message": "Fix running negative tests", "committedDate": "2020-03-04T05:29:12Z", "type": "commit"}, {"oid": "7f47c0b36610a862ac0075dd9a94414ac64312d7", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7f47c0b36610a862ac0075dd9a94414ac64312d7", "message": "Disable failing negative tests", "committedDate": "2020-03-04T05:29:57Z", "type": "commit"}, {"oid": "61278aae53e5eb07f5237248f3df59698c95b47d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/61278aae53e5eb07f5237248f3df59698c95b47d", "message": "Force rerun gradle tasks to override cache temporally", "committedDate": "2020-03-04T05:33:54Z", "type": "commit"}, {"oid": "7ae8882b91090620aef93185c5118660a8317389", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7ae8882b91090620aef93185c5118660a8317389", "message": "Merge remote-tracking branch 'origin/jbal-be-rewrite' into jbal-be-rewrite", "committedDate": "2020-03-04T05:35:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ1NTI1Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21435#discussion_r387455253", "bodyText": "Shall we remove commented out code in all places before merging?", "author": "riyafa", "createdAt": "2020-03-04T05:27:24Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmCastGen.java", "diffHunk": "@@ -0,0 +1,1096 @@\n+/*\n+ *  Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.bir.codegen;\n+\n+import org.ballerinalang.compiler.BLangCompilerException;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.MethodVisitor;\n+import org.wso2.ballerinalang.compiler.bir.codegen.JvmMethodGen.BalToJVMIndexMap;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JType;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JTypeTags;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRVariableDcl;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarScope;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BFiniteType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BMapType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BUnionType;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.TypeTags;\n+\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.ASTORE;\n+import static org.objectweb.asm.Opcodes.CHECKCAST;\n+import static org.objectweb.asm.Opcodes.D2F;\n+import static org.objectweb.asm.Opcodes.D2I;\n+import static org.objectweb.asm.Opcodes.D2L;\n+import static org.objectweb.asm.Opcodes.DUP;\n+import static org.objectweb.asm.Opcodes.F2D;\n+import static org.objectweb.asm.Opcodes.I2B;\n+import static org.objectweb.asm.Opcodes.I2C;\n+import static org.objectweb.asm.Opcodes.I2D;\n+import static org.objectweb.asm.Opcodes.I2F;\n+import static org.objectweb.asm.Opcodes.I2L;\n+import static org.objectweb.asm.Opcodes.I2S;\n+import static org.objectweb.asm.Opcodes.IFNE;\n+import static org.objectweb.asm.Opcodes.IFNULL;\n+import static org.objectweb.asm.Opcodes.INSTANCEOF;\n+import static org.objectweb.asm.Opcodes.INVOKEINTERFACE;\n+import static org.objectweb.asm.Opcodes.INVOKESPECIAL;\n+import static org.objectweb.asm.Opcodes.INVOKESTATIC;\n+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n+import static org.objectweb.asm.Opcodes.L2D;\n+import static org.objectweb.asm.Opcodes.L2F;\n+import static org.objectweb.asm.Opcodes.L2I;\n+import static org.objectweb.asm.Opcodes.NEW;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ARRAY_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BHANDLE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BOOLEAN_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BTYPE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DECIMAL_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DOUBLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ERROR_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUNCTION_POINTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUTURE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.HANDLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.INT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.LONG_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MAP_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.NUMBER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.REF_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.SIMPLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STREAM_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TABLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPEDESC_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPE_CHECKER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPE_CONVERTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.XML_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.B_STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.I_STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.addBoxInsn;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmLabelGen.LabelGenerator;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.symbolTable;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen.loadType;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.interop.InteropMethodGen.getSignatureForJType;\n+\n+/**\n+ * Check cast methods generation for JVM bytecode generation.\n+ *\n+ * @since 1.2.0\n+ */\n+public class JvmCastGen {\n+\n+    static void generatePlatformCheckCast(MethodVisitor mv, BalToJVMIndexMap indexMap, BType sourceType,\n+                                          BType targetType) {\n+\n+        if (sourceType.tag == JTypeTags.JTYPE) {\n+            // If a target type is bir type, then we can guarantee source type is a jvm type, hence the cast\n+            generateJToBCheckCast(mv, indexMap, (JType) sourceType, targetType);\n+        } else {\n+            // else target type is jvm and source type is bir\n+            generateBToJCheckCast(mv, sourceType, (JType) targetType);\n+        }\n+    }\n+\n+    public static void generateBToJCheckCast(MethodVisitor mv, BType sourceType, JType targetType) {\n+\n+        if (targetType.jTag == JTypeTags.JBYTE) {\n+            generateCheckCastBToJByte(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JCHAR) {\n+            generateCheckCastBToJChar(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JSHORT) {\n+            generateCheckCastBToJShort(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JINT) {\n+            generateCheckCastBToJInt(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JLONG) {\n+            generateCheckCastBToJLong(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JFLOAT) {\n+            generateCheckCastBToJFloat(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JDOUBLE) {\n+            generateCheckCastBToJDouble(mv, sourceType);\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JREF) {\n+            if (((JType.JRefType) targetType).typeValue.equals(B_STRING_VALUE)) {\n+                generateCheckCastBToJString(mv, sourceType);\n+            } else {\n+                generateCheckCastBToJRef(mv, sourceType, targetType);\n+            }\n+            return;\n+        } else if (targetType.jTag == JTypeTags.JARRAY) {\n+            generateCheckCastBToJRef(mv, sourceType, targetType);\n+            return;\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java %s'\",\n+                    sourceType, targetType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJString(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.STRING) {\n+            mv.visitMethodInsn(INVOKESTATIC, STRING_UTILS, \"fromString\",\n+                    String.format(\"(L%s;)L%s;\", STRING_VALUE, B_STRING_VALUE), false);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java byte'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJByte(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {\n+            // do nothing\n+        } else if (sourceType.tag == TypeTags.INT) {\n+            mv.visitInsn(L2I);\n+            mv.visitInsn(I2B);\n+        } else if (sourceType.tag == TypeTags.FLOAT) {\n+            mv.visitInsn(D2I);\n+            mv.visitInsn(I2B);\n+        } else if (sourceType.tag == TypeTags.HANDLE) {\n+            mv.visitMethodInsn(INVOKEVIRTUAL, HANDLE_VALUE, \"getValue\", \"()Ljava/lang/Object;\", false);\n+        } else if (sourceType.tag == TypeTags.FINITE) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToByte\", String.format(\"(L%s;)I\", OBJECT), false);\n+            mv.visitInsn(I2B);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java byte'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJChar(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {\n+            mv.visitInsn(I2C);\n+        } else if (sourceType.tag == TypeTags.INT) {\n+            mv.visitInsn(L2I);\n+            mv.visitInsn(I2C);\n+        } else if (sourceType.tag == TypeTags.FLOAT) {\n+            mv.visitInsn(D2I);\n+            mv.visitInsn(I2C);\n+        } else if (sourceType.tag == TypeTags.HANDLE) {\n+            mv.visitMethodInsn(INVOKEVIRTUAL, HANDLE_VALUE, \"getValue\", \"()Ljava/lang/Object;\", false);\n+        } else if (sourceType.tag == TypeTags.FINITE) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToInt\", String.format(\"(L%s;)J\", OBJECT), false);\n+            mv.visitInsn(L2I);\n+            mv.visitInsn(I2C);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java char'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJShort(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {\n+            mv.visitInsn(I2S);\n+        } else if (sourceType.tag == TypeTags.INT) {\n+            mv.visitInsn(L2I);\n+            mv.visitInsn(I2S);\n+        } else if (sourceType.tag == TypeTags.FLOAT) {\n+            mv.visitInsn(D2I);\n+            mv.visitInsn(I2S);\n+        } else if (sourceType.tag == TypeTags.HANDLE) {\n+            mv.visitMethodInsn(INVOKEVIRTUAL, HANDLE_VALUE, \"getValue\", \"()Ljava/lang/Object;\", false);\n+        } else if (sourceType.tag == TypeTags.FINITE) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToInt\", String.format(\"(L%s;)J\", OBJECT), false);\n+            mv.visitInsn(L2I);\n+            mv.visitInsn(I2S);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java short'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJInt(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {\n+            // do nothing\n+        } else if (sourceType.tag == TypeTags.INT) {\n+            mv.visitInsn(L2I);\n+        } else if (sourceType.tag == TypeTags.FLOAT) {\n+            mv.visitInsn(D2I);\n+        } else if (sourceType.tag == TypeTags.HANDLE) {\n+            mv.visitMethodInsn(INVOKEVIRTUAL, HANDLE_VALUE, \"getValue\", \"()Ljava/lang/Object;\", false);\n+        } else if (sourceType.tag == TypeTags.FINITE) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToInt\", String.format(\"(L%s;)J\", OBJECT), false);\n+            mv.visitInsn(L2I);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java int'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJLong(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {\n+            mv.visitInsn(I2L);\n+        } else if (sourceType.tag == TypeTags.INT) {\n+            // do nothing\n+        } else if (sourceType.tag == TypeTags.FLOAT) {\n+            mv.visitInsn(D2L);\n+        } else if (sourceType.tag == TypeTags.HANDLE) {\n+            mv.visitMethodInsn(INVOKEVIRTUAL, HANDLE_VALUE, \"getValue\", \"()Ljava/lang/Object;\", false);\n+        } else if (sourceType.tag == TypeTags.FINITE) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToInt\", String.format(\"(L%s;)J\", OBJECT), false);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java long'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJFloat(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {\n+            mv.visitInsn(I2F);\n+        } else if (sourceType.tag == TypeTags.INT) {\n+            mv.visitInsn(L2F);\n+        } else if (sourceType.tag == TypeTags.FLOAT) {\n+            mv.visitInsn(D2F);\n+        } else if (sourceType.tag == TypeTags.HANDLE) {\n+            mv.visitMethodInsn(INVOKEVIRTUAL, HANDLE_VALUE, \"getValue\", \"()Ljava/lang/Object;\", false);\n+        } else if (sourceType.tag == TypeTags.FINITE) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToFloat\", String.format(\"(L%s;)D\", OBJECT), false);\n+            mv.visitInsn(D2F);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java float'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJDouble(MethodVisitor mv, BType sourceType) {\n+\n+        if (sourceType.tag == TypeTags.BYTE) {\n+            mv.visitInsn(I2D);\n+        } else if (sourceType.tag == TypeTags.INT) {\n+            mv.visitInsn(L2D);\n+        } else if (sourceType.tag == TypeTags.FLOAT) {\n+            // do nothing\n+        } else if (sourceType.tag == TypeTags.HANDLE) {\n+            mv.visitMethodInsn(INVOKEVIRTUAL, HANDLE_VALUE, \"getValue\", \"()Ljava/lang/Object;\", false);\n+        } else if (sourceType.tag == TypeTags.FINITE) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToFloat\", String.format(\"(L%s;)D\", OBJECT), false);\n+        } else {\n+            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'java double'\",\n+                    sourceType));\n+        }\n+    }\n+\n+    private static void generateCheckCastBToJRef(MethodVisitor mv, BType sourceType, JType targetType) {\n+\n+        if (sourceType.tag == TypeTags.HANDLE) {\n+            if (targetType.jTag == JTypeTags.JREF) {\n+                JType.JRefType jRefType = (JType.JRefType) targetType;\n+                if (jRefType.typeValue.equals(HANDLE_VALUE) || jRefType.typeValue.equals(BHANDLE)) {\n+                    // do nothing\n+                    return;\n+                }\n+            }\n+            mv.visitMethodInsn(INVOKEVIRTUAL, HANDLE_VALUE, \"getValue\", \"()Ljava/lang/Object;\", false);\n+            String sig = getSignatureForJType(targetType);\n+            mv.visitTypeInsn(CHECKCAST, sig);\n+        } else if (sourceType.tag == TypeTags.DECIMAL) {\n+            // do nothing\n+            return;\n+        } else {\n+            if (targetType.jTag == JTypeTags.JREF) {\n+                addBoxInsn(mv, sourceType);\n+                mv.visitTypeInsn(CHECKCAST, ((JType.JRefType) targetType).typeValue);\n+            } else {\n+                throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to '%s'\",\n+                        sourceType, targetType));\n+            }\n+        }\n+    }\n+\n+    private static void generateJToBCheckCast(MethodVisitor mv, BalToJVMIndexMap indexMap, JType sourceType,\n+                                              BType targetType) {\n+\n+        if (targetType.tag == TypeTags.INT) {\n+            generateCheckCastJToBInt(mv, sourceType);\n+            return;\n+        } else if (targetType.tag == TypeTags.FLOAT) {\n+            generateCheckCastJToBFloat(mv, sourceType);\n+            return;\n+        } else if (targetType.tag == TypeTags.STRING) {\n+            generateCheckCastJToBString(mv, sourceType);\n+            return;\n+        } else if (targetType.tag == TypeTags.DECIMAL) {\n+            generateCheckCastJToBDecimal(mv, sourceType);\n+            return;\n+        } else if (targetType.tag == TypeTags.BOOLEAN) {\n+            generateCheckCastJToBBoolean(mv, sourceType);\n+            return;\n+        } else if (targetType.tag == TypeTags.BYTE) {\n+            generateCheckCastJToBByte(mv, sourceType);\n+            return;\n+        } else if (targetType.tag == TypeTags.NIL) {\n+            // Do nothing\n+            return;\n+        } else {\n+            if (targetType.tag == TypeTags.UNION) {\n+                generateCheckCastJToBUnionType(mv, indexMap, sourceType, (BUnionType) targetType);\n+            } else if (targetType.tag == TypeTags.ANYDATA) {\n+                generateCheckCastJToBAnyData(mv, indexMap, sourceType);\n+            } else if (targetType.tag == TypeTags.HANDLE) {\n+                generateJCastToBHandle(mv, sourceType);\n+            } else if (targetType.tag == TypeTags.ANY) {\n+                generateJCastToBAny(mv, indexMap, sourceType, targetType);\n+            } else if (targetType.tag == TypeTags.JSON) {\n+                generateCheckCastJToBJSON(mv, indexMap, sourceType);\n+            } else if (targetType.tag == TypeTags.FINITE) {\n+                generateCheckCastJToBFiniteType(mv, indexMap, sourceType, targetType);\n+                // TODO fix below properly - rajith\n+                //} else if (sourceType is bir:BXMLType && targetType is bir:BMapType) {\n+                //    generateXMLToAttributesMap(mv, sourceType);\n+                //    return;\n+                //} else if (targetType is bir:BFiniteType) {\n+                //    generateCheckCastToFiniteType(mv, sourceType, targetType);\n+                //    return;\n+                //} else if (sourceType is bir:BRecordType && (targetType is bir:BMapType && targetType.constraint\n+                // is bir:BTypeAny)) {\n+                //    // do nothing", "originalCommit": "82df207efdc85acd9646a1aae1461f7d1f7bbc5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ1ODI2NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21435#discussion_r387458264", "bodyText": "Shall we fix these strange comments?", "author": "riyafa", "createdAt": "2020-03-04T05:40:37Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmInstructionGen.java", "diffHunk": "@@ -0,0 +1,1698 @@\n+/*\n+ *  Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.bir.codegen;\n+\n+import org.ballerinalang.compiler.BLangCompilerException;\n+import org.ballerinalang.model.elements.PackageID;\n+import org.objectweb.asm.Handle;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.MethodVisitor;\n+import org.objectweb.asm.Opcodes;\n+import org.objectweb.asm.Type;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JInsKind;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JType;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JTypeTags;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRGlobalVariableDcl;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRPackage;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRVariableDcl;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLProcIns;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.UnaryOP;\n+import org.wso2.ballerinalang.compiler.bir.model.BIROperand;\n+import org.wso2.ballerinalang.compiler.bir.model.InstructionKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BArrayType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BJSONType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BObjectType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BServiceType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.util.TypeTags;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.objectweb.asm.Opcodes.ACONST_NULL;\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.ASTORE;\n+import static org.objectweb.asm.Opcodes.BIPUSH;\n+import static org.objectweb.asm.Opcodes.CHECKCAST;\n+import static org.objectweb.asm.Opcodes.DADD;\n+import static org.objectweb.asm.Opcodes.DCMPL;\n+import static org.objectweb.asm.Opcodes.DDIV;\n+import static org.objectweb.asm.Opcodes.DLOAD;\n+import static org.objectweb.asm.Opcodes.DMUL;\n+import static org.objectweb.asm.Opcodes.DNEG;\n+import static org.objectweb.asm.Opcodes.DREM;\n+import static org.objectweb.asm.Opcodes.DSTORE;\n+import static org.objectweb.asm.Opcodes.DSUB;\n+import static org.objectweb.asm.Opcodes.DUP;\n+import static org.objectweb.asm.Opcodes.FLOAD;\n+import static org.objectweb.asm.Opcodes.FSTORE;\n+import static org.objectweb.asm.Opcodes.GETSTATIC;\n+import static org.objectweb.asm.Opcodes.GOTO;\n+import static org.objectweb.asm.Opcodes.I2B;\n+import static org.objectweb.asm.Opcodes.I2L;\n+import static org.objectweb.asm.Opcodes.IADD;\n+import static org.objectweb.asm.Opcodes.IAND;\n+import static org.objectweb.asm.Opcodes.IASTORE;\n+import static org.objectweb.asm.Opcodes.ICONST_0;\n+import static org.objectweb.asm.Opcodes.ICONST_1;\n+import static org.objectweb.asm.Opcodes.IFEQ;\n+import static org.objectweb.asm.Opcodes.IFGE;\n+import static org.objectweb.asm.Opcodes.IFGT;\n+import static org.objectweb.asm.Opcodes.IFLE;\n+import static org.objectweb.asm.Opcodes.IFLT;\n+import static org.objectweb.asm.Opcodes.IFNE;\n+import static org.objectweb.asm.Opcodes.IF_ICMPEQ;\n+import static org.objectweb.asm.Opcodes.IF_ICMPGE;\n+import static org.objectweb.asm.Opcodes.IF_ICMPGT;\n+import static org.objectweb.asm.Opcodes.IF_ICMPLE;\n+import static org.objectweb.asm.Opcodes.IF_ICMPLT;\n+import static org.objectweb.asm.Opcodes.IF_ICMPNE;\n+import static org.objectweb.asm.Opcodes.ILOAD;\n+import static org.objectweb.asm.Opcodes.INEG;\n+import static org.objectweb.asm.Opcodes.INVOKEINTERFACE;\n+import static org.objectweb.asm.Opcodes.INVOKESPECIAL;\n+import static org.objectweb.asm.Opcodes.INVOKESTATIC;\n+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n+import static org.objectweb.asm.Opcodes.IOR;\n+import static org.objectweb.asm.Opcodes.ISHL;\n+import static org.objectweb.asm.Opcodes.ISHR;\n+import static org.objectweb.asm.Opcodes.ISTORE;\n+import static org.objectweb.asm.Opcodes.IUSHR;\n+import static org.objectweb.asm.Opcodes.IXOR;\n+import static org.objectweb.asm.Opcodes.L2I;\n+import static org.objectweb.asm.Opcodes.LADD;\n+import static org.objectweb.asm.Opcodes.LAND;\n+import static org.objectweb.asm.Opcodes.LCMP;\n+import static org.objectweb.asm.Opcodes.LLOAD;\n+import static org.objectweb.asm.Opcodes.LMUL;\n+import static org.objectweb.asm.Opcodes.LNEG;\n+import static org.objectweb.asm.Opcodes.LOR;\n+import static org.objectweb.asm.Opcodes.LSHL;\n+import static org.objectweb.asm.Opcodes.LSHR;\n+import static org.objectweb.asm.Opcodes.LSTORE;\n+import static org.objectweb.asm.Opcodes.LSUB;\n+import static org.objectweb.asm.Opcodes.LUSHR;\n+import static org.objectweb.asm.Opcodes.LXOR;\n+import static org.objectweb.asm.Opcodes.NEW;\n+import static org.objectweb.asm.Opcodes.NEWARRAY;\n+import static org.objectweb.asm.Opcodes.PUTSTATIC;\n+import static org.objectweb.asm.Opcodes.SWAP;\n+import static org.objectweb.asm.Opcodes.T_INT;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmCastGen.generateCast;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmCastGen.generateCheckCast;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmCastGen.generateCheckCastToByte;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmCastGen.generatePlatformCheckCast;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmCastGen.getTargetClass;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ANNOTATION_MAP_NAME;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ANNOTATION_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ARRAY_TYPE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ARRAY_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ARRAY_VALUE_IMPL;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BTYPE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BXML_QNAME;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DECIMAL_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ERROR_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUNCTION;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUNCTION_POINTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.JSON_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.LONG_STREAM;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MAP_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MAP_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MAP_VALUE_IMPL;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MATH_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MODULE_INIT_CLASS_NAME;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT_TYPE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRAND;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TABLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TUPLE_TYPE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TUPLE_VALUE_IMPL;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPEDESC_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPE_CHECKER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.XML_FACTORY;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.XML_QNAME;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.XML_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmMethodGen.BalToJVMIndexMap;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.currentClass;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.getPackageName;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.lambdaIndex;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.lambdas;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.lookupGlobalVarClassName;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.lookupTypeDef;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.symbolTable;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTerminatorGen.TerminatorGenerator.toNameString;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen.duplicateServiceTypeWithAnnots;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen.getTypeDesc;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen.loadExternalType;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen.loadType;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmValueGen.getTypeValueClassName;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.interop.InteropMethodGen.JCast;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.interop.InteropMethodGen.JInstruction;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.BinaryOp;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.ConstantLoad;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.FPLoad;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.FieldAccess;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.IsLike;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.Move;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewArray;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewError;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewInstance;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewStringXMLQName;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewStructure;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewTable;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewTypeDesc;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLComment;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLElement;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLQName;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLText;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.TypeCast;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.TypeTest;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.XMLAccess;\n+\n+/**\n+ * BIR instructions to JVM byte code generation related methods.\n+ *\n+ * @since 1.2.0\n+ */\n+public class JvmInstructionGen {\n+\n+    public static final String I_STRING_VALUE = \"org/ballerinalang/jvm/values/StringValue\";\n+    public static final String B_STRING_VALUE = \"org/ballerinalang/jvm/values/api/BString\";\n+    public static final String BMP_STRING_VALUE = \"org/ballerinalang/jvm/values/BmpStringValue\";\n+    public static final String NON_BMP_STRING_VALUE = \"org/ballerinalang/jvm/values/NonBmpStringValue\";\n+    public static final boolean IS_BSTRING = (System.getProperty(\"ballerina.bstring\") != null &&\n+            !\"\".equals(System.getProperty(\"ballerina.bstring\")));\n+    public static final String BSTRING_VALUE = IS_BSTRING ? I_STRING_VALUE : STRING_VALUE;\n+\n+    static void addBoxInsn(MethodVisitor mv, @Nilable BType bType) {\n+\n+        if (bType == null) {\n+            return;\n+        } else {\n+            generateCast(mv, bType, symbolTable.anyType, false);\n+        }\n+    }\n+\n+    public static void addUnboxInsn(MethodVisitor mv, @Nilable BType bType, boolean useBString /* = false */) {\n+\n+        if (bType == null) {\n+            return;\n+        } else {\n+            generateCast(mv, symbolTable.anyType, bType, useBString);\n+        }\n+    }\n+\n+    static void addJUnboxInsn(MethodVisitor mv, @Nilable JType jType) {\n+\n+        if (jType == null) {\n+            return;\n+        } else if (jType.jTag == JTypeTags.JBYTE) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToJByte\", String.format(\"(L%s;)B\", OBJECT), false);\n+        } else if (jType.jTag == JTypeTags.JCHAR) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToJChar\", String.format(\"(L%s;)C\", OBJECT), false);\n+        } else if (jType.jTag == JTypeTags.JSHORT) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToJShort\", String.format(\"(L%s;)S\", OBJECT), false);\n+        } else if (jType.jTag == JTypeTags.JINT) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToJInt\", String.format(\"(L%s;)I\", OBJECT), false);\n+        } else if (jType.jTag == JTypeTags.JLONG) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToJLong\", String.format(\"(L%s;)J\", OBJECT), false);\n+        } else if (jType.jTag == JTypeTags.JFLOAT) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToJFloat\", String.format(\"(L%s;)F\", OBJECT), false);\n+        } else if (jType.jTag == JTypeTags.JDOUBLE) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToJDouble\", String.format(\"(L%s;)D\", OBJECT), false);\n+        } else if (jType.jTag == JTypeTags.JBOOLEAN) {\n+            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToJBoolean\", String.format(\"(L%s;)Z\", OBJECT), false);\n+        } else if (jType.jTag == JTypeTags.JREF) {\n+            mv.visitTypeInsn(CHECKCAST, ((JType.JRefType) jType).typeValue);\n+            //} else {\n+            //    error err = error(io:sprintf(\"Unboxing is not supported for '%s'\", bType));\n+            //    panic err;\n+        }\n+    }\n+\n+    public static void generateVarLoad(MethodVisitor mv, BIRVariableDcl varDcl, String currentPackageName,\n+                                       int valueIndex) {\n+\n+        BType bType = varDcl.type;\n+\n+        if (varDcl.kind == VarKind.GLOBAL) {\n+            BIRGlobalVariableDcl globalVar = (BIRGlobalVariableDcl) varDcl;\n+            PackageID modId = globalVar.pkgId;\n+            String moduleName = getPackageName(modId.orgName, modId.name);\n+\n+            String varName = varDcl.name.value;\n+            String className = lookupGlobalVarClassName(moduleName, varName);\n+\n+            String typeSig = getTypeDesc(bType, false);\n+            mv.visitFieldInsn(GETSTATIC, className, varName, typeSig);\n+            return;\n+        } else if (varDcl.kind == VarKind.SELF) {\n+            mv.visitVarInsn(ALOAD, 0);\n+            return;\n+        } else if (varDcl.kind == VarKind.CONSTANT) {\n+            String varName = varDcl.name.value;\n+            PackageID moduleId = ((BIRGlobalVariableDcl) varDcl).pkgId;\n+            String pkgName = getPackageName(moduleId.orgName, moduleId.name);\n+            String className = lookupGlobalVarClassName(pkgName, varName);\n+            String typeSig = getTypeDesc(bType, false);\n+            mv.visitFieldInsn(GETSTATIC, className, varName, typeSig);\n+            return;\n+        }\n+\n+        if (bType.tag == TypeTags.INT) {\n+            mv.visitVarInsn(LLOAD, valueIndex);\n+        } else if (bType.tag == TypeTags.BYTE) {\n+            mv.visitVarInsn(ILOAD, valueIndex);\n+            mv.visitInsn(I2B);\n+            mv.visitMethodInsn(INVOKESTATIC, \"java/lang/Byte\", \"toUnsignedInt\", \"(B)I\", false);\n+        } else if (bType.tag == TypeTags.FLOAT) {\n+            mv.visitVarInsn(DLOAD, valueIndex);\n+        } else if (bType.tag == TypeTags.BOOLEAN) {\n+            mv.visitVarInsn(ILOAD, valueIndex);\n+        } else if (bType.tag == TypeTags.ARRAY ||\n+                bType.tag == TypeTags.STRING ||\n+                bType.tag == TypeTags.MAP ||\n+                bType.tag == TypeTags.TABLE ||\n+                bType.tag == TypeTags.STREAM ||\n+                bType.tag == TypeTags.ANY ||\n+                bType.tag == TypeTags.ANYDATA ||\n+                bType.tag == TypeTags.NIL ||\n+                bType.tag == TypeTags.UNION ||\n+                bType.tag == TypeTags.TUPLE ||\n+                bType.tag == TypeTags.RECORD ||\n+                bType.tag == TypeTags.ERROR ||\n+                bType.tag == TypeTags.JSON ||\n+                bType.tag == TypeTags.FUTURE ||\n+                bType.tag == TypeTags.OBJECT ||\n+                bType.tag == TypeTags.SERVICE ||\n+                bType.tag == TypeTags.DECIMAL ||\n+                bType.tag == TypeTags.XML ||\n+                bType.tag == TypeTags.INVOKABLE ||\n+                bType.tag == TypeTags.FINITE ||\n+                bType.tag == TypeTags.HANDLE ||\n+                bType.tag == TypeTags.TYPEDESC) {\n+            mv.visitVarInsn(ALOAD, valueIndex);\n+        } else if (bType.tag == JTypeTags.JTYPE) {\n+            generateJVarLoad(mv, (JType) bType, currentPackageName, valueIndex);\n+        } else {\n+            throw new BLangCompilerException(\"JVM generation is not supported for type \" + String.format(\"%s\", bType));\n+        }\n+    }\n+\n+    private static void generateJVarLoad(MethodVisitor mv, JType jType, String currentPackageName, int valueIndex) {\n+\n+        if (jType.jTag == JTypeTags.JBYTE) {\n+            mv.visitVarInsn(ILOAD, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JCHAR) {\n+            mv.visitVarInsn(ILOAD, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JSHORT) {\n+            mv.visitVarInsn(ILOAD, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JINT) {\n+            mv.visitVarInsn(ILOAD, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JLONG) {\n+            mv.visitVarInsn(LLOAD, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JFLOAT) {\n+            mv.visitVarInsn(FLOAD, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JDOUBLE) {\n+            mv.visitVarInsn(DLOAD, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JBOOLEAN) {\n+            mv.visitVarInsn(ILOAD, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JARRAY ||\n+                jType.jTag == JTypeTags.JREF) {\n+            mv.visitVarInsn(ALOAD, valueIndex);\n+        } else {\n+            throw new BLangCompilerException(\"JVM generation is not supported for type \" + String.format(\"%s\", jType));\n+        }\n+    }\n+\n+    public static void generateVarStore(MethodVisitor mv, BIRVariableDcl varDcl, String currentPackageName,\n+                                        int valueIndex) {\n+\n+        BType bType = varDcl.type;\n+\n+        if (varDcl.kind == VarKind.GLOBAL) {\n+            String varName = varDcl.name.value;\n+            String className = lookupGlobalVarClassName(currentPackageName, varName);\n+            String typeSig = getTypeDesc(bType, false);\n+            mv.visitFieldInsn(PUTSTATIC, className, varName, typeSig);\n+            return;\n+        } else if (varDcl.kind == VarKind.CONSTANT) {\n+            String varName = varDcl.name.value;\n+            PackageID moduleId = ((BIRGlobalVariableDcl) varDcl).pkgId;\n+            String pkgName = getPackageName(moduleId.orgName, moduleId.name);\n+            String className = lookupGlobalVarClassName(pkgName, varName);\n+            String typeSig = getTypeDesc(bType, false);\n+            mv.visitFieldInsn(PUTSTATIC, className, varName, typeSig);\n+            return;\n+        }\n+\n+        if (bType.tag == TypeTags.INT) {\n+            mv.visitVarInsn(LSTORE, valueIndex);\n+        } else if (bType.tag == TypeTags.BYTE) {\n+            mv.visitVarInsn(ISTORE, valueIndex);\n+        } else if (bType.tag == TypeTags.FLOAT) {\n+            mv.visitVarInsn(DSTORE, valueIndex);\n+        } else if (bType.tag == TypeTags.BOOLEAN) {\n+            mv.visitVarInsn(ISTORE, valueIndex);\n+        } else if (bType.tag == TypeTags.ARRAY ||\n+                bType.tag == TypeTags.STRING ||\n+                bType.tag == TypeTags.MAP ||\n+                bType.tag == TypeTags.TABLE ||\n+                bType.tag == TypeTags.STREAM ||\n+                bType.tag == TypeTags.ANY ||\n+                bType.tag == TypeTags.ANYDATA ||\n+                bType.tag == TypeTags.NIL ||\n+                bType.tag == TypeTags.UNION ||\n+                bType.tag == TypeTags.TUPLE ||\n+                bType.tag == TypeTags.DECIMAL ||\n+                bType.tag == TypeTags.RECORD ||\n+                bType.tag == TypeTags.ERROR ||\n+                bType.tag == TypeTags.JSON ||\n+                bType.tag == TypeTags.FUTURE ||\n+                bType.tag == TypeTags.OBJECT ||\n+                bType.tag == TypeTags.SERVICE ||\n+                bType.tag == TypeTags.XML ||\n+                bType.tag == TypeTags.INVOKABLE ||\n+                bType.tag == TypeTags.FINITE ||\n+                bType.tag == TypeTags.HANDLE ||\n+                bType.tag == TypeTags.TYPEDESC) {\n+            mv.visitVarInsn(ASTORE, valueIndex);\n+        } else if (bType.tag == JTypeTags.JTYPE) {\n+            generateJVarStore(mv, (JType) bType, currentPackageName, valueIndex);\n+        } else {\n+            throw new BLangCompilerException(\"JVM generation is not supported for type \" + String.format(\"%s\", bType));\n+        }\n+    }\n+\n+    private static void generateJVarStore(MethodVisitor mv, JType jType, String currentPackageName, int valueIndex) {\n+\n+        if (jType.jTag == JTypeTags.JBYTE) {\n+            mv.visitVarInsn(ISTORE, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JCHAR) {\n+            mv.visitVarInsn(ISTORE, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JSHORT) {\n+            mv.visitVarInsn(ISTORE, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JINT) {\n+            mv.visitVarInsn(ISTORE, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JLONG) {\n+            mv.visitVarInsn(LSTORE, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JFLOAT) {\n+            mv.visitVarInsn(FSTORE, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JDOUBLE) {\n+            mv.visitVarInsn(DSTORE, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JBOOLEAN) {\n+            mv.visitVarInsn(ISTORE, valueIndex);\n+        } else if (jType.jTag == JTypeTags.JARRAY ||\n+                jType.jTag == JTypeTags.JREF) {\n+            mv.visitVarInsn(ASTORE, valueIndex);\n+        } else {\n+            throw new BLangCompilerException(\"JVM generation is not supported for type \" + String.format(\"%s\", jType));\n+        }\n+    }\n+\n+    /**\n+     * Instruction generator helper class to hold its enclosing pkg and index map.\n+     *\n+     * @since 1.2.0\n+     */\n+    public static class InstructionGenerator {\n+\n+        MethodVisitor mv;\n+        BalToJVMIndexMap indexMap;\n+        String currentPackageName;\n+        BIRPackage currentPackage;\n+\n+        public InstructionGenerator(MethodVisitor mv, BalToJVMIndexMap indexMap, BIRPackage currentPackage) {\n+\n+            this.mv = mv;\n+            this.indexMap = indexMap;\n+            this.currentPackage = currentPackage;\n+            this.currentPackageName = getPackageName(currentPackage.org.value, currentPackage.name.value);\n+        }\n+\n+        void generatePlatformIns(JInstruction ins) {\n+\n+            if (ins.jKind == JInsKind.JCAST) {\n+                JCast castIns = (JCast) ins;\n+                BType targetType = castIns.targetType;\n+                this.loadVar(castIns.rhsOp.variableDcl);\n+                generatePlatformCheckCast(this.mv, this.indexMap, castIns.rhsOp.variableDcl.type, targetType);\n+                this.storeToVar(castIns.lhsOp.variableDcl);\n+            }\n+        }\n+\n+        void generateMoveIns(Move moveIns) {\n+\n+            this.loadVar(moveIns.rhsOp.variableDcl);\n+            this.storeToVar(moveIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateBinaryOpIns(BinaryOp binaryIns) {\n+\n+            InstructionKind insKind = binaryIns.kind;\n+            switch (insKind) {\n+                case ADD:\n+                    this.generateAddIns(binaryIns);\n+                    break;\n+                case SUB:\n+                    this.generateSubIns(binaryIns);\n+                    break;\n+                case MUL:\n+                    this.generateMulIns(binaryIns);\n+                    break;\n+                case DIV:\n+                    this.generateDivIns(binaryIns);\n+                    break;\n+                case MOD:\n+                    this.generateRemIns(binaryIns);\n+                    break;\n+                case EQUAL:\n+                    this.generateEqualIns(binaryIns);\n+                    break;\n+                case NOT_EQUAL:\n+                    this.generateNotEqualIns(binaryIns);\n+                    break;\n+                case GREATER_THAN:\n+                    this.generateGreaterThanIns(binaryIns);\n+                    break;\n+                case GREATER_EQUAL:\n+                    this.generateGreaterEqualIns(binaryIns);\n+                    break;\n+                case LESS_THAN:\n+                    this.generateLessThanIns(binaryIns);\n+                    break;\n+                case LESS_EQUAL:\n+                    this.generateLessEqualIns(binaryIns);\n+                    break;\n+                case REF_EQUAL:\n+                    this.generateRefEqualIns(binaryIns);\n+                    break;\n+                case REF_NOT_EQUAL:\n+                    this.generateRefNotEqualIns(binaryIns);\n+                    break;\n+                case CLOSED_RANGE:\n+                    this.generateClosedRangeIns(binaryIns);\n+                    break;\n+                case HALF_OPEN_RANGE:\n+                    this.generateClosedRangeIns(binaryIns);\n+                    break;\n+                case ANNOT_ACCESS:\n+                    this.generateAnnotAccessIns(binaryIns);\n+                    break;\n+                case BITWISE_AND:\n+                    this.generateBitwiseAndIns(binaryIns);\n+                    break;\n+                case BITWISE_OR:\n+                    this.generateBitwiseOrIns(binaryIns);\n+                    break;\n+                case BITWISE_XOR:\n+                    this.generateBitwiseXorIns(binaryIns);\n+                    break;\n+                case BITWISE_LEFT_SHIFT:\n+                    this.generateBitwiseLeftShiftIns(binaryIns);\n+                    break;\n+                case BITWISE_RIGHT_SHIFT:\n+                    this.generateBitwiseRightShiftIns(binaryIns);\n+                    break;\n+                case BITWISE_UNSIGNED_RIGHT_SHIFT:\n+                    this.generateBitwiseUnsignedRightShiftIns(binaryIns);\n+                    break;\n+                default:\n+                    throw new BLangCompilerException(\"JVM generation is not supported for instruction kind : \" +\n+                            String.format(\"%s\", insKind));\n+            }\n+        }\n+\n+        void generateBinaryRhsAndLhsLoad(BinaryOp binaryIns) {\n+\n+            this.loadVar(binaryIns.rhsOp1.variableDcl);\n+            this.loadVar(binaryIns.rhsOp2.variableDcl);\n+        }\n+\n+        private void generateLessThanIns(BinaryOp binaryIns) {\n+\n+            this.generateBinaryCompareIns(binaryIns, IFLT);\n+        }\n+\n+        private void generateGreaterThanIns(BinaryOp binaryIns) {\n+\n+            this.generateBinaryCompareIns(binaryIns, IFGT);\n+        }\n+\n+        private void generateLessEqualIns(BinaryOp binaryIns) {\n+\n+            this.generateBinaryCompareIns(binaryIns, IFLE);\n+\n+        }\n+\n+        private void generateGreaterEqualIns(BinaryOp binaryIns) {\n+\n+            this.generateBinaryCompareIns(binaryIns, IFGE);\n+        }\n+\n+        private void generateBinaryCompareIns(BinaryOp binaryIns, int opcode) {\n+\n+            if (opcode != IFLT && opcode != IFGT && opcode != IFLE && opcode != IFGE) {\n+                throw new BLangCompilerException(String.format(\"Unsupported opcode '%s' for binary operator.\", opcode));\n+            }\n+\n+            this.generateBinaryRhsAndLhsLoad(binaryIns);\n+            Label label1 = new Label();\n+            Label label2 = new Label();\n+\n+            BType lhsOpType = binaryIns.rhsOp1.variableDcl.type;\n+            BType rhsOpType = binaryIns.rhsOp2.variableDcl.type;\n+\n+            if (lhsOpType.tag == TypeTags.INT && rhsOpType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(LCMP);\n+                this.mv.visitJumpInsn(opcode, label1);\n+            } else if (lhsOpType.tag == TypeTags.BYTE && rhsOpType.tag == TypeTags.BYTE) {\n+                if (opcode == IFLT) {\n+                    this.mv.visitJumpInsn(IF_ICMPLT, label1);\n+                } else if (opcode != IFGT) {\n+                    this.mv.visitJumpInsn(IF_ICMPGT, label1);\n+                } else if (opcode != IFLE) {\n+                    this.mv.visitJumpInsn(IF_ICMPLE, label1);\n+                } else if (opcode == IFGE) {\n+                    this.mv.visitJumpInsn(IF_ICMPGE, label1);\n+                }\n+            } else if (lhsOpType.tag == TypeTags.FLOAT && rhsOpType.tag == TypeTags.FLOAT) {\n+                this.mv.visitInsn(DCMPL);\n+                this.mv.visitJumpInsn(opcode, label1);\n+            } else if (lhsOpType.tag == TypeTags.DECIMAL && rhsOpType.tag == TypeTags.DECIMAL) {\n+                String compareFuncName = this.getDecimalCompareFuncName(opcode);\n+                this.mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, compareFuncName,\n+                        String.format(\"(L%s;L%s;)Z\", DECIMAL_VALUE, DECIMAL_VALUE), false);\n+                this.storeToVar(binaryIns.lhsOp.variableDcl);\n+                return;\n+            }\n+\n+            this.mv.visitInsn(ICONST_0);\n+            this.mv.visitJumpInsn(GOTO, label2);\n+\n+            this.mv.visitLabel(label1);\n+            this.mv.visitInsn(ICONST_1);\n+\n+            this.mv.visitLabel(label2);\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        private String getDecimalCompareFuncName(int opcode) {\n+\n+            if (opcode == IFGT) {\n+                return \"checkDecimalGreaterThan\";\n+            } else if (opcode == IFGE) {\n+                return \"checkDecimalGreaterThanOrEqual\";\n+            } else if (opcode == IFLT) {\n+                return \"checkDecimalLessThan\";\n+            } else if (opcode == IFLE) {\n+                return \"checkDecimalLessThanOrEqual\";\n+            } else {\n+                throw new BLangCompilerException(String.format(\"Opcode: '%s' is not a comparison opcode.\", opcode));\n+            }\n+        }\n+\n+        void generateEqualIns(BinaryOp binaryIns) {\n+\n+            this.generateBinaryRhsAndLhsLoad(binaryIns);\n+\n+            Label label1 = new Label();\n+            Label label2 = new Label();\n+\n+            BType lhsOpType = binaryIns.rhsOp1.variableDcl.type;\n+            BType rhsOpType = binaryIns.rhsOp2.variableDcl.type;\n+\n+            if (lhsOpType.tag == TypeTags.INT && rhsOpType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(LCMP);\n+                this.mv.visitJumpInsn(IFNE, label1);\n+            } else if (lhsOpType.tag == TypeTags.BYTE && rhsOpType.tag == TypeTags.BYTE) {\n+                this.mv.visitJumpInsn(IF_ICMPNE, label1);\n+            } else if (lhsOpType.tag == TypeTags.FLOAT && rhsOpType.tag == TypeTags.FLOAT) {\n+                this.mv.visitInsn(DCMPL);\n+                this.mv.visitJumpInsn(IFNE, label1);\n+            } else if (lhsOpType.tag == TypeTags.BOOLEAN && rhsOpType.tag == TypeTags.BOOLEAN) {\n+                this.mv.visitJumpInsn(IF_ICMPNE, label1);\n+            } else if (lhsOpType.tag == TypeTags.DECIMAL && rhsOpType.tag == TypeTags.DECIMAL) {\n+                this.mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"checkDecimalEqual\",\n+                        String.format(\"(L%s;L%s;)Z\", DECIMAL_VALUE, DECIMAL_VALUE), false);\n+                this.storeToVar(binaryIns.lhsOp.variableDcl);\n+                return;\n+            } else {\n+                this.mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"isEqual\",\n+                        String.format(\"(L%s;L%s;)Z\", OBJECT, OBJECT), false);\n+                this.storeToVar(binaryIns.lhsOp.variableDcl);\n+                return;\n+            }\n+\n+            this.mv.visitInsn(ICONST_1);\n+            this.mv.visitJumpInsn(GOTO, label2);\n+\n+            this.mv.visitLabel(label1);\n+            this.mv.visitInsn(ICONST_0);\n+\n+            this.mv.visitLabel(label2);\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateNotEqualIns(BinaryOp binaryIns) {\n+\n+            this.generateBinaryRhsAndLhsLoad(binaryIns);\n+\n+            Label label1 = new Label();\n+            Label label2 = new Label();\n+\n+            // It is assumed that both operands are of same type\n+            BType lhsOpType = binaryIns.rhsOp1.variableDcl.type;\n+            BType rhsOpType = binaryIns.rhsOp2.variableDcl.type;\n+            if (lhsOpType.tag == TypeTags.INT && rhsOpType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(LCMP);\n+                this.mv.visitJumpInsn(IFEQ, label1);\n+            } else if (lhsOpType.tag == TypeTags.BYTE && rhsOpType.tag == TypeTags.BYTE) {\n+                this.mv.visitJumpInsn(IF_ICMPEQ, label1);\n+            } else if (lhsOpType.tag == TypeTags.FLOAT && rhsOpType.tag == TypeTags.FLOAT) {\n+                this.mv.visitInsn(DCMPL);\n+                this.mv.visitJumpInsn(IFEQ, label1);\n+            } else if (lhsOpType.tag == TypeTags.BOOLEAN && rhsOpType.tag == TypeTags.BOOLEAN) {\n+                this.mv.visitJumpInsn(IF_ICMPEQ, label1);\n+            } else if (lhsOpType.tag == TypeTags.DECIMAL && rhsOpType.tag == TypeTags.DECIMAL) {\n+                this.mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"checkDecimalEqual\",\n+                        String.format(\"(L%s;L%s;)Z\", DECIMAL_VALUE, DECIMAL_VALUE), false);\n+                this.mv.visitJumpInsn(IFNE, label1);\n+            } else {\n+                this.mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"isEqual\",\n+                        String.format(\"(L%s;L%s;)Z\", OBJECT, OBJECT), false);\n+                this.mv.visitJumpInsn(IFNE, label1);\n+            }\n+\n+            this.mv.visitInsn(ICONST_1);\n+            this.mv.visitJumpInsn(GOTO, label2);\n+\n+            this.mv.visitLabel(label1);\n+            this.mv.visitInsn(ICONST_0);\n+\n+            this.mv.visitLabel(label2);\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateRefEqualIns(BinaryOp binaryIns) {\n+\n+            this.generateBinaryRhsAndLhsLoad(binaryIns);\n+\n+            Label label1 = new Label();\n+            Label label2 = new Label();\n+\n+            BType lhsOpType = binaryIns.rhsOp1.variableDcl.type;\n+            BType rhsOpType = binaryIns.rhsOp2.variableDcl.type;\n+            if (lhsOpType.tag == TypeTags.INT && rhsOpType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(LCMP);\n+                this.mv.visitJumpInsn(IFNE, label1);\n+            } else if (lhsOpType.tag == TypeTags.BYTE && rhsOpType.tag == TypeTags.BYTE) {\n+                this.mv.visitJumpInsn(IF_ICMPNE, label1);\n+            } else if (lhsOpType.tag == TypeTags.FLOAT && rhsOpType.tag == TypeTags.FLOAT) {\n+                this.mv.visitInsn(DCMPL);\n+                this.mv.visitJumpInsn(IFNE, label1);\n+            } else if (lhsOpType.tag == TypeTags.BOOLEAN && rhsOpType.tag == TypeTags.BOOLEAN) {\n+                this.mv.visitJumpInsn(IF_ICMPNE, label1);\n+            } else {\n+                this.mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"isReferenceEqual\",\n+                        String.format(\"(L%s;L%s;)Z\", OBJECT, OBJECT), false);\n+                this.storeToVar(binaryIns.lhsOp.variableDcl);\n+                return;\n+            }\n+\n+            this.mv.visitInsn(ICONST_1);\n+            this.mv.visitJumpInsn(GOTO, label2);\n+\n+            this.mv.visitLabel(label1);\n+            this.mv.visitInsn(ICONST_0);\n+\n+            this.mv.visitLabel(label2);\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateRefNotEqualIns(BinaryOp binaryIns) {\n+\n+            this.generateBinaryRhsAndLhsLoad(binaryIns);\n+\n+            Label label1 = new Label();\n+            Label label2 = new Label();\n+\n+            // It is assumed that both operands are of same type\n+            BType lhsOpType = binaryIns.rhsOp1.variableDcl.type;\n+            BType rhsOpType = binaryIns.rhsOp2.variableDcl.type;\n+            if (lhsOpType.tag == TypeTags.INT && rhsOpType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(LCMP);\n+                this.mv.visitJumpInsn(IFEQ, label1);\n+            } else if (lhsOpType.tag == TypeTags.BYTE && rhsOpType.tag == TypeTags.BYTE) {\n+                this.mv.visitJumpInsn(IF_ICMPEQ, label1);\n+            } else if (lhsOpType.tag == TypeTags.FLOAT && rhsOpType.tag == TypeTags.FLOAT) {\n+                this.mv.visitInsn(DCMPL);\n+                this.mv.visitJumpInsn(IFEQ, label1);\n+            } else if (lhsOpType.tag == TypeTags.BOOLEAN && rhsOpType.tag == TypeTags.BOOLEAN) {\n+                this.mv.visitJumpInsn(IF_ICMPEQ, label1);\n+            } else {\n+                this.mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"isReferenceEqual\",\n+                        String.format(\"(L%s;L%s;)Z\", OBJECT, OBJECT), false);\n+                this.mv.visitJumpInsn(IFNE, label1);\n+            }\n+\n+            this.mv.visitInsn(ICONST_1);\n+            this.mv.visitJumpInsn(GOTO, label2);\n+\n+            this.mv.visitLabel(label1);\n+            this.mv.visitInsn(ICONST_0);\n+\n+            this.mv.visitLabel(label2);\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateClosedRangeIns(BinaryOp binaryIns) {\n+\n+            this.mv.visitTypeInsn(NEW, ARRAY_VALUE_IMPL);\n+            this.mv.visitInsn(DUP);\n+            this.generateBinaryRhsAndLhsLoad(binaryIns);\n+            this.mv.visitMethodInsn(INVOKESTATIC, LONG_STREAM, \"rangeClosed\", String.format(\"(JJ)L%s;\", LONG_STREAM),\n+                    true);\n+            this.mv.visitMethodInsn(INVOKEINTERFACE, LONG_STREAM, \"toArray\", \"()[J\", true);\n+            this.mv.visitMethodInsn(INVOKESPECIAL, ARRAY_VALUE_IMPL, \"<init>\", \"([J)V\", false);\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateAnnotAccessIns(BinaryOp binaryIns) {\n+\n+            this.loadVar(binaryIns.rhsOp1.variableDcl);\n+            this.loadVar(binaryIns.rhsOp2.variableDcl);\n+            this.mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"getAnnotValue\",\n+                    String.format(\"(L%s;L%s;)L%s;\", TYPEDESC_VALUE, STRING_VALUE, OBJECT), false);\n+\n+            BType targetType = binaryIns.lhsOp.variableDcl.type;\n+            addUnboxInsn(this.mv, targetType, false);\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateAddIns(BinaryOp binaryIns) {\n+\n+            BType bType = binaryIns.lhsOp.variableDcl.type;\n+            this.generateBinaryRhsAndLhsLoad(binaryIns);\n+            if (bType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(LADD);\n+            } else if (bType.tag == TypeTags.BYTE) {\n+                this.mv.visitInsn(IADD);\n+            } else if (bType.tag == TypeTags.STRING) {\n+                if (IS_BSTRING) {\n+                    this.mv.visitMethodInsn(INVOKEINTERFACE, BSTRING_VALUE, \"concat\",\n+                            String.format(\"(L%s;)L%s;\", BSTRING_VALUE, BSTRING_VALUE), true);\n+                } else {\n+                    this.mv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/String\", \"concat\",\n+                            String.format(\"(L%s;)L%s;\", STRING_VALUE, STRING_VALUE), false);\n+                }\n+            } else if (bType.tag == TypeTags.DECIMAL) {\n+                this.mv.visitMethodInsn(INVOKEVIRTUAL, DECIMAL_VALUE, \"add\",\n+                        String.format(\"(L%s;)L%s;\", DECIMAL_VALUE, DECIMAL_VALUE), false);\n+            } else if (bType.tag == TypeTags.FLOAT) {\n+                this.mv.visitInsn(DADD);\n+            } else if (bType.tag == TypeTags.XML) {\n+                this.mv.visitMethodInsn(INVOKESTATIC, XML_FACTORY, \"concatenate\",\n+                        String.format(\"(L%s;L%s;)L%s;\", XML_VALUE, XML_VALUE, XML_VALUE), false);\n+            } else {\n+                throw new BLangCompilerException(\"JVM generation is not supported for type \" +\n+                        String.format(\"%s\", binaryIns.lhsOp.variableDcl.type));\n+            }\n+\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateSubIns(BinaryOp binaryIns) {\n+\n+            BType bType = binaryIns.lhsOp.variableDcl.type;\n+            this.generateBinaryRhsAndLhsLoad(binaryIns);\n+            if (bType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(LSUB);\n+            } else if (bType.tag == TypeTags.FLOAT) {\n+                this.mv.visitInsn(DSUB);\n+            } else if (bType.tag == TypeTags.DECIMAL) {\n+                this.mv.visitMethodInsn(INVOKEVIRTUAL, DECIMAL_VALUE, \"subtract\",\n+                        String.format(\"(L%s;)L%s;\", DECIMAL_VALUE, DECIMAL_VALUE), false);\n+            } else {\n+                throw new BLangCompilerException(\"JVM generation is not supported for type \" +\n+                        String.format(\"%s\", binaryIns.lhsOp.variableDcl.type));\n+            }\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateDivIns(BinaryOp binaryIns) {\n+\n+            BType bType = binaryIns.lhsOp.variableDcl.type;\n+            this.generateBinaryRhsAndLhsLoad(binaryIns);\n+            if (bType.tag == TypeTags.INT) {\n+                this.mv.visitMethodInsn(INVOKESTATIC, MATH_UTILS, \"divide\", \"(JJ)J\", false);\n+            } else if (bType.tag == TypeTags.FLOAT) {\n+                this.mv.visitInsn(DDIV);\n+            } else if (bType.tag == TypeTags.DECIMAL) {\n+                this.mv.visitMethodInsn(INVOKEVIRTUAL, DECIMAL_VALUE, \"divide\",\n+                        String.format(\"(L%s;)L%s;\", DECIMAL_VALUE, DECIMAL_VALUE), false);\n+            } else {\n+                throw new BLangCompilerException(\"JVM generation is not supported for type \" +\n+                        String.format(\"%s\", binaryIns.lhsOp.variableDcl.type));\n+            }\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateMulIns(BinaryOp binaryIns) {\n+\n+            BType bType = binaryIns.lhsOp.variableDcl.type;\n+            this.generateBinaryRhsAndLhsLoad(binaryIns);\n+            if (bType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(LMUL);\n+            } else if (bType.tag == TypeTags.FLOAT) {\n+                this.mv.visitInsn(DMUL);\n+            } else if (bType.tag == TypeTags.DECIMAL) {\n+                this.mv.visitMethodInsn(INVOKEVIRTUAL, DECIMAL_VALUE, \"multiply\",\n+                        String.format(\"(L%s;)L%s;\", DECIMAL_VALUE, DECIMAL_VALUE), false);\n+            } else {\n+                throw new BLangCompilerException(\"JVM generation is not supported for type \" +\n+                        String.format(\"%s\", binaryIns.lhsOp.variableDcl.type));\n+            }\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateRemIns(BinaryOp binaryIns) {\n+\n+            BType bType = binaryIns.lhsOp.variableDcl.type;\n+            this.generateBinaryRhsAndLhsLoad(binaryIns);\n+            if (bType.tag == TypeTags.INT) {\n+                this.mv.visitMethodInsn(INVOKESTATIC, MATH_UTILS, \"remainder\", \"(JJ)J\", false);\n+            } else if (bType.tag == TypeTags.FLOAT) {\n+                this.mv.visitInsn(DREM);\n+            } else if (bType.tag == TypeTags.DECIMAL) {\n+                this.mv.visitMethodInsn(INVOKEVIRTUAL, DECIMAL_VALUE, \"remainder\",\n+                        String.format(\"(L%s;)L%s;\", DECIMAL_VALUE, DECIMAL_VALUE), false);\n+            } else {\n+                throw new BLangCompilerException(\"JVM generation is not supported for type \" +\n+                        String.format(\"%s\", binaryIns.lhsOp.variableDcl.type));\n+            }\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateBitwiseAndIns(BinaryOp binaryIns) {\n+\n+            BType opType1 = binaryIns.rhsOp1.variableDcl.type;\n+            BType opType2 = binaryIns.rhsOp2.variableDcl.type;\n+\n+            if (opType1.tag == TypeTags.INT && opType2.tag == TypeTags.INT) {\n+                this.loadVar(binaryIns.rhsOp1.variableDcl);\n+                this.loadVar(binaryIns.rhsOp2.variableDcl);\n+                this.mv.visitInsn(LAND);\n+            } else {\n+                this.loadVar(binaryIns.rhsOp1.variableDcl);\n+                generateCheckCastToByte(this.mv, opType1);\n+\n+                this.loadVar(binaryIns.rhsOp2.variableDcl);\n+                generateCheckCastToByte(this.mv, opType2);\n+\n+                this.mv.visitInsn(IAND);\n+            }\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateBitwiseOrIns(BinaryOp binaryIns) {\n+\n+            this.loadVar(binaryIns.rhsOp1.variableDcl);\n+            this.loadVar(binaryIns.rhsOp2.variableDcl);\n+\n+            BType opType = binaryIns.rhsOp1.variableDcl.type;\n+            if (opType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(LOR);\n+            } else {\n+                this.mv.visitInsn(IOR);\n+            }\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateBitwiseXorIns(BinaryOp binaryIns) {\n+\n+            this.loadVar(binaryIns.rhsOp1.variableDcl);\n+            this.loadVar(binaryIns.rhsOp2.variableDcl);\n+\n+            BType opType = binaryIns.rhsOp1.variableDcl.type;\n+            if (opType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(LXOR);\n+            } else {\n+                this.mv.visitInsn(IXOR);\n+            }\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateBitwiseLeftShiftIns(BinaryOp binaryIns) {\n+\n+            this.loadVar(binaryIns.rhsOp1.variableDcl);\n+            this.loadVar(binaryIns.rhsOp2.variableDcl);\n+\n+            BType secondOpType = binaryIns.rhsOp2.variableDcl.type;\n+            if (secondOpType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(L2I);\n+            }\n+\n+            BType firstOpType = binaryIns.rhsOp1.variableDcl.type;\n+            if (firstOpType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(LSHL);\n+            } else {\n+                this.mv.visitInsn(ISHL);\n+                this.mv.visitInsn(I2L);\n+            }\n+\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateBitwiseRightShiftIns(BinaryOp binaryIns) {\n+\n+            this.loadVar(binaryIns.rhsOp1.variableDcl);\n+            this.loadVar(binaryIns.rhsOp2.variableDcl);\n+\n+            BType secondOpType = binaryIns.rhsOp2.variableDcl.type;\n+            if (secondOpType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(L2I);\n+            }\n+\n+            BType firstOpType = binaryIns.rhsOp1.variableDcl.type;\n+            if (firstOpType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(LSHR);\n+            } else {\n+                this.mv.visitInsn(ISHR);\n+            }\n+\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateBitwiseUnsignedRightShiftIns(BinaryOp binaryIns) {\n+\n+            this.loadVar(binaryIns.rhsOp1.variableDcl);\n+            this.loadVar(binaryIns.rhsOp2.variableDcl);\n+\n+            BType secondOpType = binaryIns.rhsOp2.variableDcl.type;\n+            if (secondOpType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(L2I);\n+            }\n+\n+            BType firstOpType = binaryIns.rhsOp1.variableDcl.type;\n+            if (firstOpType.tag == TypeTags.INT) {\n+                this.mv.visitInsn(LUSHR);\n+            } else {\n+                this.mv.visitInsn(IUSHR);\n+            }\n+\n+            this.storeToVar(binaryIns.lhsOp.variableDcl);\n+        }\n+\n+        int getJVMIndexOfVarRef(BIRVariableDcl varDcl) {\n+\n+            return this.indexMap.getIndex(varDcl);\n+        }\n+\n+        void generateMapNewIns(NewStructure mapNewIns, int localVarOffset) {\n+\n+            BType typeOfMapNewIns = mapNewIns.type;\n+            String className = MAP_VALUE_IMPL;\n+\n+            if (typeOfMapNewIns.tag == TypeTags.RECORD) {\n+                if (mapNewIns.isExternalDef) {\n+                    className = getTypeValueClassName(mapNewIns.externalPackageId, toNameString(typeOfMapNewIns));\n+                } else {\n+                    className = getTypeValueClassName(this.currentPackage, toNameString(typeOfMapNewIns));\n+                }\n+\n+                this.mv.visitTypeInsn(NEW, className);\n+                this.mv.visitInsn(DUP);\n+                this.mv.visitInsn(DUP);\n+                if (mapNewIns.isExternalDef) {\n+                    loadExternalType(this.mv, mapNewIns.externalPackageId, mapNewIns.recordName);\n+                } else {\n+                    loadType(this.mv, mapNewIns.type);\n+                }\n+                this.mv.visitMethodInsn(INVOKESPECIAL, className, \"<init>\", String.format(\"(L%s;)V\", BTYPE), false);\n+\n+                // Invoke the init-function of this type.\n+                this.mv.visitVarInsn(ALOAD, localVarOffset);\n+                this.mv.visitInsn(SWAP);\n+                this.mv.visitMethodInsn(INVOKESTATIC, className, \"$init\",\n+                        String.format(\"(L%s;L%s;)V\", STRAND, MAP_VALUE), false);\n+            } else {\n+                this.mv.visitTypeInsn(NEW, className);\n+                this.mv.visitInsn(DUP);\n+                loadType(this.mv, mapNewIns.type);\n+                this.mv.visitMethodInsn(INVOKESPECIAL, className, \"<init>\", String.format(\"(L%s;)V\", BTYPE), false);\n+            }\n+            this.storeToVar(mapNewIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateTableNewIns(NewTable tableNewIns) {\n+\n+            this.mv.visitTypeInsn(NEW, TABLE_VALUE);\n+            this.mv.visitInsn(DUP);\n+            loadType(this.mv, tableNewIns.type);\n+            this.loadVar(tableNewIns.keyColOp.variableDcl);\n+            this.loadVar(tableNewIns.dataOp.variableDcl);\n+            this.mv.visitMethodInsn(INVOKESPECIAL, TABLE_VALUE, \"<init>\", String.format(\"(L%s;L%s;L%s;)V\", BTYPE,\n+                    ARRAY_VALUE, ARRAY_VALUE), false);\n+            this.storeToVar(tableNewIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateMapStoreIns(FieldAccess mapStoreIns) {\n+            // visit map_ref\n+            this.loadVar(mapStoreIns.lhsOp.variableDcl);\n+            BType varRefType = mapStoreIns.lhsOp.variableDcl.type;\n+\n+            // visit key_expr\n+            this.loadVar(mapStoreIns.keyOp.variableDcl);\n+\n+            // visit value_expr\n+            BType valueType = mapStoreIns.rhsOp.variableDcl.type;\n+            this.loadVar(mapStoreIns.rhsOp.variableDcl);\n+            addBoxInsn(this.mv, valueType);\n+\n+            if (varRefType.tag == TypeTags.JSON) {\n+                this.mv.visitMethodInsn(INVOKESTATIC, JSON_UTILS, \"setElement\",\n+                        String.format(\"(L%s;L%s;L%s;)V\", OBJECT, STRING_VALUE, OBJECT), false);\n+            } else {\n+                this.mv.visitMethodInsn(INVOKESTATIC, MAP_UTILS, \"handleMapStore\",\n+                        String.format(\"(L%s;L%s;L%s;)V\", MAP_VALUE, STRING_VALUE, OBJECT),\n+                        false);\n+            }\n+        }\n+\n+        void generateMapLoadIns(FieldAccess mapLoadIns) {\n+            // visit map_ref\n+            this.loadVar(mapLoadIns.rhsOp.variableDcl);\n+            BType varRefType = mapLoadIns.rhsOp.variableDcl.type;\n+            addUnboxInsn(this.mv, varRefType, false);\n+\n+            // visit key_expr\n+            this.loadVar(mapLoadIns.keyOp.variableDcl);\n+\n+            if (varRefType.tag == TypeTags.JSON) {\n+                if (mapLoadIns.optionalFieldAccess) {\n+                    this.mv.visitTypeInsn(CHECKCAST, STRING_VALUE);\n+                    this.mv.visitMethodInsn(INVOKESTATIC, JSON_UTILS, \"getElementOrNil\",\n+                            String.format(\"(L%s;L%s;)L%s;\", OBJECT, STRING_VALUE, OBJECT), false);\n+                } else {\n+                    this.mv.visitTypeInsn(CHECKCAST, STRING_VALUE);\n+                    this.mv.visitMethodInsn(INVOKESTATIC, JSON_UTILS, \"getElement\",\n+                            String.format(\"(L%s;L%s;)L%s;\", OBJECT, STRING_VALUE, OBJECT), false);\n+                }\n+            } else {\n+                if (mapLoadIns.fillingRead) {\n+                    this.mv.visitMethodInsn(INVOKEINTERFACE, MAP_VALUE, \"fillAndGet\",\n+                            String.format(\"(L%s;)L%s;\", OBJECT, OBJECT), true);\n+                } else {\n+                    this.mv.visitMethodInsn(INVOKEINTERFACE, MAP_VALUE, \"get\",\n+                            String.format(\"(L%s;)L%s;\", OBJECT, OBJECT), true);\n+                }\n+            }\n+\n+            // store in the target reg\n+            BType targetType = mapLoadIns.lhsOp.variableDcl.type;\n+            addUnboxInsn(this.mv, targetType, false);\n+            this.storeToVar(mapLoadIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateObjectLoadIns(FieldAccess objectLoadIns) {\n+            // visit object_ref\n+            this.loadVar(objectLoadIns.rhsOp.variableDcl);\n+            BType varRefType = objectLoadIns.rhsOp.variableDcl.type;\n+\n+            // visit key_expr\n+            this.loadVar(objectLoadIns.keyOp.variableDcl);\n+\n+            // invoke get() method, and unbox if needed\n+            this.mv.visitMethodInsn(INVOKEINTERFACE, OBJECT_VALUE, \"get\",\n+                    String.format(\"(L%s;)L%s;\", STRING_VALUE, OBJECT), true);\n+            BType targetType = objectLoadIns.lhsOp.variableDcl.type;\n+            addUnboxInsn(this.mv, targetType, false);\n+\n+            // store in the target reg\n+            this.storeToVar(objectLoadIns.lhsOp.variableDcl);\n+        }\n+\n+        void generateObjectStoreIns(FieldAccess objectStoreIns, boolean useBString) {\n+            // visit object_ref\n+            this.loadVar(objectStoreIns.lhsOp.variableDcl);\n+            BType varRefType = objectStoreIns.lhsOp.variableDcl.type;\n+\n+            // visit key_expr\n+            this.loadVar(objectStoreIns.keyOp.variableDcl);\n+\n+            // visit value_expr\n+            BType valueType = objectStoreIns.rhsOp.variableDcl.type;\n+            this.loadVar(objectStoreIns.rhsOp.variableDcl);\n+            addBoxInsn(this.mv, valueType);\n+\n+            // invoke set() method\n+            this.mv.visitMethodInsn(INVOKEINTERFACE, OBJECT_VALUE, \"set\",\n+                    String.format(\"(L%s;L%s;)V\", useBString ? I_STRING_VALUE : STRING_VALUE, OBJECT), true);\n+        }\n+\n+        void generateStringLoadIns(FieldAccess stringLoadIns) {\n+            // visit the string\n+            this.loadVar(stringLoadIns.rhsOp.variableDcl);\n+\n+            // visit the key expr\n+            this.loadVar(stringLoadIns.keyOp.variableDcl);\n+\n+            // invoke the `getStringAt()` method\n+            this.mv.visitMethodInsn(INVOKESTATIC, STRING_UTILS, \"getStringAt\",\n+                    String.format(\"(L%s;J)L%s;\", STRING_VALUE, STRING_VALUE), false);\n+\n+            // store in the target reg\n+            this.storeToVar(stringLoadIns.lhsOp.variableDcl);\n+        }\n+\n+        //    # Generate a new instance of an array value\n+//    #\n+//    # + inst - the new array instruction\n+        void generateArrayNewIns(NewArray inst) {\n+\n+            if (inst.type.tag == TypeTags.ARRAY) {\n+                this.mv.visitTypeInsn(NEW, ARRAY_VALUE_IMPL);\n+                this.mv.visitInsn(DUP);\n+                loadType(this.mv, inst.type);\n+                this.loadVar(inst.sizeOp.variableDcl);\n+                this.mv.visitMethodInsn(INVOKESPECIAL, ARRAY_VALUE_IMPL, \"<init>\",\n+                        String.format(\"(L%s;J)V\", ARRAY_TYPE), false);\n+                this.storeToVar(inst.lhsOp.variableDcl);\n+            } else {\n+                this.mv.visitTypeInsn(NEW, TUPLE_VALUE_IMPL);\n+                this.mv.visitInsn(DUP);\n+                loadType(this.mv, inst.type);\n+                this.loadVar(inst.sizeOp.variableDcl);\n+                this.mv.visitMethodInsn(INVOKESPECIAL, TUPLE_VALUE_IMPL, \"<init>\",\n+                        String.format(\"(L%s;J)V\", TUPLE_TYPE), false);\n+                this.storeToVar(inst.lhsOp.variableDcl);\n+            }\n+        }\n+\n+        //    # Generate adding a new value to an array\n+//    #\n+//    # + inst - array store instruction", "originalCommit": "82df207efdc85acd9646a1aae1461f7d1f7bbc5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ1ODk1Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21435#discussion_r387458957", "bodyText": "We really need switch statements.", "author": "riyafa", "createdAt": "2020-03-04T05:43:40Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmMethodGen.java", "diffHunk": "@@ -0,0 +1,2928 @@\n+/*\n+ *  Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.bir.codegen;\n+\n+import org.ballerinalang.compiler.BLangCompilerException;\n+import org.ballerinalang.model.elements.PackageID;\n+import org.objectweb.asm.ClassWriter;\n+import org.objectweb.asm.FieldVisitor;\n+import org.objectweb.asm.Label;\n+import org.objectweb.asm.MethodVisitor;\n+import org.wso2.ballerinalang.compiler.bir.codegen.JvmErrorGen.ErrorHandlerGenerator;\n+import org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.InstructionGenerator;\n+import org.wso2.ballerinalang.compiler.bir.codegen.JvmLabelGen.LabelGenerator;\n+import org.wso2.ballerinalang.compiler.bir.codegen.JvmTerminatorGen.TerminatorGenerator;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JType;\n+import org.wso2.ballerinalang.compiler.bir.codegen.interop.JTypeTags;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRInstruction;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRAnnotationArrayValue;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRAnnotationAttachment;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRAnnotationLiteralValue;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRAnnotationRecordValue;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRAnnotationValue;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRBasicBlock;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRFunction;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRFunctionParameter;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRPackage;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRTypeDefinition;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRVariableDcl;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.BinaryOp;\n+import org.wso2.ballerinalang.compiler.bir.model.BIROperand;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRTerminator;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRTerminator.AsyncCall;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRTerminator.GOTO;\n+import org.wso2.ballerinalang.compiler.bir.model.InstructionKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarScope;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BInvokableSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BPackageSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BField;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BFutureType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BInvokableType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BNilType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BObjectType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BServiceType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BUnionType;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.TypeTags;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+import org.wso2.ballerinalang.util.Flags;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.objectweb.asm.ClassWriter.COMPUTE_FRAMES;\n+import static org.objectweb.asm.Opcodes.AALOAD;\n+import static org.objectweb.asm.Opcodes.AASTORE;\n+import static org.objectweb.asm.Opcodes.ACC_PUBLIC;\n+import static org.objectweb.asm.Opcodes.ACC_STATIC;\n+import static org.objectweb.asm.Opcodes.ACC_SUPER;\n+import static org.objectweb.asm.Opcodes.ACONST_NULL;\n+import static org.objectweb.asm.Opcodes.ALOAD;\n+import static org.objectweb.asm.Opcodes.ANEWARRAY;\n+import static org.objectweb.asm.Opcodes.ARETURN;\n+import static org.objectweb.asm.Opcodes.ASTORE;\n+import static org.objectweb.asm.Opcodes.ATHROW;\n+import static org.objectweb.asm.Opcodes.BIPUSH;\n+import static org.objectweb.asm.Opcodes.CHECKCAST;\n+import static org.objectweb.asm.Opcodes.DCONST_0;\n+import static org.objectweb.asm.Opcodes.DLOAD;\n+import static org.objectweb.asm.Opcodes.DSTORE;\n+import static org.objectweb.asm.Opcodes.DUP;\n+import static org.objectweb.asm.Opcodes.DUP_X1;\n+import static org.objectweb.asm.Opcodes.FCONST_0;\n+import static org.objectweb.asm.Opcodes.FLOAD;\n+import static org.objectweb.asm.Opcodes.FSTORE;\n+import static org.objectweb.asm.Opcodes.GETFIELD;\n+import static org.objectweb.asm.Opcodes.GETSTATIC;\n+import static org.objectweb.asm.Opcodes.GOTO;\n+import static org.objectweb.asm.Opcodes.IADD;\n+import static org.objectweb.asm.Opcodes.ICONST_0;\n+import static org.objectweb.asm.Opcodes.ICONST_1;\n+import static org.objectweb.asm.Opcodes.IFEQ;\n+import static org.objectweb.asm.Opcodes.IFGT;\n+import static org.objectweb.asm.Opcodes.IFNE;\n+import static org.objectweb.asm.Opcodes.IFNULL;\n+import static org.objectweb.asm.Opcodes.ILOAD;\n+import static org.objectweb.asm.Opcodes.INVOKEINTERFACE;\n+import static org.objectweb.asm.Opcodes.INVOKESPECIAL;\n+import static org.objectweb.asm.Opcodes.INVOKESTATIC;\n+import static org.objectweb.asm.Opcodes.INVOKEVIRTUAL;\n+import static org.objectweb.asm.Opcodes.ISTORE;\n+import static org.objectweb.asm.Opcodes.ISUB;\n+import static org.objectweb.asm.Opcodes.L2I;\n+import static org.objectweb.asm.Opcodes.LCONST_0;\n+import static org.objectweb.asm.Opcodes.LLOAD;\n+import static org.objectweb.asm.Opcodes.LSTORE;\n+import static org.objectweb.asm.Opcodes.NEW;\n+import static org.objectweb.asm.Opcodes.POP;\n+import static org.objectweb.asm.Opcodes.PUTFIELD;\n+import static org.objectweb.asm.Opcodes.RETURN;\n+import static org.objectweb.asm.Opcodes.SIPUSH;\n+import static org.objectweb.asm.Opcodes.V1_8;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ANNOTATION_MAP_NAME;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ANNOTATION_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ARGUMENT_PARSER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ARRAY_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BALLERINA;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BAL_ERRORS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BAL_EXTENSION;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BOOLEAN_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BTYPE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.BUILT_IN_PACKAGE_NAME;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.CHANNEL_DETAILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.COMPATIBILITY_CHECKER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.CURRENT_MODULE_INIT;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DECIMAL_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DEFAULTABLE_ARGS_ANOT_FIELD;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DEFAULTABLE_ARGS_ANOT_NAME;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.DOUBLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.ERROR_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUNCTION;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUNCTION_POINTER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.FUTURE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.HANDLE_RETURNED_ERROR_METHOD;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.HANDLE_STOP_PANIC_METHOD;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.HANDLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.INT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.JAVA_PACKAGE_SEPERATOR;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.JAVA_RUNTIME;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.JAVA_THREAD;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.LAUNCH_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.LONG_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MAP_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MODULE_INIT;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MODULE_INIT_CLASS_NAME;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MODULE_START;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.MODULE_STOP;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.OBJECT_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.PANIC_FIELD;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.RUNTIME_UTILS;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.SCHEDULER;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.SCHEDULER_START_METHOD;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.SCHEDULE_FUNCTION_METHOD;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRAND;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STREAM_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TABLE_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.THROWABLE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.TYPEDESC_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.VALUE_CREATOR;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.WINDOWS_PATH_SEPERATOR;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmConstants.XML_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.BSTRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.IS_BSTRING;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.I_STRING_VALUE;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.InstructionGenerator.visitInvokeDyn;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.addBoxInsn;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmInstructionGen.addUnboxInsn;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmObservabilityGen.emitReportErrorInvocation;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmObservabilityGen.emitStartObservationInvocation;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmObservabilityGen.emitStopObservationInvocation;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmObservabilityGen.getFullQualifiedRemoteFunctionName;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.JavaClass;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.birFunctionMap;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.currentClass;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.getFunctionWrapper;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.getModuleLevelClassName;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.getPackageName;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.lookupGlobalVarClassName;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.packageToModuleId;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmPackageGen.symbolTable;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTerminatorGen.TerminatorGenerator.toNameString;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTerminatorGen.cleanupObjectTypeName;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTerminatorGen.isExternStaticFunctionCall;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTerminatorGen.loadChannelDetails;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen.loadExternalOrLocalType;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen.loadType;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.JvmTypeGen.typeOwnerClass;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.interop.ExternalMethodGen.genJMethodForBExternalFunc;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.interop.ExternalMethodGen.isBallerinaBuiltinModule;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.interop.InteropMethodGen.JInstruction;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.interop.InteropMethodGen.getJTypeSignature;\n+import static org.wso2.ballerinalang.compiler.bir.codegen.interop.InteropMethodGen.getSignatureForJType;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.ConstantLoad;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.FPLoad;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.FieldAccess;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.IsLike;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.Move;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewArray;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewError;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewInstance;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewStringXMLQName;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewStructure;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewTable;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewTypeDesc;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLComment;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLElement;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLProcIns;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLQName;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLText;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.TypeCast;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.TypeTest;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.UnaryOP;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.XMLAccess;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRTerminator.Branch;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRTerminator.Call;\n+import static org.wso2.ballerinalang.compiler.bir.model.BIRTerminator.Return;\n+\n+/**\n+ * BIR function to JVM byte code generation class.\n+ *\n+ * @since 1.2.0\n+ */\n+public class JvmMethodGen {\n+\n+    private static List<String> generatedInitFuncs = new ArrayList<>();\n+    public static int nextId = -1;\n+    public static int nextVarId = -1;\n+\n+    private static final FunctionParamComparator FUNCTION_PARAM_COMPARATOR = new FunctionParamComparator();\n+    static BUnionType errorOrNilType;\n+\n+    static void generateMethod(BIRFunction birFunc,\n+                               ClassWriter cw,\n+                               BIRPackage birModule,\n+                               @Nilable BType attachedType /* = () */,\n+                               boolean isService /* = false */,\n+                               String serviceName /* = \"\" */) {\n+\n+        if (isExternFunc(birFunc)) {\n+            genJMethodForBExternalFunc(birFunc, cw, birModule, attachedType);\n+        } else {\n+            genJMethodForBFunc(birFunc, cw, birModule, isService, serviceName, attachedType);\n+        }\n+    }\n+\n+    public static void genJMethodForBFunc(BIRFunction func,\n+                                          ClassWriter cw,\n+                                          BIRPackage module,\n+                                          boolean isService,\n+                                          String serviceName,\n+                                          @Nilable BType attachedType /* = () */) {\n+\n+        String currentPackageName = getPackageName(module.org.value, module.name.value);\n+        BalToJVMIndexMap indexMap = new BalToJVMIndexMap();\n+        String funcName = cleanupFunctionName(func.name.value);\n+        boolean useBString = IS_BSTRING;\n+        int returnVarRefIndex = -1;\n+\n+        BIRVariableDcl strandVar = new BIRVariableDcl(symbolTable.stringType, new Name(\"strand\"),\n+                VarScope.FUNCTION, VarKind.ARG);\n+        int ignoreStrandVarIndex = indexMap.getIndex(strandVar);\n+\n+        // generate method desc\n+        String desc = getMethodDesc(func.type.paramTypes, func.type.retType, null, false, useBString);\n+        int access = ACC_PUBLIC;\n+        int localVarOffset;\n+        if (attachedType != null) {\n+            localVarOffset = 1;\n+\n+            // add the self as the first local var\n+            // TODO: find a better way\n+            BIRVariableDcl selfVar = new BIRVariableDcl(symbolTable.anyType, new Name(\"self\"),\n+                    VarScope.FUNCTION, VarKind.ARG);\n+            int ignoreSelfVarIndex = indexMap.getIndex(selfVar);\n+        } else {\n+            localVarOffset = 0;\n+            access += ACC_STATIC;\n+        }\n+\n+        MethodVisitor mv = cw.visitMethod(access, funcName, desc, null, null);\n+        InstructionGenerator instGen = new InstructionGenerator(mv, indexMap, module);\n+        ErrorHandlerGenerator errorGen = new ErrorHandlerGenerator(mv, indexMap, currentPackageName);\n+        LabelGenerator labelGen = new LabelGenerator();\n+\n+        mv.visitCode();\n+\n+        @Nilable Label tryStart = null;\n+        boolean isObserved = false;\n+        boolean isWorker = (func.flags & Flags.WORKER) == Flags.WORKER;\n+        boolean isRemote = (func.flags & Flags.REMOTE) == Flags.REMOTE;\n+        if ((isService || isRemote || isWorker) && !\"__init\".equals(funcName) && !\"$__init$\".equals(funcName)) {\n+            // create try catch block to start and stop observability.\n+            isObserved = true;\n+            tryStart = labelGen.getLabel(\"try-start\");\n+            mv.visitLabel(tryStart);\n+        }\n+\n+        Label methodStartLabel = new Label();\n+        mv.visitLabel(methodStartLabel);\n+\n+        // generate method body\n+        int k = 1;\n+\n+        // set channel details to strand.\n+        // these channel info is required to notify datachannels, when there is a panic\n+        // we cannot set this during strand creation, because function call do not have this info.\n+        if (func.workerChannels.length > 0) {\n+            mv.visitVarInsn(ALOAD, localVarOffset);\n+            loadChannelDetails(mv, Arrays.asList(func.workerChannels));\n+            mv.visitMethodInsn(INVOKEVIRTUAL, STRAND, \"updateChannelDetails\",\n+                    String.format(\"([L%s;)V\", CHANNEL_DETAILS), false);\n+        }\n+\n+        // panic if this strand is cancelled\n+        checkStrandCancelled(mv, localVarOffset);\n+\n+        func.localVars.sort(FUNCTION_PARAM_COMPARATOR);\n+\n+        @Nilable List<BIRVariableDcl> localVars = func.localVars;\n+        while (k < localVars.size()) {\n+            BIRVariableDcl localVar = getVariableDcl(localVars.get(k));\n+            int index = indexMap.getIndex(localVar);\n+            if (localVar.kind != VarKind.ARG) {\n+                BType bType = localVar.type;\n+                genDefaultValue(mv, bType, index);\n+            }\n+            k += 1;\n+        }\n+\n+        BIRVariableDcl varDcl = getVariableDcl(localVars.get(0));\n+        returnVarRefIndex = indexMap.getIndex(varDcl);\n+        BType returnType = func.type.retType;\n+        genDefaultValue(mv, returnType, returnVarRefIndex);\n+\n+        BIRVariableDcl stateVar = new BIRVariableDcl(symbolTable.stringType, //should  be javaInt\n+                new Name(\"state\"), null, VarKind.TEMP);\n+        int stateVarIndex = indexMap.getIndex(stateVar);\n+        mv.visitInsn(ICONST_0);\n+        mv.visitVarInsn(ISTORE, stateVarIndex);\n+\n+        mv.visitVarInsn(ALOAD, localVarOffset);\n+        mv.visitFieldInsn(GETFIELD, \"org/ballerinalang/jvm/scheduling/Strand\", \"resumeIndex\", \"I\");\n+        Label resumeLable = labelGen.getLabel(funcName + \"resume\");\n+        mv.visitJumpInsn(IFGT, resumeLable);\n+\n+        Label varinitLable = labelGen.getLabel(funcName + \"varinit\");\n+        mv.visitLabel(varinitLable);\n+\n+        // uncomment to test yield\n+        // mv.visitFieldInsn(GETSTATIC, className, \"i\", \"I\");\n+        // mv.visitInsn(ICONST_1);\n+        // mv.visitInsn(IADD);\n+        // mv.visitFieldInsn(PUTSTATIC, className, \"i\", \"I\");\n+\n+        // process basic blocks\n+        @Nilable List<BIRBasicBlock> basicBlocks = func.basicBlocks;\n+\n+        List<Label> lables = new ArrayList<>();\n+        List<Integer> states = new ArrayList<>();\n+\n+        int i = 0;\n+        int caseIndex = 0;\n+        while (i < basicBlocks.size()) {\n+            BIRBasicBlock bb = getBasicBlock(basicBlocks.get(i));\n+            if (i == 0) {\n+                lables.add(caseIndex, labelGen.getLabel(funcName + bb.id.value));\n+                states.add(caseIndex, caseIndex);\n+                caseIndex += 1;\n+            }\n+            lables.add(caseIndex, labelGen.getLabel(funcName + bb.id.value + \"beforeTerm\"));\n+            states.add(caseIndex, caseIndex);\n+            caseIndex += 1;\n+            i = i + 1;\n+        }\n+\n+        TerminatorGenerator termGen = new TerminatorGenerator(mv, indexMap, labelGen, errorGen, module);\n+\n+        // uncomment to test yield\n+        // mv.visitFieldInsn(GETSTATIC, className, \"i\", \"I\");\n+        // mv.visitIntInsn(BIPUSH, 100);\n+        // jvm:Label l0 = labelGen.getLabel(funcName + \"l0\");\n+        // mv.visitJumpInsn(IF_ICMPNE, l0);\n+        // mv.visitVarInsn(ALOAD, 0);\n+        // mv.visitInsn(ICONST_1);\n+        // mv.visitFieldInsn(PUTFIELD, \"org/ballerinalang/jvm/scheduling/Strand\", \"yield\", \"Z\");\n+        // termGen.genReturnTerm({kind:\"RETURN\"}, returnVarRefIndex, func);\n+        // mv.visitLabel(l0);\n+\n+        mv.visitVarInsn(ILOAD, stateVarIndex);\n+        Label yieldLable = labelGen.getLabel(funcName + \"yield\");\n+        mv.visitLookupSwitchInsn(yieldLable, toIntArray(states), lables.toArray(new Label[0]));\n+\n+        generateBasicBlocks(mv, basicBlocks, labelGen, errorGen, instGen, termGen, func, returnVarRefIndex,\n+                stateVarIndex, localVarOffset, false, module, currentPackageName, attachedType, isObserved, isService,\n+                serviceName, useBString);\n+\n+        String frameName = getFrameClassName(currentPackageName, funcName, attachedType);\n+        mv.visitLabel(resumeLable);\n+        mv.visitVarInsn(ALOAD, localVarOffset);\n+        mv.visitFieldInsn(GETFIELD, \"org/ballerinalang/jvm/scheduling/Strand\", \"frames\", \"[Ljava/lang/Object;\");\n+        mv.visitVarInsn(ALOAD, localVarOffset);\n+        mv.visitInsn(DUP);\n+        mv.visitFieldInsn(GETFIELD, \"org/ballerinalang/jvm/scheduling/Strand\", \"resumeIndex\", \"I\");\n+        mv.visitInsn(ICONST_1);\n+        mv.visitInsn(ISUB);\n+        mv.visitInsn(DUP_X1);\n+        mv.visitFieldInsn(PUTFIELD, \"org/ballerinalang/jvm/scheduling/Strand\", \"resumeIndex\", \"I\");\n+        mv.visitInsn(AALOAD);\n+        mv.visitTypeInsn(CHECKCAST, frameName);\n+\n+        generateFrameClassFieldLoad(localVars, mv, indexMap, frameName, useBString);\n+        mv.visitFieldInsn(GETFIELD, frameName, \"state\", \"I\");\n+        mv.visitVarInsn(ISTORE, stateVarIndex);\n+        mv.visitJumpInsn(GOTO, varinitLable);\n+\n+        mv.visitLabel(yieldLable);\n+        mv.visitTypeInsn(NEW, frameName);\n+        mv.visitInsn(DUP);\n+        mv.visitMethodInsn(INVOKESPECIAL, frameName, \"<init>\", \"()V\", false);\n+\n+        generateFrameClassFieldUpdate(localVars, mv, indexMap, frameName, useBString);\n+\n+        mv.visitInsn(DUP);\n+        mv.visitVarInsn(ILOAD, stateVarIndex);\n+        mv.visitFieldInsn(PUTFIELD, frameName, \"state\", \"I\");\n+\n+        BIRVariableDcl frameVar = new BIRVariableDcl(symbolTable.stringType, new Name(\"frame\"), null, VarKind.TEMP);\n+        int frameVarIndex = indexMap.getIndex(frameVar);\n+        mv.visitVarInsn(ASTORE, frameVarIndex);\n+\n+        mv.visitVarInsn(ALOAD, localVarOffset);\n+        mv.visitFieldInsn(GETFIELD, \"org/ballerinalang/jvm/scheduling/Strand\", \"frames\", \"[Ljava/lang/Object;\");\n+        mv.visitVarInsn(ALOAD, localVarOffset);\n+        mv.visitInsn(DUP);\n+        mv.visitFieldInsn(GETFIELD, \"org/ballerinalang/jvm/scheduling/Strand\", \"resumeIndex\", \"I\");\n+        mv.visitInsn(DUP_X1);\n+        mv.visitInsn(ICONST_1);\n+        mv.visitInsn(IADD);\n+        mv.visitFieldInsn(PUTFIELD, \"org/ballerinalang/jvm/scheduling/Strand\", \"resumeIndex\", \"I\");\n+        mv.visitVarInsn(ALOAD, frameVarIndex);\n+        mv.visitInsn(AASTORE);\n+\n+        Label methodEndLabel = new Label();\n+        // generate the try catch finally to stop observing if an error occurs.\n+        if (isObserved) {\n+            Label tryEnd = labelGen.getLabel(\"try-end\");\n+            Label tryCatch = labelGen.getLabel(\"try-handler\");\n+            // visitTryCatchBlock visited at the end since order of the error table matters.\n+            mv.visitTryCatchBlock((Label) tryStart, tryEnd, tryCatch, ERROR_VALUE);\n+            Label tryFinally = labelGen.getLabel(\"try-finally\");\n+            mv.visitTryCatchBlock((Label) tryStart, tryEnd, tryFinally, null);\n+            Label tryCatchFinally = labelGen.getLabel(\"try-catch-finally\");\n+            mv.visitTryCatchBlock(tryCatch, tryCatchFinally, tryFinally, null);\n+\n+            BIRVariableDcl catchVarDcl = new BIRVariableDcl(symbolTable.anyType, new Name(\"$_catch_$\"),\n+                    VarScope.FUNCTION, VarKind.ARG);\n+            int catchVarIndex = indexMap.getIndex(catchVarDcl);\n+            BIRVariableDcl throwableVarDcl = new BIRVariableDcl(symbolTable.anyType, new Name(\"$_throwable_$\"),\n+                    VarScope.FUNCTION, VarKind.ARG);\n+            int throwableVarIndex = indexMap.getIndex(throwableVarDcl);\n+\n+            // Try-To-Finally\n+            mv.visitLabel(tryEnd);\n+            // emitStopObservationInvocation(mv, localVarOffset);\n+            Label tryBlock1 = labelGen.getLabel(\"try-block-1\");\n+            mv.visitLabel(tryBlock1);\n+            mv.visitJumpInsn(GOTO, methodEndLabel);\n+\n+            // Catch Block\n+            mv.visitLabel(tryCatch);\n+            mv.visitVarInsn(ASTORE, catchVarIndex);\n+            Label tryBlock2 = labelGen.getLabel(\"try-block-2\");\n+            mv.visitLabel(tryBlock2);\n+            emitReportErrorInvocation(mv, localVarOffset, catchVarIndex);\n+            mv.visitLabel(tryCatchFinally);\n+            emitStopObservationInvocation(mv, localVarOffset);\n+            Label tryBlock3 = labelGen.getLabel(\"try-block-3\");\n+            mv.visitLabel(tryBlock3);\n+            // re-throw caught error value\n+            mv.visitVarInsn(ALOAD, catchVarIndex);\n+            mv.visitInsn(ATHROW);\n+\n+            // Finally Block\n+            mv.visitLabel(tryFinally);\n+            mv.visitVarInsn(ASTORE, throwableVarIndex);\n+            emitStopObservationInvocation(mv, localVarOffset);\n+            Label tryBlock4 = labelGen.getLabel(\"try-block-4\");\n+            mv.visitLabel(tryBlock4);\n+            mv.visitVarInsn(ALOAD, throwableVarIndex);\n+            mv.visitInsn(ATHROW);\n+        }\n+        mv.visitLabel(methodEndLabel);\n+        termGen.genReturnTerm(new Return(null), returnVarRefIndex, func, false, -1);\n+\n+        // Create Local Variable Table\n+        k = localVarOffset;\n+        // Add strand variable to LVT\n+        mv.visitLocalVariable(\"__strand\", String.format(\"L%s;\", STRAND), null, methodStartLabel, methodEndLabel,\n+                localVarOffset);\n+        while (k < localVars.size()) {\n+            BIRVariableDcl localVar = getVariableDcl(localVars.get(k));\n+            Label startLabel = methodStartLabel;\n+            Label endLabel = methodEndLabel;\n+            boolean tmpBoolParam = localVar.type.tag == TypeTags.BOOLEAN && localVar.name.value.startsWith(\"%syn\");\n+            if (!tmpBoolParam && (localVar.kind == VarKind.LOCAL || localVar.kind == VarKind.ARG)) {\n+                // local vars have visible range information\n+                if (localVar.kind == VarKind.LOCAL) {\n+//                    String startBBID = localVar.startBB.id.value;\n+//                    String endBBID = localVar.endBB.id.value;\n+                    int insOffset = localVar.insOffset;\n+                    if (localVar.startBB != null) {\n+                        startLabel = labelGen.getLabel(funcName + localVar.startBB.id.value + \"ins\" + insOffset);\n+                    }\n+                    if (localVar.endBB != null) {\n+                        endLabel = labelGen.getLabel(funcName + localVar.endBB.id.value + \"beforeTerm\");\n+                    }\n+                }\n+                String metaVarName = localVar.name.value;\n+                if (!\"\".equals(metaVarName) &&\n+                        // filter out compiler added vars\n+                        !((metaVarName.startsWith(\"$\") && metaVarName.endsWith(\"$\"))\n+                                || (metaVarName.startsWith(\"$$\") && metaVarName.endsWith(\"$$\"))\n+                                || metaVarName.startsWith(\"_$$_\"))) {\n+                    mv.visitLocalVariable(metaVarName, getJVMTypeSign(localVar.type), null,\n+                            startLabel, endLabel, indexMap.getIndex(localVar));\n+                }\n+            }\n+            k = k + 1;\n+        }\n+\n+        mv.visitMaxs(0, 0);\n+        mv.visitEnd();\n+    }\n+\n+    private static int[] toIntArray(List<Integer> states) {\n+\n+        int[] ints = new int[states.size()];\n+        for (int i = 0; i < states.size(); i++) {\n+            ints[i] = states.get(i);\n+        }\n+        return ints;\n+    }\n+\n+    private static void generateFrameClassFieldLoad(List<BIRVariableDcl> localVars, MethodVisitor mv,\n+                                                    BalToJVMIndexMap indexMap, String frameName, boolean useBString) {\n+\n+        int k = 0;\n+        while (k < localVars.size()) {\n+            BIRVariableDcl localVar = getVariableDcl(localVars.get(k));\n+            int index = indexMap.getIndex(localVar);\n+            BType bType = localVar.type;\n+            mv.visitInsn(DUP);\n+\n+            if (bType.tag == TypeTags.INT) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"J\");\n+                mv.visitVarInsn(LSTORE, index);\n+            } else if (bType.tag == TypeTags.BYTE) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"I\");\n+                mv.visitVarInsn(ISTORE, index);\n+            } else if (bType.tag == TypeTags.FLOAT) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"D\");\n+                mv.visitVarInsn(DSTORE, index);\n+            } else if (bType.tag == TypeTags.STRING) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", useBString ? I_STRING_VALUE : STRING_VALUE));\n+                mv.visitVarInsn(ASTORE, index);\n+            } else if (bType.tag == TypeTags.DECIMAL) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", DECIMAL_VALUE));\n+                mv.visitVarInsn(ASTORE, index);\n+            } else if (bType.tag == TypeTags.BOOLEAN) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"Z\");\n+                mv.visitVarInsn(ISTORE, index);\n+            } else if (bType.tag == TypeTags.MAP || bType.tag == TypeTags.RECORD) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", MAP_VALUE));\n+                mv.visitVarInsn(ASTORE, index);\n+            } else if (bType.tag == TypeTags.TABLE) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", TABLE_VALUE));\n+                mv.visitVarInsn(ASTORE, index);\n+            } else if (bType.tag == TypeTags.STREAM) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", STREAM_VALUE));\n+                mv.visitVarInsn(ASTORE, index);\n+            } else if (bType.tag == TypeTags.ARRAY ||\n+                    bType.tag == TypeTags.TUPLE) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", ARRAY_VALUE));\n+                mv.visitVarInsn(ASTORE, index);\n+            } else if (bType.tag == TypeTags.OBJECT || bType.tag == TypeTags.SERVICE) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", OBJECT_VALUE));\n+                mv.visitVarInsn(ASTORE, index);\n+            } else if (bType.tag == TypeTags.ERROR) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", ERROR_VALUE));\n+                mv.visitVarInsn(ASTORE, index);\n+            } else if (bType.tag == TypeTags.FUTURE) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", FUTURE_VALUE));\n+                mv.visitVarInsn(ASTORE, index);\n+            } else if (bType.tag == TypeTags.INVOKABLE) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", FUNCTION_POINTER));\n+                mv.visitVarInsn(ASTORE, index);\n+            } else if (bType.tag == TypeTags.TYPEDESC) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", TYPEDESC_VALUE));\n+                mv.visitVarInsn(ASTORE, index);\n+            } else if (bType.tag == TypeTags.NIL ||\n+                    bType.tag == TypeTags.ANY ||\n+                    bType.tag == TypeTags.ANYDATA ||\n+                    bType.tag == TypeTags.UNION ||\n+                    bType.tag == TypeTags.JSON ||\n+                    bType.tag == TypeTags.FINITE) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", OBJECT));\n+                mv.visitVarInsn(ASTORE, index);\n+            } else if (bType.tag == TypeTags.XML) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", XML_VALUE));\n+                mv.visitVarInsn(ASTORE, index);\n+            } else if (bType.tag == TypeTags.HANDLE) {\n+                mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", HANDLE_VALUE));\n+                mv.visitVarInsn(ASTORE, index);\n+            } else if (bType.tag == JTypeTags.JTYPE) {\n+                generateFrameClassJFieldLoad(localVar, mv, index, frameName);\n+            } else {\n+                throw new BLangCompilerException(\"JVM generation is not supported for type \" +\n+                        String.format(\"%s\", bType));\n+            }\n+            k = k + 1;\n+        }\n+\n+    }\n+\n+    private static void generateFrameClassJFieldLoad(BIRVariableDcl localVar, MethodVisitor mv,\n+                                                     int index, String frameName) {\n+\n+        JType jType = (JType) localVar.type;\n+\n+        if (jType.jTag == JTypeTags.JBYTE) {\n+            mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"I\");\n+            mv.visitVarInsn(ISTORE, index);\n+        } else if (jType.jTag == JTypeTags.JCHAR) {\n+            mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"I\");\n+            mv.visitVarInsn(ISTORE, index);\n+        } else if (jType.jTag == JTypeTags.JSHORT) {\n+            mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"I\");\n+            mv.visitVarInsn(ISTORE, index);\n+        } else if (jType.jTag == JTypeTags.JINT) {\n+            mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"I\");\n+            mv.visitVarInsn(ISTORE, index);\n+        } else if (jType.jTag == JTypeTags.JLONG) {\n+            mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"J\");\n+            mv.visitVarInsn(LSTORE, index);\n+        } else if (jType.jTag == JTypeTags.JFLOAT) {\n+            mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"F\");\n+            mv.visitVarInsn(FSTORE, index);\n+        } else if (jType.jTag == JTypeTags.JDOUBLE) {\n+            mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"D\");\n+            mv.visitVarInsn(DSTORE, index);\n+        } else if (jType.jTag == JTypeTags.JBOOLEAN) {\n+            mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"Z\");\n+            mv.visitVarInsn(ISTORE, index);\n+        } else if (jType.jTag == JTypeTags.JARRAY ||\n+                jType.jTag == JTypeTags.JREF) {\n+            mv.visitFieldInsn(GETFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), getJTypeSignature(jType));\n+            mv.visitVarInsn(ASTORE, index);\n+        } else {\n+            throw new BLangCompilerException(\"JVM generation is not supported for type \" + String.format(\"%s\", jType));\n+        }\n+\n+    }\n+\n+    private static void generateFrameClassFieldUpdate(@Nilable List<BIRVariableDcl> localVars, MethodVisitor mv,\n+                                                      BalToJVMIndexMap indexMap, String frameName, boolean useBString) {\n+\n+        int k = 0;\n+        while (k < localVars.size()) {\n+            BIRVariableDcl localVar = getVariableDcl(localVars.get(k));\n+            int index = indexMap.getIndex(localVar);\n+            mv.visitInsn(DUP);\n+\n+            BType bType = localVar.type;\n+            if (bType.tag == TypeTags.INT) {\n+                mv.visitVarInsn(LLOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"J\");\n+            } else if (bType.tag == TypeTags.BYTE) {\n+                mv.visitVarInsn(ILOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"I\");\n+            } else if (bType.tag == TypeTags.FLOAT) {\n+                mv.visitVarInsn(DLOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"D\");\n+            } else if (bType.tag == TypeTags.STRING) {\n+                mv.visitVarInsn(ALOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", useBString ? I_STRING_VALUE : STRING_VALUE));\n+            } else if (bType.tag == TypeTags.DECIMAL) {\n+                mv.visitVarInsn(ALOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", DECIMAL_VALUE));\n+            } else if (bType.tag == TypeTags.BOOLEAN) {\n+                mv.visitVarInsn(ILOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"Z\");\n+            } else if (bType.tag == TypeTags.MAP ||\n+                    bType.tag == TypeTags.RECORD) {\n+                mv.visitVarInsn(ALOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", MAP_VALUE));\n+            } else if (bType.tag == TypeTags.TABLE) {\n+                mv.visitVarInsn(ALOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", TABLE_VALUE));\n+            } else if (bType.tag == TypeTags.STREAM) {\n+                mv.visitVarInsn(ALOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", STREAM_VALUE));\n+            } else if (bType.tag == TypeTags.ARRAY ||\n+                    bType.tag == TypeTags.TUPLE) {\n+                mv.visitVarInsn(ALOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", ARRAY_VALUE));\n+            } else if (bType.tag == TypeTags.ERROR) {\n+                mv.visitVarInsn(ALOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", ERROR_VALUE));\n+            } else if (bType.tag == TypeTags.FUTURE) {\n+                mv.visitVarInsn(ALOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", FUTURE_VALUE));\n+            } else if (bType.tag == TypeTags.TYPEDESC) {\n+                mv.visitVarInsn(ALOAD, index);\n+                mv.visitTypeInsn(CHECKCAST, TYPEDESC_VALUE);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", TYPEDESC_VALUE));\n+            } else if (bType.tag == TypeTags.OBJECT || bType.tag == TypeTags.SERVICE) {\n+                mv.visitVarInsn(ALOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", OBJECT_VALUE));\n+            } else if (bType.tag == TypeTags.INVOKABLE) {\n+                mv.visitVarInsn(ALOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", FUNCTION_POINTER));\n+            } else if (bType.tag == TypeTags.NIL ||\n+                    bType.tag == TypeTags.ANY ||\n+                    bType.tag == TypeTags.ANYDATA ||\n+                    bType.tag == TypeTags.UNION ||\n+                    bType.tag == TypeTags.JSON ||\n+                    bType.tag == TypeTags.FINITE) {\n+                mv.visitVarInsn(ALOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", OBJECT));\n+            } else if (bType.tag == TypeTags.XML) {\n+                mv.visitVarInsn(ALOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", XML_VALUE));\n+            } else if (bType.tag == TypeTags.HANDLE) {\n+                mv.visitVarInsn(ALOAD, index);\n+                mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"),\n+                        String.format(\"L%s;\", HANDLE_VALUE));\n+            } else if (bType.tag == JTypeTags.JTYPE) {\n+                generateFrameClassJFieldUpdate(localVar, mv, index, frameName);\n+            } else {\n+                throw new BLangCompilerException(\"JVM generation is not supported for type \" +\n+                        String.format(\"%s\", bType));\n+            }\n+            k = k + 1;\n+        }\n+    }\n+\n+    private static void generateFrameClassJFieldUpdate(BIRVariableDcl localVar, MethodVisitor mv,\n+                                                       int index, String frameName) {\n+\n+        JType jType = (JType) localVar.type;\n+        if (jType.jTag == JTypeTags.JBYTE) {\n+            mv.visitVarInsn(ILOAD, index);\n+            mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"B\");\n+        } else if (jType.jTag == JTypeTags.JCHAR) {\n+            mv.visitVarInsn(ILOAD, index);\n+            mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"C\");\n+        } else if (jType.jTag == JTypeTags.JSHORT) {\n+            mv.visitVarInsn(ILOAD, index);\n+            mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"S\");\n+        } else if (jType.jTag == JTypeTags.JINT) {\n+            mv.visitVarInsn(ILOAD, index);\n+            mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"I\");\n+        } else if (jType.jTag == JTypeTags.JLONG) {\n+            mv.visitVarInsn(LLOAD, index);\n+            mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"J\");\n+        } else if (jType.jTag == JTypeTags.JFLOAT) {\n+            mv.visitVarInsn(FLOAD, index);\n+            mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"F\");\n+        } else if (jType.jTag == JTypeTags.JDOUBLE) {\n+            mv.visitVarInsn(DLOAD, index);\n+            mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"D\");\n+        } else if (jType.jTag == JTypeTags.JBOOLEAN) {\n+            mv.visitVarInsn(ILOAD, index);\n+            mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), \"Z\");\n+        } else if (jType.jTag == JTypeTags.JARRAY || jType.jTag == JTypeTags.JREF) {\n+            String classSig = getJTypeSignature(jType);\n+            String className = getSignatureForJType(jType);\n+            mv.visitVarInsn(ALOAD, index);\n+            mv.visitTypeInsn(CHECKCAST, className);\n+            mv.visitFieldInsn(PUTFIELD, frameName, localVar.name.value.replace(\"%\", \"_\"), classSig);\n+        } else {\n+            throw new BLangCompilerException(\"JVM generation is not supported for type \" + String.format(\"%s\", jType));\n+        }\n+    }\n+\n+    private static String getJVMTypeSign(BType bType) {\n+\n+        String jvmType = \"\";\n+        if (bType.tag == TypeTags.INT) {\n+            jvmType = \"J\";\n+        } else if (bType.tag == TypeTags.BYTE) {\n+            jvmType = \"I\";\n+        } else if (bType.tag == TypeTags.FLOAT) {\n+            jvmType = \"D\";\n+        } else if (bType.tag == TypeTags.BOOLEAN) {\n+            jvmType = \"Z\";\n+        } else if (bType.tag == TypeTags.STRING) {\n+            jvmType = String.format(\"L%s;\", STRING_VALUE);\n+        } else if (bType.tag == TypeTags.DECIMAL) {\n+            jvmType = String.format(\"L%s;\", DECIMAL_VALUE);\n+        } else if (bType.tag == TypeTags.MAP || bType.tag == TypeTags.RECORD) {\n+            jvmType = String.format(\"L%s;\", MAP_VALUE);\n+        } else if (bType.tag == TypeTags.TABLE) {\n+            jvmType = String.format(\"L%s;\", TABLE_VALUE);\n+        } else if (bType.tag == TypeTags.STREAM) {\n+            jvmType = String.format(\"L%s;\", STREAM_VALUE);\n+        } else if (bType.tag == TypeTags.ARRAY ||\n+                bType.tag == TypeTags.TUPLE) {\n+            jvmType = String.format(\"L%s;\", ARRAY_VALUE);\n+        } else if (bType.tag == TypeTags.OBJECT || bType.tag == TypeTags.SERVICE) {\n+            jvmType = String.format(\"L%s;\", OBJECT_VALUE);\n+        } else if (bType.tag == TypeTags.ERROR) {\n+            jvmType = String.format(\"L%s;\", ERROR_VALUE);\n+        } else if (bType.tag == TypeTags.FUTURE) {\n+            jvmType = String.format(\"L%s;\", FUTURE_VALUE);\n+        } else if (bType.tag == TypeTags.INVOKABLE) {\n+            jvmType = String.format(\"L%s;\", FUNCTION_POINTER);\n+        } else if (bType.tag == TypeTags.HANDLE) {\n+            jvmType = String.format(\"L%s;\", HANDLE_VALUE);\n+        } else if (bType.tag == TypeTags.TYPEDESC) {\n+            jvmType = String.format(\"L%s;\", TYPEDESC_VALUE);\n+        } else if (bType.tag == TypeTags.NIL\n+                || bType.tag == TypeTags.ANY\n+                || bType.tag == TypeTags.ANYDATA\n+                || bType.tag == TypeTags.UNION\n+                || bType.tag == TypeTags.JSON\n+                || bType.tag == TypeTags.FINITE) {\n+            jvmType = String.format(\"L%s;\", OBJECT);\n+        } else if (bType.tag == JTypeTags.JTYPE) {\n+            jvmType = getJTypeSignature((JType) bType);\n+        } else if (bType.tag == TypeTags.XML) {\n+            jvmType = String.format(\"L%s;\", XML_VALUE);\n+        } else {\n+            throw new BLangCompilerException(\"JVM code generation is not supported for type \" +\n+                    String.format(\"%s\", bType));\n+        }\n+        return jvmType;\n+    }\n+\n+    public static void generateBasicBlocks(MethodVisitor mv, @Nilable List<BIRBasicBlock> basicBlocks,\n+                                           LabelGenerator labelGen, ErrorHandlerGenerator errorGen,\n+                                           InstructionGenerator instGen, TerminatorGenerator termGen,\n+                                           BIRFunction func, int returnVarRefIndex, int stateVarIndex,\n+                                           int localVarOffset, boolean isArg, BIRPackage module,\n+                                           String currentPackageName, @Nilable BType attachedType,\n+                                           boolean isObserved /* = false */,\n+                                           boolean isService /* = false */, String serviceName /* = \"\" */,\n+                                           boolean useBString /* = false */) {\n+\n+        int j = 0;\n+        String funcName = cleanupFunctionName(func.name.value);\n+\n+        int caseIndex = 0;\n+\n+        while (j < basicBlocks.size()) {\n+            BIRBasicBlock bb = getBasicBlock(basicBlocks.get(j));\n+            String currentBBName = String.format(\"%s\", bb.id.value);\n+\n+            // create jvm label\n+            Label bbLabel = labelGen.getLabel(funcName + bb.id.value);\n+            mv.visitLabel(bbLabel);\n+            if (j == 0 && !isArg) {\n+                // SIPUSH range is (-32768 to 32767) so if the state index goes beyond that, need to use visitLdcInsn\n+                mv.visitIntInsn(SIPUSH, caseIndex);\n+                mv.visitVarInsn(ISTORE, stateVarIndex);\n+                caseIndex += 1;\n+            }\n+\n+            String serviceOrConnectorName = serviceName;\n+            if (isObserved && j == 0) {\n+                String observationStartMethod = isService ? \"startResourceObservation\" : \"startCallableObservation\";\n+                if (!isService && attachedType != null && attachedType.tag == TypeTags.OBJECT) {\n+                    // add module org and module name to remote spans.\n+                    BObjectType attachedTypeObj = (BObjectType) attachedType;\n+                    serviceOrConnectorName = getFullQualifiedRemoteFunctionName(\n+                            attachedTypeObj.tsymbol.pkgID.orgName.value,\n+                            attachedTypeObj.tsymbol.pkgID.name.value, serviceName);\n+                }\n+                emitStartObservationInvocation(mv, localVarOffset, serviceOrConnectorName, funcName,\n+                        observationStartMethod);\n+            }\n+\n+            // generate instructions\n+            int m = 0;\n+            int insCount = bb.instructions.size();\n+\n+            InstructionKind insKind;\n+            while (m < insCount) {\n+                Label insLabel = labelGen.getLabel(funcName + bb.id.value + \"ins\" + m);\n+                mv.visitLabel(insLabel);\n+                @Nilable BIRInstruction inst = bb.instructions.get(m);\n+                if (inst == null) {\n+                    continue;\n+                } else {\n+                    insKind = inst.getKind();\n+                    generateDiagnosticPos(((BIRNode) inst).pos, mv);\n+                }\n+\n+                if (inst instanceof BinaryOp) {\n+                    instGen.generateBinaryOpIns((BinaryOp) inst);\n+                } else {\n+                    switch (insKind) {\n+                        case MOVE:\n+                            instGen.generateMoveIns((Move) inst);\n+                            break;\n+                        case CONST_LOAD:\n+                            instGen.generateConstantLoadIns((ConstantLoad) inst, useBString);\n+                            break;\n+                        case NEW_STRUCTURE:\n+                            instGen.generateMapNewIns((NewStructure) inst, localVarOffset);\n+                            break;\n+                        case NEW_INSTANCE:\n+                            instGen.generateObjectNewIns((NewInstance) inst, localVarOffset);\n+                            break;\n+                        case MAP_STORE:\n+                            instGen.generateMapStoreIns((FieldAccess) inst);\n+                            break;\n+                        case NEW_ARRAY:\n+                            instGen.generateArrayNewIns((NewArray) inst);\n+                            break;\n+                        case ARRAY_STORE:\n+                            instGen.generateArrayStoreIns((FieldAccess) inst);\n+                            break;\n+                        case MAP_LOAD:\n+                            instGen.generateMapLoadIns((FieldAccess) inst);\n+                            break;\n+                        case ARRAY_LOAD:\n+                            instGen.generateArrayValueLoad((FieldAccess) inst);\n+                            break;\n+                        case NEW_ERROR:\n+                            instGen.generateNewErrorIns((NewError) inst);\n+                            break;\n+                        case TYPE_CAST:\n+                            instGen.generateCastIns((TypeCast) inst);\n+                            break;\n+                        case IS_LIKE:\n+                            instGen.generateIsLikeIns((IsLike) inst);\n+                            break;\n+                        case TYPE_TEST:\n+                            instGen.generateTypeTestIns((TypeTest) inst);\n+                            break;\n+                        case OBJECT_STORE:\n+                            instGen.generateObjectStoreIns((FieldAccess) inst, useBString);\n+                            break;\n+                        case OBJECT_LOAD:\n+                            instGen.generateObjectLoadIns((FieldAccess) inst);\n+                            break;\n+                        case NEW_XML_ELEMENT:\n+                            instGen.generateNewXMLElementIns((NewXMLElement) inst);\n+                            break;\n+                        case NEW_XML_TEXT:\n+                            instGen.generateNewXMLTextIns((NewXMLText) inst);\n+                            break;\n+                        case NEW_XML_COMMENT:\n+                            instGen.generateNewXMLCommentIns((NewXMLComment) inst);\n+                            break;\n+                        case NEW_XML_PI:\n+                            instGen.generateNewXMLProcIns((NewXMLProcIns) inst);\n+                            break;\n+                        case NEW_XML_QNAME:\n+                            instGen.generateNewXMLQNameIns((NewXMLQName) inst);\n+                            break;\n+                        case NEW_STRING_XML_QNAME:\n+                            instGen.generateNewStringXMLQNameIns((NewStringXMLQName) inst);\n+                            break;\n+                        case XML_SEQ_STORE:\n+                            instGen.generateXMLStoreIns((XMLAccess) inst);\n+                            break;\n+                        case XML_SEQ_LOAD:\n+                            instGen.generateXMLLoadIns((FieldAccess) inst);\n+                            break;\n+                        case XML_LOAD:\n+                            instGen.generateXMLLoadIns((FieldAccess) inst);\n+                            break;\n+                        case XML_LOAD_ALL:\n+                            instGen.generateXMLLoadAllIns((XMLAccess) inst);\n+                            break;\n+                        case XML_ATTRIBUTE_STORE:\n+                            instGen.generateXMLAttrStoreIns((FieldAccess) inst);\n+                            break;\n+                        case XML_ATTRIBUTE_LOAD:\n+                            instGen.generateXMLAttrLoadIns((FieldAccess) inst);\n+                            break;\n+                        case FP_LOAD:\n+                            instGen.generateFPLoadIns((FPLoad) inst);\n+                            break;\n+                        case STRING_LOAD:\n+                            instGen.generateStringLoadIns((FieldAccess) inst);\n+                            break;\n+                        case NEW_TABLE:\n+                            instGen.generateTableNewIns((NewTable) inst);\n+                            break;\n+                        case TYPEOF:\n+                            instGen.generateTypeofIns((UnaryOP) inst);\n+                            break;\n+                        case NOT:\n+                            instGen.generateNotIns((UnaryOP) inst);\n+                            break;\n+                        case NEW_TYPEDESC:\n+                            instGen.generateNewTypedescIns((NewTypeDesc) inst);\n+                            break;\n+                        case NEGATE:\n+                            instGen.generateNegateIns((UnaryOP) inst);\n+                            break;\n+                        case PLATFORM:\n+                            instGen.generatePlatformIns((JInstruction) inst);\n+                            break;\n+                        default:\n+                            throw new BLangCompilerException(\"JVM generation is not supported for operation \" +\n+                                    String.format(\"%s\", inst));\n+                    }\n+                }\n+                m += 1;\n+            }\n+\n+            Label bbEndLable = labelGen.getLabel(funcName + bb.id.value + \"beforeTerm\");\n+            mv.visitLabel(bbEndLable);\n+\n+            BIRTerminator terminator = bb.terminator;\n+            if (!isArg) {\n+                // SIPUSH range is (-32768 to 32767) so if the state index goes beyond that, need to use visitLdcInsn\n+                mv.visitIntInsn(SIPUSH, caseIndex);\n+                mv.visitVarInsn(ISTORE, stateVarIndex);\n+                caseIndex += 1;\n+            }\n+\n+            // process terminator\n+            boolean isTerminatorTrapped = false;\n+            if (!isArg || (isArg && !(terminator instanceof Return))) {\n+                generateDiagnosticPos(terminator.pos, mv);\n+                if (isModuleInitFunction(module, func) && terminator instanceof Return) {\n+                    generateAnnotLoad(mv, module.typeDefs, getPackageName(module.org.value, module.name.value));\n+                }\n+                termGen.genTerminator(terminator, func, funcName, localVarOffset, returnVarRefIndex, attachedType,\n+                        isObserved);\n+            }\n+\n+            errorGen.generateTryCatch(func, funcName, bb, instGen, termGen, labelGen);\n+\n+            BIRBasicBlock thenBB = terminator.thenBB;\n+            if (thenBB instanceof BIRBasicBlock) {\n+                genYieldCheck(mv, termGen.labelGen, thenBB, funcName, localVarOffset);\n+            }\n+            j += 1;\n+        }\n+    }\n+\n+    private static void genYieldCheck(MethodVisitor mv, LabelGenerator labelGen, BIRBasicBlock thenBB, String funcName,\n+                                      int localVarOffset) {\n+\n+        mv.visitVarInsn(ALOAD, localVarOffset);\n+        mv.visitMethodInsn(INVOKEVIRTUAL, STRAND, \"isYielded\", \"()Z\", false);\n+        Label yieldLabel = labelGen.getLabel(funcName + \"yield\");\n+        mv.visitJumpInsn(IFNE, yieldLabel);\n+\n+        // goto thenBB\n+        Label gotoLabel = labelGen.getLabel(funcName + thenBB.id.value);\n+        mv.visitJumpInsn(GOTO, gotoLabel);\n+    }\n+\n+    static void generateLambdaMethod(BIRInstruction ins, ClassWriter cw, String lambdaName) {\n+\n+        @Nilable BType lhsType;\n+        String orgName;\n+        String moduleName;\n+        String funcName;\n+        int paramIndex = 1;\n+        boolean isVirtual = false;\n+        InstructionKind kind = ins.getKind();\n+        if (kind == InstructionKind.ASYNC_CALL) {\n+            AsyncCall asyncIns = (AsyncCall) ins;\n+            isVirtual = asyncIns.isVirtual;\n+            lhsType = asyncIns.lhsOp != null ? asyncIns.lhsOp.variableDcl.type : null;\n+            orgName = asyncIns.calleePkg.orgName.value;\n+            moduleName = asyncIns.calleePkg.name.value;\n+            funcName = asyncIns.name.getValue();\n+        } else if (kind == InstructionKind.FP_LOAD) {\n+            FPLoad fpIns = (FPLoad) ins;\n+            lhsType = fpIns.lhsOp.variableDcl.type;\n+            orgName = fpIns.pkgId.orgName.value;\n+            moduleName = fpIns.pkgId.name.value;\n+            funcName = fpIns.funcName.getValue();\n+        } else {\n+            throw new BLangCompilerException(\"JVM lambda method generation is not supported for instruction \" +\n+                    String.format(\"%s\", ins));\n+        }\n+\n+        boolean isExternFunction = isExternStaticFunctionCall(ins);\n+        boolean isBuiltinModule = isBallerinaBuiltinModule(orgName, moduleName);\n+\n+        BType returnType = new BNilType();\n+        if (lhsType.tag == TypeTags.FUTURE) {\n+            returnType = ((BFutureType) lhsType).constraint;\n+        } else if (ins instanceof FPLoad) {\n+            returnType = ((FPLoad) ins).retType;\n+            if (returnType.tag == TypeTags.INVOKABLE) {\n+                returnType = ((BInvokableType) returnType).retType;\n+            }\n+        } else {\n+            throw new BLangCompilerException(\"JVM generation is not supported for async return type \" +\n+                    String.format(\"%s\", lhsType));\n+        }\n+\n+        int closureMapsCount = 0;\n+        if (kind == InstructionKind.FP_LOAD) {\n+            closureMapsCount = ((FPLoad) ins).closureMaps.size();\n+        }\n+        String closureMapsDesc = getMapValueDesc(closureMapsCount);\n+\n+        MethodVisitor mv;\n+        mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, cleanupFunctionName(lambdaName),\n+                String.format(\"(%s[L%s;)L%s;\", closureMapsDesc, OBJECT, OBJECT), null, null);\n+\n+        mv.visitCode();\n+        // load strand as first arg\n+        // strand and other args are in a object[] param. This param comes after closure maps.\n+        // hence the closureMapsCount is equal to the array's param index.\n+        mv.visitVarInsn(ALOAD, closureMapsCount);\n+        mv.visitInsn(ICONST_0);\n+        mv.visitInsn(AALOAD);\n+        mv.visitTypeInsn(CHECKCAST, STRAND);\n+\n+        if (isExternFunction) {\n+            Label blockedOnExternLabel = new Label();\n+\n+            mv.visitInsn(DUP);\n+\n+            mv.visitMethodInsn(INVOKEVIRTUAL, STRAND, \"isBlockedOnExtern\", \"()Z\", false);\n+            mv.visitJumpInsn(IFEQ, blockedOnExternLabel);\n+\n+            mv.visitInsn(DUP);\n+            mv.visitInsn(ICONST_0);\n+            mv.visitFieldInsn(PUTFIELD, STRAND, \"blockedOnExtern\", \"Z\");\n+\n+            mv.visitInsn(DUP);\n+            mv.visitFieldInsn(GETFIELD, STRAND, \"returnValue\", \"Ljava/lang/Object;\");\n+            mv.visitInsn(ARETURN);\n+\n+            mv.visitLabel(blockedOnExternLabel);\n+        }\n+        @Nilable List<BType> paramBTypes = new ArrayList<>();\n+\n+        if (kind == InstructionKind.ASYNC_CALL) {\n+            AsyncCall asyncIns = (AsyncCall) ins;\n+            @Nilable List<BIROperand> paramTypes = asyncIns.args;\n+            if (isVirtual) {\n+                genLoadDataForObjectAttachedLambdas(asyncIns, mv, closureMapsCount, paramTypes, isBuiltinModule);\n+                int paramTypeIndex = 1;\n+                paramIndex = 2;\n+                while (paramTypeIndex < paramTypes.size()) {\n+                    generateObjectArgs(mv, paramIndex);\n+                    paramTypeIndex += 1;\n+                    paramIndex += 1;\n+                    if (!isBuiltinModule) {\n+                        generateObjectArgs(mv, paramIndex);\n+                        paramIndex += 1;\n+               ", "originalCommit": "82df207efdc85acd9646a1aae1461f7d1f7bbc5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "58faa6a198cd02edc9d1caff261bab161f142d46", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/58faa6a198cd02edc9d1caff261bab161f142d46", "message": "Disable failing negative tests", "committedDate": "2020-03-04T06:03:08Z", "type": "commit"}, {"oid": "4cbd7c6e6975054bfba2f394b2f26c79f7860760", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4cbd7c6e6975054bfba2f394b2f26c79f7860760", "message": "Disable gradle pre-running assemble\n\nsee https://github.com/travis-ci/travis-ci/issues/8667", "committedDate": "2020-03-04T08:02:26Z", "type": "commit"}, {"oid": "88e5a152a4cefd9ab787de4230813c1ff1f31fbb", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/88e5a152a4cefd9ab787de4230813c1ff1f31fbb", "message": "Disable balopath test temporary", "committedDate": "2020-03-04T09:10:51Z", "type": "commit"}, {"oid": "09fb153d30fe9707da93adcdfbf9bd1c7cf8784f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/09fb153d30fe9707da93adcdfbf9bd1c7cf8784f", "message": "Disable testBaloPathCase2 testcase", "committedDate": "2020-03-04T09:34:32Z", "type": "commit"}, {"oid": "800b24ef066a76dc8c536b503d94f0cbd0dced14", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/800b24ef066a76dc8c536b503d94f0cbd0dced14", "message": "Merge pull request #21473 from warunalakshitha/disable_tests\n\nDisable balo path test", "committedDate": "2020-03-04T09:38:17Z", "type": "commit"}, {"oid": "cad8d24bc398e669b8a88fefdf824557d4e17a12", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/cad8d24bc398e669b8a88fefdf824557d4e17a12", "message": "Disable cache for integration test travis build", "committedDate": "2020-03-04T12:37:25Z", "type": "commit"}, {"oid": "a68378a72ad595f9af92c7f3909845e296ba2d0b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a68378a72ad595f9af92c7f3909845e296ba2d0b", "message": "Disable gradle pre-running assemble for integration test", "committedDate": "2020-03-04T13:20:39Z", "type": "commit"}, {"oid": "1fb1689213dc2cc962eadad4bb58f3fbdce99ea0", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1fb1689213dc2cc962eadad4bb58f3fbdce99ea0", "message": "Merge pull request #21318 from manuranga/jbal-be-rewrite\n\nFix duplicate stop methods issue", "committedDate": "2020-02-27T06:53:39Z", "type": "commit"}, {"oid": "9899f57c32c6c53ba874c2883bd4d391239dc425", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9899f57c32c6c53ba874c2883bd4d391239dc425", "message": "Fix missing bitwise operation instruction case", "committedDate": "2020-02-27T09:58:17Z", "type": "commit"}, {"oid": "832b3985448c119f3f289d8bfb83b38661456de4", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/832b3985448c119f3f289d8bfb83b38661456de4", "message": "Use tSymbol to get name and flag values", "committedDate": "2020-02-27T09:58:43Z", "type": "commit"}, {"oid": "bdf5465521cb02b3f30e51ffacbda3ee748a9bab", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bdf5465521cb02b3f30e51ffacbda3ee748a9bab", "message": "Merge pull request #21330 from Kishanthan/jbal-merge-master\n\nUse tSymbol to get name and flag values", "committedDate": "2020-02-27T10:01:56Z", "type": "commit"}, {"oid": "b3eb593287d03cd987db7783c849b59c8ccae6eb", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b3eb593287d03cd987db7783c849b59c8ccae6eb", "message": "Fix lambda function lookup using symbols", "committedDate": "2020-02-27T10:41:22Z", "type": "commit"}, {"oid": "2ce613652e658e2e659bc50c2905981b8976bf17", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2ce613652e658e2e659bc50c2905981b8976bf17", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-merge-master", "committedDate": "2020-02-27T10:41:44Z", "type": "commit"}, {"oid": "6455d5a1eb2c9fc8d00b7ed1a9273987754928e7", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6455d5a1eb2c9fc8d00b7ed1a9273987754928e7", "message": "Fix InherentTypeViolation bug", "committedDate": "2020-02-27T11:35:48Z", "type": "commit"}, {"oid": "8de29baa98d712b230a61fd3a275f9fa7c30f101", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8de29baa98d712b230a61fd3a275f9fa7c30f101", "message": "Merge pull request #21333 from manuranga/jbal-be-rewrite\n\nFix InherentTypeViolation bug", "committedDate": "2020-02-27T11:38:41Z", "type": "commit"}, {"oid": "9a0f60295ee5f86fb71aeb7bb23f9ab1235e64b1", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9a0f60295ee5f86fb71aeb7bb23f9ab1235e64b1", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-merge-master", "committedDate": "2020-02-27T11:39:07Z", "type": "commit"}, {"oid": "89e9bcba320546135ada3a9af9fda56aaff49c21", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/89e9bcba320546135ada3a9af9fda56aaff49c21", "message": "Clean jar cache prior to each balo creation run", "committedDate": "2020-02-27T14:12:44Z", "type": "commit"}, {"oid": "fa756e084066815874ba07a90ab8f1cf6fefa40f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fa756e084066815874ba07a90ab8f1cf6fefa40f", "message": "Use correct flag value for attach fns", "committedDate": "2020-02-27T14:13:16Z", "type": "commit"}, {"oid": "53449827b8bf492b4d1ba0d39f95e58e16d9536b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/53449827b8bf492b4d1ba0d39f95e58e16d9536b", "message": "Preserve insertion order and build recursive imports", "committedDate": "2020-02-27T14:14:18Z", "type": "commit"}, {"oid": "360319f8000f4e2e9459e73ce8bc2021256a387c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/360319f8000f4e2e9459e73ce8bc2021256a387c", "message": "Remove unused imports", "committedDate": "2020-02-27T14:14:43Z", "type": "commit"}, {"oid": "4392e76fff0ab8f9106658d317226e61df64f4c7", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4392e76fff0ab8f9106658d317226e61df64f4c7", "message": "Merge pull request #21332 from Kishanthan/jbal-merge-master\n\nFix lambda function lookup using symbols", "committedDate": "2020-02-27T14:21:31Z", "type": "commit"}, {"oid": "37925b86300a12b924231bd5cd40047ae47b2ebc", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/37925b86300a12b924231bd5cd40047ae47b2ebc", "message": "Fixes related to global var lookup and null type name", "committedDate": "2020-02-28T05:27:24Z", "type": "commit"}, {"oid": "b6ba652fcfad33c6f701e7892ab291dc6e879a7e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b6ba652fcfad33c6f701e7892ab291dc6e879a7e", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-merge-master", "committedDate": "2020-02-28T05:27:56Z", "type": "commit"}, {"oid": "193389ed96f2d1e29a656e80ebd97e1fd2910312", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/193389ed96f2d1e29a656e80ebd97e1fd2910312", "message": "Remove unused import", "committedDate": "2020-02-28T05:29:57Z", "type": "commit"}, {"oid": "627169c0a1352cfa19902f47cecb5669e587b400", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/627169c0a1352cfa19902f47cecb5669e587b400", "message": "Merge pull request #21342 from Kishanthan/jbal-merge-master\n\nFixes related to global var lookup and null type name", "committedDate": "2020-02-28T05:33:36Z", "type": "commit"}, {"oid": "f69aa660140b4c0ff21f6b576426cf8ef92f93e9", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f69aa660140b4c0ff21f6b576426cf8ef92f93e9", "message": "Skip desugaring imported same project modules", "committedDate": "2020-02-28T08:06:35Z", "type": "commit"}, {"oid": "86cfbc4f6176a9b2204aae43232a072a81ca2051", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/86cfbc4f6176a9b2204aae43232a072a81ca2051", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-merge-master", "committedDate": "2020-02-28T08:07:01Z", "type": "commit"}, {"oid": "02ffd79c675792de9e727cc21a260fc86bc2c93d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/02ffd79c675792de9e727cc21a260fc86bc2c93d", "message": "Fix object/record type flags", "committedDate": "2020-02-28T08:36:28Z", "type": "commit"}, {"oid": "6891824c9ee6517386591cd79ea77b1bf20ce8d0", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6891824c9ee6517386591cd79ea77b1bf20ce8d0", "message": "Merge pull request #21348 from SupunS/jbal-be-rewrite\n\nFix object/record type flags", "committedDate": "2020-02-28T08:40:49Z", "type": "commit"}, {"oid": "fa1432f8f050cd1b5f8e642ec509c4b52a4009b3", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fa1432f8f050cd1b5f8e642ec509c4b52a4009b3", "message": "Fix visitMaxs in ArrayFillTest", "committedDate": "2020-02-28T09:33:42Z", "type": "commit"}, {"oid": "30cabafa5682b53cbb35b31831eebe97f527acb7", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/30cabafa5682b53cbb35b31831eebe97f527acb7", "message": "Merge pull request #21351 from SupunS/jbal-be-rewrite\n\nFix visitMaxs in ArrayFillTest", "committedDate": "2020-02-28T09:49:58Z", "type": "commit"}, {"oid": "2aa01a590a7b962716ebac3a7ba180c8be533bd1", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2aa01a590a7b962716ebac3a7ba180c8be533bd1", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-merge-master", "committedDate": "2020-02-28T09:56:05Z", "type": "commit"}, {"oid": "4e7756b6babf544b9335e07e6d1f3380412e69ad", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4e7756b6babf544b9335e07e6d1f3380412e69ad", "message": "Fix decimal finitie type", "committedDate": "2020-02-28T10:08:40Z", "type": "commit"}, {"oid": "2a9033e46a5ce55ad8a104f0fe96930520216b00", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2a9033e46a5ce55ad8a104f0fe96930520216b00", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-be-rewrite", "committedDate": "2020-02-28T10:08:53Z", "type": "commit"}, {"oid": "51463b20389be601264176479b19f155695eb7c7", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/51463b20389be601264176479b19f155695eb7c7", "message": "Clean jar cache dir before test run", "committedDate": "2020-02-28T10:11:38Z", "type": "commit"}, {"oid": "0bf554ed2acd5053cf9ecb54319668ea3310b2d7", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0bf554ed2acd5053cf9ecb54319668ea3310b2d7", "message": "Merge pull request #21356 from SupunS/jbal-be-rewrite\n\nFix decimal finite type", "committedDate": "2020-02-28T10:16:22Z", "type": "commit"}, {"oid": "54514326cfdf6d7b7aec5c0cb18bf4b31a0e6392", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/54514326cfdf6d7b7aec5c0cb18bf4b31a0e6392", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-merge-master", "committedDate": "2020-02-28T10:19:17Z", "type": "commit"}, {"oid": "a21988dba40b835c9efc60ae29a44e6359b25fc4", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a21988dba40b835c9efc60ae29a44e6359b25fc4", "message": "Merge pull request #21355 from Kishanthan/jbal-merge-master\n\nSkip desugaring imported same project modules", "committedDate": "2020-02-28T10:38:43Z", "type": "commit"}, {"oid": "bd67c81a2061b9040e547c29e975d4fce019af26", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bd67c81a2061b9040e547c29e975d4fce019af26", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into jbal-with-latest-master", "committedDate": "2020-02-28T10:58:13Z", "type": "commit"}, {"oid": "f1dd18c82fe9f82baa4c516f9d02f43a2d0226ce", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f1dd18c82fe9f82baa4c516f9d02f43a2d0226ce", "message": "Fix compilation issues with lock changes", "committedDate": "2020-02-28T11:39:43Z", "type": "commit"}, {"oid": "b183c45674c3074c103deba446049da9ed4e0a5e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b183c45674c3074c103deba446049da9ed4e0a5e", "message": "Fix compilation issues with BIR emitter", "committedDate": "2020-02-28T11:55:23Z", "type": "commit"}, {"oid": "9e765a61692631d241dab03abf6f8b46c71b6415", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9e765a61692631d241dab03abf6f8b46c71b6415", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-with-latest-master", "committedDate": "2020-02-28T11:55:46Z", "type": "commit"}, {"oid": "0e62a6d210b0b7c944fdbf417e2eabca0f608424", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0e62a6d210b0b7c944fdbf417e2eabca0f608424", "message": "Merge pull request #21358 from Kishanthan/jbal-with-latest-master\n\nMerge jbal-rewrite-be with master", "committedDate": "2020-02-28T12:17:42Z", "type": "commit"}, {"oid": "1155903e425124a9fe6af2868cb161faf00de723", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1155903e425124a9fe6af2868cb161faf00de723", "message": "Add compiled module cache to avoid recompilation", "committedDate": "2020-02-28T13:17:35Z", "type": "commit"}, {"oid": "e75d6e0d1ba15a007e88496e0805afee53e5f091", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e75d6e0d1ba15a007e88496e0805afee53e5f091", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-with-latest-master", "committedDate": "2020-02-28T13:17:57Z", "type": "commit"}, {"oid": "cd215549b135dba5a7ac6cce707351db37588727", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/cd215549b135dba5a7ac6cce707351db37588727", "message": "Merge pull request #21359 from Kishanthan/jbal-with-latest-master\n\nAdd compiled module cache to avoid recompilation", "committedDate": "2020-02-29T04:14:48Z", "type": "commit"}, {"oid": "6f201568ef6c2f14c1189a356ab8306e5c72d0c4", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6f201568ef6c2f14c1189a356ab8306e5c72d0c4", "message": "Fix module stop function lambda generation", "committedDate": "2020-02-29T05:48:44Z", "type": "commit"}, {"oid": "93e9bfc09e6273b38fd93b2c01d4fabff9960102", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/93e9bfc09e6273b38fd93b2c01d4fabff9960102", "message": "Merge pull request #21361 from SupunS/jbal-be-rewrite\n\nFix module stop function lambda generation", "committedDate": "2020-02-29T06:05:54Z", "type": "commit"}, {"oid": "61683ae83dfedc5321cb2454b941cc352e3f659e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/61683ae83dfedc5321cb2454b941cc352e3f659e", "message": "Ondemand cleaning of cache dir for balo tests", "committedDate": "2020-02-29T06:10:35Z", "type": "commit"}, {"oid": "9d539f02945e90fcf1160d63717b3c19052c5c07", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9d539f02945e90fcf1160d63717b3c19052c5c07", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-with-latest-master", "committedDate": "2020-02-29T06:10:51Z", "type": "commit"}, {"oid": "1d2a56aaf556bcbd9a5d39d94ee888963e647d8f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1d2a56aaf556bcbd9a5d39d94ee888963e647d8f", "message": "Move create balo logic inside test cases", "committedDate": "2020-02-29T07:16:53Z", "type": "commit"}, {"oid": "54bbe6d3cd71a623e047b2cf65b2a320ffb1219c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/54bbe6d3cd71a623e047b2cf65b2a320ffb1219c", "message": "FIx compiler backend error logging", "committedDate": "2020-02-29T08:14:47Z", "type": "commit"}, {"oid": "b441e0ab27041ce0308d0e8f23770d3f07b9e868", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b441e0ab27041ce0308d0e8f23770d3f07b9e868", "message": "Merge pull request #21363 from SupunS/jbal-be-rewrite\n\nFix compiler backend error logging", "committedDate": "2020-02-29T08:24:47Z", "type": "commit"}, {"oid": "cdcfa87a5f43611dbb38be4b88e2ee9418c5fcd9", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/cdcfa87a5f43611dbb38be4b88e2ee9418c5fcd9", "message": "Merge pull request #21362 from Kishanthan/jbal-with-latest-master\n\nOndemand cleaning of cache dir for balo tests", "committedDate": "2020-02-29T08:25:56Z", "type": "commit"}, {"oid": "da6af5302c360188825f5cefd6e3ee72c404b811", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/da6af5302c360188825f5cefd6e3ee72c404b811", "message": "Use correct types with casting", "committedDate": "2020-02-29T08:33:28Z", "type": "commit"}, {"oid": "66dece05f93e2854e88a7767ba48f02452e6eaa5", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/66dece05f93e2854e88a7767ba48f02452e6eaa5", "message": "Clean cache directory for balo test", "committedDate": "2020-02-29T08:33:54Z", "type": "commit"}, {"oid": "14b4c8e0e8552124146b3d249b2482dffc8651a2", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/14b4c8e0e8552124146b3d249b2482dffc8651a2", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-with-latest-master", "committedDate": "2020-02-29T08:34:05Z", "type": "commit"}, {"oid": "6b8a08b031a509fa603a58890bb0555f474a9331", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6b8a08b031a509fa603a58890bb0555f474a9331", "message": "Catch only on-compiler errors", "committedDate": "2020-02-29T08:47:11Z", "type": "commit"}, {"oid": "3661057bc8b5d356818ace6767afef3c05519f48", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3661057bc8b5d356818ace6767afef3c05519f48", "message": "Merge pull request #21365 from Kishanthan/jbal-with-latest-master\n\nUse correct types with casting", "committedDate": "2020-02-29T08:50:58Z", "type": "commit"}, {"oid": "dddaf421850c1037c220acbd94ff294d163e57b9", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/dddaf421850c1037c220acbd94ff294d163e57b9", "message": "Merge pull request #21366 from SupunS/jbal-be-rewrite\n\nCatch only non-compiler errors", "committedDate": "2020-02-29T08:54:03Z", "type": "commit"}, {"oid": "2c9ec4c56d945f426a2b3c784ae298c6ec396c9a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2c9ec4c56d945f426a2b3c784ae298c6ec396c9a", "message": "Use type instance from symbol table", "committedDate": "2020-02-29T09:08:58Z", "type": "commit"}, {"oid": "5684015f663ca5cfd5c2cf5789792a30251998a8", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5684015f663ca5cfd5c2cf5789792a30251998a8", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-with-latest-master", "committedDate": "2020-02-29T09:09:39Z", "type": "commit"}, {"oid": "30a347b5b416b18ae192c5f78d65e277d314761c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/30a347b5b416b18ae192c5f78d65e277d314761c", "message": "Fix xml test", "committedDate": "2020-02-29T09:20:49Z", "type": "commit"}, {"oid": "300aa9bd811b1b1efb4650314faf96254d60c26e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/300aa9bd811b1b1efb4650314faf96254d60c26e", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-be-rewrite", "committedDate": "2020-02-29T09:21:09Z", "type": "commit"}, {"oid": "4690e662ba0ab1f6919cfbadc9516dc921cee7f6", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4690e662ba0ab1f6919cfbadc9516dc921cee7f6", "message": "Change the build to use ported java backend", "committedDate": "2020-02-29T09:27:38Z", "type": "commit"}, {"oid": "93d4eae9c8a8d12bde3497f3c530efe9be433ccc", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/93d4eae9c8a8d12bde3497f3c530efe9be433ccc", "message": "Merge pull request #21368 from SupunS/jbal-be-rewrite\n\nFix xml test", "committedDate": "2020-02-29T09:27:43Z", "type": "commit"}, {"oid": "671b66c3c275296f887cb4f9f49e9e59800fcc72", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/671b66c3c275296f887cb4f9f49e9e59800fcc72", "message": "Merge pull request #21367 from Kishanthan/jbal-with-latest-master\n\nUse type instance from symbol table", "committedDate": "2020-02-29T09:27:54Z", "type": "commit"}, {"oid": "5b6224735d5607e363653bde17dffdefc1955147", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5b6224735d5607e363653bde17dffdefc1955147", "message": "Merge remote-tracking branch 'origin/jbal-be-rewrite' into jbal-be-rewrite\n\n# Conflicts:\n#\tcompiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmMethodGen.java", "committedDate": "2020-02-29T09:30:35Z", "type": "commit"}, {"oid": "411d1ee6c0d49b1b833e526d1294a28c90819e0d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/411d1ee6c0d49b1b833e526d1294a28c90819e0d", "message": "Fix future type", "committedDate": "2020-02-29T09:44:24Z", "type": "commit"}, {"oid": "2dfdfdf72960844824fa75ffe64f0a86f720dad9", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2dfdfdf72960844824fa75ffe64f0a86f720dad9", "message": "Merge pull request #21364 from manuranga/jbal-be-rewrite\n\nChange the build to use ported java backend", "committedDate": "2020-02-29T09:51:37Z", "type": "commit"}, {"oid": "9efaab431b2511b84777c8fb00bda4035762b8a5", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9efaab431b2511b84777c8fb00bda4035762b8a5", "message": "Merge pull request #21370 from SupunS/jbal-be-rewrite\n\nFix future type", "committedDate": "2020-02-29T09:52:03Z", "type": "commit"}, {"oid": "78b96edd3d402916afd6cfda9c0d03d3585ddd83", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/78b96edd3d402916afd6cfda9c0d03d3585ddd83", "message": "Fix calling main function with rest param", "committedDate": "2020-02-29T10:40:23Z", "type": "commit"}, {"oid": "26b0f024ecc655935980ec6948f35181c42aacc7", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/26b0f024ecc655935980ec6948f35181c42aacc7", "message": "Merge pull request #21372 from manuranga/jbal-be-rewrite\n\nFix calling main function with rest param", "committedDate": "2020-02-29T10:43:36Z", "type": "commit"}, {"oid": "058039e8aa664fd2015c104028c4b5b3b8412b76", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/058039e8aa664fd2015c104028c4b5b3b8412b76", "message": "Migrate stream related codegen changes", "committedDate": "2020-02-29T10:51:17Z", "type": "commit"}, {"oid": "70b57901e71c269298e787c24824b23c8c6b0ff5", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/70b57901e71c269298e787c24824b23c8c6b0ff5", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-with-latest-master", "committedDate": "2020-02-29T10:51:38Z", "type": "commit"}, {"oid": "6495a3ac1ff5d7f17455b213faadaa3f0e60595c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6495a3ac1ff5d7f17455b213faadaa3f0e60595c", "message": "Merge pull request #21373 from Kishanthan/jbal-with-latest-master\n\nMigrate stream related codegen changes", "committedDate": "2020-02-29T10:55:30Z", "type": "commit"}, {"oid": "c6628c85add03f3784ec4905d5b41027adea0ced", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c6628c85add03f3784ec4905d5b41027adea0ced", "message": "Fix interop unit tests", "committedDate": "2020-02-29T16:11:58Z", "type": "commit"}, {"oid": "b38296a24e0bd297fdddb0da0779d538985d695d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b38296a24e0bd297fdddb0da0779d538985d695d", "message": "Merge branch jbal-be-rewrite", "committedDate": "2020-02-29T17:33:12Z", "type": "commit"}, {"oid": "7ab477adfef86253a6bd2b28e80d7b331fdc5d32", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7ab477adfef86253a6bd2b28e80d7b331fdc5d32", "message": "Fix java interop reftype tests", "committedDate": "2020-02-29T18:27:46Z", "type": "commit"}, {"oid": "a2b1310717ecc66cf1f30328c5724bbbffe64f72", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a2b1310717ecc66cf1f30328c5724bbbffe64f72", "message": "Merge pull request #21377 from warunalakshitha/jbal_rewrite\n\nFix java interop unit tests", "committedDate": "2020-03-01T06:49:33Z", "type": "commit"}, {"oid": "a5f1006ef7b90d9ba22587695929ae03fc44a30a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a5f1006ef7b90d9ba22587695929ae03fc44a30a", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into jbal-with-latest-master", "committedDate": "2020-03-01T07:44:51Z", "type": "commit"}, {"oid": "d9c01cb2eb2f547bce44d9c167baf6e0e59f20d7", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d9c01cb2eb2f547bce44d9c167baf6e0e59f20d7", "message": "Merge pull request #21379 from Kishanthan/jbal-with-latest-master\n\nMerge with master", "committedDate": "2020-03-01T08:04:47Z", "type": "commit"}, {"oid": "7cc2d4cffdaec4b6e814ade1a888e88456035785", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7cc2d4cffdaec4b6e814ade1a888e88456035785", "message": "Fix interop validation class not found issue", "committedDate": "2020-03-01T08:15:52Z", "type": "commit"}, {"oid": "87e92a6433080050ecce85c11a7789812f2a4fb5", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/87e92a6433080050ecce85c11a7789812f2a4fb5", "message": "Merge pull request #21380 from manuranga/jbal-be-rewrite\n\nFix interop validation class not found issue", "committedDate": "2020-03-01T08:27:47Z", "type": "commit"}, {"oid": "54b5b6451b3ed22f8b448fa1c2ae6d5337c7182c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/54b5b6451b3ed22f8b448fa1c2ae6d5337c7182c", "message": "Fix checkstyle and code quality issues", "committedDate": "2020-03-01T18:42:25Z", "type": "commit"}, {"oid": "034715b7a881290c0f5e5131bacc9287be951111", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/034715b7a881290c0f5e5131bacc9287be951111", "message": "Merge pull request #21384 from Kishanthan/jbal-with-latest-master\n\nFix checkstyle and code quality issues", "committedDate": "2020-03-02T05:41:39Z", "type": "commit"}, {"oid": "d2fd9553df062c8f3f385d8f3e2e5c2312bc7c05", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d2fd9553df062c8f3f385d8f3e2e5c2312bc7c05", "message": "Remove variable shadowing fixing interop cast issue", "committedDate": "2020-03-02T06:23:35Z", "type": "commit"}, {"oid": "8b15a5099fea53aa2fc469603e84b14dbf861f68", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8b15a5099fea53aa2fc469603e84b14dbf861f68", "message": "Merge remote-tracking branch 'origin/jbal-be-rewrite' into jbal-be-rewrite\n\n# Conflicts:\n#\tcompiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/interop/ExternalMethodGen.java\n#\tcompiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/interop/InteropMethodGen.java", "committedDate": "2020-03-02T06:26:23Z", "type": "commit"}, {"oid": "51096f9463adcb9fe190b3aa113649ffeaafeb5a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/51096f9463adcb9fe190b3aa113649ffeaafeb5a", "message": "Merge pull request #21392 from manuranga/jbal-be-rewrite\n\nRemove variable shadowing fixing interop cast issue", "committedDate": "2020-03-02T06:30:53Z", "type": "commit"}, {"oid": "b2fc0d6d43b5b9b3c95e44bee84b4a015b4ec387", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b2fc0d6d43b5b9b3c95e44bee84b4a015b4ec387", "message": "Fix build dependency issue", "committedDate": "2020-03-02T07:47:53Z", "type": "commit"}, {"oid": "bc6679ff9669d139626d67c1b4f2bcd520b547a0", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bc6679ff9669d139626d67c1b4f2bcd520b547a0", "message": "Fix style issue", "committedDate": "2020-03-02T07:48:07Z", "type": "commit"}, {"oid": "eb5b074769d1ff67f1f05a6e4fcaa5cc6f2738fa", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/eb5b074769d1ff67f1f05a6e4fcaa5cc6f2738fa", "message": "Merge pull request #21394 from manuranga/jbal-be-rewrite\n\nFix build issues", "committedDate": "2020-03-02T07:50:12Z", "type": "commit"}, {"oid": "0a657c6132f80a69aa337203106fb45729a057ea", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0a657c6132f80a69aa337203106fb45729a057ea", "message": "Exclude spotbugs warnings for codegen pkg and fix checkstyle issues", "committedDate": "2020-03-02T07:55:05Z", "type": "commit"}, {"oid": "7fa1897a16f9a81ddb14fa62599353931cb79bae", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7fa1897a16f9a81ddb14fa62599353931cb79bae", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-with-latest-master", "committedDate": "2020-03-02T07:55:20Z", "type": "commit"}, {"oid": "a73e1afd5e815d31cb2c8c52011a14d4451b6bf8", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a73e1afd5e815d31cb2c8c52011a14d4451b6bf8", "message": "Merge pull request #21395 from Kishanthan/jbal-with-latest-master\n\nExclude spotbugs warnings for codegen pkg and fix checkstyle issues", "committedDate": "2020-03-02T08:01:28Z", "type": "commit"}, {"oid": "7be3aa6a675c013652cd2e38915b4944e75ff57e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7be3aa6a675c013652cd2e38915b4944e75ff57e", "message": "Exclude BIR emit pkg", "committedDate": "2020-03-02T08:21:35Z", "type": "commit"}, {"oid": "656c7be20d1024580cf1fce16b57be2520ec765f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/656c7be20d1024580cf1fce16b57be2520ec765f", "message": "Merge pull request #21397 from Kishanthan/jbal-with-latest-master\n\nExclude BIR emit pkg", "committedDate": "2020-03-02T08:25:28Z", "type": "commit"}, {"oid": "8310062768790c40f724972bafa3469267161daf", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8310062768790c40f724972bafa3469267161daf", "message": "Clean CreateJarTask class for spotbugs issue", "committedDate": "2020-03-02T08:44:23Z", "type": "commit"}, {"oid": "2c6a383ee4741c2f56e5e232bd105b2f025830f3", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2c6a383ee4741c2f56e5e232bd105b2f025830f3", "message": "Merge pull request #21399 from Kishanthan/jbal-with-latest-master\n\nClean CreateJarTask class for spotbugs issue", "committedDate": "2020-03-02T09:17:12Z", "type": "commit"}, {"oid": "be616a2ac3a17cdb0ebfe6ee03383ce1d0ef3bd4", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/be616a2ac3a17cdb0ebfe6ee03383ce1d0ef3bd4", "message": "Fix interop compile errors", "committedDate": "2020-03-02T12:43:58Z", "type": "commit"}, {"oid": "5b7a8ccb6352f536abfe6f0c9a692847f1f8b75d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5b7a8ccb6352f536abfe6f0c9a692847f1f8b75d", "message": "Refactor interop negative tests to use diagnostics", "committedDate": "2020-03-02T12:44:46Z", "type": "commit"}, {"oid": "c1bc7e435014f68ac5a2a2f13e6e11a223275a79", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c1bc7e435014f68ac5a2a2f13e6e11a223275a79", "message": "Merge branch jbal-be-rewrite", "committedDate": "2020-03-02T13:05:28Z", "type": "commit"}, {"oid": "ebc69b0d0fe77f80c9db601d5ec6c6d4c7ba6b71", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ebc69b0d0fe77f80c9db601d5ec6c6d4c7ba6b71", "message": "Merge remote-tracking branch 'origin/master' into jbal-be-rewrite\n\n# Conflicts:\n#\tcli/ballerina-packerina/src/main/java/org/ballerinalang/packerina/cmd/TestCommand.java", "committedDate": "2020-03-02T13:07:59Z", "type": "commit"}, {"oid": "6fcb38034688bf09f6cba1915be13517750913d2", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6fcb38034688bf09f6cba1915be13517750913d2", "message": "Use a seperate classloader for interop validation", "committedDate": "2020-03-02T13:37:20Z", "type": "commit"}, {"oid": "0eb14756b3f0a286ed90caa4ccb98fb6ae2527d4", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0eb14756b3f0a286ed90caa4ccb98fb6ae2527d4", "message": "Merge pull request #21408 from warunalakshitha/jbal_rewrite\n\nFix interop Negative Tests", "committedDate": "2020-03-02T13:38:22Z", "type": "commit"}, {"oid": "e8e97637df9355155dfabe8d5e4c1da41a1e2a0a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e8e97637df9355155dfabe8d5e4c1da41a1e2a0a", "message": "Merge with remote", "committedDate": "2020-03-02T13:39:52Z", "type": "commit"}, {"oid": "39fb957b2d0b8a7ea7def2ba44e6acd1fc754b5b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/39fb957b2d0b8a7ea7def2ba44e6acd1fc754b5b", "message": "Fix code gen error tests", "committedDate": "2020-03-02T13:52:51Z", "type": "commit"}, {"oid": "6088c3e84c6e4f89569a7d33e4ebde6514b64159", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6088c3e84c6e4f89569a7d33e4ebde6514b64159", "message": "Migrate JvmTerminatorGen and fix compilation errors", "committedDate": "2020-02-12T05:56:02Z", "type": "commit"}, {"oid": "21d338facc9a1dafbf7fe7fb39dc4315ab92f9e0", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/21d338facc9a1dafbf7fe7fb39dc4315ab92f9e0", "message": "Use correct BFutureType", "committedDate": "2020-02-12T06:25:50Z", "type": "commit"}, {"oid": "d3c92839bf260f6096410614263ff209fbbde713", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d3c92839bf260f6096410614263ff209fbbde713", "message": "Merge pull request #21007 from Kishanthan/jbal-be-rewrite\n\nMigrate JvmTerminatorGen and fix compilation errors", "committedDate": "2020-02-12T06:26:30Z", "type": "commit"}, {"oid": "42d2350fa4b0727dd8cf766c2705c34734dc8b76", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/42d2350fa4b0727dd8cf766c2705c34734dc8b76", "message": "Remove BIRVarRef class and use BIROperand instead", "committedDate": "2020-02-12T06:56:30Z", "type": "commit"}, {"oid": "c77a1833336c0d00078f725e3ea05720052191b1", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c77a1833336c0d00078f725e3ea05720052191b1", "message": "Merge pull request #21014 from Kishanthan/jbal-be-rewrite\n\nRemove BIRVarRef class and use BIROperand instead", "committedDate": "2020-02-12T08:15:57Z", "type": "commit"}, {"oid": "18d039ff5129ee6d2c74a34be0bcc7b701d2051c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/18d039ff5129ee6d2c74a34be0bcc7b701d2051c", "message": "Migrate JvmInstructionGen to java", "committedDate": "2020-02-12T09:07:57Z", "type": "commit"}, {"oid": "f4340c2e4a1793acd339ab51ba80373ee39776e0", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f4340c2e4a1793acd339ab51ba80373ee39776e0", "message": "Migrate JvmPackageGen and fix compilation errors", "committedDate": "2020-02-12T09:11:05Z", "type": "commit"}, {"oid": "f09c688784732df1577259a8ace9544904485fe5", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f09c688784732df1577259a8ace9544904485fe5", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-be-rewrite", "committedDate": "2020-02-12T09:11:27Z", "type": "commit"}, {"oid": "95e2bcc767c94d6b7620a9e66d06b0356c94206f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/95e2bcc767c94d6b7620a9e66d06b0356c94206f", "message": "Merge with upstream", "committedDate": "2020-02-12T09:13:54Z", "type": "commit"}, {"oid": "5e36d2f2ff5c57880c5290be82964f0d1ecc485c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5e36d2f2ff5c57880c5290be82964f0d1ecc485c", "message": "Fix compilation errors with addJUnboxInsn method", "committedDate": "2020-02-12T09:18:14Z", "type": "commit"}, {"oid": "bf76bf3d9a52b592733fd17b52b55cd79b849f64", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bf76bf3d9a52b592733fd17b52b55cd79b849f64", "message": "Merge pull request #21022 from Kishanthan/jbal-be-rewrite\n\nMigrate JvmPackageGen and fix compilation errors", "committedDate": "2020-02-12T09:19:37Z", "type": "commit"}, {"oid": "059a5d21b0f0c2d115add37afa9dbd8c4dd32da5", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/059a5d21b0f0c2d115add37afa9dbd8c4dd32da5", "message": "Migrate JvmObservabilityGen, JvmLabelGen and fix compilation errors", "committedDate": "2020-02-12T09:22:59Z", "type": "commit"}, {"oid": "1695fc32ce33cac29c6c0078615b3a42ea49c2d9", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1695fc32ce33cac29c6c0078615b3a42ea49c2d9", "message": "Update java docs", "committedDate": "2020-02-12T09:24:30Z", "type": "commit"}, {"oid": "2a21af0668722bce28a3d27cfa45abdb04e0cecf", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2a21af0668722bce28a3d27cfa45abdb04e0cecf", "message": "Merge pull request #21023 from Kishanthan/jbal-be-rewrite\n\nMigrate JvmObservabilityGen, JvmLabelGen and fix compilation errors", "committedDate": "2020-02-12T09:25:56Z", "type": "commit"}, {"oid": "05af2608360da5b7df8fd4442f88694b6bf954f0", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/05af2608360da5b7df8fd4442f88694b6bf954f0", "message": "Migrate JvmMethodGen to java", "committedDate": "2020-02-14T07:48:18Z", "type": "commit"}, {"oid": "984d668fe4fa98ec4dced1a305328732d0dddcc2", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/984d668fe4fa98ec4dced1a305328732d0dddcc2", "message": "Migrate interop gen related classes", "committedDate": "2020-02-14T08:06:49Z", "type": "commit"}, {"oid": "2ba6e84953620d2f9435e42560c146ba3b319596", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2ba6e84953620d2f9435e42560c146ba3b319596", "message": "Merge pull request #21077 from manuranga/jbal-be-rewrite\n\nMigrate JvmMethodGen to java", "committedDate": "2020-02-14T08:07:44Z", "type": "commit"}, {"oid": "adb6a6aab24d6324714b047de88a2a15681a27d4", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/adb6a6aab24d6324714b047de88a2a15681a27d4", "message": "Fix merge conlficts and compilation errors", "committedDate": "2020-02-14T09:35:17Z", "type": "commit"}, {"oid": "d78720298be9070cb122f9936e59899217a49107", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d78720298be9070cb122f9936e59899217a49107", "message": "Merge pull request #21087 from Kishanthan/jbal-be-rewrite\n\nMigrate interop gen related classes", "committedDate": "2020-02-14T09:46:35Z", "type": "commit"}, {"oid": "f0e863cadd089a136acdde30e5827ff3e91d588a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f0e863cadd089a136acdde30e5827ff3e91d588a", "message": "Fix runtime bugs to get migrated backend working for empty function", "committedDate": "2020-02-17T09:48:46Z", "type": "commit"}, {"oid": "4d2a10d0a1a0eb1bc7f18474480e7b2a8306a46e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4d2a10d0a1a0eb1bc7f18474480e7b2a8306a46e", "message": "Fix genJFieldForInteropField compilation errors", "committedDate": "2020-02-17T09:56:23Z", "type": "commit"}, {"oid": "51b26f097b827473489296db3b13fe56c861e82a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/51b26f097b827473489296db3b13fe56c861e82a", "message": "Merge pull request #21115 from manuranga/jbal-be-rewrite\n\nFix runtime bugs to get migrated backend working for empty function", "committedDate": "2020-02-17T09:57:23Z", "type": "commit"}, {"oid": "057c8837c8098f0949220c46563f60ade911c8e0", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/057c8837c8098f0949220c46563f60ade911c8e0", "message": "Fix InteropMethodGen compilation errors and conflicts with upstream", "committedDate": "2020-02-17T11:56:00Z", "type": "commit"}, {"oid": "ea3b4a36cb4f4f5740f552be1978395bc18497d3", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ea3b4a36cb4f4f5740f552be1978395bc18497d3", "message": "Merge pull request #21121 from Kishanthan/jbal-be-rewrite\n\nFix InteropMethodGen compilation errors and conflicts", "committedDate": "2020-02-17T12:40:55Z", "type": "commit"}, {"oid": "962434437872ae662a2dc16c3b11841deb52b527", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/962434437872ae662a2dc16c3b11841deb52b527", "message": "Clean JInteropFieldValidator logic", "committedDate": "2020-02-17T13:17:47Z", "type": "commit"}, {"oid": "3cda3d33aedbdacbf75f8bf2a0aa7c1baba025bd", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3cda3d33aedbdacbf75f8bf2a0aa7c1baba025bd", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-be-rewrite", "committedDate": "2020-02-17T13:18:08Z", "type": "commit"}, {"oid": "61c3be6fd9e4845ad8568050cd8f7a9c410dcf6e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/61c3be6fd9e4845ad8568050cd8f7a9c410dcf6e", "message": "Use BackendDriver with test source compilation", "committedDate": "2020-02-17T13:49:03Z", "type": "commit"}, {"oid": "3efa0112665c68192b7e84f6ac1865d6d97d48b4", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3efa0112665c68192b7e84f6ac1865d6d97d48b4", "message": "Merge pull request #21124 from Kishanthan/jbal-be-rewrite\n\nClean JInteropFieldValidator and Use BackendDriver for test source compilation", "committedDate": "2020-02-18T05:50:53Z", "type": "commit"}, {"oid": "f4fd5e24b6141185d33488436f03af49c98d30ce", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f4fd5e24b6141185d33488436f03af49c98d30ce", "message": "Cleanup jvm interop gen related classes", "committedDate": "2020-02-18T09:54:42Z", "type": "commit"}, {"oid": "0ef125d4662dbbdf1e73191e383d144a3113285d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0ef125d4662dbbdf1e73191e383d144a3113285d", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-be-rewrite", "committedDate": "2020-02-18T09:55:03Z", "type": "commit"}, {"oid": "ca2b9ecdbf8414013e1f9e80014363b2d1194e57", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ca2b9ecdbf8414013e1f9e80014363b2d1194e57", "message": "Fix casting issue and clean unused vars", "committedDate": "2020-02-18T10:06:54Z", "type": "commit"}, {"oid": "a54254080e5293f8d72c7a3d8b7faa7115fdd412", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a54254080e5293f8d72c7a3d8b7faa7115fdd412", "message": "Merge pull request #21136 from Kishanthan/jbal-be-rewrite\n\nCleanup jvm interop gen related classes", "committedDate": "2020-02-18T10:11:48Z", "type": "commit"}, {"oid": "0013449bbbf00342dbbd373414b497a0f9d039de", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0013449bbbf00342dbbd373414b497a0f9d039de", "message": "Fix visitMax issue for empty function codegen", "committedDate": "2020-02-18T11:16:51Z", "type": "commit"}, {"oid": "3f0cecdf78082e397f94ef511a3d0444d314526f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3f0cecdf78082e397f94ef511a3d0444d314526f", "message": "Merge pull request #21138 from manuranga/jbal-be-rewrite\n\nFix visitMax issue for empty function codegen", "committedDate": "2020-02-18T11:20:39Z", "type": "commit"}, {"oid": "ca82a0f0480014197ca70bf8031998dd3bb6dfb2", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ca82a0f0480014197ca70bf8031998dd3bb6dfb2", "message": "Use symbol to lookup java method names", "committedDate": "2020-02-18T11:36:03Z", "type": "commit"}, {"oid": "6aeae4539841a31cd0c592db89892942b2d58c43", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6aeae4539841a31cd0c592db89892942b2d58c43", "message": "Merge pull request #21139 from manuranga/jbal-be-rewrite\n\nUse symbol to lookup java method names", "committedDate": "2020-02-18T11:40:51Z", "type": "commit"}, {"oid": "d84982938d4a2be8b2f1c4cbeb9bbb04b498bfc7", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d84982938d4a2be8b2f1c4cbeb9bbb04b498bfc7", "message": "Fix visit max from opt-prams gen", "committedDate": "2020-02-18T14:11:16Z", "type": "commit"}, {"oid": "409cfdc2a1da5d14ed7f996c46ba3ccfad56fd95", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/409cfdc2a1da5d14ed7f996c46ba3ccfad56fd95", "message": "Merge pull request #21140 from manuranga/jbal-be-rewrite\n\nFix visit max from opt-prams gen", "committedDate": "2020-02-19T04:06:35Z", "type": "commit"}, {"oid": "c69288be9bd379e92aacb5d7171487de50cdfbd7", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c69288be9bd379e92aacb5d7171487de50cdfbd7", "message": "Clean and format code", "committedDate": "2020-02-19T05:56:24Z", "type": "commit"}, {"oid": "390c3db7efdad7a2c04e20b4cce4c13d4854b88a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/390c3db7efdad7a2c04e20b4cce4c13d4854b88a", "message": "Make obvious static methods private", "committedDate": "2020-02-19T07:35:53Z", "type": "commit"}, {"oid": "93c50a694bfe0f9cb5d505fe23f55511d6538d1c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/93c50a694bfe0f9cb5d505fe23f55511d6538d1c", "message": "Fix issue when calling functions with args", "committedDate": "2020-02-19T08:27:49Z", "type": "commit"}, {"oid": "1ee43ca792aa3116a0acf6820a2db60032661cad", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1ee43ca792aa3116a0acf6820a2db60032661cad", "message": "Merge pull request #21148 from manuranga/jbal-be-rewrite\n\nFix issue when calling functions with args", "committedDate": "2020-02-19T09:02:01Z", "type": "commit"}, {"oid": "6c972af5f7a4c85e6abb50d2ea58871b6b142715", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6c972af5f7a4c85e6abb50d2ea58871b6b142715", "message": "Fix moduleInit return variable missing issue", "committedDate": "2020-02-19T09:02:56Z", "type": "commit"}, {"oid": "0ef43a8f686f14fe263221a58a8e88174bde9324", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0ef43a8f686f14fe263221a58a8e88174bde9324", "message": "Merge with upstream and fix conflicts", "committedDate": "2020-02-19T09:07:00Z", "type": "commit"}, {"oid": "3e78dfac344c175ae579e3aed688b7ca345a65c4", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3e78dfac344c175ae579e3aed688b7ca345a65c4", "message": "Merge pull request #21149 from Kishanthan/jbal-be-rewrite\n\nFix moduleInit return variable missing issue", "committedDate": "2020-02-19T09:11:04Z", "type": "commit"}, {"oid": "f345258733f4cc6c3b5e735c4e9cbfaa8433c834", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f345258733f4cc6c3b5e735c4e9cbfaa8433c834", "message": "Re-fix calling imported functions", "committedDate": "2020-02-19T10:38:59Z", "type": "commit"}, {"oid": "3caf9b70a0f223c4388798cda71dc1d69d6f6ff7", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3caf9b70a0f223c4388798cda71dc1d69d6f6ff7", "message": "Fix parms missing in local var list", "committedDate": "2020-02-19T10:39:26Z", "type": "commit"}, {"oid": "5c1b93e33554e3758b9fb6b450d73dccf5bb3edb", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5c1b93e33554e3758b9fb6b450d73dccf5bb3edb", "message": "Merge pull request #21156 from manuranga/jbal-be-rewrite\n\nFix parms missing in local var list and calling imported functions", "committedDate": "2020-02-19T10:45:10Z", "type": "commit"}, {"oid": "9cf344c9ba9fd4ef3516bb41d753243a28679ce0", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9cf344c9ba9fd4ef3516bb41d753243a28679ce0", "message": "Clean BalToJVMIndexMap class", "committedDate": "2020-02-19T11:57:03Z", "type": "commit"}, {"oid": "05c8eb19322150fcdeb6482ca722fac4434ba236", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/05c8eb19322150fcdeb6482ca722fac4434ba236", "message": "Remove adding syn boolean arg to bvmParamTypes", "committedDate": "2020-02-19T11:57:56Z", "type": "commit"}, {"oid": "36ba2d7a5c9fb93fa9df065cf8a16f3b7587daac", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/36ba2d7a5c9fb93fa9df065cf8a16f3b7587daac", "message": "Add extended ASM ClassWriter to codegen pkg", "committedDate": "2020-02-20T05:32:28Z", "type": "commit"}, {"oid": "02f4837090ac7e89f9a8fe7bae5fa40e9a6ab81c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/02f4837090ac7e89f9a8fe7bae5fa40e9a6ab81c", "message": "Merge pull request #21168 from Kishanthan/jbal-be-rewrite\n\nAdd extended ASM ClassWriter to codegen pkg", "committedDate": "2020-02-20T05:37:36Z", "type": "commit"}, {"oid": "44370872f4a159034c24762d8a3688f06adf2761", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/44370872f4a159034c24762d8a3688f06adf2761", "message": "Enable passing test cases", "committedDate": "2020-02-20T06:56:44Z", "type": "commit"}, {"oid": "b190bed11761fa0cd80896581f5b5ed7e4197cfc", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b190bed11761fa0cd80896581f5b5ed7e4197cfc", "message": "Fix float type constant load issue", "committedDate": "2020-02-20T06:57:29Z", "type": "commit"}, {"oid": "a6e516ff29903256af159337763c4f8a2f43e47c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a6e516ff29903256af159337763c4f8a2f43e47c", "message": "Add missing eof lines", "committedDate": "2020-02-20T06:57:46Z", "type": "commit"}, {"oid": "5b5d5be5b4f40fa5eeb3e60687860a9f1b4ea5d1", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5b5d5be5b4f40fa5eeb3e60687860a9f1b4ea5d1", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-be-rewrite", "committedDate": "2020-02-20T06:57:55Z", "type": "commit"}, {"oid": "889d78d9cac2facf728ef6425cb1a5887de0784b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/889d78d9cac2facf728ef6425cb1a5887de0784b", "message": "Fix type name being null", "committedDate": "2020-02-20T07:21:26Z", "type": "commit"}, {"oid": "030e26c8fb087a834f751c1e320e16c7224ef0bd", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/030e26c8fb087a834f751c1e320e16c7224ef0bd", "message": "Add missing LESS_EQUAL instruction", "committedDate": "2020-02-20T08:27:21Z", "type": "commit"}, {"oid": "887130be226b5fff5f9c18142cbef55b67790d79", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/887130be226b5fff5f9c18142cbef55b67790d79", "message": "Merge pull request #21177 from manuranga/jbal-be-rewrite\n\nFix type name being null", "committedDate": "2020-02-20T08:28:36Z", "type": "commit"}, {"oid": "e06980dc179ffadd2b9da874910bd2cde37a0270", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e06980dc179ffadd2b9da874910bd2cde37a0270", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-be-rewrite", "committedDate": "2020-02-20T08:28:46Z", "type": "commit"}, {"oid": "6ffe8c01b36b7533a547795f9129d075f45e95f4", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6ffe8c01b36b7533a547795f9129d075f45e95f4", "message": "Use correct object type name", "committedDate": "2020-02-20T09:40:40Z", "type": "commit"}, {"oid": "19d6d9f63e04109ad60276130d6194c42bba2b1f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/19d6d9f63e04109ad60276130d6194c42bba2b1f", "message": "Fix record init", "committedDate": "2020-02-20T10:12:09Z", "type": "commit"}, {"oid": "26469e319000905ccc47071d9e64b5e371ef0ff0", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/26469e319000905ccc47071d9e64b5e371ef0ff0", "message": "Merge branch 'jbal-be-rewrite' of github.com:ballerina-platform/ballerina-lang into jbal-be-rewrite", "committedDate": "2020-02-20T10:31:40Z", "type": "commit"}, {"oid": "95f25a3ecae9b26f5277f75d7f861971d8b5dddd", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/95f25a3ecae9b26f5277f75d7f861971d8b5dddd", "message": "Use instanceof for BServiceType to avoid conflicts with BObjectType", "committedDate": "2020-02-21T06:00:05Z", "type": "commit"}, {"oid": "9517dfc3aa36683a59bdfb629cb3ecd95c89eace", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9517dfc3aa36683a59bdfb629cb3ecd95c89eace", "message": "Enable all unit tests in testng.xml", "committedDate": "2020-02-21T06:00:43Z", "type": "commit"}, {"oid": "0262851afd1b1cfcc64071c404ed1cf8741bc8dd", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0262851afd1b1cfcc64071c404ed1cf8741bc8dd", "message": "Merge pull request #21176 from Kishanthan/jbal-be-rewrite\n\nFix float type constant load issue", "committedDate": "2020-02-21T06:05:00Z", "type": "commit"}, {"oid": "873521a14cf195b11c33c6290ffab434ec03a2ae", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/873521a14cf195b11c33c6290ffab434ec03a2ae", "message": "Merge branch 'jbal-be-rewrite' of github.com:ballerina-platform/ballerina-lang into jbal-be-rewrite", "committedDate": "2020-02-21T06:08:05Z", "type": "commit"}, {"oid": "f12d237d1cd1459e069c54aac6cddac84dc913e2", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f12d237d1cd1459e069c54aac6cddac84dc913e2", "message": "Merge pull request #21191 from manuranga/jbal-be-rewrite\n\nFix record init", "committedDate": "2020-02-21T06:10:49Z", "type": "commit"}, {"oid": "e2ab2a3c51ef3e852b3095b96693012f431193c8", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e2ab2a3c51ef3e852b3095b96693012f431193c8", "message": "Fix record value put", "committedDate": "2020-02-21T09:08:14Z", "type": "commit"}, {"oid": "eb833495eb05ee75d15fbd8baf4c087d79730819", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/eb833495eb05ee75d15fbd8baf4c087d79730819", "message": "Merge pull request #21195 from manuranga/jbal-be-rewrite\n\nFix record value put", "committedDate": "2020-02-21T09:10:42Z", "type": "commit"}, {"oid": "adac4b947e7701830968226844b18695ca7582e1", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/adac4b947e7701830968226844b18695ca7582e1", "message": "Merge with master", "committedDate": "2020-02-21T09:51:10Z", "type": "commit"}, {"oid": "af9d4e1b4f15cd08ff561ccbc850559a38604bbc", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/af9d4e1b4f15cd08ff561ccbc850559a38604bbc", "message": "Code cleanup", "committedDate": "2020-02-21T09:57:51Z", "type": "commit"}, {"oid": "2586d49c75845f2b32c88acdb9d978fe60a8f732", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2586d49c75845f2b32c88acdb9d978fe60a8f732", "message": "Use same testng file from master", "committedDate": "2020-02-21T10:00:15Z", "type": "commit"}, {"oid": "c01a82d53e42de7975911abf810eec399eb37ede", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c01a82d53e42de7975911abf810eec399eb37ede", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-merge-master", "committedDate": "2020-02-21T10:00:49Z", "type": "commit"}, {"oid": "e595bb0773cee69a0a7b1a55780cfd518e06bf5f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e595bb0773cee69a0a7b1a55780cfd518e06bf5f", "message": "Fix byte const load", "committedDate": "2020-02-24T12:19:18Z", "type": "commit"}, {"oid": "1764beb454abb3c7927279f01ff427e34b807888", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1764beb454abb3c7927279f01ff427e34b807888", "message": "Make unit tests reset after each compilation", "committedDate": "2020-02-24T12:20:00Z", "type": "commit"}, {"oid": "27fa2c6d6addb5b8524cb804f7e31df1ca52e501", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/27fa2c6d6addb5b8524cb804f7e31df1ca52e501", "message": "Fix error in test exception printing", "committedDate": "2020-02-24T12:49:01Z", "type": "commit"}, {"oid": "0cb4f5f9f333633d571957748cd3a19206fbae7f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0cb4f5f9f333633d571957748cd3a19206fbae7f", "message": "Merge pull request #21219 from manuranga/jbal-be-rewrite\n\nbackend migration fixes", "committedDate": "2020-02-25T04:31:22Z", "type": "commit"}, {"oid": "c8daaa593a52d247d5e422d7105589ab21ce1bc2", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c8daaa593a52d247d5e422d7105589ab21ce1bc2", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-merge-master", "committedDate": "2020-02-25T04:38:34Z", "type": "commit"}, {"oid": "93d54a60d12b3840546483b7701da622b7d859d0", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/93d54a60d12b3840546483b7701da622b7d859d0", "message": "Fix imported type object creation", "committedDate": "2020-02-25T08:51:12Z", "type": "commit"}, {"oid": "c6b924acac284aef6ecef535dfb1b73dc6aa24a1", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c6b924acac284aef6ecef535dfb1b73dc6aa24a1", "message": "Merge pull request #21229 from manuranga/jbal-be-rewrite\n\nFix imported type object creation", "committedDate": "2020-02-25T08:53:45Z", "type": "commit"}, {"oid": "3744c2bbe5f9e2f2788469d2a402045aeb79eb5e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3744c2bbe5f9e2f2788469d2a402045aeb79eb5e", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-merge-master", "committedDate": "2020-02-25T08:54:19Z", "type": "commit"}, {"oid": "4c5542f61b593c4cd893b30f4d451cb443180e91", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4c5542f61b593c4cd893b30f4d451cb443180e91", "message": "Add pkg import codegen logic", "committedDate": "2020-02-25T12:24:10Z", "type": "commit"}, {"oid": "13b33837522834d09234c6859da3154698405bfa", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/13b33837522834d09234c6859da3154698405bfa", "message": "Add generating code for imports in test", "committedDate": "2020-02-25T12:24:52Z", "type": "commit"}, {"oid": "d948d0d710dd9df6c79f48bc5ece5c368c5811d6", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d948d0d710dd9df6c79f48bc5ece5c368c5811d6", "message": "Remove empty line", "committedDate": "2020-02-25T12:25:09Z", "type": "commit"}, {"oid": "17a900ed4720ab4e923272b7907b20afcb7b225c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/17a900ed4720ab4e923272b7907b20afcb7b225c", "message": "Merge pull request #21241 from Kishanthan/jbal-merge-master\n\nAdd pkg import codegen logic and synch up with master", "committedDate": "2020-02-25T12:45:36Z", "type": "commit"}, {"oid": "2058ae6dedaf20242126f4998df0b8903219c740", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2058ae6dedaf20242126f4998df0b8903219c740", "message": "Reorder adding argument to local var", "committedDate": "2020-02-26T05:59:46Z", "type": "commit"}, {"oid": "82b2aebc1f8dd564d643fdea00a23d2688c8e510", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/82b2aebc1f8dd564d643fdea00a23d2688c8e510", "message": "Fixes related to using correct local var and srevice type check", "committedDate": "2020-02-26T06:01:00Z", "type": "commit"}, {"oid": "99398de8cc357830d968f021797e7b29383277b3", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/99398de8cc357830d968f021797e7b29383277b3", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-merge-master", "committedDate": "2020-02-26T06:01:16Z", "type": "commit"}, {"oid": "c02d84d5eba3972ebeb856771eec2f49cdb6d495", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c02d84d5eba3972ebeb856771eec2f49cdb6d495", "message": "Merge pull request #21254 from Kishanthan/jbal-merge-master\n\nFixes related to using correct local var and srevice type check", "committedDate": "2020-02-26T06:25:37Z", "type": "commit"}, {"oid": "8d2f53103ecf353d62656bd6505a746d1db9dd1b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8d2f53103ecf353d62656bd6505a746d1db9dd1b", "message": "Add function param sorting logic", "committedDate": "2020-02-26T09:19:51Z", "type": "commit"}, {"oid": "2cb99d1794db9e5dca65906e9b7e3ea84c4f2542", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2cb99d1794db9e5dca65906e9b7e3ea84c4f2542", "message": "Fix constants code gen (#21269)", "committedDate": "2020-02-26T09:43:00Z", "type": "commit"}, {"oid": "30018f9045f4281db9271253886271b0ef6e911e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/30018f9045f4281db9271253886271b0ef6e911e", "message": "Fix transaction import code gen", "committedDate": "2020-02-27T06:05:20Z", "type": "commit"}, {"oid": "d3f724163061cafb2c6e1398d6812739b375a1f6", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d3f724163061cafb2c6e1398d6812739b375a1f6", "message": "Fix finite type loac constant value issue", "committedDate": "2020-02-27T06:14:10Z", "type": "commit"}, {"oid": "8272eff95a4e74af8452ffe37be61f2b56baedb9", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8272eff95a4e74af8452ffe37be61f2b56baedb9", "message": "Include imported standalone modules jars to jar cache", "committedDate": "2020-02-27T06:15:01Z", "type": "commit"}, {"oid": "57d73774039fc01967552f1ed87346f752e1b295", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/57d73774039fc01967552f1ed87346f752e1b295", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-merge-master", "committedDate": "2020-02-27T06:15:18Z", "type": "commit"}, {"oid": "2360f6dd539b38c59d30738adbe591bc825e6b8a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2360f6dd539b38c59d30738adbe591bc825e6b8a", "message": "Merge pull request #21312 from manuranga/jbal-be-rewrite\n\nFix transaction import code gen", "committedDate": "2020-02-27T06:22:20Z", "type": "commit"}, {"oid": "86d08e1fcf1d131fbe01c40644f618f8f183f72d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/86d08e1fcf1d131fbe01c40644f618f8f183f72d", "message": "Merge branch 'jbal-be-rewrite' of https://github.com/ballerina-platform/ballerina-lang into jbal-merge-master", "committedDate": "2020-02-27T06:25:05Z", "type": "commit"}, {"oid": "b5f32f68d8ff90abb650e0abf93e119e15059110", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b5f32f68d8ff90abb650e0abf93e119e15059110", "message": "Fix duplicate stop methods issue", "committedDate": "2020-02-27T06:42:51Z", "type": "commit"}, {"oid": "8dcd4e32f2f3d625c10fa94354d7eaea7a3003e5", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8dcd4e32f2f3d625c10fa94354d7eaea7a3003e5", "message": "Merge pull request #21316 from Kishanthan/jbal-merge-master\n\nAdd function param sorting logic and many other fixes", "committedDate": "2020-02-27T06:51:31Z", "type": "commit"}]}