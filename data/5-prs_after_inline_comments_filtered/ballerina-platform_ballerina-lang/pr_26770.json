{"pr_number": 26770, "pr_title": "Enable Intersection of error types", "pr_createdAt": "2020-11-05T08:31:30Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770", "timeline": [{"oid": "203d3d82376d11317765ce358c8b8c483977bca9", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/203d3d82376d11317765ce358c8b8c483977bca9", "message": "Add support for intersection of intersectionTypes\n\nLooping through multiple types to analyze if anything other than error type is present. If so log an error.\nIf type is valid, generate a potential intersection type using the previous intersection type and current error type.\nContinue this for all the types available in the intersection.", "committedDate": "2020-11-05T08:43:56Z", "type": "forcePushed"}, {"oid": "4827b7a5e8d2fb3bedeaf9dd47ff8cf495b94652", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4827b7a5e8d2fb3bedeaf9dd47ff8cf495b94652", "message": "Add support for distinct types\n\nCapture type ids of intersecting errors and populate them to a TypeId set.\nUse all the set of primary and secondary TypeIDs as secondary TypeIDs of the new intersection error type", "committedDate": "2020-11-07T16:22:27Z", "type": "forcePushed"}, {"oid": "4b743aa23518101d1c59b9a7baf5e8ef2538590b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4b743aa23518101d1c59b9a7baf5e8ef2538590b", "message": "Add support for errors with `BMapType` as detail type.\n\nSkipping since the resulting `BRecordType` is unsealed and has `anydata` as rest type.", "committedDate": "2020-11-07T17:05:32Z", "type": "forcePushed"}, {"oid": "95a9886b728d1b513e119e5458fd48005f986fd4", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/95a9886b728d1b513e119e5458fd48005f986fd4", "message": "Add support for map and map intersection\n\nRefactored the code to generify the getTypeIntersection method. It now supports `record & record` `record & map` and `map & map`. Earlier `record & record` for error detail was done in a method which was directly called from the method which creates the error intersection.", "committedDate": "2020-11-10T19:31:48Z", "type": "forcePushed"}, {"oid": "7aa2a1561579e350d7c8e6427ccff2dcb1366954", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7aa2a1561579e350d7c8e6427ccff2dcb1366954", "message": "Add support for map and map intersection\n\nRefactored the code to generify the getTypeIntersection method. It now supports `record & record` `record & map` and `map & map`. Earlier `record & record` for error detail was done in a method which was directly called from the method which creates the error intersection.", "committedDate": "2020-11-10T19:32:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE0Nzk2MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r521147961", "bodyText": "The compiler crashes here for\ntype Detail record {\n    string x;\n};\n\ntype DetailTwo record {\n    string x;\n    string y;\n};\n\ntype ErrorOne error<Detail>;\n\ntype ErrorTwo error<DetailTwo>;\n\ntype IntersectionError ErrorOne & ErrorTwo;\n\npublic function main() {\n    var err = IntersectionError(\"message\", x = \"x\", y = \"y\");\n}", "author": "MaryamZi", "createdAt": "2020-11-11T06:49:01Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SymbolEnter.java", "diffHunk": "@@ -397,6 +404,171 @@ private void defineConstructs(BLangPackage pkgNode, SymbolEnv pkgEnv) {\n                 .forEach(varSymbol -> varSymbol.tag = SymTag.ENDPOINT);\n     }\n \n+    private void defineErrorIntersection(SymbolEnv env) {\n+        for (BLangNode typeDescriptor : this.errorIntersectionTypes) {\n+            BLangTypeDefinition typeDefinition = (BLangTypeDefinition) typeDescriptor;\n+\n+            boolean isDistinctType = isDistinctFlagPresent(typeDefinition);\n+            boolean isPublicType = typeDefinition.flagSet.contains(Flag.PUBLIC);\n+            Set<BTypeIdSet.BTypeId> secondaryTypeIds = new HashSet<>();\n+\n+            BLangIntersectionTypeNode intersectionTypeNode = (BLangIntersectionTypeNode) typeDefinition.typeNode;\n+            List<BLangType> constituentTypes = intersectionTypeNode.constituentTypeNodes;\n+\n+            BLangType bLangTypeOne = constituentTypes.get(0);\n+            BType typeOne = symResolver.resolveTypeNode(bLangTypeOne, env);\n+            if (typeOne.tag != TypeTags.ERROR && typeOne.tag != TypeTags.READONLY) {\n+                // TODO: log error for intersection type with other types.\n+                continue;\n+            }\n+\n+            BLangType bLangTypeTwo = constituentTypes.get(1);\n+            BType typeTwo = symResolver.resolveTypeNode(bLangTypeTwo, env);\n+            if (typeTwo.tag != TypeTags.ERROR && typeTwo.tag != TypeTags.READONLY) {\n+                // TODO: log error for intersection type with other types.\n+                continue;\n+            }\n+\n+            // Collecting typeIds.\n+            if (typeOne.tag != TypeTags.READONLY) {\n+                populateSecondaryTypeIdSet(secondaryTypeIds, (BErrorType) typeOne);\n+            }\n+            if (typeTwo.tag != TypeTags.READONLY) {\n+                populateSecondaryTypeIdSet(secondaryTypeIds, (BErrorType) typeTwo);\n+            }\n+\n+            BType potentialIntersectionType = types.getTypeIntersection(typeOne, typeTwo);\n+\n+            boolean isValidIntersection = true;\n+            for (int i = 2; i < constituentTypes.size(); i++) {\n+                BLangType bLangType = constituentTypes.get(i);\n+                BType bType = symResolver.resolveTypeNode(bLangType, env);\n+\n+                if (bType.getKind() != TypeKind.ERROR && typeTwo.tag != TypeTags.READONLY) {\n+                    // TODO: Log error for invalid intersection\n+                    isValidIntersection = false;\n+                    break;\n+                }\n+\n+                if (bType.tag != TypeTags.READONLY) {\n+                    populateSecondaryTypeIdSet(secondaryTypeIds, (BErrorType) bType);\n+                }\n+\n+                potentialIntersectionType = types.getTypeIntersection(potentialIntersectionType, bType);\n+                if (potentialIntersectionType == symTable.semanticError) {\n+                    // TODO: Log invalid intersection\n+                    isValidIntersection = false;\n+                    break;\n+                }\n+            }\n+\n+            if (!isValidIntersection) {\n+                continue;\n+            }\n+\n+            if (isDistinctType) {\n+                ((BErrorType) potentialIntersectionType).typeIdSet = BTypeIdSet.from(\n+                        potentialIntersectionType.tsymbol.pkgID, typeDefinition.name.value, isPublicType,\n+                        secondaryTypeIds);\n+            }\n+\n+            LinkedHashSet<BType> constituentBTypes = new LinkedHashSet<>() {{\n+                add(typeOne);\n+                add(typeTwo);\n+            }};\n+            BIntersectionType intersectionType = definePotentialIntersectionType((BErrorType) potentialIntersectionType,\n+                                                                                 typeDefinition, constituentBTypes);\n+            typeDefinition.symbol = intersectionType.tsymbol;\n+            typeDefinition.typeNode.type = intersectionType;\n+        }\n+    }\n+\n+    private void populateSecondaryTypeIdSet(Set<BTypeIdSet.BTypeId> secondaryTypeIds, BErrorType typeOne) {\n+        secondaryTypeIds.addAll(typeOne.typeIdSet.primary);\n+        secondaryTypeIds.addAll(typeOne.typeIdSet.secondary);\n+    }\n+\n+    private BIntersectionType definePotentialIntersectionType(BErrorType potentialIntersectionType,\n+                                                              BLangTypeDefinition typeDefinition,\n+                                                              LinkedHashSet<BType> constituentBTypes) {\n+\n+        BSymbol owner = potentialIntersectionType.tsymbol.owner;\n+        PackageID pkgId = potentialIntersectionType.tsymbol.pkgID;\n+        SymbolEnv pkgEnv = symTable.pkgEnvMap.get(owner);\n+\n+        BLangTypeDefinition detailTypeDef = defineErrorDetailRecord((BRecordType) potentialIntersectionType.detailType,\n+                                                                    typeDefinition.pos, pkgEnv);\n+        defineErrorType(potentialIntersectionType, detailTypeDef, pkgEnv, typeDefinition);\n+        return defineErrorIntersectionType(potentialIntersectionType, typeDefinition, constituentBTypes, pkgId, owner,\n+                                           pkgEnv);\n+    }\n+\n+    private BLangTypeDefinition defineErrorDetailRecord(BRecordType detailRecord, Location pos, SymbolEnv env) {\n+        // TODO: need to support map intersection.\n+        BRecordTypeSymbol detailRecordSymbol = (BRecordTypeSymbol) detailRecord.tsymbol;\n+        detailRecordSymbol.scope.define(names.fromString(", "originalCommit": "7aa2a1561579e350d7c8e6427ccff2dcb1366954", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ4MzQyOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r521483428", "bodyText": "Fixed", "author": "dulvinw", "createdAt": "2020-11-11T16:32:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE0Nzk2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE1NjA4Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r521156087", "bodyText": "Any specific reason to check kind instead of tag here?", "author": "MaryamZi", "createdAt": "2020-11-11T07:01:53Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SymbolEnter.java", "diffHunk": "@@ -397,6 +406,170 @@ private void defineConstructs(BLangPackage pkgNode, SymbolEnv pkgEnv) {\n                 .forEach(varSymbol -> varSymbol.tag = SymTag.ENDPOINT);\n     }\n \n+    private void defineErrorIntersection(SymbolEnv env) {\n+        for (BLangNode typeDescriptor : this.errorIntersectionTypes) {\n+            BLangTypeDefinition typeDefinition = (BLangTypeDefinition) typeDescriptor;\n+\n+            boolean isDistinctType = isDistinctFlagPresent(typeDefinition);\n+            boolean isPublicType = typeDefinition.flagSet.contains(Flag.PUBLIC);\n+            Set<BTypeIdSet.BTypeId> secondaryTypeIds = new HashSet<>();\n+\n+            BLangIntersectionTypeNode intersectionTypeNode = (BLangIntersectionTypeNode) typeDefinition.typeNode;\n+            List<BLangType> constituentTypes = intersectionTypeNode.constituentTypeNodes;\n+\n+            BLangType bLangTypeOne = constituentTypes.get(0);\n+            BType typeOne = symResolver.resolveTypeNode(bLangTypeOne, env);\n+            if (typeOne.tag != TypeTags.ERROR && typeOne.tag != TypeTags.READONLY) {\n+                dlog.error(bLangTypeOne.pos, INVALID_ERROR_INTERSECTION, bLangTypeOne);\n+                continue;\n+            }\n+\n+            BLangType bLangTypeTwo = constituentTypes.get(1);\n+            BType typeTwo = symResolver.resolveTypeNode(bLangTypeTwo, env);\n+            if (typeTwo.tag != TypeTags.ERROR && typeTwo.tag != TypeTags.READONLY) {\n+                dlog.error(bLangTypeTwo.pos, INVALID_ERROR_INTERSECTION, bLangTypeTwo);\n+                continue;\n+            }\n+\n+            // Collecting typeIds.\n+            if (typeOne.tag != TypeTags.READONLY) {\n+                populateSecondaryTypeIdSet(secondaryTypeIds, (BErrorType) typeOne);\n+            }\n+            if (typeTwo.tag != TypeTags.READONLY) {\n+                populateSecondaryTypeIdSet(secondaryTypeIds, (BErrorType) typeTwo);\n+            }\n+\n+            BType potentialIntersectionType = types.getTypeIntersection(typeOne, typeTwo);\n+\n+            boolean isValidIntersection = true;\n+            for (int i = 2; i < constituentTypes.size(); i++) {\n+                BLangType bLangType = constituentTypes.get(i);\n+                BType bType = symResolver.resolveTypeNode(bLangType, env);\n+\n+                if (bType.getKind() != TypeKind.ERROR && typeTwo.tag != TypeTags.READONLY) {", "originalCommit": "10014b1a8708eeb074e7e82463fb840ab008faf6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ4NjczOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r521486738", "bodyText": "Fixed", "author": "dulvinw", "createdAt": "2020-11-11T16:36:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE1NjA4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE1Nzc0OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r521157748", "bodyText": "In this case, is it actually potential if we get to this point?", "author": "MaryamZi", "createdAt": "2020-11-11T07:06:43Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SymbolEnter.java", "diffHunk": "@@ -397,6 +406,170 @@ private void defineConstructs(BLangPackage pkgNode, SymbolEnv pkgEnv) {\n                 .forEach(varSymbol -> varSymbol.tag = SymTag.ENDPOINT);\n     }\n \n+    private void defineErrorIntersection(SymbolEnv env) {\n+        for (BLangNode typeDescriptor : this.errorIntersectionTypes) {\n+            BLangTypeDefinition typeDefinition = (BLangTypeDefinition) typeDescriptor;\n+\n+            boolean isDistinctType = isDistinctFlagPresent(typeDefinition);\n+            boolean isPublicType = typeDefinition.flagSet.contains(Flag.PUBLIC);\n+            Set<BTypeIdSet.BTypeId> secondaryTypeIds = new HashSet<>();\n+\n+            BLangIntersectionTypeNode intersectionTypeNode = (BLangIntersectionTypeNode) typeDefinition.typeNode;\n+            List<BLangType> constituentTypes = intersectionTypeNode.constituentTypeNodes;\n+\n+            BLangType bLangTypeOne = constituentTypes.get(0);\n+            BType typeOne = symResolver.resolveTypeNode(bLangTypeOne, env);\n+            if (typeOne.tag != TypeTags.ERROR && typeOne.tag != TypeTags.READONLY) {\n+                dlog.error(bLangTypeOne.pos, INVALID_ERROR_INTERSECTION, bLangTypeOne);\n+                continue;\n+            }\n+\n+            BLangType bLangTypeTwo = constituentTypes.get(1);\n+            BType typeTwo = symResolver.resolveTypeNode(bLangTypeTwo, env);\n+            if (typeTwo.tag != TypeTags.ERROR && typeTwo.tag != TypeTags.READONLY) {\n+                dlog.error(bLangTypeTwo.pos, INVALID_ERROR_INTERSECTION, bLangTypeTwo);\n+                continue;\n+            }\n+\n+            // Collecting typeIds.\n+            if (typeOne.tag != TypeTags.READONLY) {\n+                populateSecondaryTypeIdSet(secondaryTypeIds, (BErrorType) typeOne);\n+            }\n+            if (typeTwo.tag != TypeTags.READONLY) {\n+                populateSecondaryTypeIdSet(secondaryTypeIds, (BErrorType) typeTwo);\n+            }\n+\n+            BType potentialIntersectionType = types.getTypeIntersection(typeOne, typeTwo);\n+\n+            boolean isValidIntersection = true;\n+            for (int i = 2; i < constituentTypes.size(); i++) {\n+                BLangType bLangType = constituentTypes.get(i);\n+                BType bType = symResolver.resolveTypeNode(bLangType, env);\n+\n+                if (bType.getKind() != TypeKind.ERROR && typeTwo.tag != TypeTags.READONLY) {\n+                    dlog.error(bLangType.pos, INVALID_ERROR_INTERSECTION, bLangType);\n+                    isValidIntersection = false;\n+                    break;\n+                }\n+\n+                if (bType.tag != TypeTags.READONLY) {\n+                    populateSecondaryTypeIdSet(secondaryTypeIds, (BErrorType) bType);\n+                }\n+\n+                potentialIntersectionType = types.getTypeIntersection(potentialIntersectionType, bType);\n+                if (potentialIntersectionType == symTable.semanticError) {\n+                    dlog.error(typeDefinition.typeNode.pos, INVALID_INTERSECTION_TYPE, typeDefinition.typeNode);\n+                    isValidIntersection = false;\n+                    break;\n+                }\n+            }\n+\n+            if (!isValidIntersection) {\n+                continue;\n+            }\n+\n+            if (isDistinctType) {\n+                ((BErrorType) potentialIntersectionType).typeIdSet = BTypeIdSet.from(\n+                        potentialIntersectionType.tsymbol.pkgID, typeDefinition.name.value, isPublicType,\n+                        secondaryTypeIds);\n+            }\n+\n+            LinkedHashSet<BType> constituentBTypes = new LinkedHashSet<>() {{\n+                add(typeOne);\n+                add(typeTwo);\n+            }};\n+            BIntersectionType intersectionType = definePotentialIntersectionType((BErrorType) potentialIntersectionType,\n+                                                                                 typeDefinition, constituentBTypes);\n+            typeDefinition.symbol = intersectionType.tsymbol;\n+            typeDefinition.typeNode.type = intersectionType;\n+        }\n+    }\n+\n+    private void populateSecondaryTypeIdSet(Set<BTypeIdSet.BTypeId> secondaryTypeIds, BErrorType typeOne) {\n+        secondaryTypeIds.addAll(typeOne.typeIdSet.primary);\n+        secondaryTypeIds.addAll(typeOne.typeIdSet.secondary);\n+    }\n+\n+    private BIntersectionType definePotentialIntersectionType(BErrorType potentialIntersectionType,", "originalCommit": "10014b1a8708eeb074e7e82463fb840ab008faf6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ4NTQzMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r521485433", "bodyText": "fixed", "author": "dulvinw", "createdAt": "2020-11-11T16:34:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE1Nzc0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE2Mzk0OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r521163949", "bodyText": "Crashes when potentialIntersectionType is symTable.semanticError due to one error type being invalid.\ntype Detail record {| // closed, invalid\n    string x;\n|};\n\ntype DetailTwo record {\n    string y;\n};\n\ntype ErrorOne error<Detail>;\n\ntype ErrorTwo error<DetailTwo>;\n\ntype IntersectionError ErrorOne & ErrorTwo;\n[2020-11-11 12:52:48,270] SEVERE {b7a.log.crash} - class org.wso2.ballerinalang.compiler.semantics.model.types.BType cannot be cast to class org.wso2.ballerinalang.compiler.semantics.model.types.BErrorType (org.wso2.ballerinalang.compiler.semantics.model.types.BType and org.wso2.ballerinalang.compiler.semantics.model.types.BErrorType are in unnamed module of loader 'app') \njava.lang.ClassCastException: class org.wso2.ballerinalang.compiler.semantics.model.types.BType cannot be cast to class org.wso2.ballerinalang.compiler.semantics.model.types.BErrorType (org.wso2.ballerinalang.compiler.semantics.model.types.BType and org.wso2.ballerinalang.compiler.semantics.model.types.BErrorType are in unnamed module of loader 'app')\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SymbolEnter.defineErrorIntersection(SymbolEnter.java:479)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SymbolEnter.defineConstructs(SymbolEnter.java:373)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SymbolEnter.visit(SymbolEnter.java:287)\n\tat org.wso2.ballerinalang.compiler.tree.BLangPackage.accept(BLangPackage.java:163)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SymbolEnter.defineNode(SymbolEnter.java:249)\n\tat org.wso2.ballerinalang.compiler.semantics.analyzer.SymbolEnter.definePackage(SymbolEnter.java:242)\n\tat org.wso2.ballerinalang.compiler.PackageLoader.define(PackageLoader.java:464)\n\tat org.wso2.ballerinalang.compiler.PackageLoader.loadEntryPackage(PackageLoader.java:375)\n\tat org.wso2.ballerinalang.compiler.Compiler.compilePackages(Compiler.java:166)\n\tat org.wso2.ballerinalang.compiler.Compiler.compilePackage(Compiler.java:221)\n\tat org.wso2.ballerinalang.compiler.Compiler.compile(Compiler.java:101)\n\tat org.wso2.ballerinalang.compiler.Compiler.build(Compiler.java:109)\n\tat org.ballerinalang.packerina.task.CompileTask.execute(CompileTask.java:55)\n\tat org.ballerinalang.packerina.TaskExecutor.executeTasks(TaskExecutor.java:38)\n\tat org.ballerinalang.packerina.cmd.RunCommand.execute(RunCommand.java:297)\n\tat java.base/java.util.Optional.ifPresent(Optional.java:183)\n\tat org.ballerinalang.tool.Main.main(Main.java:57)", "author": "MaryamZi", "createdAt": "2020-11-11T07:23:45Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SymbolEnter.java", "diffHunk": "@@ -397,6 +406,170 @@ private void defineConstructs(BLangPackage pkgNode, SymbolEnv pkgEnv) {\n                 .forEach(varSymbol -> varSymbol.tag = SymTag.ENDPOINT);\n     }\n \n+    private void defineErrorIntersection(SymbolEnv env) {\n+        for (BLangNode typeDescriptor : this.errorIntersectionTypes) {\n+            BLangTypeDefinition typeDefinition = (BLangTypeDefinition) typeDescriptor;\n+\n+            boolean isDistinctType = isDistinctFlagPresent(typeDefinition);\n+            boolean isPublicType = typeDefinition.flagSet.contains(Flag.PUBLIC);\n+            Set<BTypeIdSet.BTypeId> secondaryTypeIds = new HashSet<>();\n+\n+            BLangIntersectionTypeNode intersectionTypeNode = (BLangIntersectionTypeNode) typeDefinition.typeNode;\n+            List<BLangType> constituentTypes = intersectionTypeNode.constituentTypeNodes;\n+\n+            BLangType bLangTypeOne = constituentTypes.get(0);\n+            BType typeOne = symResolver.resolveTypeNode(bLangTypeOne, env);\n+            if (typeOne.tag != TypeTags.ERROR && typeOne.tag != TypeTags.READONLY) {\n+                dlog.error(bLangTypeOne.pos, INVALID_ERROR_INTERSECTION, bLangTypeOne);\n+                continue;\n+            }\n+\n+            BLangType bLangTypeTwo = constituentTypes.get(1);\n+            BType typeTwo = symResolver.resolveTypeNode(bLangTypeTwo, env);\n+            if (typeTwo.tag != TypeTags.ERROR && typeTwo.tag != TypeTags.READONLY) {\n+                dlog.error(bLangTypeTwo.pos, INVALID_ERROR_INTERSECTION, bLangTypeTwo);\n+                continue;\n+            }\n+\n+            // Collecting typeIds.\n+            if (typeOne.tag != TypeTags.READONLY) {\n+                populateSecondaryTypeIdSet(secondaryTypeIds, (BErrorType) typeOne);\n+            }\n+            if (typeTwo.tag != TypeTags.READONLY) {\n+                populateSecondaryTypeIdSet(secondaryTypeIds, (BErrorType) typeTwo);\n+            }\n+\n+            BType potentialIntersectionType = types.getTypeIntersection(typeOne, typeTwo);\n+\n+            boolean isValidIntersection = true;\n+            for (int i = 2; i < constituentTypes.size(); i++) {\n+                BLangType bLangType = constituentTypes.get(i);\n+                BType bType = symResolver.resolveTypeNode(bLangType, env);\n+\n+                if (bType.getKind() != TypeKind.ERROR && typeTwo.tag != TypeTags.READONLY) {\n+                    dlog.error(bLangType.pos, INVALID_ERROR_INTERSECTION, bLangType);\n+                    isValidIntersection = false;\n+                    break;\n+                }\n+\n+                if (bType.tag != TypeTags.READONLY) {\n+                    populateSecondaryTypeIdSet(secondaryTypeIds, (BErrorType) bType);\n+                }\n+\n+                potentialIntersectionType = types.getTypeIntersection(potentialIntersectionType, bType);\n+                if (potentialIntersectionType == symTable.semanticError) {\n+                    dlog.error(typeDefinition.typeNode.pos, INVALID_INTERSECTION_TYPE, typeDefinition.typeNode);\n+                    isValidIntersection = false;\n+                    break;\n+                }\n+            }\n+\n+            if (!isValidIntersection) {\n+                continue;\n+            }\n+\n+            if (isDistinctType) {\n+                ((BErrorType) potentialIntersectionType).typeIdSet = BTypeIdSet.from(\n+                        potentialIntersectionType.tsymbol.pkgID, typeDefinition.name.value, isPublicType,\n+                        secondaryTypeIds);\n+            }\n+\n+            LinkedHashSet<BType> constituentBTypes = new LinkedHashSet<>() {{\n+                add(typeOne);\n+                add(typeTwo);\n+            }};\n+            BIntersectionType intersectionType = definePotentialIntersectionType((BErrorType) potentialIntersectionType,", "originalCommit": "10014b1a8708eeb074e7e82463fb840ab008faf6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ4NDU1Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r521484552", "bodyText": "Fixed", "author": "dulvinw", "createdAt": "2020-11-11T16:33:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE2Mzk0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE4OTQ0MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r521189441", "bodyText": "Don't we have to validate/fix types for already specified fields with the same name?\nLeads to issues like #26770 (comment)\nand\ntype Detail record {\n    string x;\n};\n\ntype DetailTwo record {|\n    int x?;\n    string...;\n|};\n\ntype ErrorOne error<Detail>;\n\ntype ErrorTwo error<DetailTwo>;\n\ntype IntersectionError ErrorOne & ErrorTwo;\n\npublic function main() {\n    var err1 = IntersectionError(\"message\", x = \"x\"); // invalid arg type in error detail field 'x', expected 'int', found 'string'\n    var err2 = IntersectionError(\"message\", x = 1); // works\n}", "author": "MaryamZi", "createdAt": "2020-11-11T08:21:18Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -3129,6 +3168,131 @@ BType getTypeIntersection(BType lhsType, BType rhsType) {\n         }\n     }\n \n+    private BType getIntersectionForErrorTypes(BType lhsType, BType rhsType) {\n+\n+        BType detailTypeOne = ((BErrorType) lhsType).detailType;\n+        BType detailTypeTwo = ((BErrorType) rhsType).detailType;\n+\n+        if (isSealedRecord(detailTypeOne) || isSealedRecord(detailTypeTwo)) {\n+            return symTable.semanticError;\n+        }\n+\n+        SymbolEnv prevEnv = this.env;\n+        this.env = symTable.pkgEnvMap.get(lhsType.tsymbol.owner);\n+\n+        BType detailIntersectionType = getTypeIntersection(detailTypeOne, detailTypeTwo);\n+        if (detailIntersectionType == symTable.semanticError) {\n+            return symTable.semanticError;\n+        }\n+\n+        BErrorType intersectionErrorType = createErrorType(lhsType, rhsType, detailIntersectionType);\n+        this.env = prevEnv;\n+\n+        return intersectionErrorType;\n+    }\n+\n+    private BType createRecordIntersection(BType recordTypeOne, BType recordTypeTwo) {\n+\n+        BRecordType recordType = createAnonymousRecord();\n+\n+        populateRecordFields(recordType, recordTypeOne);\n+        populateRecordFields(recordType, recordTypeTwo);\n+\n+        recordType.restFieldType = getTypeIntersection(((BRecordType) recordTypeOne).restFieldType,\n+                                                       ((BRecordType) recordTypeTwo).restFieldType);\n+\n+        if (recordType.restFieldType == symTable.semanticError) {\n+            return symTable.semanticError;\n+        }\n+\n+        return recordType;\n+    }\n+\n+    private BRecordType createAnonymousRecord() {\n+        EnumSet<Flag> flags = EnumSet.of(Flag.PUBLIC, Flag.ANONYMOUS);\n+        BRecordTypeSymbol recordSymbol = Symbols.createRecordSymbol(Flags.asMask(flags), Names.EMPTY,\n+                                                                                this.env.enclPkg.packageID, null,\n+                                                                                this.env.scope.owner, null, VIRTUAL);\n+        recordSymbol.name = names.fromString(\n+                anonymousModelHelper.getNextAnonymousTypeKey(this.env.enclPkg.packageID));\n+        BInvokableType bInvokableType = new BInvokableType(new ArrayList<>(), symTable.nilType, null);\n+        BInvokableSymbol initFuncSymbol = Symbols.createFunctionSymbol(\n+                Flags.PUBLIC, Names.EMPTY, this.env.enclPkg.symbol.pkgID, bInvokableType, this.env.scope.owner, false,\n+                symTable.builtinPos, VIRTUAL);\n+        initFuncSymbol.retType = symTable.nilType;\n+        recordSymbol.initializerFunc = new BAttachedFunction(Names.INIT_FUNCTION_SUFFIX, initFuncSymbol,\n+                                                                         bInvokableType, symTable.builtinPos);\n+        recordSymbol.scope = new Scope(recordSymbol);\n+\n+        BRecordType recordType = new BRecordType(recordSymbol);\n+        recordType.tsymbol = recordSymbol;\n+        recordSymbol.type = recordType;\n+\n+        return recordType;\n+    }\n+\n+    private BType createRecordAndMapIntersection(BType type, BType mapType) {\n+        BRecordType intersectionRecord = createAnonymousRecord();\n+        populateRecordFields(intersectionRecord, type);\n+        intersectionRecord.restFieldType = getRestFieldIntersectionType(type, (BMapType) mapType);\n+\n+        if (intersectionRecord.restFieldType == symTable.semanticError) {\n+            return symTable.semanticError;\n+        }\n+\n+        return intersectionRecord;\n+    }\n+\n+    private BType getRestFieldIntersectionType(BType type, BMapType mapType) {\n+        if (type.tag == TypeTags.RECORD) {\n+            return getTypeIntersection(((BRecordType) type).restFieldType, mapType.constraint);\n+        } else {\n+            return getTypeIntersection(((BMapType) type).constraint, mapType.constraint);\n+        }\n+    }\n+\n+    private BErrorType createErrorType(BType lhsType, BType rhsType, BType detailType) {\n+        BErrorTypeSymbol errorTypeSymbol = Symbols.createErrorSymbol(lhsType.flags, Names.EMPTY,\n+                                                                     this.env.enclPkg.symbol.pkgID, null,\n+                                                                     this.env.scope.owner, null, VIRTUAL);\n+        errorTypeSymbol.flags |= rhsType.flags;\n+        BErrorType errorType = new BErrorType(errorTypeSymbol, detailType);\n+        errorType.flags |= errorTypeSymbol.flags;\n+        errorTypeSymbol.type = errorType;\n+        symResolver.markParameterizedType(errorType, detailType);\n+        errorType.typeIdSet = BTypeIdSet.emptySet();\n+\n+        return errorType;\n+    }\n+\n+    private void populateRecordFields(BRecordType recordType, BType originalType) {\n+        BTypeSymbol intersectionRecordSymbol = recordType.tsymbol;\n+        // If the detail type is BMapType simply ignore since the resulting detail type has `anydata` as rest type.\n+        if (originalType.getKind() != TypeKind.RECORD) {\n+            return;\n+        }\n+        BRecordType originalRecordType = (BRecordType) originalType;\n+        LinkedHashMap<String, BField> fields = new LinkedHashMap<>();\n+        for (BField origField : originalRecordType.fields.values()) {\n+            org.wso2.ballerinalang.compiler.util.Name origFieldName = origField.name;\n+            BType recordFieldType = origField.type;\n+            BVarSymbol recordFieldSymbol = new BVarSymbol(origField.symbol.flags, origFieldName,\n+                                                          this.env.enclPkg.packageID, recordFieldType,\n+                                                          intersectionRecordSymbol, origField.pos, SOURCE);\n+            if (recordFieldType.tag == TypeTags.INVOKABLE && recordFieldType.tsymbol != null) {\n+                BInvokableTypeSymbol tsymbol = (BInvokableTypeSymbol) recordFieldType.tsymbol;\n+                BInvokableSymbol invokableSymbol = (BInvokableSymbol) recordFieldSymbol;\n+                invokableSymbol.params = tsymbol.params;\n+                invokableSymbol.restParam = tsymbol.restParam;\n+                invokableSymbol.retType = tsymbol.returnType;\n+                invokableSymbol.flags = tsymbol.flags;\n+            }\n+            String nameString = origFieldName.value;\n+            fields.put(nameString, new BField(origFieldName, null, recordFieldSymbol));\n+        }\n+        recordType.fields.putAll(fields);", "originalCommit": "10014b1a8708eeb074e7e82463fb840ab008faf6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTIyMTYzNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r521221634", "bodyText": "I think I should do an additional check to handle this situation. And it should be an invalid intersection in that case right?", "author": "dulvinw", "createdAt": "2020-11-11T09:20:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE4OTQ0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM3Mjg4NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r521372884", "bodyText": "Yeah, it's invalid.\nI think if the field is there we should check for the intersection between the already present type and this new type, and\n\nmake it an error if there is no intersection\nif there is an intersection - set the intersection type as the field type", "author": "MaryamZi", "createdAt": "2020-11-11T13:53:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE4OTQ0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ4NTE3MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r521485171", "bodyText": "Fixed", "author": "dulvinw", "createdAt": "2020-11-11T16:34:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTE4OTQ0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM1NjA5MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r521356091", "bodyText": "Given that Types.java is like a stateless util class I'm not sure if we should maintain the env like this.\nRaised the same in @KavinduZoysa's PR too - https://github.com/ballerina-platform/ballerina-lang/pull/26144/files#r520295821.\nI think we'll have to refactor getTypeIntersection to accept env too.\nAlso, regarding the RHS here, IMO getting the env of lhsType.tsymbol.owner won't quite be the correct approach if lhsType is from an imported module, right? Shouldn't it always be the current module?", "author": "MaryamZi", "createdAt": "2020-11-11T13:26:05Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -3129,6 +3168,131 @@ BType getTypeIntersection(BType lhsType, BType rhsType) {\n         }\n     }\n \n+    private BType getIntersectionForErrorTypes(BType lhsType, BType rhsType) {\n+\n+        BType detailTypeOne = ((BErrorType) lhsType).detailType;\n+        BType detailTypeTwo = ((BErrorType) rhsType).detailType;\n+\n+        if (isSealedRecord(detailTypeOne) || isSealedRecord(detailTypeTwo)) {\n+            return symTable.semanticError;\n+        }\n+\n+        SymbolEnv prevEnv = this.env;\n+        this.env = symTable.pkgEnvMap.get(lhsType.tsymbol.owner);", "originalCommit": "10014b1a8708eeb074e7e82463fb840ab008faf6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ1NzYwOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r521457608", "bodyText": "I think you're correct regarding imported modules issue. If we refactor getTypeIntersection it wouldn't be an issue. Would overloading getTypeIntersection work? WDYT?", "author": "dulvinw", "createdAt": "2020-11-11T15:56:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM1NjA5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ2MjQ5NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r521462494", "bodyText": "With this change, we would be allowing intersections that were not previously allowed, right? e.g., record and map intersections. This would mean that in other places like type narrowing in the type guard also we will be allowing these intersections. So it is possible that we would need the env even then.\nMentioned a similar scenario in https://github.com/ballerina-platform/ballerina-lang/pull/26144/files#r521415590.\nUnless there are some specific cases where we know we wouldn't need the env (and can pass null), I think we should mandate passing the env.", "author": "MaryamZi", "createdAt": "2020-11-11T16:03:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM1NjA5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUwNjI1MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r521506250", "bodyText": "Cool. Will go through the usages and figure out what I can do. Thanks for your input :)", "author": "dulvinw", "createdAt": "2020-11-11T17:05:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM1NjA5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU2NDU0MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r521564541", "bodyText": "Fixed", "author": "dulvinw", "createdAt": "2020-11-11T18:43:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM1NjA5MQ=="}], "type": "inlineReview"}, {"oid": "60e4a6cc7608d133e22a106c152f0a3f4458b076", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/60e4a6cc7608d133e22a106c152f0a3f4458b076", "message": "Add tests", "committedDate": "2020-11-11T17:18:52Z", "type": "forcePushed"}, {"oid": "1d6bfcf7949f557094616fdaf12489d4c4af2715", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1d6bfcf7949f557094616fdaf12489d4c4af2715", "message": "Add tests", "committedDate": "2020-11-11T18:24:08Z", "type": "forcePushed"}, {"oid": "b73ba5cf64fb89f545ffbe48d4286495bbc0890b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b73ba5cf64fb89f545ffbe48d4286495bbc0890b", "message": "Refactor `getTypeIntersection`\n\nRefactored the `getTypeIntersection` method to accept the package env as a parameter.\nThis was done since the Types class was a stateless class and having a state variable such as env was violating this. Hence we had to modify the method to accept the environment as a parameter.", "committedDate": "2020-11-11T18:51:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzkxODY0Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r523918642", "bodyText": "Is this method name correct? IMO, under this condition we cannot call createRecordAndMapIntersection, we need to call another method to get the intersection between two maps. WDYT?", "author": "KavinduZoysa", "createdAt": "2020-11-16T06:19:51Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -3109,6 +3124,31 @@ BType getTypeIntersection(BType lhsType, BType rhsType) {\n                 }\n             } else if (type.tag == TypeTags.NULL_SET) {\n                 return type;\n+            } else if (type.tag == TypeTags.ERROR && lhsType.tag == TypeTags.ERROR) {\n+                BType intersectionType = getIntersectionForErrorTypes(lhsType, type, pkgEnv);\n+                if (intersectionType != symTable.semanticError) {\n+                    return intersectionType;\n+                }\n+            } else if (type.tag == TypeTags.RECORD && lhsType.tag == TypeTags.RECORD) {\n+                BType intersectionType = createRecordIntersection(lhsType, type, pkgEnv);\n+                if (intersectionType != symTable.semanticError) {\n+                    return intersectionType;\n+                }\n+            } else if (type.tag == TypeTags.MAP && lhsType.tag == TypeTags.RECORD) {\n+                BType intersectionType = createRecordAndMapIntersection(lhsType, type, pkgEnv);\n+                if (intersectionType != symTable.semanticError) {\n+                    return intersectionType;\n+                }\n+            } else if (type.tag == TypeTags.RECORD && lhsType.tag == TypeTags.MAP) {\n+                BType intersectionType = createRecordAndMapIntersection(type, lhsType, pkgEnv);\n+                if (intersectionType != symTable.semanticError) {\n+                    return intersectionType;\n+                }\n+            } else if (type.tag == TypeTags.MAP && lhsType.tag == TypeTags.MAP) {\n+                BType intersectionType = createRecordAndMapIntersection(type, lhsType, pkgEnv);", "originalCommit": "b73ba5cf64fb89f545ffbe48d4286495bbc0890b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjcwMTE0Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r526701143", "bodyText": "The idea was to create a same method to get the interesctions of records, as well as maps. I too feel this is kinda confusing. I'll check how I can improve this.", "author": "dulvinw", "createdAt": "2020-11-19T09:10:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzkxODY0Mg=="}], "type": "inlineReview"}, {"oid": "7090f7b80f57772b9560abd7a94188af12219aa4", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7090f7b80f57772b9560abd7a94188af12219aa4", "message": "Fix int long conversion of flags after master change", "committedDate": "2020-11-16T17:26:55Z", "type": "forcePushed"}, {"oid": "7bed1610dae0471055e6439c86b0117d7dc3aa35", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7bed1610dae0471055e6439c86b0117d7dc3aa35", "message": "Sync with master\n\nMoved the new error type to `DiagnosticErrorCode`", "committedDate": "2020-11-20T10:57:39Z", "type": "forcePushed"}, {"oid": "dd25fdc25f1530a37fa4495ba1a09ff8093b9384", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/dd25fdc25f1530a37fa4495ba1a09ff8093b9384", "message": "Sync with master\n\nMoved the new error type to `DiagnosticErrorCode`", "committedDate": "2020-11-20T11:05:26Z", "type": "forcePushed"}, {"oid": "8f901207cf02c454972a63eae82c3831ca403106", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8f901207cf02c454972a63eae82c3831ca403106", "message": "Sync with master\n\nMoved the new error type to `DiagnosticErrorCode`", "committedDate": "2020-11-20T11:12:26Z", "type": "forcePushed"}, {"oid": "cca340d89bf2a4bcf1e9e09f867ff0ee54ba0ee9", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/cca340d89bf2a4bcf1e9e09f867ff0ee54ba0ee9", "message": "Sync with master\n\nMoved the new error type to `DiagnosticErrorCode`", "committedDate": "2020-11-23T04:00:56Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTU4MzczNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r531583735", "bodyText": "Wouldn't passing the current env work? Please check other usage too.", "author": "MaryamZi", "createdAt": "2020-11-27T12:49:41Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SemanticAnalyzer.java", "diffHunk": "@@ -2449,7 +2449,8 @@ public void visit(BLangListMatchPattern listMatchPattern) {\n             matchPatternType.restType = restType;\n         }\n \n-        listMatchPattern.type = types.resolvePatternTypeFromMatchExpr(listMatchExpr, matchPatternType);\n+        SymbolEnv pkgEnv = symTable.pkgEnvMap.get(env.enclPkg.symbol);\n+        listMatchPattern.type = types.resolvePatternTypeFromMatchExpr(listMatchExpr, matchPatternType, pkgEnv);", "originalCommit": "cca340d89bf2a4bcf1e9e09f867ff0ee54ba0ee9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYxNzYzNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r531617636", "bodyText": "Would this approach with in-line type-descriptors? Shouldn't we define these errors in the relevant scope, instead of making them module-level type definitions?", "author": "MaryamZi", "createdAt": "2020-11-27T13:58:48Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SymbolEnter.java", "diffHunk": "@@ -407,6 +416,200 @@ private void defineConstructs(BLangPackage pkgNode, SymbolEnv pkgEnv) {\n                 .forEach(varSymbol -> varSymbol.tag = SymTag.ENDPOINT);\n     }\n \n+    private void defineErrorIntersection(SymbolEnv env) {\n+        for (BLangNode typeDescriptor : this.errorIntersectionTypes) {", "originalCommit": "cca340d89bf2a4bcf1e9e09f867ff0ee54ba0ee9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYyMTcyOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r531621729", "bodyText": "Isn't adding this check a bit contradictory with the method name? Should we rename the method to be more generic?", "author": "MaryamZi", "createdAt": "2020-11-27T14:06:56Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SymbolEnter.java", "diffHunk": "@@ -2119,8 +2330,10 @@ private void validateReadOnlyIntersectionTypeDefinitions(List<BLangTypeDefinitio\n                     if (constituentType == symTable.readonlyType) {\n                         continue;\n                     }\n+                    // If constituent type is error, we have already validated error intersections.\n+                    if (!types.isSelectivelyImmutableType(constituentType, true, true)\n+                            && constituentType.tag != TypeTags.ERROR) {", "originalCommit": "cca340d89bf2a4bcf1e9e09f867ff0ee54ba0ee9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYyMjgzNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r531622835", "bodyText": "When can these become null? I'm not sure if we should add these checks here, we should probably not call this if a type is null.", "author": "MaryamZi", "createdAt": "2020-11-27T14:09:10Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -228,6 +238,9 @@ public boolean isSameType(BType source, BType target) {\n     }\n \n     private boolean isSameType(BType source, BType target, Set<TypePair> unresolvedTypes) {\n+        if (source == null || target == null) {\n+            return false;", "originalCommit": "cca340d89bf2a4bcf1e9e09f867ff0ee54ba0ee9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYyNDQ5MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r531624490", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } else if (isAssignable(origField.type, overlappingField.type)) {\n          \n          \n            \n                        return origField.type;\n          \n          \n            \n                    } else {\n          \n          \n            \n                        return symTable.semanticError;\n          \n          \n            \n                    }\n          \n          \n            \n                    } \n          \n          \n            \n                    \n          \n          \n            \n                    if (isAssignable(origField.type, overlappingField.type)) {\n          \n          \n            \n                        return origField.type;\n          \n          \n            \n                    }\n          \n          \n            \n                    return symTable.semanticError;", "author": "MaryamZi", "createdAt": "2020-11-27T14:12:24Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "diffHunk": "@@ -3142,6 +3182,161 @@ BType getTypeIntersection(BType lhsType, BType rhsType) {\n         }\n     }\n \n+    private BType getIntersectionForErrorTypes(BType lhsType, BType rhsType, SymbolEnv env) {\n+\n+        BType detailTypeOne = ((BErrorType) lhsType).detailType;\n+        BType detailTypeTwo = ((BErrorType) rhsType).detailType;\n+\n+        if (isSealedRecord(detailTypeOne) || isSealedRecord(detailTypeTwo)) {\n+            return symTable.semanticError;\n+        }\n+\n+        BType detailIntersectionType = getTypeIntersection(detailTypeOne, detailTypeTwo, env);\n+        if (detailIntersectionType == symTable.semanticError) {\n+            return symTable.semanticError;\n+        }\n+\n+        BErrorType intersectionErrorType = createErrorType(lhsType, rhsType, detailIntersectionType, env);\n+\n+        return intersectionErrorType;\n+    }\n+\n+    private BType createRecordIntersection(BType recordTypeOne, BType recordTypeTwo, SymbolEnv env) {\n+\n+        BRecordType recordType = createAnonymousRecord(env);\n+\n+        if (!populateRecordFields(recordType, recordTypeOne, env) ||\n+                !populateRecordFields(recordType, recordTypeTwo, env)) {\n+            return symTable.semanticError;\n+        }\n+\n+        recordType.restFieldType = getTypeIntersection(((BRecordType) recordTypeOne).restFieldType,\n+                                                       ((BRecordType) recordTypeTwo).restFieldType, env);\n+\n+        if (recordType.restFieldType == symTable.semanticError) {\n+            return symTable.semanticError;\n+        }\n+\n+        return recordType;\n+    }\n+\n+    private BRecordType createAnonymousRecord(SymbolEnv env) {\n+        EnumSet<Flag> flags = EnumSet.of(Flag.PUBLIC, Flag.ANONYMOUS);\n+        BRecordTypeSymbol recordSymbol = Symbols.createRecordSymbol(Flags.asMask(flags), Names.EMPTY,\n+                                                                                env.enclPkg.packageID, null,\n+                                                                                env.scope.owner, null, VIRTUAL);\n+        recordSymbol.name = names.fromString(\n+                anonymousModelHelper.getNextAnonymousTypeKey(env.enclPkg.packageID));\n+        BInvokableType bInvokableType = new BInvokableType(new ArrayList<>(), symTable.nilType, null);\n+        BInvokableSymbol initFuncSymbol = Symbols.createFunctionSymbol(\n+                Flags.PUBLIC, Names.EMPTY, env.enclPkg.symbol.pkgID, bInvokableType, env.scope.owner, false,\n+                symTable.builtinPos, VIRTUAL);\n+        initFuncSymbol.retType = symTable.nilType;\n+        recordSymbol.initializerFunc = new BAttachedFunction(Names.INIT_FUNCTION_SUFFIX, initFuncSymbol,\n+                                                                         bInvokableType, symTable.builtinPos);\n+        recordSymbol.scope = new Scope(recordSymbol);\n+\n+        BRecordType recordType = new BRecordType(recordSymbol);\n+        recordType.tsymbol = recordSymbol;\n+        recordSymbol.type = recordType;\n+\n+        return recordType;\n+    }\n+\n+    private BType createRecordAndMapIntersection(BType type, BType mapType, SymbolEnv env) {\n+        BRecordType intersectionRecord = createAnonymousRecord(env);\n+        if (!populateRecordFields(intersectionRecord, type, env)) {\n+            return symTable.semanticError;\n+        }\n+        intersectionRecord.restFieldType = getRestFieldIntersectionType(type, (BMapType) mapType, env);\n+\n+        if (intersectionRecord.restFieldType == symTable.semanticError) {\n+            return symTable.semanticError;\n+        }\n+\n+        return intersectionRecord;\n+    }\n+\n+    private BType getRestFieldIntersectionType(BType type, BMapType mapType, SymbolEnv env) {\n+        if (type.tag == TypeTags.RECORD) {\n+            return getTypeIntersection(((BRecordType) type).restFieldType, mapType.constraint, env);\n+        } else {\n+            return getTypeIntersection(((BMapType) type).constraint, mapType.constraint, env);\n+        }\n+    }\n+\n+    private BErrorType createErrorType(BType lhsType, BType rhsType, BType detailType, SymbolEnv env) {\n+        BErrorType errorType = createErrorType(detailType, lhsType.flags, env);\n+        errorType.tsymbol.flags |= rhsType.flags;\n+\n+        return errorType;\n+    }\n+\n+    public BErrorType createErrorType(BType detailType, long flags, SymbolEnv env) {\n+        BErrorTypeSymbol errorTypeSymbol = Symbols.createErrorSymbol(flags, Names.EMPTY,\n+                                                                     env.enclPkg.symbol.pkgID, null,\n+                                                                     env.scope.owner, null, VIRTUAL);\n+        BErrorType errorType = new BErrorType(errorTypeSymbol, detailType);\n+        errorType.flags |= errorTypeSymbol.flags;\n+        errorTypeSymbol.type = errorType;\n+        symResolver.markParameterizedType(errorType, detailType);\n+        errorType.typeIdSet = BTypeIdSet.emptySet();\n+\n+        return errorType;\n+    }\n+\n+    private boolean populateRecordFields(BRecordType recordType, BType originalType, SymbolEnv env) {\n+        BTypeSymbol intersectionRecordSymbol = recordType.tsymbol;\n+        // If the detail type is BMapType simply ignore since the resulting detail type has `anydata` as rest type.\n+        if (originalType.getKind() != TypeKind.RECORD) {\n+            return true;\n+        }\n+        BRecordType originalRecordType = (BRecordType) originalType;\n+        LinkedHashMap<String, BField> fields = new LinkedHashMap<>();\n+        for (BField origField : originalRecordType.fields.values()) {\n+            org.wso2.ballerinalang.compiler.util.Name origFieldName = origField.name;\n+            String nameString = origFieldName.value;\n+\n+            BType recordFieldType = validateOverlappingFields(recordType, origField);\n+            if (recordFieldType == symTable.semanticError) {\n+                return false;\n+            }\n+\n+            BVarSymbol recordFieldSymbol = new BVarSymbol(origField.symbol.flags, origFieldName,\n+                                                          env.enclPkg.packageID, recordFieldType,\n+                                                          intersectionRecordSymbol, origField.pos, SOURCE);\n+            if (recordFieldType.tag == TypeTags.INVOKABLE && recordFieldType.tsymbol != null) {\n+                BInvokableTypeSymbol tsymbol = (BInvokableTypeSymbol) recordFieldType.tsymbol;\n+                BInvokableSymbol invokableSymbol = (BInvokableSymbol) recordFieldSymbol;\n+                invokableSymbol.params = tsymbol.params;\n+                invokableSymbol.restParam = tsymbol.restParam;\n+                invokableSymbol.retType = tsymbol.returnType;\n+                invokableSymbol.flags = tsymbol.flags;\n+            }\n+\n+\n+            fields.put(nameString, new BField(origFieldName, null, recordFieldSymbol));\n+        }\n+        recordType.fields.putAll(fields);\n+\n+        return true;\n+    }\n+\n+    private BType validateOverlappingFields(BRecordType recordType, BField origField) {\n+        BField overlappingField = recordType.fields.get(origField.name.value);\n+        if (overlappingField == null) {\n+            return origField.type;\n+        }\n+\n+        if (isAssignable(overlappingField.type, origField.type)) {\n+            return overlappingField.type;\n+        } else if (isAssignable(origField.type, overlappingField.type)) {\n+            return origField.type;\n+        } else {\n+            return symTable.semanticError;\n+        }", "originalCommit": "cca340d89bf2a4bcf1e9e09f867ff0ee54ba0ee9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "288a33a16b0c50a12e3a58cbbf474fbfd21b5cdd", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/288a33a16b0c50a12e3a58cbbf474fbfd21b5cdd", "message": "Update compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n\nCo-authored-by: Maryam Ziyad <maryamziyadm@gmail.com>", "committedDate": "2020-12-14T15:01:46Z", "type": "forcePushed"}, {"oid": "bded6e540a9f2e23028ec8b8c60dc50e8ecb75ae", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bded6e540a9f2e23028ec8b8c60dc50e8ecb75ae", "message": "Update compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n\nCo-authored-by: Maryam Ziyad <maryamziyadm@gmail.com>", "committedDate": "2020-12-14T15:03:21Z", "type": "forcePushed"}, {"oid": "9735dbefda63a381e9919c5b0bfd058a28a141e8", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9735dbefda63a381e9919c5b0bfd058a28a141e8", "message": "Update compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n\nCo-authored-by: Maryam Ziyad <maryamziyadm@gmail.com>", "committedDate": "2020-12-14T15:09:24Z", "type": "forcePushed"}, {"oid": "f6e2dfbe2c41de8018a7233ab72046eb4b4d3936", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f6e2dfbe2c41de8018a7233ab72046eb4b4d3936", "message": "Update compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n\nCo-authored-by: Maryam Ziyad <maryamziyadm@gmail.com>", "committedDate": "2020-12-14T15:23:09Z", "type": "forcePushed"}, {"oid": "071fa0d59f258f80051c572190ab71b24ab6d78e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/071fa0d59f258f80051c572190ab71b24ab6d78e", "message": "Update compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n\nCo-authored-by: Maryam Ziyad <maryamziyadm@gmail.com>", "committedDate": "2020-12-14T16:00:21Z", "type": "forcePushed"}, {"oid": "dd99d7089a9a42b733053c02baf8949b71e4b372", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/dd99d7089a9a42b733053c02baf8949b71e4b372", "message": "Add new checks for map and record intersection\n\nWhen intersecting a map and a record, now the checks are validating each field with the constraint of the map.\nIf a field is optional and the intersection is an error, we skip that for the generated type.\nIn case it's not optional the intersection is a semantic error.", "committedDate": "2020-12-18T08:00:10Z", "type": "forcePushed"}, {"oid": "ae011cf75d4ec75832f28fc6eb7d3d1ae74b483b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ae011cf75d4ec75832f28fc6eb7d3d1ae74b483b", "message": "Add new checks for map and record intersection\n\nWhen intersecting a map and a record, now the checks are validating each field with the constraint of the map.\nIf a field is optional and the intersection is an error, we skip that for the generated type.\nIn case it's not optional the intersection is a semantic error.", "committedDate": "2020-12-21T05:58:31Z", "type": "forcePushed"}, {"oid": "6a1ba444b49bc060213d6a5948e540205d1f65df", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6a1ba444b49bc060213d6a5948e540205d1f65df", "message": "Capture error intersections\n\nCapture error intersections to be analyzed after defining nodes.\nChanged the order of defineField and defineError so that the fields of records would be defined and then those could be used to calculate the error intersection. Then only defining errorDetails.", "committedDate": "2021-01-05T14:23:54Z", "type": "commit"}, {"oid": "c1a636c6b1e1f073ea1e6e6fc8872b10c5c47f0c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c1a636c6b1e1f073ea1e6e6fc8872b10c5c47f0c", "message": "Create detail type for record intersection\n\nCreate detail type for record intersection is completed in this commit.\nThe symbols are not defined in the types. Need to define symbols", "committedDate": "2021-01-05T14:23:54Z", "type": "commit"}, {"oid": "7c179d7db9a8058b06742de1f583cf969b357a47", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7c179d7db9a8058b06742de1f583cf969b357a47", "message": "Define new anonymous Types\n\nDefine symbols for detail record and error type.\nCreate type definition for detail record.\nCreate type definition for error type.\nTwo new methods were added to TypeDefBuilderHelper to create a BLangErrorType and to create an Identifier.", "committedDate": "2021-01-05T14:23:54Z", "type": "commit"}, {"oid": "37b940a79990959d052bef2f3bf5db30c93e8cea", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/37b940a79990959d052bef2f3bf5db30c93e8cea", "message": "Create intersection type\n\nDefine methods in SymbolEnter to create a new intersection type. Changed the name of the BLangErrorType to the name of the intersection type. Defined the record, error and intersection symbols.", "committedDate": "2021-01-05T14:23:54Z", "type": "commit"}, {"oid": "6dba2f82667ace8dff32d38b31369542baffa066", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6dba2f82667ace8dff32d38b31369542baffa066", "message": "Add support for intersection of intersectionTypes\n\nLooping through multiple types to analyze if anything other than error type is present. If so log an error.\nIf type is valid, generate a potential intersection type using the previous intersection type and current error type.\nContinue this for all the types available in the intersection.", "committedDate": "2021-01-05T14:23:54Z", "type": "commit"}, {"oid": "0d31276a9ed0bbd9fbc2119b4af97b8f97f08789", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0d31276a9ed0bbd9fbc2119b4af97b8f97f08789", "message": "Add support for distinct types\n\nCapture type ids of intersecting errors and populate them to a TypeId set.\nUse all the set of primary and secondary TypeIDs as secondary TypeIDs of the new intersection error type", "committedDate": "2021-01-05T14:23:54Z", "type": "commit"}, {"oid": "239cf48985b3cde010952983b4ba38e4c9fe7975", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/239cf48985b3cde010952983b4ba38e4c9fe7975", "message": "Add support for errors with `BMapType` as detail type.\n\nSkipping since the resulting `BRecordType` is unsealed and has `anydata` as rest type.", "committedDate": "2021-01-05T14:23:54Z", "type": "commit"}, {"oid": "9eccd9fe5a4894299255ba8a1bab70704549f969", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9eccd9fe5a4894299255ba8a1bab70704549f969", "message": "Add support for map and map intersection\n\nRefactored the code to generify the getTypeIntersection method. It now supports `record & record` `record & map` and `map & map`. Earlier `record & record` for error detail was done in a method which was directly called from the method which creates the error intersection.", "committedDate": "2021-01-05T14:23:54Z", "type": "commit"}, {"oid": "c38445df1b7f9a3c811022a0d50b787ea2281409", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c38445df1b7f9a3c811022a0d50b787ea2281409", "message": "Define errors\n\nNew error is defined for when a constituent node is not of the error or readonly type when found in a error intersection.\nUsed the same invalid error intersection when `Types` returns a semanticError.", "committedDate": "2021-01-05T14:23:54Z", "type": "commit"}, {"oid": "4e615882f8b1281ba967152264ba84114e73ffb5", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4e615882f8b1281ba967152264ba84114e73ffb5", "message": "Fix intersection type being already existing type error.\n\nCheck if `getTypeIntersection` returns a compared error. If so keep a flag.\nIf a pre existing error is received, do not create a type definition, instead create a `BLangUserDefinedTypeNode`\nand use it for the error type definition.\nAdded tests", "committedDate": "2021-01-05T14:23:54Z", "type": "commit"}, {"oid": "b3b9b9c0e20bb0dd6117812eaf859ad4cc18d357", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b3b9b9c0e20bb0dd6117812eaf859ad4cc18d357", "message": "Add review suggestions\n\nUsed `TypeTag` instead of `getKind()`", "committedDate": "2021-01-05T14:23:55Z", "type": "commit"}, {"oid": "11a2d8e09cb6eb8f6b862a01ed3f7e944b9b1fec", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/11a2d8e09cb6eb8f6b862a01ed3f7e944b9b1fec", "message": "Add tests", "committedDate": "2021-01-05T14:23:55Z", "type": "commit"}, {"oid": "c99e0cd4c494cad5953b86286a1e0a48d38dc041", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c99e0cd4c494cad5953b86286a1e0a48d38dc041", "message": "Refactor `getTypeIntersection`\n\nRefactored the `getTypeIntersection` method to accept the package env as a parameter.\nThis was done since the Types class was a stateless class and having a state variable such as env was violating this. Hence we had to modify the method to accept the environment as a parameter.", "committedDate": "2021-01-05T14:23:55Z", "type": "commit"}, {"oid": "ba920b93d710a1d1c62b441b3ecdefb5b350f7ea", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ba920b93d710a1d1c62b441b3ecdefb5b350f7ea", "message": "Fix int long conversion of flags after master change", "committedDate": "2021-01-05T14:23:55Z", "type": "commit"}, {"oid": "abef5a49a90fb280cc12f7bf9f55795b94d3bad3", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/abef5a49a90fb280cc12f7bf9f55795b94d3bad3", "message": "Sync with master\n\nMoved the new error type to `DiagnosticErrorCode`", "committedDate": "2021-01-05T14:24:35Z", "type": "commit"}, {"oid": "a30d526411ea9bf711577af42bf23828824e369a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a30d526411ea9bf711577af42bf23828824e369a", "message": "Fix SymbolEnter\n\nFixed an issue where inline intersection type descriptors were not captured.", "committedDate": "2021-01-05T14:24:35Z", "type": "commit"}, {"oid": "333aaf8ea9fd63c5794304741fc1b863d06a8acf", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/333aaf8ea9fd63c5794304741fc1b863d06a8acf", "message": "Restructure SymbolEnter\n\nRestructured SymbolEnter to calculate error intersection more generically using SymbolResolver", "committedDate": "2021-01-05T14:24:36Z", "type": "commit"}, {"oid": "cd06c43d9093d44bd3f5a91258757892aab1022a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/cd06c43d9093d44bd3f5a91258757892aab1022a", "message": "Update compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java\n\nCo-authored-by: Maryam Ziyad <maryamziyadm@gmail.com>", "committedDate": "2021-01-05T14:24:36Z", "type": "commit"}, {"oid": "e7a8a5c44737c0d06b8d95ecaa071238f4737e49", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e7a8a5c44737c0d06b8d95ecaa071238f4737e49", "message": "Add new checks for map and record intersection\n\nWhen intersecting a map and a record, now the checks are validating each field with the constraint of the map.\nIf a field is optional and the intersection is an error, we skip that for the generated type.\nIn case it's not optional the intersection is a semantic error.", "committedDate": "2021-01-05T14:24:36Z", "type": "forcePushed"}, {"oid": "12caaadf90d031ab01b8ae5c4fcc3463c765037c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/12caaadf90d031ab01b8ae5c4fcc3463c765037c", "message": "Add new checks for map and record intersection\n\nWhen intersecting a map and a record, now the checks are validating each field with the constraint of the map.\nIf a field is optional and the intersection is an error, we skip that for the generated type.\nIn case it's not optional the intersection is a semantic error.", "committedDate": "2021-01-05T18:19:00Z", "type": "commit"}, {"oid": "12caaadf90d031ab01b8ae5c4fcc3463c765037c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/12caaadf90d031ab01b8ae5c4fcc3463c765037c", "message": "Add new checks for map and record intersection\n\nWhen intersecting a map and a record, now the checks are validating each field with the constraint of the map.\nIf a field is optional and the intersection is an error, we skip that for the generated type.\nIn case it's not optional the intersection is a semantic error.", "committedDate": "2021-01-05T18:19:00Z", "type": "forcePushed"}, {"oid": "8a2d376d4cf14cdfdc5a1864d3e749ccc7a0b6b7", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8a2d376d4cf14cdfdc5a1864d3e749ccc7a0b6b7", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into intersection-error-type", "committedDate": "2021-01-06T04:26:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM2NDAzNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r552364036", "bodyText": "Extra new line", "author": "rdhananjaya", "createdAt": "2021-01-06T04:35:43Z", "path": "compiler/ballerina-lang/src/main/java/org/ballerinalang/util/diagnostic/DiagnosticErrorCode.java", "diffHunk": "@@ -660,6 +660,7 @@\n     SERVICE_LITERAL_REQUIRED_BY_LISTENER(\"BCE3973\", \"service.path.literal.required.by.listener\"),\n     SERVICE_ABSOLUTE_PATH_REQUIRED_BY_LISTENER(\"BCE3974\", \"service.absolute.path.required.by.listener\"),\n     MULTIPLE_RECEIVE_ACTION_NOT_YET_SUPPORTED(\"BCE3975\", \"multiple.receive.action.not.yet.supported\"),\n+", "originalCommit": "8a2d376d4cf14cdfdc5a1864d3e749ccc7a0b6b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM2NDU2OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r552364569", "bodyText": "Fixed", "author": "dulvinw", "createdAt": "2021-01-06T04:37:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM2NDAzNg=="}], "type": "inlineReview"}, {"oid": "9f4685f2a1e77e3030c00d8b66d7fc6e43223d04", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9f4685f2a1e77e3030c00d8b66d7fc6e43223d04", "message": "Fix typo in DiagnosticErrorCode", "committedDate": "2021-01-06T04:37:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM2OTMxMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r552369310", "bodyText": "Shall we add a comment explaining this", "author": "rdhananjaya", "createdAt": "2021-01-06T04:57:14Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SymbolEnter.java", "diffHunk": "@@ -1969,6 +2058,9 @@ private void addTopLevelNode(BLangPackage pkgNode, TopLevelNode node) {\n \n     private void defineErrorDetails(List<BLangTypeDefinition> typeDefNodes, SymbolEnv pkgEnv) {\n         for (BLangTypeDefinition typeDef : typeDefNodes) {\n+            if (typeDef.symbol == null) {", "originalCommit": "9f4685f2a1e77e3030c00d8b66d7fc6e43223d04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM4MzA0Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r552383043", "bodyText": "can we use this \n  \n    \n      ballerina-lang/compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/ASTBuilderUtil.java\n    \n    \n         Line 704\n      in\n      1ce30c6\n    \n    \n    \n    \n\n        \n          \n           public static BLangIdentifier createIdentifier(Location pos, String value) {", "author": "rdhananjaya", "createdAt": "2021-01-06T05:50:33Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/util/TypeDefBuilderHelper.java", "diffHunk": "@@ -215,4 +218,29 @@ public static BLangClassDefinition createClassDef(Location pos, BObjectTypeSymbo\n \n         return classDefNode;\n     }\n+\n+    public static BLangErrorType createBLangErrorType(Location pos, BType detailType, String name) {\n+        BLangErrorType errorType = (BLangErrorType) TreeBuilder.createErrorTypeNode();\n+        BLangUserDefinedType userDefinedTypeNode = (BLangUserDefinedType) TreeBuilder.createUserDefinedTypeNode();\n+        userDefinedTypeNode.pos = pos;\n+        userDefinedTypeNode.pkgAlias = (BLangIdentifier) TreeBuilder.createIdentifierNode();\n+        userDefinedTypeNode.typeName = createIdentifier(pos, name);\n+        userDefinedTypeNode.type = detailType;\n+        errorType.detailType = userDefinedTypeNode;\n+\n+        return errorType;\n+    }\n+\n+    private static BLangIdentifier createIdentifier(Location pos, String value) {", "originalCommit": "9f4685f2a1e77e3030c00d8b66d7fc6e43223d04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQwNzEzNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26770#discussion_r552407134", "bodyText": "Fixed", "author": "dulvinw", "createdAt": "2021-01-06T07:16:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM4MzA0Mw=="}], "type": "inlineReview"}, {"oid": "6b48b989a6e89db776f6a4f4e04cf1a146ee9662", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6b48b989a6e89db776f6a4f4e04cf1a146ee9662", "message": "Remove redundant checks", "committedDate": "2021-01-06T07:15:35Z", "type": "commit"}, {"oid": "6b48b989a6e89db776f6a4f4e04cf1a146ee9662", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6b48b989a6e89db776f6a4f4e04cf1a146ee9662", "message": "Remove redundant checks", "committedDate": "2021-01-06T07:15:35Z", "type": "forcePushed"}, {"oid": "2a5d85985eb0e5f9ee381ab0f1dcc5b94babc7ea", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2a5d85985eb0e5f9ee381ab0f1dcc5b94babc7ea", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into intersection-error-type", "committedDate": "2021-01-06T11:37:17Z", "type": "commit"}, {"oid": "a13ccacbf4b858b2c11ccd35304adaef0d224e1e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a13ccacbf4b858b2c11ccd35304adaef0d224e1e", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into intersection-error-type\n\n# Conflicts:\n#\tcompiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SymbolEnter.java", "committedDate": "2021-01-07T04:39:28Z", "type": "commit"}, {"oid": "9800d6df336b8a4c2d82d712f02f825b32ddfdee", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9800d6df336b8a4c2d82d712f02f825b32ddfdee", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into intersection-error-type\n\n# Conflicts:\n#\tcompiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/SymbolEnter.java\n#\tcompiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/Types.java", "committedDate": "2021-01-08T06:59:01Z", "type": "commit"}, {"oid": "612b5b6d1927b22b1ba602f10d9ccee82779b839", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/612b5b6d1927b22b1ba602f10d9ccee82779b839", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into intersection-error-type", "committedDate": "2021-01-08T07:04:44Z", "type": "commit"}, {"oid": "612b5b6d1927b22b1ba602f10d9ccee82779b839", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/612b5b6d1927b22b1ba602f10d9ccee82779b839", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into intersection-error-type", "committedDate": "2021-01-08T07:04:44Z", "type": "forcePushed"}, {"oid": "c02333a494a4b35b471f66d3298761f48e3a6618", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c02333a494a4b35b471f66d3298761f48e3a6618", "message": "Add tests for distinct error types\n\nThis commit adds testcases to test the new distinct type created by intersecting two errors.", "committedDate": "2021-01-08T08:42:03Z", "type": "forcePushed"}, {"oid": "23338fc8b5c97459aba261608c305777090bd850", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/23338fc8b5c97459aba261608c305777090bd850", "message": "Add tests for distinct error types\n\nThis commit adds testcases to test the new distinct type created by intersecting two errors.", "committedDate": "2021-01-08T09:47:37Z", "type": "commit"}, {"oid": "23338fc8b5c97459aba261608c305777090bd850", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/23338fc8b5c97459aba261608c305777090bd850", "message": "Add tests for distinct error types\n\nThis commit adds testcases to test the new distinct type created by intersecting two errors.", "committedDate": "2021-01-08T09:47:37Z", "type": "forcePushed"}]}