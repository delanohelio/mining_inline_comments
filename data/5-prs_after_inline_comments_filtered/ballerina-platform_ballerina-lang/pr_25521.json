{"pr_number": 25521, "pr_title": "Remove functional binding pattern", "pr_createdAt": "2020-08-28T12:39:40Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/25521", "timeline": [{"oid": "5841925727eeb566911f2ca685cedf27e57d5942", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5841925727eeb566911f2ca685cedf27e57d5942", "message": "Binding pattern parsing changes.\nRemove functional binding patterns and update error binding pattern parsing logic.", "committedDate": "2020-08-25T10:12:19Z", "type": "commit"}, {"oid": "d2ce5bdf056a8d42843aa301e86bdd43e34e0109", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d2ce5bdf056a8d42843aa301e86bdd43e34e0109", "message": "Update recovery for new spec.", "committedDate": "2020-08-27T06:42:13Z", "type": "commit"}, {"oid": "841262545ec0709b995cc33eaba8587df5d8a89a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/841262545ec0709b995cc33eaba8587df5d8a89a", "message": "Add node class files.", "committedDate": "2020-08-27T06:43:49Z", "type": "commit"}, {"oid": "05fa03b5aa4cdf20dafc103b458c84bc5f781ccf", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/05fa03b5aa4cdf20dafc103b458c84bc5f781ccf", "message": "Remove unwanted contexts.", "committedDate": "2020-08-27T11:25:20Z", "type": "commit"}, {"oid": "c4757f6f773167e2a86cb71ff2ec1ee2494bc6cd", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c4757f6f773167e2a86cb71ff2ec1ee2494bc6cd", "message": "Update assert files.", "committedDate": "2020-08-28T10:45:26Z", "type": "commit"}, {"oid": "c9cdca8aef668a97c08ae917977a0b969bd141e9", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c9cdca8aef668a97c08ae917977a0b969bd141e9", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into remove-functional", "committedDate": "2020-08-28T10:48:03Z", "type": "commit"}, {"oid": "9f1d06f49f7decb0b0aeea3fc68fb6af65ce197a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9f1d06f49f7decb0b0aeea3fc68fb6af65ce197a", "message": "Add isOptional attribute to typeReference.", "committedDate": "2020-08-28T13:43:23Z", "type": "commit"}, {"oid": "3b4630b236465fec3fa0f7f5e7af17f296cde857", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3b4630b236465fec3fa0f7f5e7af17f296cde857", "message": "Fix formatter errors.", "committedDate": "2020-08-31T06:08:03Z", "type": "commit"}, {"oid": "5860cbb1fabc9568d21f14286e5fb967e30a25a8", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5860cbb1fabc9568d21f14286e5fb967e30a25a8", "message": "Remove commented code line.", "committedDate": "2020-08-31T06:52:35Z", "type": "commit"}, {"oid": "faa3e90a6822d4987ce7b32e8ee0a029c089227e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/faa3e90a6822d4987ce7b32e8ee0a029c089227e", "message": "NodeTransformer changes for error BP.", "committedDate": "2020-08-31T08:04:00Z", "type": "commit"}, {"oid": "6f463e26cffe70fa199501d0e15a35528d76fdcc", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6f463e26cffe70fa199501d0e15a35528d76fdcc", "message": "Fix checkstyle issues in NodeTransformer.", "committedDate": "2020-08-31T08:49:48Z", "type": "commit"}, {"oid": "b41322879eb96347fa9c8a37b214133843649a43", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b41322879eb96347fa9c8a37b214133843649a43", "message": "Fix parsing issue in error BP.", "committedDate": "2020-08-31T10:09:33Z", "type": "commit"}, {"oid": "f0ce5bd8aa709ec92eaf376cb3d1278def8465ce", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f0ce5bd8aa709ec92eaf376cb3d1278def8465ce", "message": "Fix assertion fail in language server.", "committedDate": "2020-08-31T11:00:45Z", "type": "commit"}, {"oid": "d84d99b561102ee76d405d898e1dc6c8d4e70a1b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d84d99b561102ee76d405d898e1dc6c8d4e70a1b", "message": "Fix parsing issue in errorBP.", "committedDate": "2020-09-01T06:22:37Z", "type": "commit"}, {"oid": "e1ff5f322a78418ebbe1e4f6acd0ee0d1e823926", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e1ff5f322a78418ebbe1e4f6acd0ee0d1e823926", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into remove-functional", "committedDate": "2020-09-02T04:15:51Z", "type": "commit"}, {"oid": "36f157d698ad8405860bf35c4413fe95b31d49ba", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/36f157d698ad8405860bf35c4413fe95b31d49ba", "message": "Add a println for test purpose.", "committedDate": "2020-09-02T07:07:50Z", "type": "commit"}, {"oid": "7228e331e4b0559a1d92076a21e2ebec9d2f824e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7228e331e4b0559a1d92076a21e2ebec9d2f824e", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into remove-functional", "committedDate": "2020-09-02T12:39:09Z", "type": "commit"}, {"oid": "f838a70ba26890edd7c319b862e7bed6a8321e2f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f838a70ba26890edd7c319b862e7bed6a8321e2f", "message": "Remove println.", "committedDate": "2020-09-02T13:43:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjY4MDM3Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25521#discussion_r482680376", "bodyText": "lets use the expanded name for BP:  parseAsErrorBindingPattern", "author": "SupunS", "createdAt": "2020-09-03T03:25:31Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12975,165 +12987,277 @@ private boolean isEndOfMappingBindingPattern(SyntaxKind nextTokenKind) {\n         return nextTokenKind == SyntaxKind.CLOSE_BRACE_TOKEN;\n     }\n \n+    private STNode parseErrorTypeDescOrErrorBP(STNode annots) {\n+        STToken nextNextToken = peek(2);\n+        switch (nextNextToken.kind) {\n+            case OPEN_PAREN_TOKEN:// Error binding pattern\n+                return parseAsErrorBP();\n+            case LT_TOKEN:\n+                return parseAsErrorTypeDesc(annots);\n+            case IDENTIFIER_TOKEN:\n+                // If the next token is identifier it can be either error a; or error a (errorMessage);\n+                SyntaxKind nextNextNextTokenKind = peek(3).kind;\n+                if (nextNextNextTokenKind == SyntaxKind.COLON_TOKEN ||\n+                        nextNextNextTokenKind == SyntaxKind.OPEN_PAREN_TOKEN) {\n+                    return parseAsErrorBP();\n+                }\n+                // Fall through.\n+            default:\n+                return parseAsErrorTypeDesc(annots);\n+        }\n+    }\n+\n+    private STNode parseAsErrorBP() {", "originalCommit": "f838a70ba26890edd7c319b862e7bed6a8321e2f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjY4MDY2Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25521#discussion_r482680667", "bodyText": "Need a newline after }", "author": "SupunS", "createdAt": "2020-09-03T03:26:40Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12975,165 +12987,277 @@ private boolean isEndOfMappingBindingPattern(SyntaxKind nextTokenKind) {\n         return nextTokenKind == SyntaxKind.CLOSE_BRACE_TOKEN;\n     }\n \n+    private STNode parseErrorTypeDescOrErrorBP(STNode annots) {\n+        STToken nextNextToken = peek(2);\n+        switch (nextNextToken.kind) {\n+            case OPEN_PAREN_TOKEN:// Error binding pattern\n+                return parseAsErrorBP();\n+            case LT_TOKEN:\n+                return parseAsErrorTypeDesc(annots);\n+            case IDENTIFIER_TOKEN:\n+                // If the next token is identifier it can be either error a; or error a (errorMessage);\n+                SyntaxKind nextNextNextTokenKind = peek(3).kind;\n+                if (nextNextNextTokenKind == SyntaxKind.COLON_TOKEN ||\n+                        nextNextNextTokenKind == SyntaxKind.OPEN_PAREN_TOKEN) {\n+                    return parseAsErrorBP();\n+                }\n+                // Fall through.\n+            default:\n+                return parseAsErrorTypeDesc(annots);\n+        }\n+    }\n+\n+    private STNode parseAsErrorBP() {\n+        startContext(ParserRuleContext.ASSIGNMENT_STMT);\n+        return parseAssignmentStmtRhs(parseErrorBindingPattern());\n+    }\n+\n+    private STNode parseAsErrorTypeDesc(STNode annots) {\n+        STNode finalKeyword = STNodeFactory.createEmptyNode();\n+        return parseVariableDecl(getAnnotations(annots), finalKeyword, false);\n+    }", "originalCommit": "f838a70ba26890edd7c319b862e7bed6a8321e2f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjY4Mzc3Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25521#discussion_r482683772", "bodyText": "Should we loop on a condition like isErrorArgsListEnd()?\nThen we can exit early for cases like eof-token, ) token, etc..", "author": "SupunS", "createdAt": "2020-09-03T03:38:41Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12975,165 +12987,277 @@ private boolean isEndOfMappingBindingPattern(SyntaxKind nextTokenKind) {\n         return nextTokenKind == SyntaxKind.CLOSE_BRACE_TOKEN;\n     }\n \n+    private STNode parseErrorTypeDescOrErrorBP(STNode annots) {\n+        STToken nextNextToken = peek(2);\n+        switch (nextNextToken.kind) {\n+            case OPEN_PAREN_TOKEN:// Error binding pattern\n+                return parseAsErrorBP();\n+            case LT_TOKEN:\n+                return parseAsErrorTypeDesc(annots);\n+            case IDENTIFIER_TOKEN:\n+                // If the next token is identifier it can be either error a; or error a (errorMessage);\n+                SyntaxKind nextNextNextTokenKind = peek(3).kind;\n+                if (nextNextNextTokenKind == SyntaxKind.COLON_TOKEN ||\n+                        nextNextNextTokenKind == SyntaxKind.OPEN_PAREN_TOKEN) {\n+                    return parseAsErrorBP();\n+                }\n+                // Fall through.\n+            default:\n+                return parseAsErrorTypeDesc(annots);\n+        }\n+    }\n+\n+    private STNode parseAsErrorBP() {\n+        startContext(ParserRuleContext.ASSIGNMENT_STMT);\n+        return parseAssignmentStmtRhs(parseErrorBindingPattern());\n+    }\n+\n+    private STNode parseAsErrorTypeDesc(STNode annots) {\n+        STNode finalKeyword = STNodeFactory.createEmptyNode();\n+        return parseVariableDecl(getAnnotations(annots), finalKeyword, false);\n+    }\n     /**\n      * Parse error binding pattern node.\n      * <p>\n-     * <code>functional-binding-pattern := error ( arg-list-binding-pattern )</code>\n+     * <code>error-binding-pattern := error [error-type-reference] ( error-arg-list-binding-pattern )</code>\n+     * <br/><br/>\n+     * error-arg-list-binding-pattern :=\n+     *    error-message-binding-pattern [, error-cause-binding-pattern] [, error-field-binding-patterns]\n+     *    | [error-field-binding-patterns]\n+     * <br/><br/>\n+     * error-message-binding-pattern := simple-binding-pattern\n+     * <br/><br/>\n+     * error-cause-binding-pattern := simple-binding-pattern | error-binding-pattern\n+     * <br/><br/>\n+     * simple-binding-pattern := capture-binding-pattern | wildcard-binding-pattern\n+     * <br/><br/>\n+     * error-field-binding-patterns :=\n+     *    named-arg-binding-pattern (, named-arg-binding-pattern)* [, rest-binding-pattern]\n+     *    | rest-binding-pattern\n+     * <br/><br/>\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n      * \n      * @return Error binding pattern node.\n      */\n     private STNode parseErrorBindingPattern() {\n-        startContext(ParserRuleContext.FUNCTIONAL_BINDING_PATTERN);\n-        STNode typeDesc = parseErrorKeyword();\n-        return parseFunctionalBindingPattern(typeDesc);\n+        startContext(ParserRuleContext.ERROR_BINDING_PATTERN);\n+        STNode errorKeyword = parseErrorKeyword();\n+        return parseErrorBindingPattern(errorKeyword);\n+    }\n+\n+    private STNode parseErrorBindingPattern(STNode errorKeyword) {\n+        STToken nextToken = peek();\n+        STNode typeRef;\n+        switch (nextToken.kind) {\n+            case IDENTIFIER_TOKEN:\n+                typeRef = parseTypeReference();\n+                break;\n+            case OPEN_PAREN_TOKEN:\n+                typeRef = STNodeFactory.createEmptyNode();\n+                break;\n+            default:\n+                recover(peek(), ParserRuleContext.ERROR_BINDING_PATTERN_ERROR_KEYWORD_RHS);\n+                return parseErrorBindingPattern(errorKeyword);\n+        }\n+        return parseErrorBindingPattern(errorKeyword, typeRef);\n+    }\n+\n+    private STNode parseErrorBindingPattern(STNode errorKeyword, STNode typeRef) {\n+        STNode openParenthesis = parseOpenParenthesis(ParserRuleContext.OPEN_PARENTHESIS);\n+        STNode argListBindingPatterns = parseErrorArgListBindingPatterns();\n+        STNode closeParenthesis = parseCloseParenthesis();\n+        endContext();\n+        return STNodeFactory.createErrorBindingPatternNode(errorKeyword, typeRef, openParenthesis,\n+                argListBindingPatterns, closeParenthesis);\n     }\n \n     /**\n-     * Parse functional binding pattern.\n+     * Parse error arg list binding pattern.\n      * <p>\n      * <code>\n-     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * error-arg-list-binding-pattern :=\n+     * error-message-binding-pattern [, error-cause-binding-pattern] [, error-field-binding-patterns]\n+     * | [error-field-binding-patterns]\n      * <br/><br/>\n-     * functionally-constructible-type-reference := error | type-reference\n+     *\n+     * error-message-binding-pattern := simple-binding-pattern\n+     * <br/><br/>\n+     *\n+     * error-cause-binding-pattern := simple-binding-pattern | error-binding-pattern\n+     * <br/><br/>\n+     *\n+     * simple-binding-pattern := capture-binding-pattern | wildcard-binding-pattern\n+     * <br/><br/>\n+     *\n+     * error-field-binding-patterns :=\n+     * named-arg-binding-pattern (, named-arg-binding-pattern)* [, rest-binding-pattern]\n+     * | rest-binding-pattern\n+     * <br/><br/>\n+     *\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n      * </code>\n-     * \n-     * @param typeDesc Functionally constructible type reference\n-     * @return Functional binding pattern node.\n+     *\n+     * @return Error arg list binding patterns.\n      */\n-    private STNode parseFunctionalBindingPattern(STNode typeDesc) {\n-        STNode openParenthesis = parseOpenParenthesis(ParserRuleContext.ARG_LIST_START);\n-        STNode argListBindingPatterns = parseArgListBindingPatterns();\n-        STNode closeParenthesis = parseCloseParenthesis();\n-        endContext();\n-        return STNodeFactory.createFunctionalBindingPatternNode(typeDesc, openParenthesis, argListBindingPatterns,\n-                closeParenthesis);\n-    }\n-\n-    private STNode parseArgListBindingPatterns() {\n+    private STNode parseErrorArgListBindingPatterns() {\n         List<STNode> argListBindingPatterns = new ArrayList<>();\n         SyntaxKind lastValidArgKind = SyntaxKind.CAPTURE_BINDING_PATTERN;\n         STToken nextToken = peek();\n \n         if (isEndOfParametersList(nextToken.kind)) {\n             return STNodeFactory.createNodeList(argListBindingPatterns);\n         }\n-        argListBindingPatterns.add(parseArgBindingPattern());\n \n-        nextToken = peek();\n-        while (!isEndOfParametersList(nextToken.kind)) {\n-            STNode argEnd = parseArgsBindingPatternEnd();\n-            if (argEnd == null) {\n-                // null marks the end of args\n-                break;\n-            }\n+        int argCount = 1;\n+        boolean isArgEnd = false;\n+        while (!isArgEnd) {", "originalCommit": "f838a70ba26890edd7c319b862e7bed6a8321e2f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjY4NDIyNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25521#discussion_r482684227", "bodyText": "Taking this snippet out (immediately after the parseErrorArgsBindingPatternEnd) will simplify the logic", "author": "SupunS", "createdAt": "2020-09-03T03:40:26Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12975,165 +12987,277 @@ private boolean isEndOfMappingBindingPattern(SyntaxKind nextTokenKind) {\n         return nextTokenKind == SyntaxKind.CLOSE_BRACE_TOKEN;\n     }\n \n+    private STNode parseErrorTypeDescOrErrorBP(STNode annots) {\n+        STToken nextNextToken = peek(2);\n+        switch (nextNextToken.kind) {\n+            case OPEN_PAREN_TOKEN:// Error binding pattern\n+                return parseAsErrorBP();\n+            case LT_TOKEN:\n+                return parseAsErrorTypeDesc(annots);\n+            case IDENTIFIER_TOKEN:\n+                // If the next token is identifier it can be either error a; or error a (errorMessage);\n+                SyntaxKind nextNextNextTokenKind = peek(3).kind;\n+                if (nextNextNextTokenKind == SyntaxKind.COLON_TOKEN ||\n+                        nextNextNextTokenKind == SyntaxKind.OPEN_PAREN_TOKEN) {\n+                    return parseAsErrorBP();\n+                }\n+                // Fall through.\n+            default:\n+                return parseAsErrorTypeDesc(annots);\n+        }\n+    }\n+\n+    private STNode parseAsErrorBP() {\n+        startContext(ParserRuleContext.ASSIGNMENT_STMT);\n+        return parseAssignmentStmtRhs(parseErrorBindingPattern());\n+    }\n+\n+    private STNode parseAsErrorTypeDesc(STNode annots) {\n+        STNode finalKeyword = STNodeFactory.createEmptyNode();\n+        return parseVariableDecl(getAnnotations(annots), finalKeyword, false);\n+    }\n     /**\n      * Parse error binding pattern node.\n      * <p>\n-     * <code>functional-binding-pattern := error ( arg-list-binding-pattern )</code>\n+     * <code>error-binding-pattern := error [error-type-reference] ( error-arg-list-binding-pattern )</code>\n+     * <br/><br/>\n+     * error-arg-list-binding-pattern :=\n+     *    error-message-binding-pattern [, error-cause-binding-pattern] [, error-field-binding-patterns]\n+     *    | [error-field-binding-patterns]\n+     * <br/><br/>\n+     * error-message-binding-pattern := simple-binding-pattern\n+     * <br/><br/>\n+     * error-cause-binding-pattern := simple-binding-pattern | error-binding-pattern\n+     * <br/><br/>\n+     * simple-binding-pattern := capture-binding-pattern | wildcard-binding-pattern\n+     * <br/><br/>\n+     * error-field-binding-patterns :=\n+     *    named-arg-binding-pattern (, named-arg-binding-pattern)* [, rest-binding-pattern]\n+     *    | rest-binding-pattern\n+     * <br/><br/>\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n      * \n      * @return Error binding pattern node.\n      */\n     private STNode parseErrorBindingPattern() {\n-        startContext(ParserRuleContext.FUNCTIONAL_BINDING_PATTERN);\n-        STNode typeDesc = parseErrorKeyword();\n-        return parseFunctionalBindingPattern(typeDesc);\n+        startContext(ParserRuleContext.ERROR_BINDING_PATTERN);\n+        STNode errorKeyword = parseErrorKeyword();\n+        return parseErrorBindingPattern(errorKeyword);\n+    }\n+\n+    private STNode parseErrorBindingPattern(STNode errorKeyword) {\n+        STToken nextToken = peek();\n+        STNode typeRef;\n+        switch (nextToken.kind) {\n+            case IDENTIFIER_TOKEN:\n+                typeRef = parseTypeReference();\n+                break;\n+            case OPEN_PAREN_TOKEN:\n+                typeRef = STNodeFactory.createEmptyNode();\n+                break;\n+            default:\n+                recover(peek(), ParserRuleContext.ERROR_BINDING_PATTERN_ERROR_KEYWORD_RHS);\n+                return parseErrorBindingPattern(errorKeyword);\n+        }\n+        return parseErrorBindingPattern(errorKeyword, typeRef);\n+    }\n+\n+    private STNode parseErrorBindingPattern(STNode errorKeyword, STNode typeRef) {\n+        STNode openParenthesis = parseOpenParenthesis(ParserRuleContext.OPEN_PARENTHESIS);\n+        STNode argListBindingPatterns = parseErrorArgListBindingPatterns();\n+        STNode closeParenthesis = parseCloseParenthesis();\n+        endContext();\n+        return STNodeFactory.createErrorBindingPatternNode(errorKeyword, typeRef, openParenthesis,\n+                argListBindingPatterns, closeParenthesis);\n     }\n \n     /**\n-     * Parse functional binding pattern.\n+     * Parse error arg list binding pattern.\n      * <p>\n      * <code>\n-     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * error-arg-list-binding-pattern :=\n+     * error-message-binding-pattern [, error-cause-binding-pattern] [, error-field-binding-patterns]\n+     * | [error-field-binding-patterns]\n      * <br/><br/>\n-     * functionally-constructible-type-reference := error | type-reference\n+     *\n+     * error-message-binding-pattern := simple-binding-pattern\n+     * <br/><br/>\n+     *\n+     * error-cause-binding-pattern := simple-binding-pattern | error-binding-pattern\n+     * <br/><br/>\n+     *\n+     * simple-binding-pattern := capture-binding-pattern | wildcard-binding-pattern\n+     * <br/><br/>\n+     *\n+     * error-field-binding-patterns :=\n+     * named-arg-binding-pattern (, named-arg-binding-pattern)* [, rest-binding-pattern]\n+     * | rest-binding-pattern\n+     * <br/><br/>\n+     *\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n      * </code>\n-     * \n-     * @param typeDesc Functionally constructible type reference\n-     * @return Functional binding pattern node.\n+     *\n+     * @return Error arg list binding patterns.\n      */\n-    private STNode parseFunctionalBindingPattern(STNode typeDesc) {\n-        STNode openParenthesis = parseOpenParenthesis(ParserRuleContext.ARG_LIST_START);\n-        STNode argListBindingPatterns = parseArgListBindingPatterns();\n-        STNode closeParenthesis = parseCloseParenthesis();\n-        endContext();\n-        return STNodeFactory.createFunctionalBindingPatternNode(typeDesc, openParenthesis, argListBindingPatterns,\n-                closeParenthesis);\n-    }\n-\n-    private STNode parseArgListBindingPatterns() {\n+    private STNode parseErrorArgListBindingPatterns() {\n         List<STNode> argListBindingPatterns = new ArrayList<>();\n         SyntaxKind lastValidArgKind = SyntaxKind.CAPTURE_BINDING_PATTERN;\n         STToken nextToken = peek();\n \n         if (isEndOfParametersList(nextToken.kind)) {\n             return STNodeFactory.createNodeList(argListBindingPatterns);\n         }\n-        argListBindingPatterns.add(parseArgBindingPattern());\n \n-        nextToken = peek();\n-        while (!isEndOfParametersList(nextToken.kind)) {\n-            STNode argEnd = parseArgsBindingPatternEnd();\n-            if (argEnd == null) {\n-                // null marks the end of args\n-                break;\n-            }\n+        int argCount = 1;\n+        boolean isArgEnd = false;\n+        while (!isArgEnd) {\n \n-            nextToken = peek();\n-            STNode currentArg = parseArgBindingPattern();\n-            DiagnosticErrorCode errorCode = validateArgBindingPatternOrder(lastValidArgKind, currentArg.kind);\n+            STNode currentArg = parseErrorArgListBindingPattern(argCount);\n+            DiagnosticErrorCode errorCode = validateArgBindingPatternOrder(lastValidArgKind, currentArg.kind,\n+                    argCount);\n+            STNode argEnd = parseErrorArgsBindingPatternEnd(argCount);\n             if (errorCode == null) {\n-                argListBindingPatterns.add(argEnd);\n                 argListBindingPatterns.add(currentArg);\n+                if (argEnd == null) {\n+                    // null marks the end of args\n+                    break;", "originalCommit": "f838a70ba26890edd7c319b862e7bed6a8321e2f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjY4NzAyOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25521#discussion_r482687028", "bodyText": "toString() method will include minutiae including comments, invalid tokens, etc..", "author": "SupunS", "createdAt": "2020-09-03T03:51:29Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12975,165 +12987,277 @@ private boolean isEndOfMappingBindingPattern(SyntaxKind nextTokenKind) {\n         return nextTokenKind == SyntaxKind.CLOSE_BRACE_TOKEN;\n     }\n \n+    private STNode parseErrorTypeDescOrErrorBP(STNode annots) {\n+        STToken nextNextToken = peek(2);\n+        switch (nextNextToken.kind) {\n+            case OPEN_PAREN_TOKEN:// Error binding pattern\n+                return parseAsErrorBP();\n+            case LT_TOKEN:\n+                return parseAsErrorTypeDesc(annots);\n+            case IDENTIFIER_TOKEN:\n+                // If the next token is identifier it can be either error a; or error a (errorMessage);\n+                SyntaxKind nextNextNextTokenKind = peek(3).kind;\n+                if (nextNextNextTokenKind == SyntaxKind.COLON_TOKEN ||\n+                        nextNextNextTokenKind == SyntaxKind.OPEN_PAREN_TOKEN) {\n+                    return parseAsErrorBP();\n+                }\n+                // Fall through.\n+            default:\n+                return parseAsErrorTypeDesc(annots);\n+        }\n+    }\n+\n+    private STNode parseAsErrorBP() {\n+        startContext(ParserRuleContext.ASSIGNMENT_STMT);\n+        return parseAssignmentStmtRhs(parseErrorBindingPattern());\n+    }\n+\n+    private STNode parseAsErrorTypeDesc(STNode annots) {\n+        STNode finalKeyword = STNodeFactory.createEmptyNode();\n+        return parseVariableDecl(getAnnotations(annots), finalKeyword, false);\n+    }\n     /**\n      * Parse error binding pattern node.\n      * <p>\n-     * <code>functional-binding-pattern := error ( arg-list-binding-pattern )</code>\n+     * <code>error-binding-pattern := error [error-type-reference] ( error-arg-list-binding-pattern )</code>\n+     * <br/><br/>\n+     * error-arg-list-binding-pattern :=\n+     *    error-message-binding-pattern [, error-cause-binding-pattern] [, error-field-binding-patterns]\n+     *    | [error-field-binding-patterns]\n+     * <br/><br/>\n+     * error-message-binding-pattern := simple-binding-pattern\n+     * <br/><br/>\n+     * error-cause-binding-pattern := simple-binding-pattern | error-binding-pattern\n+     * <br/><br/>\n+     * simple-binding-pattern := capture-binding-pattern | wildcard-binding-pattern\n+     * <br/><br/>\n+     * error-field-binding-patterns :=\n+     *    named-arg-binding-pattern (, named-arg-binding-pattern)* [, rest-binding-pattern]\n+     *    | rest-binding-pattern\n+     * <br/><br/>\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n      * \n      * @return Error binding pattern node.\n      */\n     private STNode parseErrorBindingPattern() {\n-        startContext(ParserRuleContext.FUNCTIONAL_BINDING_PATTERN);\n-        STNode typeDesc = parseErrorKeyword();\n-        return parseFunctionalBindingPattern(typeDesc);\n+        startContext(ParserRuleContext.ERROR_BINDING_PATTERN);\n+        STNode errorKeyword = parseErrorKeyword();\n+        return parseErrorBindingPattern(errorKeyword);\n+    }\n+\n+    private STNode parseErrorBindingPattern(STNode errorKeyword) {\n+        STToken nextToken = peek();\n+        STNode typeRef;\n+        switch (nextToken.kind) {\n+            case IDENTIFIER_TOKEN:\n+                typeRef = parseTypeReference();\n+                break;\n+            case OPEN_PAREN_TOKEN:\n+                typeRef = STNodeFactory.createEmptyNode();\n+                break;\n+            default:\n+                recover(peek(), ParserRuleContext.ERROR_BINDING_PATTERN_ERROR_KEYWORD_RHS);\n+                return parseErrorBindingPattern(errorKeyword);\n+        }\n+        return parseErrorBindingPattern(errorKeyword, typeRef);\n+    }\n+\n+    private STNode parseErrorBindingPattern(STNode errorKeyword, STNode typeRef) {\n+        STNode openParenthesis = parseOpenParenthesis(ParserRuleContext.OPEN_PARENTHESIS);\n+        STNode argListBindingPatterns = parseErrorArgListBindingPatterns();\n+        STNode closeParenthesis = parseCloseParenthesis();\n+        endContext();\n+        return STNodeFactory.createErrorBindingPatternNode(errorKeyword, typeRef, openParenthesis,\n+                argListBindingPatterns, closeParenthesis);\n     }\n \n     /**\n-     * Parse functional binding pattern.\n+     * Parse error arg list binding pattern.\n      * <p>\n      * <code>\n-     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * error-arg-list-binding-pattern :=\n+     * error-message-binding-pattern [, error-cause-binding-pattern] [, error-field-binding-patterns]\n+     * | [error-field-binding-patterns]\n      * <br/><br/>\n-     * functionally-constructible-type-reference := error | type-reference\n+     *\n+     * error-message-binding-pattern := simple-binding-pattern\n+     * <br/><br/>\n+     *\n+     * error-cause-binding-pattern := simple-binding-pattern | error-binding-pattern\n+     * <br/><br/>\n+     *\n+     * simple-binding-pattern := capture-binding-pattern | wildcard-binding-pattern\n+     * <br/><br/>\n+     *\n+     * error-field-binding-patterns :=\n+     * named-arg-binding-pattern (, named-arg-binding-pattern)* [, rest-binding-pattern]\n+     * | rest-binding-pattern\n+     * <br/><br/>\n+     *\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n      * </code>\n-     * \n-     * @param typeDesc Functionally constructible type reference\n-     * @return Functional binding pattern node.\n+     *\n+     * @return Error arg list binding patterns.\n      */\n-    private STNode parseFunctionalBindingPattern(STNode typeDesc) {\n-        STNode openParenthesis = parseOpenParenthesis(ParserRuleContext.ARG_LIST_START);\n-        STNode argListBindingPatterns = parseArgListBindingPatterns();\n-        STNode closeParenthesis = parseCloseParenthesis();\n-        endContext();\n-        return STNodeFactory.createFunctionalBindingPatternNode(typeDesc, openParenthesis, argListBindingPatterns,\n-                closeParenthesis);\n-    }\n-\n-    private STNode parseArgListBindingPatterns() {\n+    private STNode parseErrorArgListBindingPatterns() {\n         List<STNode> argListBindingPatterns = new ArrayList<>();\n         SyntaxKind lastValidArgKind = SyntaxKind.CAPTURE_BINDING_PATTERN;\n         STToken nextToken = peek();\n \n         if (isEndOfParametersList(nextToken.kind)) {\n             return STNodeFactory.createNodeList(argListBindingPatterns);\n         }\n-        argListBindingPatterns.add(parseArgBindingPattern());\n \n-        nextToken = peek();\n-        while (!isEndOfParametersList(nextToken.kind)) {\n-            STNode argEnd = parseArgsBindingPatternEnd();\n-            if (argEnd == null) {\n-                // null marks the end of args\n-                break;\n-            }\n+        int argCount = 1;\n+        boolean isArgEnd = false;\n+        while (!isArgEnd) {\n \n-            nextToken = peek();\n-            STNode currentArg = parseArgBindingPattern();\n-            DiagnosticErrorCode errorCode = validateArgBindingPatternOrder(lastValidArgKind, currentArg.kind);\n+            STNode currentArg = parseErrorArgListBindingPattern(argCount);\n+            DiagnosticErrorCode errorCode = validateArgBindingPatternOrder(lastValidArgKind, currentArg.kind,\n+                    argCount);\n+            STNode argEnd = parseErrorArgsBindingPatternEnd(argCount);\n             if (errorCode == null) {\n-                argListBindingPatterns.add(argEnd);\n                 argListBindingPatterns.add(currentArg);\n+                if (argEnd == null) {\n+                    // null marks the end of args\n+                    break;\n+                }\n+                argListBindingPatterns.add(argEnd);\n                 lastValidArgKind = currentArg.kind;\n+                argCount++;\n             } else {\n-                updateLastNodeInListWithInvalidNode(argListBindingPatterns, argEnd, null);\n-                updateLastNodeInListWithInvalidNode(argListBindingPatterns, currentArg, errorCode);\n+                if (argListBindingPatterns.size() != 0) {\n+                    updateLastNodeInListWithInvalidNode(argListBindingPatterns, currentArg, errorCode);\n+                    if (argEnd != null) {\n+                        updateLastNodeInListWithInvalidNode(argListBindingPatterns, argEnd, null);\n+                    }\n+                } else {\n+                    addInvalidNodeToNextToken(currentArg, errorCode, currentArg.toString().trim());", "originalCommit": "f838a70ba26890edd7c319b862e7bed6a8321e2f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjY4OTQxMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25521#discussion_r482689413", "bodyText": "Can we only rely on the lastValidArgKind?\nI feel we can do all the validation only using the lastValidArgKind..", "author": "SupunS", "createdAt": "2020-09-03T04:00:41Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12975,165 +12987,277 @@ private boolean isEndOfMappingBindingPattern(SyntaxKind nextTokenKind) {\n         return nextTokenKind == SyntaxKind.CLOSE_BRACE_TOKEN;\n     }\n \n+    private STNode parseErrorTypeDescOrErrorBP(STNode annots) {\n+        STToken nextNextToken = peek(2);\n+        switch (nextNextToken.kind) {\n+            case OPEN_PAREN_TOKEN:// Error binding pattern\n+                return parseAsErrorBP();\n+            case LT_TOKEN:\n+                return parseAsErrorTypeDesc(annots);\n+            case IDENTIFIER_TOKEN:\n+                // If the next token is identifier it can be either error a; or error a (errorMessage);\n+                SyntaxKind nextNextNextTokenKind = peek(3).kind;\n+                if (nextNextNextTokenKind == SyntaxKind.COLON_TOKEN ||\n+                        nextNextNextTokenKind == SyntaxKind.OPEN_PAREN_TOKEN) {\n+                    return parseAsErrorBP();\n+                }\n+                // Fall through.\n+            default:\n+                return parseAsErrorTypeDesc(annots);\n+        }\n+    }\n+\n+    private STNode parseAsErrorBP() {\n+        startContext(ParserRuleContext.ASSIGNMENT_STMT);\n+        return parseAssignmentStmtRhs(parseErrorBindingPattern());\n+    }\n+\n+    private STNode parseAsErrorTypeDesc(STNode annots) {\n+        STNode finalKeyword = STNodeFactory.createEmptyNode();\n+        return parseVariableDecl(getAnnotations(annots), finalKeyword, false);\n+    }\n     /**\n      * Parse error binding pattern node.\n      * <p>\n-     * <code>functional-binding-pattern := error ( arg-list-binding-pattern )</code>\n+     * <code>error-binding-pattern := error [error-type-reference] ( error-arg-list-binding-pattern )</code>\n+     * <br/><br/>\n+     * error-arg-list-binding-pattern :=\n+     *    error-message-binding-pattern [, error-cause-binding-pattern] [, error-field-binding-patterns]\n+     *    | [error-field-binding-patterns]\n+     * <br/><br/>\n+     * error-message-binding-pattern := simple-binding-pattern\n+     * <br/><br/>\n+     * error-cause-binding-pattern := simple-binding-pattern | error-binding-pattern\n+     * <br/><br/>\n+     * simple-binding-pattern := capture-binding-pattern | wildcard-binding-pattern\n+     * <br/><br/>\n+     * error-field-binding-patterns :=\n+     *    named-arg-binding-pattern (, named-arg-binding-pattern)* [, rest-binding-pattern]\n+     *    | rest-binding-pattern\n+     * <br/><br/>\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n      * \n      * @return Error binding pattern node.\n      */\n     private STNode parseErrorBindingPattern() {\n-        startContext(ParserRuleContext.FUNCTIONAL_BINDING_PATTERN);\n-        STNode typeDesc = parseErrorKeyword();\n-        return parseFunctionalBindingPattern(typeDesc);\n+        startContext(ParserRuleContext.ERROR_BINDING_PATTERN);\n+        STNode errorKeyword = parseErrorKeyword();\n+        return parseErrorBindingPattern(errorKeyword);\n+    }\n+\n+    private STNode parseErrorBindingPattern(STNode errorKeyword) {\n+        STToken nextToken = peek();\n+        STNode typeRef;\n+        switch (nextToken.kind) {\n+            case IDENTIFIER_TOKEN:\n+                typeRef = parseTypeReference();\n+                break;\n+            case OPEN_PAREN_TOKEN:\n+                typeRef = STNodeFactory.createEmptyNode();\n+                break;\n+            default:\n+                recover(peek(), ParserRuleContext.ERROR_BINDING_PATTERN_ERROR_KEYWORD_RHS);\n+                return parseErrorBindingPattern(errorKeyword);\n+        }\n+        return parseErrorBindingPattern(errorKeyword, typeRef);\n+    }\n+\n+    private STNode parseErrorBindingPattern(STNode errorKeyword, STNode typeRef) {\n+        STNode openParenthesis = parseOpenParenthesis(ParserRuleContext.OPEN_PARENTHESIS);\n+        STNode argListBindingPatterns = parseErrorArgListBindingPatterns();\n+        STNode closeParenthesis = parseCloseParenthesis();\n+        endContext();\n+        return STNodeFactory.createErrorBindingPatternNode(errorKeyword, typeRef, openParenthesis,\n+                argListBindingPatterns, closeParenthesis);\n     }\n \n     /**\n-     * Parse functional binding pattern.\n+     * Parse error arg list binding pattern.\n      * <p>\n      * <code>\n-     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * error-arg-list-binding-pattern :=\n+     * error-message-binding-pattern [, error-cause-binding-pattern] [, error-field-binding-patterns]\n+     * | [error-field-binding-patterns]\n      * <br/><br/>\n-     * functionally-constructible-type-reference := error | type-reference\n+     *\n+     * error-message-binding-pattern := simple-binding-pattern\n+     * <br/><br/>\n+     *\n+     * error-cause-binding-pattern := simple-binding-pattern | error-binding-pattern\n+     * <br/><br/>\n+     *\n+     * simple-binding-pattern := capture-binding-pattern | wildcard-binding-pattern\n+     * <br/><br/>\n+     *\n+     * error-field-binding-patterns :=\n+     * named-arg-binding-pattern (, named-arg-binding-pattern)* [, rest-binding-pattern]\n+     * | rest-binding-pattern\n+     * <br/><br/>\n+     *\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n      * </code>\n-     * \n-     * @param typeDesc Functionally constructible type reference\n-     * @return Functional binding pattern node.\n+     *\n+     * @return Error arg list binding patterns.\n      */\n-    private STNode parseFunctionalBindingPattern(STNode typeDesc) {\n-        STNode openParenthesis = parseOpenParenthesis(ParserRuleContext.ARG_LIST_START);\n-        STNode argListBindingPatterns = parseArgListBindingPatterns();\n-        STNode closeParenthesis = parseCloseParenthesis();\n-        endContext();\n-        return STNodeFactory.createFunctionalBindingPatternNode(typeDesc, openParenthesis, argListBindingPatterns,\n-                closeParenthesis);\n-    }\n-\n-    private STNode parseArgListBindingPatterns() {\n+    private STNode parseErrorArgListBindingPatterns() {\n         List<STNode> argListBindingPatterns = new ArrayList<>();\n         SyntaxKind lastValidArgKind = SyntaxKind.CAPTURE_BINDING_PATTERN;\n         STToken nextToken = peek();\n \n         if (isEndOfParametersList(nextToken.kind)) {\n             return STNodeFactory.createNodeList(argListBindingPatterns);\n         }\n-        argListBindingPatterns.add(parseArgBindingPattern());\n \n-        nextToken = peek();\n-        while (!isEndOfParametersList(nextToken.kind)) {\n-            STNode argEnd = parseArgsBindingPatternEnd();\n-            if (argEnd == null) {\n-                // null marks the end of args\n-                break;\n-            }\n+        int argCount = 1;", "originalCommit": "f838a70ba26890edd7c319b862e7bed6a8321e2f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8f7a81692afe2f04d27870c2b5429e9aace71c3a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8f7a81692afe2f04d27870c2b5429e9aace71c3a", "message": "Refactor code.", "committedDate": "2020-09-03T07:40:16Z", "type": "commit"}, {"oid": "787979b0b2560417f598df580ba4cb210d22df57", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/787979b0b2560417f598df580ba4cb210d22df57", "message": "Clean the parsing logic for error-arg-list-binding-pattern.", "committedDate": "2020-09-03T11:13:21Z", "type": "commit"}, {"oid": "4fe4b452947e1ee6675d1844c7e6d0bf979ef4ae", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4fe4b452947e1ee6675d1844c7e6d0bf979ef4ae", "message": "Undo change to foreach_stmt_ctx_config2.json", "committedDate": "2020-09-03T12:10:03Z", "type": "commit"}, {"oid": "d8952388abc9dc177fbbaa824119b226ab5f12e1", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d8952388abc9dc177fbbaa824119b226ab5f12e1", "message": "Update foreach_stmt_ctx_config2.json", "committedDate": "2020-09-03T12:14:22Z", "type": "commit"}, {"oid": "255f71f6cb32ac76eeaff6ac8070aeec6dac51a6", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/255f71f6cb32ac76eeaff6ac8070aeec6dac51a6", "message": "Add new line to foreach_stmt_ctx_config2.json", "committedDate": "2020-09-03T14:03:25Z", "type": "commit"}, {"oid": "b2692e264ba3b0fe8bbc1f6ad685ba672e2e27f3", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b2692e264ba3b0fe8bbc1f6ad685ba672e2e27f3", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into remove-functional", "committedDate": "2020-09-03T15:44:19Z", "type": "commit"}, {"oid": "ff68af2d65f78ca06028bb945229cc4b6f7ae95f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ff68af2d65f78ca06028bb945229cc4b6f7ae95f", "message": "Reformat foreach_stmt_ctx_config2.json", "committedDate": "2020-09-04T03:54:22Z", "type": "commit"}, {"oid": "fb5c77a46bd333f3ff429cd8719fc02787459f00", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fb5c77a46bd333f3ff429cd8719fc02787459f00", "message": "Fix CCE in NodeTransformer.", "committedDate": "2020-09-04T08:17:23Z", "type": "commit"}, {"oid": "908a5cf1fb56973e75669cd616060a22550392d8", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/908a5cf1fb56973e75669cd616060a22550392d8", "message": "Update foreach_stmt_ctx_config2.json", "committedDate": "2020-09-04T09:21:53Z", "type": "commit"}, {"oid": "1e5d00d599006b3f4394f18f682a051cd40b2a2e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1e5d00d599006b3f4394f18f682a051cd40b2a2e", "message": "Add new line.", "committedDate": "2020-09-04T09:22:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUxMzg5Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25521#discussion_r483513896", "bodyText": "can merge the else and the if", "author": "SupunS", "createdAt": "2020-09-04T09:51:31Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12975,165 +12987,265 @@ private boolean isEndOfMappingBindingPattern(SyntaxKind nextTokenKind) {\n         return nextTokenKind == SyntaxKind.CLOSE_BRACE_TOKEN;\n     }\n \n+    private STNode parseErrorTypeDescOrErrorBP(STNode annots) {\n+        STToken nextNextToken = peek(2);\n+        switch (nextNextToken.kind) {\n+            case OPEN_PAREN_TOKEN:// Error binding pattern\n+                return parseAsErrorBindingPattern();\n+            case LT_TOKEN:\n+                return parseAsErrorTypeDesc(annots);\n+            case IDENTIFIER_TOKEN:\n+                // If the next token is identifier it can be either error a; or error a (errorMessage);\n+                SyntaxKind nextNextNextTokenKind = peek(3).kind;\n+                if (nextNextNextTokenKind == SyntaxKind.COLON_TOKEN ||\n+                        nextNextNextTokenKind == SyntaxKind.OPEN_PAREN_TOKEN) {\n+                    return parseAsErrorBindingPattern();\n+                }\n+                // Fall through.\n+            default:\n+                return parseAsErrorTypeDesc(annots);\n+        }\n+    }\n+\n+    private STNode parseAsErrorBindingPattern() {\n+        startContext(ParserRuleContext.ASSIGNMENT_STMT);\n+        return parseAssignmentStmtRhs(parseErrorBindingPattern());\n+    }\n+\n+    private STNode parseAsErrorTypeDesc(STNode annots) {\n+        STNode finalKeyword = STNodeFactory.createEmptyNode();\n+        return parseVariableDecl(getAnnotations(annots), finalKeyword, false);\n+    }\n+\n     /**\n      * Parse error binding pattern node.\n      * <p>\n-     * <code>functional-binding-pattern := error ( arg-list-binding-pattern )</code>\n+     * <code>error-binding-pattern := error [error-type-reference] ( error-arg-list-binding-pattern )</code>\n+     * <br/><br/>\n+     * error-arg-list-binding-pattern :=\n+     *    error-message-binding-pattern [, error-cause-binding-pattern] [, error-field-binding-patterns]\n+     *    | [error-field-binding-patterns]\n+     * <br/><br/>\n+     * error-message-binding-pattern := simple-binding-pattern\n+     * <br/><br/>\n+     * error-cause-binding-pattern := simple-binding-pattern | error-binding-pattern\n+     * <br/><br/>\n+     * simple-binding-pattern := capture-binding-pattern | wildcard-binding-pattern\n+     * <br/><br/>\n+     * error-field-binding-patterns :=\n+     *    named-arg-binding-pattern (, named-arg-binding-pattern)* [, rest-binding-pattern]\n+     *    | rest-binding-pattern\n+     * <br/><br/>\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n      * \n      * @return Error binding pattern node.\n      */\n     private STNode parseErrorBindingPattern() {\n-        startContext(ParserRuleContext.FUNCTIONAL_BINDING_PATTERN);\n-        STNode typeDesc = parseErrorKeyword();\n-        return parseFunctionalBindingPattern(typeDesc);\n+        startContext(ParserRuleContext.ERROR_BINDING_PATTERN);\n+        STNode errorKeyword = parseErrorKeyword();\n+        return parseErrorBindingPattern(errorKeyword);\n+    }\n+\n+    private STNode parseErrorBindingPattern(STNode errorKeyword) {\n+        STToken nextToken = peek();\n+        STNode typeRef;\n+        switch (nextToken.kind) {\n+            case IDENTIFIER_TOKEN:\n+                typeRef = parseTypeReference();\n+                break;\n+            case OPEN_PAREN_TOKEN:\n+                typeRef = STNodeFactory.createEmptyNode();\n+                break;\n+            default:\n+                recover(peek(), ParserRuleContext.ERROR_BINDING_PATTERN_ERROR_KEYWORD_RHS);\n+                return parseErrorBindingPattern(errorKeyword);\n+        }\n+        return parseErrorBindingPattern(errorKeyword, typeRef);\n+    }\n+\n+    private STNode parseErrorBindingPattern(STNode errorKeyword, STNode typeRef) {\n+        STNode openParenthesis = parseOpenParenthesis(ParserRuleContext.OPEN_PARENTHESIS);\n+        STNode argListBindingPatterns = parseErrorArgListBindingPatterns();\n+        STNode closeParenthesis = parseCloseParenthesis();\n+        endContext();\n+        return STNodeFactory.createErrorBindingPatternNode(errorKeyword, typeRef, openParenthesis,\n+                argListBindingPatterns, closeParenthesis);\n     }\n \n     /**\n-     * Parse functional binding pattern.\n+     * Parse error arg list binding pattern.\n      * <p>\n      * <code>\n-     * functional-binding-pattern := functionally-constructible-type-reference ( arg-list-binding-pattern )\n+     * error-arg-list-binding-pattern :=\n+     * error-message-binding-pattern [, error-cause-binding-pattern] [, error-field-binding-patterns]\n+     * | [error-field-binding-patterns]\n      * <br/><br/>\n-     * functionally-constructible-type-reference := error | type-reference\n+     *\n+     * error-message-binding-pattern := simple-binding-pattern\n+     * <br/><br/>\n+     *\n+     * error-cause-binding-pattern := simple-binding-pattern | error-binding-pattern\n+     * <br/><br/>\n+     *\n+     * simple-binding-pattern := capture-binding-pattern | wildcard-binding-pattern\n+     * <br/><br/>\n+     *\n+     * error-field-binding-patterns :=\n+     * named-arg-binding-pattern (, named-arg-binding-pattern)* [, rest-binding-pattern]\n+     * | rest-binding-pattern\n+     * <br/><br/>\n+     *\n+     * named-arg-binding-pattern := arg-name = binding-pattern\n      * </code>\n-     * \n-     * @param typeDesc Functionally constructible type reference\n-     * @return Functional binding pattern node.\n+     *\n+     * @return Error arg list binding patterns.\n      */\n-    private STNode parseFunctionalBindingPattern(STNode typeDesc) {\n-        STNode openParenthesis = parseOpenParenthesis(ParserRuleContext.ARG_LIST_START);\n-        STNode argListBindingPatterns = parseArgListBindingPatterns();\n-        STNode closeParenthesis = parseCloseParenthesis();\n-        endContext();\n-        return STNodeFactory.createFunctionalBindingPatternNode(typeDesc, openParenthesis, argListBindingPatterns,\n-                closeParenthesis);\n-    }\n-\n-    private STNode parseArgListBindingPatterns() {\n+    private STNode parseErrorArgListBindingPatterns() {\n         List<STNode> argListBindingPatterns = new ArrayList<>();\n-        SyntaxKind lastValidArgKind = SyntaxKind.CAPTURE_BINDING_PATTERN;\n-        STToken nextToken = peek();\n-\n-        if (isEndOfParametersList(nextToken.kind)) {\n+        if (isEndOfErrorFieldBindingPatterns()) {\n             return STNodeFactory.createNodeList(argListBindingPatterns);\n         }\n-        argListBindingPatterns.add(parseArgBindingPattern());\n+        STNode firstArg = parseErrorArgListBindingPattern(ParserRuleContext.ERROR_ARG_LIST_BINDING_PATTERN_START);\n+        if (firstArg.kind == SyntaxKind.CAPTURE_BINDING_PATTERN ||\n+                firstArg.kind == SyntaxKind.WILDCARD_BINDING_PATTERN) {\n \n-        nextToken = peek();\n-        while (!isEndOfParametersList(nextToken.kind)) {\n-            STNode argEnd = parseArgsBindingPatternEnd();\n+            argListBindingPatterns.add(firstArg);\n+            STNode argEnd = parseErrorArgsBindingPatternEnd(ParserRuleContext.ERROR_MESSAGE_BINDING_PATTERN_END);\n+            if (argEnd != null) {\n+                // null marks the end of args\n+                STNode secondArg = parseErrorArgListBindingPattern(ParserRuleContext.ERROR_MESSAGE_BINDING_PATTERN_RHS);\n+                if (isValidSecondArgBindingPattern(secondArg.kind)) {\n+                    argListBindingPatterns.add(argEnd);\n+                    argListBindingPatterns.add(secondArg);\n+                } else {\n+                    updateLastNodeInListWithInvalidNode(argListBindingPatterns, argEnd, null);\n+                    updateLastNodeInListWithInvalidNode(argListBindingPatterns, secondArg,\n+                            DiagnosticErrorCode.ERROR_BINDING_PATTERN_NOT_ALLOWED);\n+                }\n+            }\n+        } else {\n+            if (firstArg.kind != SyntaxKind.NAMED_ARG_BINDING_PATTERN &&", "originalCommit": "1e5d00d599006b3f4394f18f682a051cd40b2a2e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}