{"pr_number": 25653, "pr_title": "Implement Balo Writer", "pr_createdAt": "2020-09-07T14:06:50Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/25653", "timeline": [{"oid": "97442474e7445f9665e8e0fb09bacda7ac451aac", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/97442474e7445f9665e8e0fb09bacda7ac451aac", "message": "Implement Balo Writer\n\nFixes https://github.com/ballerina-platform/ballerina-lang/issues/25587", "committedDate": "2020-09-07T14:04:27Z", "type": "commit"}, {"oid": "6af8a23e77cfac267f5b5bc0ac3282b4a656a6bf", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6af8a23e77cfac267f5b5bc0ac3282b4a656a6bf", "message": "Fix issues in BaloWriter", "committedDate": "2020-09-07T18:55:59Z", "type": "commit"}, {"oid": "fde4c5f1ff12ae902e46f551b3d0def2427fd4a6", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fde4c5f1ff12ae902e46f551b3d0def2427fd4a6", "message": "Add test case for BaloWriter", "committedDate": "2020-09-10T07:56:22Z", "type": "commit"}, {"oid": "fde4c5f1ff12ae902e46f551b3d0def2427fd4a6", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fde4c5f1ff12ae902e46f551b3d0def2427fd4a6", "message": "Add test case for BaloWriter", "committedDate": "2020-09-10T07:56:22Z", "type": "forcePushed"}, {"oid": "2efcb4da3eb6756bd07fb3b29b32a60b1d519f48", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2efcb4da3eb6756bd07fb3b29b32a60b1d519f48", "message": "Add & improve tests", "committedDate": "2020-09-11T09:48:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE0ODg0Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25653#discussion_r488148846", "bodyText": "Looks like this method is unused. If so, can we remove it?", "author": "azinneera", "createdAt": "2020-09-14T18:49:53Z", "path": "project-api/ballerina-projects/src/main/java/io/ballerina/projects/Package.java", "diffHunk": "@@ -63,4 +64,8 @@ public Module getDefaultModule() {\n     public BallerinaToml ballerinaToml() {\n         return this.packageContext.ballerinaToml();\n     }\n+\n+    public Path packagePath() {", "originalCommit": "2efcb4da3eb6756bd07fb3b29b32a60b1d519f48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODQxMTI5Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25653#discussion_r488411293", "bodyText": "It is used inside write in BaloWriter class", "author": "pramodya1994", "createdAt": "2020-09-15T06:15:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE0ODg0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE0OTkyMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25653#discussion_r488149923", "bodyText": "We should not be exposing the packageConfig. Instead we expose individual fields (whichever is necessary). Anyway looks like there is only used in Package#packagePath() and so we would not need this.", "author": "azinneera", "createdAt": "2020-09-14T18:51:45Z", "path": "project-api/ballerina-projects/src/main/java/io/ballerina/projects/PackageContext.java", "diffHunk": "@@ -99,4 +99,8 @@ ModuleContext defaultModuleContext() {\n     BallerinaToml ballerinaToml() {\n         return this.ballerinaToml;\n     }\n+\n+    PackageConfig packageConfig() {", "originalCommit": "2efcb4da3eb6756bd07fb3b29b32a60b1d519f48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODQxMzc2Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25653#discussion_r488413762", "bodyText": "Changed implementation to:\nPath packagePath() {\n        return this.packageConfig.packagePath();\n}", "author": "pramodya1994", "createdAt": "2020-09-15T06:21:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE0OTkyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE1NTE2MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25653#discussion_r488155161", "bodyText": "We can use ProjectConstants.MODULES_ROOT without initializing a new constant", "author": "azinneera", "createdAt": "2020-09-14T19:01:11Z", "path": "project-api/ballerina-projects/src/main/java/io/ballerina/projects/writers/BaloWriter.java", "diffHunk": "@@ -29,18 +59,347 @@\n  */\n public class BaloWriter {\n \n+    private static final String MODULES = \"modules\";", "originalCommit": "2efcb4da3eb6756bd07fb3b29b32a60b1d519f48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODQxNDc4Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25653#discussion_r488414783", "bodyText": "Added", "author": "pramodya1994", "createdAt": "2020-09-15T06:23:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE1NTE2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE1NTc0Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25653#discussion_r488155742", "bodyText": "We can remove these unnecessary comments.", "author": "azinneera", "createdAt": "2020-09-14T19:02:13Z", "path": "project-api/ballerina-projects/src/main/java/io/ballerina/projects/writers/BaloWriter.java", "diffHunk": "@@ -29,18 +59,347 @@\n  */\n public class BaloWriter {\n \n+    private static final String MODULES = \"modules\";\n+\n+    private BaloWriter() {}\n+\n     /**\n      * Write a package to a .balo and return the created .balo path.\n-     * @param pkg Package to be written as a .balo.\n+     *\n+     * @param pkg  Package to be written as a .balo.\n      * @param path Directory where the .balo should be created.\n      * @return Newly created balo path\n      */\n     public static Path write(Package pkg, Path path) {\n-        Path balo = path.resolve(\"org-name-any-version.balo\");\n         // todo check if the given package is compiled properly\n-        // todo check if the path is a directory\n+\n+        // Check if the path is a directory\n+        if (!path.toFile().isDirectory()) {\n+            throw new RuntimeException(\"Given path is not a directory: \" + path);\n+        }\n+\n         // Check directory permissions\n-        // Handle any io errors\n+//        if (!new File(String.valueOf(path)).canWrite()) {", "originalCommit": "2efcb4da3eb6756bd07fb3b29b32a60b1d519f48", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE2NDI1NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25653#discussion_r488164255", "bodyText": "Since this is an IO related exception, IMO, we don't need a custom exception to handle permissions. We can throw an the existing java exception. IOException or to be more specific,  AccessDeniedException would suffice here.", "author": "azinneera", "createdAt": "2020-09-14T19:17:34Z", "path": "project-api/ballerina-projects/src/main/java/io/ballerina/projects/writers/BaloWriter.java", "diffHunk": "@@ -29,18 +59,347 @@\n  */\n public class BaloWriter {\n \n+    private static final String MODULES = \"modules\";\n+\n+    private BaloWriter() {}\n+\n     /**\n      * Write a package to a .balo and return the created .balo path.\n-     * @param pkg Package to be written as a .balo.\n+     *\n+     * @param pkg  Package to be written as a .balo.\n      * @param path Directory where the .balo should be created.\n      * @return Newly created balo path\n      */\n     public static Path write(Package pkg, Path path) {\n-        Path balo = path.resolve(\"org-name-any-version.balo\");\n         // todo check if the given package is compiled properly\n-        // todo check if the path is a directory\n+\n+        // Check if the path is a directory\n+        if (!path.toFile().isDirectory()) {\n+            throw new RuntimeException(\"Given path is not a directory: \" + path);\n+        }\n+\n         // Check directory permissions\n-        // Handle any io errors\n+//        if (!new File(String.valueOf(path)).canWrite()) {\n+//            throw new NoPermissionException(\"No write access to create balo:\" + path);\n+//        }\n+\n+        if (!path.toFile().canWrite()) {\n+            throw new NoPermissionException(\"No write access to create balo:\" + path);", "originalCommit": "2efcb4da3eb6756bd07fb3b29b32a60b1d519f48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODQxNzAyOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25653#discussion_r488417028", "bodyText": "Used AccessDeniedException", "author": "pramodya1994", "createdAt": "2020-09-15T06:29:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE2NDI1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE2ODQ4NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25653#discussion_r488168484", "bodyText": "We can write the Files.delete(balo); within the first catch block (before L99). This way we don't need to catch and re-throw the BLangCompilerException", "author": "azinneera", "createdAt": "2020-09-14T19:25:35Z", "path": "project-api/ballerina-projects/src/main/java/io/ballerina/projects/writers/BaloWriter.java", "diffHunk": "@@ -29,18 +59,347 @@\n  */\n public class BaloWriter {\n \n+    private static final String MODULES = \"modules\";\n+\n+    private BaloWriter() {}\n+\n     /**\n      * Write a package to a .balo and return the created .balo path.\n-     * @param pkg Package to be written as a .balo.\n+     *\n+     * @param pkg  Package to be written as a .balo.\n      * @param path Directory where the .balo should be created.\n      * @return Newly created balo path\n      */\n     public static Path write(Package pkg, Path path) {\n-        Path balo = path.resolve(\"org-name-any-version.balo\");\n         // todo check if the given package is compiled properly\n-        // todo check if the path is a directory\n+\n+        // Check if the path is a directory\n+        if (!path.toFile().isDirectory()) {\n+            throw new RuntimeException(\"Given path is not a directory: \" + path);\n+        }\n+\n         // Check directory permissions\n-        // Handle any io errors\n+//        if (!new File(String.valueOf(path)).canWrite()) {\n+//            throw new NoPermissionException(\"No write access to create balo:\" + path);\n+//        }\n+\n+        if (!path.toFile().canWrite()) {\n+            throw new NoPermissionException(\"No write access to create balo:\" + path);\n+        }\n+\n+        BallerinaToml ballerinaToml = pkg.ballerinaToml();\n+        Path packagePath = pkg.packagePath();\n+        Path balo = path.resolve(getBaloName(ballerinaToml));\n+\n+        // Create the archive over write if exists\n+        try (FileSystem baloFS = createBaloArchive(balo)) {\n+            // Now lets put stuff in\n+            populateBaloArchive(baloFS, packagePath, ballerinaToml);\n+        } catch (IOException e) {\n+            throw new BLangCompilerException(\"Failed to create balo :\" + e.getMessage(), e);\n+        } catch (BLangCompilerException be) {", "originalCommit": "2efcb4da3eb6756bd07fb3b29b32a60b1d519f48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODQyNjMzOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25653#discussion_r488426338", "bodyText": "IOException in L 98. associate to the error when creating balo. At that case, we cant do Files.delete(balo); since balo is not created.", "author": "pramodya1994", "createdAt": "2020-09-15T06:50:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE2ODQ4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE3MjExMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25653#discussion_r488172111", "bodyText": "We can use ProjectConstants.RESOURCE_DIR_NAME instead of the hardcoded string \"resources\"", "author": "azinneera", "createdAt": "2020-09-14T19:32:48Z", "path": "project-api/ballerina-projects/src/main/java/io/ballerina/projects/writers/BaloWriter.java", "diffHunk": "@@ -29,18 +59,347 @@\n  */\n public class BaloWriter {\n \n+    private static final String MODULES = \"modules\";\n+\n+    private BaloWriter() {}\n+\n     /**\n      * Write a package to a .balo and return the created .balo path.\n-     * @param pkg Package to be written as a .balo.\n+     *\n+     * @param pkg  Package to be written as a .balo.\n      * @param path Directory where the .balo should be created.\n      * @return Newly created balo path\n      */\n     public static Path write(Package pkg, Path path) {\n-        Path balo = path.resolve(\"org-name-any-version.balo\");\n         // todo check if the given package is compiled properly\n-        // todo check if the path is a directory\n+\n+        // Check if the path is a directory\n+        if (!path.toFile().isDirectory()) {\n+            throw new RuntimeException(\"Given path is not a directory: \" + path);\n+        }\n+\n         // Check directory permissions\n-        // Handle any io errors\n+//        if (!new File(String.valueOf(path)).canWrite()) {\n+//            throw new NoPermissionException(\"No write access to create balo:\" + path);\n+//        }\n+\n+        if (!path.toFile().canWrite()) {\n+            throw new NoPermissionException(\"No write access to create balo:\" + path);\n+        }\n+\n+        BallerinaToml ballerinaToml = pkg.ballerinaToml();\n+        Path packagePath = pkg.packagePath();\n+        Path balo = path.resolve(getBaloName(ballerinaToml));\n+\n+        // Create the archive over write if exists\n+        try (FileSystem baloFS = createBaloArchive(balo)) {\n+            // Now lets put stuff in\n+            populateBaloArchive(baloFS, packagePath, ballerinaToml);\n+        } catch (IOException e) {\n+            throw new BLangCompilerException(\"Failed to create balo :\" + e.getMessage(), e);\n+        } catch (BLangCompilerException be) {\n+            // clean up if an error occur\n+            try {\n+                Files.delete(balo);\n+            } catch (IOException e) {\n+                // We ignore this error and throw out the original blang compiler error to the user\n+            }\n+            throw be;\n+        }\n         return balo;\n     }\n+\n+    private static String getBaloName(BallerinaToml ballerinaToml) {\n+        // <orgname>-<packagename>-<platform>-<version>.balo\n+        String platform = ballerinaToml.getPlatform().target;\n+        if (platform == null || \"\".equals(platform)) {\n+            platform = \"any\";\n+        }\n+        return ballerinaToml.getPackage().getOrg() + \"-\" + ballerinaToml.getPackage().getName() + \"-\"\n+                + platform + \"-\" + ballerinaToml.getPackage().getVersion() + \".balo\";\n+    }\n+\n+    private static FileSystem createBaloArchive(Path path) throws IOException {\n+        // TODO check apache commons zip file writer\n+        // Remove if file already exists\n+        if (path.toFile().exists()) {\n+            Files.delete(path);\n+        }\n+        // Define ZIP File System Properties\n+        Map<String, String> env = new HashMap<>();\n+        env.put(\"create\", \"true\");\n+        env.put(\"encoding\", \"UTF-8\");\n+\n+        /* Locate File on disk for creation */\n+        URI zipDisk = URI.create(\"jar:\" + path.toUri());\n+        /* Create ZIP file System */\n+        return FileSystems.newFileSystem(zipDisk, env);\n+    }\n+\n+    private static void populateBaloArchive(FileSystem baloFS, Path packagePath, BallerinaToml ballerinaToml)\n+            throws IOException {\n+        Path root = baloFS.getPath(\"/\");\n+        String packageName = ballerinaToml.getPackage().getName();\n+\n+        //   Add spec directory structure items\n+        //\n+        //   org-foo-any-1.0.0.balo\n+        //    \u251c\u2500\u2500 balo.json             ---> Details about balo\n+        //    \u251c\u2500\u2500 package.json          ---> Details about package within balo\n+        //    \u251c\u2500\u2500 docs/\n+        //    \u2502\t   \u251c\u2500\u2500 Package.md       ---> MD file describing the package\n+        //    \u2502\t   \u251c\u2500\u2500 modules/\n+        //    \u2502\t   \u2502\t\u251c\u2500\u2500 foo/\n+        //    \u2502\t   \u2502\t\u2502\t \u2514\u2500\u2500 Module.md\n+        //    \u2502\t   \u2502    \u251c\u2500\u2500 foo.bar/\n+        //    \u2502\t   \u2502    \u2514\u2500\u2500 foo.baz/\n+        //    \u2502    \u2514\u2500\u2500 api-docs.json    ---> API Docs json file\n+        //    \u251c\u2500\u2500 modules/\n+        //    \u2502\t   \u251c\u2500\u2500 foo/             ---> content of default module\n+        //    \u2502    \u251c\u2500\u2500 foo.bar/         ---> content of sub module\n+        //    \u2502    \u2514\u2500\u2500 foo.baz/         ---> content of sub module\n+        //    \u2502\t\t    \u251c\u2500\u2500 resources/\n+        //    \u2502\t        \u251c\u2500\u2500 first.bal\n+        //    \u2502\t        \u251c\u2500\u2500 second.bal\n+        //    \u2502         \u2514\u2500\u2500 third.bal\n+        //    \u251c\u2500\u2500 lib/                  ---> Platform Libraries\n+        //    \u2502\t   \u251c\u2500\u2500\n+        //    \u2502\t   \u2514\u2500\u2500 third-party.jar\n+        //    \u2514\u2500\u2500 ext/\n+        //         \u251c\u2500\u2500 datamapper/\n+        //         \u2514\u2500\u2500 ext2/\n+\n+        addBaloJson(root);\n+        addPackageJson(root, ballerinaToml);\n+        addPackageDoc(root, packagePath, ballerinaToml.getPackage().getName());\n+        addPackageSource(root, packagePath, packageName);\n+        // Add platform libs only if it is not a template module\n+        if (!ballerinaToml.isTemplateModule(packageName)) {\n+            addPlatformLibs(root, packagePath, ballerinaToml);\n+        }\n+    }\n+\n+    private static void addBaloJson(Path root) {\n+        Gson gson = new GsonBuilder().setPrettyPrinting().create();\n+        String baloJson = gson.toJson(new BaloJson());\n+        try {\n+            Files.write(root.resolve(\"balo.json\"), baloJson.getBytes(Charset.defaultCharset()));\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"Failed to write 'balo.json' file: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    private static void addPackageJson(Path root, BallerinaToml ballerinaToml) {\n+        io.ballerina.projects.model.Package pkg = ballerinaToml.getPackage();\n+        PackageJson packageJson = new PackageJson(pkg.getOrg(), pkg.getName(), pkg.getVersion());\n+\n+        // Information extracted from Ballerina.toml\n+        packageJson.setLicenses(pkg.getLicense());\n+        packageJson.setAuthors(pkg.getAuthors());\n+        packageJson.setSourceRepository(pkg.getRepository());\n+        packageJson.setKeywords(pkg.getKeywords());\n+        packageJson.setExported(pkg.getExported());\n+\n+        // Distribution details\n+        packageJson.setBallerinaVersion(RepoUtils.getBallerinaVersion());\n+        // TODO Need to set platform, implementation_vendor & spec\n+\n+        // Dependencies and platform libraries\n+        List<Dependency> dependencies = new ArrayList<>();\n+        List<PlatformLibrary> platformLibraries = new ArrayList<>();\n+\n+        // TODO Need to get all the dependencies (Not mentioned in the toml)\n+        Map<String, Object> tomlDependencies = ballerinaToml.getDependencies();\n+        for (String key : tomlDependencies.keySet()) {\n+            Object dependency = tomlDependencies.get(key);\n+            // if String, then Dependency\n+            if (dependency instanceof String) {\n+                String[] keyParts = key.split(\"/\");\n+                Dependency dep = new Dependency(keyParts[0], keyParts[1], (String) dependency);\n+                dependencies.add(dep);\n+            } else { // else, PlatformLibrary\n+                // TODO Need to set platform libraries\n+            }\n+        }\n+\n+        // Remove fields with empty values from `package.json`\n+        Gson gson = new GsonBuilder()\n+                .registerTypeHierarchyAdapter(Collection.class, new JsonCollectionsAdaptor())\n+                .registerTypeHierarchyAdapter(String.class, new JsonStringsAdaptor())\n+                .setPrettyPrinting()\n+                .create();\n+\n+        String baloJson = gson.toJson(packageJson);\n+        try {\n+            Files.write(root.resolve(\"package.json\"), baloJson.getBytes(Charset.defaultCharset()));\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"Failed to write 'package.json' file: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    private static void addPackageDoc(Path root, Path packageSourceDir, String pkgName) throws IOException {\n+        final String packageMdFileName = \"Package.md\";\n+        final String moduleMdFileName = \"Module.md\";\n+\n+        Path packageMd = packageSourceDir.resolve(packageMdFileName);\n+        Path docsDirInBalo = root.resolve(\"docs\");\n+\n+        // If `Package.md` exists, create the docs directory & add `Package.md`\n+        if (packageMd.toFile().exists()) {\n+            Files.createDirectory(docsDirInBalo);\n+            Path packageMdInBalo = docsDirInBalo.resolve(packageMdFileName);\n+            Files.copy(packageMd, packageMdInBalo);\n+        }\n+\n+        // If `Module.md` of default module exists, create `docs/modules` directory & add `Module.md`\n+        Path defaultModuleMd = packageSourceDir.resolve(moduleMdFileName);\n+        Path modulesDirInBaloDocs = docsDirInBalo.resolve(MODULES);\n+\n+        if (defaultModuleMd.toFile().exists()) {\n+            Files.createDirectory(modulesDirInBaloDocs);\n+\n+            Path defaultModuleDirInBaloDocs = modulesDirInBaloDocs.resolve(pkgName);\n+            Files.createDirectory(defaultModuleDirInBaloDocs);\n+            Path defaultModuleMdInBaloDocs = modulesDirInBaloDocs.resolve(pkgName).resolve(moduleMdFileName);\n+            Files.copy(defaultModuleMd, defaultModuleMdInBaloDocs);\n+        }\n+\n+        // Add other module docs\n+        File modulesSourceDir = new File(String.valueOf(packageSourceDir.resolve(MODULES)));\n+        File[] directoryListing = modulesSourceDir.listFiles();\n+\n+        if (directoryListing != null) {\n+            for (File moduleDir : directoryListing) {\n+                if (moduleDir.isDirectory()) {\n+                    // Get `Module.md` path\n+                    Path otherModuleMd = packageSourceDir.resolve(MODULES).resolve(moduleDir.getName())\n+                            .resolve(moduleMdFileName);\n+                    // Create `package.module` folder, if `Module.md` path exists\n+                    if (otherModuleMd.toFile().exists()) {\n+                        Path otherModuleDirInBaloDocs = modulesDirInBaloDocs\n+                                .resolve(pkgName + \".\" + moduleDir.getName());\n+                        Files.createDirectory(otherModuleDirInBaloDocs);\n+                        Path otherModuleMdInBaloDocs = modulesDirInBaloDocs\n+                                .resolve(pkgName + \".\" + moduleDir.getName()).resolve(moduleMdFileName);\n+                        Files.copy(otherModuleMd, otherModuleMdInBaloDocs);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void addPackageSource(Path root, Path packageSourceDir, String defaultPackageName)\n+            throws IOException {\n+        // create the module directory in zip\n+        Path packageInBalo = root.resolve(MODULES);\n+        Files.createDirectory(packageInBalo);\n+\n+        // add default module\n+        Path defaultPkgDirInBalo = packageInBalo.resolve(defaultPackageName);\n+        Files.createDirectory(defaultPkgDirInBalo);\n+\n+        // copy resources directory\n+        copyResourcesDir(packageSourceDir, defaultPkgDirInBalo);\n+        // only add .bal files in the package root\n+        copyBallerinaSrcFiles(packageSourceDir, defaultPkgDirInBalo);\n+\n+        // add other modules\n+        File modulesSourceDir = new File(String.valueOf(packageSourceDir.resolve(MODULES)));\n+        File[] directoryListing = modulesSourceDir.listFiles();\n+\n+        if (directoryListing != null) {\n+            for (File moduleDir : directoryListing) {\n+                if (moduleDir.isDirectory()) {\n+                    // add module\n+                    Path moduleDirInBalo = packageInBalo.resolve(defaultPackageName + \".\" + moduleDir.getName());\n+                    Files.createDirectory(moduleDirInBalo);\n+\n+                    // copy resources directory\n+                    copyResourcesDir(moduleDir.toPath(), moduleDirInBalo);\n+                    // only add .bal files in the module root\n+                    copyBallerinaSrcFiles(moduleDir.toPath(), moduleDirInBalo);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void copyResourcesDir(Path sourceDir, Path sourceDirInBalo) throws IOException {\n+        Path resourcesDir = sourceDirInBalo.resolve(\"resources\");", "originalCommit": "2efcb4da3eb6756bd07fb3b29b32a60b1d519f48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODQyNzcyOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25653#discussion_r488427729", "bodyText": "Added", "author": "pramodya1994", "createdAt": "2020-09-15T06:53:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE3MjExMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE3NDExOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25653#discussion_r488174119", "bodyText": "We can use ProjectConstants.BLANG_SOURCE_EXT instead of hardcoding the Ballerina file extension", "author": "azinneera", "createdAt": "2020-09-14T19:36:48Z", "path": "project-api/ballerina-projects/src/main/java/io/ballerina/projects/writers/BaloWriter.java", "diffHunk": "@@ -29,18 +59,347 @@\n  */\n public class BaloWriter {\n \n+    private static final String MODULES = \"modules\";\n+\n+    private BaloWriter() {}\n+\n     /**\n      * Write a package to a .balo and return the created .balo path.\n-     * @param pkg Package to be written as a .balo.\n+     *\n+     * @param pkg  Package to be written as a .balo.\n      * @param path Directory where the .balo should be created.\n      * @return Newly created balo path\n      */\n     public static Path write(Package pkg, Path path) {\n-        Path balo = path.resolve(\"org-name-any-version.balo\");\n         // todo check if the given package is compiled properly\n-        // todo check if the path is a directory\n+\n+        // Check if the path is a directory\n+        if (!path.toFile().isDirectory()) {\n+            throw new RuntimeException(\"Given path is not a directory: \" + path);\n+        }\n+\n         // Check directory permissions\n-        // Handle any io errors\n+//        if (!new File(String.valueOf(path)).canWrite()) {\n+//            throw new NoPermissionException(\"No write access to create balo:\" + path);\n+//        }\n+\n+        if (!path.toFile().canWrite()) {\n+            throw new NoPermissionException(\"No write access to create balo:\" + path);\n+        }\n+\n+        BallerinaToml ballerinaToml = pkg.ballerinaToml();\n+        Path packagePath = pkg.packagePath();\n+        Path balo = path.resolve(getBaloName(ballerinaToml));\n+\n+        // Create the archive over write if exists\n+        try (FileSystem baloFS = createBaloArchive(balo)) {\n+            // Now lets put stuff in\n+            populateBaloArchive(baloFS, packagePath, ballerinaToml);\n+        } catch (IOException e) {\n+            throw new BLangCompilerException(\"Failed to create balo :\" + e.getMessage(), e);\n+        } catch (BLangCompilerException be) {\n+            // clean up if an error occur\n+            try {\n+                Files.delete(balo);\n+            } catch (IOException e) {\n+                // We ignore this error and throw out the original blang compiler error to the user\n+            }\n+            throw be;\n+        }\n         return balo;\n     }\n+\n+    private static String getBaloName(BallerinaToml ballerinaToml) {\n+        // <orgname>-<packagename>-<platform>-<version>.balo\n+        String platform = ballerinaToml.getPlatform().target;\n+        if (platform == null || \"\".equals(platform)) {\n+            platform = \"any\";\n+        }\n+        return ballerinaToml.getPackage().getOrg() + \"-\" + ballerinaToml.getPackage().getName() + \"-\"\n+                + platform + \"-\" + ballerinaToml.getPackage().getVersion() + \".balo\";\n+    }\n+\n+    private static FileSystem createBaloArchive(Path path) throws IOException {\n+        // TODO check apache commons zip file writer\n+        // Remove if file already exists\n+        if (path.toFile().exists()) {\n+            Files.delete(path);\n+        }\n+        // Define ZIP File System Properties\n+        Map<String, String> env = new HashMap<>();\n+        env.put(\"create\", \"true\");\n+        env.put(\"encoding\", \"UTF-8\");\n+\n+        /* Locate File on disk for creation */\n+        URI zipDisk = URI.create(\"jar:\" + path.toUri());\n+        /* Create ZIP file System */\n+        return FileSystems.newFileSystem(zipDisk, env);\n+    }\n+\n+    private static void populateBaloArchive(FileSystem baloFS, Path packagePath, BallerinaToml ballerinaToml)\n+            throws IOException {\n+        Path root = baloFS.getPath(\"/\");\n+        String packageName = ballerinaToml.getPackage().getName();\n+\n+        //   Add spec directory structure items\n+        //\n+        //   org-foo-any-1.0.0.balo\n+        //    \u251c\u2500\u2500 balo.json             ---> Details about balo\n+        //    \u251c\u2500\u2500 package.json          ---> Details about package within balo\n+        //    \u251c\u2500\u2500 docs/\n+        //    \u2502\t   \u251c\u2500\u2500 Package.md       ---> MD file describing the package\n+        //    \u2502\t   \u251c\u2500\u2500 modules/\n+        //    \u2502\t   \u2502\t\u251c\u2500\u2500 foo/\n+        //    \u2502\t   \u2502\t\u2502\t \u2514\u2500\u2500 Module.md\n+        //    \u2502\t   \u2502    \u251c\u2500\u2500 foo.bar/\n+        //    \u2502\t   \u2502    \u2514\u2500\u2500 foo.baz/\n+        //    \u2502    \u2514\u2500\u2500 api-docs.json    ---> API Docs json file\n+        //    \u251c\u2500\u2500 modules/\n+        //    \u2502\t   \u251c\u2500\u2500 foo/             ---> content of default module\n+        //    \u2502    \u251c\u2500\u2500 foo.bar/         ---> content of sub module\n+        //    \u2502    \u2514\u2500\u2500 foo.baz/         ---> content of sub module\n+        //    \u2502\t\t    \u251c\u2500\u2500 resources/\n+        //    \u2502\t        \u251c\u2500\u2500 first.bal\n+        //    \u2502\t        \u251c\u2500\u2500 second.bal\n+        //    \u2502         \u2514\u2500\u2500 third.bal\n+        //    \u251c\u2500\u2500 lib/                  ---> Platform Libraries\n+        //    \u2502\t   \u251c\u2500\u2500\n+        //    \u2502\t   \u2514\u2500\u2500 third-party.jar\n+        //    \u2514\u2500\u2500 ext/\n+        //         \u251c\u2500\u2500 datamapper/\n+        //         \u2514\u2500\u2500 ext2/\n+\n+        addBaloJson(root);\n+        addPackageJson(root, ballerinaToml);\n+        addPackageDoc(root, packagePath, ballerinaToml.getPackage().getName());\n+        addPackageSource(root, packagePath, packageName);\n+        // Add platform libs only if it is not a template module\n+        if (!ballerinaToml.isTemplateModule(packageName)) {\n+            addPlatformLibs(root, packagePath, ballerinaToml);\n+        }\n+    }\n+\n+    private static void addBaloJson(Path root) {\n+        Gson gson = new GsonBuilder().setPrettyPrinting().create();\n+        String baloJson = gson.toJson(new BaloJson());\n+        try {\n+            Files.write(root.resolve(\"balo.json\"), baloJson.getBytes(Charset.defaultCharset()));\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"Failed to write 'balo.json' file: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    private static void addPackageJson(Path root, BallerinaToml ballerinaToml) {\n+        io.ballerina.projects.model.Package pkg = ballerinaToml.getPackage();\n+        PackageJson packageJson = new PackageJson(pkg.getOrg(), pkg.getName(), pkg.getVersion());\n+\n+        // Information extracted from Ballerina.toml\n+        packageJson.setLicenses(pkg.getLicense());\n+        packageJson.setAuthors(pkg.getAuthors());\n+        packageJson.setSourceRepository(pkg.getRepository());\n+        packageJson.setKeywords(pkg.getKeywords());\n+        packageJson.setExported(pkg.getExported());\n+\n+        // Distribution details\n+        packageJson.setBallerinaVersion(RepoUtils.getBallerinaVersion());\n+        // TODO Need to set platform, implementation_vendor & spec\n+\n+        // Dependencies and platform libraries\n+        List<Dependency> dependencies = new ArrayList<>();\n+        List<PlatformLibrary> platformLibraries = new ArrayList<>();\n+\n+        // TODO Need to get all the dependencies (Not mentioned in the toml)\n+        Map<String, Object> tomlDependencies = ballerinaToml.getDependencies();\n+        for (String key : tomlDependencies.keySet()) {\n+            Object dependency = tomlDependencies.get(key);\n+            // if String, then Dependency\n+            if (dependency instanceof String) {\n+                String[] keyParts = key.split(\"/\");\n+                Dependency dep = new Dependency(keyParts[0], keyParts[1], (String) dependency);\n+                dependencies.add(dep);\n+            } else { // else, PlatformLibrary\n+                // TODO Need to set platform libraries\n+            }\n+        }\n+\n+        // Remove fields with empty values from `package.json`\n+        Gson gson = new GsonBuilder()\n+                .registerTypeHierarchyAdapter(Collection.class, new JsonCollectionsAdaptor())\n+                .registerTypeHierarchyAdapter(String.class, new JsonStringsAdaptor())\n+                .setPrettyPrinting()\n+                .create();\n+\n+        String baloJson = gson.toJson(packageJson);\n+        try {\n+            Files.write(root.resolve(\"package.json\"), baloJson.getBytes(Charset.defaultCharset()));\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"Failed to write 'package.json' file: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    private static void addPackageDoc(Path root, Path packageSourceDir, String pkgName) throws IOException {\n+        final String packageMdFileName = \"Package.md\";\n+        final String moduleMdFileName = \"Module.md\";\n+\n+        Path packageMd = packageSourceDir.resolve(packageMdFileName);\n+        Path docsDirInBalo = root.resolve(\"docs\");\n+\n+        // If `Package.md` exists, create the docs directory & add `Package.md`\n+        if (packageMd.toFile().exists()) {\n+            Files.createDirectory(docsDirInBalo);\n+            Path packageMdInBalo = docsDirInBalo.resolve(packageMdFileName);\n+            Files.copy(packageMd, packageMdInBalo);\n+        }\n+\n+        // If `Module.md` of default module exists, create `docs/modules` directory & add `Module.md`\n+        Path defaultModuleMd = packageSourceDir.resolve(moduleMdFileName);\n+        Path modulesDirInBaloDocs = docsDirInBalo.resolve(MODULES);\n+\n+        if (defaultModuleMd.toFile().exists()) {\n+            Files.createDirectory(modulesDirInBaloDocs);\n+\n+            Path defaultModuleDirInBaloDocs = modulesDirInBaloDocs.resolve(pkgName);\n+            Files.createDirectory(defaultModuleDirInBaloDocs);\n+            Path defaultModuleMdInBaloDocs = modulesDirInBaloDocs.resolve(pkgName).resolve(moduleMdFileName);\n+            Files.copy(defaultModuleMd, defaultModuleMdInBaloDocs);\n+        }\n+\n+        // Add other module docs\n+        File modulesSourceDir = new File(String.valueOf(packageSourceDir.resolve(MODULES)));\n+        File[] directoryListing = modulesSourceDir.listFiles();\n+\n+        if (directoryListing != null) {\n+            for (File moduleDir : directoryListing) {\n+                if (moduleDir.isDirectory()) {\n+                    // Get `Module.md` path\n+                    Path otherModuleMd = packageSourceDir.resolve(MODULES).resolve(moduleDir.getName())\n+                            .resolve(moduleMdFileName);\n+                    // Create `package.module` folder, if `Module.md` path exists\n+                    if (otherModuleMd.toFile().exists()) {\n+                        Path otherModuleDirInBaloDocs = modulesDirInBaloDocs\n+                                .resolve(pkgName + \".\" + moduleDir.getName());\n+                        Files.createDirectory(otherModuleDirInBaloDocs);\n+                        Path otherModuleMdInBaloDocs = modulesDirInBaloDocs\n+                                .resolve(pkgName + \".\" + moduleDir.getName()).resolve(moduleMdFileName);\n+                        Files.copy(otherModuleMd, otherModuleMdInBaloDocs);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void addPackageSource(Path root, Path packageSourceDir, String defaultPackageName)\n+            throws IOException {\n+        // create the module directory in zip\n+        Path packageInBalo = root.resolve(MODULES);\n+        Files.createDirectory(packageInBalo);\n+\n+        // add default module\n+        Path defaultPkgDirInBalo = packageInBalo.resolve(defaultPackageName);\n+        Files.createDirectory(defaultPkgDirInBalo);\n+\n+        // copy resources directory\n+        copyResourcesDir(packageSourceDir, defaultPkgDirInBalo);\n+        // only add .bal files in the package root\n+        copyBallerinaSrcFiles(packageSourceDir, defaultPkgDirInBalo);\n+\n+        // add other modules\n+        File modulesSourceDir = new File(String.valueOf(packageSourceDir.resolve(MODULES)));\n+        File[] directoryListing = modulesSourceDir.listFiles();\n+\n+        if (directoryListing != null) {\n+            for (File moduleDir : directoryListing) {\n+                if (moduleDir.isDirectory()) {\n+                    // add module\n+                    Path moduleDirInBalo = packageInBalo.resolve(defaultPackageName + \".\" + moduleDir.getName());\n+                    Files.createDirectory(moduleDirInBalo);\n+\n+                    // copy resources directory\n+                    copyResourcesDir(moduleDir.toPath(), moduleDirInBalo);\n+                    // only add .bal files in the module root\n+                    copyBallerinaSrcFiles(moduleDir.toPath(), moduleDirInBalo);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void copyResourcesDir(Path sourceDir, Path sourceDirInBalo) throws IOException {\n+        Path resourcesDir = sourceDirInBalo.resolve(\"resources\");\n+        Path resourcesSrcDir = sourceDir.resolve(\"resources\");\n+\n+        // if resources not exists ignore copying\n+        if (resourcesSrcDir.toFile().exists()) {\n+            File[] resourceFiles = new File(String.valueOf(resourcesSrcDir)).listFiles();\n+            if (resourceFiles != null && resourceFiles.length > 0) {\n+                Files.walkFileTree(resourcesSrcDir, new CopyResources(resourcesSrcDir, resourcesDir));\n+            }\n+        }\n+    }\n+\n+    private static void copyBallerinaSrcFiles(Path sourceDirPath, Path targetPath) throws IOException {\n+        File[] defaultModuleFiles = new File(String.valueOf(sourceDirPath)).listFiles();\n+        if (defaultModuleFiles != null) {\n+            for (File file : defaultModuleFiles) {\n+                if (file.isFile() && file.getName().endsWith(\".bal\")) {", "originalCommit": "2efcb4da3eb6756bd07fb3b29b32a60b1d519f48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODQyNzc2Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25653#discussion_r488427763", "bodyText": "Added", "author": "pramodya1994", "createdAt": "2020-09-15T06:53:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE3NDExOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE3NDY1Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25653#discussion_r488174656", "bodyText": "Shall we move \"lib\" to ProjectConstants class?", "author": "azinneera", "createdAt": "2020-09-14T19:37:43Z", "path": "project-api/ballerina-projects/src/main/java/io/ballerina/projects/writers/BaloWriter.java", "diffHunk": "@@ -29,18 +59,347 @@\n  */\n public class BaloWriter {\n \n+    private static final String MODULES = \"modules\";\n+\n+    private BaloWriter() {}\n+\n     /**\n      * Write a package to a .balo and return the created .balo path.\n-     * @param pkg Package to be written as a .balo.\n+     *\n+     * @param pkg  Package to be written as a .balo.\n      * @param path Directory where the .balo should be created.\n      * @return Newly created balo path\n      */\n     public static Path write(Package pkg, Path path) {\n-        Path balo = path.resolve(\"org-name-any-version.balo\");\n         // todo check if the given package is compiled properly\n-        // todo check if the path is a directory\n+\n+        // Check if the path is a directory\n+        if (!path.toFile().isDirectory()) {\n+            throw new RuntimeException(\"Given path is not a directory: \" + path);\n+        }\n+\n         // Check directory permissions\n-        // Handle any io errors\n+//        if (!new File(String.valueOf(path)).canWrite()) {\n+//            throw new NoPermissionException(\"No write access to create balo:\" + path);\n+//        }\n+\n+        if (!path.toFile().canWrite()) {\n+            throw new NoPermissionException(\"No write access to create balo:\" + path);\n+        }\n+\n+        BallerinaToml ballerinaToml = pkg.ballerinaToml();\n+        Path packagePath = pkg.packagePath();\n+        Path balo = path.resolve(getBaloName(ballerinaToml));\n+\n+        // Create the archive over write if exists\n+        try (FileSystem baloFS = createBaloArchive(balo)) {\n+            // Now lets put stuff in\n+            populateBaloArchive(baloFS, packagePath, ballerinaToml);\n+        } catch (IOException e) {\n+            throw new BLangCompilerException(\"Failed to create balo :\" + e.getMessage(), e);\n+        } catch (BLangCompilerException be) {\n+            // clean up if an error occur\n+            try {\n+                Files.delete(balo);\n+            } catch (IOException e) {\n+                // We ignore this error and throw out the original blang compiler error to the user\n+            }\n+            throw be;\n+        }\n         return balo;\n     }\n+\n+    private static String getBaloName(BallerinaToml ballerinaToml) {\n+        // <orgname>-<packagename>-<platform>-<version>.balo\n+        String platform = ballerinaToml.getPlatform().target;\n+        if (platform == null || \"\".equals(platform)) {\n+            platform = \"any\";\n+        }\n+        return ballerinaToml.getPackage().getOrg() + \"-\" + ballerinaToml.getPackage().getName() + \"-\"\n+                + platform + \"-\" + ballerinaToml.getPackage().getVersion() + \".balo\";\n+    }\n+\n+    private static FileSystem createBaloArchive(Path path) throws IOException {\n+        // TODO check apache commons zip file writer\n+        // Remove if file already exists\n+        if (path.toFile().exists()) {\n+            Files.delete(path);\n+        }\n+        // Define ZIP File System Properties\n+        Map<String, String> env = new HashMap<>();\n+        env.put(\"create\", \"true\");\n+        env.put(\"encoding\", \"UTF-8\");\n+\n+        /* Locate File on disk for creation */\n+        URI zipDisk = URI.create(\"jar:\" + path.toUri());\n+        /* Create ZIP file System */\n+        return FileSystems.newFileSystem(zipDisk, env);\n+    }\n+\n+    private static void populateBaloArchive(FileSystem baloFS, Path packagePath, BallerinaToml ballerinaToml)\n+            throws IOException {\n+        Path root = baloFS.getPath(\"/\");\n+        String packageName = ballerinaToml.getPackage().getName();\n+\n+        //   Add spec directory structure items\n+        //\n+        //   org-foo-any-1.0.0.balo\n+        //    \u251c\u2500\u2500 balo.json             ---> Details about balo\n+        //    \u251c\u2500\u2500 package.json          ---> Details about package within balo\n+        //    \u251c\u2500\u2500 docs/\n+        //    \u2502\t   \u251c\u2500\u2500 Package.md       ---> MD file describing the package\n+        //    \u2502\t   \u251c\u2500\u2500 modules/\n+        //    \u2502\t   \u2502\t\u251c\u2500\u2500 foo/\n+        //    \u2502\t   \u2502\t\u2502\t \u2514\u2500\u2500 Module.md\n+        //    \u2502\t   \u2502    \u251c\u2500\u2500 foo.bar/\n+        //    \u2502\t   \u2502    \u2514\u2500\u2500 foo.baz/\n+        //    \u2502    \u2514\u2500\u2500 api-docs.json    ---> API Docs json file\n+        //    \u251c\u2500\u2500 modules/\n+        //    \u2502\t   \u251c\u2500\u2500 foo/             ---> content of default module\n+        //    \u2502    \u251c\u2500\u2500 foo.bar/         ---> content of sub module\n+        //    \u2502    \u2514\u2500\u2500 foo.baz/         ---> content of sub module\n+        //    \u2502\t\t    \u251c\u2500\u2500 resources/\n+        //    \u2502\t        \u251c\u2500\u2500 first.bal\n+        //    \u2502\t        \u251c\u2500\u2500 second.bal\n+        //    \u2502         \u2514\u2500\u2500 third.bal\n+        //    \u251c\u2500\u2500 lib/                  ---> Platform Libraries\n+        //    \u2502\t   \u251c\u2500\u2500\n+        //    \u2502\t   \u2514\u2500\u2500 third-party.jar\n+        //    \u2514\u2500\u2500 ext/\n+        //         \u251c\u2500\u2500 datamapper/\n+        //         \u2514\u2500\u2500 ext2/\n+\n+        addBaloJson(root);\n+        addPackageJson(root, ballerinaToml);\n+        addPackageDoc(root, packagePath, ballerinaToml.getPackage().getName());\n+        addPackageSource(root, packagePath, packageName);\n+        // Add platform libs only if it is not a template module\n+        if (!ballerinaToml.isTemplateModule(packageName)) {\n+            addPlatformLibs(root, packagePath, ballerinaToml);\n+        }\n+    }\n+\n+    private static void addBaloJson(Path root) {\n+        Gson gson = new GsonBuilder().setPrettyPrinting().create();\n+        String baloJson = gson.toJson(new BaloJson());\n+        try {\n+            Files.write(root.resolve(\"balo.json\"), baloJson.getBytes(Charset.defaultCharset()));\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"Failed to write 'balo.json' file: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    private static void addPackageJson(Path root, BallerinaToml ballerinaToml) {\n+        io.ballerina.projects.model.Package pkg = ballerinaToml.getPackage();\n+        PackageJson packageJson = new PackageJson(pkg.getOrg(), pkg.getName(), pkg.getVersion());\n+\n+        // Information extracted from Ballerina.toml\n+        packageJson.setLicenses(pkg.getLicense());\n+        packageJson.setAuthors(pkg.getAuthors());\n+        packageJson.setSourceRepository(pkg.getRepository());\n+        packageJson.setKeywords(pkg.getKeywords());\n+        packageJson.setExported(pkg.getExported());\n+\n+        // Distribution details\n+        packageJson.setBallerinaVersion(RepoUtils.getBallerinaVersion());\n+        // TODO Need to set platform, implementation_vendor & spec\n+\n+        // Dependencies and platform libraries\n+        List<Dependency> dependencies = new ArrayList<>();\n+        List<PlatformLibrary> platformLibraries = new ArrayList<>();\n+\n+        // TODO Need to get all the dependencies (Not mentioned in the toml)\n+        Map<String, Object> tomlDependencies = ballerinaToml.getDependencies();\n+        for (String key : tomlDependencies.keySet()) {\n+            Object dependency = tomlDependencies.get(key);\n+            // if String, then Dependency\n+            if (dependency instanceof String) {\n+                String[] keyParts = key.split(\"/\");\n+                Dependency dep = new Dependency(keyParts[0], keyParts[1], (String) dependency);\n+                dependencies.add(dep);\n+            } else { // else, PlatformLibrary\n+                // TODO Need to set platform libraries\n+            }\n+        }\n+\n+        // Remove fields with empty values from `package.json`\n+        Gson gson = new GsonBuilder()\n+                .registerTypeHierarchyAdapter(Collection.class, new JsonCollectionsAdaptor())\n+                .registerTypeHierarchyAdapter(String.class, new JsonStringsAdaptor())\n+                .setPrettyPrinting()\n+                .create();\n+\n+        String baloJson = gson.toJson(packageJson);\n+        try {\n+            Files.write(root.resolve(\"package.json\"), baloJson.getBytes(Charset.defaultCharset()));\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"Failed to write 'package.json' file: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    private static void addPackageDoc(Path root, Path packageSourceDir, String pkgName) throws IOException {\n+        final String packageMdFileName = \"Package.md\";\n+        final String moduleMdFileName = \"Module.md\";\n+\n+        Path packageMd = packageSourceDir.resolve(packageMdFileName);\n+        Path docsDirInBalo = root.resolve(\"docs\");\n+\n+        // If `Package.md` exists, create the docs directory & add `Package.md`\n+        if (packageMd.toFile().exists()) {\n+            Files.createDirectory(docsDirInBalo);\n+            Path packageMdInBalo = docsDirInBalo.resolve(packageMdFileName);\n+            Files.copy(packageMd, packageMdInBalo);\n+        }\n+\n+        // If `Module.md` of default module exists, create `docs/modules` directory & add `Module.md`\n+        Path defaultModuleMd = packageSourceDir.resolve(moduleMdFileName);\n+        Path modulesDirInBaloDocs = docsDirInBalo.resolve(MODULES);\n+\n+        if (defaultModuleMd.toFile().exists()) {\n+            Files.createDirectory(modulesDirInBaloDocs);\n+\n+            Path defaultModuleDirInBaloDocs = modulesDirInBaloDocs.resolve(pkgName);\n+            Files.createDirectory(defaultModuleDirInBaloDocs);\n+            Path defaultModuleMdInBaloDocs = modulesDirInBaloDocs.resolve(pkgName).resolve(moduleMdFileName);\n+            Files.copy(defaultModuleMd, defaultModuleMdInBaloDocs);\n+        }\n+\n+        // Add other module docs\n+        File modulesSourceDir = new File(String.valueOf(packageSourceDir.resolve(MODULES)));\n+        File[] directoryListing = modulesSourceDir.listFiles();\n+\n+        if (directoryListing != null) {\n+            for (File moduleDir : directoryListing) {\n+                if (moduleDir.isDirectory()) {\n+                    // Get `Module.md` path\n+                    Path otherModuleMd = packageSourceDir.resolve(MODULES).resolve(moduleDir.getName())\n+                            .resolve(moduleMdFileName);\n+                    // Create `package.module` folder, if `Module.md` path exists\n+                    if (otherModuleMd.toFile().exists()) {\n+                        Path otherModuleDirInBaloDocs = modulesDirInBaloDocs\n+                                .resolve(pkgName + \".\" + moduleDir.getName());\n+                        Files.createDirectory(otherModuleDirInBaloDocs);\n+                        Path otherModuleMdInBaloDocs = modulesDirInBaloDocs\n+                                .resolve(pkgName + \".\" + moduleDir.getName()).resolve(moduleMdFileName);\n+                        Files.copy(otherModuleMd, otherModuleMdInBaloDocs);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void addPackageSource(Path root, Path packageSourceDir, String defaultPackageName)\n+            throws IOException {\n+        // create the module directory in zip\n+        Path packageInBalo = root.resolve(MODULES);\n+        Files.createDirectory(packageInBalo);\n+\n+        // add default module\n+        Path defaultPkgDirInBalo = packageInBalo.resolve(defaultPackageName);\n+        Files.createDirectory(defaultPkgDirInBalo);\n+\n+        // copy resources directory\n+        copyResourcesDir(packageSourceDir, defaultPkgDirInBalo);\n+        // only add .bal files in the package root\n+        copyBallerinaSrcFiles(packageSourceDir, defaultPkgDirInBalo);\n+\n+        // add other modules\n+        File modulesSourceDir = new File(String.valueOf(packageSourceDir.resolve(MODULES)));\n+        File[] directoryListing = modulesSourceDir.listFiles();\n+\n+        if (directoryListing != null) {\n+            for (File moduleDir : directoryListing) {\n+                if (moduleDir.isDirectory()) {\n+                    // add module\n+                    Path moduleDirInBalo = packageInBalo.resolve(defaultPackageName + \".\" + moduleDir.getName());\n+                    Files.createDirectory(moduleDirInBalo);\n+\n+                    // copy resources directory\n+                    copyResourcesDir(moduleDir.toPath(), moduleDirInBalo);\n+                    // only add .bal files in the module root\n+                    copyBallerinaSrcFiles(moduleDir.toPath(), moduleDirInBalo);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void copyResourcesDir(Path sourceDir, Path sourceDirInBalo) throws IOException {\n+        Path resourcesDir = sourceDirInBalo.resolve(\"resources\");\n+        Path resourcesSrcDir = sourceDir.resolve(\"resources\");\n+\n+        // if resources not exists ignore copying\n+        if (resourcesSrcDir.toFile().exists()) {\n+            File[] resourceFiles = new File(String.valueOf(resourcesSrcDir)).listFiles();\n+            if (resourceFiles != null && resourceFiles.length > 0) {\n+                Files.walkFileTree(resourcesSrcDir, new CopyResources(resourcesSrcDir, resourcesDir));\n+            }\n+        }\n+    }\n+\n+    private static void copyBallerinaSrcFiles(Path sourceDirPath, Path targetPath) throws IOException {\n+        File[] defaultModuleFiles = new File(String.valueOf(sourceDirPath)).listFiles();\n+        if (defaultModuleFiles != null) {\n+            for (File file : defaultModuleFiles) {\n+                if (file.isFile() && file.getName().endsWith(\".bal\")) {\n+                    Files.copy(file.toPath(), targetPath.resolve(file.getName()), StandardCopyOption.REPLACE_EXISTING);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void addPlatformLibs(Path root, Path projectDirectory, BallerinaToml ballerinaToml)\n+            throws IOException {\n+        //If platform libs are defined add them to balo\n+        List<Library> platformLibs = ballerinaToml.getPlatform().libraries;\n+        if (platformLibs == null) {\n+            return;\n+        }\n+        Path platformLibsDir = root.resolve(\"lib\");", "originalCommit": "2efcb4da3eb6756bd07fb3b29b32a60b1d519f48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODQyODYwNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25653#discussion_r488428604", "bodyText": "Added LIB_DIR to ProjectConstants", "author": "pramodya1994", "createdAt": "2020-09-15T06:54:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE3NDY1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE3ODE1Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25653#discussion_r488178156", "bodyText": "Files.copy can throw an I/O exception for reasons other than for a file not found. Therefore, it would be better if we make it more generic and append the exception e to the message.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                throw new BLangCompilerException(\"Dependency jar not found : \" + lib.toString());\n          \n          \n            \n                                throw new BLangCompilerException(\"Error while trying to add platform library to the BALO: \" + lib.toString(), e);", "author": "azinneera", "createdAt": "2020-09-14T19:44:56Z", "path": "project-api/ballerina-projects/src/main/java/io/ballerina/projects/writers/BaloWriter.java", "diffHunk": "@@ -29,18 +59,347 @@\n  */\n public class BaloWriter {\n \n+    private static final String MODULES = \"modules\";\n+\n+    private BaloWriter() {}\n+\n     /**\n      * Write a package to a .balo and return the created .balo path.\n-     * @param pkg Package to be written as a .balo.\n+     *\n+     * @param pkg  Package to be written as a .balo.\n      * @param path Directory where the .balo should be created.\n      * @return Newly created balo path\n      */\n     public static Path write(Package pkg, Path path) {\n-        Path balo = path.resolve(\"org-name-any-version.balo\");\n         // todo check if the given package is compiled properly\n-        // todo check if the path is a directory\n+\n+        // Check if the path is a directory\n+        if (!path.toFile().isDirectory()) {\n+            throw new RuntimeException(\"Given path is not a directory: \" + path);\n+        }\n+\n         // Check directory permissions\n-        // Handle any io errors\n+//        if (!new File(String.valueOf(path)).canWrite()) {\n+//            throw new NoPermissionException(\"No write access to create balo:\" + path);\n+//        }\n+\n+        if (!path.toFile().canWrite()) {\n+            throw new NoPermissionException(\"No write access to create balo:\" + path);\n+        }\n+\n+        BallerinaToml ballerinaToml = pkg.ballerinaToml();\n+        Path packagePath = pkg.packagePath();\n+        Path balo = path.resolve(getBaloName(ballerinaToml));\n+\n+        // Create the archive over write if exists\n+        try (FileSystem baloFS = createBaloArchive(balo)) {\n+            // Now lets put stuff in\n+            populateBaloArchive(baloFS, packagePath, ballerinaToml);\n+        } catch (IOException e) {\n+            throw new BLangCompilerException(\"Failed to create balo :\" + e.getMessage(), e);\n+        } catch (BLangCompilerException be) {\n+            // clean up if an error occur\n+            try {\n+                Files.delete(balo);\n+            } catch (IOException e) {\n+                // We ignore this error and throw out the original blang compiler error to the user\n+            }\n+            throw be;\n+        }\n         return balo;\n     }\n+\n+    private static String getBaloName(BallerinaToml ballerinaToml) {\n+        // <orgname>-<packagename>-<platform>-<version>.balo\n+        String platform = ballerinaToml.getPlatform().target;\n+        if (platform == null || \"\".equals(platform)) {\n+            platform = \"any\";\n+        }\n+        return ballerinaToml.getPackage().getOrg() + \"-\" + ballerinaToml.getPackage().getName() + \"-\"\n+                + platform + \"-\" + ballerinaToml.getPackage().getVersion() + \".balo\";\n+    }\n+\n+    private static FileSystem createBaloArchive(Path path) throws IOException {\n+        // TODO check apache commons zip file writer\n+        // Remove if file already exists\n+        if (path.toFile().exists()) {\n+            Files.delete(path);\n+        }\n+        // Define ZIP File System Properties\n+        Map<String, String> env = new HashMap<>();\n+        env.put(\"create\", \"true\");\n+        env.put(\"encoding\", \"UTF-8\");\n+\n+        /* Locate File on disk for creation */\n+        URI zipDisk = URI.create(\"jar:\" + path.toUri());\n+        /* Create ZIP file System */\n+        return FileSystems.newFileSystem(zipDisk, env);\n+    }\n+\n+    private static void populateBaloArchive(FileSystem baloFS, Path packagePath, BallerinaToml ballerinaToml)\n+            throws IOException {\n+        Path root = baloFS.getPath(\"/\");\n+        String packageName = ballerinaToml.getPackage().getName();\n+\n+        //   Add spec directory structure items\n+        //\n+        //   org-foo-any-1.0.0.balo\n+        //    \u251c\u2500\u2500 balo.json             ---> Details about balo\n+        //    \u251c\u2500\u2500 package.json          ---> Details about package within balo\n+        //    \u251c\u2500\u2500 docs/\n+        //    \u2502\t   \u251c\u2500\u2500 Package.md       ---> MD file describing the package\n+        //    \u2502\t   \u251c\u2500\u2500 modules/\n+        //    \u2502\t   \u2502\t\u251c\u2500\u2500 foo/\n+        //    \u2502\t   \u2502\t\u2502\t \u2514\u2500\u2500 Module.md\n+        //    \u2502\t   \u2502    \u251c\u2500\u2500 foo.bar/\n+        //    \u2502\t   \u2502    \u2514\u2500\u2500 foo.baz/\n+        //    \u2502    \u2514\u2500\u2500 api-docs.json    ---> API Docs json file\n+        //    \u251c\u2500\u2500 modules/\n+        //    \u2502\t   \u251c\u2500\u2500 foo/             ---> content of default module\n+        //    \u2502    \u251c\u2500\u2500 foo.bar/         ---> content of sub module\n+        //    \u2502    \u2514\u2500\u2500 foo.baz/         ---> content of sub module\n+        //    \u2502\t\t    \u251c\u2500\u2500 resources/\n+        //    \u2502\t        \u251c\u2500\u2500 first.bal\n+        //    \u2502\t        \u251c\u2500\u2500 second.bal\n+        //    \u2502         \u2514\u2500\u2500 third.bal\n+        //    \u251c\u2500\u2500 lib/                  ---> Platform Libraries\n+        //    \u2502\t   \u251c\u2500\u2500\n+        //    \u2502\t   \u2514\u2500\u2500 third-party.jar\n+        //    \u2514\u2500\u2500 ext/\n+        //         \u251c\u2500\u2500 datamapper/\n+        //         \u2514\u2500\u2500 ext2/\n+\n+        addBaloJson(root);\n+        addPackageJson(root, ballerinaToml);\n+        addPackageDoc(root, packagePath, ballerinaToml.getPackage().getName());\n+        addPackageSource(root, packagePath, packageName);\n+        // Add platform libs only if it is not a template module\n+        if (!ballerinaToml.isTemplateModule(packageName)) {\n+            addPlatformLibs(root, packagePath, ballerinaToml);\n+        }\n+    }\n+\n+    private static void addBaloJson(Path root) {\n+        Gson gson = new GsonBuilder().setPrettyPrinting().create();\n+        String baloJson = gson.toJson(new BaloJson());\n+        try {\n+            Files.write(root.resolve(\"balo.json\"), baloJson.getBytes(Charset.defaultCharset()));\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"Failed to write 'balo.json' file: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    private static void addPackageJson(Path root, BallerinaToml ballerinaToml) {\n+        io.ballerina.projects.model.Package pkg = ballerinaToml.getPackage();\n+        PackageJson packageJson = new PackageJson(pkg.getOrg(), pkg.getName(), pkg.getVersion());\n+\n+        // Information extracted from Ballerina.toml\n+        packageJson.setLicenses(pkg.getLicense());\n+        packageJson.setAuthors(pkg.getAuthors());\n+        packageJson.setSourceRepository(pkg.getRepository());\n+        packageJson.setKeywords(pkg.getKeywords());\n+        packageJson.setExported(pkg.getExported());\n+\n+        // Distribution details\n+        packageJson.setBallerinaVersion(RepoUtils.getBallerinaVersion());\n+        // TODO Need to set platform, implementation_vendor & spec\n+\n+        // Dependencies and platform libraries\n+        List<Dependency> dependencies = new ArrayList<>();\n+        List<PlatformLibrary> platformLibraries = new ArrayList<>();\n+\n+        // TODO Need to get all the dependencies (Not mentioned in the toml)\n+        Map<String, Object> tomlDependencies = ballerinaToml.getDependencies();\n+        for (String key : tomlDependencies.keySet()) {\n+            Object dependency = tomlDependencies.get(key);\n+            // if String, then Dependency\n+            if (dependency instanceof String) {\n+                String[] keyParts = key.split(\"/\");\n+                Dependency dep = new Dependency(keyParts[0], keyParts[1], (String) dependency);\n+                dependencies.add(dep);\n+            } else { // else, PlatformLibrary\n+                // TODO Need to set platform libraries\n+            }\n+        }\n+\n+        // Remove fields with empty values from `package.json`\n+        Gson gson = new GsonBuilder()\n+                .registerTypeHierarchyAdapter(Collection.class, new JsonCollectionsAdaptor())\n+                .registerTypeHierarchyAdapter(String.class, new JsonStringsAdaptor())\n+                .setPrettyPrinting()\n+                .create();\n+\n+        String baloJson = gson.toJson(packageJson);\n+        try {\n+            Files.write(root.resolve(\"package.json\"), baloJson.getBytes(Charset.defaultCharset()));\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"Failed to write 'package.json' file: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    private static void addPackageDoc(Path root, Path packageSourceDir, String pkgName) throws IOException {\n+        final String packageMdFileName = \"Package.md\";\n+        final String moduleMdFileName = \"Module.md\";\n+\n+        Path packageMd = packageSourceDir.resolve(packageMdFileName);\n+        Path docsDirInBalo = root.resolve(\"docs\");\n+\n+        // If `Package.md` exists, create the docs directory & add `Package.md`\n+        if (packageMd.toFile().exists()) {\n+            Files.createDirectory(docsDirInBalo);\n+            Path packageMdInBalo = docsDirInBalo.resolve(packageMdFileName);\n+            Files.copy(packageMd, packageMdInBalo);\n+        }\n+\n+        // If `Module.md` of default module exists, create `docs/modules` directory & add `Module.md`\n+        Path defaultModuleMd = packageSourceDir.resolve(moduleMdFileName);\n+        Path modulesDirInBaloDocs = docsDirInBalo.resolve(MODULES);\n+\n+        if (defaultModuleMd.toFile().exists()) {\n+            Files.createDirectory(modulesDirInBaloDocs);\n+\n+            Path defaultModuleDirInBaloDocs = modulesDirInBaloDocs.resolve(pkgName);\n+            Files.createDirectory(defaultModuleDirInBaloDocs);\n+            Path defaultModuleMdInBaloDocs = modulesDirInBaloDocs.resolve(pkgName).resolve(moduleMdFileName);\n+            Files.copy(defaultModuleMd, defaultModuleMdInBaloDocs);\n+        }\n+\n+        // Add other module docs\n+        File modulesSourceDir = new File(String.valueOf(packageSourceDir.resolve(MODULES)));\n+        File[] directoryListing = modulesSourceDir.listFiles();\n+\n+        if (directoryListing != null) {\n+            for (File moduleDir : directoryListing) {\n+                if (moduleDir.isDirectory()) {\n+                    // Get `Module.md` path\n+                    Path otherModuleMd = packageSourceDir.resolve(MODULES).resolve(moduleDir.getName())\n+                            .resolve(moduleMdFileName);\n+                    // Create `package.module` folder, if `Module.md` path exists\n+                    if (otherModuleMd.toFile().exists()) {\n+                        Path otherModuleDirInBaloDocs = modulesDirInBaloDocs\n+                                .resolve(pkgName + \".\" + moduleDir.getName());\n+                        Files.createDirectory(otherModuleDirInBaloDocs);\n+                        Path otherModuleMdInBaloDocs = modulesDirInBaloDocs\n+                                .resolve(pkgName + \".\" + moduleDir.getName()).resolve(moduleMdFileName);\n+                        Files.copy(otherModuleMd, otherModuleMdInBaloDocs);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void addPackageSource(Path root, Path packageSourceDir, String defaultPackageName)\n+            throws IOException {\n+        // create the module directory in zip\n+        Path packageInBalo = root.resolve(MODULES);\n+        Files.createDirectory(packageInBalo);\n+\n+        // add default module\n+        Path defaultPkgDirInBalo = packageInBalo.resolve(defaultPackageName);\n+        Files.createDirectory(defaultPkgDirInBalo);\n+\n+        // copy resources directory\n+        copyResourcesDir(packageSourceDir, defaultPkgDirInBalo);\n+        // only add .bal files in the package root\n+        copyBallerinaSrcFiles(packageSourceDir, defaultPkgDirInBalo);\n+\n+        // add other modules\n+        File modulesSourceDir = new File(String.valueOf(packageSourceDir.resolve(MODULES)));\n+        File[] directoryListing = modulesSourceDir.listFiles();\n+\n+        if (directoryListing != null) {\n+            for (File moduleDir : directoryListing) {\n+                if (moduleDir.isDirectory()) {\n+                    // add module\n+                    Path moduleDirInBalo = packageInBalo.resolve(defaultPackageName + \".\" + moduleDir.getName());\n+                    Files.createDirectory(moduleDirInBalo);\n+\n+                    // copy resources directory\n+                    copyResourcesDir(moduleDir.toPath(), moduleDirInBalo);\n+                    // only add .bal files in the module root\n+                    copyBallerinaSrcFiles(moduleDir.toPath(), moduleDirInBalo);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void copyResourcesDir(Path sourceDir, Path sourceDirInBalo) throws IOException {\n+        Path resourcesDir = sourceDirInBalo.resolve(\"resources\");\n+        Path resourcesSrcDir = sourceDir.resolve(\"resources\");\n+\n+        // if resources not exists ignore copying\n+        if (resourcesSrcDir.toFile().exists()) {\n+            File[] resourceFiles = new File(String.valueOf(resourcesSrcDir)).listFiles();\n+            if (resourceFiles != null && resourceFiles.length > 0) {\n+                Files.walkFileTree(resourcesSrcDir, new CopyResources(resourcesSrcDir, resourcesDir));\n+            }\n+        }\n+    }\n+\n+    private static void copyBallerinaSrcFiles(Path sourceDirPath, Path targetPath) throws IOException {\n+        File[] defaultModuleFiles = new File(String.valueOf(sourceDirPath)).listFiles();\n+        if (defaultModuleFiles != null) {\n+            for (File file : defaultModuleFiles) {\n+                if (file.isFile() && file.getName().endsWith(\".bal\")) {\n+                    Files.copy(file.toPath(), targetPath.resolve(file.getName()), StandardCopyOption.REPLACE_EXISTING);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void addPlatformLibs(Path root, Path projectDirectory, BallerinaToml ballerinaToml)\n+            throws IOException {\n+        //If platform libs are defined add them to balo\n+        List<Library> platformLibs = ballerinaToml.getPlatform().libraries;\n+        if (platformLibs == null) {\n+            return;\n+        }\n+        Path platformLibsDir = root.resolve(\"lib\");\n+        Files.createDirectory(platformLibsDir);\n+\n+        for (Library lib : platformLibs) {\n+            if (lib.getModules() == null && lib.getScope() == null) {\n+                Path libPath = Paths.get(lib.getPath());\n+                Path nativeFile = projectDirectory.resolve(libPath);\n+                Path libFileName = libPath.getFileName();\n+                if (libFileName == null) {\n+                    continue;\n+                }\n+                Path targetPath = platformLibsDir.resolve(libFileName.toString());\n+                try {\n+                    Files.copy(nativeFile, targetPath, StandardCopyOption.REPLACE_EXISTING);\n+                } catch (IOException e) {\n+                    throw new BLangCompilerException(\"Dependency jar not found : \" + lib.toString());", "originalCommit": "2efcb4da3eb6756bd07fb3b29b32a60b1d519f48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODUwMjIzOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25653#discussion_r488502239", "bodyText": "Added", "author": "pramodya1994", "createdAt": "2020-09-15T08:57:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE3ODE1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE3OTc1MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25653#discussion_r488179751", "bodyText": "We can use IOExceptions instead of this custom exception.", "author": "azinneera", "createdAt": "2020-09-14T19:47:18Z", "path": "project-api/ballerina-projects/src/main/java/io/ballerina/projects/writers/exceptions/NoPermissionException.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package io.ballerina.projects.writers.exceptions;\n+\n+/**\n+ * {@code NoPermissionException} throws when permission denied for certain action.\n+ *\n+ * @since 2.0.0\n+ */\n+public class NoPermissionException extends RuntimeException {", "originalCommit": "2efcb4da3eb6756bd07fb3b29b32a60b1d519f48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODUwMjQzMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25653#discussion_r488502431", "bodyText": "Removed this custom exception", "author": "pramodya1994", "createdAt": "2020-09-15T08:58:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE3OTc1MQ=="}], "type": "inlineReview"}, {"oid": "fc7617e378290cbdcc5128927e7e6c816b5a0d11", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fc7617e378290cbdcc5128927e7e6c816b5a0d11", "message": "Merge branch 'project_api' of https://github.com/ballerina-platform/ballerina-lang into balo-write-project_api", "committedDate": "2020-09-15T06:52:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODU0NzA2MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25653#discussion_r488547060", "bodyText": "We should use io.ballerina.projects.utils.ProjectUtils. Shall we copy the required utilities to this class from RepoUtils?", "author": "azinneera", "createdAt": "2020-09-15T10:07:37Z", "path": "project-api/ballerina-projects/src/main/java/io/ballerina/projects/writers/BaloWriter.java", "diffHunk": "@@ -18,9 +18,39 @@\n \n package io.ballerina.projects.writers;\n \n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n import io.ballerina.projects.Package;\n+import io.ballerina.projects.model.BallerinaToml;\n+import io.ballerina.projects.model.BaloJson;\n+import io.ballerina.projects.model.Dependency;\n+import io.ballerina.projects.model.PackageJson;\n+import io.ballerina.projects.model.PlatformLibrary;\n+import io.ballerina.projects.model.adaptors.JsonCollectionsAdaptor;\n+import io.ballerina.projects.model.adaptors.JsonStringsAdaptor;\n+import io.ballerina.projects.writers.exceptions.NoPermissionException;\n+import org.ballerinalang.compiler.BLangCompilerException;\n+import org.ballerinalang.toml.model.Library;\n+import org.wso2.ballerinalang.util.RepoUtils;", "originalCommit": "2efcb4da3eb6756bd07fb3b29b32a60b1d519f48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODU1MTg0Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25653#discussion_r488551843", "bodyText": "Added to this class.", "author": "pramodya1994", "createdAt": "2020-09-15T10:16:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODU0NzA2MA=="}], "type": "inlineReview"}, {"oid": "13af031af8b0b028b751bcc0fad53445140c6e90", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/13af031af8b0b028b751bcc0fad53445140c6e90", "message": "Address PR comments", "committedDate": "2020-09-15T10:15:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODU1MzczMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25653#discussion_r488553733", "bodyText": "Since this method already throws an IOException, cant we get rid of this try-catch block?", "author": "azinneera", "createdAt": "2020-09-15T10:19:19Z", "path": "project-api/ballerina-projects/src/main/java/io/ballerina/projects/writers/BaloWriter.java", "diffHunk": "@@ -29,18 +62,356 @@\n  */\n public class BaloWriter {\n \n+    private BaloWriter() {}\n+\n     /**\n      * Write a package to a .balo and return the created .balo path.\n-     * @param pkg Package to be written as a .balo.\n+     *\n+     * @param pkg  Package to be written as a .balo.\n      * @param path Directory where the .balo should be created.\n      * @return Newly created balo path\n      */\n-    public static Path write(Package pkg, Path path) {\n-        Path balo = path.resolve(\"org-name-any-version.balo\");\n+    public static Path write(Package pkg, Path path) throws AccessDeniedException {\n         // todo check if the given package is compiled properly\n-        // todo check if the path is a directory\n-        // Check directory permissions\n-        // Handle any io errors\n+\n+        // Check if the path is a directory\n+        if (!path.toFile().isDirectory()) {\n+            throw new RuntimeException(\"Given path is not a directory: \" + path);\n+        }\n+\n+        if (!path.toFile().canWrite()) {\n+            throw new AccessDeniedException(\"No write access to create balo:\" + path);\n+        }\n+\n+        BallerinaToml ballerinaToml = pkg.ballerinaToml();\n+        Path packagePath = pkg.packagePath();\n+        Path balo = path.resolve(getBaloName(ballerinaToml));\n+\n+        // Create the archive over write if exists\n+        try (FileSystem baloFS = createBaloArchive(balo)) {\n+            // Now lets put stuff in\n+            populateBaloArchive(baloFS, packagePath, ballerinaToml);\n+        } catch (IOException e) {\n+            throw new BLangCompilerException(\"Failed to create balo :\" + e.getMessage(), e);\n+        } catch (BLangCompilerException be) {\n+            // clean up if an error occur\n+            try {\n+                Files.delete(balo);\n+            } catch (IOException e) {\n+                // We ignore this error and throw out the original blang compiler error to the user\n+            }\n+            throw be;\n+        }\n         return balo;\n     }\n+\n+    private static String getBaloName(BallerinaToml ballerinaToml) {\n+        // <orgname>-<packagename>-<platform>-<version>.balo\n+        String platform = ballerinaToml.getPlatform().target;\n+        if (platform == null || \"\".equals(platform)) {\n+            platform = \"any\";\n+        }\n+        return ballerinaToml.getPackage().getOrg() + \"-\" + ballerinaToml.getPackage().getName() + \"-\"\n+                + platform + \"-\" + ballerinaToml.getPackage().getVersion() + \".balo\";\n+    }\n+\n+    private static FileSystem createBaloArchive(Path path) throws IOException {\n+        // TODO check apache commons zip file writer\n+        // Remove if file already exists\n+        if (path.toFile().exists()) {\n+            Files.delete(path);\n+        }\n+        // Define ZIP File System Properties\n+        Map<String, String> env = new HashMap<>();\n+        env.put(\"create\", \"true\");\n+        env.put(\"encoding\", \"UTF-8\");\n+\n+        /* Locate File on disk for creation */\n+        URI zipDisk = URI.create(\"jar:\" + path.toUri());\n+        /* Create ZIP file System */\n+        return FileSystems.newFileSystem(zipDisk, env);\n+    }\n+\n+    private static void populateBaloArchive(FileSystem baloFS, Path packagePath, BallerinaToml ballerinaToml)\n+            throws IOException {\n+        Path root = baloFS.getPath(\"/\");\n+        String packageName = ballerinaToml.getPackage().getName();\n+\n+        //   Add spec directory structure items\n+        //\n+        //   org-foo-any-1.0.0.balo\n+        //    \u251c\u2500\u2500 balo.json             ---> Details about balo\n+        //    \u251c\u2500\u2500 package.json          ---> Details about package within balo\n+        //    \u251c\u2500\u2500 docs/\n+        //    \u2502\t   \u251c\u2500\u2500 Package.md       ---> MD file describing the package\n+        //    \u2502\t   \u251c\u2500\u2500 modules/\n+        //    \u2502\t   \u2502\t\u251c\u2500\u2500 foo/\n+        //    \u2502\t   \u2502\t\u2502\t \u2514\u2500\u2500 Module.md\n+        //    \u2502\t   \u2502    \u251c\u2500\u2500 foo.bar/\n+        //    \u2502\t   \u2502    \u2514\u2500\u2500 foo.baz/\n+        //    \u2502    \u2514\u2500\u2500 api-docs.json    ---> API Docs json file\n+        //    \u251c\u2500\u2500 modules/\n+        //    \u2502\t   \u251c\u2500\u2500 foo/             ---> content of default module\n+        //    \u2502    \u251c\u2500\u2500 foo.bar/         ---> content of sub module\n+        //    \u2502    \u2514\u2500\u2500 foo.baz/         ---> content of sub module\n+        //    \u2502\t\t    \u251c\u2500\u2500 resources/\n+        //    \u2502\t        \u251c\u2500\u2500 first.bal\n+        //    \u2502\t        \u251c\u2500\u2500 second.bal\n+        //    \u2502         \u2514\u2500\u2500 third.bal\n+        //    \u251c\u2500\u2500 lib/                  ---> Platform Libraries\n+        //    \u2502\t   \u251c\u2500\u2500\n+        //    \u2502\t   \u2514\u2500\u2500 third-party.jar\n+        //    \u2514\u2500\u2500 ext/\n+        //         \u251c\u2500\u2500 datamapper/\n+        //         \u2514\u2500\u2500 ext2/\n+\n+        addBaloJson(root);\n+        addPackageJson(root, ballerinaToml);\n+        addPackageDoc(root, packagePath, ballerinaToml.getPackage().getName());\n+        addPackageSource(root, packagePath, packageName);\n+        // Add platform libs only if it is not a template module\n+        if (!ballerinaToml.isTemplateModule(packageName)) {\n+            addPlatformLibs(root, packagePath, ballerinaToml);\n+        }\n+    }\n+\n+    private static void addBaloJson(Path root) {\n+        Gson gson = new GsonBuilder().setPrettyPrinting().create();\n+        String baloJson = gson.toJson(new BaloJson());\n+        try {\n+            Files.write(root.resolve(\"balo.json\"), baloJson.getBytes(Charset.defaultCharset()));\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"Failed to write 'balo.json' file: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    private static void addPackageJson(Path root, BallerinaToml ballerinaToml) {\n+        io.ballerina.projects.model.Package pkg = ballerinaToml.getPackage();\n+        PackageJson packageJson = new PackageJson(pkg.getOrg(), pkg.getName(), pkg.getVersion());\n+\n+        // Information extracted from Ballerina.toml\n+        packageJson.setLicenses(pkg.getLicense());\n+        packageJson.setAuthors(pkg.getAuthors());\n+        packageJson.setSourceRepository(pkg.getRepository());\n+        packageJson.setKeywords(pkg.getKeywords());\n+        packageJson.setExported(pkg.getExported());\n+\n+        // Distribution details\n+        packageJson.setBallerinaVersion(getBallerinaVersion());\n+        // TODO Need to set platform, implementation_vendor & spec\n+\n+        // Dependencies and platform libraries\n+        List<Dependency> dependencies = new ArrayList<>();\n+        List<PlatformLibrary> platformLibraries = new ArrayList<>();\n+\n+        // TODO Need to get all the dependencies (Not mentioned in the toml)\n+        Map<String, Object> tomlDependencies = ballerinaToml.getDependencies();\n+        for (String key : tomlDependencies.keySet()) {\n+            Object dependency = tomlDependencies.get(key);\n+            // if String, then Dependency\n+            if (dependency instanceof String) {\n+                String[] keyParts = key.split(\"/\");\n+                Dependency dep = new Dependency(keyParts[0], keyParts[1], (String) dependency);\n+                dependencies.add(dep);\n+            } else { // else, PlatformLibrary\n+                // TODO Need to set platform libraries\n+            }\n+        }\n+\n+        // Remove fields with empty values from `package.json`\n+        Gson gson = new GsonBuilder()\n+                .registerTypeHierarchyAdapter(Collection.class, new JsonCollectionsAdaptor())\n+                .registerTypeHierarchyAdapter(String.class, new JsonStringsAdaptor())\n+                .setPrettyPrinting()\n+                .create();\n+\n+        String baloJson = gson.toJson(packageJson);\n+        try {\n+            Files.write(root.resolve(\"package.json\"), baloJson.getBytes(Charset.defaultCharset()));\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"Failed to write 'package.json' file: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    private static void addPackageDoc(Path root, Path packageSourceDir, String pkgName) throws IOException {\n+        final String packageMdFileName = \"Package.md\";\n+        final String moduleMdFileName = \"Module.md\";\n+\n+        Path packageMd = packageSourceDir.resolve(packageMdFileName);\n+        Path docsDirInBalo = root.resolve(\"docs\");\n+\n+        // If `Package.md` exists, create the docs directory & add `Package.md`\n+        if (packageMd.toFile().exists()) {\n+            Files.createDirectory(docsDirInBalo);\n+            Path packageMdInBalo = docsDirInBalo.resolve(packageMdFileName);\n+            Files.copy(packageMd, packageMdInBalo);\n+        }\n+\n+        // If `Module.md` of default module exists, create `docs/modules` directory & add `Module.md`\n+        Path defaultModuleMd = packageSourceDir.resolve(moduleMdFileName);\n+        Path modulesDirInBaloDocs = docsDirInBalo.resolve(ProjectConstants.MODULES_ROOT);\n+\n+        if (defaultModuleMd.toFile().exists()) {\n+            Files.createDirectory(modulesDirInBaloDocs);\n+\n+            Path defaultModuleDirInBaloDocs = modulesDirInBaloDocs.resolve(pkgName);\n+            Files.createDirectory(defaultModuleDirInBaloDocs);\n+            Path defaultModuleMdInBaloDocs = modulesDirInBaloDocs.resolve(pkgName).resolve(moduleMdFileName);\n+            Files.copy(defaultModuleMd, defaultModuleMdInBaloDocs);\n+        }\n+\n+        // Add other module docs\n+        File modulesSourceDir = new File(String.valueOf(packageSourceDir.resolve(ProjectConstants.MODULES_ROOT)));\n+        File[] directoryListing = modulesSourceDir.listFiles();\n+\n+        if (directoryListing != null) {\n+            for (File moduleDir : directoryListing) {\n+                if (moduleDir.isDirectory()) {\n+                    // Get `Module.md` path\n+                    Path otherModuleMd = packageSourceDir.resolve(ProjectConstants.MODULES_ROOT)\n+                            .resolve(moduleDir.getName()).resolve(moduleMdFileName);\n+                    // Create `package.module` folder, if `Module.md` path exists\n+                    if (otherModuleMd.toFile().exists()) {\n+                        Path otherModuleDirInBaloDocs = modulesDirInBaloDocs\n+                                .resolve(pkgName + \".\" + moduleDir.getName());\n+                        Files.createDirectory(otherModuleDirInBaloDocs);\n+                        Path otherModuleMdInBaloDocs = modulesDirInBaloDocs\n+                                .resolve(pkgName + \".\" + moduleDir.getName()).resolve(moduleMdFileName);\n+                        Files.copy(otherModuleMd, otherModuleMdInBaloDocs);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void addPackageSource(Path root, Path packageSourceDir, String defaultPackageName)\n+            throws IOException {\n+        // create the module directory in zip\n+        Path packageInBalo = root.resolve(ProjectConstants.MODULES_ROOT);\n+        Files.createDirectory(packageInBalo);\n+\n+        // add default module\n+        Path defaultPkgDirInBalo = packageInBalo.resolve(defaultPackageName);\n+        Files.createDirectory(defaultPkgDirInBalo);\n+\n+        // copy resources directory\n+        copyResourcesDir(packageSourceDir, defaultPkgDirInBalo);\n+        // only add .bal files in the package root\n+        copyBallerinaSrcFiles(packageSourceDir, defaultPkgDirInBalo);\n+\n+        // add other modules\n+        File modulesSourceDir = new File(String.valueOf(packageSourceDir.resolve(ProjectConstants.MODULES_ROOT)));\n+        File[] directoryListing = modulesSourceDir.listFiles();\n+\n+        if (directoryListing != null) {\n+            for (File moduleDir : directoryListing) {\n+                if (moduleDir.isDirectory()) {\n+                    // add module\n+                    Path moduleDirInBalo = packageInBalo.resolve(defaultPackageName + \".\" + moduleDir.getName());\n+                    Files.createDirectory(moduleDirInBalo);\n+\n+                    // copy resources directory\n+                    copyResourcesDir(moduleDir.toPath(), moduleDirInBalo);\n+                    // only add .bal files in the module root\n+                    copyBallerinaSrcFiles(moduleDir.toPath(), moduleDirInBalo);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void copyResourcesDir(Path sourceDir, Path sourceDirInBalo) throws IOException {\n+        Path resourcesDir = sourceDirInBalo.resolve(ProjectConstants.RESOURCE_DIR_NAME);\n+        Path resourcesSrcDir = sourceDir.resolve(ProjectConstants.RESOURCE_DIR_NAME);\n+\n+        // if resources not exists ignore copying\n+        if (resourcesSrcDir.toFile().exists()) {\n+            File[] resourceFiles = new File(String.valueOf(resourcesSrcDir)).listFiles();\n+            if (resourceFiles != null && resourceFiles.length > 0) {\n+                Files.walkFileTree(resourcesSrcDir, new CopyResources(resourcesSrcDir, resourcesDir));\n+            }\n+        }\n+    }\n+\n+    private static void copyBallerinaSrcFiles(Path sourceDirPath, Path targetPath) throws IOException {\n+        File[] defaultModuleFiles = new File(String.valueOf(sourceDirPath)).listFiles();\n+        if (defaultModuleFiles != null) {\n+            for (File file : defaultModuleFiles) {\n+                if (file.isFile() && file.getName().endsWith(ProjectConstants.BLANG_SOURCE_EXT)) {\n+                    Files.copy(file.toPath(), targetPath.resolve(file.getName()), StandardCopyOption.REPLACE_EXISTING);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void addPlatformLibs(Path root, Path projectDirectory, BallerinaToml ballerinaToml)\n+            throws IOException {\n+        //If platform libs are defined add them to balo\n+        List<Library> platformLibs = ballerinaToml.getPlatform().libraries;\n+        if (platformLibs == null) {\n+            return;\n+        }\n+        Path platformLibsDir = root.resolve(ProjectConstants.LIB_DIR);\n+        Files.createDirectory(platformLibsDir);\n+\n+        for (Library lib : platformLibs) {\n+            if (lib.getModules() == null && lib.getScope() == null) {\n+                Path libPath = Paths.get(lib.getPath());\n+                Path nativeFile = projectDirectory.resolve(libPath);\n+                Path libFileName = libPath.getFileName();\n+                if (libFileName == null) {\n+                    continue;\n+                }\n+                Path targetPath = platformLibsDir.resolve(libFileName.toString());\n+                try {\n+                    Files.copy(nativeFile, targetPath, StandardCopyOption.REPLACE_EXISTING);", "originalCommit": "13af031af8b0b028b751bcc0fad53445140c6e90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODU1ODQ3Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25653#discussion_r488558472", "bodyText": "Let's keep this till we implement an exception model", "author": "azinneera", "createdAt": "2020-09-15T10:27:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODU1MzczMw=="}], "type": "inlineReview"}, {"oid": "58760016779a962e39b0a7f5f70c20548a57a8f5", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/58760016779a962e39b0a7f5f70c20548a57a8f5", "message": "Address PR comments", "committedDate": "2020-09-15T10:50:55Z", "type": "forcePushed"}, {"oid": "0a174b9d1ead8b8144e2fc06bc3f077a4b47a582", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0a174b9d1ead8b8144e2fc06bc3f077a4b47a582", "message": "Address PR comments", "committedDate": "2020-09-15T11:12:13Z", "type": "commit"}, {"oid": "0a174b9d1ead8b8144e2fc06bc3f077a4b47a582", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0a174b9d1ead8b8144e2fc06bc3f077a4b47a582", "message": "Address PR comments", "committedDate": "2020-09-15T11:12:13Z", "type": "forcePushed"}]}