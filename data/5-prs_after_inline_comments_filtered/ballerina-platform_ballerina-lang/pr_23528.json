{"pr_number": 23528, "pr_title": "Add implementation of Dependency Resolver API", "pr_createdAt": "2020-05-27T04:19:31Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/23528", "timeline": [{"oid": "ec60809e81e1148ec98e7d6c48db3f76873c5b88", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ec60809e81e1148ec98e7d6c48db3f76873c5b88", "message": "Implement dependency resolver API", "committedDate": "2020-05-25T14:02:23Z", "type": "commit"}, {"oid": "c48a257bcdfb97e3e8797e8241f5282b1d4a2b3b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c48a257bcdfb97e3e8797e8241f5282b1d4a2b3b", "message": "Merge pull request #23480 from suganyasuven/jar-resolver\n\nImplement dependency resolver API", "committedDate": "2020-05-26T08:39:52Z", "type": "commit"}, {"oid": "e16c4aac217a328afc232ce526b334e51eb1f3d1", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e16c4aac217a328afc232ce526b334e51eb1f3d1", "message": "Refactor the implementation of dependency resolver API", "committedDate": "2020-05-26T12:06:08Z", "type": "commit"}, {"oid": "5b7813fe98e73b1c3744db627f134197c1379039", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5b7813fe98e73b1c3744db627f134197c1379039", "message": "Merge pull request #23512 from suganyasuven/jar-resolver\n\nRefactor the implementation of dependency resolver API", "committedDate": "2020-05-26T13:11:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk3NzI4Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23528#discussion_r430977287", "bodyText": "The license header is missing.", "author": "IrushiL", "createdAt": "2020-05-27T09:19:53Z", "path": "cli/ballerina-packerina/src/main/java/org/ballerinalang/packerina/NativeDependencyResolverImpl.java", "diffHunk": "@@ -0,0 +1,312 @@\n+package org.ballerinalang.packerina;", "originalCommit": "5b7813fe98e73b1c3744db627f134197c1379039", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk3Nzg0Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23528#discussion_r430977842", "bodyText": "Please include license header", "author": "keizer619", "createdAt": "2020-05-27T09:20:46Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/NativeDependencyResolver.java", "diffHunk": "@@ -0,0 +1,21 @@\n+package org.wso2.ballerinalang.compiler;", "originalCommit": "5b7813fe98e73b1c3744db627f134197c1379039", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk3ODg5NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23528#discussion_r430978894", "bodyText": "License header.", "author": "IrushiL", "createdAt": "2020-05-27T09:22:32Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/NativeDependencyResolver.java", "diffHunk": "@@ -0,0 +1,21 @@\n+package org.wso2.ballerinalang.compiler;", "originalCommit": "5b7813fe98e73b1c3744db627f134197c1379039", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk3OTYxMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23528#discussion_r430979613", "bodyText": "Extra line.", "author": "IrushiL", "createdAt": "2020-05-27T09:23:38Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/NativeDependencyResolver.java", "diffHunk": "@@ -0,0 +1,21 @@\n+package org.wso2.ballerinalang.compiler;\n+\n+import org.ballerinalang.model.elements.PackageID;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+/**\n+ * Contains methods to resolve the module jars and native libraries.\n+ *\n+ * @since 1.3.0\n+ */\n+public interface NativeDependencyResolver {\n+\n+    Path moduleJar(PackageID packageID, String platform);\n+\n+    List<Path> nativeDependencies(PackageID packageID);\n+\n+    List<Path> nativeDependenciesForTests(PackageID packageID);\n+", "originalCommit": "5b7813fe98e73b1c3744db627f134197c1379039", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4MDQyMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23528#discussion_r430980420", "bodyText": "Since 1.3.0 is an old release I was wondering if this is correct. Same for the NativeDependencyResolverImpl class.", "author": "IrushiL", "createdAt": "2020-05-27T09:24:57Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/NativeDependencyResolver.java", "diffHunk": "@@ -0,0 +1,21 @@\n+package org.wso2.ballerinalang.compiler;\n+\n+import org.ballerinalang.model.elements.PackageID;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+/**\n+ * Contains methods to resolve the module jars and native libraries.\n+ *\n+ * @since 1.3.0", "originalCommit": "5b7813fe98e73b1c3744db627f134197c1379039", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4NDUzMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23528#discussion_r430984531", "bodyText": "Yeah true. As per the current release road map there will be no 1.3.0 release. The next major release will be 2.0.0.", "author": "NipunaRanasinghe", "createdAt": "2020-05-27T09:31:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4MDQyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4MDcwOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23528#discussion_r430980709", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    supportedPlatforms.add(\"any\");\n          \n          \n            \n                    supportedPlatforms.add(ProgramFileConstants.ANY_PLATFORM);\n          \n      \n    \n    \n  \n\nCan we use this content without adding a String here?", "author": "pramodya1994", "createdAt": "2020-05-27T09:25:25Z", "path": "cli/ballerina-packerina/src/main/java/org/ballerinalang/packerina/NativeDependencyResolverImpl.java", "diffHunk": "@@ -0,0 +1,312 @@\n+package org.ballerinalang.packerina;\n+\n+import com.moandjiezana.toml.Toml;\n+import org.ballerinalang.model.elements.PackageID;\n+import org.ballerinalang.packerina.buildcontext.BuildContext;\n+import org.ballerinalang.packerina.buildcontext.BuildContextField;\n+import org.ballerinalang.toml.model.Dependency;\n+import org.ballerinalang.toml.model.Library;\n+import org.ballerinalang.toml.model.Manifest;\n+import org.ballerinalang.toml.parser.ManifestProcessor;\n+import org.wso2.ballerinalang.compiler.NativeDependencyResolver;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.ProjectDirs;\n+import org.wso2.ballerinalang.programfile.ProgramFileConstants;\n+import org.wso2.ballerinalang.util.RepoUtils;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+import java.util.stream.Collectors;\n+\n+import static org.ballerinalang.tool.LauncherUtils.createLauncherException;\n+import static org.wso2.ballerinalang.compiler.util.ProjectDirConstants.BALO_PLATFORM_LIB_DIR_NAME;\n+import static org.wso2.ballerinalang.compiler.util.ProjectDirConstants.BLANG_COMPILED_JAR_EXT;\n+import static org.wso2.ballerinalang.compiler.util.ProjectDirConstants.BLANG_PKG_DEFAULT_VERSION;\n+import static org.wso2.ballerinalang.compiler.util.ProjectDirConstants.DIST_BIR_CACHE_DIR_NAME;\n+\n+/**\n+ * Resolves jars and native libs for modules.\n+ *\n+ * @since 1.3.0\n+ */\n+public class NativeDependencyResolverImpl implements NativeDependencyResolver {\n+    private static final CompilerContext.Key<NativeDependencyResolver> JAR_RESOLVER_KEY = new CompilerContext.Key<>();\n+    private List<String> supportedPlatforms = Arrays.stream(ProgramFileConstants.SUPPORTED_PLATFORMS)\n+            .collect(Collectors.toList());\n+    private final BuildContext buildContext;\n+    private final Path sourceRootPath;\n+    private final String balHomePath;\n+    private final Manifest manifest;\n+    private boolean skipCopyLibsFromDist;\n+\n+    public static NativeDependencyResolver getInstance(BuildContext buildContext, boolean skipCopyLibsFromDist) {\n+        CompilerContext context = buildContext.get(BuildContextField.COMPILER_CONTEXT);\n+        NativeDependencyResolver nativeDependencyResolver = context.get(JAR_RESOLVER_KEY);\n+        if (nativeDependencyResolver == null) {\n+            nativeDependencyResolver = new NativeDependencyResolverImpl(buildContext, skipCopyLibsFromDist);\n+        }\n+        context.put(JAR_RESOLVER_KEY, nativeDependencyResolver);\n+        return nativeDependencyResolver;\n+    }\n+\n+    private NativeDependencyResolverImpl(BuildContext buildContext, boolean skipCopyLibsFromDist) {\n+        CompilerContext context = buildContext.get(BuildContextField.COMPILER_CONTEXT);\n+        this.buildContext = buildContext;\n+        this.manifest = ManifestProcessor.getInstance(context).getManifest();\n+        this.sourceRootPath = buildContext.get(BuildContextField.SOURCE_ROOT);\n+        this.skipCopyLibsFromDist = skipCopyLibsFromDist;\n+        this.balHomePath = buildContext.get(BuildContextField.HOME_REPO).toString();\n+        supportedPlatforms.add(\"any\");", "originalCommit": "5b7813fe98e73b1c3744db627f134197c1379039", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4NTcxNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23528#discussion_r430985714", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (baloPath != null && Files.exists(baloPath)) {\n          \n          \n            \n                        if (baloPath != null && baloPath.toFile().exists()) {\n          \n      \n    \n    \n  \n\nAccording to SonarLint Java 8's Files.exists() method has noticibly poor performance in JDK8, So Shall we use toFile().exists()?", "author": "pramodya1994", "createdAt": "2020-05-27T09:33:31Z", "path": "cli/ballerina-packerina/src/main/java/org/ballerinalang/packerina/NativeDependencyResolverImpl.java", "diffHunk": "@@ -0,0 +1,312 @@\n+package org.ballerinalang.packerina;\n+\n+import com.moandjiezana.toml.Toml;\n+import org.ballerinalang.model.elements.PackageID;\n+import org.ballerinalang.packerina.buildcontext.BuildContext;\n+import org.ballerinalang.packerina.buildcontext.BuildContextField;\n+import org.ballerinalang.toml.model.Dependency;\n+import org.ballerinalang.toml.model.Library;\n+import org.ballerinalang.toml.model.Manifest;\n+import org.ballerinalang.toml.parser.ManifestProcessor;\n+import org.wso2.ballerinalang.compiler.NativeDependencyResolver;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.ProjectDirs;\n+import org.wso2.ballerinalang.programfile.ProgramFileConstants;\n+import org.wso2.ballerinalang.util.RepoUtils;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+import java.util.stream.Collectors;\n+\n+import static org.ballerinalang.tool.LauncherUtils.createLauncherException;\n+import static org.wso2.ballerinalang.compiler.util.ProjectDirConstants.BALO_PLATFORM_LIB_DIR_NAME;\n+import static org.wso2.ballerinalang.compiler.util.ProjectDirConstants.BLANG_COMPILED_JAR_EXT;\n+import static org.wso2.ballerinalang.compiler.util.ProjectDirConstants.BLANG_PKG_DEFAULT_VERSION;\n+import static org.wso2.ballerinalang.compiler.util.ProjectDirConstants.DIST_BIR_CACHE_DIR_NAME;\n+\n+/**\n+ * Resolves jars and native libs for modules.\n+ *\n+ * @since 1.3.0\n+ */\n+public class NativeDependencyResolverImpl implements NativeDependencyResolver {\n+    private static final CompilerContext.Key<NativeDependencyResolver> JAR_RESOLVER_KEY = new CompilerContext.Key<>();\n+    private List<String> supportedPlatforms = Arrays.stream(ProgramFileConstants.SUPPORTED_PLATFORMS)\n+            .collect(Collectors.toList());\n+    private final BuildContext buildContext;\n+    private final Path sourceRootPath;\n+    private final String balHomePath;\n+    private final Manifest manifest;\n+    private boolean skipCopyLibsFromDist;\n+\n+    public static NativeDependencyResolver getInstance(BuildContext buildContext, boolean skipCopyLibsFromDist) {\n+        CompilerContext context = buildContext.get(BuildContextField.COMPILER_CONTEXT);\n+        NativeDependencyResolver nativeDependencyResolver = context.get(JAR_RESOLVER_KEY);\n+        if (nativeDependencyResolver == null) {\n+            nativeDependencyResolver = new NativeDependencyResolverImpl(buildContext, skipCopyLibsFromDist);\n+        }\n+        context.put(JAR_RESOLVER_KEY, nativeDependencyResolver);\n+        return nativeDependencyResolver;\n+    }\n+\n+    private NativeDependencyResolverImpl(BuildContext buildContext, boolean skipCopyLibsFromDist) {\n+        CompilerContext context = buildContext.get(BuildContextField.COMPILER_CONTEXT);\n+        this.buildContext = buildContext;\n+        this.manifest = ManifestProcessor.getInstance(context).getManifest();\n+        this.sourceRootPath = buildContext.get(BuildContextField.SOURCE_ROOT);\n+        this.skipCopyLibsFromDist = skipCopyLibsFromDist;\n+        this.balHomePath = buildContext.get(BuildContextField.HOME_REPO).toString();\n+        supportedPlatforms.add(\"any\");\n+    }\n+\n+    @Override\n+    public Path moduleJar(PackageID packageID, String platform) {\n+        // Look if it is a project module.\n+        if (isProjectModule(packageID)) {\n+            // If so fetch from project balo cache\n+            return buildContext.getBaloFromTarget(packageID);\n+        } else if (isPathDependency(packageID)) {\n+            // If so fetch from project jar cache\n+            return buildContext.getJarPathFromTargetCache(packageID);\n+        } else if (isModuleInDistribution(packageID)) {\n+            return getJarFromDistribution(packageID);\n+        } else {\n+            // If not fetch from home balo cache.\n+            return buildContext.getBaloFromHomeCache(packageID, platform);\n+        }\n+    }\n+\n+    @Override\n+    public List<Path> nativeDependencies(PackageID packageID) {\n+        List<Path> modulePlatformLibs = new ArrayList<>();\n+        // copy platform libs for all modules(imported modules as well)\n+        addPlatformLibs(packageID, modulePlatformLibs);\n+\n+        if (isProjectModule(packageID)) {\n+            return modulePlatformLibs;\n+        } else if (isPathDependency(packageID)) {\n+            addLibsFromBaloDependency(packageID, modulePlatformLibs);\n+        } else if (isModuleInDistribution(packageID)) {\n+            addLibsFromDistribution(packageID, modulePlatformLibs);\n+        } else {\n+            addLibsFromHomeBaloCache(packageID, modulePlatformLibs);\n+        }\n+        return modulePlatformLibs;\n+    }\n+\n+    @Override\n+    public List<Path> nativeDependenciesForTests(PackageID packageID) {\n+        List<Path> testPlatformLibs = new ArrayList<>();\n+        List<Library> libraries = manifest.getPlatform().libraries;\n+        if (libraries != null) {\n+            for (Library library : libraries) {\n+                if ((library.getModules() == null ||\n+                        Arrays.asList(library.getModules()).contains(packageID.name.value)) &&\n+                        (library.getScope() != null && library.getScope().equalsIgnoreCase(\"testOnly\"))) {\n+                    String libFilePath = library.getPath();\n+                    if (libFilePath == null) {\n+                        continue;\n+                    }\n+                    Path nativeFile = sourceRootPath.resolve(Paths.get(libFilePath));\n+                    testPlatformLibs.add(nativeFile);\n+                }\n+            }\n+        }\n+        return testPlatformLibs;\n+    }\n+\n+    private boolean isModuleInDistribution(PackageID packageID) {\n+        return getTomlFilePath(packageID).exists();\n+    }\n+\n+    private File getTomlFilePath(PackageID packageID) {\n+        String version = BLANG_PKG_DEFAULT_VERSION;\n+        if (!packageID.version.value.equals(\"\")) {\n+            version = packageID.version.value;\n+        }\n+\n+        return Paths.get(balHomePath, DIST_BIR_CACHE_DIR_NAME, packageID.orgName.value,\n+                packageID.name.value, version, \"Ballerina.toml\").toFile();\n+    }\n+\n+    private boolean isPathDependency(PackageID packageID) {\n+        return buildContext.getImportPathDependency(packageID).isPresent();\n+    }\n+\n+    private boolean isProjectModule(PackageID packageID) {\n+        return manifest.getProject().getOrgName().equals(packageID.orgName.value) &&\n+                ProjectDirs.isModuleExist(sourceRootPath, packageID.name.value);\n+    }\n+\n+    private void addLibsFromHomeBaloCache(PackageID packageID, List<Path> modulePlatformLibs) {\n+        for (String platform : supportedPlatforms) {\n+            Path baloPath = buildContext.getBaloFromHomeCache(packageID, platform);\n+            if (baloPath != null && Files.exists(baloPath)) {", "originalCommit": "5b7813fe98e73b1c3744db627f134197c1379039", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4NjE4Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23528#discussion_r430986186", "bodyText": "Shall we remove this extra line?", "author": "keizer619", "createdAt": "2020-05-27T09:34:21Z", "path": "cli/ballerina-packerina/src/main/java/org/ballerinalang/packerina/NativeDependencyResolverImpl.java", "diffHunk": "@@ -0,0 +1,312 @@\n+package org.ballerinalang.packerina;\n+\n+import com.moandjiezana.toml.Toml;\n+import org.ballerinalang.model.elements.PackageID;\n+import org.ballerinalang.packerina.buildcontext.BuildContext;\n+import org.ballerinalang.packerina.buildcontext.BuildContextField;\n+import org.ballerinalang.toml.model.Dependency;\n+import org.ballerinalang.toml.model.Library;\n+import org.ballerinalang.toml.model.Manifest;\n+import org.ballerinalang.toml.parser.ManifestProcessor;\n+import org.wso2.ballerinalang.compiler.NativeDependencyResolver;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.ProjectDirs;\n+import org.wso2.ballerinalang.programfile.ProgramFileConstants;\n+import org.wso2.ballerinalang.util.RepoUtils;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+import java.util.stream.Collectors;\n+\n+import static org.ballerinalang.tool.LauncherUtils.createLauncherException;\n+import static org.wso2.ballerinalang.compiler.util.ProjectDirConstants.BALO_PLATFORM_LIB_DIR_NAME;\n+import static org.wso2.ballerinalang.compiler.util.ProjectDirConstants.BLANG_COMPILED_JAR_EXT;\n+import static org.wso2.ballerinalang.compiler.util.ProjectDirConstants.BLANG_PKG_DEFAULT_VERSION;\n+import static org.wso2.ballerinalang.compiler.util.ProjectDirConstants.DIST_BIR_CACHE_DIR_NAME;\n+\n+/**\n+ * Resolves jars and native libs for modules.\n+ *\n+ * @since 1.3.0\n+ */\n+public class NativeDependencyResolverImpl implements NativeDependencyResolver {\n+    private static final CompilerContext.Key<NativeDependencyResolver> JAR_RESOLVER_KEY = new CompilerContext.Key<>();\n+    private List<String> supportedPlatforms = Arrays.stream(ProgramFileConstants.SUPPORTED_PLATFORMS)\n+            .collect(Collectors.toList());\n+    private final BuildContext buildContext;\n+    private final Path sourceRootPath;\n+    private final String balHomePath;\n+    private final Manifest manifest;\n+    private boolean skipCopyLibsFromDist;\n+\n+    public static NativeDependencyResolver getInstance(BuildContext buildContext, boolean skipCopyLibsFromDist) {\n+        CompilerContext context = buildContext.get(BuildContextField.COMPILER_CONTEXT);\n+        NativeDependencyResolver nativeDependencyResolver = context.get(JAR_RESOLVER_KEY);\n+        if (nativeDependencyResolver == null) {\n+            nativeDependencyResolver = new NativeDependencyResolverImpl(buildContext, skipCopyLibsFromDist);\n+        }\n+        context.put(JAR_RESOLVER_KEY, nativeDependencyResolver);\n+        return nativeDependencyResolver;\n+    }\n+\n+    private NativeDependencyResolverImpl(BuildContext buildContext, boolean skipCopyLibsFromDist) {\n+        CompilerContext context = buildContext.get(BuildContextField.COMPILER_CONTEXT);\n+        this.buildContext = buildContext;\n+        this.manifest = ManifestProcessor.getInstance(context).getManifest();\n+        this.sourceRootPath = buildContext.get(BuildContextField.SOURCE_ROOT);\n+        this.skipCopyLibsFromDist = skipCopyLibsFromDist;\n+        this.balHomePath = buildContext.get(BuildContextField.HOME_REPO).toString();\n+        supportedPlatforms.add(\"any\");\n+    }\n+\n+    @Override\n+    public Path moduleJar(PackageID packageID, String platform) {\n+        // Look if it is a project module.\n+        if (isProjectModule(packageID)) {\n+            // If so fetch from project balo cache\n+            return buildContext.getBaloFromTarget(packageID);\n+        } else if (isPathDependency(packageID)) {\n+            // If so fetch from project jar cache\n+            return buildContext.getJarPathFromTargetCache(packageID);\n+        } else if (isModuleInDistribution(packageID)) {\n+            return getJarFromDistribution(packageID);\n+        } else {\n+            // If not fetch from home balo cache.\n+            return buildContext.getBaloFromHomeCache(packageID, platform);\n+        }\n+    }\n+\n+    @Override\n+    public List<Path> nativeDependencies(PackageID packageID) {\n+        List<Path> modulePlatformLibs = new ArrayList<>();\n+        // copy platform libs for all modules(imported modules as well)\n+        addPlatformLibs(packageID, modulePlatformLibs);\n+\n+        if (isProjectModule(packageID)) {\n+            return modulePlatformLibs;\n+        } else if (isPathDependency(packageID)) {\n+            addLibsFromBaloDependency(packageID, modulePlatformLibs);\n+        } else if (isModuleInDistribution(packageID)) {\n+            addLibsFromDistribution(packageID, modulePlatformLibs);\n+        } else {\n+            addLibsFromHomeBaloCache(packageID, modulePlatformLibs);\n+        }\n+        return modulePlatformLibs;\n+    }\n+\n+    @Override\n+    public List<Path> nativeDependenciesForTests(PackageID packageID) {\n+        List<Path> testPlatformLibs = new ArrayList<>();\n+        List<Library> libraries = manifest.getPlatform().libraries;\n+        if (libraries != null) {\n+            for (Library library : libraries) {\n+                if ((library.getModules() == null ||\n+                        Arrays.asList(library.getModules()).contains(packageID.name.value)) &&\n+                        (library.getScope() != null && library.getScope().equalsIgnoreCase(\"testOnly\"))) {\n+                    String libFilePath = library.getPath();\n+                    if (libFilePath == null) {\n+                        continue;\n+                    }\n+                    Path nativeFile = sourceRootPath.resolve(Paths.get(libFilePath));\n+                    testPlatformLibs.add(nativeFile);\n+                }\n+            }\n+        }\n+        return testPlatformLibs;\n+    }\n+\n+    private boolean isModuleInDistribution(PackageID packageID) {\n+        return getTomlFilePath(packageID).exists();\n+    }\n+\n+    private File getTomlFilePath(PackageID packageID) {\n+        String version = BLANG_PKG_DEFAULT_VERSION;\n+        if (!packageID.version.value.equals(\"\")) {\n+            version = packageID.version.value;\n+        }\n+\n+        return Paths.get(balHomePath, DIST_BIR_CACHE_DIR_NAME, packageID.orgName.value,\n+                packageID.name.value, version, \"Ballerina.toml\").toFile();\n+    }\n+\n+    private boolean isPathDependency(PackageID packageID) {\n+        return buildContext.getImportPathDependency(packageID).isPresent();\n+    }\n+\n+    private boolean isProjectModule(PackageID packageID) {\n+        return manifest.getProject().getOrgName().equals(packageID.orgName.value) &&\n+                ProjectDirs.isModuleExist(sourceRootPath, packageID.name.value);\n+    }\n+\n+    private void addLibsFromHomeBaloCache(PackageID packageID, List<Path> modulePlatformLibs) {\n+        for (String platform : supportedPlatforms) {\n+            Path baloPath = buildContext.getBaloFromHomeCache(packageID, platform);\n+            if (baloPath != null && Files.exists(baloPath)) {\n+                addLibsFromBalo(baloPath, modulePlatformLibs);\n+            }\n+        }\n+    }\n+\n+    private void addLibsFromBaloDependency(PackageID packageID, List<Path> modulePlatformLibs) {\n+        addLibsFromBalo(buildContext.getImportPathDependency(packageID).get().getMetadata().getPath(),\n+                modulePlatformLibs);\n+    }\n+\n+    private void addLibsFromDistribution(PackageID packageID, List<Path> modulePlatformLibs) {\n+        List<Path> dependencies = getDependenciesFromDist(packageID);\n+        if (dependencies != null) {\n+            modulePlatformLibs.addAll(dependencies);\n+        }\n+    }\n+\n+    private void addPlatformLibs(PackageID packageID, List<Path> modulePlatformLibs) {\n+        List<Path> platformLibs = new ArrayList<>();\n+        List<Library> libraries = manifest.getPlatform().libraries;\n+\n+        Optional<Dependency> importPathDependency = buildContext.getImportPathDependency(packageID);\n+        if (libraries != null) {\n+            for (Library library : libraries) {\n+                if ((library.getModules() == null ||\n+                        Arrays.asList(library.getModules()).contains(packageID.name.value) ||\n+                        Arrays.asList(library.getModules()).contains(packageID.orgName.value + \"/\" +\n+                                packageID.name.value)) &&\n+                        !(library.getScope() != null && library.getScope().equalsIgnoreCase(\"testOnly\"))) {\n+                    String libFilePath = library.getPath();\n+                    if (libFilePath == null) {\n+                        continue;\n+                    }\n+\n+                    Path nativeFile = sourceRootPath.resolve(Paths.get(libFilePath));\n+                    if (importPathDependency.isPresent()) {\n+                        platformLibs.add(nativeFile.getFileName());\n+                    }\n+                    modulePlatformLibs.add(nativeFile);\n+                }\n+            }\n+        }\n+\n+        importPathDependency.ifPresent(dependency -> validateBaloDependencies(packageID, platformLibs,\n+                dependency.getMetadata().getPath()));\n+    }\n+\n+    private void validateBaloDependencies(PackageID packageID, List<Path> platformLibs, Path importDependencyPath) {\n+        Manifest manifestFromBalo = RepoUtils.getManifestFromBalo(importDependencyPath);\n+        List<Library> baloDependencies = manifestFromBalo.getPlatform().libraries;\n+        List<Path> baloCompileScopeDependencies = new ArrayList<>();\n+        if (baloDependencies == null) {\n+            return;\n+        }\n+\n+        for (Library baloTomlLib : baloDependencies) {\n+            if (baloTomlLib.getScope() != null && baloTomlLib.getScope().equalsIgnoreCase(\"provided\")) {\n+                baloCompileScopeDependencies.add(Paths.get(baloTomlLib.getPath()).getFileName());\n+            }\n+        }\n+\n+        for (Path baloTomlLib : baloCompileScopeDependencies) {\n+            if (!platformLibs.contains(baloTomlLib)) {\n+                buildContext.out().println(\"warning: \" + packageID + \" is missing a native library dependency - \" +\n+                        baloTomlLib);\n+            }\n+        }\n+    }\n+\n+    private void addLibsFromBalo(Path baloFilePath, List<Path> moduleDependencySet) {\n+", "originalCommit": "5b7813fe98e73b1c3744db627f134197c1379039", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4OTk2NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23528#discussion_r430989965", "bodyText": "'Optional.get()' without 'isPresent()' check\nPls check whether you can use orElse() for get()\nMore info: https://softwareengineering.stackexchange.com/questions/318912/why-is-optional-get-without-calling-ispresent-bad-but-not-iterator-next", "author": "pramodya1994", "createdAt": "2020-05-27T09:40:54Z", "path": "cli/ballerina-packerina/src/main/java/org/ballerinalang/packerina/NativeDependencyResolverImpl.java", "diffHunk": "@@ -0,0 +1,312 @@\n+package org.ballerinalang.packerina;\n+\n+import com.moandjiezana.toml.Toml;\n+import org.ballerinalang.model.elements.PackageID;\n+import org.ballerinalang.packerina.buildcontext.BuildContext;\n+import org.ballerinalang.packerina.buildcontext.BuildContextField;\n+import org.ballerinalang.toml.model.Dependency;\n+import org.ballerinalang.toml.model.Library;\n+import org.ballerinalang.toml.model.Manifest;\n+import org.ballerinalang.toml.parser.ManifestProcessor;\n+import org.wso2.ballerinalang.compiler.NativeDependencyResolver;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.ProjectDirs;\n+import org.wso2.ballerinalang.programfile.ProgramFileConstants;\n+import org.wso2.ballerinalang.util.RepoUtils;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+import java.util.stream.Collectors;\n+\n+import static org.ballerinalang.tool.LauncherUtils.createLauncherException;\n+import static org.wso2.ballerinalang.compiler.util.ProjectDirConstants.BALO_PLATFORM_LIB_DIR_NAME;\n+import static org.wso2.ballerinalang.compiler.util.ProjectDirConstants.BLANG_COMPILED_JAR_EXT;\n+import static org.wso2.ballerinalang.compiler.util.ProjectDirConstants.BLANG_PKG_DEFAULT_VERSION;\n+import static org.wso2.ballerinalang.compiler.util.ProjectDirConstants.DIST_BIR_CACHE_DIR_NAME;\n+\n+/**\n+ * Resolves jars and native libs for modules.\n+ *\n+ * @since 1.3.0\n+ */\n+public class NativeDependencyResolverImpl implements NativeDependencyResolver {\n+    private static final CompilerContext.Key<NativeDependencyResolver> JAR_RESOLVER_KEY = new CompilerContext.Key<>();\n+    private List<String> supportedPlatforms = Arrays.stream(ProgramFileConstants.SUPPORTED_PLATFORMS)\n+            .collect(Collectors.toList());\n+    private final BuildContext buildContext;\n+    private final Path sourceRootPath;\n+    private final String balHomePath;\n+    private final Manifest manifest;\n+    private boolean skipCopyLibsFromDist;\n+\n+    public static NativeDependencyResolver getInstance(BuildContext buildContext, boolean skipCopyLibsFromDist) {\n+        CompilerContext context = buildContext.get(BuildContextField.COMPILER_CONTEXT);\n+        NativeDependencyResolver nativeDependencyResolver = context.get(JAR_RESOLVER_KEY);\n+        if (nativeDependencyResolver == null) {\n+            nativeDependencyResolver = new NativeDependencyResolverImpl(buildContext, skipCopyLibsFromDist);\n+        }\n+        context.put(JAR_RESOLVER_KEY, nativeDependencyResolver);\n+        return nativeDependencyResolver;\n+    }\n+\n+    private NativeDependencyResolverImpl(BuildContext buildContext, boolean skipCopyLibsFromDist) {\n+        CompilerContext context = buildContext.get(BuildContextField.COMPILER_CONTEXT);\n+        this.buildContext = buildContext;\n+        this.manifest = ManifestProcessor.getInstance(context).getManifest();\n+        this.sourceRootPath = buildContext.get(BuildContextField.SOURCE_ROOT);\n+        this.skipCopyLibsFromDist = skipCopyLibsFromDist;\n+        this.balHomePath = buildContext.get(BuildContextField.HOME_REPO).toString();\n+        supportedPlatforms.add(\"any\");\n+    }\n+\n+    @Override\n+    public Path moduleJar(PackageID packageID, String platform) {\n+        // Look if it is a project module.\n+        if (isProjectModule(packageID)) {\n+            // If so fetch from project balo cache\n+            return buildContext.getBaloFromTarget(packageID);\n+        } else if (isPathDependency(packageID)) {\n+            // If so fetch from project jar cache\n+            return buildContext.getJarPathFromTargetCache(packageID);\n+        } else if (isModuleInDistribution(packageID)) {\n+            return getJarFromDistribution(packageID);\n+        } else {\n+            // If not fetch from home balo cache.\n+            return buildContext.getBaloFromHomeCache(packageID, platform);\n+        }\n+    }\n+\n+    @Override\n+    public List<Path> nativeDependencies(PackageID packageID) {\n+        List<Path> modulePlatformLibs = new ArrayList<>();\n+        // copy platform libs for all modules(imported modules as well)\n+        addPlatformLibs(packageID, modulePlatformLibs);\n+\n+        if (isProjectModule(packageID)) {\n+            return modulePlatformLibs;\n+        } else if (isPathDependency(packageID)) {\n+            addLibsFromBaloDependency(packageID, modulePlatformLibs);\n+        } else if (isModuleInDistribution(packageID)) {\n+            addLibsFromDistribution(packageID, modulePlatformLibs);\n+        } else {\n+            addLibsFromHomeBaloCache(packageID, modulePlatformLibs);\n+        }\n+        return modulePlatformLibs;\n+    }\n+\n+    @Override\n+    public List<Path> nativeDependenciesForTests(PackageID packageID) {\n+        List<Path> testPlatformLibs = new ArrayList<>();\n+        List<Library> libraries = manifest.getPlatform().libraries;\n+        if (libraries != null) {\n+            for (Library library : libraries) {\n+                if ((library.getModules() == null ||\n+                        Arrays.asList(library.getModules()).contains(packageID.name.value)) &&\n+                        (library.getScope() != null && library.getScope().equalsIgnoreCase(\"testOnly\"))) {\n+                    String libFilePath = library.getPath();\n+                    if (libFilePath == null) {\n+                        continue;\n+                    }\n+                    Path nativeFile = sourceRootPath.resolve(Paths.get(libFilePath));\n+                    testPlatformLibs.add(nativeFile);\n+                }\n+            }\n+        }\n+        return testPlatformLibs;\n+    }\n+\n+    private boolean isModuleInDistribution(PackageID packageID) {\n+        return getTomlFilePath(packageID).exists();\n+    }\n+\n+    private File getTomlFilePath(PackageID packageID) {\n+        String version = BLANG_PKG_DEFAULT_VERSION;\n+        if (!packageID.version.value.equals(\"\")) {\n+            version = packageID.version.value;\n+        }\n+\n+        return Paths.get(balHomePath, DIST_BIR_CACHE_DIR_NAME, packageID.orgName.value,\n+                packageID.name.value, version, \"Ballerina.toml\").toFile();\n+    }\n+\n+    private boolean isPathDependency(PackageID packageID) {\n+        return buildContext.getImportPathDependency(packageID).isPresent();\n+    }\n+\n+    private boolean isProjectModule(PackageID packageID) {\n+        return manifest.getProject().getOrgName().equals(packageID.orgName.value) &&\n+                ProjectDirs.isModuleExist(sourceRootPath, packageID.name.value);\n+    }\n+\n+    private void addLibsFromHomeBaloCache(PackageID packageID, List<Path> modulePlatformLibs) {\n+        for (String platform : supportedPlatforms) {\n+            Path baloPath = buildContext.getBaloFromHomeCache(packageID, platform);\n+            if (baloPath != null && Files.exists(baloPath)) {\n+                addLibsFromBalo(baloPath, modulePlatformLibs);\n+            }\n+        }\n+    }\n+\n+    private void addLibsFromBaloDependency(PackageID packageID, List<Path> modulePlatformLibs) {\n+        addLibsFromBalo(buildContext.getImportPathDependency(packageID).get().getMetadata().getPath(),", "originalCommit": "5b7813fe98e73b1c3744db627f134197c1379039", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk5NTgzOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23528#discussion_r430995838", "bodyText": "Calling this method after the 'isPresent()' check.", "author": "suganyasuven", "createdAt": "2020-05-27T09:50:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4OTk2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk5MzczOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23528#discussion_r430993739", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            fileName.substring(0, fileName.lastIndexOf(\".\")));\n          \n          \n            \n                            fileName.substring(0, fileName.lastIndexOf('.')));\n          \n      \n    \n    \n  \n\nCan we make this a char argument?", "author": "pramodya1994", "createdAt": "2020-05-27T09:47:34Z", "path": "cli/ballerina-packerina/src/main/java/org/ballerinalang/packerina/NativeDependencyResolverImpl.java", "diffHunk": "@@ -0,0 +1,312 @@\n+package org.ballerinalang.packerina;\n+\n+import com.moandjiezana.toml.Toml;\n+import org.ballerinalang.model.elements.PackageID;\n+import org.ballerinalang.packerina.buildcontext.BuildContext;\n+import org.ballerinalang.packerina.buildcontext.BuildContextField;\n+import org.ballerinalang.toml.model.Dependency;\n+import org.ballerinalang.toml.model.Library;\n+import org.ballerinalang.toml.model.Manifest;\n+import org.ballerinalang.toml.parser.ManifestProcessor;\n+import org.wso2.ballerinalang.compiler.NativeDependencyResolver;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.ProjectDirs;\n+import org.wso2.ballerinalang.programfile.ProgramFileConstants;\n+import org.wso2.ballerinalang.util.RepoUtils;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+import java.util.stream.Collectors;\n+\n+import static org.ballerinalang.tool.LauncherUtils.createLauncherException;\n+import static org.wso2.ballerinalang.compiler.util.ProjectDirConstants.BALO_PLATFORM_LIB_DIR_NAME;\n+import static org.wso2.ballerinalang.compiler.util.ProjectDirConstants.BLANG_COMPILED_JAR_EXT;\n+import static org.wso2.ballerinalang.compiler.util.ProjectDirConstants.BLANG_PKG_DEFAULT_VERSION;\n+import static org.wso2.ballerinalang.compiler.util.ProjectDirConstants.DIST_BIR_CACHE_DIR_NAME;\n+\n+/**\n+ * Resolves jars and native libs for modules.\n+ *\n+ * @since 1.3.0\n+ */\n+public class NativeDependencyResolverImpl implements NativeDependencyResolver {\n+    private static final CompilerContext.Key<NativeDependencyResolver> JAR_RESOLVER_KEY = new CompilerContext.Key<>();\n+    private List<String> supportedPlatforms = Arrays.stream(ProgramFileConstants.SUPPORTED_PLATFORMS)\n+            .collect(Collectors.toList());\n+    private final BuildContext buildContext;\n+    private final Path sourceRootPath;\n+    private final String balHomePath;\n+    private final Manifest manifest;\n+    private boolean skipCopyLibsFromDist;\n+\n+    public static NativeDependencyResolver getInstance(BuildContext buildContext, boolean skipCopyLibsFromDist) {\n+        CompilerContext context = buildContext.get(BuildContextField.COMPILER_CONTEXT);\n+        NativeDependencyResolver nativeDependencyResolver = context.get(JAR_RESOLVER_KEY);\n+        if (nativeDependencyResolver == null) {\n+            nativeDependencyResolver = new NativeDependencyResolverImpl(buildContext, skipCopyLibsFromDist);\n+        }\n+        context.put(JAR_RESOLVER_KEY, nativeDependencyResolver);\n+        return nativeDependencyResolver;\n+    }\n+\n+    private NativeDependencyResolverImpl(BuildContext buildContext, boolean skipCopyLibsFromDist) {\n+        CompilerContext context = buildContext.get(BuildContextField.COMPILER_CONTEXT);\n+        this.buildContext = buildContext;\n+        this.manifest = ManifestProcessor.getInstance(context).getManifest();\n+        this.sourceRootPath = buildContext.get(BuildContextField.SOURCE_ROOT);\n+        this.skipCopyLibsFromDist = skipCopyLibsFromDist;\n+        this.balHomePath = buildContext.get(BuildContextField.HOME_REPO).toString();\n+        supportedPlatforms.add(\"any\");\n+    }\n+\n+    @Override\n+    public Path moduleJar(PackageID packageID, String platform) {\n+        // Look if it is a project module.\n+        if (isProjectModule(packageID)) {\n+            // If so fetch from project balo cache\n+            return buildContext.getBaloFromTarget(packageID);\n+        } else if (isPathDependency(packageID)) {\n+            // If so fetch from project jar cache\n+            return buildContext.getJarPathFromTargetCache(packageID);\n+        } else if (isModuleInDistribution(packageID)) {\n+            return getJarFromDistribution(packageID);\n+        } else {\n+            // If not fetch from home balo cache.\n+            return buildContext.getBaloFromHomeCache(packageID, platform);\n+        }\n+    }\n+\n+    @Override\n+    public List<Path> nativeDependencies(PackageID packageID) {\n+        List<Path> modulePlatformLibs = new ArrayList<>();\n+        // copy platform libs for all modules(imported modules as well)\n+        addPlatformLibs(packageID, modulePlatformLibs);\n+\n+        if (isProjectModule(packageID)) {\n+            return modulePlatformLibs;\n+        } else if (isPathDependency(packageID)) {\n+            addLibsFromBaloDependency(packageID, modulePlatformLibs);\n+        } else if (isModuleInDistribution(packageID)) {\n+            addLibsFromDistribution(packageID, modulePlatformLibs);\n+        } else {\n+            addLibsFromHomeBaloCache(packageID, modulePlatformLibs);\n+        }\n+        return modulePlatformLibs;\n+    }\n+\n+    @Override\n+    public List<Path> nativeDependenciesForTests(PackageID packageID) {\n+        List<Path> testPlatformLibs = new ArrayList<>();\n+        List<Library> libraries = manifest.getPlatform().libraries;\n+        if (libraries != null) {\n+            for (Library library : libraries) {\n+                if ((library.getModules() == null ||\n+                        Arrays.asList(library.getModules()).contains(packageID.name.value)) &&\n+                        (library.getScope() != null && library.getScope().equalsIgnoreCase(\"testOnly\"))) {\n+                    String libFilePath = library.getPath();\n+                    if (libFilePath == null) {\n+                        continue;\n+                    }\n+                    Path nativeFile = sourceRootPath.resolve(Paths.get(libFilePath));\n+                    testPlatformLibs.add(nativeFile);\n+                }\n+            }\n+        }\n+        return testPlatformLibs;\n+    }\n+\n+    private boolean isModuleInDistribution(PackageID packageID) {\n+        return getTomlFilePath(packageID).exists();\n+    }\n+\n+    private File getTomlFilePath(PackageID packageID) {\n+        String version = BLANG_PKG_DEFAULT_VERSION;\n+        if (!packageID.version.value.equals(\"\")) {\n+            version = packageID.version.value;\n+        }\n+\n+        return Paths.get(balHomePath, DIST_BIR_CACHE_DIR_NAME, packageID.orgName.value,\n+                packageID.name.value, version, \"Ballerina.toml\").toFile();\n+    }\n+\n+    private boolean isPathDependency(PackageID packageID) {\n+        return buildContext.getImportPathDependency(packageID).isPresent();\n+    }\n+\n+    private boolean isProjectModule(PackageID packageID) {\n+        return manifest.getProject().getOrgName().equals(packageID.orgName.value) &&\n+                ProjectDirs.isModuleExist(sourceRootPath, packageID.name.value);\n+    }\n+\n+    private void addLibsFromHomeBaloCache(PackageID packageID, List<Path> modulePlatformLibs) {\n+        for (String platform : supportedPlatforms) {\n+            Path baloPath = buildContext.getBaloFromHomeCache(packageID, platform);\n+            if (baloPath != null && Files.exists(baloPath)) {\n+                addLibsFromBalo(baloPath, modulePlatformLibs);\n+            }\n+        }\n+    }\n+\n+    private void addLibsFromBaloDependency(PackageID packageID, List<Path> modulePlatformLibs) {\n+        addLibsFromBalo(buildContext.getImportPathDependency(packageID).get().getMetadata().getPath(),\n+                modulePlatformLibs);\n+    }\n+\n+    private void addLibsFromDistribution(PackageID packageID, List<Path> modulePlatformLibs) {\n+        List<Path> dependencies = getDependenciesFromDist(packageID);\n+        if (dependencies != null) {\n+            modulePlatformLibs.addAll(dependencies);\n+        }\n+    }\n+\n+    private void addPlatformLibs(PackageID packageID, List<Path> modulePlatformLibs) {\n+        List<Path> platformLibs = new ArrayList<>();\n+        List<Library> libraries = manifest.getPlatform().libraries;\n+\n+        Optional<Dependency> importPathDependency = buildContext.getImportPathDependency(packageID);\n+        if (libraries != null) {\n+            for (Library library : libraries) {\n+                if ((library.getModules() == null ||\n+                        Arrays.asList(library.getModules()).contains(packageID.name.value) ||\n+                        Arrays.asList(library.getModules()).contains(packageID.orgName.value + \"/\" +\n+                                packageID.name.value)) &&\n+                        !(library.getScope() != null && library.getScope().equalsIgnoreCase(\"testOnly\"))) {\n+                    String libFilePath = library.getPath();\n+                    if (libFilePath == null) {\n+                        continue;\n+                    }\n+\n+                    Path nativeFile = sourceRootPath.resolve(Paths.get(libFilePath));\n+                    if (importPathDependency.isPresent()) {\n+                        platformLibs.add(nativeFile.getFileName());\n+                    }\n+                    modulePlatformLibs.add(nativeFile);\n+                }\n+            }\n+        }\n+\n+        importPathDependency.ifPresent(dependency -> validateBaloDependencies(packageID, platformLibs,\n+                dependency.getMetadata().getPath()));\n+    }\n+\n+    private void validateBaloDependencies(PackageID packageID, List<Path> platformLibs, Path importDependencyPath) {\n+        Manifest manifestFromBalo = RepoUtils.getManifestFromBalo(importDependencyPath);\n+        List<Library> baloDependencies = manifestFromBalo.getPlatform().libraries;\n+        List<Path> baloCompileScopeDependencies = new ArrayList<>();\n+        if (baloDependencies == null) {\n+            return;\n+        }\n+\n+        for (Library baloTomlLib : baloDependencies) {\n+            if (baloTomlLib.getScope() != null && baloTomlLib.getScope().equalsIgnoreCase(\"provided\")) {\n+                baloCompileScopeDependencies.add(Paths.get(baloTomlLib.getPath()).getFileName());\n+            }\n+        }\n+\n+        for (Path baloTomlLib : baloCompileScopeDependencies) {\n+            if (!platformLibs.contains(baloTomlLib)) {\n+                buildContext.out().println(\"warning: \" + packageID + \" is missing a native library dependency - \" +\n+                        baloTomlLib);\n+            }\n+        }\n+    }\n+\n+    private void addLibsFromBalo(Path baloFilePath, List<Path> moduleDependencySet) {\n+\n+        String fileName = baloFilePath.getFileName().toString();\n+        Path baloFileUnzipDirectory = Paths.get(baloFilePath.getParent().toString(),\n+                fileName.substring(0, fileName.lastIndexOf(\".\")));", "originalCommit": "5b7813fe98e73b1c3744db627f134197c1379039", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "222730030b8d483f26ed57dee8d6188c66d4485f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/222730030b8d483f26ed57dee8d6188c66d4485f", "message": "Add license header and apply suggestions", "committedDate": "2020-05-27T09:58:51Z", "type": "commit"}, {"oid": "030d5c191dc02604870b6da291051782e531c4fb", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/030d5c191dc02604870b6da291051782e531c4fb", "message": "Merge pull request #23538 from suganyasuven/jar-resolver\n\nRefactor dependency resolver api", "committedDate": "2020-05-27T11:00:13Z", "type": "commit"}]}