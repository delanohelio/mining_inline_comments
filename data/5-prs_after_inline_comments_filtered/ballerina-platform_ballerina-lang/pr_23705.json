{"pr_number": 23705, "pr_title": "Add support for raw template literals", "pr_createdAt": "2020-06-03T19:48:48Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkzNjQyMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r434936423", "bodyText": "Let's not use Preview1", "author": "hasithaa", "createdAt": "2020-06-04T01:06:07Z", "path": "compiler/ballerina-lang/src/main/java/org/ballerinalang/model/tree/expressions/TemplateLiteralNode.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+*  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+*\n+*  WSO2 Inc. licenses this file to you under the Apache License,\n+*  Version 2.0 (the \"License\"); you may not use this file except\n+*  in compliance with the License.\n+*  You may obtain a copy of the License at\n+*\n+*    http://www.apache.org/licenses/LICENSE-2.0\n+*\n+*  Unless required by applicable law or agreed to in writing,\n+*  software distributed under the License is distributed on an\n+*  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+*  KIND, either express or implied.  See the License for the\n+*  specific language governing permissions and limitations\n+*  under the License.\n+*/\n+package org.ballerinalang.model.tree.expressions;\n+\n+import java.util.List;\n+\n+/**\n+ * Represents a backtick string template literal node.\n+ *\n+ * @since 2.0.0-Preview1", "originalCommit": "5126d4c60a558ea9413a498955cf6399ca92c258", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkzNzU4OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r434937588", "bodyText": "Shall we add a comment explaining the final desugar outcome?", "author": "hasithaa", "createdAt": "2020-06-04T01:11:20Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -4368,6 +4369,55 @@ public void visit(BLangStringTemplateLiteral stringTemplateLiteral) {\n         result = rewriteExpr(constructStringTemplateConcatExpression(stringTemplateLiteral.exprs));\n     }\n \n+    @Override\n+    public void visit(BLangRawTemplateLiteral rawTemplateLiteral) {", "originalCommit": "5126d4c60a558ea9413a498955cf6399ca92c258", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5OTk1NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r436399955", "bodyText": "Added with c860ced", "author": "pubudu91", "createdAt": "2020-06-07T20:42:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkzNzU4OA=="}], "type": "inlineReview"}, {"oid": "02b7eb0c50c102818c98076a9625f106c8cfe426", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/02b7eb0c50c102818c98076a9625f106c8cfe426", "message": "Implement node transform logic for query-expr and from, select, where clauses", "committedDate": "2020-06-04T20:39:03Z", "type": "forcePushed"}, {"oid": "2d3f8f78ed4735e47af9ec09d5db3edaf1c9b0f8", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2d3f8f78ed4735e47af9ec09d5db3edaf1c9b0f8", "message": "Add subtype support for raw template literals", "committedDate": "2020-06-05T20:04:33Z", "type": "forcePushed"}, {"oid": "7592a72924d5c50a61e2c014ec7c3f00b6f129de", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7592a72924d5c50a61e2c014ec7c3f00b6f129de", "message": "Add subtype support for raw template literals", "committedDate": "2020-06-07T14:18:47Z", "type": "forcePushed"}, {"oid": "c70d86aa75259e08fd8f002a3f4fb9b03d07ee27", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c70d86aa75259e08fd8f002a3f4fb9b03d07ee27", "message": "Add test cases for raw template literals", "committedDate": "2020-06-08T05:09:24Z", "type": "forcePushed"}, {"oid": "664d7a1a6e6b189bebef7477308925dc573a8a1c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/664d7a1a6e6b189bebef7477308925dc573a8a1c", "message": "Add more subtyping tests and negative tests", "committedDate": "2020-06-08T14:32:15Z", "type": "forcePushed"}, {"oid": "c14f7763b91fdf5587ee75207dc30c88d463d2f8", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c14f7763b91fdf5587ee75207dc30c88d463d2f8", "message": "Rewrite the raw template literal desugar logic", "committedDate": "2020-06-10T14:38:55Z", "type": "forcePushed"}, {"oid": "563ee547a6c17630cad9b8e902fbf04161a9bab0", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/563ee547a6c17630cad9b8e902fbf04161a9bab0", "message": "Resolve syncing errors", "committedDate": "2020-06-10T14:59:28Z", "type": "forcePushed"}, {"oid": "e66f5f6555b4de42627fc6ab29a6d0081c226ce1", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e66f5f6555b4de42627fc6ab29a6d0081c226ce1", "message": "Resolve syncing errors", "committedDate": "2020-06-10T15:39:08Z", "type": "forcePushed"}, {"oid": "8ae4b7db94637e24df2fb309bf349c2cd3f8bc00", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8ae4b7db94637e24df2fb309bf349c2cd3f8bc00", "message": "Update type checking rules of raw template literals", "committedDate": "2020-06-10T21:05:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU2MTAwNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r438561007", "bodyText": "Shouldn't this be readonly & string[]", "author": "KRVPerera", "createdAt": "2020-06-11T06:05:34Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -4263,6 +4281,160 @@ public void visit(BLangStringTemplateLiteral stringTemplateLiteral) {\n         result = rewriteExpr(constructStringTemplateConcatExpression(stringTemplateLiteral.exprs));\n     }\n \n+    /**\n+     * The raw template literal gets desugared to a type init expression. For each literal, a new object class type\n+     * def is generated from the object type. The type init expression creates an instance of this generated object\n+     * type. For example, consider the following statements:\n+     *      string name = \"Pubudu\";\n+     *      'object:RawTemplate rt = `Hello ${name}!`;\n+     *\n+     * The raw template literal above is desugared to:\n+     *      type RawTemplate$Impl$0 object {\n+     *          public string[] strings = [\"Hello \", \"!\"];\n+     *          public (any|error)[] insertions;\n+     *\n+     *          function init((any|error)[] insertions) {\n+     *              self.insertions = insertions;\n+     *          }\n+     *      };\n+     *\n+     *      // somewhere in code\n+     *      'object:RawTemplate rt = new RawTemplate$Impl$0([name]);\n+     *\n+     * @param rawTemplateLiteral The raw template literal to be desugared.\n+     */\n+    @Override\n+    public void visit(BLangRawTemplateLiteral rawTemplateLiteral) {\n+        DiagnosticPos pos = rawTemplateLiteral.pos;\n+        BObjectType objType = (BObjectType) rawTemplateLiteral.type;\n+        BLangTypeDefinition objClassDef = desugarTemplateLiteralObjectTypedef(rawTemplateLiteral.strings, objType, pos);\n+        BObjectType classObjType = (BObjectType) objClassDef.type;\n+\n+        BVarSymbol insertionsSym = classObjType.fields.get(\"insertions\").symbol;\n+        BLangListConstructorExpr insertionsList = ASTBuilderUtil.createEmptyArrayLiteral(pos, insertionsSym.type);\n+        insertionsList.exprs.addAll(rawTemplateLiteral.insertions);\n+        insertionsList.expectedType = insertionsSym.type;\n+\n+        // Create an instance of the generated object class\n+        BLangTypeInit typeNewExpr = ASTBuilderUtil.createEmptyTypeInit(pos, classObjType);\n+        typeNewExpr.argsExpr.add(insertionsList);\n+        typeNewExpr.initInvocation.argExprs.add(insertionsList);\n+        typeNewExpr.initInvocation.requiredArgs.add(insertionsList);\n+\n+        result = rewriteExpr(typeNewExpr);\n+    }\n+\n+    /**\n+     * This method desugars a raw template literal object class for the provided raw template object type as follows:\n+     * A literal defined as 'object:RawTemplate rt = `Hello ${name}!`;\n+     * is desugared to,\n+     *      type $anonType$0 object {\n+     *          public string[] strings = [\"Hello \", \"!\"];", "originalCommit": "8ae4b7db94637e24df2fb309bf349c2cd3f8bc00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU2MTkzNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r438561934", "bodyText": "Also can't we have this as an actual object defined in lang.object\nballerina-platform/ballerina-spec#442 (comment)", "author": "KRVPerera", "createdAt": "2020-06-11T06:08:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU2MTAwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU4MTg5OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r438581899", "bodyText": "Yes, need to change it to readonly & string[].", "author": "pubudu91", "createdAt": "2020-06-11T07:01:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU2MTAwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU4MjkxMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r438582910", "bodyText": "Also can't we have this as an actual object defined in lang.object\nballerina-platform/ballerina-spec#442 (comment)\n\nThis is what I initially did. But as James clarified in the above issue, raw template literals are meant to work with abstract objects. If we try to use them with concrete objects, we run in to the issue I explained in ballerina-platform/ballerina-spec#442 (comment).", "author": "pubudu91", "createdAt": "2020-06-11T07:04:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU2MTAwNw=="}], "type": "inlineReview"}, {"oid": "66641535b5ebb4c17aab78b0c7d6426a285b721c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/66641535b5ebb4c17aab78b0c7d6426a285b721c", "message": "Improve error messages and fix test cases", "committedDate": "2020-06-11T13:26:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgzMjU5NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r438832595", "bodyText": "not used ?", "author": "KRVPerera", "createdAt": "2020-06-11T14:34:27Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/util/Flags.java", "diffHunk": "@@ -225,6 +225,10 @@ public static int asMask(Set<Flag> flagSet) {\n         return flagSet;\n     }\n \n+    public static int unset(int mask, int flag) {", "originalCommit": "66641535b5ebb4c17aab78b0c7d6426a285b721c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg0MTg2MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r438841860", "bodyText": "This is used in desugarTemplateLiteralObjectTypedef() method in Desugar", "author": "pubudu91", "createdAt": "2020-06-11T14:47:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgzMjU5NQ=="}], "type": "inlineReview"}, {"oid": "fd82f348921449885db5de62db2be7576acdb103", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fd82f348921449885db5de62db2be7576acdb103", "message": "Add explicit empty strings around interpolations", "committedDate": "2020-06-12T14:54:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU3MDAxNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r438570017", "bodyText": "Shouldn't we keep this as is and use BLangListConstructorExpr.BLangTupleLiteral for tuples?", "author": "MaryamZi", "createdAt": "2020-06-11T06:31:39Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/ASTBuilderUtil.java", "diffHunk": "@@ -626,7 +625,11 @@ static BLangRecordLiteral createEmptyRecordLiteral(DiagnosticPos pos, BType type\n         return recordKeyValue;\n     }\n \n-    static BLangListConstructorExpr.BLangArrayLiteral createEmptyArrayLiteral(DiagnosticPos pos, BArrayType type) {\n+    static BLangListConstructorExpr.BLangArrayLiteral createEmptyArrayLiteral(DiagnosticPos pos, BType type) {", "originalCommit": "8ae4b7db94637e24df2fb309bf349c2cd3f8bc00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4MjE2MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r439582161", "bodyText": "Ah I wasn't aware of this node. Just used this since it was the only API for creating an array.", "author": "pubudu91", "createdAt": "2020-06-12T18:34:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU3MDAxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4MjYyNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r439582627", "bodyText": "Come to think of it, I probably should be creating a BLangListConstructorExpr and let the desugar handle separating it out to array and tuple literals right?", "author": "pubudu91", "createdAt": "2020-06-12T18:35:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU3MDAxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk0Mzg3NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r438943874", "bodyText": "Is this comment still valid?", "author": "MaryamZi", "createdAt": "2020-06-11T17:15:59Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -4263,6 +4281,160 @@ public void visit(BLangStringTemplateLiteral stringTemplateLiteral) {\n         result = rewriteExpr(constructStringTemplateConcatExpression(stringTemplateLiteral.exprs));\n     }\n \n+    /**\n+     * The raw template literal gets desugared to a type init expression. For each literal, a new object class type\n+     * def is generated from the object type. The type init expression creates an instance of this generated object\n+     * type. For example, consider the following statements:\n+     *      string name = \"Pubudu\";\n+     *      'object:RawTemplate rt = `Hello ${name}!`;\n+     *\n+     * The raw template literal above is desugared to:\n+     *      type RawTemplate$Impl$0 object {\n+     *          public string[] strings = [\"Hello \", \"!\"];\n+     *          public (any|error)[] insertions;\n+     *\n+     *          function init((any|error)[] insertions) {\n+     *              self.insertions = insertions;\n+     *          }\n+     *      };\n+     *\n+     *      // somewhere in code\n+     *      'object:RawTemplate rt = new RawTemplate$Impl$0([name]);\n+     *\n+     * @param rawTemplateLiteral The raw template literal to be desugared.\n+     */\n+    @Override\n+    public void visit(BLangRawTemplateLiteral rawTemplateLiteral) {\n+        DiagnosticPos pos = rawTemplateLiteral.pos;\n+        BObjectType objType = (BObjectType) rawTemplateLiteral.type;\n+        BLangTypeDefinition objClassDef = desugarTemplateLiteralObjectTypedef(rawTemplateLiteral.strings, objType, pos);\n+        BObjectType classObjType = (BObjectType) objClassDef.type;\n+\n+        BVarSymbol insertionsSym = classObjType.fields.get(\"insertions\").symbol;\n+        BLangListConstructorExpr insertionsList = ASTBuilderUtil.createEmptyArrayLiteral(pos, insertionsSym.type);\n+        insertionsList.exprs.addAll(rawTemplateLiteral.insertions);\n+        insertionsList.expectedType = insertionsSym.type;\n+\n+        // Create an instance of the generated object class\n+        BLangTypeInit typeNewExpr = ASTBuilderUtil.createEmptyTypeInit(pos, classObjType);\n+        typeNewExpr.argsExpr.add(insertionsList);\n+        typeNewExpr.initInvocation.argExprs.add(insertionsList);\n+        typeNewExpr.initInvocation.requiredArgs.add(insertionsList);\n+\n+        result = rewriteExpr(typeNewExpr);\n+    }\n+\n+    /**\n+     * This method desugars a raw template literal object class for the provided raw template object type as follows.\n+     * A literal defined as 'object:RawTemplate rt = `Hello ${name}!`;\n+     * is desugared to,\n+     *      type $anonType$0 object {\n+     *          public string[] strings = [\"Hello \", \"!\"];\n+     *          public (any|error)[] insertions;\n+     *\n+     *          function init((any|error)[] insertions) {\n+     *              self.insertions = insertions;\n+     *          }\n+     *      };\n+     * @param strings    The string portions of the literal\n+     * @param objectType The abstract object type for which an object class needs to be generated\n+     * @param pos        The diagnostic position info for the type node\n+     * @return Returns the generated concrete object class def\n+     */\n+    private BLangTypeDefinition desugarTemplateLiteralObjectTypedef(List<BLangLiteral> strings, BObjectType objectType,\n+                                                                    DiagnosticPos pos) {\n+        // TODO: Use the anon model helper to generate the object name?", "originalCommit": "891490b3a6b6b735e7100ecee4a9aea422113bcc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4MzM1MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r439583350", "bodyText": "I think it would be better. Have to add an API to the anon model helper for it. So was planning to push it as a further improvement in preview2.", "author": "pubudu91", "createdAt": "2020-06-12T18:37:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk0Mzg3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwMDI4Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r439500283", "bodyText": "When we use an invalid type now, the error is for the rawTemplateLiteral itself.\npublic type Template abstract object {\n    public string[] strings;\n};\n\npublic function main() {\n    string name = \"World\";\n\n    Template greeting = `Hello ${name}`; // error: .::xyz.bal:8:25: incompatible types: expected 'ballerina/lang.object:1.0.0:RawTemplate', found 'Template'\n}\nShouldn't the error be for the expected type, to say something like these template literals are only allowed with sub-types of 'lang.object:RawTemplate'?", "author": "MaryamZi", "createdAt": "2020-06-12T15:50:00Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -3619,6 +3622,111 @@ public void visit(BLangStringTemplateLiteral stringTemplateLiteral) {\n         resultType = types.checkType(stringTemplateLiteral, symTable.stringType, expType);\n     }\n \n+    @Override\n+    public void visit(BLangRawTemplateLiteral rawTemplateLiteral) {\n+        // First, ensure that the contextually expected type is compatible with the RawTemplate type.\n+        // The RawTemplate type should have just two fields: strings and insertions. There shouldn't be any methods.\n+        BType type = determineRawTemplateLiteralType(rawTemplateLiteral, expType);\n+\n+        if (type == symTable.semanticError) {\n+            resultType = type;\n+            return;\n+        }\n+\n+        // Once we ensure the types are compatible, need to ensure that the types of the strings and insertions are\n+        // compatible with the types of the strings and insertions fields.\n+        BObjectType literalType = (BObjectType) type;\n+        BType stringsType = literalType.fields.get(\"strings\").type;\n+\n+        if (evaluateRawTemplateExprs(rawTemplateLiteral.strings, stringsType, INVALID_NUM_STRINGS,\n+                                     rawTemplateLiteral.pos)) {\n+            type = symTable.semanticError;\n+        }\n+\n+        BType insertionsType = literalType.fields.get(\"insertions\").type;\n+\n+        if (evaluateRawTemplateExprs(rawTemplateLiteral.insertions, insertionsType, INVALID_NUM_INSERTIONS,\n+                                     rawTemplateLiteral.pos)) {\n+            type = symTable.semanticError;\n+        }\n+\n+        resultType = type;\n+    }\n+\n+    private BType determineRawTemplateLiteralType(BLangRawTemplateLiteral rawTemplateLiteral, BType expType) {\n+        // Contextually expected type is NoType when `var` is used.\n+        // Therefore consider the literal as of type RawTemplate\n+        if (expType == symTable.noType) {\n+            return symTable.rawTemplateType;\n+        }\n+\n+        BType type = types.checkType(rawTemplateLiteral, expType, symTable.rawTemplateType);", "originalCommit": "fd82f348921449885db5de62db2be7576acdb103", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4NDYwMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r439584601", "bodyText": "Hmm yes, that does look wrong. I guess the correct way to do this would be to do what you suggested in #23705 (comment) and not switch the order. Will change.", "author": "pubudu91", "createdAt": "2020-06-12T18:40:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwMDI4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTYxNjE4MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r439616181", "bodyText": "Had a look at this. Instead of type checking against an inferred type, how about giving a different error here, instead of the standard incompatible types error? The reason is, to infer a type, we'll have to first individually type check the strings and insertions. But since now we are not type checking those two fields against a type, we'll be losing more accurate error messages we can give like in the following scenario.\ntype Temp abstract object {\n    public [string, string, string] strings;\n    public [int, float] insertions;\n};\n\nfunction testTypeChecking() {\n    Temp rt = `Foo${8}Bar${\"asdf\"}`;\n}\nThe error:\nerror: .::test.bal:7:29: incompatible types: expected 'float', found 'string'\n\nIf we infer a type and type check what we'd get is the standard incompatible message like:\nerror: .::test.bal:7:16: incompatible types: expected 'Temp', found 'abstract object {....}'", "author": "pubudu91", "createdAt": "2020-06-12T19:57:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwMDI4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwNjEzMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r439706132", "bodyText": "Yeah. I also think a different error would be more explanatory here. It's a bit different from our usual errors, but I guess that's OK given that this is kinda different syntax to create a value of a specific type of object?", "author": "MaryamZi", "createdAt": "2020-06-13T03:52:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwMDI4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxMzY1MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r439713650", "bodyText": "Yeah, was thinking the same. Will type check with a different error message", "author": "pubudu91", "createdAt": "2020-06-13T06:17:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwMDI4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNzMyMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r439717321", "bodyText": "Changed to the following in 7f3b0c2\ninvalid literal for type 'string': raw templates can only be assigned to abstract subtypes of 'ballerina/lang.object:1.0.0:RawTemplate'", "author": "pubudu91", "createdAt": "2020-06-13T07:22:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwMDI4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwOTQxMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r439509411", "bodyText": "Could this ever get printed? Shouldn't the string representation differentiate between the insertions and the strings?", "author": "MaryamZi", "createdAt": "2020-06-12T16:07:18Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/tree/expressions/BLangRawTemplateLiteral.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.tree.expressions;\n+\n+import org.ballerinalang.model.tree.NodeKind;\n+import org.ballerinalang.model.tree.expressions.ExpressionNode;\n+import org.ballerinalang.model.tree.expressions.RawTemplateLiteralNode;\n+import org.wso2.ballerinalang.compiler.tree.BLangNodeVisitor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Represents a raw template literal of the form: `Hello ${name}!`. This gets desugared to an object:RawTemplate object\n+ * or a subtype of this.\n+ *\n+ * @since 2.0.0\n+ */\n+public class BLangRawTemplateLiteral extends BLangExpression implements RawTemplateLiteralNode {\n+\n+    public List<BLangExpression> insertions;\n+    public List<BLangLiteral> strings;\n+\n+    public BLangRawTemplateLiteral() {\n+        insertions = new ArrayList<>();\n+        strings = new ArrayList<>();\n+    }\n+\n+    @Override\n+    public void accept(BLangNodeVisitor visitor) {\n+        visitor.visit(this);\n+    }\n+\n+    @Override\n+    public NodeKind getKind() {\n+        return NodeKind.RAW_TEMPLATE_LITERAL;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"BLangRawTemplateLiteral: \" + insertions + \" \" + strings;", "originalCommit": "fd82f348921449885db5de62db2be7576acdb103", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4NTkwOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r439585908", "bodyText": "No, don't think so, since this is the node itself. This just shows up in the debugger as the string representation of the node AFAIK. The string looks something like the following:\nBLangRawTemplateLiteral: [name]  [Hello, how are you?]", "author": "pubudu91", "createdAt": "2020-06-12T18:43:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwOTQxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwNjkxNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r439706915", "bodyText": "Was just wondering if we should change this to something like\nBLangRawTemplateLiteral: insertions [name] strings [Hello, how are you?]", "author": "MaryamZi", "createdAt": "2020-06-13T04:07:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwOTQxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU3MjA0MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r439572041", "bodyText": "Can/should we infer a narrower type instead, at least in the future??\nFor example, for\npublic function main() {\n    string item = \"Book\";\n    int count = 2;\n\n    var temp = `${item} count: ${count}`;\n}\ncan we infer something like\nabstract object {\n    public [string, string, string] strings;\n    public [string, int] insertions;\n}", "author": "MaryamZi", "createdAt": "2020-06-12T18:12:07Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -3619,6 +3622,111 @@ public void visit(BLangStringTemplateLiteral stringTemplateLiteral) {\n         resultType = types.checkType(stringTemplateLiteral, symTable.stringType, expType);\n     }\n \n+    @Override\n+    public void visit(BLangRawTemplateLiteral rawTemplateLiteral) {\n+        // First, ensure that the contextually expected type is compatible with the RawTemplate type.\n+        // The RawTemplate type should have just two fields: strings and insertions. There shouldn't be any methods.\n+        BType type = determineRawTemplateLiteralType(rawTemplateLiteral, expType);\n+\n+        if (type == symTable.semanticError) {\n+            resultType = type;\n+            return;\n+        }\n+\n+        // Once we ensure the types are compatible, need to ensure that the types of the strings and insertions are\n+        // compatible with the types of the strings and insertions fields.\n+        BObjectType literalType = (BObjectType) type;\n+        BType stringsType = literalType.fields.get(\"strings\").type;\n+\n+        if (evaluateRawTemplateExprs(rawTemplateLiteral.strings, stringsType, INVALID_NUM_STRINGS,\n+                                     rawTemplateLiteral.pos)) {\n+            type = symTable.semanticError;\n+        }\n+\n+        BType insertionsType = literalType.fields.get(\"insertions\").type;\n+\n+        if (evaluateRawTemplateExprs(rawTemplateLiteral.insertions, insertionsType, INVALID_NUM_INSERTIONS,\n+                                     rawTemplateLiteral.pos)) {\n+            type = symTable.semanticError;\n+        }\n+\n+        resultType = type;\n+    }\n+\n+    private BType determineRawTemplateLiteralType(BLangRawTemplateLiteral rawTemplateLiteral, BType expType) {\n+        // Contextually expected type is NoType when `var` is used.\n+        // Therefore consider the literal as of type RawTemplate\n+        if (expType == symTable.noType) {\n+            return symTable.rawTemplateType;", "originalCommit": "fd82f348921449885db5de62db2be7576acdb103", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4ODAzMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r439588033", "bodyText": "Yes, should be inferring a narrower type. Will see check and see.", "author": "pubudu91", "createdAt": "2020-06-12T18:47:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU3MjA0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU3Mzc4OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r439573788", "bodyText": "Will we be updating the logic for fixed-length arrays in this PR?", "author": "MaryamZi", "createdAt": "2020-06-12T18:15:52Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -3619,6 +3622,111 @@ public void visit(BLangStringTemplateLiteral stringTemplateLiteral) {\n         resultType = types.checkType(stringTemplateLiteral, symTable.stringType, expType);\n     }\n \n+    @Override\n+    public void visit(BLangRawTemplateLiteral rawTemplateLiteral) {\n+        // First, ensure that the contextually expected type is compatible with the RawTemplate type.\n+        // The RawTemplate type should have just two fields: strings and insertions. There shouldn't be any methods.\n+        BType type = determineRawTemplateLiteralType(rawTemplateLiteral, expType);\n+\n+        if (type == symTable.semanticError) {\n+            resultType = type;\n+            return;\n+        }\n+\n+        // Once we ensure the types are compatible, need to ensure that the types of the strings and insertions are\n+        // compatible with the types of the strings and insertions fields.\n+        BObjectType literalType = (BObjectType) type;\n+        BType stringsType = literalType.fields.get(\"strings\").type;\n+\n+        if (evaluateRawTemplateExprs(rawTemplateLiteral.strings, stringsType, INVALID_NUM_STRINGS,\n+                                     rawTemplateLiteral.pos)) {\n+            type = symTable.semanticError;\n+        }\n+\n+        BType insertionsType = literalType.fields.get(\"insertions\").type;\n+\n+        if (evaluateRawTemplateExprs(rawTemplateLiteral.insertions, insertionsType, INVALID_NUM_INSERTIONS,\n+                                     rawTemplateLiteral.pos)) {\n+            type = symTable.semanticError;\n+        }\n+\n+        resultType = type;\n+    }\n+\n+    private BType determineRawTemplateLiteralType(BLangRawTemplateLiteral rawTemplateLiteral, BType expType) {\n+        // Contextually expected type is NoType when `var` is used.\n+        // Therefore consider the literal as of type RawTemplate\n+        if (expType == symTable.noType) {\n+            return symTable.rawTemplateType;\n+        }\n+\n+        BType type = types.checkType(rawTemplateLiteral, expType, symTable.rawTemplateType);\n+\n+        if (type == symTable.semanticError) {\n+            return type;\n+        }\n+\n+        // Raw template literals can be directly assigned only to abstract object types\n+        if (!Symbols.isFlagOn(type.tsymbol.flags, Flags.ABSTRACT)) {\n+            dlog.error(rawTemplateLiteral.pos, DiagnosticCode.INVALID_RAW_TEMPLATE_ASSIGNMENT, type);\n+            return symTable.semanticError;\n+        }\n+\n+        // Ensure that only the two fields, strings and insertions, are there\n+        BObjectType litObjType = (BObjectType) type;\n+        BObjectTypeSymbol objTSymbol = (BObjectTypeSymbol) litObjType.tsymbol;\n+\n+        if (litObjType.fields.size() > 2) {\n+            dlog.error(rawTemplateLiteral.pos, DiagnosticCode.INVALID_NUM_FIELDS, litObjType);\n+            type = symTable.semanticError;\n+        }\n+\n+        if (!objTSymbol.attachedFuncs.isEmpty()) {\n+            dlog.error(rawTemplateLiteral.pos, DiagnosticCode.METHODS_NOT_ALLOWED, litObjType);\n+            type = symTable.semanticError;\n+        }\n+\n+        return type;\n+    }\n+\n+    private boolean evaluateRawTemplateExprs(List<? extends BLangExpression> exprs, BType listType, DiagnosticCode code,\n+                                             DiagnosticPos pos) {\n+        boolean errored = false;\n+\n+        if (listType.tag == TypeTags.ARRAY) {\n+            BArrayType arrayType = (BArrayType) listType;\n+            for (BLangExpression expr : exprs) {\n+                errored = (checkExpr(expr, env, arrayType.eType) == symTable.semanticError) || errored;\n+            }\n+            // TODO: Consider fixed-length arrays", "originalCommit": "fd82f348921449885db5de62db2be7576acdb103", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4ODU4MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r439588580", "bodyText": "Was thinking of deferring that to preview2", "author": "pubudu91", "createdAt": "2020-06-12T18:48:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU3Mzc4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwNzE3Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r439707176", "bodyText": "But this could lead to issues right, since we aren't validating too many/not enough expressions?\nIMO, it would be better if we can introduce this feature with this validation.", "author": "MaryamZi", "createdAt": "2020-06-13T04:13:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU3Mzc4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNDcxMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r439714713", "bodyText": "Didn't get that.What do you mean by \"validating too many/not enough expressions\"?", "author": "pubudu91", "createdAt": "2020-06-13T06:36:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU3Mzc4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxOTI0Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r439719242", "bodyText": "I meant something like\npublic type Template abstract object {\n    public string[10] strings;\n    public int[1] insertions;\n};\n\npublic function main() {    \n    Template t = `Count:${1}${2}`;\n}\nThis currently fails at runtime\n$ ballerina run --new-parser xyz.bal \nCompiling source\n        xyz.bal\nRunning executables\n\nerror: {ballerina/lang.array}IndexOutOfRange message=array index out of range: index: 1, size: 1\n        at xyz:main(xyz.bal:7)", "author": "MaryamZi", "createdAt": "2020-06-13T07:56:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU3Mzc4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc0NjQ2Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23705#discussion_r439746467", "bodyText": "Added with f494648", "author": "pubudu91", "createdAt": "2020-06-13T15:16:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU3Mzc4OA=="}], "type": "inlineReview"}, {"oid": "cc2c2f4ed0cefc71adae73bdac03c5a8e6448203", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/cc2c2f4ed0cefc71adae73bdac03c5a8e6448203", "message": "Add an API for creating a list constructor expr", "committedDate": "2020-06-12T20:33:37Z", "type": "forcePushed"}, {"oid": "3a27023b37120a4897d4fb0029961dab21650225", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3a27023b37120a4897d4fb0029961dab21650225", "message": "Change the type checking error message for raw templates", "committedDate": "2020-06-13T07:20:00Z", "type": "forcePushed"}, {"oid": "f494648d56ce24b6567dc9f7c437f8a4b509474f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f494648d56ce24b6567dc9f7c437f8a4b509474f", "message": "Add type checking for fixed length arrays", "committedDate": "2020-06-13T15:14:59Z", "type": "forcePushed"}, {"oid": "8ef05a6e0c57f0d27b4214979b607f0a43cc022d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8ef05a6e0c57f0d27b4214979b607f0a43cc022d", "message": "Add type checking for fixed length arrays", "committedDate": "2020-06-13T16:49:54Z", "type": "forcePushed"}, {"oid": "2c430e4a15d4bfb6ff2cea02444401f1f010fd30", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2c430e4a15d4bfb6ff2cea02444401f1f010fd30", "message": "Introduce raw template literal and add node transformer logic for it", "committedDate": "2020-06-13T17:11:22Z", "type": "commit"}, {"oid": "66ff87c19ab5347f766e27eb8b887bf7f824050a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/66ff87c19ab5347f766e27eb8b887bf7f824050a", "message": "Introduce RawTemplate object type and add it to symbol table", "committedDate": "2020-06-13T17:11:32Z", "type": "commit"}, {"oid": "a2713a4a5c83a26600e25b8a82061350db3989f7", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a2713a4a5c83a26600e25b8a82061350db3989f7", "message": "Add semantic checking logic for raw template literals", "committedDate": "2020-06-13T17:11:32Z", "type": "commit"}, {"oid": "94a1c0108b3ea0cfeb95276a2677bf805a03d22b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/94a1c0108b3ea0cfeb95276a2677bf805a03d22b", "message": "Desugar raw template literal to RawTemplate object", "committedDate": "2020-06-13T17:11:32Z", "type": "commit"}, {"oid": "e6b9be14c66a2cc231c2659cccae86acb9bab40a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e6b9be14c66a2cc231c2659cccae86acb9bab40a", "message": "Implement visit() for raw template literal in query desugar", "committedDate": "2020-06-13T17:11:32Z", "type": "commit"}, {"oid": "2fa6ee069cb85582073f9963d3479fb705378646", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2fa6ee069cb85582073f9963d3479fb705378646", "message": "Add subtype support for raw template literals", "committedDate": "2020-06-13T17:11:33Z", "type": "commit"}, {"oid": "b87915ab1cde926f3385bec74d29f9060bab8f3e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b87915ab1cde926f3385bec74d29f9060bab8f3e", "message": "Clean up the code", "committedDate": "2020-06-13T17:11:33Z", "type": "commit"}, {"oid": "4b5a5e30497e0079cd4b9c01c9afeb66f4d29668", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4b5a5e30497e0079cd4b9c01c9afeb66f4d29668", "message": "Add test cases for raw template literals", "committedDate": "2020-06-13T17:12:59Z", "type": "commit"}, {"oid": "420a792394b3dff02b2d11ac92e16aeca613556a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/420a792394b3dff02b2d11ac92e16aeca613556a", "message": "Add support for use with var and subtyping support for strings field", "committedDate": "2020-06-13T17:12:59Z", "type": "commit"}, {"oid": "3d0dbd722e4ad2d2fc7765b1b3303dccd103bcad", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3d0dbd722e4ad2d2fc7765b1b3303dccd103bcad", "message": "Add more subtyping tests and negative tests", "committedDate": "2020-06-13T17:12:59Z", "type": "commit"}, {"oid": "b0b6cd0f49af97463bf862ec630a29eb51ca0109", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b0b6cd0f49af97463bf862ec630a29eb51ca0109", "message": "Rewrite the raw template literal desugar logic", "committedDate": "2020-06-13T17:13:00Z", "type": "commit"}, {"oid": "0fb9c521d26782d82e4f8fc8446ba06e47c3f45e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0fb9c521d26782d82e4f8fc8446ba06e47c3f45e", "message": "Resolve syncing errors", "committedDate": "2020-06-13T17:13:00Z", "type": "commit"}, {"oid": "62a2acf8f7b152bafe4137c50103fd75131bd241", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/62a2acf8f7b152bafe4137c50103fd75131bd241", "message": "Update type checking rules of raw template literals", "committedDate": "2020-06-13T17:13:00Z", "type": "commit"}, {"oid": "e05b865c9b685e65ba27f872513fdbac4dc2e6eb", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e05b865c9b685e65ba27f872513fdbac4dc2e6eb", "message": "Improve error messages and fix test cases", "committedDate": "2020-06-13T17:13:00Z", "type": "commit"}, {"oid": "fd1f46b507b5eda4666a864d8d4e994afe632c1b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fd1f46b507b5eda4666a864d8d4e994afe632c1b", "message": "Fix checkstyle issues", "committedDate": "2020-06-13T17:13:00Z", "type": "commit"}, {"oid": "d367f73ba85b0a4215ab253aafe51260392d4544", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d367f73ba85b0a4215ab253aafe51260392d4544", "message": "Improve type checking logic to better handle handle error scenarios", "committedDate": "2020-06-13T17:13:01Z", "type": "commit"}, {"oid": "1a3d5e5249ca8ccf684bfdf7c5ef5fed96bdcda4", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1a3d5e5249ca8ccf684bfdf7c5ef5fed96bdcda4", "message": "Add explicit empty strings around interpolations", "committedDate": "2020-06-13T17:13:01Z", "type": "commit"}, {"oid": "ab0ae750c6c653b929ebb1bb0e8f84e002e31cd5", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ab0ae750c6c653b929ebb1bb0e8f84e002e31cd5", "message": "Improve error messages and add docs to raw template def", "committedDate": "2020-06-13T17:13:01Z", "type": "commit"}, {"oid": "733514b0e053a6f232598ef4f06c54701af8cd02", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/733514b0e053a6f232598ef4f06c54701af8cd02", "message": "Add an API for creating a list constructor expr", "committedDate": "2020-06-13T17:13:01Z", "type": "commit"}, {"oid": "a24da8287657e0f8216ac8465cfca72bea7b19e4", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a24da8287657e0f8216ac8465cfca72bea7b19e4", "message": "Change the type checking error message for raw templates", "committedDate": "2020-06-13T17:13:01Z", "type": "commit"}, {"oid": "000c62a21bd81482471668023beaa8a484cf58ac", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/000c62a21bd81482471668023beaa8a484cf58ac", "message": "Add test case for using raw templates with any", "committedDate": "2020-06-13T17:13:02Z", "type": "commit"}, {"oid": "72afc2dd689dc5ffd78a591bf9a2b0192d97fc14", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/72afc2dd689dc5ffd78a591bf9a2b0192d97fc14", "message": "Add type checking for fixed length arrays", "committedDate": "2020-06-13T17:13:02Z", "type": "commit"}, {"oid": "72afc2dd689dc5ffd78a591bf9a2b0192d97fc14", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/72afc2dd689dc5ffd78a591bf9a2b0192d97fc14", "message": "Add type checking for fixed length arrays", "committedDate": "2020-06-13T17:13:02Z", "type": "forcePushed"}]}