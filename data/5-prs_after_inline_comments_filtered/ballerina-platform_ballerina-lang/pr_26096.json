{"pr_number": 26096, "pr_title": "Introduce New TOML Parser", "pr_createdAt": "2020-09-25T07:42:40Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096", "timeline": [{"oid": "97b298a7de6715795128ac7d7251b45eabfb6df2", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/97b298a7de6715795128ac7d7251b45eabfb6df2", "message": "Add new AST Impl", "committedDate": "2020-09-25T09:55:36Z", "type": "forcePushed"}, {"oid": "d22c104ddce808398b620b31dae4565957a26240", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d22c104ddce808398b620b31dae4565957a26240", "message": "Add new AST Impl", "committedDate": "2020-09-25T10:16:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcyNTk1NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r495725954", "bodyText": "Shall we use io.ballerina.toml.* for all packages?", "author": "SupunS", "createdAt": "2020-09-28T06:59:05Z", "path": "misc/toml-parser/src/main/java/api/TOML.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package api;", "originalCommit": "d22c104ddce808398b620b31dae4565957a26240", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcyNjc3Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r495726773", "bodyText": "Let's use the existing diagnostic classes coming from tools-api module.", "author": "SupunS", "createdAt": "2020-09-28T07:00:42Z", "path": "misc/toml-parser/src/main/java/diagnostics/Diagnostic.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package diagnostics;\n+\n+import syntax.tree.NodeLocation;\n+\n+/**\n+ * A diagnostic represents a compiler error, a warning or a message at a specific location in the source file.\n+ *\n+ * @since 2.0.0\n+ */\n+public abstract class Diagnostic {", "originalCommit": "d22c104ddce808398b620b31dae4565957a26240", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcyNzE4Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r495727183", "bodyText": "Add doc comments for all public APIs", "author": "SupunS", "createdAt": "2020-09-28T07:01:45Z", "path": "misc/toml-parser/src/main/java/api/TOML.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package api;\n+\n+import diagnostics.Diagnostic;\n+import diagnostics.DiagnosticSeverity;\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerina.tools.text.TextDocument;\n+import io.ballerina.tools.text.TextDocuments;\n+import sementic.TomlTransformer;\n+import sementic.nodes.DiagnosticLog;\n+import sementic.nodes.DiagnosticPos;\n+import sementic.nodes.DiagnosticSource;\n+import sementic.nodes.SemanticAnalyzer;\n+import sementic.nodes.TomlArray;\n+import sementic.nodes.TomlBasicValue;\n+import sementic.nodes.TomlKey;\n+import sementic.nodes.TomlKeyValue;\n+import sementic.nodes.TomlTable;\n+import sementic.nodes.TomlTableArray;\n+import sementic.nodes.TomlValue;\n+import sementic.nodes.TopLevelNode;\n+import sementic.tools.DiagnosticCode;\n+import syntax.tree.ModulePartNode;\n+import syntax.tree.NodeLocation;\n+import syntax.tree.SyntaxKind;\n+import syntax.tree.SyntaxTree;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * TOML Library API.\n+ */\n+public class TOML {\n+\n+    private TomlTable rootNode;\n+    private DiagnosticLog dlog;\n+\n+    public TOML() {\n+        TomlKey tomlKey = new TomlKey(\"RootNode\", SyntaxKind.MODULE_NAME);\n+        this.rootNode = new TomlTable(tomlKey);\n+        this.dlog = DiagnosticLog.getInstance();\n+    }\n+\n+    public TOML(TomlTable tomlTable) {", "originalCommit": "d22c104ddce808398b620b31dae4565957a26240", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcyNzI5Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r495727293", "bodyText": "extra newline", "author": "SupunS", "createdAt": "2020-09-28T07:01:59Z", "path": "misc/toml-parser/src/main/java/api/TOML.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package api;\n+\n+import diagnostics.Diagnostic;\n+import diagnostics.DiagnosticSeverity;\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerina.tools.text.TextDocument;\n+import io.ballerina.tools.text.TextDocuments;\n+import sementic.TomlTransformer;\n+import sementic.nodes.DiagnosticLog;\n+import sementic.nodes.DiagnosticPos;\n+import sementic.nodes.DiagnosticSource;\n+import sementic.nodes.SemanticAnalyzer;\n+import sementic.nodes.TomlArray;\n+import sementic.nodes.TomlBasicValue;\n+import sementic.nodes.TomlKey;\n+import sementic.nodes.TomlKeyValue;\n+import sementic.nodes.TomlTable;\n+import sementic.nodes.TomlTableArray;\n+import sementic.nodes.TomlValue;\n+import sementic.nodes.TopLevelNode;\n+import sementic.tools.DiagnosticCode;\n+import syntax.tree.ModulePartNode;\n+import syntax.tree.NodeLocation;\n+import syntax.tree.SyntaxKind;\n+import syntax.tree.SyntaxTree;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * TOML Library API.\n+ */\n+public class TOML {\n+\n+    private TomlTable rootNode;\n+    private DiagnosticLog dlog;\n+\n+    public TOML() {\n+        TomlKey tomlKey = new TomlKey(\"RootNode\", SyntaxKind.MODULE_NAME);\n+        this.rootNode = new TomlTable(tomlKey);\n+        this.dlog = DiagnosticLog.getInstance();\n+    }\n+\n+    public TOML(TomlTable tomlTable) {\n+        this.rootNode = tomlTable;\n+    }\n+\n+    public TOML read(InputStream inputStream) {\n+        return this.read((Reader) (new InputStreamReader(inputStream)));\n+    }\n+\n+    public TOML read(Reader reader) {\n+", "originalCommit": "d22c104ddce808398b620b31dae4565957a26240", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcyNzY2Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r495727662", "bodyText": "Good to throw a toml parsing specific exception rather than the generic RuntimeException", "author": "SupunS", "createdAt": "2020-09-28T07:02:53Z", "path": "misc/toml-parser/src/main/java/api/TOML.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package api;\n+\n+import diagnostics.Diagnostic;\n+import diagnostics.DiagnosticSeverity;\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerina.tools.text.TextDocument;\n+import io.ballerina.tools.text.TextDocuments;\n+import sementic.TomlTransformer;\n+import sementic.nodes.DiagnosticLog;\n+import sementic.nodes.DiagnosticPos;\n+import sementic.nodes.DiagnosticSource;\n+import sementic.nodes.SemanticAnalyzer;\n+import sementic.nodes.TomlArray;\n+import sementic.nodes.TomlBasicValue;\n+import sementic.nodes.TomlKey;\n+import sementic.nodes.TomlKeyValue;\n+import sementic.nodes.TomlTable;\n+import sementic.nodes.TomlTableArray;\n+import sementic.nodes.TomlValue;\n+import sementic.nodes.TopLevelNode;\n+import sementic.tools.DiagnosticCode;\n+import syntax.tree.ModulePartNode;\n+import syntax.tree.NodeLocation;\n+import syntax.tree.SyntaxKind;\n+import syntax.tree.SyntaxTree;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * TOML Library API.\n+ */\n+public class TOML {\n+\n+    private TomlTable rootNode;\n+    private DiagnosticLog dlog;\n+\n+    public TOML() {\n+        TomlKey tomlKey = new TomlKey(\"RootNode\", SyntaxKind.MODULE_NAME);\n+        this.rootNode = new TomlTable(tomlKey);\n+        this.dlog = DiagnosticLog.getInstance();\n+    }\n+\n+    public TOML(TomlTable tomlTable) {\n+        this.rootNode = tomlTable;\n+    }\n+\n+    public TOML read(InputStream inputStream) {\n+        return this.read((Reader) (new InputStreamReader(inputStream)));\n+    }\n+\n+    public TOML read(Reader reader) {\n+\n+        try (BufferedReader bufferedReader = new BufferedReader(reader)) {\n+            StringBuilder w = new StringBuilder();\n+            for (String line = bufferedReader.readLine(); line != null; line = bufferedReader.readLine()) {\n+                w.append(line).append('\\n');\n+            }\n+\n+            return this.read(w.toString());\n+        } catch (IOException var12) {\n+            throw new RuntimeException(var12);", "originalCommit": "d22c104ddce808398b620b31dae4565957a26240", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcyNzk0Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r495727942", "bodyText": "can we use a better name for var12?", "author": "SupunS", "createdAt": "2020-09-28T07:03:43Z", "path": "misc/toml-parser/src/main/java/api/TOML.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package api;\n+\n+import diagnostics.Diagnostic;\n+import diagnostics.DiagnosticSeverity;\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerina.tools.text.TextDocument;\n+import io.ballerina.tools.text.TextDocuments;\n+import sementic.TomlTransformer;\n+import sementic.nodes.DiagnosticLog;\n+import sementic.nodes.DiagnosticPos;\n+import sementic.nodes.DiagnosticSource;\n+import sementic.nodes.SemanticAnalyzer;\n+import sementic.nodes.TomlArray;\n+import sementic.nodes.TomlBasicValue;\n+import sementic.nodes.TomlKey;\n+import sementic.nodes.TomlKeyValue;\n+import sementic.nodes.TomlTable;\n+import sementic.nodes.TomlTableArray;\n+import sementic.nodes.TomlValue;\n+import sementic.nodes.TopLevelNode;\n+import sementic.tools.DiagnosticCode;\n+import syntax.tree.ModulePartNode;\n+import syntax.tree.NodeLocation;\n+import syntax.tree.SyntaxKind;\n+import syntax.tree.SyntaxTree;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * TOML Library API.\n+ */\n+public class TOML {\n+\n+    private TomlTable rootNode;\n+    private DiagnosticLog dlog;\n+\n+    public TOML() {\n+        TomlKey tomlKey = new TomlKey(\"RootNode\", SyntaxKind.MODULE_NAME);\n+        this.rootNode = new TomlTable(tomlKey);\n+        this.dlog = DiagnosticLog.getInstance();\n+    }\n+\n+    public TOML(TomlTable tomlTable) {\n+        this.rootNode = tomlTable;\n+    }\n+\n+    public TOML read(InputStream inputStream) {\n+        return this.read((Reader) (new InputStreamReader(inputStream)));\n+    }\n+\n+    public TOML read(Reader reader) {\n+\n+        try (BufferedReader bufferedReader = new BufferedReader(reader)) {\n+            StringBuilder w = new StringBuilder();\n+            for (String line = bufferedReader.readLine(); line != null; line = bufferedReader.readLine()) {\n+                w.append(line).append('\\n');\n+            }\n+\n+            return this.read(w.toString());\n+        } catch (IOException var12) {", "originalCommit": "d22c104ddce808398b620b31dae4565957a26240", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTczMDYxOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r495730618", "bodyText": "Lets re-use the existing diagnostic implementation", "author": "SupunS", "createdAt": "2020-09-28T07:10:06Z", "path": "misc/toml-parser/src/main/java/sementic/nodes/DiagnosticLog.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ *  Copyright (c) 2017, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package sementic.nodes;\n+\n+import sementic.tools.DiagnosticCode;\n+\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.ResourceBundle;\n+\n+/**\n+ * Diagnostic logger.\n+ *\n+ * @since 0.94\n+ */\n+public class DiagnosticLog {", "originalCommit": "d22c104ddce808398b620b31dae4565957a26240", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzI0ODE3MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r497248170", "bodyText": "Interface or the Class? The existing DiagnosticLog Class use Package Cache and lots of ballerina related stuff.", "author": "xlight05", "createdAt": "2020-09-30T05:17:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTczMDYxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTczMTI5NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r495731294", "bodyText": "We are planing to remove DiagnosticSource. Lets avoid using it", "author": "SupunS", "createdAt": "2020-09-28T07:11:34Z", "path": "misc/toml-parser/src/main/java/api/TOML.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package api;\n+\n+import diagnostics.Diagnostic;\n+import diagnostics.DiagnosticSeverity;\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerina.tools.text.TextDocument;\n+import io.ballerina.tools.text.TextDocuments;\n+import sementic.TomlTransformer;\n+import sementic.nodes.DiagnosticLog;\n+import sementic.nodes.DiagnosticPos;\n+import sementic.nodes.DiagnosticSource;\n+import sementic.nodes.SemanticAnalyzer;\n+import sementic.nodes.TomlArray;\n+import sementic.nodes.TomlBasicValue;\n+import sementic.nodes.TomlKey;\n+import sementic.nodes.TomlKeyValue;\n+import sementic.nodes.TomlTable;\n+import sementic.nodes.TomlTableArray;\n+import sementic.nodes.TomlValue;\n+import sementic.nodes.TopLevelNode;\n+import sementic.tools.DiagnosticCode;\n+import syntax.tree.ModulePartNode;\n+import syntax.tree.NodeLocation;\n+import syntax.tree.SyntaxKind;\n+import syntax.tree.SyntaxTree;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * TOML Library API.\n+ */\n+public class TOML {\n+\n+    private TomlTable rootNode;\n+    private DiagnosticLog dlog;\n+\n+    public TOML() {\n+        TomlKey tomlKey = new TomlKey(\"RootNode\", SyntaxKind.MODULE_NAME);\n+        this.rootNode = new TomlTable(tomlKey);\n+        this.dlog = DiagnosticLog.getInstance();\n+    }\n+\n+    public TOML(TomlTable tomlTable) {\n+        this.rootNode = tomlTable;\n+    }\n+\n+    public TOML read(InputStream inputStream) {\n+        return this.read((Reader) (new InputStreamReader(inputStream)));\n+    }\n+\n+    public TOML read(Reader reader) {\n+\n+        try (BufferedReader bufferedReader = new BufferedReader(reader)) {\n+            StringBuilder w = new StringBuilder();\n+            for (String line = bufferedReader.readLine(); line != null; line = bufferedReader.readLine()) {\n+                w.append(line).append('\\n');\n+            }\n+\n+            return this.read(w.toString());\n+        } catch (IOException var12) {\n+            throw new RuntimeException(var12);\n+        }\n+    }\n+\n+    public TOML read(String content) {\n+        TextDocument textDocument = TextDocuments.from(content);\n+        SyntaxTree syntaxTree = SyntaxTree.from(textDocument);\n+\n+        DiagnosticSource diagnosticSource = new DiagnosticSource(\"basic-toml.toml\"); //TODO instance", "originalCommit": "d22c104ddce808398b620b31dae4565957a26240", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTczMjIzOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r495732239", "bodyText": "Same for DiagnosticPos as well. Lets stick to the classes coming from the tools-api module.", "author": "SupunS", "createdAt": "2020-09-28T07:13:32Z", "path": "misc/toml-parser/src/main/java/api/TOML.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package api;\n+\n+import diagnostics.Diagnostic;\n+import diagnostics.DiagnosticSeverity;\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerina.tools.text.TextDocument;\n+import io.ballerina.tools.text.TextDocuments;\n+import sementic.TomlTransformer;\n+import sementic.nodes.DiagnosticLog;\n+import sementic.nodes.DiagnosticPos;\n+import sementic.nodes.DiagnosticSource;\n+import sementic.nodes.SemanticAnalyzer;\n+import sementic.nodes.TomlArray;\n+import sementic.nodes.TomlBasicValue;\n+import sementic.nodes.TomlKey;\n+import sementic.nodes.TomlKeyValue;\n+import sementic.nodes.TomlTable;\n+import sementic.nodes.TomlTableArray;\n+import sementic.nodes.TomlValue;\n+import sementic.nodes.TopLevelNode;\n+import sementic.tools.DiagnosticCode;\n+import syntax.tree.ModulePartNode;\n+import syntax.tree.NodeLocation;\n+import syntax.tree.SyntaxKind;\n+import syntax.tree.SyntaxTree;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * TOML Library API.\n+ */\n+public class TOML {\n+\n+    private TomlTable rootNode;\n+    private DiagnosticLog dlog;\n+\n+    public TOML() {\n+        TomlKey tomlKey = new TomlKey(\"RootNode\", SyntaxKind.MODULE_NAME);\n+        this.rootNode = new TomlTable(tomlKey);\n+        this.dlog = DiagnosticLog.getInstance();\n+    }\n+\n+    public TOML(TomlTable tomlTable) {\n+        this.rootNode = tomlTable;\n+    }\n+\n+    public TOML read(InputStream inputStream) {\n+        return this.read((Reader) (new InputStreamReader(inputStream)));\n+    }\n+\n+    public TOML read(Reader reader) {\n+\n+        try (BufferedReader bufferedReader = new BufferedReader(reader)) {\n+            StringBuilder w = new StringBuilder();\n+            for (String line = bufferedReader.readLine(); line != null; line = bufferedReader.readLine()) {\n+                w.append(line).append('\\n');\n+            }\n+\n+            return this.read(w.toString());\n+        } catch (IOException var12) {\n+            throw new RuntimeException(var12);\n+        }\n+    }\n+\n+    public TOML read(String content) {\n+        TextDocument textDocument = TextDocuments.from(content);\n+        SyntaxTree syntaxTree = SyntaxTree.from(textDocument);\n+\n+        DiagnosticSource diagnosticSource = new DiagnosticSource(\"basic-toml.toml\"); //TODO instance\n+        reportSyntaxDiagnostics(diagnosticSource, syntaxTree);\n+        TomlTransformer nodeTransformer = new TomlTransformer(diagnosticSource);\n+        TomlTable transformedTable = (TomlTable) nodeTransformer.transform((ModulePartNode) syntaxTree.rootNode());\n+        SemanticAnalyzer semanticAnalyzer = new SemanticAnalyzer();\n+        semanticAnalyzer.visit(transformedTable);\n+        return new TOML(transformedTable);\n+    }\n+\n+    private void reportSyntaxDiagnostics(DiagnosticSource diagnosticSource, SyntaxTree tree) {\n+        for (Diagnostic syntaxDiagnostic : tree.diagnostics()) {\n+            DiagnosticPos pos = getPosition(syntaxDiagnostic.location(), diagnosticSource);\n+\n+            DiagnosticCode code;\n+            DiagnosticSeverity severity = syntaxDiagnostic.diagnosticInfo().severity();\n+            if (severity == DiagnosticSeverity.WARNING) {\n+                code = DiagnosticCode.SYNTAX_WARNING;\n+                dlog.warning(pos, code, syntaxDiagnostic.message());\n+            } else {\n+                code = DiagnosticCode.SYNTAX_ERROR;\n+                dlog.error(pos, code, syntaxDiagnostic.message());\n+            }\n+        }\n+    }\n+\n+    private DiagnosticPos getPosition(NodeLocation location, DiagnosticSource diagnosticSource) {\n+        if (location == null) {\n+            return null;\n+        }\n+        LineRange lineRange = location.lineRange();\n+        LinePosition startPos = lineRange.startLine();\n+        LinePosition endPos = lineRange.endLine();\n+        return new DiagnosticPos(diagnosticSource, startPos.line() + 1, endPos.line() + 1,", "originalCommit": "d22c104ddce808398b620b31dae4565957a26240", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTczMzQ2Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r495733463", "bodyText": "I think diagnostics should be persisted in the toml model itself. DiagnosticLog should only have the utility methods, and should not store anything.", "author": "SupunS", "createdAt": "2020-09-28T07:16:09Z", "path": "misc/toml-parser/src/main/java/api/TOML.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package api;\n+\n+import diagnostics.Diagnostic;\n+import diagnostics.DiagnosticSeverity;\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerina.tools.text.TextDocument;\n+import io.ballerina.tools.text.TextDocuments;\n+import sementic.TomlTransformer;\n+import sementic.nodes.DiagnosticLog;\n+import sementic.nodes.DiagnosticPos;\n+import sementic.nodes.DiagnosticSource;\n+import sementic.nodes.SemanticAnalyzer;\n+import sementic.nodes.TomlArray;\n+import sementic.nodes.TomlBasicValue;\n+import sementic.nodes.TomlKey;\n+import sementic.nodes.TomlKeyValue;\n+import sementic.nodes.TomlTable;\n+import sementic.nodes.TomlTableArray;\n+import sementic.nodes.TomlValue;\n+import sementic.nodes.TopLevelNode;\n+import sementic.tools.DiagnosticCode;\n+import syntax.tree.ModulePartNode;\n+import syntax.tree.NodeLocation;\n+import syntax.tree.SyntaxKind;\n+import syntax.tree.SyntaxTree;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * TOML Library API.\n+ */\n+public class TOML {\n+\n+    private TomlTable rootNode;\n+    private DiagnosticLog dlog;\n+\n+    public TOML() {\n+        TomlKey tomlKey = new TomlKey(\"RootNode\", SyntaxKind.MODULE_NAME);\n+        this.rootNode = new TomlTable(tomlKey);\n+        this.dlog = DiagnosticLog.getInstance();\n+    }\n+\n+    public TOML(TomlTable tomlTable) {\n+        this.rootNode = tomlTable;\n+    }\n+\n+    public TOML read(InputStream inputStream) {\n+        return this.read((Reader) (new InputStreamReader(inputStream)));\n+    }\n+\n+    public TOML read(Reader reader) {\n+\n+        try (BufferedReader bufferedReader = new BufferedReader(reader)) {\n+            StringBuilder w = new StringBuilder();\n+            for (String line = bufferedReader.readLine(); line != null; line = bufferedReader.readLine()) {\n+                w.append(line).append('\\n');\n+            }\n+\n+            return this.read(w.toString());\n+        } catch (IOException var12) {\n+            throw new RuntimeException(var12);\n+        }\n+    }\n+\n+    public TOML read(String content) {\n+        TextDocument textDocument = TextDocuments.from(content);\n+        SyntaxTree syntaxTree = SyntaxTree.from(textDocument);\n+\n+        DiagnosticSource diagnosticSource = new DiagnosticSource(\"basic-toml.toml\"); //TODO instance\n+        reportSyntaxDiagnostics(diagnosticSource, syntaxTree);\n+        TomlTransformer nodeTransformer = new TomlTransformer(diagnosticSource);\n+        TomlTable transformedTable = (TomlTable) nodeTransformer.transform((ModulePartNode) syntaxTree.rootNode());\n+        SemanticAnalyzer semanticAnalyzer = new SemanticAnalyzer();\n+        semanticAnalyzer.visit(transformedTable);\n+        return new TOML(transformedTable);\n+    }\n+\n+    private void reportSyntaxDiagnostics(DiagnosticSource diagnosticSource, SyntaxTree tree) {\n+        for (Diagnostic syntaxDiagnostic : tree.diagnostics()) {", "originalCommit": "d22c104ddce808398b620b31dae4565957a26240", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTczNDYyMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r495734622", "bodyText": "Can we avoid these instanceof checks?", "author": "SupunS", "createdAt": "2020-09-28T07:18:40Z", "path": "misc/toml-parser/src/main/java/api/TOML.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package api;\n+\n+import diagnostics.Diagnostic;\n+import diagnostics.DiagnosticSeverity;\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerina.tools.text.TextDocument;\n+import io.ballerina.tools.text.TextDocuments;\n+import sementic.TomlTransformer;\n+import sementic.nodes.DiagnosticLog;\n+import sementic.nodes.DiagnosticPos;\n+import sementic.nodes.DiagnosticSource;\n+import sementic.nodes.SemanticAnalyzer;\n+import sementic.nodes.TomlArray;\n+import sementic.nodes.TomlBasicValue;\n+import sementic.nodes.TomlKey;\n+import sementic.nodes.TomlKeyValue;\n+import sementic.nodes.TomlTable;\n+import sementic.nodes.TomlTableArray;\n+import sementic.nodes.TomlValue;\n+import sementic.nodes.TopLevelNode;\n+import sementic.tools.DiagnosticCode;\n+import syntax.tree.ModulePartNode;\n+import syntax.tree.NodeLocation;\n+import syntax.tree.SyntaxKind;\n+import syntax.tree.SyntaxTree;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * TOML Library API.\n+ */\n+public class TOML {\n+\n+    private TomlTable rootNode;\n+    private DiagnosticLog dlog;\n+\n+    public TOML() {\n+        TomlKey tomlKey = new TomlKey(\"RootNode\", SyntaxKind.MODULE_NAME);\n+        this.rootNode = new TomlTable(tomlKey);\n+        this.dlog = DiagnosticLog.getInstance();\n+    }\n+\n+    public TOML(TomlTable tomlTable) {\n+        this.rootNode = tomlTable;\n+    }\n+\n+    public TOML read(InputStream inputStream) {\n+        return this.read((Reader) (new InputStreamReader(inputStream)));\n+    }\n+\n+    public TOML read(Reader reader) {\n+\n+        try (BufferedReader bufferedReader = new BufferedReader(reader)) {\n+            StringBuilder w = new StringBuilder();\n+            for (String line = bufferedReader.readLine(); line != null; line = bufferedReader.readLine()) {\n+                w.append(line).append('\\n');\n+            }\n+\n+            return this.read(w.toString());\n+        } catch (IOException var12) {\n+            throw new RuntimeException(var12);\n+        }\n+    }\n+\n+    public TOML read(String content) {\n+        TextDocument textDocument = TextDocuments.from(content);\n+        SyntaxTree syntaxTree = SyntaxTree.from(textDocument);\n+\n+        DiagnosticSource diagnosticSource = new DiagnosticSource(\"basic-toml.toml\"); //TODO instance\n+        reportSyntaxDiagnostics(diagnosticSource, syntaxTree);\n+        TomlTransformer nodeTransformer = new TomlTransformer(diagnosticSource);\n+        TomlTable transformedTable = (TomlTable) nodeTransformer.transform((ModulePartNode) syntaxTree.rootNode());\n+        SemanticAnalyzer semanticAnalyzer = new SemanticAnalyzer();\n+        semanticAnalyzer.visit(transformedTable);\n+        return new TOML(transformedTable);\n+    }\n+\n+    private void reportSyntaxDiagnostics(DiagnosticSource diagnosticSource, SyntaxTree tree) {\n+        for (Diagnostic syntaxDiagnostic : tree.diagnostics()) {\n+            DiagnosticPos pos = getPosition(syntaxDiagnostic.location(), diagnosticSource);\n+\n+            DiagnosticCode code;\n+            DiagnosticSeverity severity = syntaxDiagnostic.diagnosticInfo().severity();\n+            if (severity == DiagnosticSeverity.WARNING) {\n+                code = DiagnosticCode.SYNTAX_WARNING;\n+                dlog.warning(pos, code, syntaxDiagnostic.message());\n+            } else {\n+                code = DiagnosticCode.SYNTAX_ERROR;\n+                dlog.error(pos, code, syntaxDiagnostic.message());\n+            }\n+        }\n+    }\n+\n+    private DiagnosticPos getPosition(NodeLocation location, DiagnosticSource diagnosticSource) {\n+        if (location == null) {\n+            return null;\n+        }\n+        LineRange lineRange = location.lineRange();\n+        LinePosition startPos = lineRange.startLine();\n+        LinePosition endPos = lineRange.endLine();\n+        return new DiagnosticPos(diagnosticSource, startPos.line() + 1, endPos.line() + 1,\n+                startPos.offset() + 1, endPos.offset() + 1);\n+    }\n+\n+    public String getString(String key) {\n+        Object value = getValueFromAST(key);\n+        if (value instanceof String) {\n+            return (String) value;\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    public Double getDouble(String key) {\n+        Object value = getValueFromAST(key);\n+        if (value instanceof Double) {", "originalCommit": "d22c104ddce808398b620b31dae4565957a26240", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTczNTg3Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r495735873", "bodyText": "We don't need to support this. If someone needs to access a nested table, say \"foo.bar\", they need to chain the call x.getTable(\"foo\").getTable(\"bar\") and so on.\nSame is applicable for other methods as well.", "author": "SupunS", "createdAt": "2020-09-28T07:21:14Z", "path": "misc/toml-parser/src/main/java/api/TOML.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package api;\n+\n+import diagnostics.Diagnostic;\n+import diagnostics.DiagnosticSeverity;\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerina.tools.text.TextDocument;\n+import io.ballerina.tools.text.TextDocuments;\n+import sementic.TomlTransformer;\n+import sementic.nodes.DiagnosticLog;\n+import sementic.nodes.DiagnosticPos;\n+import sementic.nodes.DiagnosticSource;\n+import sementic.nodes.SemanticAnalyzer;\n+import sementic.nodes.TomlArray;\n+import sementic.nodes.TomlBasicValue;\n+import sementic.nodes.TomlKey;\n+import sementic.nodes.TomlKeyValue;\n+import sementic.nodes.TomlTable;\n+import sementic.nodes.TomlTableArray;\n+import sementic.nodes.TomlValue;\n+import sementic.nodes.TopLevelNode;\n+import sementic.tools.DiagnosticCode;\n+import syntax.tree.ModulePartNode;\n+import syntax.tree.NodeLocation;\n+import syntax.tree.SyntaxKind;\n+import syntax.tree.SyntaxTree;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * TOML Library API.\n+ */\n+public class TOML {\n+\n+    private TomlTable rootNode;\n+    private DiagnosticLog dlog;\n+\n+    public TOML() {\n+        TomlKey tomlKey = new TomlKey(\"RootNode\", SyntaxKind.MODULE_NAME);\n+        this.rootNode = new TomlTable(tomlKey);\n+        this.dlog = DiagnosticLog.getInstance();\n+    }\n+\n+    public TOML(TomlTable tomlTable) {\n+        this.rootNode = tomlTable;\n+    }\n+\n+    public TOML read(InputStream inputStream) {\n+        return this.read((Reader) (new InputStreamReader(inputStream)));\n+    }\n+\n+    public TOML read(Reader reader) {\n+\n+        try (BufferedReader bufferedReader = new BufferedReader(reader)) {\n+            StringBuilder w = new StringBuilder();\n+            for (String line = bufferedReader.readLine(); line != null; line = bufferedReader.readLine()) {\n+                w.append(line).append('\\n');\n+            }\n+\n+            return this.read(w.toString());\n+        } catch (IOException var12) {\n+            throw new RuntimeException(var12);\n+        }\n+    }\n+\n+    public TOML read(String content) {\n+        TextDocument textDocument = TextDocuments.from(content);\n+        SyntaxTree syntaxTree = SyntaxTree.from(textDocument);\n+\n+        DiagnosticSource diagnosticSource = new DiagnosticSource(\"basic-toml.toml\"); //TODO instance\n+        reportSyntaxDiagnostics(diagnosticSource, syntaxTree);\n+        TomlTransformer nodeTransformer = new TomlTransformer(diagnosticSource);\n+        TomlTable transformedTable = (TomlTable) nodeTransformer.transform((ModulePartNode) syntaxTree.rootNode());\n+        SemanticAnalyzer semanticAnalyzer = new SemanticAnalyzer();\n+        semanticAnalyzer.visit(transformedTable);\n+        return new TOML(transformedTable);\n+    }\n+\n+    private void reportSyntaxDiagnostics(DiagnosticSource diagnosticSource, SyntaxTree tree) {\n+        for (Diagnostic syntaxDiagnostic : tree.diagnostics()) {\n+            DiagnosticPos pos = getPosition(syntaxDiagnostic.location(), diagnosticSource);\n+\n+            DiagnosticCode code;\n+            DiagnosticSeverity severity = syntaxDiagnostic.diagnosticInfo().severity();\n+            if (severity == DiagnosticSeverity.WARNING) {\n+                code = DiagnosticCode.SYNTAX_WARNING;\n+                dlog.warning(pos, code, syntaxDiagnostic.message());\n+            } else {\n+                code = DiagnosticCode.SYNTAX_ERROR;\n+                dlog.error(pos, code, syntaxDiagnostic.message());\n+            }\n+        }\n+    }\n+\n+    private DiagnosticPos getPosition(NodeLocation location, DiagnosticSource diagnosticSource) {\n+        if (location == null) {\n+            return null;\n+        }\n+        LineRange lineRange = location.lineRange();\n+        LinePosition startPos = lineRange.startLine();\n+        LinePosition endPos = lineRange.endLine();\n+        return new DiagnosticPos(diagnosticSource, startPos.line() + 1, endPos.line() + 1,\n+                startPos.offset() + 1, endPos.offset() + 1);\n+    }\n+\n+    public String getString(String key) {\n+        Object value = getValueFromAST(key);\n+        if (value instanceof String) {\n+            return (String) value;\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    public Double getDouble(String key) {\n+        Object value = getValueFromAST(key);\n+        if (value instanceof Double) {\n+            return (Double) value;\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    public Long getLong(String key) {\n+        Object value = getValueFromAST(key);\n+        if (value instanceof Long) {\n+            return (Long) value;\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    public <T> List<T> getList(String key) {\n+        Object value = getValueFromAST(key);\n+        if (value instanceof List) {\n+            return (List<T>) value;\n+        }\n+        return null;\n+    }\n+\n+    public Boolean getBoolean(String key) {\n+        Object value = getValueFromAST(key);\n+        if (value instanceof Boolean) {\n+            return (Boolean) value;\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    private Object getValueFromAST(String key) {\n+        String[] split = key.split(\"\\\\.\");", "originalCommit": "d22c104ddce808398b620b31dae4565957a26240", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzI0ODg2OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r497248868", "bodyText": "I agree, developer can use it however TOML Spec and implementations such as  TOML4J supports this.", "author": "xlight05", "createdAt": "2020-09-30T05:20:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTczNTg3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTczNjQzNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r495736434", "bodyText": "Returning a TomlValue from this method will help to avoid the instanceof checks in other places", "author": "SupunS", "createdAt": "2020-09-28T07:22:22Z", "path": "misc/toml-parser/src/main/java/api/TOML.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package api;\n+\n+import diagnostics.Diagnostic;\n+import diagnostics.DiagnosticSeverity;\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerina.tools.text.TextDocument;\n+import io.ballerina.tools.text.TextDocuments;\n+import sementic.TomlTransformer;\n+import sementic.nodes.DiagnosticLog;\n+import sementic.nodes.DiagnosticPos;\n+import sementic.nodes.DiagnosticSource;\n+import sementic.nodes.SemanticAnalyzer;\n+import sementic.nodes.TomlArray;\n+import sementic.nodes.TomlBasicValue;\n+import sementic.nodes.TomlKey;\n+import sementic.nodes.TomlKeyValue;\n+import sementic.nodes.TomlTable;\n+import sementic.nodes.TomlTableArray;\n+import sementic.nodes.TomlValue;\n+import sementic.nodes.TopLevelNode;\n+import sementic.tools.DiagnosticCode;\n+import syntax.tree.ModulePartNode;\n+import syntax.tree.NodeLocation;\n+import syntax.tree.SyntaxKind;\n+import syntax.tree.SyntaxTree;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * TOML Library API.\n+ */\n+public class TOML {\n+\n+    private TomlTable rootNode;\n+    private DiagnosticLog dlog;\n+\n+    public TOML() {\n+        TomlKey tomlKey = new TomlKey(\"RootNode\", SyntaxKind.MODULE_NAME);\n+        this.rootNode = new TomlTable(tomlKey);\n+        this.dlog = DiagnosticLog.getInstance();\n+    }\n+\n+    public TOML(TomlTable tomlTable) {\n+        this.rootNode = tomlTable;\n+    }\n+\n+    public TOML read(InputStream inputStream) {\n+        return this.read((Reader) (new InputStreamReader(inputStream)));\n+    }\n+\n+    public TOML read(Reader reader) {\n+\n+        try (BufferedReader bufferedReader = new BufferedReader(reader)) {\n+            StringBuilder w = new StringBuilder();\n+            for (String line = bufferedReader.readLine(); line != null; line = bufferedReader.readLine()) {\n+                w.append(line).append('\\n');\n+            }\n+\n+            return this.read(w.toString());\n+        } catch (IOException var12) {\n+            throw new RuntimeException(var12);\n+        }\n+    }\n+\n+    public TOML read(String content) {\n+        TextDocument textDocument = TextDocuments.from(content);\n+        SyntaxTree syntaxTree = SyntaxTree.from(textDocument);\n+\n+        DiagnosticSource diagnosticSource = new DiagnosticSource(\"basic-toml.toml\"); //TODO instance\n+        reportSyntaxDiagnostics(diagnosticSource, syntaxTree);\n+        TomlTransformer nodeTransformer = new TomlTransformer(diagnosticSource);\n+        TomlTable transformedTable = (TomlTable) nodeTransformer.transform((ModulePartNode) syntaxTree.rootNode());\n+        SemanticAnalyzer semanticAnalyzer = new SemanticAnalyzer();\n+        semanticAnalyzer.visit(transformedTable);\n+        return new TOML(transformedTable);\n+    }\n+\n+    private void reportSyntaxDiagnostics(DiagnosticSource diagnosticSource, SyntaxTree tree) {\n+        for (Diagnostic syntaxDiagnostic : tree.diagnostics()) {\n+            DiagnosticPos pos = getPosition(syntaxDiagnostic.location(), diagnosticSource);\n+\n+            DiagnosticCode code;\n+            DiagnosticSeverity severity = syntaxDiagnostic.diagnosticInfo().severity();\n+            if (severity == DiagnosticSeverity.WARNING) {\n+                code = DiagnosticCode.SYNTAX_WARNING;\n+                dlog.warning(pos, code, syntaxDiagnostic.message());\n+            } else {\n+                code = DiagnosticCode.SYNTAX_ERROR;\n+                dlog.error(pos, code, syntaxDiagnostic.message());\n+            }\n+        }\n+    }\n+\n+    private DiagnosticPos getPosition(NodeLocation location, DiagnosticSource diagnosticSource) {\n+        if (location == null) {\n+            return null;\n+        }\n+        LineRange lineRange = location.lineRange();\n+        LinePosition startPos = lineRange.startLine();\n+        LinePosition endPos = lineRange.endLine();\n+        return new DiagnosticPos(diagnosticSource, startPos.line() + 1, endPos.line() + 1,\n+                startPos.offset() + 1, endPos.offset() + 1);\n+    }\n+\n+    public String getString(String key) {\n+        Object value = getValueFromAST(key);\n+        if (value instanceof String) {\n+            return (String) value;\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    public Double getDouble(String key) {\n+        Object value = getValueFromAST(key);\n+        if (value instanceof Double) {\n+            return (Double) value;\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    public Long getLong(String key) {\n+        Object value = getValueFromAST(key);\n+        if (value instanceof Long) {\n+            return (Long) value;\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    public <T> List<T> getList(String key) {\n+        Object value = getValueFromAST(key);\n+        if (value instanceof List) {\n+            return (List<T>) value;\n+        }\n+        return null;\n+    }\n+\n+    public Boolean getBoolean(String key) {\n+        Object value = getValueFromAST(key);\n+        if (value instanceof Boolean) {\n+            return (Boolean) value;\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    private Object getValueFromAST(String key) {\n+        String[] split = key.split(\"\\\\.\");\n+        String[] parentTables = Arrays.copyOf(split, split.length - 1);\n+        String lastKey = split[split.length - 1];\n+\n+        TomlTable parentTable = getParentTable(parentTables);\n+        if (parentTable != null) {\n+            TomlKeyValue tomlKeyValue = (TomlKeyValue) parentTable.getChilds().get(lastKey);\n+            if (tomlKeyValue != null) {\n+\n+                TomlValue value = tomlKeyValue.value;\n+                if (value instanceof TomlBasicValue) {\n+                    return ((TomlBasicValue) value).getValue();", "originalCommit": "d22c104ddce808398b620b31dae4565957a26240", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTczNzQ3MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r495737471", "bodyText": "Why do we need to return a list here? Can a single kay map to multiple values?", "author": "SupunS", "createdAt": "2020-09-28T07:24:32Z", "path": "misc/toml-parser/src/main/java/api/TOML.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package api;\n+\n+import diagnostics.Diagnostic;\n+import diagnostics.DiagnosticSeverity;\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerina.tools.text.TextDocument;\n+import io.ballerina.tools.text.TextDocuments;\n+import sementic.TomlTransformer;\n+import sementic.nodes.DiagnosticLog;\n+import sementic.nodes.DiagnosticPos;\n+import sementic.nodes.DiagnosticSource;\n+import sementic.nodes.SemanticAnalyzer;\n+import sementic.nodes.TomlArray;\n+import sementic.nodes.TomlBasicValue;\n+import sementic.nodes.TomlKey;\n+import sementic.nodes.TomlKeyValue;\n+import sementic.nodes.TomlTable;\n+import sementic.nodes.TomlTableArray;\n+import sementic.nodes.TomlValue;\n+import sementic.nodes.TopLevelNode;\n+import sementic.tools.DiagnosticCode;\n+import syntax.tree.ModulePartNode;\n+import syntax.tree.NodeLocation;\n+import syntax.tree.SyntaxKind;\n+import syntax.tree.SyntaxTree;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * TOML Library API.\n+ */\n+public class TOML {\n+\n+    private TomlTable rootNode;\n+    private DiagnosticLog dlog;\n+\n+    public TOML() {\n+        TomlKey tomlKey = new TomlKey(\"RootNode\", SyntaxKind.MODULE_NAME);\n+        this.rootNode = new TomlTable(tomlKey);\n+        this.dlog = DiagnosticLog.getInstance();\n+    }\n+\n+    public TOML(TomlTable tomlTable) {\n+        this.rootNode = tomlTable;\n+    }\n+\n+    public TOML read(InputStream inputStream) {\n+        return this.read((Reader) (new InputStreamReader(inputStream)));\n+    }\n+\n+    public TOML read(Reader reader) {\n+\n+        try (BufferedReader bufferedReader = new BufferedReader(reader)) {\n+            StringBuilder w = new StringBuilder();\n+            for (String line = bufferedReader.readLine(); line != null; line = bufferedReader.readLine()) {\n+                w.append(line).append('\\n');\n+            }\n+\n+            return this.read(w.toString());\n+        } catch (IOException var12) {\n+            throw new RuntimeException(var12);\n+        }\n+    }\n+\n+    public TOML read(String content) {\n+        TextDocument textDocument = TextDocuments.from(content);\n+        SyntaxTree syntaxTree = SyntaxTree.from(textDocument);\n+\n+        DiagnosticSource diagnosticSource = new DiagnosticSource(\"basic-toml.toml\"); //TODO instance\n+        reportSyntaxDiagnostics(diagnosticSource, syntaxTree);\n+        TomlTransformer nodeTransformer = new TomlTransformer(diagnosticSource);\n+        TomlTable transformedTable = (TomlTable) nodeTransformer.transform((ModulePartNode) syntaxTree.rootNode());\n+        SemanticAnalyzer semanticAnalyzer = new SemanticAnalyzer();\n+        semanticAnalyzer.visit(transformedTable);\n+        return new TOML(transformedTable);\n+    }\n+\n+    private void reportSyntaxDiagnostics(DiagnosticSource diagnosticSource, SyntaxTree tree) {\n+        for (Diagnostic syntaxDiagnostic : tree.diagnostics()) {\n+            DiagnosticPos pos = getPosition(syntaxDiagnostic.location(), diagnosticSource);\n+\n+            DiagnosticCode code;\n+            DiagnosticSeverity severity = syntaxDiagnostic.diagnosticInfo().severity();\n+            if (severity == DiagnosticSeverity.WARNING) {\n+                code = DiagnosticCode.SYNTAX_WARNING;\n+                dlog.warning(pos, code, syntaxDiagnostic.message());\n+            } else {\n+                code = DiagnosticCode.SYNTAX_ERROR;\n+                dlog.error(pos, code, syntaxDiagnostic.message());\n+            }\n+        }\n+    }\n+\n+    private DiagnosticPos getPosition(NodeLocation location, DiagnosticSource diagnosticSource) {\n+        if (location == null) {\n+            return null;\n+        }\n+        LineRange lineRange = location.lineRange();\n+        LinePosition startPos = lineRange.startLine();\n+        LinePosition endPos = lineRange.endLine();\n+        return new DiagnosticPos(diagnosticSource, startPos.line() + 1, endPos.line() + 1,\n+                startPos.offset() + 1, endPos.offset() + 1);\n+    }\n+\n+    public String getString(String key) {\n+        Object value = getValueFromAST(key);\n+        if (value instanceof String) {\n+            return (String) value;\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    public Double getDouble(String key) {\n+        Object value = getValueFromAST(key);\n+        if (value instanceof Double) {\n+            return (Double) value;\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    public Long getLong(String key) {\n+        Object value = getValueFromAST(key);\n+        if (value instanceof Long) {\n+            return (Long) value;\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    public <T> List<T> getList(String key) {\n+        Object value = getValueFromAST(key);\n+        if (value instanceof List) {\n+            return (List<T>) value;\n+        }\n+        return null;\n+    }\n+\n+    public Boolean getBoolean(String key) {\n+        Object value = getValueFromAST(key);\n+        if (value instanceof Boolean) {\n+            return (Boolean) value;\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    private Object getValueFromAST(String key) {\n+        String[] split = key.split(\"\\\\.\");\n+        String[] parentTables = Arrays.copyOf(split, split.length - 1);\n+        String lastKey = split[split.length - 1];\n+\n+        TomlTable parentTable = getParentTable(parentTables);\n+        if (parentTable != null) {\n+            TomlKeyValue tomlKeyValue = (TomlKeyValue) parentTable.getChilds().get(lastKey);\n+            if (tomlKeyValue != null) {\n+\n+                TomlValue value = tomlKeyValue.value;\n+                if (value instanceof TomlBasicValue) {\n+                    return ((TomlBasicValue) value).getValue();\n+                } else if (value instanceof TomlArray) {\n+                    return extractValuesFromTomlArray((TomlArray) value);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private List<Object> extractValuesFromTomlArray(TomlArray array) {\n+        List<TomlValue> elements = array.getElements();\n+        List<Object> output = new ArrayList<>();\n+        for (TomlValue value : elements) {\n+            if (value instanceof TomlBasicValue) {\n+                output.add(((TomlBasicValue) value).getValue());\n+            } else if (value instanceof TomlArray) {\n+                output.add(extractValuesFromTomlArray((TomlArray) value));\n+            }\n+        }\n+        return output;", "originalCommit": "d22c104ddce808398b620b31dae4565957a26240", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTczODIwOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r495738208", "bodyText": "Cleanup this class and keep only the required ones for the toml parser", "author": "SupunS", "createdAt": "2020-09-28T07:26:00Z", "path": "misc/toml-parser/src/main/java/internal/diagnostics/DiagnosticErrorCode.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package internal.diagnostics;\n+\n+import diagnostics.DiagnosticSeverity;\n+\n+/**\n+ * Represents a diagnostic error code.\n+ *\n+ * @since 2.0.0\n+ */\n+public enum DiagnosticErrorCode implements DiagnosticCode {", "originalCommit": "d22c104ddce808398b620b31dae4565957a26240", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgxMzQ1Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r495813456", "bodyText": "missing version. i.e: @since", "author": "SupunS", "createdAt": "2020-09-28T09:40:21Z", "path": "misc/toml-parser/src/main/java/api/TOML.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package api;\n+\n+import diagnostics.Diagnostic;\n+import diagnostics.DiagnosticSeverity;\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerina.tools.text.TextDocument;\n+import io.ballerina.tools.text.TextDocuments;\n+import sementic.TomlTransformer;\n+import sementic.nodes.DiagnosticLog;\n+import sementic.nodes.DiagnosticPos;\n+import sementic.nodes.DiagnosticSource;\n+import sementic.nodes.SemanticAnalyzer;\n+import sementic.nodes.TomlArray;\n+import sementic.nodes.TomlBasicValue;\n+import sementic.nodes.TomlKey;\n+import sementic.nodes.TomlKeyValue;\n+import sementic.nodes.TomlTable;\n+import sementic.nodes.TomlTableArray;\n+import sementic.nodes.TomlValue;\n+import sementic.nodes.TopLevelNode;\n+import sementic.tools.DiagnosticCode;\n+import syntax.tree.ModulePartNode;\n+import syntax.tree.NodeLocation;\n+import syntax.tree.SyntaxKind;\n+import syntax.tree.SyntaxTree;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * TOML Library API.", "originalCommit": "d22c104ddce808398b620b31dae4565957a26240", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgxNjU0MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r495816541", "bodyText": "Can't we use the abstract classes from ballerina-parser module?", "author": "SupunS", "createdAt": "2020-09-28T09:45:22Z", "path": "misc/toml-parser/src/main/java/internal/parser/AbstractLexer.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package internal.parser;\n+\n+import internal.diagnostics.DiagnosticCode;\n+import internal.parser.tree.STNode;\n+import internal.parser.tree.STNodeDiagnostic;\n+import internal.parser.tree.STToken;\n+import io.ballerina.tools.text.CharReader;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+/**\n+ * An abstract lexer to be extended by all ballerina lexer implementations.\n+ *\n+ * @since 2.0.0\n+ */\n+public abstract class AbstractLexer {", "originalCommit": "d22c104ddce808398b620b31dae4565957a26240", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzI0OTMwNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r497249307", "bodyText": "AbstractLexer uses STNode for leadingTriviaList. therefore i don't think we can atm.", "author": "xlight05", "createdAt": "2020-09-30T05:22:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgxNjU0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgxNjg2OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r495816869", "bodyText": "incorrect version", "author": "SupunS", "createdAt": "2020-09-28T09:45:53Z", "path": "misc/toml-parser/src/main/java/internal/parser/LexerTerminals.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package internal.parser;\n+\n+/**\n+ * Contains lexer terminal nodes. Includes keywords, syntaxes, and operators.\n+ *\n+ * @since 1.2.0", "originalCommit": "d22c104ddce808398b620b31dae4565957a26240", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgxNzA2MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r495817060", "bodyText": "Incorrect version", "author": "SupunS", "createdAt": "2020-09-28T09:46:13Z", "path": "misc/toml-parser/src/main/java/internal/parser/ParserFactory.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package internal.parser;\n+\n+import io.ballerina.tools.text.CharReader;\n+import io.ballerina.tools.text.TextDocument;\n+import io.ballerina.tools.text.TextDocuments;\n+\n+\n+/**\n+ * A factory for creating {@code BallerinaParser} instances.\n+ * <p>\n+ * Creates a regular parser or an incremental parser based on the parameters.\n+ *\n+ * @since 1.3.0", "originalCommit": "d22c104ddce808398b620b31dae4565957a26240", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgxNzQ0MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r495817440", "bodyText": "Do we need this enum?", "author": "SupunS", "createdAt": "2020-09-28T09:46:49Z", "path": "misc/toml-parser/src/main/java/internal/parser/ParserMode.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package internal.parser;\n+\n+/**\n+ * Modes of parsing.\n+ * \n+ * @since 1.3.0\n+ */\n+public enum ParserMode {", "originalCommit": "d22c104ddce808398b620b31dae4565957a26240", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzI0OTg5MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r497249890", "bodyText": "No we don't. However, Its required by the abstract lexer. I modified only the Node imports of the Abstract Lexer. Its possible remove this but we'll have to modify the logic of the abstract lexer a  bit.", "author": "xlight05", "createdAt": "2020-09-30T05:24:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgxNzQ0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgxODI0NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r495818245", "bodyText": "This class has lots of unused/unnecessary methods. Lets clean it up", "author": "SupunS", "createdAt": "2020-09-28T09:48:11Z", "path": "misc/toml-parser/src/main/java/internal/parser/SyntaxErrors.java", "diffHunk": "@@ -0,0 +1,553 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package internal.parser;\n+\n+import internal.diagnostics.DiagnosticCode;\n+import internal.diagnostics.DiagnosticErrorCode;\n+import internal.parser.tree.STNode;\n+import internal.parser.tree.STNodeDiagnostic;\n+import internal.parser.tree.STNodeFactory;\n+import internal.parser.tree.STNodeList;\n+import internal.parser.tree.STToken;\n+import internal.syntax.NodeListUtils;\n+import internal.syntax.SyntaxUtils;\n+import syntax.tree.SyntaxKind;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * This class contains utilities to handle syntax errors.\n+ *\n+ * @since 2.0.0\n+ */\n+public class SyntaxErrors {", "originalCommit": "d22c104ddce808398b620b31dae4565957a26240", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgyMDEyNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r495820125", "bodyText": "Can we follow the same approach as the BallerinaLexer for capturing diagnostics?", "author": "SupunS", "createdAt": "2020-09-28T09:51:13Z", "path": "misc/toml-parser/src/main/java/internal/parser/TomlLexer.java", "diffHunk": "@@ -0,0 +1,744 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package internal.parser;\n+\n+import internal.diagnostics.DiagnosticErrorCode;\n+import internal.parser.tree.STNode;\n+import internal.parser.tree.STNodeFactory;\n+import internal.parser.tree.STToken;\n+import io.ballerina.tools.text.CharReader;\n+import syntax.tree.SyntaxKind;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * A LL(k) lexer for TOML.\n+ *\n+ * @since 1.2.0\n+ */\n+public class TomlLexer extends AbstractLexer {\n+\n+    public TomlLexer(CharReader charReader) {\n+        super(charReader, ParserMode.DEFAULT);\n+    }\n+\n+    /**\n+     * Get the next lexical token.\n+     *\n+     * @return Next lexical token.\n+     */\n+    public STToken nextToken() {\n+        STToken token;\n+        processLeadingTrivia();\n+        token = readToken();\n+\n+        // Can we improve this logic by creating the token with diagnostics then and there?\n+        return cloneWithDiagnostics(token);", "originalCommit": "d22c104ddce808398b620b31dae4565957a26240", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgyMDk0NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r495820945", "bodyText": "I guess you want to check for triple double-quotes? In that case you should check reader.peek(1) and reader.peek(2)", "author": "SupunS", "createdAt": "2020-09-28T09:52:42Z", "path": "misc/toml-parser/src/main/java/internal/parser/TomlLexer.java", "diffHunk": "@@ -0,0 +1,744 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package internal.parser;\n+\n+import internal.diagnostics.DiagnosticErrorCode;\n+import internal.parser.tree.STNode;\n+import internal.parser.tree.STNodeFactory;\n+import internal.parser.tree.STToken;\n+import io.ballerina.tools.text.CharReader;\n+import syntax.tree.SyntaxKind;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * A LL(k) lexer for TOML.\n+ *\n+ * @since 1.2.0\n+ */\n+public class TomlLexer extends AbstractLexer {\n+\n+    public TomlLexer(CharReader charReader) {\n+        super(charReader, ParserMode.DEFAULT);\n+    }\n+\n+    /**\n+     * Get the next lexical token.\n+     *\n+     * @return Next lexical token.\n+     */\n+    public STToken nextToken() {\n+        STToken token;\n+        processLeadingTrivia();\n+        token = readToken();\n+\n+        // Can we improve this logic by creating the token with diagnostics then and there?\n+        return cloneWithDiagnostics(token);\n+    }\n+\n+    /*\n+     * Private Methods\n+     */\n+\n+    private STToken readToken() {\n+        reader.mark();\n+        if (reader.isEOF()) {\n+            return getSyntaxToken(SyntaxKind.EOF_TOKEN);\n+        }\n+\n+        int c = reader.peek();\n+        reader.advance();\n+        STToken token;\n+        switch (c) {\n+            // Separators\n+            case LexerTerminals.OPEN_BRACKET:\n+                token = processOpenBracket();\n+                break;\n+            case LexerTerminals.CLOSE_BRACKET:\n+                token = processCloseBracket();\n+                break;\n+            case LexerTerminals.DOUBLE_QUOTE:\n+                if (this.reader.peek() == LexerTerminals.DOUBLE_QUOTE &&", "originalCommit": "d22c104ddce808398b620b31dae4565957a26240", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgyMzI5MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r495823291", "bodyText": "Same as above", "author": "SupunS", "createdAt": "2020-09-28T09:56:36Z", "path": "misc/toml-parser/src/main/java/internal/parser/TomlLexer.java", "diffHunk": "@@ -0,0 +1,744 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package internal.parser;\n+\n+import internal.diagnostics.DiagnosticErrorCode;\n+import internal.parser.tree.STNode;\n+import internal.parser.tree.STNodeFactory;\n+import internal.parser.tree.STToken;\n+import io.ballerina.tools.text.CharReader;\n+import syntax.tree.SyntaxKind;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * A LL(k) lexer for TOML.\n+ *\n+ * @since 1.2.0\n+ */\n+public class TomlLexer extends AbstractLexer {\n+\n+    public TomlLexer(CharReader charReader) {\n+        super(charReader, ParserMode.DEFAULT);\n+    }\n+\n+    /**\n+     * Get the next lexical token.\n+     *\n+     * @return Next lexical token.\n+     */\n+    public STToken nextToken() {\n+        STToken token;\n+        processLeadingTrivia();\n+        token = readToken();\n+\n+        // Can we improve this logic by creating the token with diagnostics then and there?\n+        return cloneWithDiagnostics(token);\n+    }\n+\n+    /*\n+     * Private Methods\n+     */\n+\n+    private STToken readToken() {\n+        reader.mark();\n+        if (reader.isEOF()) {\n+            return getSyntaxToken(SyntaxKind.EOF_TOKEN);\n+        }\n+\n+        int c = reader.peek();\n+        reader.advance();\n+        STToken token;\n+        switch (c) {\n+            // Separators\n+            case LexerTerminals.OPEN_BRACKET:\n+                token = processOpenBracket();\n+                break;\n+            case LexerTerminals.CLOSE_BRACKET:\n+                token = processCloseBracket();\n+                break;\n+            case LexerTerminals.DOUBLE_QUOTE:\n+                if (this.reader.peek() == LexerTerminals.DOUBLE_QUOTE &&\n+                        this.reader.peek(1) == LexerTerminals.DOUBLE_QUOTE) {\n+                    this.reader.advance(2);\n+                    token = processMultilineString(LexerTerminals.DOUBLE_QUOTE);\n+                } else {\n+                    token = processString(LexerTerminals.DOUBLE_QUOTE);\n+                }\n+                break;\n+            case LexerTerminals.SINGLE_QUOTE:\n+                if (this.reader.peek() == LexerTerminals.SINGLE_QUOTE &&", "originalCommit": "d22c104ddce808398b620b31dae4565957a26240", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg1MDMzMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r495850332", "bodyText": "I think we can remove this block", "author": "SupunS", "createdAt": "2020-09-28T10:48:18Z", "path": "misc/toml-parser/src/main/java/internal/parser/TomlLexer.java", "diffHunk": "@@ -0,0 +1,744 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package internal.parser;\n+\n+import internal.diagnostics.DiagnosticErrorCode;\n+import internal.parser.tree.STNode;\n+import internal.parser.tree.STNodeFactory;\n+import internal.parser.tree.STToken;\n+import io.ballerina.tools.text.CharReader;\n+import syntax.tree.SyntaxKind;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * A LL(k) lexer for TOML.\n+ *\n+ * @since 1.2.0\n+ */\n+public class TomlLexer extends AbstractLexer {\n+\n+    public TomlLexer(CharReader charReader) {\n+        super(charReader, ParserMode.DEFAULT);\n+    }\n+\n+    /**\n+     * Get the next lexical token.\n+     *\n+     * @return Next lexical token.\n+     */\n+    public STToken nextToken() {\n+        STToken token;\n+        processLeadingTrivia();\n+        token = readToken();\n+\n+        // Can we improve this logic by creating the token with diagnostics then and there?\n+        return cloneWithDiagnostics(token);\n+    }\n+\n+    /*\n+     * Private Methods\n+     */\n+\n+    private STToken readToken() {\n+        reader.mark();\n+        if (reader.isEOF()) {\n+            return getSyntaxToken(SyntaxKind.EOF_TOKEN);\n+        }\n+\n+        int c = reader.peek();\n+        reader.advance();\n+        STToken token;\n+        switch (c) {\n+            // Separators\n+            case LexerTerminals.OPEN_BRACKET:\n+                token = processOpenBracket();\n+                break;\n+            case LexerTerminals.CLOSE_BRACKET:\n+                token = processCloseBracket();\n+                break;\n+            case LexerTerminals.DOUBLE_QUOTE:\n+                if (this.reader.peek() == LexerTerminals.DOUBLE_QUOTE &&\n+                        this.reader.peek(1) == LexerTerminals.DOUBLE_QUOTE) {\n+                    this.reader.advance(2);\n+                    token = processMultilineString(LexerTerminals.DOUBLE_QUOTE);\n+                } else {\n+                    token = processString(LexerTerminals.DOUBLE_QUOTE);\n+                }\n+                break;\n+            case LexerTerminals.SINGLE_QUOTE:\n+                if (this.reader.peek() == LexerTerminals.SINGLE_QUOTE &&\n+                        this.reader.peek(1) == LexerTerminals.SINGLE_QUOTE) {\n+                    this.reader.advance(2);\n+                    token = processMultilineString(LexerTerminals.SINGLE_QUOTE);\n+                } else {\n+                    token = processString(LexerTerminals.SINGLE_QUOTE);\n+                }\n+                break;\n+            // Arithmetic operators\n+            case LexerTerminals.EQUAL:\n+                token = getSyntaxToken(SyntaxKind.EQUAL_TOKEN);\n+                break;\n+            case LexerTerminals.COMMA:\n+                token = getSyntaxToken(SyntaxKind.COMMA_TOKEN);\n+                break;\n+\n+            // Numbers\n+            case '0':\n+            case '1':\n+            case '2':\n+            case '3':\n+            case '4':\n+            case '5':\n+            case '6':\n+            case '7':\n+            case '8':\n+            case '9':\n+\n+            case '+':\n+            case '-':\n+                token = processNumericLiteral(c);\n+                break;\n+\n+            case 'A':\n+            case 'B':\n+            case 'C':\n+            case 'D':\n+            case 'E':\n+            case 'F':\n+            case 'G':\n+            case 'H':\n+            case 'I':\n+            case 'J':\n+            case 'K':\n+            case 'L':\n+            case 'M':\n+            case 'N':\n+            case 'O':\n+            case 'P':\n+            case 'Q':\n+            case 'R':\n+            case 'S':\n+            case 'T':\n+            case 'U':\n+            case 'V':\n+            case 'W':\n+            case 'X':\n+            case 'Y':\n+            case 'Z':\n+            case 'a':\n+            case 'b':\n+            case 'c':\n+            case 'd':\n+            case 'e':\n+            case 'f':\n+            case 'g':\n+            case 'h':\n+            case 'i':\n+            case 'j':\n+            case 'k':\n+            case 'l':\n+            case 'm':\n+            case 'n':\n+            case 'o':\n+            case 'p':\n+            case 'q':\n+            case 'r':\n+            case 's':\n+            case 't':\n+            case 'u':\n+            case 'v':\n+            case 'w':\n+            case 'x':\n+            case 'y':\n+            case 'z':\n+            case '_':\n+                token = processKey();\n+                break;\n+\n+            // Other\n+            default:\n+                // Process invalid token as trivia, and continue to next token\n+                processInvalidToken();\n+\n+                // Use the internal method to use the already captured trivia.\n+                token = readToken();\n+                break;\n+        }\n+\n+        return token;\n+    }\n+\n+    private STToken processOpenBracket() {\n+        int nextChar = peek();\n+        if (nextChar == LexerTerminals.OPEN_BRACKET) {\n+            reader.advance();\n+            return getSyntaxToken(SyntaxKind.DOUBLE_OPEN_BRACKET_TOKEN);\n+        }\n+        return getSyntaxToken(SyntaxKind.OPEN_BRACKET_TOKEN);\n+    }\n+\n+    private STToken processCloseBracket() {\n+        int nextChar = peek();\n+        if (nextChar == LexerTerminals.CLOSE_BRACKET) {\n+            reader.advance();\n+            return getSyntaxToken(SyntaxKind.DOUBLE_CLOSE_BRACKET_TOKEN);\n+        }\n+        return getSyntaxToken(SyntaxKind.CLOSE_BRACKET_TOKEN);\n+    }\n+\n+    private STToken getSyntaxToken(SyntaxKind kind) {\n+        STNode leadingTrivia = STNodeFactory.createNodeList(this.leadingTriviaList);\n+        STNode trailingTrivia = processTrailingTrivia();\n+        return STNodeFactory.createToken(kind, leadingTrivia, trailingTrivia);\n+    }\n+\n+    private STToken getUnquotedKey() {\n+        STNode leadingTrivia = STNodeFactory.createNodeList(this.leadingTriviaList);\n+        String lexeme = getLexeme();\n+        STNode trailingTrivia = processTrailingTrivia();\n+        return STNodeFactory.createIdentifierToken(lexeme, leadingTrivia, trailingTrivia);\n+    }\n+\n+    private STToken getLiteral(SyntaxKind kind) {\n+        STNode leadingTrivia = STNodeFactory.createNodeList(this.leadingTriviaList);\n+        String lexeme = getLexeme();\n+        STNode trailingTrivia = processTrailingTrivia();\n+        return STNodeFactory.createLiteralValueToken(kind, lexeme, leadingTrivia, trailingTrivia);\n+    }\n+\n+    /**\n+     * Process leading trivia.\n+     */\n+    private void processLeadingTrivia() {\n+        this.leadingTriviaList = new ArrayList<>(10);\n+        processSyntaxTrivia(this.leadingTriviaList, true);\n+    }\n+\n+    /**\n+     * Process and return trailing trivia.\n+     *\n+     * @return Trailing trivia\n+     */\n+    private STNode processTrailingTrivia() {\n+        List<STNode> triviaList = new ArrayList<>(10);\n+        processSyntaxTrivia(triviaList, false);\n+        return STNodeFactory.createNodeList(triviaList);\n+    }\n+\n+    /**\n+     * Process syntax trivia and add it to the provided list.\n+     * <p>\n+     * <code>syntax-trivia := whitespace | end-of-line | comments</code>\n+     *\n+     * @param triviaList List of trivia\n+     * @param isLeading  Flag indicating whether the currently processing leading trivia or not\n+     */\n+    private void processSyntaxTrivia(List<STNode> triviaList, boolean isLeading) {\n+        while (!reader.isEOF()) {\n+            reader.mark();\n+            char c = reader.peek();\n+            switch (c) {\n+                case LexerTerminals.SPACE:\n+                case LexerTerminals.TAB:\n+                case LexerTerminals.FORM_FEED:\n+                    triviaList.add(processWhitespaces());\n+                    break;\n+                case LexerTerminals.CARRIAGE_RETURN:\n+                case LexerTerminals.NEWLINE:\n+                    triviaList.add(processEndOfLine());\n+                    if (isLeading) {\n+                        break;\n+                    }\n+                    return;\n+                case LexerTerminals.HASH:\n+                    triviaList.add(processComment());\n+                    break;\n+                default:\n+                    return;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Process whitespace up to an end of line.\n+     * <p>\n+     * <code>whitespace := 0x9 | 0xC | 0x20</code>\n+     *\n+     * @return Whitespace trivia\n+     */\n+    private STNode processWhitespaces() {\n+        while (!reader.isEOF()) {\n+            char c = reader.peek();\n+            switch (c) {\n+                case LexerTerminals.SPACE:\n+                case LexerTerminals.TAB:\n+                case LexerTerminals.FORM_FEED:\n+                    reader.advance();\n+                    continue;\n+                case LexerTerminals.CARRIAGE_RETURN:\n+                case LexerTerminals.NEWLINE:\n+                    break;\n+                default:\n+                    break;\n+            }\n+            break;\n+        }\n+\n+        return STNodeFactory.createMinutiae(SyntaxKind.WHITESPACE_MINUTIAE, getLexeme());\n+    }\n+\n+    /**\n+     * Process end of line.\n+     * <p>\n+     * <code>end-of-line := 0xA | 0xD</code>\n+     *\n+     * @return End of line trivia\n+     */\n+    private STNode processEndOfLine() {\n+        char c = reader.peek();\n+        switch (c) {\n+            case LexerTerminals.NEWLINE:\n+                reader.advance();\n+                return STNodeFactory.createMinutiae(SyntaxKind.END_OF_LINE_MINUTIAE, getLexeme());\n+            case LexerTerminals.CARRIAGE_RETURN:\n+                reader.advance();\n+                if (reader.peek() == LexerTerminals.NEWLINE) {\n+                    reader.advance();\n+                }\n+                return STNodeFactory.createMinutiae(SyntaxKind.END_OF_LINE_MINUTIAE, getLexeme());\n+            default:\n+                throw new IllegalStateException();\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Process a comment, and add it to trivia list.\n+     * </p>\n+     * <code>\n+     * Comment := // AnyCharButNewline*\n+     * <br/><br/>\n+     * AnyCharButNewline := ^ 0xA\n+     * </code>\n+     */\n+    private STNode processComment() {\n+        // We reach here after verifying up to 2 code-points ahead. Hence advance(2).\n+        reader.advance(2);\n+        int nextToken = peek();\n+        while (!reader.isEOF()) {\n+            switch (nextToken) {\n+                case LexerTerminals.NEWLINE:\n+                case LexerTerminals.CARRIAGE_RETURN:\n+                    break;\n+                default:\n+                    reader.advance();\n+                    nextToken = peek();\n+                    continue;\n+            }\n+            break;\n+        }\n+\n+        return STNodeFactory.createMinutiae(SyntaxKind.COMMENT_MINUTIAE, getLexeme());\n+    }\n+\n+    /**\n+     * <p>\n+     * Process and returns a numeric literal.\n+     * </p>\n+     * <code>\n+     * numeric-literal := int-literal | floating-point-literal\n+     * <br/>\n+     * floating-point-literal := DecimalFloatingPointNumber | HexFloatingPointLiteral\n+     * <br/>\n+     * int-literal := DecimalNumber | HexIntLiteral\n+     * <br/>\n+     * DecimalNumber := 0 | NonZeroDigit Digit*\n+     * <br/>\n+     * Digit := 0 .. 9\n+     * <br/>\n+     * NonZeroDigit := 1 .. 9\n+     * </code>\n+     *\n+     * @return The numeric literal.\n+     */\n+    private STToken processNumericLiteral(int startChar) {\n+        int nextChar = peek();\n+        if (nextChar == '+' || nextChar == '-') {\n+            reader.advance();\n+            nextChar = peek();\n+        }\n+\n+        int len = 1;\n+        SyntaxKind type = SyntaxKind.DEC_INT;\n+        boolean isString = false;\n+        while (!reader.isEOF()) {\n+            if (isDigit(nextChar) || nextChar == '.' || nextChar == '_') {\n+                if (nextChar == '.') {\n+                    type = SyntaxKind.FLOAT;\n+                }\n+                reader.advance();\n+                len++;\n+                nextChar = peek();\n+                continue;\n+            } else if (Character.isLetter(nextChar)) {\n+                isString = true;\n+            }\n+            break;\n+        }\n+        if (isString) {\n+            type = SyntaxKind.UNQUOTED_KEY_TOKEN; //TODO change to identiifer\n+        }\n+        // Integer cannot have a leading zero\n+        if (startChar == '0' && len > 1) {\n+            reportLexerError(DiagnosticErrorCode.ERROR_LEADING_ZEROS_IN_NUMERIC_LITERALS);\n+        }\n+\n+        return getLiteral(type);\n+    }\n+\n+    /**\n+     * Process and returns an identifier or a keyword.\n+     *\n+     * @return An identifier or a keyword.\n+     */\n+    private STToken processKey() {\n+        while (isIdentifierFollowingChar(peek())) {\n+            reader.advance();\n+        }\n+\n+        String tokenText = getLexeme();\n+        switch (tokenText) {\n+            case LexerTerminals.TRUE:\n+            case LexerTerminals.FALSE:\n+                return getLiteral(SyntaxKind.BOOLEAN);\n+            case LexerTerminals.INF:\n+            case LexerTerminals.NAN:\n+                return getLiteral(SyntaxKind.FLOAT);\n+            default:\n+                return getUnquotedKey();\n+        }\n+    }\n+\n+    /**\n+     * Process and returns an invalid token. Consumes the input until {@link #isEndOfInvalidToken()}\n+     * is reached.\n+     */\n+    private void processInvalidToken() {\n+        while (!isEndOfInvalidToken()) {\n+            reader.advance();\n+        }\n+\n+        String tokenText = getLexeme();\n+        STNode invalidToken = STNodeFactory.createInvalidToken(tokenText);\n+        STNode invalidNodeMinutiae = STNodeFactory.createInvalidNodeMinutiae(invalidToken);\n+        this.leadingTriviaList.add(invalidNodeMinutiae);\n+    }\n+\n+    /**\n+     * Check whether the current index is pointing to an end of an invalid lexer-token.\n+     * An invalid token is considered to end if one of the below is reached:\n+     * <ul>\n+     * <li>a whitespace</li>\n+     * <li>semicolon</li>\n+     * <li>newline</li>\n+     * </ul>\n+     *\n+     * @return <code>true</code>, if the end of an invalid token is reached, <code>false</code> otherwise\n+     */\n+    private boolean isEndOfInvalidToken() {\n+        if (reader.isEOF()) {\n+            return true;\n+        }\n+\n+        int currentChar = peek();\n+        switch (currentChar) {\n+            case LexerTerminals.NEWLINE:\n+            case LexerTerminals.CARRIAGE_RETURN:\n+            case LexerTerminals.SPACE:\n+            case LexerTerminals.TAB:\n+            case LexerTerminals.SEMICOLON:\n+            case LexerTerminals.OPEN_BRACE:\n+            case LexerTerminals.CLOSE_BRACE:\n+            case LexerTerminals.OPEN_BRACKET:\n+            case LexerTerminals.CLOSE_BRACKET:\n+            case LexerTerminals.OPEN_PARANTHESIS:\n+            case LexerTerminals.CLOSE_PARANTHESIS:\n+                // TODO: add all separators (braces, parentheses, etc)\n+                // TODO: add all operators (arithmetic, binary, etc)\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Check whether a given char is an identifier start char.\n+     * </p>\n+     * <code>IdentifierInitialChar := A .. Z | a .. z | _ | UnicodeIdentifierChar</code>\n+     *\n+     * @param c character to check\n+     * @return <code>true</code>, if the character is an identifier start char. <code>false</code> otherwise.\n+     */\n+    private boolean isIdentifierInitialChar(int c) {\n+        // TODO: pre-mark all possible characters, using a mask. And use that mask here to check\n+        if ('A' <= c && c <= 'Z') {\n+            return true;\n+        }\n+\n+        if ('a' <= c && c <= 'z') {\n+            return true;\n+        }\n+\n+        if (c == '_' || c == '.' || c == '-') {\n+            return true;\n+        }\n+\n+        // TODO: if (UnicodeIdentifierChar) return false;\n+        return false;\n+    }\n+\n+    /**\n+     * <p>\n+     * Check whether a given char is an identifier following char.\n+     * </p>\n+     * <code>IdentifierFollowingChar := IdentifierInitialChar | Digit</code>\n+     *\n+     * @param c character to check\n+     * @return <code>true</code>, if the character is an identifier following char. <code>false</code> otherwise.\n+     */\n+    private boolean isIdentifierFollowingChar(int c) {\n+        return isIdentifierInitialChar(c) || isDigit(c);\n+    }\n+\n+    /**\n+     * <p>\n+     * Check whether a given char is a digit.\n+     * </p>\n+     * <code>Digit := 0..9</code>\n+     *\n+     * @param c character to check\n+     * @return <code>true</code>, if the character represents a digit. <code>false</code> otherwise.\n+     */\n+    static boolean isDigit(int c) {\n+        return ('0' <= c && c <= '9');\n+    }\n+\n+    /**\n+     * <p>\n+     * Check whether a given char is a hexa digit.\n+     * </p>\n+     * <code>HexDigit := Digit | a .. f | A .. F</code>\n+     *\n+     * @param c character to check\n+     * @return <code>true</code>, if the character represents a hex digit. <code>false</code> otherwise.\n+     */\n+    static boolean isHexDigit(int c) {\n+        if ('a' <= c && c <= 'f') {\n+            return true;\n+        }\n+        if ('A' <= c && c <= 'F') {\n+            return true;\n+        }\n+        return isDigit(c);\n+    }\n+\n+    /**\n+     * <p>\n+     * Check whether current input index points to a start of a hex-numeric literal.\n+     * </p>\n+     * <code>HexIndicator := 0x | 0X</code>\n+     *\n+     * @param startChar Starting character of the literal\n+     * @param nextChar  Second character of the literal\n+     * @return <code>true</code>, if the current input points to a start of a hex-numeric literal.\n+     * <code>false</code> otherwise.\n+     */\n+    private boolean isHexIndicator(int startChar, int nextChar) {\n+        return startChar == '0' && (nextChar == 'x' || nextChar == 'X');\n+    }\n+\n+    /**\n+     * Returns the next character from the reader, without consuming the stream.\n+     *\n+     * @return Next character\n+     */\n+    private int peek() {\n+        return this.reader.peek();\n+    }\n+\n+    /**\n+     * Get the text associated with the current token.\n+     *\n+     * @return Text associated with the current token.\n+     */\n+    private String getLexeme() {\n+        return reader.getMarkedChars();\n+    }\n+\n+    /**\n+     * Process and return double-quoted string literal.\n+     * <p>\n+     * <code>string-literal := DoubleQuotedStringLiteral\n+     * <br/>\n+     * DoubleQuotedStringLiteral := \" (StringChar | StringEscape)* \"\n+     * <br/>\n+     * StringChar := ^ ( 0xA | 0xD | \\ | \" )\n+     * <br/>\n+     * StringEscape := StringSingleEscape | StringNumericEscape\n+     * <br/>\n+     * StringSingleEscape := \\t | \\n | \\r | \\\\ | \\\"\n+     * <br/>\n+     * StringNumericEscape := \\ u{ CodePoint }\n+     * <br/>\n+     * CodePoint := HexDigit+\n+     * </code>\n+     *\n+     * @return String literal token\n+     */\n+    private STToken processString(char type) {\n+\n+        int nextChar;\n+        while (!reader.isEOF()) {\n+            nextChar = peek();\n+            switch (nextChar) {\n+                case LexerTerminals.NEWLINE:\n+                case LexerTerminals.CARRIAGE_RETURN:\n+                    reportLexerError(DiagnosticErrorCode.ERROR_MISSING_DOUBLE_QUOTE);\n+                    break;\n+                case LexerTerminals.BACKSLASH:\n+                    switch (this.reader.peek(1)) {\n+                        case 'n':\n+                        case 't':\n+                        case 'r':\n+                        case LexerTerminals.BACKSLASH:\n+                        case LexerTerminals.DOUBLE_QUOTE:\n+                            this.reader.advance(2);\n+                            continue;\n+                        case 'u':\n+                            if (this.reader.peek(2) == LexerTerminals.OPEN_BRACE) {\n+                                processStringNumericEscape();\n+                            } else {\n+                                reportLexerError(DiagnosticErrorCode.ERROR_INVALID_STRING_NUMERIC_ESCAPE_SEQUENCE);\n+                                this.reader.advance(2);\n+                            }\n+                            continue;", "originalCommit": "d22c104ddce808398b620b31dae4565957a26240", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg1MDU3Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r495850573", "bodyText": "Can remove this", "author": "SupunS", "createdAt": "2020-09-28T10:48:47Z", "path": "misc/toml-parser/src/main/java/internal/parser/TomlLexer.java", "diffHunk": "@@ -0,0 +1,744 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package internal.parser;\n+\n+import internal.diagnostics.DiagnosticErrorCode;\n+import internal.parser.tree.STNode;\n+import internal.parser.tree.STNodeFactory;\n+import internal.parser.tree.STToken;\n+import io.ballerina.tools.text.CharReader;\n+import syntax.tree.SyntaxKind;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * A LL(k) lexer for TOML.\n+ *\n+ * @since 1.2.0\n+ */\n+public class TomlLexer extends AbstractLexer {\n+\n+    public TomlLexer(CharReader charReader) {\n+        super(charReader, ParserMode.DEFAULT);\n+    }\n+\n+    /**\n+     * Get the next lexical token.\n+     *\n+     * @return Next lexical token.\n+     */\n+    public STToken nextToken() {\n+        STToken token;\n+        processLeadingTrivia();\n+        token = readToken();\n+\n+        // Can we improve this logic by creating the token with diagnostics then and there?\n+        return cloneWithDiagnostics(token);\n+    }\n+\n+    /*\n+     * Private Methods\n+     */\n+\n+    private STToken readToken() {\n+        reader.mark();\n+        if (reader.isEOF()) {\n+            return getSyntaxToken(SyntaxKind.EOF_TOKEN);\n+        }\n+\n+        int c = reader.peek();\n+        reader.advance();\n+        STToken token;\n+        switch (c) {\n+            // Separators\n+            case LexerTerminals.OPEN_BRACKET:\n+                token = processOpenBracket();\n+                break;\n+            case LexerTerminals.CLOSE_BRACKET:\n+                token = processCloseBracket();\n+                break;\n+            case LexerTerminals.DOUBLE_QUOTE:\n+                if (this.reader.peek() == LexerTerminals.DOUBLE_QUOTE &&\n+                        this.reader.peek(1) == LexerTerminals.DOUBLE_QUOTE) {\n+                    this.reader.advance(2);\n+                    token = processMultilineString(LexerTerminals.DOUBLE_QUOTE);\n+                } else {\n+                    token = processString(LexerTerminals.DOUBLE_QUOTE);\n+                }\n+                break;\n+            case LexerTerminals.SINGLE_QUOTE:\n+                if (this.reader.peek() == LexerTerminals.SINGLE_QUOTE &&\n+                        this.reader.peek(1) == LexerTerminals.SINGLE_QUOTE) {\n+                    this.reader.advance(2);\n+                    token = processMultilineString(LexerTerminals.SINGLE_QUOTE);\n+                } else {\n+                    token = processString(LexerTerminals.SINGLE_QUOTE);\n+                }\n+                break;\n+            // Arithmetic operators\n+            case LexerTerminals.EQUAL:\n+                token = getSyntaxToken(SyntaxKind.EQUAL_TOKEN);\n+                break;\n+            case LexerTerminals.COMMA:\n+                token = getSyntaxToken(SyntaxKind.COMMA_TOKEN);\n+                break;\n+\n+            // Numbers\n+            case '0':\n+            case '1':\n+            case '2':\n+            case '3':\n+            case '4':\n+            case '5':\n+            case '6':\n+            case '7':\n+            case '8':\n+            case '9':\n+\n+            case '+':\n+            case '-':\n+                token = processNumericLiteral(c);\n+                break;\n+\n+            case 'A':\n+            case 'B':\n+            case 'C':\n+            case 'D':\n+            case 'E':\n+            case 'F':\n+            case 'G':\n+            case 'H':\n+            case 'I':\n+            case 'J':\n+            case 'K':\n+            case 'L':\n+            case 'M':\n+            case 'N':\n+            case 'O':\n+            case 'P':\n+            case 'Q':\n+            case 'R':\n+            case 'S':\n+            case 'T':\n+            case 'U':\n+            case 'V':\n+            case 'W':\n+            case 'X':\n+            case 'Y':\n+            case 'Z':\n+            case 'a':\n+            case 'b':\n+            case 'c':\n+            case 'd':\n+            case 'e':\n+            case 'f':\n+            case 'g':\n+            case 'h':\n+            case 'i':\n+            case 'j':\n+            case 'k':\n+            case 'l':\n+            case 'm':\n+            case 'n':\n+            case 'o':\n+            case 'p':\n+            case 'q':\n+            case 'r':\n+            case 's':\n+            case 't':\n+            case 'u':\n+            case 'v':\n+            case 'w':\n+            case 'x':\n+            case 'y':\n+            case 'z':\n+            case '_':\n+                token = processKey();\n+                break;\n+\n+            // Other\n+            default:\n+                // Process invalid token as trivia, and continue to next token\n+                processInvalidToken();\n+\n+                // Use the internal method to use the already captured trivia.\n+                token = readToken();\n+                break;\n+        }\n+\n+        return token;\n+    }\n+\n+    private STToken processOpenBracket() {\n+        int nextChar = peek();\n+        if (nextChar == LexerTerminals.OPEN_BRACKET) {\n+            reader.advance();\n+            return getSyntaxToken(SyntaxKind.DOUBLE_OPEN_BRACKET_TOKEN);\n+        }\n+        return getSyntaxToken(SyntaxKind.OPEN_BRACKET_TOKEN);\n+    }\n+\n+    private STToken processCloseBracket() {\n+        int nextChar = peek();\n+        if (nextChar == LexerTerminals.CLOSE_BRACKET) {\n+            reader.advance();\n+            return getSyntaxToken(SyntaxKind.DOUBLE_CLOSE_BRACKET_TOKEN);\n+        }\n+        return getSyntaxToken(SyntaxKind.CLOSE_BRACKET_TOKEN);\n+    }\n+\n+    private STToken getSyntaxToken(SyntaxKind kind) {\n+        STNode leadingTrivia = STNodeFactory.createNodeList(this.leadingTriviaList);\n+        STNode trailingTrivia = processTrailingTrivia();\n+        return STNodeFactory.createToken(kind, leadingTrivia, trailingTrivia);\n+    }\n+\n+    private STToken getUnquotedKey() {\n+        STNode leadingTrivia = STNodeFactory.createNodeList(this.leadingTriviaList);\n+        String lexeme = getLexeme();\n+        STNode trailingTrivia = processTrailingTrivia();\n+        return STNodeFactory.createIdentifierToken(lexeme, leadingTrivia, trailingTrivia);\n+    }\n+\n+    private STToken getLiteral(SyntaxKind kind) {\n+        STNode leadingTrivia = STNodeFactory.createNodeList(this.leadingTriviaList);\n+        String lexeme = getLexeme();\n+        STNode trailingTrivia = processTrailingTrivia();\n+        return STNodeFactory.createLiteralValueToken(kind, lexeme, leadingTrivia, trailingTrivia);\n+    }\n+\n+    /**\n+     * Process leading trivia.\n+     */\n+    private void processLeadingTrivia() {\n+        this.leadingTriviaList = new ArrayList<>(10);\n+        processSyntaxTrivia(this.leadingTriviaList, true);\n+    }\n+\n+    /**\n+     * Process and return trailing trivia.\n+     *\n+     * @return Trailing trivia\n+     */\n+    private STNode processTrailingTrivia() {\n+        List<STNode> triviaList = new ArrayList<>(10);\n+        processSyntaxTrivia(triviaList, false);\n+        return STNodeFactory.createNodeList(triviaList);\n+    }\n+\n+    /**\n+     * Process syntax trivia and add it to the provided list.\n+     * <p>\n+     * <code>syntax-trivia := whitespace | end-of-line | comments</code>\n+     *\n+     * @param triviaList List of trivia\n+     * @param isLeading  Flag indicating whether the currently processing leading trivia or not\n+     */\n+    private void processSyntaxTrivia(List<STNode> triviaList, boolean isLeading) {\n+        while (!reader.isEOF()) {\n+            reader.mark();\n+            char c = reader.peek();\n+            switch (c) {\n+                case LexerTerminals.SPACE:\n+                case LexerTerminals.TAB:\n+                case LexerTerminals.FORM_FEED:\n+                    triviaList.add(processWhitespaces());\n+                    break;\n+                case LexerTerminals.CARRIAGE_RETURN:\n+                case LexerTerminals.NEWLINE:\n+                    triviaList.add(processEndOfLine());\n+                    if (isLeading) {\n+                        break;\n+                    }\n+                    return;\n+                case LexerTerminals.HASH:\n+                    triviaList.add(processComment());\n+                    break;\n+                default:\n+                    return;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Process whitespace up to an end of line.\n+     * <p>\n+     * <code>whitespace := 0x9 | 0xC | 0x20</code>\n+     *\n+     * @return Whitespace trivia\n+     */\n+    private STNode processWhitespaces() {\n+        while (!reader.isEOF()) {\n+            char c = reader.peek();\n+            switch (c) {\n+                case LexerTerminals.SPACE:\n+                case LexerTerminals.TAB:\n+                case LexerTerminals.FORM_FEED:\n+                    reader.advance();\n+                    continue;\n+                case LexerTerminals.CARRIAGE_RETURN:\n+                case LexerTerminals.NEWLINE:\n+                    break;\n+                default:\n+                    break;\n+            }\n+            break;\n+        }\n+\n+        return STNodeFactory.createMinutiae(SyntaxKind.WHITESPACE_MINUTIAE, getLexeme());\n+    }\n+\n+    /**\n+     * Process end of line.\n+     * <p>\n+     * <code>end-of-line := 0xA | 0xD</code>\n+     *\n+     * @return End of line trivia\n+     */\n+    private STNode processEndOfLine() {\n+        char c = reader.peek();\n+        switch (c) {\n+            case LexerTerminals.NEWLINE:\n+                reader.advance();\n+                return STNodeFactory.createMinutiae(SyntaxKind.END_OF_LINE_MINUTIAE, getLexeme());\n+            case LexerTerminals.CARRIAGE_RETURN:\n+                reader.advance();\n+                if (reader.peek() == LexerTerminals.NEWLINE) {\n+                    reader.advance();\n+                }\n+                return STNodeFactory.createMinutiae(SyntaxKind.END_OF_LINE_MINUTIAE, getLexeme());\n+            default:\n+                throw new IllegalStateException();\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Process a comment, and add it to trivia list.\n+     * </p>\n+     * <code>\n+     * Comment := // AnyCharButNewline*\n+     * <br/><br/>\n+     * AnyCharButNewline := ^ 0xA\n+     * </code>\n+     */\n+    private STNode processComment() {\n+        // We reach here after verifying up to 2 code-points ahead. Hence advance(2).\n+        reader.advance(2);\n+        int nextToken = peek();\n+        while (!reader.isEOF()) {\n+            switch (nextToken) {\n+                case LexerTerminals.NEWLINE:\n+                case LexerTerminals.CARRIAGE_RETURN:\n+                    break;\n+                default:\n+                    reader.advance();\n+                    nextToken = peek();\n+                    continue;\n+            }\n+            break;\n+        }\n+\n+        return STNodeFactory.createMinutiae(SyntaxKind.COMMENT_MINUTIAE, getLexeme());\n+    }\n+\n+    /**\n+     * <p>\n+     * Process and returns a numeric literal.\n+     * </p>\n+     * <code>\n+     * numeric-literal := int-literal | floating-point-literal\n+     * <br/>\n+     * floating-point-literal := DecimalFloatingPointNumber | HexFloatingPointLiteral\n+     * <br/>\n+     * int-literal := DecimalNumber | HexIntLiteral\n+     * <br/>\n+     * DecimalNumber := 0 | NonZeroDigit Digit*\n+     * <br/>\n+     * Digit := 0 .. 9\n+     * <br/>\n+     * NonZeroDigit := 1 .. 9\n+     * </code>\n+     *\n+     * @return The numeric literal.\n+     */\n+    private STToken processNumericLiteral(int startChar) {\n+        int nextChar = peek();\n+        if (nextChar == '+' || nextChar == '-') {\n+            reader.advance();\n+            nextChar = peek();\n+        }\n+\n+        int len = 1;\n+        SyntaxKind type = SyntaxKind.DEC_INT;\n+        boolean isString = false;\n+        while (!reader.isEOF()) {\n+            if (isDigit(nextChar) || nextChar == '.' || nextChar == '_') {\n+                if (nextChar == '.') {\n+                    type = SyntaxKind.FLOAT;\n+                }\n+                reader.advance();\n+                len++;\n+                nextChar = peek();\n+                continue;\n+            } else if (Character.isLetter(nextChar)) {\n+                isString = true;\n+            }\n+            break;\n+        }\n+        if (isString) {\n+            type = SyntaxKind.UNQUOTED_KEY_TOKEN; //TODO change to identiifer\n+        }\n+        // Integer cannot have a leading zero\n+        if (startChar == '0' && len > 1) {\n+            reportLexerError(DiagnosticErrorCode.ERROR_LEADING_ZEROS_IN_NUMERIC_LITERALS);\n+        }\n+\n+        return getLiteral(type);\n+    }\n+\n+    /**\n+     * Process and returns an identifier or a keyword.\n+     *\n+     * @return An identifier or a keyword.\n+     */\n+    private STToken processKey() {\n+        while (isIdentifierFollowingChar(peek())) {\n+            reader.advance();\n+        }\n+\n+        String tokenText = getLexeme();\n+        switch (tokenText) {\n+            case LexerTerminals.TRUE:\n+            case LexerTerminals.FALSE:\n+                return getLiteral(SyntaxKind.BOOLEAN);\n+            case LexerTerminals.INF:\n+            case LexerTerminals.NAN:\n+                return getLiteral(SyntaxKind.FLOAT);\n+            default:\n+                return getUnquotedKey();\n+        }\n+    }\n+\n+    /**\n+     * Process and returns an invalid token. Consumes the input until {@link #isEndOfInvalidToken()}\n+     * is reached.\n+     */\n+    private void processInvalidToken() {\n+        while (!isEndOfInvalidToken()) {\n+            reader.advance();\n+        }\n+\n+        String tokenText = getLexeme();\n+        STNode invalidToken = STNodeFactory.createInvalidToken(tokenText);\n+        STNode invalidNodeMinutiae = STNodeFactory.createInvalidNodeMinutiae(invalidToken);\n+        this.leadingTriviaList.add(invalidNodeMinutiae);\n+    }\n+\n+    /**\n+     * Check whether the current index is pointing to an end of an invalid lexer-token.\n+     * An invalid token is considered to end if one of the below is reached:\n+     * <ul>\n+     * <li>a whitespace</li>\n+     * <li>semicolon</li>\n+     * <li>newline</li>\n+     * </ul>\n+     *\n+     * @return <code>true</code>, if the end of an invalid token is reached, <code>false</code> otherwise\n+     */\n+    private boolean isEndOfInvalidToken() {\n+        if (reader.isEOF()) {\n+            return true;\n+        }\n+\n+        int currentChar = peek();\n+        switch (currentChar) {\n+            case LexerTerminals.NEWLINE:\n+            case LexerTerminals.CARRIAGE_RETURN:\n+            case LexerTerminals.SPACE:\n+            case LexerTerminals.TAB:\n+            case LexerTerminals.SEMICOLON:\n+            case LexerTerminals.OPEN_BRACE:\n+            case LexerTerminals.CLOSE_BRACE:\n+            case LexerTerminals.OPEN_BRACKET:\n+            case LexerTerminals.CLOSE_BRACKET:\n+            case LexerTerminals.OPEN_PARANTHESIS:\n+            case LexerTerminals.CLOSE_PARANTHESIS:\n+                // TODO: add all separators (braces, parentheses, etc)\n+                // TODO: add all operators (arithmetic, binary, etc)\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Check whether a given char is an identifier start char.\n+     * </p>\n+     * <code>IdentifierInitialChar := A .. Z | a .. z | _ | UnicodeIdentifierChar</code>\n+     *\n+     * @param c character to check\n+     * @return <code>true</code>, if the character is an identifier start char. <code>false</code> otherwise.\n+     */\n+    private boolean isIdentifierInitialChar(int c) {\n+        // TODO: pre-mark all possible characters, using a mask. And use that mask here to check\n+        if ('A' <= c && c <= 'Z') {\n+            return true;\n+        }\n+\n+        if ('a' <= c && c <= 'z') {\n+            return true;\n+        }\n+\n+        if (c == '_' || c == '.' || c == '-') {\n+            return true;\n+        }\n+\n+        // TODO: if (UnicodeIdentifierChar) return false;\n+        return false;\n+    }\n+\n+    /**\n+     * <p>\n+     * Check whether a given char is an identifier following char.\n+     * </p>\n+     * <code>IdentifierFollowingChar := IdentifierInitialChar | Digit</code>\n+     *\n+     * @param c character to check\n+     * @return <code>true</code>, if the character is an identifier following char. <code>false</code> otherwise.\n+     */\n+    private boolean isIdentifierFollowingChar(int c) {\n+        return isIdentifierInitialChar(c) || isDigit(c);\n+    }\n+\n+    /**\n+     * <p>\n+     * Check whether a given char is a digit.\n+     * </p>\n+     * <code>Digit := 0..9</code>\n+     *\n+     * @param c character to check\n+     * @return <code>true</code>, if the character represents a digit. <code>false</code> otherwise.\n+     */\n+    static boolean isDigit(int c) {\n+        return ('0' <= c && c <= '9');\n+    }\n+\n+    /**\n+     * <p>\n+     * Check whether a given char is a hexa digit.\n+     * </p>\n+     * <code>HexDigit := Digit | a .. f | A .. F</code>\n+     *\n+     * @param c character to check\n+     * @return <code>true</code>, if the character represents a hex digit. <code>false</code> otherwise.\n+     */\n+    static boolean isHexDigit(int c) {\n+        if ('a' <= c && c <= 'f') {\n+            return true;\n+        }\n+        if ('A' <= c && c <= 'F') {\n+            return true;\n+        }\n+        return isDigit(c);\n+    }\n+\n+    /**\n+     * <p>\n+     * Check whether current input index points to a start of a hex-numeric literal.\n+     * </p>\n+     * <code>HexIndicator := 0x | 0X</code>\n+     *\n+     * @param startChar Starting character of the literal\n+     * @param nextChar  Second character of the literal\n+     * @return <code>true</code>, if the current input points to a start of a hex-numeric literal.\n+     * <code>false</code> otherwise.\n+     */\n+    private boolean isHexIndicator(int startChar, int nextChar) {\n+        return startChar == '0' && (nextChar == 'x' || nextChar == 'X');\n+    }\n+\n+    /**\n+     * Returns the next character from the reader, without consuming the stream.\n+     *\n+     * @return Next character\n+     */\n+    private int peek() {\n+        return this.reader.peek();\n+    }\n+\n+    /**\n+     * Get the text associated with the current token.\n+     *\n+     * @return Text associated with the current token.\n+     */\n+    private String getLexeme() {\n+        return reader.getMarkedChars();\n+    }\n+\n+    /**\n+     * Process and return double-quoted string literal.\n+     * <p>\n+     * <code>string-literal := DoubleQuotedStringLiteral\n+     * <br/>\n+     * DoubleQuotedStringLiteral := \" (StringChar | StringEscape)* \"\n+     * <br/>\n+     * StringChar := ^ ( 0xA | 0xD | \\ | \" )\n+     * <br/>\n+     * StringEscape := StringSingleEscape | StringNumericEscape\n+     * <br/>\n+     * StringSingleEscape := \\t | \\n | \\r | \\\\ | \\\"\n+     * <br/>\n+     * StringNumericEscape := \\ u{ CodePoint }\n+     * <br/>\n+     * CodePoint := HexDigit+\n+     * </code>\n+     *\n+     * @return String literal token\n+     */\n+    private STToken processString(char type) {\n+\n+        int nextChar;\n+        while (!reader.isEOF()) {\n+            nextChar = peek();\n+            switch (nextChar) {\n+                case LexerTerminals.NEWLINE:\n+                case LexerTerminals.CARRIAGE_RETURN:\n+                    reportLexerError(DiagnosticErrorCode.ERROR_MISSING_DOUBLE_QUOTE);\n+                    break;\n+                case LexerTerminals.BACKSLASH:\n+                    switch (this.reader.peek(1)) {\n+                        case 'n':\n+                        case 't':\n+                        case 'r':\n+                        case LexerTerminals.BACKSLASH:\n+                        case LexerTerminals.DOUBLE_QUOTE:\n+                            this.reader.advance(2);\n+                            continue;\n+                        case 'u':\n+                            if (this.reader.peek(2) == LexerTerminals.OPEN_BRACE) {\n+                                processStringNumericEscape();\n+                            } else {\n+                                reportLexerError(DiagnosticErrorCode.ERROR_INVALID_STRING_NUMERIC_ESCAPE_SEQUENCE);\n+                                this.reader.advance(2);\n+                            }\n+                            continue;\n+                        default:\n+                            reportLexerError(DiagnosticErrorCode.ERROR_INVALID_ESCAPE_SEQUENCE);\n+                            this.reader.advance();\n+                            continue;\n+                    }\n+                default:\n+                    if (nextChar == type) {\n+                        this.reader.advance();\n+                        break;\n+                    }\n+                    this.reader.advance();\n+                    continue;\n+            }\n+            break;\n+        }\n+\n+        return getLiteral(SyntaxKind.STRING_LITERAL);\n+    }\n+\n+    private STToken processMultilineString(char type) {\n+\n+        int nextChar;\n+        while (!reader.isEOF()) {\n+            nextChar = peek();\n+            switch (nextChar) {\n+                case LexerTerminals.BACKSLASH:\n+                    switch (this.reader.peek(1)) {\n+                        case 'n':\n+                        case 't':\n+                        case 'r':\n+                        case LexerTerminals.BACKSLASH:\n+                        case LexerTerminals.DOUBLE_QUOTE:\n+                            this.reader.advance(2);\n+                            continue;\n+                        case 'u':\n+                            if (this.reader.peek(2) == LexerTerminals.OPEN_BRACE) {\n+                                processStringNumericEscape();\n+                            } else {\n+                                reportLexerError(DiagnosticErrorCode.ERROR_INVALID_STRING_NUMERIC_ESCAPE_SEQUENCE);\n+                                this.reader.advance(2);\n+                            }\n+                            continue;", "originalCommit": "d22c104ddce808398b620b31dae4565957a26240", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg1MTMzNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r495851337", "bodyText": "The method body seems to be parsing only a single table - shall we revisit this function name?", "author": "SupunS", "createdAt": "2020-09-28T10:50:20Z", "path": "misc/toml-parser/src/main/java/internal/parser/TomlParser.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package internal.parser;\n+\n+import internal.parser.tree.STLiteralValueToken;\n+import internal.parser.tree.STNode;\n+import internal.parser.tree.STNodeFactory;\n+import internal.parser.tree.STToken;\n+import syntax.tree.SyntaxKind;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static syntax.tree.SyntaxKind.DOUBLE_OPEN_BRACKET_TOKEN;\n+import static syntax.tree.SyntaxKind.EOF_TOKEN;\n+import static syntax.tree.SyntaxKind.OPEN_BRACKET_TOKEN;\n+\n+/**\n+ * A LL(k) recursive-descent parser for TOML.\n+ *\n+ * @since 1.2.0\n+ */\n+public class TomlParser extends AbstractParser {\n+\n+    public TomlParser(AbstractTokenReader tokenReader) {\n+        super(tokenReader, new TomlParserErrorHandler(tokenReader));\n+    }\n+\n+    /**\n+     * Parse a given input and returns the AST. Starts parsing from the top of a compilation unit.\n+     *\n+     * @return Parsed node\n+     */\n+    @Override\n+    public STNode parse() {\n+        startContext(ParserRuleContext.TOP_LEVEL_NODE);\n+        List<STNode> topLevelNodes = new ArrayList<>();\n+        STToken token = peek();\n+\n+        while (token.kind != SyntaxKind.EOF_TOKEN) {\n+            STNode decl = parseTopLevelNode();\n+            if (decl == null) {\n+                break;\n+            }\n+\n+            topLevelNodes.add(decl);\n+            token = peek();\n+        }\n+\n+        STToken eof = consume();\n+        endContext();\n+\n+        return STNodeFactory.createModulePartNode(\n+                STNodeFactory.createNodeList(topLevelNodes), eof);\n+    }\n+\n+    /**\n+     * Parse top level node given the next token kind and the modifier that precedes it.\n+     *\n+     * @return Parsed top-level node\n+     */\n+    private STNode parseTopLevelNode() {\n+        STToken nextToken = peek();\n+        switch (nextToken.kind) {\n+            case EOF_TOKEN:\n+                return null;\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTable();\n+            case DOUBLE_OPEN_BRACKET_TOKEN:\n+                return parseArrayOfTables();\n+            case UNQUOTED_KEY_TOKEN:\n+            case STRING_LITERAL:\n+            case BOOLEAN:\n+            case DEC_INT:\n+            case FLOAT://todo check +/- ?\n+                return parseKeyValue();\n+            default:\n+                STToken token = peek();\n+                recover(token, ParserRuleContext.TOP_LEVEL_NODE);\n+\n+                return parseTopLevelNode();\n+        }\n+    }\n+\n+    private STNode parseArrayOfTables() {", "originalCommit": "d22c104ddce808398b620b31dae4565957a26240", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzI1MDQ3NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r497250474", "bodyText": "It Parses Array of Table of TOML Spec. [[table]]. It's different from a normal table. [table]", "author": "xlight05", "createdAt": "2020-09-30T05:26:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg1MTMzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg1MzQ4NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r495853484", "bodyText": "Does the toml spec allows whitespace between the two brackets?\nIf thats the case, then the lexer should send the individual bracket as a separate token. The parser should check for the two brackets separately.", "author": "SupunS", "createdAt": "2020-09-28T10:54:45Z", "path": "misc/toml-parser/src/main/java/internal/parser/TomlParser.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package internal.parser;\n+\n+import internal.parser.tree.STLiteralValueToken;\n+import internal.parser.tree.STNode;\n+import internal.parser.tree.STNodeFactory;\n+import internal.parser.tree.STToken;\n+import syntax.tree.SyntaxKind;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static syntax.tree.SyntaxKind.DOUBLE_OPEN_BRACKET_TOKEN;\n+import static syntax.tree.SyntaxKind.EOF_TOKEN;\n+import static syntax.tree.SyntaxKind.OPEN_BRACKET_TOKEN;\n+\n+/**\n+ * A LL(k) recursive-descent parser for TOML.\n+ *\n+ * @since 1.2.0\n+ */\n+public class TomlParser extends AbstractParser {\n+\n+    public TomlParser(AbstractTokenReader tokenReader) {\n+        super(tokenReader, new TomlParserErrorHandler(tokenReader));\n+    }\n+\n+    /**\n+     * Parse a given input and returns the AST. Starts parsing from the top of a compilation unit.\n+     *\n+     * @return Parsed node\n+     */\n+    @Override\n+    public STNode parse() {\n+        startContext(ParserRuleContext.TOP_LEVEL_NODE);\n+        List<STNode> topLevelNodes = new ArrayList<>();\n+        STToken token = peek();\n+\n+        while (token.kind != SyntaxKind.EOF_TOKEN) {\n+            STNode decl = parseTopLevelNode();\n+            if (decl == null) {\n+                break;\n+            }\n+\n+            topLevelNodes.add(decl);\n+            token = peek();\n+        }\n+\n+        STToken eof = consume();\n+        endContext();\n+\n+        return STNodeFactory.createModulePartNode(\n+                STNodeFactory.createNodeList(topLevelNodes), eof);\n+    }\n+\n+    /**\n+     * Parse top level node given the next token kind and the modifier that precedes it.\n+     *\n+     * @return Parsed top-level node\n+     */\n+    private STNode parseTopLevelNode() {\n+        STToken nextToken = peek();\n+        switch (nextToken.kind) {\n+            case EOF_TOKEN:\n+                return null;\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTable();\n+            case DOUBLE_OPEN_BRACKET_TOKEN:\n+                return parseArrayOfTables();\n+            case UNQUOTED_KEY_TOKEN:\n+            case STRING_LITERAL:\n+            case BOOLEAN:\n+            case DEC_INT:\n+            case FLOAT://todo check +/- ?\n+                return parseKeyValue();\n+            default:\n+                STToken token = peek();\n+                recover(token, ParserRuleContext.TOP_LEVEL_NODE);\n+\n+                return parseTopLevelNode();\n+        }\n+    }\n+\n+    private STNode parseArrayOfTables() {\n+        startContext(ParserRuleContext.TOML_TABLE_ARRAY);\n+        STNode openBracket = parseDoubleOpenBracket();\n+        STNode identifierToken = parseKey();\n+        STNode closedBracket = parseDoubleCloseBracket();\n+        List<STNode> fields = parseKeyValues();\n+        endContext();\n+        return STNodeFactory.createTableArrayNode(openBracket,\n+                identifierToken, closedBracket, STNodeFactory.createNodeList(fields));\n+    }\n+\n+    private STNode parseDoubleOpenBracket() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.DOUBLE_OPEN_BRACKET_TOKEN) {\n+            return consume();\n+        } else {\n+            recover(token, ParserRuleContext.DOUBLE_OPEN_BRACKET);\n+            return parseDoubleOpenBracket();\n+        }\n+    }\n+\n+    private STNode parseDoubleCloseBracket() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.DOUBLE_CLOSE_BRACKET_TOKEN) {", "originalCommit": "d22c104ddce808398b620b31dae4565957a26240", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzI1MDU0OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r497250549", "bodyText": "No. it doesn't allow whitespaces.", "author": "xlight05", "createdAt": "2020-09-30T05:26:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg1MzQ4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg1NDIzNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r495854236", "bodyText": "Let's add the related part of the spec as a doc comment. Then it's easy for someone who reads the code to quickly refer the spec then and there.\nBetter to do this for all methods, even if they are just private methods.", "author": "SupunS", "createdAt": "2020-09-28T10:56:18Z", "path": "misc/toml-parser/src/main/java/internal/parser/TomlParser.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package internal.parser;\n+\n+import internal.parser.tree.STLiteralValueToken;\n+import internal.parser.tree.STNode;\n+import internal.parser.tree.STNodeFactory;\n+import internal.parser.tree.STToken;\n+import syntax.tree.SyntaxKind;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static syntax.tree.SyntaxKind.DOUBLE_OPEN_BRACKET_TOKEN;\n+import static syntax.tree.SyntaxKind.EOF_TOKEN;\n+import static syntax.tree.SyntaxKind.OPEN_BRACKET_TOKEN;\n+\n+/**\n+ * A LL(k) recursive-descent parser for TOML.\n+ *\n+ * @since 1.2.0\n+ */\n+public class TomlParser extends AbstractParser {\n+\n+    public TomlParser(AbstractTokenReader tokenReader) {\n+        super(tokenReader, new TomlParserErrorHandler(tokenReader));\n+    }\n+\n+    /**\n+     * Parse a given input and returns the AST. Starts parsing from the top of a compilation unit.\n+     *\n+     * @return Parsed node\n+     */\n+    @Override\n+    public STNode parse() {\n+        startContext(ParserRuleContext.TOP_LEVEL_NODE);\n+        List<STNode> topLevelNodes = new ArrayList<>();\n+        STToken token = peek();\n+\n+        while (token.kind != SyntaxKind.EOF_TOKEN) {\n+            STNode decl = parseTopLevelNode();\n+            if (decl == null) {\n+                break;\n+            }\n+\n+            topLevelNodes.add(decl);\n+            token = peek();\n+        }\n+\n+        STToken eof = consume();\n+        endContext();\n+\n+        return STNodeFactory.createModulePartNode(\n+                STNodeFactory.createNodeList(topLevelNodes), eof);\n+    }\n+\n+    /**\n+     * Parse top level node given the next token kind and the modifier that precedes it.\n+     *\n+     * @return Parsed top-level node\n+     */\n+    private STNode parseTopLevelNode() {\n+        STToken nextToken = peek();\n+        switch (nextToken.kind) {\n+            case EOF_TOKEN:\n+                return null;\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTable();\n+            case DOUBLE_OPEN_BRACKET_TOKEN:\n+                return parseArrayOfTables();\n+            case UNQUOTED_KEY_TOKEN:\n+            case STRING_LITERAL:\n+            case BOOLEAN:\n+            case DEC_INT:\n+            case FLOAT://todo check +/- ?\n+                return parseKeyValue();\n+            default:\n+                STToken token = peek();\n+                recover(token, ParserRuleContext.TOP_LEVEL_NODE);\n+\n+                return parseTopLevelNode();\n+        }\n+    }\n+\n+    private STNode parseArrayOfTables() {\n+        startContext(ParserRuleContext.TOML_TABLE_ARRAY);\n+        STNode openBracket = parseDoubleOpenBracket();\n+        STNode identifierToken = parseKey();\n+        STNode closedBracket = parseDoubleCloseBracket();\n+        List<STNode> fields = parseKeyValues();\n+        endContext();\n+        return STNodeFactory.createTableArrayNode(openBracket,\n+                identifierToken, closedBracket, STNodeFactory.createNodeList(fields));\n+    }\n+\n+    private STNode parseDoubleOpenBracket() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.DOUBLE_OPEN_BRACKET_TOKEN) {\n+            return consume();\n+        } else {\n+            recover(token, ParserRuleContext.DOUBLE_OPEN_BRACKET);\n+            return parseDoubleOpenBracket();\n+        }\n+    }\n+\n+    private STNode parseDoubleCloseBracket() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.DOUBLE_CLOSE_BRACKET_TOKEN) {\n+            return consume();\n+        } else {\n+            recover(token, ParserRuleContext.DOUBLE_CLOSE_BRACKET);\n+            return parseDoubleCloseBracket();\n+        }\n+    }\n+\n+    private STNode parseTable() {", "originalCommit": "d22c104ddce808398b620b31dae4565957a26240", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg1NDc4MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r495854780", "bodyText": "It would be clean to extract the condition to a separate method", "author": "SupunS", "createdAt": "2020-09-28T10:57:25Z", "path": "misc/toml-parser/src/main/java/internal/parser/TomlParser.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package internal.parser;\n+\n+import internal.parser.tree.STLiteralValueToken;\n+import internal.parser.tree.STNode;\n+import internal.parser.tree.STNodeFactory;\n+import internal.parser.tree.STToken;\n+import syntax.tree.SyntaxKind;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static syntax.tree.SyntaxKind.DOUBLE_OPEN_BRACKET_TOKEN;\n+import static syntax.tree.SyntaxKind.EOF_TOKEN;\n+import static syntax.tree.SyntaxKind.OPEN_BRACKET_TOKEN;\n+\n+/**\n+ * A LL(k) recursive-descent parser for TOML.\n+ *\n+ * @since 1.2.0\n+ */\n+public class TomlParser extends AbstractParser {\n+\n+    public TomlParser(AbstractTokenReader tokenReader) {\n+        super(tokenReader, new TomlParserErrorHandler(tokenReader));\n+    }\n+\n+    /**\n+     * Parse a given input and returns the AST. Starts parsing from the top of a compilation unit.\n+     *\n+     * @return Parsed node\n+     */\n+    @Override\n+    public STNode parse() {\n+        startContext(ParserRuleContext.TOP_LEVEL_NODE);\n+        List<STNode> topLevelNodes = new ArrayList<>();\n+        STToken token = peek();\n+\n+        while (token.kind != SyntaxKind.EOF_TOKEN) {\n+            STNode decl = parseTopLevelNode();\n+            if (decl == null) {\n+                break;\n+            }\n+\n+            topLevelNodes.add(decl);\n+            token = peek();\n+        }\n+\n+        STToken eof = consume();\n+        endContext();\n+\n+        return STNodeFactory.createModulePartNode(\n+                STNodeFactory.createNodeList(topLevelNodes), eof);\n+    }\n+\n+    /**\n+     * Parse top level node given the next token kind and the modifier that precedes it.\n+     *\n+     * @return Parsed top-level node\n+     */\n+    private STNode parseTopLevelNode() {\n+        STToken nextToken = peek();\n+        switch (nextToken.kind) {\n+            case EOF_TOKEN:\n+                return null;\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTable();\n+            case DOUBLE_OPEN_BRACKET_TOKEN:\n+                return parseArrayOfTables();\n+            case UNQUOTED_KEY_TOKEN:\n+            case STRING_LITERAL:\n+            case BOOLEAN:\n+            case DEC_INT:\n+            case FLOAT://todo check +/- ?\n+                return parseKeyValue();\n+            default:\n+                STToken token = peek();\n+                recover(token, ParserRuleContext.TOP_LEVEL_NODE);\n+\n+                return parseTopLevelNode();\n+        }\n+    }\n+\n+    private STNode parseArrayOfTables() {\n+        startContext(ParserRuleContext.TOML_TABLE_ARRAY);\n+        STNode openBracket = parseDoubleOpenBracket();\n+        STNode identifierToken = parseKey();\n+        STNode closedBracket = parseDoubleCloseBracket();\n+        List<STNode> fields = parseKeyValues();\n+        endContext();\n+        return STNodeFactory.createTableArrayNode(openBracket,\n+                identifierToken, closedBracket, STNodeFactory.createNodeList(fields));\n+    }\n+\n+    private STNode parseDoubleOpenBracket() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.DOUBLE_OPEN_BRACKET_TOKEN) {\n+            return consume();\n+        } else {\n+            recover(token, ParserRuleContext.DOUBLE_OPEN_BRACKET);\n+            return parseDoubleOpenBracket();\n+        }\n+    }\n+\n+    private STNode parseDoubleCloseBracket() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.DOUBLE_CLOSE_BRACKET_TOKEN) {\n+            return consume();\n+        } else {\n+            recover(token, ParserRuleContext.DOUBLE_CLOSE_BRACKET);\n+            return parseDoubleCloseBracket();\n+        }\n+    }\n+\n+    private STNode parseTable() {\n+        startContext(ParserRuleContext.TOML_TABLE);\n+        STNode openBracket = parseOpenBracket();\n+        STNode identifierToken = parseKey();\n+        STNode closedBracket = parseCloseBracket();\n+        List<STNode> fields = parseKeyValues();\n+        endContext();\n+        return STNodeFactory.createTableNode(openBracket, identifierToken, closedBracket,\n+                STNodeFactory.createNodeList(fields));\n+    }\n+\n+    private List<STNode> parseKeyValues() {\n+        List<STNode> fields = new ArrayList<>();\n+        STToken nextNode = peek();\n+        while (!(nextNode.kind == OPEN_BRACKET_TOKEN || nextNode.kind == DOUBLE_OPEN_BRACKET_TOKEN ||\n+                nextNode.kind == EOF_TOKEN)) {", "originalCommit": "d22c104ddce808398b620b31dae4565957a26240", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg1NTAyMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r495855022", "bodyText": "Additional parenthesis", "author": "SupunS", "createdAt": "2020-09-28T10:57:53Z", "path": "misc/toml-parser/src/main/java/internal/parser/TomlParser.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package internal.parser;\n+\n+import internal.parser.tree.STLiteralValueToken;\n+import internal.parser.tree.STNode;\n+import internal.parser.tree.STNodeFactory;\n+import internal.parser.tree.STToken;\n+import syntax.tree.SyntaxKind;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static syntax.tree.SyntaxKind.DOUBLE_OPEN_BRACKET_TOKEN;\n+import static syntax.tree.SyntaxKind.EOF_TOKEN;\n+import static syntax.tree.SyntaxKind.OPEN_BRACKET_TOKEN;\n+\n+/**\n+ * A LL(k) recursive-descent parser for TOML.\n+ *\n+ * @since 1.2.0\n+ */\n+public class TomlParser extends AbstractParser {\n+\n+    public TomlParser(AbstractTokenReader tokenReader) {\n+        super(tokenReader, new TomlParserErrorHandler(tokenReader));\n+    }\n+\n+    /**\n+     * Parse a given input and returns the AST. Starts parsing from the top of a compilation unit.\n+     *\n+     * @return Parsed node\n+     */\n+    @Override\n+    public STNode parse() {\n+        startContext(ParserRuleContext.TOP_LEVEL_NODE);\n+        List<STNode> topLevelNodes = new ArrayList<>();\n+        STToken token = peek();\n+\n+        while (token.kind != SyntaxKind.EOF_TOKEN) {\n+            STNode decl = parseTopLevelNode();\n+            if (decl == null) {\n+                break;\n+            }\n+\n+            topLevelNodes.add(decl);\n+            token = peek();\n+        }\n+\n+        STToken eof = consume();\n+        endContext();\n+\n+        return STNodeFactory.createModulePartNode(\n+                STNodeFactory.createNodeList(topLevelNodes), eof);\n+    }\n+\n+    /**\n+     * Parse top level node given the next token kind and the modifier that precedes it.\n+     *\n+     * @return Parsed top-level node\n+     */\n+    private STNode parseTopLevelNode() {\n+        STToken nextToken = peek();\n+        switch (nextToken.kind) {\n+            case EOF_TOKEN:\n+                return null;\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTable();\n+            case DOUBLE_OPEN_BRACKET_TOKEN:\n+                return parseArrayOfTables();\n+            case UNQUOTED_KEY_TOKEN:\n+            case STRING_LITERAL:\n+            case BOOLEAN:\n+            case DEC_INT:\n+            case FLOAT://todo check +/- ?\n+                return parseKeyValue();\n+            default:\n+                STToken token = peek();\n+                recover(token, ParserRuleContext.TOP_LEVEL_NODE);\n+\n+                return parseTopLevelNode();\n+        }\n+    }\n+\n+    private STNode parseArrayOfTables() {\n+        startContext(ParserRuleContext.TOML_TABLE_ARRAY);\n+        STNode openBracket = parseDoubleOpenBracket();\n+        STNode identifierToken = parseKey();\n+        STNode closedBracket = parseDoubleCloseBracket();\n+        List<STNode> fields = parseKeyValues();\n+        endContext();\n+        return STNodeFactory.createTableArrayNode(openBracket,\n+                identifierToken, closedBracket, STNodeFactory.createNodeList(fields));\n+    }\n+\n+    private STNode parseDoubleOpenBracket() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.DOUBLE_OPEN_BRACKET_TOKEN) {\n+            return consume();\n+        } else {\n+            recover(token, ParserRuleContext.DOUBLE_OPEN_BRACKET);\n+            return parseDoubleOpenBracket();\n+        }\n+    }\n+\n+    private STNode parseDoubleCloseBracket() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.DOUBLE_CLOSE_BRACKET_TOKEN) {\n+            return consume();\n+        } else {\n+            recover(token, ParserRuleContext.DOUBLE_CLOSE_BRACKET);\n+            return parseDoubleCloseBracket();\n+        }\n+    }\n+\n+    private STNode parseTable() {\n+        startContext(ParserRuleContext.TOML_TABLE);\n+        STNode openBracket = parseOpenBracket();\n+        STNode identifierToken = parseKey();\n+        STNode closedBracket = parseCloseBracket();\n+        List<STNode> fields = parseKeyValues();\n+        endContext();\n+        return STNodeFactory.createTableNode(openBracket, identifierToken, closedBracket,\n+                STNodeFactory.createNodeList(fields));\n+    }\n+\n+    private List<STNode> parseKeyValues() {\n+        List<STNode> fields = new ArrayList<>();\n+        STToken nextNode = peek();\n+        while (!(nextNode.kind == OPEN_BRACKET_TOKEN || nextNode.kind == DOUBLE_OPEN_BRACKET_TOKEN ||\n+                nextNode.kind == EOF_TOKEN)) {\n+            STNode stNode = parseKeyValue();\n+            fields.add(stNode);\n+            nextNode = peek();\n+        }\n+        return fields;\n+    }\n+\n+    private STNode parseOpenBracket() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            return consume();\n+        } else {\n+            recover(token, ParserRuleContext.OPEN_BRACKET);\n+            return parseOpenBracket();\n+        }\n+    }\n+\n+    private STNode parseCloseBracket() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.CLOSE_BRACKET_TOKEN) {\n+            return consume();\n+        } else {\n+            recover(token, ParserRuleContext.CLOSE_BRACKET);\n+            return parseCloseBracket();\n+        }\n+    }\n+\n+    private STNode parseKeyValue() {\n+        startContext(ParserRuleContext.KEY_VALUE_PAIR);\n+        STNode identifier = parseKey();\n+        STNode equals = parseEquals();\n+        STNode value = parseValue();\n+        endContext();\n+        return STNodeFactory.createKeyValue(identifier, equals, value);\n+    }\n+\n+    private STNode parseKey() {\n+        STToken token = peek();\n+        if (isKey(token)) {\n+            return consume();\n+        } else {\n+            recover(token, ParserRuleContext.KEY);\n+            return parseKey();\n+        }\n+    }\n+\n+    public static boolean isKey(STToken token) {\n+        switch (token.kind) {\n+            case UNQUOTED_KEY_TOKEN:\n+            case BOOLEAN:\n+            case STRING_LITERAL:\n+                return true;\n+            default:\n+                return isNumberValidKey(token);\n+        }\n+    }\n+\n+    public static boolean isNumberValidKey(STToken token) {\n+        if (token instanceof STLiteralValueToken) {\n+            if (token.kind == SyntaxKind.DEC_INT ||\n+                    token.kind == SyntaxKind.FLOAT) {\n+                return !(token.text().startsWith(\"+\") || token.text().startsWith(\"-\"));\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private STNode parseEquals() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.EQUAL_TOKEN) {\n+            return consume();\n+        } else {\n+            recover(token, ParserRuleContext.ASSIGN_OP);\n+            return parseEquals();\n+        }\n+    }\n+\n+    private STNode parseValue() {\n+        STToken token = peek();\n+        if (isValue(token)) {\n+            return STNodeFactory.createBasicValueNode(token.kind, consume());\n+//            STToken consume = consume();\n+//            return STNodeFactory.createBasicValueNode(consume.kind,consume);\n+        } else if ((token.kind == OPEN_BRACKET_TOKEN)) {", "originalCommit": "d22c104ddce808398b620b31dae4565957a26240", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg1NTEzNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r495855137", "bodyText": "Remove the commented-out code", "author": "SupunS", "createdAt": "2020-09-28T10:58:11Z", "path": "misc/toml-parser/src/main/java/internal/parser/TomlParser.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package internal.parser;\n+\n+import internal.parser.tree.STLiteralValueToken;\n+import internal.parser.tree.STNode;\n+import internal.parser.tree.STNodeFactory;\n+import internal.parser.tree.STToken;\n+import syntax.tree.SyntaxKind;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static syntax.tree.SyntaxKind.DOUBLE_OPEN_BRACKET_TOKEN;\n+import static syntax.tree.SyntaxKind.EOF_TOKEN;\n+import static syntax.tree.SyntaxKind.OPEN_BRACKET_TOKEN;\n+\n+/**\n+ * A LL(k) recursive-descent parser for TOML.\n+ *\n+ * @since 1.2.0\n+ */\n+public class TomlParser extends AbstractParser {\n+\n+    public TomlParser(AbstractTokenReader tokenReader) {\n+        super(tokenReader, new TomlParserErrorHandler(tokenReader));\n+    }\n+\n+    /**\n+     * Parse a given input and returns the AST. Starts parsing from the top of a compilation unit.\n+     *\n+     * @return Parsed node\n+     */\n+    @Override\n+    public STNode parse() {\n+        startContext(ParserRuleContext.TOP_LEVEL_NODE);\n+        List<STNode> topLevelNodes = new ArrayList<>();\n+        STToken token = peek();\n+\n+        while (token.kind != SyntaxKind.EOF_TOKEN) {\n+            STNode decl = parseTopLevelNode();\n+            if (decl == null) {\n+                break;\n+            }\n+\n+            topLevelNodes.add(decl);\n+            token = peek();\n+        }\n+\n+        STToken eof = consume();\n+        endContext();\n+\n+        return STNodeFactory.createModulePartNode(\n+                STNodeFactory.createNodeList(topLevelNodes), eof);\n+    }\n+\n+    /**\n+     * Parse top level node given the next token kind and the modifier that precedes it.\n+     *\n+     * @return Parsed top-level node\n+     */\n+    private STNode parseTopLevelNode() {\n+        STToken nextToken = peek();\n+        switch (nextToken.kind) {\n+            case EOF_TOKEN:\n+                return null;\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTable();\n+            case DOUBLE_OPEN_BRACKET_TOKEN:\n+                return parseArrayOfTables();\n+            case UNQUOTED_KEY_TOKEN:\n+            case STRING_LITERAL:\n+            case BOOLEAN:\n+            case DEC_INT:\n+            case FLOAT://todo check +/- ?\n+                return parseKeyValue();\n+            default:\n+                STToken token = peek();\n+                recover(token, ParserRuleContext.TOP_LEVEL_NODE);\n+\n+                return parseTopLevelNode();\n+        }\n+    }\n+\n+    private STNode parseArrayOfTables() {\n+        startContext(ParserRuleContext.TOML_TABLE_ARRAY);\n+        STNode openBracket = parseDoubleOpenBracket();\n+        STNode identifierToken = parseKey();\n+        STNode closedBracket = parseDoubleCloseBracket();\n+        List<STNode> fields = parseKeyValues();\n+        endContext();\n+        return STNodeFactory.createTableArrayNode(openBracket,\n+                identifierToken, closedBracket, STNodeFactory.createNodeList(fields));\n+    }\n+\n+    private STNode parseDoubleOpenBracket() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.DOUBLE_OPEN_BRACKET_TOKEN) {\n+            return consume();\n+        } else {\n+            recover(token, ParserRuleContext.DOUBLE_OPEN_BRACKET);\n+            return parseDoubleOpenBracket();\n+        }\n+    }\n+\n+    private STNode parseDoubleCloseBracket() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.DOUBLE_CLOSE_BRACKET_TOKEN) {\n+            return consume();\n+        } else {\n+            recover(token, ParserRuleContext.DOUBLE_CLOSE_BRACKET);\n+            return parseDoubleCloseBracket();\n+        }\n+    }\n+\n+    private STNode parseTable() {\n+        startContext(ParserRuleContext.TOML_TABLE);\n+        STNode openBracket = parseOpenBracket();\n+        STNode identifierToken = parseKey();\n+        STNode closedBracket = parseCloseBracket();\n+        List<STNode> fields = parseKeyValues();\n+        endContext();\n+        return STNodeFactory.createTableNode(openBracket, identifierToken, closedBracket,\n+                STNodeFactory.createNodeList(fields));\n+    }\n+\n+    private List<STNode> parseKeyValues() {\n+        List<STNode> fields = new ArrayList<>();\n+        STToken nextNode = peek();\n+        while (!(nextNode.kind == OPEN_BRACKET_TOKEN || nextNode.kind == DOUBLE_OPEN_BRACKET_TOKEN ||\n+                nextNode.kind == EOF_TOKEN)) {\n+            STNode stNode = parseKeyValue();\n+            fields.add(stNode);\n+            nextNode = peek();\n+        }\n+        return fields;\n+    }\n+\n+    private STNode parseOpenBracket() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            return consume();\n+        } else {\n+            recover(token, ParserRuleContext.OPEN_BRACKET);\n+            return parseOpenBracket();\n+        }\n+    }\n+\n+    private STNode parseCloseBracket() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.CLOSE_BRACKET_TOKEN) {\n+            return consume();\n+        } else {\n+            recover(token, ParserRuleContext.CLOSE_BRACKET);\n+            return parseCloseBracket();\n+        }\n+    }\n+\n+    private STNode parseKeyValue() {\n+        startContext(ParserRuleContext.KEY_VALUE_PAIR);\n+        STNode identifier = parseKey();\n+        STNode equals = parseEquals();\n+        STNode value = parseValue();\n+        endContext();\n+        return STNodeFactory.createKeyValue(identifier, equals, value);\n+    }\n+\n+    private STNode parseKey() {\n+        STToken token = peek();\n+        if (isKey(token)) {\n+            return consume();\n+        } else {\n+            recover(token, ParserRuleContext.KEY);\n+            return parseKey();\n+        }\n+    }\n+\n+    public static boolean isKey(STToken token) {\n+        switch (token.kind) {\n+            case UNQUOTED_KEY_TOKEN:\n+            case BOOLEAN:\n+            case STRING_LITERAL:\n+                return true;\n+            default:\n+                return isNumberValidKey(token);\n+        }\n+    }\n+\n+    public static boolean isNumberValidKey(STToken token) {\n+        if (token instanceof STLiteralValueToken) {\n+            if (token.kind == SyntaxKind.DEC_INT ||\n+                    token.kind == SyntaxKind.FLOAT) {\n+                return !(token.text().startsWith(\"+\") || token.text().startsWith(\"-\"));\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private STNode parseEquals() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.EQUAL_TOKEN) {\n+            return consume();\n+        } else {\n+            recover(token, ParserRuleContext.ASSIGN_OP);\n+            return parseEquals();\n+        }\n+    }\n+\n+    private STNode parseValue() {\n+        STToken token = peek();\n+        if (isValue(token)) {\n+            return STNodeFactory.createBasicValueNode(token.kind, consume());\n+//            STToken consume = consume();\n+//            return STNodeFactory.createBasicValueNode(consume.kind,consume);", "originalCommit": "d22c104ddce808398b620b31dae4565957a26240", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg1NjM5Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r495856396", "bodyText": "A better way to do this is to send two separate tokens for the one with the 'sign' and the one without it, and check for the syntax kind. That would be faster as well, compared to checking the string content..\ne.g two tokens like signedNumericLiteral and unsignedNumericLiteral", "author": "SupunS", "createdAt": "2020-09-28T11:00:47Z", "path": "misc/toml-parser/src/main/java/internal/parser/TomlParser.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package internal.parser;\n+\n+import internal.parser.tree.STLiteralValueToken;\n+import internal.parser.tree.STNode;\n+import internal.parser.tree.STNodeFactory;\n+import internal.parser.tree.STToken;\n+import syntax.tree.SyntaxKind;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static syntax.tree.SyntaxKind.DOUBLE_OPEN_BRACKET_TOKEN;\n+import static syntax.tree.SyntaxKind.EOF_TOKEN;\n+import static syntax.tree.SyntaxKind.OPEN_BRACKET_TOKEN;\n+\n+/**\n+ * A LL(k) recursive-descent parser for TOML.\n+ *\n+ * @since 1.2.0\n+ */\n+public class TomlParser extends AbstractParser {\n+\n+    public TomlParser(AbstractTokenReader tokenReader) {\n+        super(tokenReader, new TomlParserErrorHandler(tokenReader));\n+    }\n+\n+    /**\n+     * Parse a given input and returns the AST. Starts parsing from the top of a compilation unit.\n+     *\n+     * @return Parsed node\n+     */\n+    @Override\n+    public STNode parse() {\n+        startContext(ParserRuleContext.TOP_LEVEL_NODE);\n+        List<STNode> topLevelNodes = new ArrayList<>();\n+        STToken token = peek();\n+\n+        while (token.kind != SyntaxKind.EOF_TOKEN) {\n+            STNode decl = parseTopLevelNode();\n+            if (decl == null) {\n+                break;\n+            }\n+\n+            topLevelNodes.add(decl);\n+            token = peek();\n+        }\n+\n+        STToken eof = consume();\n+        endContext();\n+\n+        return STNodeFactory.createModulePartNode(\n+                STNodeFactory.createNodeList(topLevelNodes), eof);\n+    }\n+\n+    /**\n+     * Parse top level node given the next token kind and the modifier that precedes it.\n+     *\n+     * @return Parsed top-level node\n+     */\n+    private STNode parseTopLevelNode() {\n+        STToken nextToken = peek();\n+        switch (nextToken.kind) {\n+            case EOF_TOKEN:\n+                return null;\n+            case OPEN_BRACKET_TOKEN:\n+                return parseTable();\n+            case DOUBLE_OPEN_BRACKET_TOKEN:\n+                return parseArrayOfTables();\n+            case UNQUOTED_KEY_TOKEN:\n+            case STRING_LITERAL:\n+            case BOOLEAN:\n+            case DEC_INT:\n+            case FLOAT://todo check +/- ?\n+                return parseKeyValue();\n+            default:\n+                STToken token = peek();\n+                recover(token, ParserRuleContext.TOP_LEVEL_NODE);\n+\n+                return parseTopLevelNode();\n+        }\n+    }\n+\n+    private STNode parseArrayOfTables() {\n+        startContext(ParserRuleContext.TOML_TABLE_ARRAY);\n+        STNode openBracket = parseDoubleOpenBracket();\n+        STNode identifierToken = parseKey();\n+        STNode closedBracket = parseDoubleCloseBracket();\n+        List<STNode> fields = parseKeyValues();\n+        endContext();\n+        return STNodeFactory.createTableArrayNode(openBracket,\n+                identifierToken, closedBracket, STNodeFactory.createNodeList(fields));\n+    }\n+\n+    private STNode parseDoubleOpenBracket() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.DOUBLE_OPEN_BRACKET_TOKEN) {\n+            return consume();\n+        } else {\n+            recover(token, ParserRuleContext.DOUBLE_OPEN_BRACKET);\n+            return parseDoubleOpenBracket();\n+        }\n+    }\n+\n+    private STNode parseDoubleCloseBracket() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.DOUBLE_CLOSE_BRACKET_TOKEN) {\n+            return consume();\n+        } else {\n+            recover(token, ParserRuleContext.DOUBLE_CLOSE_BRACKET);\n+            return parseDoubleCloseBracket();\n+        }\n+    }\n+\n+    private STNode parseTable() {\n+        startContext(ParserRuleContext.TOML_TABLE);\n+        STNode openBracket = parseOpenBracket();\n+        STNode identifierToken = parseKey();\n+        STNode closedBracket = parseCloseBracket();\n+        List<STNode> fields = parseKeyValues();\n+        endContext();\n+        return STNodeFactory.createTableNode(openBracket, identifierToken, closedBracket,\n+                STNodeFactory.createNodeList(fields));\n+    }\n+\n+    private List<STNode> parseKeyValues() {\n+        List<STNode> fields = new ArrayList<>();\n+        STToken nextNode = peek();\n+        while (!(nextNode.kind == OPEN_BRACKET_TOKEN || nextNode.kind == DOUBLE_OPEN_BRACKET_TOKEN ||\n+                nextNode.kind == EOF_TOKEN)) {\n+            STNode stNode = parseKeyValue();\n+            fields.add(stNode);\n+            nextNode = peek();\n+        }\n+        return fields;\n+    }\n+\n+    private STNode parseOpenBracket() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            return consume();\n+        } else {\n+            recover(token, ParserRuleContext.OPEN_BRACKET);\n+            return parseOpenBracket();\n+        }\n+    }\n+\n+    private STNode parseCloseBracket() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.CLOSE_BRACKET_TOKEN) {\n+            return consume();\n+        } else {\n+            recover(token, ParserRuleContext.CLOSE_BRACKET);\n+            return parseCloseBracket();\n+        }\n+    }\n+\n+    private STNode parseKeyValue() {\n+        startContext(ParserRuleContext.KEY_VALUE_PAIR);\n+        STNode identifier = parseKey();\n+        STNode equals = parseEquals();\n+        STNode value = parseValue();\n+        endContext();\n+        return STNodeFactory.createKeyValue(identifier, equals, value);\n+    }\n+\n+    private STNode parseKey() {\n+        STToken token = peek();\n+        if (isKey(token)) {\n+            return consume();\n+        } else {\n+            recover(token, ParserRuleContext.KEY);\n+            return parseKey();\n+        }\n+    }\n+\n+    public static boolean isKey(STToken token) {\n+        switch (token.kind) {\n+            case UNQUOTED_KEY_TOKEN:\n+            case BOOLEAN:\n+            case STRING_LITERAL:\n+                return true;\n+            default:\n+                return isNumberValidKey(token);\n+        }\n+    }\n+\n+    public static boolean isNumberValidKey(STToken token) {\n+        if (token instanceof STLiteralValueToken) {\n+            if (token.kind == SyntaxKind.DEC_INT ||\n+                    token.kind == SyntaxKind.FLOAT) {\n+                return !(token.text().startsWith(\"+\") || token.text().startsWith(\"-\"));", "originalCommit": "d22c104ddce808398b620b31dae4565957a26240", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg1Nzc1NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r495857755", "bodyText": "Use the syntax kind to check the type of the node\nInvert the condition to reduce the nesting-levels of the if blocks", "author": "SupunS", "createdAt": "2020-09-28T11:03:40Z", "path": "misc/toml-parser/src/main/java/sementic/nodes/SemanticAnalyzer.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package sementic.nodes;\n+\n+import sementic.tools.DiagnosticCode;\n+\n+import java.util.Map;\n+\n+/**\n+ * Semantic Analyzer for TOML.\n+ */\n+public class SemanticAnalyzer extends TomlNodeVisitor {\n+\n+    private DiagnosticLog dlog;\n+\n+    public SemanticAnalyzer() {\n+        this.dlog = DiagnosticLog.getInstance();\n+    }\n+\n+    @Override\n+    public void visit(TomlTable tomlTable) {\n+        Map<String, TopLevelNode> childs = tomlTable.getChilds();\n+        for (Map.Entry<String, TopLevelNode> child : childs.entrySet()) {\n+            TopLevelNode value = child.getValue();\n+            if (value instanceof TomlTable) {", "originalCommit": "d22c104ddce808398b620b31dae4565957a26240", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg1ODc2NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r495858764", "bodyText": "I think we should call this TOMLValidator, since it technically doesn't validate semantics (e.g: doesn't do type checking etc.)", "author": "SupunS", "createdAt": "2020-09-28T11:05:45Z", "path": "misc/toml-parser/src/main/java/sementic/nodes/SemanticAnalyzer.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package sementic.nodes;\n+\n+import sementic.tools.DiagnosticCode;\n+\n+import java.util.Map;\n+\n+/**\n+ * Semantic Analyzer for TOML.\n+ */\n+public class SemanticAnalyzer extends TomlNodeVisitor {", "originalCommit": "d22c104ddce808398b620b31dae4565957a26240", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg1OTA4OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r495859089", "bodyText": "Missing year", "author": "SupunS", "createdAt": "2020-09-28T11:06:25Z", "path": "misc/toml-parser/src/main/java/sementic/TomlTransformer.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package sementic;\n+\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import sementic.nodes.DiagnosticLog;\n+import sementic.nodes.DiagnosticPos;\n+import sementic.nodes.DiagnosticSource;\n+import sementic.nodes.TomlArray;\n+import sementic.nodes.TomlBasicValue;\n+import sementic.nodes.TomlKey;\n+import sementic.nodes.TomlKeyValue;\n+import sementic.nodes.TomlNode;\n+import sementic.nodes.TomlTable;\n+import sementic.nodes.TomlTableArray;\n+import sementic.nodes.TomlValue;\n+import sementic.nodes.TopLevelNode;\n+import sementic.tools.DiagnosticCode;\n+import syntax.tree.Array;\n+import syntax.tree.BasicValueNode;\n+import syntax.tree.KeyValue;\n+import syntax.tree.ModuleMemberDeclarationNode;\n+import syntax.tree.ModulePartNode;\n+import syntax.tree.Node;\n+import syntax.tree.NodeList;\n+import syntax.tree.NodeTransformer;\n+import syntax.tree.SeparatedNodeList;\n+import syntax.tree.SyntaxKind;\n+import syntax.tree.TableArrayNode;\n+import syntax.tree.TableNode;\n+import syntax.tree.Token;\n+import syntax.tree.ValueNode;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Transformer to transform Syntax tree into Abstract Syntax Tree.\n+ */", "originalCommit": "d22c104ddce808398b620b31dae4565957a26240", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg1OTE1Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r495859152", "bodyText": "extra newline", "author": "SupunS", "createdAt": "2020-09-28T11:06:33Z", "path": "misc/toml-parser/src/main/java/sementic/TomlTransformer.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package sementic;\n+\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import sementic.nodes.DiagnosticLog;\n+import sementic.nodes.DiagnosticPos;\n+import sementic.nodes.DiagnosticSource;\n+import sementic.nodes.TomlArray;\n+import sementic.nodes.TomlBasicValue;\n+import sementic.nodes.TomlKey;\n+import sementic.nodes.TomlKeyValue;\n+import sementic.nodes.TomlNode;\n+import sementic.nodes.TomlTable;\n+import sementic.nodes.TomlTableArray;\n+import sementic.nodes.TomlValue;\n+import sementic.nodes.TopLevelNode;\n+import sementic.tools.DiagnosticCode;\n+import syntax.tree.Array;\n+import syntax.tree.BasicValueNode;\n+import syntax.tree.KeyValue;\n+import syntax.tree.ModuleMemberDeclarationNode;\n+import syntax.tree.ModulePartNode;\n+import syntax.tree.Node;\n+import syntax.tree.NodeList;\n+import syntax.tree.NodeTransformer;\n+import syntax.tree.SeparatedNodeList;\n+import syntax.tree.SyntaxKind;\n+import syntax.tree.TableArrayNode;\n+import syntax.tree.TableNode;\n+import syntax.tree.Token;\n+import syntax.tree.ValueNode;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Transformer to transform Syntax tree into Abstract Syntax Tree.\n+ */\n+public class TomlTransformer extends NodeTransformer<TomlNode> {\n+\n+    private DiagnosticSource diagnosticSource;\n+    private DiagnosticLog dlog;\n+\n+    public TomlTransformer(DiagnosticSource diagnosticSource) {\n+", "originalCommit": "d22c104ddce808398b620b31dae4565957a26240", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg1OTcwNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r495859706", "bodyText": "Can replace the instanceof checks with the syntax kind checks. Then can use a switch-case as well.", "author": "SupunS", "createdAt": "2020-09-28T11:07:48Z", "path": "misc/toml-parser/src/main/java/sementic/TomlTransformer.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package sementic;\n+\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import sementic.nodes.DiagnosticLog;\n+import sementic.nodes.DiagnosticPos;\n+import sementic.nodes.DiagnosticSource;\n+import sementic.nodes.TomlArray;\n+import sementic.nodes.TomlBasicValue;\n+import sementic.nodes.TomlKey;\n+import sementic.nodes.TomlKeyValue;\n+import sementic.nodes.TomlNode;\n+import sementic.nodes.TomlTable;\n+import sementic.nodes.TomlTableArray;\n+import sementic.nodes.TomlValue;\n+import sementic.nodes.TopLevelNode;\n+import sementic.tools.DiagnosticCode;\n+import syntax.tree.Array;\n+import syntax.tree.BasicValueNode;\n+import syntax.tree.KeyValue;\n+import syntax.tree.ModuleMemberDeclarationNode;\n+import syntax.tree.ModulePartNode;\n+import syntax.tree.Node;\n+import syntax.tree.NodeList;\n+import syntax.tree.NodeTransformer;\n+import syntax.tree.SeparatedNodeList;\n+import syntax.tree.SyntaxKind;\n+import syntax.tree.TableArrayNode;\n+import syntax.tree.TableNode;\n+import syntax.tree.Token;\n+import syntax.tree.ValueNode;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Transformer to transform Syntax tree into Abstract Syntax Tree.\n+ */\n+public class TomlTransformer extends NodeTransformer<TomlNode> {\n+\n+    private DiagnosticSource diagnosticSource;\n+    private DiagnosticLog dlog;\n+\n+    public TomlTransformer(DiagnosticSource diagnosticSource) {\n+\n+        this.diagnosticSource = diagnosticSource;\n+        this.dlog = DiagnosticLog.getInstance();\n+    }\n+\n+    @Override\n+    public TomlNode transform(ModulePartNode modulePartNode) {\n+        TomlKey tomlKey = new TomlKey(\"RootNode\", SyntaxKind.MODULE_NAME);\n+        TomlTable rootTable = new TomlTable(tomlKey);\n+\n+        NodeList<ModuleMemberDeclarationNode> members = modulePartNode.members();\n+        for (ModuleMemberDeclarationNode rootNode : members) {\n+            TomlNode transformedChild = rootNode.apply(this); //todo dotted\n+            addChildNodeToParent(rootTable, transformedChild);\n+        }\n+        return rootTable;\n+    }\n+\n+    private void addChildNodeToParent(TomlTable rootTable, TomlNode transformedChild) {\n+        if (transformedChild instanceof TopLevelNode) {\n+            if (transformedChild instanceof TomlTable) {\n+                TomlTable tableChild = (TomlTable) transformedChild;\n+                addChildTableToParent(rootTable, tableChild);\n+            } else if (transformedChild instanceof TomlTableArray) {\n+                TomlTableArray transformedArray = (TomlTableArray) transformedChild;\n+                addChildParentArrayToParent(rootTable, transformedArray);\n+            } else if (transformedChild instanceof TomlKeyValue) {\n+                TomlKeyValue transformedKeyValuePair = (TomlKeyValue) transformedChild;\n+                addChildKeyValueToParent(rootTable, transformedKeyValuePair);\n+            } else {\n+                throw new UnsupportedOperationException();\n+            }", "originalCommit": "d22c104ddce808398b620b31dae4565957a26240", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg2MTQxNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r495861414", "bodyText": "setChilds  --> setChildren", "author": "SupunS", "createdAt": "2020-09-28T11:11:18Z", "path": "misc/toml-parser/src/main/java/sementic/nodes/TomlTable.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package sementic.nodes;\n+\n+import syntax.tree.SyntaxKind;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+/**\n+ * Represents Table in TOML AST.\n+ */\n+public class TomlTable extends TopLevelNode {\n+\n+    Map<String, TopLevelNode> childs;\n+    public boolean generated;\n+\n+    public TomlTable(TomlKey key) {\n+        super(key);\n+        this.childs = new LinkedHashMap<>();\n+    }\n+\n+    public Map<String, TopLevelNode> getChilds() {\n+        return childs;\n+    }\n+\n+    public void setChilds(Map<String, TopLevelNode> childs) {", "originalCommit": "d22c104ddce808398b620b31dae4565957a26240", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg2MTg5MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r495861891", "bodyText": "childs --> children", "author": "SupunS", "createdAt": "2020-09-28T11:12:17Z", "path": "misc/toml-parser/src/main/java/sementic/nodes/TomlTable.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package sementic.nodes;\n+\n+import syntax.tree.SyntaxKind;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+/**\n+ * Represents Table in TOML AST.\n+ */\n+public class TomlTable extends TopLevelNode {\n+\n+    Map<String, TopLevelNode> childs;", "originalCommit": "d22c104ddce808398b620b31dae4565957a26240", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg2MjE3OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r495862178", "bodyText": "Wrong version.", "author": "SupunS", "createdAt": "2020-09-28T11:12:56Z", "path": "misc/toml-parser/src/main/java/sementic/nodes/Node.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ *  Copyright (c) 2017, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package sementic.nodes;\n+\n+import syntax.tree.SyntaxKind;\n+\n+import java.util.Set;\n+\n+/**\n+ * {@code Node} is the base interface for all tree nodes in Ballerina abstract syntax tree.\n+ *\n+ * @since 0.94", "originalCommit": "d22c104ddce808398b620b31dae4565957a26240", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg2NDUxNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r495864514", "bodyText": "Since every node has a kind associated with it, shall we introduce the kind field to the abstract TomlNode class, and remove it from all other classes?", "author": "SupunS", "createdAt": "2020-09-28T11:17:50Z", "path": "misc/toml-parser/src/main/java/sementic/nodes/TomlKey.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package sementic.nodes;\n+\n+import syntax.tree.SyntaxKind;\n+\n+/**\n+ * Represents Key in TOML AST.\n+ */\n+public class TomlKey extends TomlNode {\n+\n+    public String name;\n+    public SyntaxKind type;", "originalCommit": "d22c104ddce808398b620b31dae4565957a26240", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg2NDk1Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r495864956", "bodyText": "This can also be moved to the abstract class, and remove from all other classes", "author": "SupunS", "createdAt": "2020-09-28T11:18:46Z", "path": "misc/toml-parser/src/main/java/sementic/nodes/TomlKey.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package sementic.nodes;\n+\n+import syntax.tree.SyntaxKind;\n+\n+/**\n+ * Represents Key in TOML AST.\n+ */\n+public class TomlKey extends TomlNode {\n+\n+    public String name;\n+    public SyntaxKind type;\n+\n+    public TomlKey(String name, SyntaxKind type) {\n+        this.name = name;\n+        this.type = type;\n+    }\n+\n+    @Override\n+    public SyntaxKind getKind() {\n+        return SyntaxKind.KEY_VALUE;\n+    }", "originalCommit": "d22c104ddce808398b620b31dae4565957a26240", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d7062765d093208dc9c50c5b5887976fb36e6890", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d7062765d093208dc9c50c5b5887976fb36e6890", "message": "Fix error handling for arrays and address review comments", "committedDate": "2020-09-30T04:57:11Z", "type": "forcePushed"}, {"oid": "0edbb28c4f1310e43418892f794ca4e7da665a55", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0edbb28c4f1310e43418892f794ca4e7da665a55", "message": "Fix error handling for arrays and address review comments", "committedDate": "2020-10-02T04:13:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzI1MzQyNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r497253425", "bodyText": "Shal we remove commented codes?", "author": "anuruddhal", "createdAt": "2020-09-30T05:37:31Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/api/TOML.java", "diffHunk": "@@ -0,0 +1,331 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package io.ballerina.toml.api;\n+\n+import io.ballerina.toml.sementic.TomlTransformer;\n+import io.ballerina.toml.sementic.nodes.DiagnosticLog;\n+import io.ballerina.toml.sementic.nodes.DiagnosticPos;\n+import io.ballerina.toml.sementic.nodes.TOMLValidator;\n+import io.ballerina.toml.sementic.nodes.TomlArray;\n+import io.ballerina.toml.sementic.nodes.TomlBasicValue;\n+import io.ballerina.toml.sementic.nodes.TomlDiagnostic;\n+import io.ballerina.toml.sementic.nodes.TomlKey;\n+import io.ballerina.toml.sementic.nodes.TomlKeyValue;\n+import io.ballerina.toml.sementic.nodes.TomlTable;\n+import io.ballerina.toml.sementic.nodes.TomlTableArray;\n+import io.ballerina.toml.sementic.nodes.TomlValue;\n+import io.ballerina.toml.sementic.nodes.TopLevelNode;\n+import io.ballerina.toml.sementic.tools.DiagnosticCode;\n+import io.ballerina.toml.syntax.tree.ModulePartNode;\n+import io.ballerina.toml.syntax.tree.SyntaxKind;\n+import io.ballerina.toml.syntax.tree.SyntaxTree;\n+import io.ballerina.tools.diagnostics.Diagnostic;\n+import io.ballerina.tools.diagnostics.DiagnosticSeverity;\n+import io.ballerina.tools.diagnostics.Location;\n+import io.ballerina.tools.text.LinePosition;\n+import io.ballerina.tools.text.LineRange;\n+import io.ballerina.tools.text.TextDocument;\n+import io.ballerina.tools.text.TextDocuments;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * API For Parsing Tom's Obvious, Minimal Language (TOML) file.\n+ *\n+ * @since 0.1.0\n+ */\n+public class TOML {\n+\n+    private TomlTable rootNode;\n+    private DiagnosticLog dlog;\n+    private List<TomlDiagnostic> diagnostics;\n+\n+\n+    /**\n+     * Creates empty TOML Node.\n+     */\n+    public TOML() {\n+        TomlKey tomlKey = new TomlKey(\"RootNode\", SyntaxKind.MODULE_NAME);\n+        this.rootNode = new TomlTable(tomlKey);\n+        this.dlog = DiagnosticLog.getInstance();\n+        this.diagnostics = new ArrayList<>();\n+    }\n+\n+    /**\n+     * Creates new Root TOML Node from AST.\n+     *\n+     * @param tomlTable AST representation of TOML Table.\n+     */\n+    public TOML(TomlTable tomlTable) {\n+        this.rootNode = tomlTable;\n+        this.dlog = DiagnosticLog.getInstance();\n+        this.diagnostics = this.rootNode.getDiagnostics();\n+    }\n+\n+    /**\n+     * Read TOML File using Path.\n+     *\n+     * @param path Path of the TOML file\n+     * @return TOML Object\n+     * @throws IOException if file is not accessible\n+     */\n+    public TOML read(Path path) throws IOException {\n+        return this.read(Files.newBufferedReader(path));\n+    }\n+\n+    /**\n+     * Read TOML File using InputStream.\n+     *\n+     * @param inputStream InputStream of the TOML file\n+     * @return TOML Object\n+     * @throws IOException if file is not accessible\n+     */\n+    public TOML read(InputStream inputStream) throws IOException {\n+        return this.read(new InputStreamReader(inputStream));\n+    }\n+\n+    /**\n+     * Read TOML File using Reader.\n+     *\n+     * @param reader reader of the TOML file\n+     * @return TOML Object\n+     * @throws IOException if file is not accessible\n+     */\n+    public TOML read(Reader reader) throws IOException {\n+        BufferedReader bufferedReader = new BufferedReader(reader);\n+        StringBuilder w = new StringBuilder();\n+        for (String line = bufferedReader.readLine(); line != null; line = bufferedReader.readLine()) {\n+            w.append(line).append('\\n');\n+        }\n+        return this.read(w.toString());\n+    }\n+\n+    /**\n+     * Parse TOML file using TOML String.\n+     *\n+     * @param content String representation of the TOML file content.\n+     * @return TOML Object\n+     */\n+    public TOML read(String content) {\n+        TextDocument textDocument = TextDocuments.from(content);\n+        SyntaxTree syntaxTree = SyntaxTree.from(textDocument);\n+        diagnostics.addAll(reportSyntaxDiagnostics(syntaxTree));\n+        TomlTransformer nodeTransformer = new TomlTransformer();\n+        TomlTable transformedTable = (TomlTable) nodeTransformer.transform((ModulePartNode) syntaxTree.rootNode());\n+        TOMLValidator tomlValidator = new TOMLValidator();\n+        tomlValidator.visit(transformedTable);\n+        transformedTable.setSyntacticalDiagnostics(diagnostics);\n+        diagnostics.addAll(transformedTable.collectSemanticDiagnostics());\n+//        for (TomlDiagnostic diagnostic : diagnostics) {", "originalCommit": "d7062765d093208dc9c50c5b5887976fb36e6890", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY0NjMxMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r498646310", "bodyText": "Fixed in new commit.", "author": "xlight05", "createdAt": "2020-10-02T07:00:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzI1MzQyNQ=="}], "type": "inlineReview"}, {"oid": "5ae01afb855e3322fbe3108a6fd0efd528d34263", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5ae01afb855e3322fbe3108a6fd0efd528d34263", "message": "Fix error handling for arrays and address review comments", "committedDate": "2020-10-02T05:49:04Z", "type": "forcePushed"}, {"oid": "5c0e78ed10beebee1e924f13ded4ac496ca397b8", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5c0e78ed10beebee1e924f13ded4ac496ca397b8", "message": "Restrict dotted strings from API", "committedDate": "2020-10-05T10:12:05Z", "type": "forcePushed"}, {"oid": "e69f8298f4135850f82f98707543326bf032c2a6", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e69f8298f4135850f82f98707543326bf032c2a6", "message": "Change API and Add Multi array support", "committedDate": "2020-10-08T07:00:47Z", "type": "forcePushed"}, {"oid": "9034885abd79e57fc43d958bbdede9f8a7dee39c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9034885abd79e57fc43d958bbdede9f8a7dee39c", "message": "Change API and Add Multi array support", "committedDate": "2020-10-08T07:19:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUwNzU2MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r501507560", "bodyText": "Since we decided to hold the library-user usecase, shall we remove this class for now?\nWe can add it back when we properly do the library-user usecase.", "author": "SupunS", "createdAt": "2020-10-08T07:35:36Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package io.ballerina.toml.api;\n+\n+import io.ballerina.toml.ast.TomlDiagnostic;\n+import io.ballerina.toml.ast.TomlKeyValueNode;\n+import io.ballerina.toml.ast.TomlNodeLocation;\n+import io.ballerina.toml.ast.TomlTableArrayNode;\n+import io.ballerina.toml.ast.TomlTableNode;\n+import io.ballerina.toml.ast.TomlTransformer;\n+import io.ballerina.toml.ast.TomlValidator;\n+import io.ballerina.toml.ast.TomlValueNode;\n+import io.ballerina.toml.ast.TopLevelNode;\n+import io.ballerina.toml.syntax.tree.ModulePartNode;\n+import io.ballerina.toml.syntax.tree.SyntaxKind;\n+import io.ballerina.toml.syntax.tree.SyntaxTree;\n+import io.ballerina.tools.diagnostics.Diagnostic;\n+import io.ballerina.tools.text.TextDocument;\n+import io.ballerina.tools.text.TextDocuments;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * API For Parsing Tom's Obvious, Minimal Language (TOML) file.\n+ *\n+ * @since 0.1.0\n+ */\n+public class Toml {", "originalCommit": "9034885abd79e57fc43d958bbdede9f8a7dee39c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUxMDQ0NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r501510445", "bodyText": "DiagnosticLog is not part of the AST. I think we should have a package-hierarchy as follows:\ntoml\n  |_syntax\n  |    |_tree\n  |_semantic\n  |    |_diagnostics\n  |    |_ast\n  |    |_<<utils and validator goes here>>\n  |_internal", "author": "SupunS", "createdAt": "2020-10-08T07:40:55Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/ast/DiagnosticLog.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ *  Copyright (c) 2017, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package io.ballerina.toml.ast;\n+\n+import io.ballerina.toml.internal.diagnostics.DiagnosticErrorCode;\n+import io.ballerina.toml.internal.diagnostics.DiagnosticMessageHelper;\n+import io.ballerina.tools.diagnostics.DiagnosticInfo;\n+\n+/**\n+ * Diagnostic logger.\n+ *\n+ * @since 0.1.0\n+ */\n+public class DiagnosticLog {", "originalCommit": "9034885abd79e57fc43d958bbdede9f8a7dee39c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUxMTAxMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r501511013", "bodyText": "version should be 2.0.0 for all classes", "author": "SupunS", "createdAt": "2020-10-08T07:41:53Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/ast/Node.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ *  Copyright (c) 2017, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package io.ballerina.toml.ast;\n+\n+import io.ballerina.toml.syntax.tree.SyntaxKind;\n+\n+/**\n+ * {@code Node} is the base interface for all tree nodes in Ballerina abstract syntax tree.\n+ *\n+ * @since 0.1.0", "originalCommit": "9034885abd79e57fc43d958bbdede9f8a7dee39c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUxMTE4Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r501511183", "bodyText": "Incorrect licence year", "author": "SupunS", "createdAt": "2020-10-08T07:42:16Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/ast/Node.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ *  Copyright (c) 2017, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.", "originalCommit": "9034885abd79e57fc43d958bbdede9f8a7dee39c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUxMjQ1MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r501512450", "bodyText": "I think we don't need this. This can be achieved using elements() method", "author": "SupunS", "createdAt": "2020-10-08T07:44:32Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/ast/TomlArrayValueNode.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package io.ballerina.toml.ast;\n+\n+import io.ballerina.toml.syntax.tree.SyntaxKind;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Represents Toml Array in AST. Used to support nested and mixed arrays.\n+ *\n+ * @since 0.1.0\n+ */\n+public class TomlArrayValueNode extends TomlValueNode {\n+\n+    private final List<TomlValueNode> elements;\n+\n+    public TomlArrayValueNode(List<TomlValueNode> elements, TomlNodeLocation location) {\n+        super(SyntaxKind.ARRAY, location);\n+        this.elements = elements;\n+    }\n+\n+    /**\n+     * Get a single element of the array based on the Index.\n+     * @param index index of the element\n+     * @param <T> Type of the element\n+     * @return Element object\n+     */\n+    public <T extends TomlValueNode> T get(int index) {\n+        TomlValueNode tomlValue = elements.get(index);\n+        if (tomlValue != null) {\n+            return (T) tomlValue;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Transofrm Array Value into a List.\n+     * @param <T> Type of the Array\n+     * @return Transformed Array\n+     */\n+    public <T> List<T> toList() {", "originalCommit": "9034885abd79e57fc43d958bbdede9f8a7dee39c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUxMzIwNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r501513207", "bodyText": "Might not need this check. Casting a null won't cause any harm AFAIK.", "author": "SupunS", "createdAt": "2020-10-08T07:45:45Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/ast/TomlArrayValueNode.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package io.ballerina.toml.ast;\n+\n+import io.ballerina.toml.syntax.tree.SyntaxKind;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Represents Toml Array in AST. Used to support nested and mixed arrays.\n+ *\n+ * @since 0.1.0\n+ */\n+public class TomlArrayValueNode extends TomlValueNode {\n+\n+    private final List<TomlValueNode> elements;\n+\n+    public TomlArrayValueNode(List<TomlValueNode> elements, TomlNodeLocation location) {\n+        super(SyntaxKind.ARRAY, location);\n+        this.elements = elements;\n+    }\n+\n+    /**\n+     * Get a single element of the array based on the Index.\n+     * @param index index of the element\n+     * @param <T> Type of the element\n+     * @return Element object\n+     */\n+    public <T extends TomlValueNode> T get(int index) {\n+        TomlValueNode tomlValue = elements.get(index);\n+        if (tomlValue != null) {", "originalCommit": "9034885abd79e57fc43d958bbdede9f8a7dee39c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUxMzY5MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r501513691", "bodyText": "Looks like theres a formatting issue here. We generally keep a newline before the version. Check the other classes..", "author": "SupunS", "createdAt": "2020-10-08T07:46:36Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/ast/TomlBasicValueNode.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package io.ballerina.toml.ast;\n+\n+import io.ballerina.toml.syntax.tree.SyntaxKind;\n+\n+/***\n+ * Represents a Basic Value in Toml AST.\n+ * @param <T>Type of the Basic Node\n+ * @since 0.1.0", "originalCommit": "9034885abd79e57fc43d958bbdede9f8a7dee39c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUxNDU2Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r501514563", "bodyText": "Do we need to pass the SyntaxKind as a parameter? We know the syntax-kind before hand..", "author": "SupunS", "createdAt": "2020-10-08T07:48:16Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/ast/TomlBooleanValueNode.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package io.ballerina.toml.ast;\n+\n+import io.ballerina.toml.syntax.tree.SyntaxKind;\n+\n+/**\n+ * Represents A Boolean Value in Toml AST.\n+ *\n+ * @since 0.1.0\n+ */\n+public class TomlBooleanValueNode extends TomlBasicValueNode<Boolean> {\n+    public TomlBooleanValueNode(Boolean value, SyntaxKind kind, TomlNodeLocation location) {", "originalCommit": "9034885abd79e57fc43d958bbdede9f8a7dee39c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUxNDc4Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r501514783", "bodyText": "Same as above", "author": "SupunS", "createdAt": "2020-10-08T07:48:41Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/ast/TomlDoubleValueNodeNode.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package io.ballerina.toml.ast;\n+\n+import io.ballerina.toml.syntax.tree.SyntaxKind;\n+\n+/**\n+ * Represents A Double Value in Toml AST.\n+ *\n+ * @since 0.1.0\n+ */\n+public class TomlDoubleValueNodeNode extends TomlBasicValueNode<Double> {\n+    public TomlDoubleValueNodeNode(Double value, SyntaxKind kind, TomlNodeLocation location) {", "originalCommit": "9034885abd79e57fc43d958bbdede9f8a7dee39c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUxNDk0NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r501514944", "bodyText": "Same here", "author": "SupunS", "createdAt": "2020-10-08T07:49:00Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/ast/TomlKeyNode.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package io.ballerina.toml.ast;\n+\n+import io.ballerina.toml.syntax.tree.SyntaxKind;\n+\n+/**\n+ * Represents Key in TOML AST.\n+ *\n+ * @since 0.1.0\n+ */\n+public class TomlKeyNode extends TomlNode {\n+\n+    private final String name;\n+\n+    public TomlKeyNode(String name, SyntaxKind type, TomlNodeLocation location) {\n+        super(type, location);", "originalCommit": "9034885abd79e57fc43d958bbdede9f8a7dee39c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUxNTY1Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r501515653", "bodyText": "We should not support any methods to update the AST (like add/set/put), since it it immutable.", "author": "SupunS", "createdAt": "2020-10-08T07:50:14Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/ast/TomlTableNode.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package io.ballerina.toml.ast;\n+\n+import io.ballerina.toml.syntax.tree.SyntaxKind;\n+\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Represents Table in TOML AST.\n+ *\n+ * @since 0.1.0\n+ */\n+public class TomlTableNode extends TopLevelNode {\n+\n+    private final Map<String, TopLevelNode> children;\n+    private final boolean generated;\n+\n+    public TomlTableNode(TomlKeyNode key, TomlNodeLocation location) {\n+        super(key, SyntaxKind.TABLE, location);\n+        this.children = new LinkedHashMap<>();\n+        this.generated = false;\n+    }\n+\n+    public TomlTableNode(TomlKeyNode key, boolean generated, TomlNodeLocation location) {\n+        super(key, SyntaxKind.TABLE, location);\n+        this.children = new LinkedHashMap<>();\n+        this.generated = generated;\n+    }\n+\n+    public TomlTableNode(TomlKeyNode key, boolean generated, TomlNodeLocation location,\n+                         Map<String, TopLevelNode> children) {\n+        super(key, SyntaxKind.TABLE, location);\n+        this.children = children;\n+        this.generated = generated;\n+    }\n+\n+    public Map<String, TopLevelNode> children() {\n+        return children;\n+    }\n+\n+    public boolean generated() {\n+        return generated;\n+    }\n+\n+    public void addChild(TopLevelNode topLevelNode) {", "originalCommit": "9034885abd79e57fc43d958bbdede9f8a7dee39c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUxNzU0NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r501517544", "bodyText": "can reduce the nested levels, if the condition is inverted. i.e.:\nif (value.kind() == SyntaxKind.TABLE) {\n    continue;\n}", "author": "SupunS", "createdAt": "2020-10-08T07:53:26Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/ast/TomlValidator.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package io.ballerina.toml.ast;\n+\n+import io.ballerina.toml.internal.diagnostics.DiagnosticErrorCode;\n+import io.ballerina.toml.syntax.tree.SyntaxKind;\n+\n+import java.util.Map;\n+\n+/**\n+ * A Validator for TOML.\n+ *\n+ * @since 0.1.0\n+ */\n+public class TomlValidator extends TomlNodeVisitor {\n+\n+    private DiagnosticLog dlog;\n+\n+    public TomlValidator() {\n+        this.dlog = DiagnosticLog.getInstance();\n+    }\n+\n+    @Override\n+    public void visit(TomlTableNode tomlTableNode) {\n+        Map<String, TopLevelNode> children = tomlTableNode.children();\n+        for (Map.Entry<String, TopLevelNode> child : children.entrySet()) {\n+            TopLevelNode value = child.getValue();\n+            if (value.kind() == SyntaxKind.TABLE) {", "originalCommit": "9034885abd79e57fc43d958bbdede9f8a7dee39c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUxODQ4MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r501518481", "bodyText": "This seems not correct to me. By the time we reach here, key cannot have dots.", "author": "SupunS", "createdAt": "2020-10-08T07:54:57Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/ast/TomlValidator.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package io.ballerina.toml.ast;\n+\n+import io.ballerina.toml.internal.diagnostics.DiagnosticErrorCode;\n+import io.ballerina.toml.syntax.tree.SyntaxKind;\n+\n+import java.util.Map;\n+\n+/**\n+ * A Validator for TOML.\n+ *\n+ * @since 0.1.0\n+ */\n+public class TomlValidator extends TomlNodeVisitor {\n+\n+    private DiagnosticLog dlog;\n+\n+    public TomlValidator() {\n+        this.dlog = DiagnosticLog.getInstance();\n+    }\n+\n+    @Override\n+    public void visit(TomlTableNode tomlTableNode) {\n+        Map<String, TopLevelNode> children = tomlTableNode.children();\n+        for (Map.Entry<String, TopLevelNode> child : children.entrySet()) {\n+            TopLevelNode value = child.getValue();\n+            if (value.kind() == SyntaxKind.TABLE) {\n+                String childTableFullName = value.key().name();\n+                String[] split = childTableFullName.split(\"\\\\.\");", "originalCommit": "9034885abd79e57fc43d958bbdede9f8a7dee39c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUyMzYyMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r501523620", "bodyText": "We don't need to persist whitespaces in the AST.", "author": "SupunS", "createdAt": "2020-10-08T08:03:35Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/ast/Whitespace.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ *  Copyright (c) 2017, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package io.ballerina.toml.ast;\n+\n+/**\n+ * Represent a white space in the source code.\n+ */\n+public class Whitespace implements Comparable<Whitespace> {", "originalCommit": "9034885abd79e57fc43d958bbdede9f8a7dee39c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUyNjAxMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r501526010", "bodyText": "We need to clean up these error codes. Can you create an issue for that?", "author": "SupunS", "createdAt": "2020-10-08T08:07:32Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/internal/diagnostics/DiagnosticErrorCode.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package io.ballerina.toml.internal.diagnostics;\n+\n+import io.ballerina.tools.diagnostics.DiagnosticSeverity;\n+\n+/**\n+ * Represents a diagnostic error code.\n+ *\n+ * @since 2.0.0\n+ */\n+public enum DiagnosticErrorCode implements DiagnosticCode {\n+    // TODO figure out an order of these error codes", "originalCommit": "9034885abd79e57fc43d958bbdede9f8a7dee39c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI0MTI0Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r502241247", "bodyText": "Created. #26289", "author": "xlight05", "createdAt": "2020-10-09T07:33:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUyNjAxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUyNjI5MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r501526290", "bodyText": "Are we using this class anywhere? if not, shall we remove it?", "author": "SupunS", "createdAt": "2020-10-08T08:08:02Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/internal/diagnostics/IRDiagnostic.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package io.ballerina.toml.internal.diagnostics;\n+\n+/**\n+ * Internal representation of a {@code Diagnostic}.\n+ *\n+ * @since 2.0.0\n+ */\n+public class IRDiagnostic {", "originalCommit": "9034885abd79e57fc43d958bbdede9f8a7dee39c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU0NzUwNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r501547505", "bodyText": "Doc comment is incorrect. should be TomlParser", "author": "SupunS", "createdAt": "2020-10-08T08:42:15Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/ParserFactory.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package io.ballerina.toml.internal.parser;\n+\n+import io.ballerina.tools.text.CharReader;\n+import io.ballerina.tools.text.TextDocument;\n+import io.ballerina.tools.text.TextDocuments;\n+\n+\n+/**\n+ * A factory for creating {@code BallerinaParser} instances.\n+ * <p>\n+ * Creates a regular parser or an incremental parser based on the parameters.\n+ *\n+ * @since 0.1.0\n+ */\n+public class ParserFactory {\n+\n+    private ParserFactory() {\n+    }\n+\n+    /**\n+     * Creates a regular {@code BallerinaParser} instance from the given {@code String}.", "originalCommit": "9034885abd79e57fc43d958bbdede9f8a7dee39c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU0OTM4NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r501549384", "bodyText": "processOpenBracket --> parseTableOrArray", "author": "SupunS", "createdAt": "2020-10-08T08:45:10Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java", "diffHunk": "@@ -0,0 +1,374 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.internal.parser;\n+\n+import io.ballerina.toml.internal.parser.tree.STNode;\n+import io.ballerina.toml.internal.parser.tree.STNodeFactory;\n+import io.ballerina.toml.internal.parser.tree.STToken;\n+import io.ballerina.toml.syntax.tree.SyntaxKind;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static io.ballerina.toml.syntax.tree.SyntaxKind.CLOSE_BRACKET_TOKEN;\n+import static io.ballerina.toml.syntax.tree.SyntaxKind.EOF_TOKEN;\n+import static io.ballerina.toml.syntax.tree.SyntaxKind.OPEN_BRACKET_TOKEN;\n+\n+/**\n+ * A LL(k) recursive-descent parser for TOML.\n+ *\n+ * @since 0.1.0\n+ */\n+public class TomlParser extends AbstractParser {\n+\n+    public TomlParser(AbstractTokenReader tokenReader) {\n+        super(tokenReader, new TomlParserErrorHandler(tokenReader));\n+    }\n+\n+    /**\n+     * Parse a given input and returns the AST. Starts parsing from the top of a compilation unit.\n+     *\n+     * @return Parsed node\n+     */\n+    @Override\n+    public STNode parse() {\n+        List<STNode> topLevelNodes = new ArrayList<>();\n+        STToken token = peek();\n+\n+        while (token.kind != SyntaxKind.EOF_TOKEN) {\n+            STNode decl = parseTopLevelNode();\n+            if (decl == null) {\n+                break;\n+            }\n+\n+            topLevelNodes.add(decl);\n+            token = peek();\n+        }\n+\n+        STToken eof = consume();\n+\n+        return STNodeFactory.createModulePartNode(\n+                STNodeFactory.createNodeList(topLevelNodes), eof);\n+    }\n+\n+    /**\n+     * Parse top level node given the next token kind and the modifier that precedes it.\n+     *\n+     * @return Parsed top-level node\n+     */\n+    private STNode parseTopLevelNode() {\n+        startContext(ParserRuleContext.TOP_LEVEL_NODE);\n+        STToken nextToken = peek();\n+        switch (nextToken.kind) {\n+            case EOF_TOKEN:\n+                return null;\n+            case OPEN_BRACKET_TOKEN:\n+                return processOpenBracket();\n+            case UNQUOTED_KEY_TOKEN:\n+            case STRING_LITERAL:\n+            case BOOLEAN:\n+            case DEC_INT:\n+            case FLOAT:\n+                return parseKeyValue();\n+            default:\n+                STToken token = peek();\n+                recover(token, ParserRuleContext.TOP_LEVEL_NODE);\n+\n+                return parseTopLevelNode();\n+        }\n+    }\n+\n+    /**\n+     * Parsing Array of Tables. Array of Table is a identifier surrounded by Double Open and Close Brackets.\n+     * Ex - [[ Identifier ]]\n+     *\n+     * @return TableArrayNode\n+     */\n+    private STNode parseArrayOfTables() {\n+        startContext(ParserRuleContext.TOML_TABLE_ARRAY);\n+        STNode firstOpenBracket = parseOpenBracket();\n+        STNode secondOpenBracket = parseOpenBracket();\n+        STNode identifierToken = parseKey();\n+        STNode firstCloseBracket = parseCloseBracket();\n+        STNode secondCloesBracket = parseCloseBracket();\n+        List<STNode> fields = parseKeyValues();\n+        endContext();\n+        return STNodeFactory.createTableArrayNode(firstOpenBracket, secondOpenBracket,\n+                identifierToken, firstCloseBracket, secondCloesBracket, STNodeFactory.createNodeList(fields));\n+    }\n+\n+    private STNode processOpenBracket() {", "originalCommit": "9034885abd79e57fc43d958bbdede9f8a7dee39c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU1MDg2Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r501550862", "bodyText": "parseKeyValues --> parseTableEntries", "author": "SupunS", "createdAt": "2020-10-08T08:47:25Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java", "diffHunk": "@@ -0,0 +1,374 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.internal.parser;\n+\n+import io.ballerina.toml.internal.parser.tree.STNode;\n+import io.ballerina.toml.internal.parser.tree.STNodeFactory;\n+import io.ballerina.toml.internal.parser.tree.STToken;\n+import io.ballerina.toml.syntax.tree.SyntaxKind;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static io.ballerina.toml.syntax.tree.SyntaxKind.CLOSE_BRACKET_TOKEN;\n+import static io.ballerina.toml.syntax.tree.SyntaxKind.EOF_TOKEN;\n+import static io.ballerina.toml.syntax.tree.SyntaxKind.OPEN_BRACKET_TOKEN;\n+\n+/**\n+ * A LL(k) recursive-descent parser for TOML.\n+ *\n+ * @since 0.1.0\n+ */\n+public class TomlParser extends AbstractParser {\n+\n+    public TomlParser(AbstractTokenReader tokenReader) {\n+        super(tokenReader, new TomlParserErrorHandler(tokenReader));\n+    }\n+\n+    /**\n+     * Parse a given input and returns the AST. Starts parsing from the top of a compilation unit.\n+     *\n+     * @return Parsed node\n+     */\n+    @Override\n+    public STNode parse() {\n+        List<STNode> topLevelNodes = new ArrayList<>();\n+        STToken token = peek();\n+\n+        while (token.kind != SyntaxKind.EOF_TOKEN) {\n+            STNode decl = parseTopLevelNode();\n+            if (decl == null) {\n+                break;\n+            }\n+\n+            topLevelNodes.add(decl);\n+            token = peek();\n+        }\n+\n+        STToken eof = consume();\n+\n+        return STNodeFactory.createModulePartNode(\n+                STNodeFactory.createNodeList(topLevelNodes), eof);\n+    }\n+\n+    /**\n+     * Parse top level node given the next token kind and the modifier that precedes it.\n+     *\n+     * @return Parsed top-level node\n+     */\n+    private STNode parseTopLevelNode() {\n+        startContext(ParserRuleContext.TOP_LEVEL_NODE);\n+        STToken nextToken = peek();\n+        switch (nextToken.kind) {\n+            case EOF_TOKEN:\n+                return null;\n+            case OPEN_BRACKET_TOKEN:\n+                return processOpenBracket();\n+            case UNQUOTED_KEY_TOKEN:\n+            case STRING_LITERAL:\n+            case BOOLEAN:\n+            case DEC_INT:\n+            case FLOAT:\n+                return parseKeyValue();\n+            default:\n+                STToken token = peek();\n+                recover(token, ParserRuleContext.TOP_LEVEL_NODE);\n+\n+                return parseTopLevelNode();\n+        }\n+    }\n+\n+    /**\n+     * Parsing Array of Tables. Array of Table is a identifier surrounded by Double Open and Close Brackets.\n+     * Ex - [[ Identifier ]]\n+     *\n+     * @return TableArrayNode\n+     */\n+    private STNode parseArrayOfTables() {\n+        startContext(ParserRuleContext.TOML_TABLE_ARRAY);\n+        STNode firstOpenBracket = parseOpenBracket();\n+        STNode secondOpenBracket = parseOpenBracket();\n+        STNode identifierToken = parseKey();\n+        STNode firstCloseBracket = parseCloseBracket();\n+        STNode secondCloesBracket = parseCloseBracket();\n+        List<STNode> fields = parseKeyValues();\n+        endContext();\n+        return STNodeFactory.createTableArrayNode(firstOpenBracket, secondOpenBracket,\n+                identifierToken, firstCloseBracket, secondCloesBracket, STNodeFactory.createNodeList(fields));\n+    }\n+\n+    private STNode processOpenBracket() {\n+        STToken token = peek(2);\n+        if (token.kind == OPEN_BRACKET_TOKEN) {\n+            return parseArrayOfTables();\n+        } else {\n+            return parseTable();\n+        }\n+    }\n+\n+    /**\n+     * Parsing TOML Table. Table is a identifier surrounded by Open and Close Brackets.\n+     * Ex - [ Identifier ]\n+     *\n+     * @return TableNode\n+     */\n+    private STNode parseTable() {\n+        startContext(ParserRuleContext.TOML_TABLE);\n+        STNode openBracket = parseOpenBracket();\n+        STNode identifierToken = parseKey();\n+        STNode closedBracket = parseCloseBracket();\n+        List<STNode> fields = parseKeyValues();\n+        endContext();\n+        return STNodeFactory.createTableNode(openBracket, identifierToken, closedBracket,\n+                STNodeFactory.createNodeList(fields));\n+    }\n+\n+    private List<STNode> parseKeyValues() {", "originalCommit": "9034885abd79e57fc43d958bbdede9f8a7dee39c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU1MTc1Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r501551756", "bodyText": "Do we need to peek again? Can use nextToken", "author": "SupunS", "createdAt": "2020-10-08T08:48:53Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java", "diffHunk": "@@ -0,0 +1,374 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.internal.parser;\n+\n+import io.ballerina.toml.internal.parser.tree.STNode;\n+import io.ballerina.toml.internal.parser.tree.STNodeFactory;\n+import io.ballerina.toml.internal.parser.tree.STToken;\n+import io.ballerina.toml.syntax.tree.SyntaxKind;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static io.ballerina.toml.syntax.tree.SyntaxKind.CLOSE_BRACKET_TOKEN;\n+import static io.ballerina.toml.syntax.tree.SyntaxKind.EOF_TOKEN;\n+import static io.ballerina.toml.syntax.tree.SyntaxKind.OPEN_BRACKET_TOKEN;\n+\n+/**\n+ * A LL(k) recursive-descent parser for TOML.\n+ *\n+ * @since 0.1.0\n+ */\n+public class TomlParser extends AbstractParser {\n+\n+    public TomlParser(AbstractTokenReader tokenReader) {\n+        super(tokenReader, new TomlParserErrorHandler(tokenReader));\n+    }\n+\n+    /**\n+     * Parse a given input and returns the AST. Starts parsing from the top of a compilation unit.\n+     *\n+     * @return Parsed node\n+     */\n+    @Override\n+    public STNode parse() {\n+        List<STNode> topLevelNodes = new ArrayList<>();\n+        STToken token = peek();\n+\n+        while (token.kind != SyntaxKind.EOF_TOKEN) {\n+            STNode decl = parseTopLevelNode();\n+            if (decl == null) {\n+                break;\n+            }\n+\n+            topLevelNodes.add(decl);\n+            token = peek();\n+        }\n+\n+        STToken eof = consume();\n+\n+        return STNodeFactory.createModulePartNode(\n+                STNodeFactory.createNodeList(topLevelNodes), eof);\n+    }\n+\n+    /**\n+     * Parse top level node given the next token kind and the modifier that precedes it.\n+     *\n+     * @return Parsed top-level node\n+     */\n+    private STNode parseTopLevelNode() {\n+        startContext(ParserRuleContext.TOP_LEVEL_NODE);\n+        STToken nextToken = peek();\n+        switch (nextToken.kind) {\n+            case EOF_TOKEN:\n+                return null;\n+            case OPEN_BRACKET_TOKEN:\n+                return processOpenBracket();\n+            case UNQUOTED_KEY_TOKEN:\n+            case STRING_LITERAL:\n+            case BOOLEAN:\n+            case DEC_INT:\n+            case FLOAT:\n+                return parseKeyValue();\n+            default:\n+                STToken token = peek();", "originalCommit": "9034885abd79e57fc43d958bbdede9f8a7dee39c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU1MjMyMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r501552323", "bodyText": "Lets invert the condition to reduce the nested levels", "author": "SupunS", "createdAt": "2020-10-08T08:49:45Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java", "diffHunk": "@@ -0,0 +1,374 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.internal.parser;\n+\n+import io.ballerina.toml.internal.parser.tree.STNode;\n+import io.ballerina.toml.internal.parser.tree.STNodeFactory;\n+import io.ballerina.toml.internal.parser.tree.STToken;\n+import io.ballerina.toml.syntax.tree.SyntaxKind;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static io.ballerina.toml.syntax.tree.SyntaxKind.CLOSE_BRACKET_TOKEN;\n+import static io.ballerina.toml.syntax.tree.SyntaxKind.EOF_TOKEN;\n+import static io.ballerina.toml.syntax.tree.SyntaxKind.OPEN_BRACKET_TOKEN;\n+\n+/**\n+ * A LL(k) recursive-descent parser for TOML.\n+ *\n+ * @since 0.1.0\n+ */\n+public class TomlParser extends AbstractParser {\n+\n+    public TomlParser(AbstractTokenReader tokenReader) {\n+        super(tokenReader, new TomlParserErrorHandler(tokenReader));\n+    }\n+\n+    /**\n+     * Parse a given input and returns the AST. Starts parsing from the top of a compilation unit.\n+     *\n+     * @return Parsed node\n+     */\n+    @Override\n+    public STNode parse() {\n+        List<STNode> topLevelNodes = new ArrayList<>();\n+        STToken token = peek();\n+\n+        while (token.kind != SyntaxKind.EOF_TOKEN) {\n+            STNode decl = parseTopLevelNode();\n+            if (decl == null) {\n+                break;\n+            }\n+\n+            topLevelNodes.add(decl);\n+            token = peek();\n+        }\n+\n+        STToken eof = consume();\n+\n+        return STNodeFactory.createModulePartNode(\n+                STNodeFactory.createNodeList(topLevelNodes), eof);\n+    }\n+\n+    /**\n+     * Parse top level node given the next token kind and the modifier that precedes it.\n+     *\n+     * @return Parsed top-level node\n+     */\n+    private STNode parseTopLevelNode() {\n+        startContext(ParserRuleContext.TOP_LEVEL_NODE);\n+        STToken nextToken = peek();\n+        switch (nextToken.kind) {\n+            case EOF_TOKEN:\n+                return null;\n+            case OPEN_BRACKET_TOKEN:\n+                return processOpenBracket();\n+            case UNQUOTED_KEY_TOKEN:\n+            case STRING_LITERAL:\n+            case BOOLEAN:\n+            case DEC_INT:\n+            case FLOAT:\n+                return parseKeyValue();\n+            default:\n+                STToken token = peek();\n+                recover(token, ParserRuleContext.TOP_LEVEL_NODE);\n+\n+                return parseTopLevelNode();\n+        }\n+    }\n+\n+    /**\n+     * Parsing Array of Tables. Array of Table is a identifier surrounded by Double Open and Close Brackets.\n+     * Ex - [[ Identifier ]]\n+     *\n+     * @return TableArrayNode\n+     */\n+    private STNode parseArrayOfTables() {\n+        startContext(ParserRuleContext.TOML_TABLE_ARRAY);\n+        STNode firstOpenBracket = parseOpenBracket();\n+        STNode secondOpenBracket = parseOpenBracket();\n+        STNode identifierToken = parseKey();\n+        STNode firstCloseBracket = parseCloseBracket();\n+        STNode secondCloesBracket = parseCloseBracket();\n+        List<STNode> fields = parseKeyValues();\n+        endContext();\n+        return STNodeFactory.createTableArrayNode(firstOpenBracket, secondOpenBracket,\n+                identifierToken, firstCloseBracket, secondCloesBracket, STNodeFactory.createNodeList(fields));\n+    }\n+\n+    private STNode processOpenBracket() {\n+        STToken token = peek(2);\n+        if (token.kind == OPEN_BRACKET_TOKEN) {\n+            return parseArrayOfTables();\n+        } else {\n+            return parseTable();\n+        }\n+    }\n+\n+    /**\n+     * Parsing TOML Table. Table is a identifier surrounded by Open and Close Brackets.\n+     * Ex - [ Identifier ]\n+     *\n+     * @return TableNode\n+     */\n+    private STNode parseTable() {\n+        startContext(ParserRuleContext.TOML_TABLE);\n+        STNode openBracket = parseOpenBracket();\n+        STNode identifierToken = parseKey();\n+        STNode closedBracket = parseCloseBracket();\n+        List<STNode> fields = parseKeyValues();\n+        endContext();\n+        return STNodeFactory.createTableNode(openBracket, identifierToken, closedBracket,\n+                STNodeFactory.createNodeList(fields));\n+    }\n+\n+    private List<STNode> parseKeyValues() {\n+        List<STNode> fields = new ArrayList<>();\n+        STToken nextNode = peek();\n+        while (!isNextTokenArray(nextNode)) {\n+            STNode stNode = parseKeyValue();\n+            fields.add(stNode);\n+            nextNode = peek();\n+        }\n+        return fields;\n+    }\n+\n+    private boolean isNextTokenArray(STToken nextNode) {\n+        return nextNode.kind == OPEN_BRACKET_TOKEN ||\n+                nextNode.kind == EOF_TOKEN;\n+    }\n+\n+    private STNode parseOpenBracket() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            return consume();\n+        } else {\n+            recover(token, ParserRuleContext.OPEN_BRACKET);\n+            return parseOpenBracket();\n+        }\n+    }\n+\n+    private STNode parseCloseBracket() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.CLOSE_BRACKET_TOKEN) {\n+            return consume();\n+        } else {\n+            recover(token, ParserRuleContext.CLOSE_BRACKET);\n+            return parseCloseBracket();\n+        }\n+    }\n+\n+    /**\n+     * Parsing Toml Key Value Pair. Key Value pair is constructed with Key Node, equals token and Value Node.\n+     * Ex - Key = Value\n+     *\n+     * @return KeyValueNode\n+     */\n+    private STNode parseKeyValue() {\n+        startContext(ParserRuleContext.KEY_VALUE_PAIR);\n+        STNode identifier = parseKey();\n+        STNode equals = parseEquals();\n+        STNode value = parseValue();\n+        endContext();\n+        return STNodeFactory.createKeyValue(identifier, equals, value);\n+    }\n+\n+    /**\n+     * Parses Key Node. A Key Node can be either one of the following forms\n+     * UNQUOTED_KEY_TOKEN (Regular Keys) |\n+     * BOOLEAN (True | False keyword) |\n+     * STRING_LITERAL (Quoted Keys)\n+     *\n+     * @return KeyNode\n+     */\n+    private STNode parseKey() {\n+        STToken token = peek();\n+        if (isKey(token)) {\n+            return consume();\n+        } else {\n+            recover(token, ParserRuleContext.KEY);\n+            return parseKey();\n+        }\n+    }\n+\n+    public static boolean isKey(STToken token) {\n+        switch (token.kind) {\n+            case UNQUOTED_KEY_TOKEN:\n+            case BOOLEAN:\n+            case STRING_LITERAL:\n+                return true;\n+            default:\n+                return isNumberValidKey(token);\n+        }\n+    }\n+\n+    public static boolean isNumberValidKey(STToken token) {\n+        if (isBasicValue(token)) {", "originalCommit": "9034885abd79e57fc43d958bbdede9f8a7dee39c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU1MjcxNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r501552717", "bodyText": "Shall we create an issue to track this one (introducing separate tokens for different numeric literals)?", "author": "SupunS", "createdAt": "2020-10-08T08:50:18Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java", "diffHunk": "@@ -0,0 +1,374 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.internal.parser;\n+\n+import io.ballerina.toml.internal.parser.tree.STNode;\n+import io.ballerina.toml.internal.parser.tree.STNodeFactory;\n+import io.ballerina.toml.internal.parser.tree.STToken;\n+import io.ballerina.toml.syntax.tree.SyntaxKind;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static io.ballerina.toml.syntax.tree.SyntaxKind.CLOSE_BRACKET_TOKEN;\n+import static io.ballerina.toml.syntax.tree.SyntaxKind.EOF_TOKEN;\n+import static io.ballerina.toml.syntax.tree.SyntaxKind.OPEN_BRACKET_TOKEN;\n+\n+/**\n+ * A LL(k) recursive-descent parser for TOML.\n+ *\n+ * @since 0.1.0\n+ */\n+public class TomlParser extends AbstractParser {\n+\n+    public TomlParser(AbstractTokenReader tokenReader) {\n+        super(tokenReader, new TomlParserErrorHandler(tokenReader));\n+    }\n+\n+    /**\n+     * Parse a given input and returns the AST. Starts parsing from the top of a compilation unit.\n+     *\n+     * @return Parsed node\n+     */\n+    @Override\n+    public STNode parse() {\n+        List<STNode> topLevelNodes = new ArrayList<>();\n+        STToken token = peek();\n+\n+        while (token.kind != SyntaxKind.EOF_TOKEN) {\n+            STNode decl = parseTopLevelNode();\n+            if (decl == null) {\n+                break;\n+            }\n+\n+            topLevelNodes.add(decl);\n+            token = peek();\n+        }\n+\n+        STToken eof = consume();\n+\n+        return STNodeFactory.createModulePartNode(\n+                STNodeFactory.createNodeList(topLevelNodes), eof);\n+    }\n+\n+    /**\n+     * Parse top level node given the next token kind and the modifier that precedes it.\n+     *\n+     * @return Parsed top-level node\n+     */\n+    private STNode parseTopLevelNode() {\n+        startContext(ParserRuleContext.TOP_LEVEL_NODE);\n+        STToken nextToken = peek();\n+        switch (nextToken.kind) {\n+            case EOF_TOKEN:\n+                return null;\n+            case OPEN_BRACKET_TOKEN:\n+                return processOpenBracket();\n+            case UNQUOTED_KEY_TOKEN:\n+            case STRING_LITERAL:\n+            case BOOLEAN:\n+            case DEC_INT:\n+            case FLOAT:\n+                return parseKeyValue();\n+            default:\n+                STToken token = peek();\n+                recover(token, ParserRuleContext.TOP_LEVEL_NODE);\n+\n+                return parseTopLevelNode();\n+        }\n+    }\n+\n+    /**\n+     * Parsing Array of Tables. Array of Table is a identifier surrounded by Double Open and Close Brackets.\n+     * Ex - [[ Identifier ]]\n+     *\n+     * @return TableArrayNode\n+     */\n+    private STNode parseArrayOfTables() {\n+        startContext(ParserRuleContext.TOML_TABLE_ARRAY);\n+        STNode firstOpenBracket = parseOpenBracket();\n+        STNode secondOpenBracket = parseOpenBracket();\n+        STNode identifierToken = parseKey();\n+        STNode firstCloseBracket = parseCloseBracket();\n+        STNode secondCloesBracket = parseCloseBracket();\n+        List<STNode> fields = parseKeyValues();\n+        endContext();\n+        return STNodeFactory.createTableArrayNode(firstOpenBracket, secondOpenBracket,\n+                identifierToken, firstCloseBracket, secondCloesBracket, STNodeFactory.createNodeList(fields));\n+    }\n+\n+    private STNode processOpenBracket() {\n+        STToken token = peek(2);\n+        if (token.kind == OPEN_BRACKET_TOKEN) {\n+            return parseArrayOfTables();\n+        } else {\n+            return parseTable();\n+        }\n+    }\n+\n+    /**\n+     * Parsing TOML Table. Table is a identifier surrounded by Open and Close Brackets.\n+     * Ex - [ Identifier ]\n+     *\n+     * @return TableNode\n+     */\n+    private STNode parseTable() {\n+        startContext(ParserRuleContext.TOML_TABLE);\n+        STNode openBracket = parseOpenBracket();\n+        STNode identifierToken = parseKey();\n+        STNode closedBracket = parseCloseBracket();\n+        List<STNode> fields = parseKeyValues();\n+        endContext();\n+        return STNodeFactory.createTableNode(openBracket, identifierToken, closedBracket,\n+                STNodeFactory.createNodeList(fields));\n+    }\n+\n+    private List<STNode> parseKeyValues() {\n+        List<STNode> fields = new ArrayList<>();\n+        STToken nextNode = peek();\n+        while (!isNextTokenArray(nextNode)) {\n+            STNode stNode = parseKeyValue();\n+            fields.add(stNode);\n+            nextNode = peek();\n+        }\n+        return fields;\n+    }\n+\n+    private boolean isNextTokenArray(STToken nextNode) {\n+        return nextNode.kind == OPEN_BRACKET_TOKEN ||\n+                nextNode.kind == EOF_TOKEN;\n+    }\n+\n+    private STNode parseOpenBracket() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            return consume();\n+        } else {\n+            recover(token, ParserRuleContext.OPEN_BRACKET);\n+            return parseOpenBracket();\n+        }\n+    }\n+\n+    private STNode parseCloseBracket() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.CLOSE_BRACKET_TOKEN) {\n+            return consume();\n+        } else {\n+            recover(token, ParserRuleContext.CLOSE_BRACKET);\n+            return parseCloseBracket();\n+        }\n+    }\n+\n+    /**\n+     * Parsing Toml Key Value Pair. Key Value pair is constructed with Key Node, equals token and Value Node.\n+     * Ex - Key = Value\n+     *\n+     * @return KeyValueNode\n+     */\n+    private STNode parseKeyValue() {\n+        startContext(ParserRuleContext.KEY_VALUE_PAIR);\n+        STNode identifier = parseKey();\n+        STNode equals = parseEquals();\n+        STNode value = parseValue();\n+        endContext();\n+        return STNodeFactory.createKeyValue(identifier, equals, value);\n+    }\n+\n+    /**\n+     * Parses Key Node. A Key Node can be either one of the following forms\n+     * UNQUOTED_KEY_TOKEN (Regular Keys) |\n+     * BOOLEAN (True | False keyword) |\n+     * STRING_LITERAL (Quoted Keys)\n+     *\n+     * @return KeyNode\n+     */\n+    private STNode parseKey() {\n+        STToken token = peek();\n+        if (isKey(token)) {\n+            return consume();\n+        } else {\n+            recover(token, ParserRuleContext.KEY);\n+            return parseKey();\n+        }\n+    }\n+\n+    public static boolean isKey(STToken token) {\n+        switch (token.kind) {\n+            case UNQUOTED_KEY_TOKEN:\n+            case BOOLEAN:\n+            case STRING_LITERAL:\n+                return true;\n+            default:\n+                return isNumberValidKey(token);\n+        }\n+    }\n+\n+    public static boolean isNumberValidKey(STToken token) {\n+        if (isBasicValue(token)) {\n+            if (token.kind == SyntaxKind.DEC_INT || token.kind == SyntaxKind.FLOAT) {\n+                return !(token.text().startsWith(\"+\") || token.text().startsWith(\"-\"));", "originalCommit": "9034885abd79e57fc43d958bbdede9f8a7dee39c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI0NjY1OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r502246659", "bodyText": "Created #26290", "author": "xlight05", "createdAt": "2020-10-09T07:44:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU1MjcxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU1NDUzMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r501554531", "bodyText": "This condition is repeating in couple of places. Shall we extract it to a separate method?", "author": "SupunS", "createdAt": "2020-10-08T08:53:16Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java", "diffHunk": "@@ -0,0 +1,374 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.internal.parser;\n+\n+import io.ballerina.toml.internal.parser.tree.STNode;\n+import io.ballerina.toml.internal.parser.tree.STNodeFactory;\n+import io.ballerina.toml.internal.parser.tree.STToken;\n+import io.ballerina.toml.syntax.tree.SyntaxKind;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static io.ballerina.toml.syntax.tree.SyntaxKind.CLOSE_BRACKET_TOKEN;\n+import static io.ballerina.toml.syntax.tree.SyntaxKind.EOF_TOKEN;\n+import static io.ballerina.toml.syntax.tree.SyntaxKind.OPEN_BRACKET_TOKEN;\n+\n+/**\n+ * A LL(k) recursive-descent parser for TOML.\n+ *\n+ * @since 0.1.0\n+ */\n+public class TomlParser extends AbstractParser {\n+\n+    public TomlParser(AbstractTokenReader tokenReader) {\n+        super(tokenReader, new TomlParserErrorHandler(tokenReader));\n+    }\n+\n+    /**\n+     * Parse a given input and returns the AST. Starts parsing from the top of a compilation unit.\n+     *\n+     * @return Parsed node\n+     */\n+    @Override\n+    public STNode parse() {\n+        List<STNode> topLevelNodes = new ArrayList<>();\n+        STToken token = peek();\n+\n+        while (token.kind != SyntaxKind.EOF_TOKEN) {\n+            STNode decl = parseTopLevelNode();\n+            if (decl == null) {\n+                break;\n+            }\n+\n+            topLevelNodes.add(decl);\n+            token = peek();\n+        }\n+\n+        STToken eof = consume();\n+\n+        return STNodeFactory.createModulePartNode(\n+                STNodeFactory.createNodeList(topLevelNodes), eof);\n+    }\n+\n+    /**\n+     * Parse top level node given the next token kind and the modifier that precedes it.\n+     *\n+     * @return Parsed top-level node\n+     */\n+    private STNode parseTopLevelNode() {\n+        startContext(ParserRuleContext.TOP_LEVEL_NODE);\n+        STToken nextToken = peek();\n+        switch (nextToken.kind) {\n+            case EOF_TOKEN:\n+                return null;\n+            case OPEN_BRACKET_TOKEN:\n+                return processOpenBracket();\n+            case UNQUOTED_KEY_TOKEN:\n+            case STRING_LITERAL:\n+            case BOOLEAN:\n+            case DEC_INT:\n+            case FLOAT:\n+                return parseKeyValue();\n+            default:\n+                STToken token = peek();\n+                recover(token, ParserRuleContext.TOP_LEVEL_NODE);\n+\n+                return parseTopLevelNode();\n+        }\n+    }\n+\n+    /**\n+     * Parsing Array of Tables. Array of Table is a identifier surrounded by Double Open and Close Brackets.\n+     * Ex - [[ Identifier ]]\n+     *\n+     * @return TableArrayNode\n+     */\n+    private STNode parseArrayOfTables() {\n+        startContext(ParserRuleContext.TOML_TABLE_ARRAY);\n+        STNode firstOpenBracket = parseOpenBracket();\n+        STNode secondOpenBracket = parseOpenBracket();\n+        STNode identifierToken = parseKey();\n+        STNode firstCloseBracket = parseCloseBracket();\n+        STNode secondCloesBracket = parseCloseBracket();\n+        List<STNode> fields = parseKeyValues();\n+        endContext();\n+        return STNodeFactory.createTableArrayNode(firstOpenBracket, secondOpenBracket,\n+                identifierToken, firstCloseBracket, secondCloesBracket, STNodeFactory.createNodeList(fields));\n+    }\n+\n+    private STNode processOpenBracket() {\n+        STToken token = peek(2);\n+        if (token.kind == OPEN_BRACKET_TOKEN) {\n+            return parseArrayOfTables();\n+        } else {\n+            return parseTable();\n+        }\n+    }\n+\n+    /**\n+     * Parsing TOML Table. Table is a identifier surrounded by Open and Close Brackets.\n+     * Ex - [ Identifier ]\n+     *\n+     * @return TableNode\n+     */\n+    private STNode parseTable() {\n+        startContext(ParserRuleContext.TOML_TABLE);\n+        STNode openBracket = parseOpenBracket();\n+        STNode identifierToken = parseKey();\n+        STNode closedBracket = parseCloseBracket();\n+        List<STNode> fields = parseKeyValues();\n+        endContext();\n+        return STNodeFactory.createTableNode(openBracket, identifierToken, closedBracket,\n+                STNodeFactory.createNodeList(fields));\n+    }\n+\n+    private List<STNode> parseKeyValues() {\n+        List<STNode> fields = new ArrayList<>();\n+        STToken nextNode = peek();\n+        while (!isNextTokenArray(nextNode)) {\n+            STNode stNode = parseKeyValue();\n+            fields.add(stNode);\n+            nextNode = peek();\n+        }\n+        return fields;\n+    }\n+\n+    private boolean isNextTokenArray(STToken nextNode) {\n+        return nextNode.kind == OPEN_BRACKET_TOKEN ||\n+                nextNode.kind == EOF_TOKEN;\n+    }\n+\n+    private STNode parseOpenBracket() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            return consume();\n+        } else {\n+            recover(token, ParserRuleContext.OPEN_BRACKET);\n+            return parseOpenBracket();\n+        }\n+    }\n+\n+    private STNode parseCloseBracket() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.CLOSE_BRACKET_TOKEN) {\n+            return consume();\n+        } else {\n+            recover(token, ParserRuleContext.CLOSE_BRACKET);\n+            return parseCloseBracket();\n+        }\n+    }\n+\n+    /**\n+     * Parsing Toml Key Value Pair. Key Value pair is constructed with Key Node, equals token and Value Node.\n+     * Ex - Key = Value\n+     *\n+     * @return KeyValueNode\n+     */\n+    private STNode parseKeyValue() {\n+        startContext(ParserRuleContext.KEY_VALUE_PAIR);\n+        STNode identifier = parseKey();\n+        STNode equals = parseEquals();\n+        STNode value = parseValue();\n+        endContext();\n+        return STNodeFactory.createKeyValue(identifier, equals, value);\n+    }\n+\n+    /**\n+     * Parses Key Node. A Key Node can be either one of the following forms\n+     * UNQUOTED_KEY_TOKEN (Regular Keys) |\n+     * BOOLEAN (True | False keyword) |\n+     * STRING_LITERAL (Quoted Keys)\n+     *\n+     * @return KeyNode\n+     */\n+    private STNode parseKey() {\n+        STToken token = peek();\n+        if (isKey(token)) {\n+            return consume();\n+        } else {\n+            recover(token, ParserRuleContext.KEY);\n+            return parseKey();\n+        }\n+    }\n+\n+    public static boolean isKey(STToken token) {\n+        switch (token.kind) {\n+            case UNQUOTED_KEY_TOKEN:\n+            case BOOLEAN:\n+            case STRING_LITERAL:\n+                return true;\n+            default:\n+                return isNumberValidKey(token);\n+        }\n+    }\n+\n+    public static boolean isNumberValidKey(STToken token) {\n+        if (isBasicValue(token)) {\n+            if (token.kind == SyntaxKind.DEC_INT || token.kind == SyntaxKind.FLOAT) {\n+                return !(token.text().startsWith(\"+\") || token.text().startsWith(\"-\"));\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private STNode parseEquals() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.EQUAL_TOKEN) {\n+            return consume();\n+        } else {\n+            recover(token, ParserRuleContext.ASSIGN_OP);\n+            return parseEquals();\n+        }\n+    }\n+\n+    /**\n+     * Parses Value Node. A Value Node can be either one of the following forms\n+     * Basic Values\n+     * STRING_LITERAL (Single Line String) |\n+     * ML_STRING_LITERAL (Multiline String) |\n+     * DEC_INT (Decimal Integer) |\n+     * FLOAT (Float) |\n+     * BOOLEAN |\n+     * BASIC_LITERAL (Recovery purposes)\n+     * Arrays\n+     *\n+     * @return ValueNode\n+     */\n+    private STNode parseValue() {\n+        STToken token = peek();\n+        if (isBasicValue(token)) {\n+            return STNodeFactory.createBasicValueNode(token.kind, consume());\n+        } else if (token.kind == OPEN_BRACKET_TOKEN) {\n+            return parseArray();\n+        } else {\n+            recover(token, ParserRuleContext.VALUE);\n+            return parseValue();\n+        }\n+    }\n+\n+    /**\n+     * Parsing Array Value. Array is surrounded by Single brackets.Array can contains any basic values and other arrays.\n+     * * Basic Values\n+     * * STRING_LITERAL (Single Line String) |\n+     * * ML_STRING_LITERAL (Multiline String) |\n+     * * DEC_INT (Decimal Integer) |\n+     * * FLOAT (Float) |\n+     * * BOOLEAN |\n+     * * BASIC_LITERAL (Recovery purposes)\n+     * * Arrays\n+     *\n+     * @return ArrayNode\n+     */\n+    private STNode parseArray() {\n+        startContext(ParserRuleContext.TOML_ARRAY);\n+        STNode openBracket = parseOpenBracket();\n+        STNode values = parseArrayValues();\n+        STNode closeBracket = parseCloseBracket();\n+        endContext();\n+        return STNodeFactory.createArray(openBracket, values, closeBracket);\n+    }\n+\n+    private STNode parseArrayValues() {\n+        startContext(ParserRuleContext.ARG_LIST);\n+        STToken token = peek();\n+\n+        if (token.kind == SyntaxKind.CLOSE_BRACKET_TOKEN || token.kind == EOF_TOKEN) {", "originalCommit": "9034885abd79e57fc43d958bbdede9f8a7dee39c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU1NTQ3MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r501555470", "bodyText": "It is not correct to call these 'arguments'. How about 'parseArrayValues'.\nbetter to replace all places where we have used 'arg' to 'arrayEntry'", "author": "SupunS", "createdAt": "2020-10-08T08:54:46Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/TomlParser.java", "diffHunk": "@@ -0,0 +1,374 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.toml.internal.parser;\n+\n+import io.ballerina.toml.internal.parser.tree.STNode;\n+import io.ballerina.toml.internal.parser.tree.STNodeFactory;\n+import io.ballerina.toml.internal.parser.tree.STToken;\n+import io.ballerina.toml.syntax.tree.SyntaxKind;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static io.ballerina.toml.syntax.tree.SyntaxKind.CLOSE_BRACKET_TOKEN;\n+import static io.ballerina.toml.syntax.tree.SyntaxKind.EOF_TOKEN;\n+import static io.ballerina.toml.syntax.tree.SyntaxKind.OPEN_BRACKET_TOKEN;\n+\n+/**\n+ * A LL(k) recursive-descent parser for TOML.\n+ *\n+ * @since 0.1.0\n+ */\n+public class TomlParser extends AbstractParser {\n+\n+    public TomlParser(AbstractTokenReader tokenReader) {\n+        super(tokenReader, new TomlParserErrorHandler(tokenReader));\n+    }\n+\n+    /**\n+     * Parse a given input and returns the AST. Starts parsing from the top of a compilation unit.\n+     *\n+     * @return Parsed node\n+     */\n+    @Override\n+    public STNode parse() {\n+        List<STNode> topLevelNodes = new ArrayList<>();\n+        STToken token = peek();\n+\n+        while (token.kind != SyntaxKind.EOF_TOKEN) {\n+            STNode decl = parseTopLevelNode();\n+            if (decl == null) {\n+                break;\n+            }\n+\n+            topLevelNodes.add(decl);\n+            token = peek();\n+        }\n+\n+        STToken eof = consume();\n+\n+        return STNodeFactory.createModulePartNode(\n+                STNodeFactory.createNodeList(topLevelNodes), eof);\n+    }\n+\n+    /**\n+     * Parse top level node given the next token kind and the modifier that precedes it.\n+     *\n+     * @return Parsed top-level node\n+     */\n+    private STNode parseTopLevelNode() {\n+        startContext(ParserRuleContext.TOP_LEVEL_NODE);\n+        STToken nextToken = peek();\n+        switch (nextToken.kind) {\n+            case EOF_TOKEN:\n+                return null;\n+            case OPEN_BRACKET_TOKEN:\n+                return processOpenBracket();\n+            case UNQUOTED_KEY_TOKEN:\n+            case STRING_LITERAL:\n+            case BOOLEAN:\n+            case DEC_INT:\n+            case FLOAT:\n+                return parseKeyValue();\n+            default:\n+                STToken token = peek();\n+                recover(token, ParserRuleContext.TOP_LEVEL_NODE);\n+\n+                return parseTopLevelNode();\n+        }\n+    }\n+\n+    /**\n+     * Parsing Array of Tables. Array of Table is a identifier surrounded by Double Open and Close Brackets.\n+     * Ex - [[ Identifier ]]\n+     *\n+     * @return TableArrayNode\n+     */\n+    private STNode parseArrayOfTables() {\n+        startContext(ParserRuleContext.TOML_TABLE_ARRAY);\n+        STNode firstOpenBracket = parseOpenBracket();\n+        STNode secondOpenBracket = parseOpenBracket();\n+        STNode identifierToken = parseKey();\n+        STNode firstCloseBracket = parseCloseBracket();\n+        STNode secondCloesBracket = parseCloseBracket();\n+        List<STNode> fields = parseKeyValues();\n+        endContext();\n+        return STNodeFactory.createTableArrayNode(firstOpenBracket, secondOpenBracket,\n+                identifierToken, firstCloseBracket, secondCloesBracket, STNodeFactory.createNodeList(fields));\n+    }\n+\n+    private STNode processOpenBracket() {\n+        STToken token = peek(2);\n+        if (token.kind == OPEN_BRACKET_TOKEN) {\n+            return parseArrayOfTables();\n+        } else {\n+            return parseTable();\n+        }\n+    }\n+\n+    /**\n+     * Parsing TOML Table. Table is a identifier surrounded by Open and Close Brackets.\n+     * Ex - [ Identifier ]\n+     *\n+     * @return TableNode\n+     */\n+    private STNode parseTable() {\n+        startContext(ParserRuleContext.TOML_TABLE);\n+        STNode openBracket = parseOpenBracket();\n+        STNode identifierToken = parseKey();\n+        STNode closedBracket = parseCloseBracket();\n+        List<STNode> fields = parseKeyValues();\n+        endContext();\n+        return STNodeFactory.createTableNode(openBracket, identifierToken, closedBracket,\n+                STNodeFactory.createNodeList(fields));\n+    }\n+\n+    private List<STNode> parseKeyValues() {\n+        List<STNode> fields = new ArrayList<>();\n+        STToken nextNode = peek();\n+        while (!isNextTokenArray(nextNode)) {\n+            STNode stNode = parseKeyValue();\n+            fields.add(stNode);\n+            nextNode = peek();\n+        }\n+        return fields;\n+    }\n+\n+    private boolean isNextTokenArray(STToken nextNode) {\n+        return nextNode.kind == OPEN_BRACKET_TOKEN ||\n+                nextNode.kind == EOF_TOKEN;\n+    }\n+\n+    private STNode parseOpenBracket() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.OPEN_BRACKET_TOKEN) {\n+            return consume();\n+        } else {\n+            recover(token, ParserRuleContext.OPEN_BRACKET);\n+            return parseOpenBracket();\n+        }\n+    }\n+\n+    private STNode parseCloseBracket() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.CLOSE_BRACKET_TOKEN) {\n+            return consume();\n+        } else {\n+            recover(token, ParserRuleContext.CLOSE_BRACKET);\n+            return parseCloseBracket();\n+        }\n+    }\n+\n+    /**\n+     * Parsing Toml Key Value Pair. Key Value pair is constructed with Key Node, equals token and Value Node.\n+     * Ex - Key = Value\n+     *\n+     * @return KeyValueNode\n+     */\n+    private STNode parseKeyValue() {\n+        startContext(ParserRuleContext.KEY_VALUE_PAIR);\n+        STNode identifier = parseKey();\n+        STNode equals = parseEquals();\n+        STNode value = parseValue();\n+        endContext();\n+        return STNodeFactory.createKeyValue(identifier, equals, value);\n+    }\n+\n+    /**\n+     * Parses Key Node. A Key Node can be either one of the following forms\n+     * UNQUOTED_KEY_TOKEN (Regular Keys) |\n+     * BOOLEAN (True | False keyword) |\n+     * STRING_LITERAL (Quoted Keys)\n+     *\n+     * @return KeyNode\n+     */\n+    private STNode parseKey() {\n+        STToken token = peek();\n+        if (isKey(token)) {\n+            return consume();\n+        } else {\n+            recover(token, ParserRuleContext.KEY);\n+            return parseKey();\n+        }\n+    }\n+\n+    public static boolean isKey(STToken token) {\n+        switch (token.kind) {\n+            case UNQUOTED_KEY_TOKEN:\n+            case BOOLEAN:\n+            case STRING_LITERAL:\n+                return true;\n+            default:\n+                return isNumberValidKey(token);\n+        }\n+    }\n+\n+    public static boolean isNumberValidKey(STToken token) {\n+        if (isBasicValue(token)) {\n+            if (token.kind == SyntaxKind.DEC_INT || token.kind == SyntaxKind.FLOAT) {\n+                return !(token.text().startsWith(\"+\") || token.text().startsWith(\"-\"));\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private STNode parseEquals() {\n+        STToken token = peek();\n+        if (token.kind == SyntaxKind.EQUAL_TOKEN) {\n+            return consume();\n+        } else {\n+            recover(token, ParserRuleContext.ASSIGN_OP);\n+            return parseEquals();\n+        }\n+    }\n+\n+    /**\n+     * Parses Value Node. A Value Node can be either one of the following forms\n+     * Basic Values\n+     * STRING_LITERAL (Single Line String) |\n+     * ML_STRING_LITERAL (Multiline String) |\n+     * DEC_INT (Decimal Integer) |\n+     * FLOAT (Float) |\n+     * BOOLEAN |\n+     * BASIC_LITERAL (Recovery purposes)\n+     * Arrays\n+     *\n+     * @return ValueNode\n+     */\n+    private STNode parseValue() {\n+        STToken token = peek();\n+        if (isBasicValue(token)) {\n+            return STNodeFactory.createBasicValueNode(token.kind, consume());\n+        } else if (token.kind == OPEN_BRACKET_TOKEN) {\n+            return parseArray();\n+        } else {\n+            recover(token, ParserRuleContext.VALUE);\n+            return parseValue();\n+        }\n+    }\n+\n+    /**\n+     * Parsing Array Value. Array is surrounded by Single brackets.Array can contains any basic values and other arrays.\n+     * * Basic Values\n+     * * STRING_LITERAL (Single Line String) |\n+     * * ML_STRING_LITERAL (Multiline String) |\n+     * * DEC_INT (Decimal Integer) |\n+     * * FLOAT (Float) |\n+     * * BOOLEAN |\n+     * * BASIC_LITERAL (Recovery purposes)\n+     * * Arrays\n+     *\n+     * @return ArrayNode\n+     */\n+    private STNode parseArray() {\n+        startContext(ParserRuleContext.TOML_ARRAY);\n+        STNode openBracket = parseOpenBracket();\n+        STNode values = parseArrayValues();\n+        STNode closeBracket = parseCloseBracket();\n+        endContext();\n+        return STNodeFactory.createArray(openBracket, values, closeBracket);\n+    }\n+\n+    private STNode parseArrayValues() {\n+        startContext(ParserRuleContext.ARG_LIST);\n+        STToken token = peek();\n+\n+        if (token.kind == SyntaxKind.CLOSE_BRACKET_TOKEN || token.kind == EOF_TOKEN) {\n+            STNode args = STNodeFactory.createEmptyNodeList();\n+            endContext();\n+            return args;\n+        }\n+\n+        STNode firstArg = parseArgument();\n+        if (firstArg == null) {\n+            return STNodeFactory.createEmptyNodeList();\n+        }\n+\n+        return parseArgList(firstArg);\n+    }\n+\n+    private STNode parseArgList(STNode firstArg) {", "originalCommit": "9034885abd79e57fc43d958bbdede9f8a7dee39c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU2MDcwNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r501560707", "bodyText": "Hardcoding the asserts is not scaling in long term. Can we use the same approach as in the parser tests?", "author": "SupunS", "createdAt": "2020-10-08T09:02:33Z", "path": "misc/toml-parser/src/test/java/toml/parser/test/core/KeyValueTest.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package toml.parser.test.core;\n+\n+import io.ballerina.toml.api.Toml;\n+import io.ballerina.toml.ast.TomlArrayValueNode;\n+import io.ballerina.toml.ast.TomlBooleanValueNode;\n+import io.ballerina.toml.ast.TomlDoubleValueNodeNode;\n+import io.ballerina.toml.ast.TomlLongValueNode;\n+import io.ballerina.toml.ast.TomlStringValueNode;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Basic Test for TOML Key Value Pairs.\n+ */\n+public class KeyValueTest {\n+\n+    @Test\n+    public void testKeys() throws IOException {\n+        InputStream inputStream = Thread.currentThread().getContextClassLoader()\n+                .getResourceAsStream(\"core/keys.toml\");\n+        Toml read = Toml.read(inputStream);\n+        String basicKey = ((TomlStringValueNode) read.get(\"key\")).getValue();\n+        String underscoreKey = ((TomlStringValueNode) read.get(\"underscore_key\")).getValue();\n+        String dashKey = ((TomlStringValueNode) read.get(\"dash-key\")).getValue();\n+        String intKey = ((TomlStringValueNode) read.get(\"1234\")).getValue();\n+\n+        String dottedString =\n+                ((TomlStringValueNode) read.getTable(\"127\").getTable(\"0\").getTable(\"0\").get(\"1\")).getValue();\n+        String spacing = ((TomlStringValueNode) read.get(\"character encoding\")).getValue();\n+        String unicode = ((TomlStringValueNode) read.get(\"\u028e\u01dd\u029e\")).getValue();\n+        String general = ((TomlStringValueNode) read.get(\"key2\")).getValue();\n+        String escape = ((TomlStringValueNode) read.get(\"quoted \\\"value\\\"\")).getValue();\n+\n+        Assert.assertEquals(basicKey, \"basic key\");\n+        Assert.assertEquals(underscoreKey, \"Underscore Key\");\n+        Assert.assertEquals(dashKey, \"Dash Key\");\n+        Assert.assertEquals(intKey, \"Int Key\");\n+\n+        Assert.assertEquals(dottedString, \"value\");\n+        Assert.assertEquals(spacing, \"value\");\n+        Assert.assertEquals(unicode, \"value\");\n+        Assert.assertEquals(general, \"value\");\n+        Assert.assertEquals(escape, \"value\");", "originalCommit": "9034885abd79e57fc43d958bbdede9f8a7dee39c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjI1MDI0OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r502250249", "bodyText": "Created. #26291", "author": "xlight05", "createdAt": "2020-10-09T07:51:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU2MDcwNw=="}], "type": "inlineReview"}, {"oid": "92847de548c9a53405fb59f46748e7a866edb821", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/92847de548c9a53405fb59f46748e7a866edb821", "message": "Fix Review Changes, String changes", "committedDate": "2020-10-12T02:51:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAyMzY3NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r503023675", "bodyText": "Look like these are tokens? In that case add the Token suffix.\nAlso, these should not be used for any non-terminal nodes. (e.g: BOOLEAN is used for both the token and the non-terminal node, which is not correct)", "author": "SupunS", "createdAt": "2020-10-12T03:45:12Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/syntax/tree/SyntaxKind.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package io.ballerina.toml.syntax.tree;\n+\n+/**\n+ * Define various kinds of syntax tree nodes, tokens and minutiae.\n+ *\n+ * @since 2.0.0\n+ */\n+public enum SyntaxKind {\n+\n+    MODULE_NAME(3014),\n+\n+    TRUE_KEYWORD(203, \"true\"),\n+    FALSE_KEYWORD(204, \"false\"),\n+\n+    // Separators\n+    OPEN_BRACE_TOKEN(500, \"{\"),\n+    CLOSE_BRACE_TOKEN(501, \"}\"),\n+    OPEN_PAREN_TOKEN(502, \"(\"),\n+    CLOSE_PAREN_TOKEN(503, \")\"),\n+    OPEN_BRACKET_TOKEN(504, \"[\"),\n+    CLOSE_BRACKET_TOKEN(505, \"]\"),\n+    SEMICOLON_TOKEN(506, \";\"),\n+    DOT_TOKEN(507, \".\"),\n+    COLON_TOKEN(508, \":\"),\n+    COMMA_TOKEN(509, \",\"),\n+    ELLIPSIS_TOKEN(510, \"...\"),\n+    OPEN_BRACE_PIPE_TOKEN(511, \"{|\"),\n+    CLOSE_BRACE_PIPE_TOKEN(512, \"|}\"),\n+    AT_TOKEN(513, \"@\"),\n+    HASH_TOKEN(514, \"#\"),\n+    BACKTICK_TOKEN(515, \"`\"),\n+    DOUBLE_QUOTE_TOKEN(516, \"\\\"\"),\n+    SINGLE_QUOTE_TOKEN(517, \"'\"),\n+    TRIPLE_DOUBLE_QUOTE_TOKEN(518, \"\\\"\\\"\\\"\"),\n+    TRIPLE_SINGLE_QUOTE_TOKEN(519, \"'''\"),\n+\n+    // Operators\n+    EQUAL_TOKEN(550, \"=\"),\n+    PLUS_TOKEN(553, \"+\"),\n+    MINUS_TOKEN(554, \"-\"),\n+\n+    UNQUOTED_KEY_TOKEN(1000),\n+    STRING_LITERAL(1001),\n+    DECIMAL_INTEGER_LITERAL(1002),\n+    HEX_INTEGER_LITERAL(1003),\n+    DECIMAL_FLOATING_POINT_LITERAL(1004),\n+    HEX_FLOATING_POINT_LITERAL(1005),\n+    XML_TEXT_CONTENT(1006),\n+    TEMPLATE_STRING(1007),\n+\n+    // Minutiae kinds\n+    WHITESPACE_MINUTIAE(1500),\n+    END_OF_LINE_MINUTIAE(1501),\n+    COMMENT_MINUTIAE(1502),\n+    INVALID_NODE_MINUTIAE(1503),\n+\n+    // Invalid nodes\n+    INVALID_TOKEN(1600),\n+\n+\n+    // Documentation\n+    MARKDOWN_DOCUMENTATION_LINE(4505),\n+    DOCUMENTATION_DESCRIPTION(4506),\n+    DOCUMENTATION_REFERENCE(4507),\n+    PARAMETER_NAME(4508),\n+    BACKTICK_CONTENT(4509),\n+    DEPRECATION_LITERAL(4510),\n+    DOCUMENTATION_STRING(4511),\n+\n+\n+    //TOML\n+    TABLE(4800),\n+    KEY_VALUE(4801),\n+    TABLE_ARRAY(4804),\n+    DATATYPE(4805),\n+\n+\n+    //NEW\n+\n+    SIGNED_NUMERICAL(4806),\n+    UNSIGNED_NUMERICAL(4807),\n+\n+    BASIC_LITERAL(4808),\n+    KEY(4809),\n+\n+    //Int\n+    DEC_INT(4810),\n+    HEX_INT(4811),\n+    OCT_INT(4812),\n+    BIN_INT(4813),\n+\n+    //Float\n+    FLOAT(4814),\n+    INF(4815, \"inf\"),\n+    NAN(4816, \"nan\"),\n+\n+    //String\n+    ML_STRING_LITERAL(4818),\n+\n+    //Bool\n+    BOOLEAN (4821),\n+\n+    //Date and Time\n+    OFFSET_DATE_TIME (4821),\n+    LOCAL_DATE_TIME (4822),\n+    LOCAL_DATE (4823),\n+    LOCAL_TIME (4824),", "originalCommit": "92847de548c9a53405fb59f46748e7a866edb821", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e749a7d6c1d93d5d1dedbd20c72247715ceabd3c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e749a7d6c1d93d5d1dedbd20c72247715ceabd3c", "message": "Initial TOML Parser implementation\n\nAdd Error recovery", "committedDate": "2020-10-12T05:41:22Z", "type": "commit"}, {"oid": "8382d50ddf2627b797fbd7c7e370a4a91987808c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8382d50ddf2627b797fbd7c7e370a4a91987808c", "message": "Implement initial Semantic Analyser", "committedDate": "2020-10-12T05:41:22Z", "type": "commit"}, {"oid": "66f902dce19d1fe0b547391946a85a92afa3e06c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/66f902dce19d1fe0b547391946a85a92afa3e06c", "message": "Add new AST Impl", "committedDate": "2020-10-12T05:41:22Z", "type": "commit"}, {"oid": "1990167456128ad2a2a05354d26818dd639fee32", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1990167456128ad2a2a05354d26818dd639fee32", "message": "Fix error handling for arrays and address review comments", "committedDate": "2020-10-12T05:41:22Z", "type": "commit"}, {"oid": "91bbca0d5af3a9563aca21cc2cf4a280b5e1861d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/91bbca0d5af3a9563aca21cc2cf4a280b5e1861d", "message": "Restrict dotted strings from API", "committedDate": "2020-10-12T05:41:22Z", "type": "commit"}, {"oid": "8388bbc57d814abdbb87b649633c3cfbcb4d3860", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8388bbc57d814abdbb87b649633c3cfbcb4d3860", "message": "Change API and Add Multi array support", "committedDate": "2020-10-12T05:41:22Z", "type": "commit"}, {"oid": "8bef9d2fb2a0d6994e7650efb2c77dae25c6d9c8", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8bef9d2fb2a0d6994e7650efb2c77dae25c6d9c8", "message": "Fix Review Changes, String changes", "committedDate": "2020-10-12T05:41:22Z", "type": "forcePushed"}, {"oid": "08dc97e6c362201784a1ed1b9b80b15148db930b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/08dc97e6c362201784a1ed1b9b80b15148db930b", "message": "Fix Review Changes, String changes", "committedDate": "2020-10-12T06:08:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA5NzY0Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r503097642", "bodyText": "Let's refactor this to have early returns", "author": "nadeeshaan", "createdAt": "2020-10-12T07:42:56Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package io.ballerina.toml.api;\n+\n+import io.ballerina.toml.semantic.TomlType;\n+import io.ballerina.toml.semantic.ast.TomlKeyValueNode;\n+import io.ballerina.toml.semantic.ast.TomlTableArrayNode;\n+import io.ballerina.toml.semantic.ast.TomlTableNode;\n+import io.ballerina.toml.semantic.ast.TomlTransformer;\n+import io.ballerina.toml.semantic.ast.TomlValueNode;\n+import io.ballerina.toml.semantic.ast.TopLevelNode;\n+import io.ballerina.toml.semantic.diagnostics.TomlDiagnostic;\n+import io.ballerina.toml.semantic.diagnostics.TomlNodeLocation;\n+import io.ballerina.toml.syntax.tree.DocumentNode;\n+import io.ballerina.toml.syntax.tree.SyntaxTree;\n+import io.ballerina.tools.diagnostics.Diagnostic;\n+import io.ballerina.tools.text.TextDocument;\n+import io.ballerina.tools.text.TextDocuments;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * API For Parsing Tom's Obvious, Minimal Language (TOML) file.\n+ *\n+ * @since 2.0.0\n+ */\n+@Deprecated\n+public class Toml {\n+\n+    private TomlTableNode rootNode;\n+\n+    /**\n+     * Creates new Root TOML Node from AST.\n+     *\n+     * @param tomlTableNode AST representation of TOML Table.\n+     */\n+    private Toml(TomlTableNode tomlTableNode) {\n+        this.rootNode = tomlTableNode;\n+    }\n+\n+    /**\n+     * Read TOML File using Path.\n+     *\n+     * @param path Path of the TOML file\n+     * @return TOML Object\n+     * @throws IOException if file is not accessible\n+     */\n+    public static Toml read(Path path) throws IOException {\n+        return read(Files.newBufferedReader(path));\n+    }\n+\n+    /**\n+     * Read TOML File using InputStream.\n+     *\n+     * @param inputStream InputStream of the TOML file\n+     * @return TOML Object\n+     * @throws IOException if file is not accessible\n+     */\n+    public static Toml read(InputStream inputStream) throws IOException {\n+        return read(new InputStreamReader(inputStream, StandardCharsets.UTF_8));\n+    }\n+\n+    /**\n+     * Read TOML File using Reader.\n+     *\n+     * @param reader reader of the TOML file\n+     * @return TOML Object\n+     * @throws IOException if file is not accessible\n+     */\n+    public static Toml read(Reader reader) throws IOException {\n+        BufferedReader bufferedReader = new BufferedReader(reader);\n+        StringBuilder w = new StringBuilder();\n+        for (String line = bufferedReader.readLine(); line != null; line = bufferedReader.readLine()) {\n+            w.append(line).append('\\n');\n+        }\n+        return read(w.toString());\n+    }\n+\n+    /**\n+     * Parse TOML file using TOML String.\n+     *\n+     * @param content String representation of the TOML file content.\n+     * @return TOML Object\n+     */\n+    public static Toml read(String content) {\n+        TextDocument textDocument = TextDocuments.from(content);\n+        SyntaxTree syntaxTree = SyntaxTree.from(textDocument);\n+        List<TomlDiagnostic> tomlDiagnostics = reportSyntaxDiagnostics(syntaxTree);\n+        TomlTransformer nodeTransformer = new TomlTransformer();\n+        TomlTableNode\n+                transformedTable = (TomlTableNode) nodeTransformer.transform((DocumentNode) syntaxTree.rootNode());\n+        transformedTable.setSyntacticalDiagnostics(tomlDiagnostics);\n+        tomlDiagnostics.addAll(transformedTable.collectSemanticDiagnostics());\n+        return new Toml(transformedTable);\n+    }\n+\n+    private static List<TomlDiagnostic> reportSyntaxDiagnostics(SyntaxTree tree) {\n+        List<TomlDiagnostic> diagnostics = new ArrayList<>();\n+        for (Diagnostic syntaxDiagnostic : tree.diagnostics()) {\n+            TomlNodeLocation tomlNodeLocation = new TomlNodeLocation(syntaxDiagnostic.location().lineRange(),\n+                    syntaxDiagnostic.location().textRange());\n+            TomlDiagnostic tomlDiagnostic =\n+                    new TomlDiagnostic(tomlNodeLocation, syntaxDiagnostic.diagnosticInfo(), syntaxDiagnostic.message());\n+            diagnostics.add(tomlDiagnostic);\n+        }\n+        return diagnostics;\n+    }\n+\n+    /**\n+     * Get value from a key of a Key Value pair.\n+     *\n+     * @param key key name\n+     * @param <T> Type of the AST Value Node\n+     * @return AST Value Node\n+     */\n+    public <T extends TomlValueNode> T get(String key) {\n+        TomlKeyValueNode tomlKeyValueNode = (TomlKeyValueNode) rootNode.children().get(key);\n+        if (tomlKeyValueNode != null) {\n+            TomlValueNode value = tomlKeyValueNode.value();\n+            if (value != null) {\n+                return (T) value;\n+            }\n+        }", "originalCommit": "08dc97e6c362201784a1ed1b9b80b15148db930b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5de2f8814fb34c2c9cedbe3235800f93fcaa9951", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5de2f8814fb34c2c9cedbe3235800f93fcaa9951", "message": "Fix Review Changes, String changes", "committedDate": "2020-10-12T08:06:29Z", "type": "commit"}, {"oid": "5de2f8814fb34c2c9cedbe3235800f93fcaa9951", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5de2f8814fb34c2c9cedbe3235800f93fcaa9951", "message": "Fix Review Changes, String changes", "committedDate": "2020-10-12T08:06:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA5ODEwMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r503098102", "bodyText": "What's the possibility of having an Optional as return. Otherwise there is a chance for missing null checks when using this API", "author": "nadeeshaan", "createdAt": "2020-10-12T07:43:44Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package io.ballerina.toml.api;\n+\n+import io.ballerina.toml.semantic.TomlType;\n+import io.ballerina.toml.semantic.ast.TomlKeyValueNode;\n+import io.ballerina.toml.semantic.ast.TomlTableArrayNode;\n+import io.ballerina.toml.semantic.ast.TomlTableNode;\n+import io.ballerina.toml.semantic.ast.TomlTransformer;\n+import io.ballerina.toml.semantic.ast.TomlValueNode;\n+import io.ballerina.toml.semantic.ast.TopLevelNode;\n+import io.ballerina.toml.semantic.diagnostics.TomlDiagnostic;\n+import io.ballerina.toml.semantic.diagnostics.TomlNodeLocation;\n+import io.ballerina.toml.syntax.tree.DocumentNode;\n+import io.ballerina.toml.syntax.tree.SyntaxTree;\n+import io.ballerina.tools.diagnostics.Diagnostic;\n+import io.ballerina.tools.text.TextDocument;\n+import io.ballerina.tools.text.TextDocuments;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * API For Parsing Tom's Obvious, Minimal Language (TOML) file.\n+ *\n+ * @since 2.0.0\n+ */\n+@Deprecated\n+public class Toml {\n+\n+    private TomlTableNode rootNode;\n+\n+    /**\n+     * Creates new Root TOML Node from AST.\n+     *\n+     * @param tomlTableNode AST representation of TOML Table.\n+     */\n+    private Toml(TomlTableNode tomlTableNode) {\n+        this.rootNode = tomlTableNode;\n+    }\n+\n+    /**\n+     * Read TOML File using Path.\n+     *\n+     * @param path Path of the TOML file\n+     * @return TOML Object\n+     * @throws IOException if file is not accessible\n+     */\n+    public static Toml read(Path path) throws IOException {\n+        return read(Files.newBufferedReader(path));\n+    }\n+\n+    /**\n+     * Read TOML File using InputStream.\n+     *\n+     * @param inputStream InputStream of the TOML file\n+     * @return TOML Object\n+     * @throws IOException if file is not accessible\n+     */\n+    public static Toml read(InputStream inputStream) throws IOException {\n+        return read(new InputStreamReader(inputStream, StandardCharsets.UTF_8));\n+    }\n+\n+    /**\n+     * Read TOML File using Reader.\n+     *\n+     * @param reader reader of the TOML file\n+     * @return TOML Object\n+     * @throws IOException if file is not accessible\n+     */\n+    public static Toml read(Reader reader) throws IOException {\n+        BufferedReader bufferedReader = new BufferedReader(reader);\n+        StringBuilder w = new StringBuilder();\n+        for (String line = bufferedReader.readLine(); line != null; line = bufferedReader.readLine()) {\n+            w.append(line).append('\\n');\n+        }\n+        return read(w.toString());\n+    }\n+\n+    /**\n+     * Parse TOML file using TOML String.\n+     *\n+     * @param content String representation of the TOML file content.\n+     * @return TOML Object\n+     */\n+    public static Toml read(String content) {\n+        TextDocument textDocument = TextDocuments.from(content);\n+        SyntaxTree syntaxTree = SyntaxTree.from(textDocument);\n+        List<TomlDiagnostic> tomlDiagnostics = reportSyntaxDiagnostics(syntaxTree);\n+        TomlTransformer nodeTransformer = new TomlTransformer();\n+        TomlTableNode\n+                transformedTable = (TomlTableNode) nodeTransformer.transform((DocumentNode) syntaxTree.rootNode());\n+        transformedTable.setSyntacticalDiagnostics(tomlDiagnostics);\n+        tomlDiagnostics.addAll(transformedTable.collectSemanticDiagnostics());\n+        return new Toml(transformedTable);\n+    }\n+\n+    private static List<TomlDiagnostic> reportSyntaxDiagnostics(SyntaxTree tree) {\n+        List<TomlDiagnostic> diagnostics = new ArrayList<>();\n+        for (Diagnostic syntaxDiagnostic : tree.diagnostics()) {\n+            TomlNodeLocation tomlNodeLocation = new TomlNodeLocation(syntaxDiagnostic.location().lineRange(),\n+                    syntaxDiagnostic.location().textRange());\n+            TomlDiagnostic tomlDiagnostic =\n+                    new TomlDiagnostic(tomlNodeLocation, syntaxDiagnostic.diagnosticInfo(), syntaxDiagnostic.message());\n+            diagnostics.add(tomlDiagnostic);\n+        }\n+        return diagnostics;\n+    }\n+\n+    /**\n+     * Get value from a key of a Key Value pair.\n+     *\n+     * @param key key name\n+     * @param <T> Type of the AST Value Node\n+     * @return AST Value Node\n+     */\n+    public <T extends TomlValueNode> T get(String key) {\n+        TomlKeyValueNode tomlKeyValueNode = (TomlKeyValueNode) rootNode.children().get(key);\n+        if (tomlKeyValueNode != null) {\n+            TomlValueNode value = tomlKeyValueNode.value();\n+            if (value != null) {\n+                return (T) value;\n+            }\n+        }\n+        return null;", "originalCommit": "08dc97e6c362201784a1ed1b9b80b15148db930b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE5NTg3OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r514195879", "bodyText": "We've decided not to use optionals to allow easy chaining between tables and keys.\nex - read.getTable(\"products\").get(\"hello1\").\nHowever this API will be revisited with the upcoming AST changes.", "author": "xlight05", "createdAt": "2020-10-29T11:44:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA5ODEwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA5ODM3Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r503098373", "bodyText": "Use early return here and also check the possibility of using Optional return here", "author": "nadeeshaan", "createdAt": "2020-10-12T07:44:18Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package io.ballerina.toml.api;\n+\n+import io.ballerina.toml.semantic.TomlType;\n+import io.ballerina.toml.semantic.ast.TomlKeyValueNode;\n+import io.ballerina.toml.semantic.ast.TomlTableArrayNode;\n+import io.ballerina.toml.semantic.ast.TomlTableNode;\n+import io.ballerina.toml.semantic.ast.TomlTransformer;\n+import io.ballerina.toml.semantic.ast.TomlValueNode;\n+import io.ballerina.toml.semantic.ast.TopLevelNode;\n+import io.ballerina.toml.semantic.diagnostics.TomlDiagnostic;\n+import io.ballerina.toml.semantic.diagnostics.TomlNodeLocation;\n+import io.ballerina.toml.syntax.tree.DocumentNode;\n+import io.ballerina.toml.syntax.tree.SyntaxTree;\n+import io.ballerina.tools.diagnostics.Diagnostic;\n+import io.ballerina.tools.text.TextDocument;\n+import io.ballerina.tools.text.TextDocuments;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * API For Parsing Tom's Obvious, Minimal Language (TOML) file.\n+ *\n+ * @since 2.0.0\n+ */\n+@Deprecated\n+public class Toml {\n+\n+    private TomlTableNode rootNode;\n+\n+    /**\n+     * Creates new Root TOML Node from AST.\n+     *\n+     * @param tomlTableNode AST representation of TOML Table.\n+     */\n+    private Toml(TomlTableNode tomlTableNode) {\n+        this.rootNode = tomlTableNode;\n+    }\n+\n+    /**\n+     * Read TOML File using Path.\n+     *\n+     * @param path Path of the TOML file\n+     * @return TOML Object\n+     * @throws IOException if file is not accessible\n+     */\n+    public static Toml read(Path path) throws IOException {\n+        return read(Files.newBufferedReader(path));\n+    }\n+\n+    /**\n+     * Read TOML File using InputStream.\n+     *\n+     * @param inputStream InputStream of the TOML file\n+     * @return TOML Object\n+     * @throws IOException if file is not accessible\n+     */\n+    public static Toml read(InputStream inputStream) throws IOException {\n+        return read(new InputStreamReader(inputStream, StandardCharsets.UTF_8));\n+    }\n+\n+    /**\n+     * Read TOML File using Reader.\n+     *\n+     * @param reader reader of the TOML file\n+     * @return TOML Object\n+     * @throws IOException if file is not accessible\n+     */\n+    public static Toml read(Reader reader) throws IOException {\n+        BufferedReader bufferedReader = new BufferedReader(reader);\n+        StringBuilder w = new StringBuilder();\n+        for (String line = bufferedReader.readLine(); line != null; line = bufferedReader.readLine()) {\n+            w.append(line).append('\\n');\n+        }\n+        return read(w.toString());\n+    }\n+\n+    /**\n+     * Parse TOML file using TOML String.\n+     *\n+     * @param content String representation of the TOML file content.\n+     * @return TOML Object\n+     */\n+    public static Toml read(String content) {\n+        TextDocument textDocument = TextDocuments.from(content);\n+        SyntaxTree syntaxTree = SyntaxTree.from(textDocument);\n+        List<TomlDiagnostic> tomlDiagnostics = reportSyntaxDiagnostics(syntaxTree);\n+        TomlTransformer nodeTransformer = new TomlTransformer();\n+        TomlTableNode\n+                transformedTable = (TomlTableNode) nodeTransformer.transform((DocumentNode) syntaxTree.rootNode());\n+        transformedTable.setSyntacticalDiagnostics(tomlDiagnostics);\n+        tomlDiagnostics.addAll(transformedTable.collectSemanticDiagnostics());\n+        return new Toml(transformedTable);\n+    }\n+\n+    private static List<TomlDiagnostic> reportSyntaxDiagnostics(SyntaxTree tree) {\n+        List<TomlDiagnostic> diagnostics = new ArrayList<>();\n+        for (Diagnostic syntaxDiagnostic : tree.diagnostics()) {\n+            TomlNodeLocation tomlNodeLocation = new TomlNodeLocation(syntaxDiagnostic.location().lineRange(),\n+                    syntaxDiagnostic.location().textRange());\n+            TomlDiagnostic tomlDiagnostic =\n+                    new TomlDiagnostic(tomlNodeLocation, syntaxDiagnostic.diagnosticInfo(), syntaxDiagnostic.message());\n+            diagnostics.add(tomlDiagnostic);\n+        }\n+        return diagnostics;\n+    }\n+\n+    /**\n+     * Get value from a key of a Key Value pair.\n+     *\n+     * @param key key name\n+     * @param <T> Type of the AST Value Node\n+     * @return AST Value Node\n+     */\n+    public <T extends TomlValueNode> T get(String key) {\n+        TomlKeyValueNode tomlKeyValueNode = (TomlKeyValueNode) rootNode.children().get(key);\n+        if (tomlKeyValueNode != null) {\n+            TomlValueNode value = tomlKeyValueNode.value();\n+            if (value != null) {\n+                return (T) value;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Get Child Table from TOML.\n+     *\n+     * @param key Identifier of the table.\n+     * @return Child Table\n+     */\n+    public Toml getTable(String key) {\n+        TopLevelNode topLevelNode = rootNode.children().get(key);\n+        if (topLevelNode.kind() == TomlType.TABLE) {\n+            return new Toml((TomlTableNode) topLevelNode);\n+        }\n+        return null;", "originalCommit": "08dc97e6c362201784a1ed1b9b80b15148db930b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE5NTg0OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r514195849", "bodyText": "We've decided not to use optionals to allow easy chaining between tables and keys.\nex - read.getTable(\"products\").get(\"hello1\").\nHowever this API will be revisited with the upcoming AST changes.", "author": "xlight05", "createdAt": "2020-10-29T11:44:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA5ODM3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA5ODg0NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r503098845", "bodyText": "Any specific reason to return null here? Can't we return empty List?", "author": "nadeeshaan", "createdAt": "2020-10-12T07:45:10Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/api/Toml.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package io.ballerina.toml.api;\n+\n+import io.ballerina.toml.semantic.TomlType;\n+import io.ballerina.toml.semantic.ast.TomlKeyValueNode;\n+import io.ballerina.toml.semantic.ast.TomlTableArrayNode;\n+import io.ballerina.toml.semantic.ast.TomlTableNode;\n+import io.ballerina.toml.semantic.ast.TomlTransformer;\n+import io.ballerina.toml.semantic.ast.TomlValueNode;\n+import io.ballerina.toml.semantic.ast.TopLevelNode;\n+import io.ballerina.toml.semantic.diagnostics.TomlDiagnostic;\n+import io.ballerina.toml.semantic.diagnostics.TomlNodeLocation;\n+import io.ballerina.toml.syntax.tree.DocumentNode;\n+import io.ballerina.toml.syntax.tree.SyntaxTree;\n+import io.ballerina.tools.diagnostics.Diagnostic;\n+import io.ballerina.tools.text.TextDocument;\n+import io.ballerina.tools.text.TextDocuments;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * API For Parsing Tom's Obvious, Minimal Language (TOML) file.\n+ *\n+ * @since 2.0.0\n+ */\n+@Deprecated\n+public class Toml {\n+\n+    private TomlTableNode rootNode;\n+\n+    /**\n+     * Creates new Root TOML Node from AST.\n+     *\n+     * @param tomlTableNode AST representation of TOML Table.\n+     */\n+    private Toml(TomlTableNode tomlTableNode) {\n+        this.rootNode = tomlTableNode;\n+    }\n+\n+    /**\n+     * Read TOML File using Path.\n+     *\n+     * @param path Path of the TOML file\n+     * @return TOML Object\n+     * @throws IOException if file is not accessible\n+     */\n+    public static Toml read(Path path) throws IOException {\n+        return read(Files.newBufferedReader(path));\n+    }\n+\n+    /**\n+     * Read TOML File using InputStream.\n+     *\n+     * @param inputStream InputStream of the TOML file\n+     * @return TOML Object\n+     * @throws IOException if file is not accessible\n+     */\n+    public static Toml read(InputStream inputStream) throws IOException {\n+        return read(new InputStreamReader(inputStream, StandardCharsets.UTF_8));\n+    }\n+\n+    /**\n+     * Read TOML File using Reader.\n+     *\n+     * @param reader reader of the TOML file\n+     * @return TOML Object\n+     * @throws IOException if file is not accessible\n+     */\n+    public static Toml read(Reader reader) throws IOException {\n+        BufferedReader bufferedReader = new BufferedReader(reader);\n+        StringBuilder w = new StringBuilder();\n+        for (String line = bufferedReader.readLine(); line != null; line = bufferedReader.readLine()) {\n+            w.append(line).append('\\n');\n+        }\n+        return read(w.toString());\n+    }\n+\n+    /**\n+     * Parse TOML file using TOML String.\n+     *\n+     * @param content String representation of the TOML file content.\n+     * @return TOML Object\n+     */\n+    public static Toml read(String content) {\n+        TextDocument textDocument = TextDocuments.from(content);\n+        SyntaxTree syntaxTree = SyntaxTree.from(textDocument);\n+        List<TomlDiagnostic> tomlDiagnostics = reportSyntaxDiagnostics(syntaxTree);\n+        TomlTransformer nodeTransformer = new TomlTransformer();\n+        TomlTableNode\n+                transformedTable = (TomlTableNode) nodeTransformer.transform((DocumentNode) syntaxTree.rootNode());\n+        transformedTable.setSyntacticalDiagnostics(tomlDiagnostics);\n+        tomlDiagnostics.addAll(transformedTable.collectSemanticDiagnostics());\n+        return new Toml(transformedTable);\n+    }\n+\n+    private static List<TomlDiagnostic> reportSyntaxDiagnostics(SyntaxTree tree) {\n+        List<TomlDiagnostic> diagnostics = new ArrayList<>();\n+        for (Diagnostic syntaxDiagnostic : tree.diagnostics()) {\n+            TomlNodeLocation tomlNodeLocation = new TomlNodeLocation(syntaxDiagnostic.location().lineRange(),\n+                    syntaxDiagnostic.location().textRange());\n+            TomlDiagnostic tomlDiagnostic =\n+                    new TomlDiagnostic(tomlNodeLocation, syntaxDiagnostic.diagnosticInfo(), syntaxDiagnostic.message());\n+            diagnostics.add(tomlDiagnostic);\n+        }\n+        return diagnostics;\n+    }\n+\n+    /**\n+     * Get value from a key of a Key Value pair.\n+     *\n+     * @param key key name\n+     * @param <T> Type of the AST Value Node\n+     * @return AST Value Node\n+     */\n+    public <T extends TomlValueNode> T get(String key) {\n+        TomlKeyValueNode tomlKeyValueNode = (TomlKeyValueNode) rootNode.children().get(key);\n+        if (tomlKeyValueNode != null) {\n+            TomlValueNode value = tomlKeyValueNode.value();\n+            if (value != null) {\n+                return (T) value;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Get Child Table from TOML.\n+     *\n+     * @param key Identifier of the table.\n+     * @return Child Table\n+     */\n+    public Toml getTable(String key) {\n+        TopLevelNode topLevelNode = rootNode.children().get(key);\n+        if (topLevelNode.kind() == TomlType.TABLE) {\n+            return new Toml((TomlTableNode) topLevelNode);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Get Array of Tables from TOML.\n+     *\n+     * @param key Identifier of the table.\n+     * @return List of Tables\n+     */\n+    public List<Toml> getTables(String key) {\n+        TopLevelNode tableNode = rootNode.children().get(key);\n+        if (tableNode.kind() == TomlType.TABLE_ARRAY) {\n+            TomlTableArrayNode tomlTableArrayNode = (TomlTableArrayNode) tableNode;\n+            List<TomlTableNode> childs = tomlTableArrayNode.children();\n+            List<Toml> tomlList = new ArrayList<>();\n+            for (TomlTableNode child : childs) {\n+                tomlList.add(new Toml(child));\n+            }\n+            return tomlList;\n+        }\n+        return null;", "originalCommit": "08dc97e6c362201784a1ed1b9b80b15148db930b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzA5OTgxOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r503099819", "bodyText": "Can we make this final?", "author": "nadeeshaan", "createdAt": "2020-10-12T07:46:53Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/internal/diagnostics/DiagnosticMessageHelper.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package io.ballerina.toml.internal.diagnostics;\n+\n+import java.text.MessageFormat;\n+import java.util.Locale;\n+import java.util.ResourceBundle;\n+\n+/**\n+ * Contains utility methods to generate diagnostic messages.\n+ *\n+ * @since 2.0.0\n+ */\n+public class DiagnosticMessageHelper {\n+    private static ResourceBundle messages = ResourceBundle.getBundle(", "originalCommit": "08dc97e6c362201784a1ed1b9b80b15148db930b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzEwMTA3OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r503101079", "bodyText": "Missing description here", "author": "nadeeshaan", "createdAt": "2020-10-12T07:49:17Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/AbstractParser.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.ballerina.toml.internal.parser;\n+\n+\n+import io.ballerina.toml.internal.diagnostics.DiagnosticCode;\n+import io.ballerina.toml.internal.diagnostics.DiagnosticErrorCode;\n+import io.ballerina.toml.internal.parser.AbstractParserErrorHandler.Action;\n+import io.ballerina.toml.internal.parser.AbstractParserErrorHandler.Solution;\n+import io.ballerina.toml.internal.parser.tree.STNode;\n+import io.ballerina.toml.internal.parser.tree.STNodeList;\n+import io.ballerina.toml.internal.parser.tree.STToken;\n+import io.ballerina.toml.internal.syntax.NodeListUtils;\n+import io.ballerina.toml.syntax.tree.SyntaxKind;\n+\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n+import java.util.List;\n+\n+/**", "originalCommit": "08dc97e6c362201784a1ed1b9b80b15148db930b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzEwMjgwMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26096#discussion_r503102803", "bodyText": "Unused parameter", "author": "nadeeshaan", "createdAt": "2020-10-12T07:52:12Z", "path": "misc/toml-parser/src/main/java/io/ballerina/toml/internal/parser/AbstractParser.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.ballerina.toml.internal.parser;\n+\n+\n+import io.ballerina.toml.internal.diagnostics.DiagnosticCode;\n+import io.ballerina.toml.internal.diagnostics.DiagnosticErrorCode;\n+import io.ballerina.toml.internal.parser.AbstractParserErrorHandler.Action;\n+import io.ballerina.toml.internal.parser.AbstractParserErrorHandler.Solution;\n+import io.ballerina.toml.internal.parser.tree.STNode;\n+import io.ballerina.toml.internal.parser.tree.STNodeList;\n+import io.ballerina.toml.internal.parser.tree.STToken;\n+import io.ballerina.toml.internal.syntax.NodeListUtils;\n+import io.ballerina.toml.syntax.tree.SyntaxKind;\n+\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n+import java.util.List;\n+\n+/**\n+ * @since 2.0.0\n+ */\n+public abstract class AbstractParser {\n+\n+    protected final AbstractParserErrorHandler errorHandler;\n+    protected final AbstractTokenReader tokenReader;\n+    private final Deque<InvalidNodeInfo> invalidNodeInfoStack = new ArrayDeque<>(5);\n+    protected STToken insertedToken = null;\n+\n+    public AbstractParser(AbstractTokenReader tokenReader, AbstractParserErrorHandler errorHandler) {\n+        this.tokenReader = tokenReader;\n+        this.errorHandler = errorHandler;\n+    }\n+\n+    public AbstractParser(AbstractTokenReader tokenReader) {\n+        this.tokenReader = tokenReader;\n+        this.errorHandler = null;\n+    }\n+\n+    public abstract STNode parse();\n+\n+    protected STToken peek() {\n+        if (this.insertedToken != null) {\n+            return this.insertedToken;\n+        }\n+\n+        return this.tokenReader.peek();\n+    }\n+\n+    protected STToken peek(int k) {\n+        if (this.insertedToken == null) {\n+            return this.tokenReader.peek(k);\n+        }\n+\n+        if (k == 1) {\n+            return this.insertedToken;\n+        }\n+\n+        if (k > 0) {\n+            k = k - 1;\n+        }\n+\n+        return this.tokenReader.peek(k);\n+    }\n+\n+    protected STToken consume() {\n+        if (this.insertedToken != null) {\n+            STToken nextToken = this.insertedToken;\n+            this.insertedToken = null;\n+            return nextToken;\n+        }\n+\n+        if (invalidNodeInfoStack.isEmpty()) {\n+            return this.tokenReader.read();\n+        }\n+\n+        return consumeWithInvalidNodes();\n+    }\n+\n+    private STToken consumeWithInvalidNodes() {\n+        // TODO can we improve this logic by cloning only once with all the invalid tokens?\n+        STToken token = this.tokenReader.read();\n+        while (!invalidNodeInfoStack.isEmpty()) {\n+            InvalidNodeInfo invalidNodeInfo = invalidNodeInfoStack.pop();\n+            token = SyntaxErrors.cloneWithLeadingInvalidNodeMinutiae(token, invalidNodeInfo.node,\n+                    invalidNodeInfo.diagnosticCode, invalidNodeInfo.args);\n+        }\n+        return token;\n+    }\n+\n+    protected Solution recover(STToken token, ParserRuleContext currentCtx, Object... args) {\n+        Solution sol = this.errorHandler.recover(currentCtx, token, args);\n+        // If the action is to remove, then re-parse the same rule.\n+        if (sol.action == Action.REMOVE) {\n+            addInvalidTokenToNextToken(sol.removedToken);\n+        } else if (sol.action == Action.INSERT) {\n+            this.insertedToken = (STToken) sol.recoveredNode;\n+        }\n+\n+        return sol;\n+    }\n+\n+    protected void insertToken(SyntaxKind kind) {\n+        this.insertedToken = SyntaxErrors.createMissingTokenWithDiagnostics(kind);\n+    }\n+\n+    protected void startContext(ParserRuleContext context) {\n+        this.errorHandler.startContext(context);\n+    }\n+\n+    protected void endContext() {\n+        this.errorHandler.endContext();\n+    }\n+\n+    /**\n+     * Switch the current context to the provided one. This will replace the\n+     * existing context.\n+     *\n+     * @param context Context to switch to.\n+     */\n+    protected void switchContext(ParserRuleContext context) {\n+        this.errorHandler.switchContext(context);\n+    }\n+\n+    protected STToken getNextNextToken(SyntaxKind tokenKind) {", "originalCommit": "08dc97e6c362201784a1ed1b9b80b15148db930b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}