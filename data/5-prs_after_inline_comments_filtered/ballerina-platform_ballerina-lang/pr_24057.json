{"pr_number": 24057, "pr_title": "Add lang-lib methods to improve JSON compatibility", "pr_createdAt": "2020-06-13T08:42:56Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTczMjEwOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r439732108", "bodyText": "I don't think this is where we should change. IMO we should do something like https://github.com/ballerina-platform/ballerina-lang/blob/master/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/JSONParser.java#L64 because\n\nthere may be other non-array member string values that will not get changed to BString if we change only here.\n\nFor example, the following might fail\npublic function main() {\n    string st = \"\\\"hello\\\"\";\n    string j = <string> st.fromJsonString();\n}\n\nOn paths where changeForBString is already called and there are arrays present we'll be calling this method twice unnecessarily.\n\ne.g., \n  \n    \n      ballerina-lang/bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/JSONParser.java\n    \n    \n         Line 95\n      in\n      8077e15\n    \n    \n    \n    \n\n        \n          \n           return changeForBString(jsonObj);", "author": "MaryamZi", "createdAt": "2020-06-13T11:32:20Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/JSONParser.java", "diffHunk": "@@ -687,7 +687,7 @@ public State transition(StateMachine sm, char[] buff, int i, int count) throws J\n                     ch = buff[i];\n                     sm.processLocation(ch);\n                     if (ch == sm.currentQuoteChar) {\n-                        ((ArrayValue) sm.currentJsonNode).append(sm.value());\n+                        ((ArrayValue) sm.currentJsonNode).append(changeForBString(sm.value()));", "originalCommit": "8077e15459944ea37f0c4a73d99bad2da6fe288f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM3MDA3Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440370076", "bodyText": "Got it. Solved", "author": "dulajdilshan", "createdAt": "2020-06-15T18:36:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTczMjEwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTczOTUyNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r439739524", "bodyText": "Please check the following example.\npublic function main() {\n    map<int> m = {a: 1, b: 2};\n    map<json> mj = <map<json>> m.toJson();\n\n    mj[\"c\"] = \"non-int json\";\n}\nThis currently fails with\n$ ballerina run xyz.bal\nCompiling source\n        xyz.bal\nRunning executables\n\nerror: {ballerina/lang.map}InherentTypeViolation message=invalid map insertion: expected value of type 'int', found 'string'\n        at xyz:main(xyz.bal:5)", "author": "MaryamZi", "createdAt": "2020-06-13T13:30:08Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.JSON),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        if (value == null) {\n+            return null;\n+        }\n+\n+        BType sourceType = TypeChecker.getType(value);\n+        BType targetJsonType = BTypes.typeJSON;\n+        if (!TypeChecker.checkIsLikeType(value, targetJsonType, true)) {\n+            if (sourceType.getTag() >= TypeTags.XML_ELEMENT_TAG || sourceType.getTag() == TypeTags.XML_TAG) {\n+                return ToString.toString(strand, value);\n+            } else {\n+                throw createConversionError(value, targetJsonType);\n+            }\n+        }\n+\n+        // handle primitive values\n+        if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+            if (TypeChecker.checkIsType(value, targetJsonType)) {\n+                return value;\n+            } else {\n+                // Has to be a numeric conversion.\n+                return TypeConverter.convertValues(targetJsonType, value);\n+            }\n+        }\n+\n+        return convert((RefValue) value, targetJsonType, new ArrayList<>(), strand);\n+    }\n+\n+    private static Object convert(RefValue value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  Strand strand) {\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, value.getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        Object newValue;\n+        switch (value.getType().getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, targetType, unresolvedValues, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, targetType, unresolvedValues, strand);\n+                break;\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+            case TypeTags.ERROR_TAG:\n+                newValue = value.copy(new HashMap<>());\n+                break;\n+            default:\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  boolean allowAmbiguity, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+        List<BType> convertibleTypes;\n+        convertibleTypes = TypeConverter.getConvertibleTypes(value, targetType);\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (!allowAmbiguity && convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType sourceType = TypeChecker.getType(value);\n+        BType matchingType = convertibleTypes.get(0);\n+        // handle primitive values\n+        if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+            if (TypeChecker.checkIsType(value, matchingType)) {\n+                return value;\n+            } else {\n+                // Has to be a numeric conversion.\n+                return TypeConverter.convertValues(matchingType, value);\n+            }\n+        }\n+\n+        return convert((RefValue) value, matchingType, unresolvedValues, strand);\n+    }\n+\n+    private static Object convertMapToJson(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                           Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+                MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType constraintType = ((BMapType) targetType).getConstrainedType();\n+                    putToMap(newMap, entry, constraintType, unresolvedValues, strand);\n+                }\n+                return newMap;\n+            case TypeTags.JSON_TAG:\n+                BType matchingType = TypeConverter.resolveMatchingTypeForUnion(map, targetType);", "originalCommit": "8077e15459944ea37f0c4a73d99bad2da6fe288f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU5MDY2NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440590665", "bodyText": "Solved", "author": "dulajdilshan", "createdAt": "2020-06-16T05:14:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTczOTUyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2MDM1Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r439760353", "bodyText": "Double check this error message format. AFAIK, the convention is to prefix the reason with the module. But I can see that some of the lang.value functions have used this format. Let's check with the others and verify.", "author": "pubudu91", "createdAt": "2020-06-13T18:48:04Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonStringWithType.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.JSONParser;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.io.Reader;\n+import java.io.StringReader;\n+\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ * Converts a string in JSON format to a user-specified type.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonStringWithType\",\n+        args = {\n+                @Argument(name = \"str\", type = TypeKind.STRING),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonStringWithType {\n+\n+    public static Object fromJsonStringWithType(Strand strand, BString value, TypedescValue t) {\n+\n+        String str = value.getValue();\n+        if (str.equals(\"null\")) {\n+            return null;\n+        }\n+        Reader reader = new StringReader(str);\n+        try {\n+            Object jsonFromString = JSONParser.parse(reader);\n+            return FromJsonWithType.fromJsonWithType(strand, jsonFromString, t);\n+        } catch (BallerinaException e) {\n+            return BallerinaErrors.createError(\"{ballerina}FromJsonStringWithTypeError\", e.getMessage());", "originalCommit": "8077e15459944ea37f0c4a73d99bad2da6fe288f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU5MDU5NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440590595", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-06-16T05:14:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2MDM1Mw=="}], "type": "inlineReview"}, {"oid": "1801ce4a280eb6c65f11988f2a0adb5b56788a7e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1801ce4a280eb6c65f11988f2a0adb5b56788a7e", "message": "Allow more tests", "committedDate": "2020-06-15T17:21:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQzODU2Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440438566", "bodyText": "Why are we trying to convert it to an XML value if there aren't any convertible types? Consider the following example,\nimport ballerina/io;\n\npublic function main() {\n    string foo = \"Foo\";\n    var v = foo.fromJsonWithType(int);\n    io:println(v);\n}\nThe above fails with the following panic:\nerror {ballerina/lang.typedesc}ConversionError message='string' value cannot be converted to 'int': failed to parse xml: Unexpected character 'F' (code 70) in prolog; expected '<'\n at [row,col {unknown-source}]: [1,1]\n\nIt says string value cannot be converted to int but then has an XML parsing error as well.", "author": "pubudu91", "createdAt": "2020-06-15T20:49:42Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypedescType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        // typedesc<json>.constructFrom like usage\n+        if (describingType.getTag() == TypeTags.TYPEDESC_TAG) {\n+            return convert(((BTypedescType) t.getDescribingType()).getConstraint(), v, t, strand);\n+        }\n+        // json.constructFrom like usage\n+        return convert(describingType, v, t, strand);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue) {\n+        return convert(convertType, inputValue, null, null);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue, TypedescValue t, Strand strand) {\n+        try {\n+            return convert(inputValue, convertType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+        return convert(value, targetType, unresolvedValues, false, t, strand);\n+    }\n+\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  boolean allowAmbiguity, TypedescValue t, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+        List<BType> convertibleTypes;\n+        convertibleTypes = TypeConverter.getConvertibleTypes(value, targetType);\n+        if (convertibleTypes.isEmpty()) {\n+            if (TypeChecker.getType(value).getTag() == TypeTags.STRING_TAG) {\n+                try {\n+                    return XMLFactory.parse(((StringValue) value).getValue());\n+                } catch (Throwable e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+            }", "originalCommit": "1801ce4a280eb6c65f11988f2a0adb5b56788a7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU5NzYwNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440597605", "bodyText": "The spec says that fromJsonWithType should do the inverse of the toJson which converts xml into a  string.\nSo, fromJsonWithType should be able to convert an appropriate string to an xml.\nChanging the behaviour of TypeConverter.getConvertibleTypes() to support this would also work, but will affect cloneWithType method and future methods to be implemented (if there are)\nI'll fix showing xml conversion error", "author": "dulajdilshan", "createdAt": "2020-06-16T05:39:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQzODU2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU5OTM1Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440599353", "bodyText": "Yeah, it doesn't make sense to try and convert to XML if I didn't specify an XML typedesc", "author": "pubudu91", "createdAt": "2020-06-16T05:46:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQzODU2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwMjMwNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440602304", "bodyText": "Yeah. Thanks!", "author": "dulajdilshan", "createdAt": "2020-06-16T05:56:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQzODU2Ng=="}], "type": "inlineReview"}, {"oid": "0f7f31f56391c00bca0e631d0db24e25c803ff64", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0f7f31f56391c00bca0e631d0db24e25c803ff64", "message": "Fix showing XML conversion error in other string type related conversions", "committedDate": "2020-06-16T05:46:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwNzgzMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440607832", "bodyText": "Shall we add an upper bound for the subtypes as well for the following? If we add another anydata type, this will break.\ntargetType.getTag() >= TypeTags.XML_ELEMENT_TAG", "author": "pubudu91", "createdAt": "2020-06-16T06:12:37Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypedescType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        // typedesc<json>.constructFrom like usage\n+        if (describingType.getTag() == TypeTags.TYPEDESC_TAG) {\n+            return convert(((BTypedescType) t.getDescribingType()).getConstraint(), v, t, strand);\n+        }\n+        // json.constructFrom like usage\n+        return convert(describingType, v, t, strand);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue) {\n+        return convert(convertType, inputValue, null, null);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue, TypedescValue t, Strand strand) {\n+        try {\n+            return convert(inputValue, convertType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+        return convert(value, targetType, unresolvedValues, false, t, strand);\n+    }\n+\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  boolean allowAmbiguity, TypedescValue t, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+        List<BType> convertibleTypes;\n+        convertibleTypes = TypeConverter.getConvertibleTypes(value, targetType);\n+        if (convertibleTypes.isEmpty()) {\n+            if (TypeChecker.getType(value).getTag() == TypeTags.STRING_TAG &&\n+                    (targetType.getTag() >= TypeTags.XML_ELEMENT_TAG || targetType.getTag() == TypeTags.XML_TAG)) {", "originalCommit": "0f7f31f56391c00bca0e631d0db24e25c803ff64", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYxMTU0OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440611548", "bodyText": "okay", "author": "dulajdilshan", "createdAt": "2020-06-16T06:22:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwNzgzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYxMTkxOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440611918", "bodyText": "Since this array type is not going to change, how about adding it to BTypes, instead of creating a new JSON array type each time?", "author": "pubudu91", "createdAt": "2020-06-16T06:23:22Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypedescType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        // typedesc<json>.constructFrom like usage\n+        if (describingType.getTag() == TypeTags.TYPEDESC_TAG) {\n+            return convert(((BTypedescType) t.getDescribingType()).getConstraint(), v, t, strand);\n+        }\n+        // json.constructFrom like usage\n+        return convert(describingType, v, t, strand);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue) {\n+        return convert(convertType, inputValue, null, null);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue, TypedescValue t, Strand strand) {\n+        try {\n+            return convert(inputValue, convertType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+        return convert(value, targetType, unresolvedValues, false, t, strand);\n+    }\n+\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  boolean allowAmbiguity, TypedescValue t, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+        List<BType> convertibleTypes;\n+        convertibleTypes = TypeConverter.getConvertibleTypes(value, targetType);\n+        if (convertibleTypes.isEmpty()) {\n+            if (TypeChecker.getType(value).getTag() == TypeTags.STRING_TAG &&\n+                    (targetType.getTag() >= TypeTags.XML_ELEMENT_TAG || targetType.getTag() == TypeTags.XML_TAG)) {\n+                try {\n+                    return XMLFactory.parse(((StringValue) value).getValue());\n+                } catch (Throwable e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+            }\n+            throw createConversionError(value, targetType);\n+        } else if (!allowAmbiguity && convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType sourceType = TypeChecker.getType(value);\n+        BType matchingType = convertibleTypes.get(0);\n+        // handle primitive values\n+        if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+            if (TypeChecker.checkIsType(value, matchingType)) {\n+                return value;\n+            } else {\n+                // Has to be a numeric conversion.\n+                return TypeConverter.convertValues(matchingType, value);\n+            }\n+        }\n+\n+        return convert((RefValue) value, matchingType, unresolvedValues, t, strand);\n+    }\n+\n+    private static Object convert(RefValue value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, value.getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        Object newValue;\n+        switch (value.getType().getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, targetType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, targetType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+            case TypeTags.ERROR_TAG:\n+                newValue = value.copy(new HashMap<>());\n+                break;\n+            default:\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMap(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                     TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+                MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType constraintType = ((BMapType) targetType).getConstrainedType();\n+                    putToMap(newMap, entry, constraintType, unresolvedValues, t, strand);\n+                }\n+                return newMap;\n+            case TypeTags.RECORD_TYPE_TAG:\n+                BRecordType recordType = (BRecordType) targetType;\n+                MapValueImpl<BString, Object> newRecord;\n+                if (t != null && t.getDescribingType() == targetType) {\n+                    newRecord = (MapValueImpl<BString, Object>) t.instantiate(strand);\n+                } else {\n+                    newRecord = (MapValueImpl<BString, Object>) BallerinaValues\n+                            .createRecordValue(recordType.getPackage(), recordType.getName());\n+                }\n+\n+                BType restFieldType = recordType.restFieldType;\n+                Map<String, BType> targetTypeField = new HashMap<>();\n+                for (BField field : recordType.getFields().values()) {\n+                    targetTypeField.put(field.getFieldName(), field.getFieldType());\n+                }\n+\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType fieldType = targetTypeField.getOrDefault(entry.getKey().toString(), restFieldType);\n+                    putToMap(newRecord, entry, fieldType, unresolvedValues, t, strand);\n+                }\n+                return newRecord;\n+            case TypeTags.JSON_TAG:\n+                BType matchingType = TypeConverter.resolveMatchingTypeForUnion(map, targetType);\n+                return convert(map, matchingType, unresolvedValues, t, strand);\n+            default:\n+                break;\n+        }\n+        // should never reach here\n+        throw BallerinaErrors.createConversionError(map, targetType);\n+    }\n+\n+\n+    private static Object convertArray(ArrayValue array, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                       TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.ARRAY_TAG:\n+                BArrayType arrayType = (BArrayType) targetType;\n+                ArrayValueImpl newArray = new ArrayValueImpl(arrayType);\n+                for (int i = 0; i < array.size(); i++) {\n+                    Object newValue = convert(array.get(i), arrayType.getElementType(), unresolvedValues, t, strand);\n+                    newArray.add(i, newValue);\n+                }\n+                return newArray;\n+            case TypeTags.TUPLE_TAG:\n+                BTupleType tupleType = (BTupleType) targetType;\n+                TupleValueImpl newTuple = new TupleValueImpl(tupleType);\n+                int minLen = tupleType.getTupleTypes().size();\n+                for (int i = 0; i < array.size(); i++) {\n+                    BType elementType = (i < minLen) ? tupleType.getTupleTypes().get(i) : tupleType.getRestType();\n+                    Object newValue = convert(array.get(i), elementType, unresolvedValues, t, strand);\n+                    newTuple.add(i, newValue);\n+                }\n+                return newTuple;\n+            case TypeTags.JSON_TAG:\n+                newArray = new ArrayValueImpl(new BArrayType(BTypes.typeJSON));", "originalCommit": "7b347b097d8ac0c0ee19ac2c060a0824b1366dc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYzMDc0MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440630740", "bodyText": "This should be thrown right? Since the signature of toJson() is json", "author": "pubudu91", "createdAt": "2020-06-16T07:07:36Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.JSON),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        if (value == null) {\n+            return null;\n+        }\n+\n+        BType sourceType = TypeChecker.getType(value);\n+        BType targetJsonType = BTypes.typeJSON;\n+        if (!isConvertibleToJson(value, new ArrayList<>())) {\n+            if (sourceType.getTag() >= TypeTags.XML_ELEMENT_TAG || sourceType.getTag() == TypeTags.XML_TAG) {\n+                return ToString.toString(strand, value);\n+            } else {\n+                throw createConversionError(value, targetJsonType);\n+            }\n+        }\n+\n+        // handle primitive values\n+        if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+            if (TypeChecker.checkIsType(value, targetJsonType)) {\n+                return value;\n+            } else {\n+                // Has to be a numeric conversion.\n+                return TypeConverter.convertValues(targetJsonType, value);\n+            }\n+        }\n+\n+        return convert((RefValue) value, targetJsonType, new ArrayList<>(), strand);\n+    }\n+\n+    private static Object convert(RefValue value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  Strand strand) {\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, value.getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        Object newValue;\n+        switch (value.getType().getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, targetType, unresolvedValues, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, targetType, unresolvedValues, strand);\n+                break;\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+                newValue = ToString.toString(strand, value);\n+                break;\n+            case TypeTags.TABLE_TAG:\n+                try {\n+                    newValue = JSONUtils.toJSON((TableValueImpl) value);\n+                } catch (Exception e) {\n+                    return createConversionError(value, targetType, e.getMessage());", "originalCommit": "7b347b097d8ac0c0ee19ac2c060a0824b1366dc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc1ODc0NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r440758745", "bodyText": "Ack. Thanks", "author": "dulajdilshan", "createdAt": "2020-06-16T10:47:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYzMDc0MA=="}], "type": "inlineReview"}, {"oid": "a077ffb23f5a9e15d2c18eec61e64a926a5d7b4a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a077ffb23f5a9e15d2c18eec61e64a926a5d7b4a", "message": "Change error message in 'fromJsonStringWithType' langlib method", "committedDate": "2020-06-16T14:03:37Z", "type": "forcePushed"}, {"oid": "6a2f3b589925768e932552b23987b87aed442edb", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6a2f3b589925768e932552b23987b87aed442edb", "message": "Disable langlib value tests", "committedDate": "2020-06-16T20:31:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ0NjYyOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r443446629", "bodyText": "Should return", "author": "dulajdilshan", "createdAt": "2020-06-22T09:55:39Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypedescType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        // typedesc<json>.constructFrom like usage\n+        if (describingType.getTag() == TypeTags.TYPEDESC_TAG) {\n+            return convert(((BTypedescType) t.getDescribingType()).getConstraint(), v, t, strand);\n+        }\n+        // json.constructFrom like usage\n+        return convert(describingType, v, t, strand);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue, TypedescValue t, Strand strand) {\n+        try {\n+            return convert(inputValue, convertType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+        return convert(value, targetType, unresolvedValues, false, t, strand);\n+    }\n+\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  boolean allowAmbiguity, TypedescValue t, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+        List<BType> convertibleTypes;\n+        convertibleTypes = getConvertibleTypesFromJson(value, targetType);\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);", "originalCommit": "6a2f3b589925768e932552b23987b87aed442edb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ0NzI0Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r443447246", "bodyText": "no need isambiguity", "author": "dulajdilshan", "createdAt": "2020-06-22T09:56:44Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypedescType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        // typedesc<json>.constructFrom like usage\n+        if (describingType.getTag() == TypeTags.TYPEDESC_TAG) {\n+            return convert(((BTypedescType) t.getDescribingType()).getConstraint(), v, t, strand);\n+        }\n+        // json.constructFrom like usage\n+        return convert(describingType, v, t, strand);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue, TypedescValue t, Strand strand) {\n+        try {\n+            return convert(inputValue, convertType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+        return convert(value, targetType, unresolvedValues, false, t, strand);\n+    }\n+\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  boolean allowAmbiguity, TypedescValue t, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+        List<BType> convertibleTypes;\n+        convertibleTypes = getConvertibleTypesFromJson(value, targetType);\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (!allowAmbiguity && convertibleTypes.size() > 1) {", "originalCommit": "6a2f3b589925768e932552b23987b87aed442edb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ2Njg4Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r443466883", "bodyText": "Error put as a cause", "author": "dulajdilshan", "createdAt": "2020-06-22T10:34:00Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypedescType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        args = {\n+                @Argument(name = \"v\", type = TypeKind.ANYDATA),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        // typedesc<json>.constructFrom like usage\n+        if (describingType.getTag() == TypeTags.TYPEDESC_TAG) {\n+            return convert(((BTypedescType) t.getDescribingType()).getConstraint(), v, t, strand);\n+        }\n+        // json.constructFrom like usage\n+        return convert(describingType, v, t, strand);\n+    }\n+\n+    public static Object convert(BType convertType, Object inputValue, TypedescValue t, Strand strand) {\n+        try {\n+            return convert(inputValue, convertType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+        return convert(value, targetType, unresolvedValues, false, t, strand);\n+    }\n+\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  boolean allowAmbiguity, TypedescValue t, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            return createError(CONSTRUCT_FROM_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+        List<BType> convertibleTypes;\n+        convertibleTypes = getConvertibleTypesFromJson(value, targetType);\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (!allowAmbiguity && convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType sourceType = TypeChecker.getType(value);\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        // handle string (xml as string) to xml conversion\n+        if (TypeChecker.getType(value).getTag() == TypeTags.STRING_TAG &&\n+                ((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG && matchingType.getTag() <= TypeTags.XML_TEXT_TAG)\n+                        || matchingType.getTag() == TypeTags.XML_TAG)) {\n+            try {\n+                return XMLFactory.parse(((StringValue) value).getValue());", "originalCommit": "6a2f3b589925768e932552b23987b87aed442edb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b0073636ea0493ddb1d44e18b2afa599d563946a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b0073636ea0493ddb1d44e18b2afa599d563946a", "message": "Refactor \"fromJsonWithType\" according to the code review suggestions", "committedDate": "2020-06-30T06:24:32Z", "type": "forcePushed"}, {"oid": "aa0eab3df2f3c2a6d1e7e831b3996d68eb4cb186", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/aa0eab3df2f3c2a6d1e7e831b3996d68eb4cb186", "message": "Fix error in the value lib test", "committedDate": "2020-06-30T08:40:24Z", "type": "forcePushed"}, {"oid": "39bbe770806904ada758446ee80c9df6cfeed410", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/39bbe770806904ada758446ee80c9df6cfeed410", "message": "Fix error in the value lib test", "committedDate": "2020-06-30T08:56:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3MTc5NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449571794", "bodyText": "Can't we do something like\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            Object val = record.get(key);\n          \n          \n            \n                            BString strVal = org.ballerinalang.jvm.StringUtils.fromString(\n          \n          \n            \n                                    org.ballerinalang.jvm.values.utils.StringUtils.getStringValue(val));\n          \n          \n            \n                            jsonObject.put(StringUtils.fromString(name), strVal);\n          \n          \n            \n            //                jsonObject.put(StringUtils.fromString(name), record.getStringValue(key));\n          \n          \n            \n                            BString strVal = StringUtils.fromString(\n          \n          \n            \n                                    org.ballerinalang.jvm.values.utils.StringUtils.getStringValue(record.get(key)));\n          \n          \n            \n                            jsonObject.put(StringUtils.fromString(name), strVal);\n          \n      \n    \n    \n  \n\ninstead?\nLet's also remove commented out code.", "author": "MaryamZi", "createdAt": "2020-07-03T13:00:51Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TableJSONDataSource.java", "diffHunk": "@@ -159,7 +159,11 @@ private static void constructJsonData(MapValueImpl record, MapValue<BString, Obj\n                         getStructData(record.getMapValue(key), structFields, index, key));\n                 break;\n             case TypeTags.XML_TAG:\n-                jsonObject.put(StringUtils.fromString(name), record.getStringValue(key));\n+                Object val = record.get(key);\n+                BString strVal = org.ballerinalang.jvm.StringUtils.fromString(\n+                        org.ballerinalang.jvm.values.utils.StringUtils.getStringValue(val));\n+                jsonObject.put(StringUtils.fromString(name), strVal);\n+//                jsonObject.put(StringUtils.fromString(name), record.getStringValue(key));", "originalCommit": "39bbe770806904ada758446ee80c9df6cfeed410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM1MjE4NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451352184", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-08T07:54:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3MTc5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY0NTc1MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449645751", "bodyText": "In this value type check, we check for simple basic types and string right? Since they are always json, wondering if we can skip the next line and directly return true.", "author": "MaryamZi", "createdAt": "2020-07-03T16:01:49Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeChecker.java", "diffHunk": "@@ -343,6 +343,56 @@ public static boolean isSameType(BType sourceType, BType targetType) {\n         return false;\n     }\n \n+    public static boolean isConvertibleToJson(Object sourceValue, List<TypeValuePair> unresolvedValues) {\n+\n+        BType sourceType = TypeChecker.getType(sourceValue);\n+\n+        if (TypeChecker.checkIsLikeType(sourceValue, BTypes.typeJSON, true)) {\n+            return true;\n+        }\n+\n+        if (sourceType.getTag() == TypeTags.ARRAY_TAG) {\n+            ArrayValue source = (ArrayValue) sourceValue;\n+            BType elementType = ((BArrayType) source.getType()).getElementType();\n+            if (BTypes.isValueType(elementType)) {", "originalCommit": "39bbe770806904ada758446ee80c9df6cfeed410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM1NDAzOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451354038", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-08T07:57:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY0NTc1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1OTc1NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449659754", "bodyText": "Do we need this isConvertibleToJson check at all? toJson can only be called on anydata values right? And unless they have cycles (which seems to be checked independent of this check), it is pretty much guaranteed that they can be converted to json?\n\n  \n    \n      ballerina-lang/langlib/lang.value/src/main/ballerina/src/lang.value/value.bal\n    \n    \n         Line 133\n      in\n      39bbe77\n    \n    \n    \n    \n\n        \n          \n           public function toJson(anydata v) returns json = external;", "author": "MaryamZi", "createdAt": "2020-07-03T16:55:56Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE,\n+                            ((RefValue) value).getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (!TypeChecker.isConvertibleToJson(value, new ArrayList<>())) {", "originalCommit": "39bbe770806904ada758446ee80c9df6cfeed410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc1MzQyNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451753425", "bodyText": "Ack. Thanks", "author": "dulajdilshan", "createdAt": "2020-07-08T18:44:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1OTc1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1OTkwMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449659900", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    BType targetJsonType = BTypes.typeJSON;\n          \n          \n            \n                    try {\n          \n          \n            \n                        return convert(value, targetJsonType, new ArrayList<>(), strand);\n          \n          \n            \n                    try {\n          \n          \n            \n                        return convert(value, BTypes.typeJSON, new ArrayList<>(), strand);", "author": "MaryamZi", "createdAt": "2020-07-03T16:56:38Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);", "originalCommit": "39bbe770806904ada758446ee80c9df6cfeed410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM1NjQ3Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451356473", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-08T08:01:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1OTkwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2MDMyMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449660321", "bodyText": "Isn't the target type always json? Makes this check always true right?", "author": "MaryamZi", "createdAt": "2020-07-03T16:58:33Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {", "originalCommit": "39bbe770806904ada758446ee80c9df6cfeed410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM2MzYyMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451363622", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-08T08:13:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2MDMyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2NjAxOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449666019", "bodyText": "Once we remove error from anydata, we won't reach here right? For the time-being I think we can panic if reach here.", "author": "MaryamZi", "createdAt": "2020-07-03T17:26:08Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE,\n+                            ((RefValue) value).getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (!TypeChecker.isConvertibleToJson(value, new ArrayList<>())) {\n+            return createConversionError(value, targetType);\n+        }\n+\n+        Object newValue;\n+        switch (TypeChecker.getType(value).getTag()) {\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+                newValue = ToString.toString(strand, value);\n+                break;\n+            case TypeTags.TUPLE_TAG:\n+            case TypeTags.ARRAY_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, unresolvedValues, strand);\n+                break;\n+            case TypeTags.TABLE_TAG:\n+                try {\n+                    newValue = JSONUtils.toJSON((TableValueImpl) value);\n+                } catch (Exception e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+                break;\n+            case TypeTags.RECORD_TYPE_TAG:\n+            case TypeTags.MAP_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, new BMapType(BTypes.typeJSON),\n+                        unresolvedValues, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:", "originalCommit": "39bbe770806904ada758446ee80c9df6cfeed410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkzNzYwNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451937606", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-09T03:04:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2NjAxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2NzQ1Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449667453", "bodyText": "We get here only for simple basic types and string, and we don't have to do any conversions here right?\nIMO, we can move this to after the null check and remove this here.", "author": "MaryamZi", "createdAt": "2020-07-03T17:33:10Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE,\n+                            ((RefValue) value).getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (!TypeChecker.isConvertibleToJson(value, new ArrayList<>())) {\n+            return createConversionError(value, targetType);\n+        }\n+\n+        Object newValue;\n+        switch (TypeChecker.getType(value).getTag()) {\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+                newValue = ToString.toString(strand, value);\n+                break;\n+            case TypeTags.TUPLE_TAG:\n+            case TypeTags.ARRAY_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, unresolvedValues, strand);\n+                break;\n+            case TypeTags.TABLE_TAG:\n+                try {\n+                    newValue = JSONUtils.toJSON((TableValueImpl) value);\n+                } catch (Exception e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+                break;\n+            case TypeTags.RECORD_TYPE_TAG:\n+            case TypeTags.MAP_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, new BMapType(BTypes.typeJSON),\n+                        unresolvedValues, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:", "originalCommit": "39bbe770806904ada758446ee80c9df6cfeed410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2ODE4OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449668188", "bodyText": "Also, assuming this is for simple basic types, they are always JSON. So we don't have to check getConvertibleTypes.", "author": "MaryamZi", "createdAt": "2020-07-03T17:37:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2NzQ1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI0MTMwNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r452241304", "bodyText": "Changed.", "author": "dulajdilshan", "createdAt": "2020-07-09T14:02:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2NzQ1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2ODU3OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449668578", "bodyText": "targetType is always map<json> right? We can have a constant/final variable for the type in this class or BTypes, or move the type creation to within this method.", "author": "MaryamZi", "createdAt": "2020-07-03T17:39:03Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE,\n+                            ((RefValue) value).getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (!TypeChecker.isConvertibleToJson(value, new ArrayList<>())) {\n+            return createConversionError(value, targetType);\n+        }\n+\n+        Object newValue;\n+        switch (TypeChecker.getType(value).getTag()) {\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+                newValue = ToString.toString(strand, value);\n+                break;\n+            case TypeTags.TUPLE_TAG:\n+            case TypeTags.ARRAY_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, unresolvedValues, strand);\n+                break;\n+            case TypeTags.TABLE_TAG:\n+                try {\n+                    newValue = JSONUtils.toJSON((TableValueImpl) value);\n+                } catch (Exception e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+                break;\n+            case TypeTags.RECORD_TYPE_TAG:\n+            case TypeTags.MAP_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, new BMapType(BTypes.typeJSON),\n+                        unresolvedValues, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                List<BType> convertibleTypes = TypeConverter.getConvertibleTypes(value, BTypes.typeJSON);\n+                if (convertibleTypes.size() == 0) {\n+                    throw createConversionError(value, targetType);\n+                } else if (convertibleTypes.size() > 1) {\n+                    throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+                }\n+\n+                BType sourceType = TypeChecker.getType(value);\n+                BType matchingType = convertibleTypes.get(0);\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                } else {\n+                    throw createConversionError(value, targetType);\n+                }\n+                break;\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMapToJson(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,", "originalCommit": "39bbe770806904ada758446ee80c9df6cfeed410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2MTcwNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451761706", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-08T18:59:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2ODU3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2ODkwMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449668902", "bodyText": "We should have extracted this out to a variable. But then again since this is always json, we can use the JSON type in BTypes.", "author": "MaryamZi", "createdAt": "2020-07-03T17:40:49Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE,\n+                            ((RefValue) value).getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (!TypeChecker.isConvertibleToJson(value, new ArrayList<>())) {\n+            return createConversionError(value, targetType);\n+        }\n+\n+        Object newValue;\n+        switch (TypeChecker.getType(value).getTag()) {\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+                newValue = ToString.toString(strand, value);\n+                break;\n+            case TypeTags.TUPLE_TAG:\n+            case TypeTags.ARRAY_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, unresolvedValues, strand);\n+                break;\n+            case TypeTags.TABLE_TAG:\n+                try {\n+                    newValue = JSONUtils.toJSON((TableValueImpl) value);\n+                } catch (Exception e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+                break;\n+            case TypeTags.RECORD_TYPE_TAG:\n+            case TypeTags.MAP_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, new BMapType(BTypes.typeJSON),\n+                        unresolvedValues, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                List<BType> convertibleTypes = TypeConverter.getConvertibleTypes(value, BTypes.typeJSON);\n+                if (convertibleTypes.size() == 0) {\n+                    throw createConversionError(value, targetType);\n+                } else if (convertibleTypes.size() > 1) {\n+                    throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+                }\n+\n+                BType sourceType = TypeChecker.getType(value);\n+                BType matchingType = convertibleTypes.get(0);\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                } else {\n+                    throw createConversionError(value, targetType);\n+                }\n+                break;\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMapToJson(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                           Strand strand) {\n+        MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+        for (Map.Entry entry : map.entrySet()) {\n+            BType constraintType = ((BMapType) targetType).getConstrainedType();", "originalCommit": "39bbe770806904ada758446ee80c9df6cfeed410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTU2MDEyNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451560124", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-08T13:51:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2ODkwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2OTQwNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449669406", "bodyText": "Can't we use BTypes.typeJsonArray you've introduced?", "author": "MaryamZi", "createdAt": "2020-07-03T17:43:31Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE,\n+                            ((RefValue) value).getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (!TypeChecker.isConvertibleToJson(value, new ArrayList<>())) {\n+            return createConversionError(value, targetType);\n+        }\n+\n+        Object newValue;\n+        switch (TypeChecker.getType(value).getTag()) {\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+                newValue = ToString.toString(strand, value);\n+                break;\n+            case TypeTags.TUPLE_TAG:\n+            case TypeTags.ARRAY_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, unresolvedValues, strand);\n+                break;\n+            case TypeTags.TABLE_TAG:\n+                try {\n+                    newValue = JSONUtils.toJSON((TableValueImpl) value);\n+                } catch (Exception e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+                break;\n+            case TypeTags.RECORD_TYPE_TAG:\n+            case TypeTags.MAP_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, new BMapType(BTypes.typeJSON),\n+                        unresolvedValues, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                List<BType> convertibleTypes = TypeConverter.getConvertibleTypes(value, BTypes.typeJSON);\n+                if (convertibleTypes.size() == 0) {\n+                    throw createConversionError(value, targetType);\n+                } else if (convertibleTypes.size() > 1) {\n+                    throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+                }\n+\n+                BType sourceType = TypeChecker.getType(value);\n+                BType matchingType = convertibleTypes.get(0);\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                } else {\n+                    throw createConversionError(value, targetType);\n+                }\n+                break;\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMapToJson(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                           Strand strand) {\n+        MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+        for (Map.Entry entry : map.entrySet()) {\n+            BType constraintType = ((BMapType) targetType).getConstrainedType();\n+            putToMap(newMap, entry, constraintType, unresolvedValues, strand);\n+        }\n+        return newMap;\n+    }\n+\n+    private static Object convertArrayToJson(ArrayValue array, List<TypeValuePair> unresolvedValues,\n+                                             Strand strand) {\n+        ArrayValueImpl newArray = new ArrayValueImpl(new BArrayType(BTypes.typeJSON));", "originalCommit": "39bbe770806904ada758446ee80c9df6cfeed410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTU1Nzk4MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451557980", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-08T13:48:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2OTQwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2OTU0NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449669545", "bodyText": "We don't need a separate method for this right?", "author": "MaryamZi", "createdAt": "2020-07-03T17:44:16Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        BType targetJsonType = BTypes.typeJSON;\n+        try {\n+            return convert(value, targetJsonType, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE,\n+                            ((RefValue) value).getType()));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (!TypeChecker.isConvertibleToJson(value, new ArrayList<>())) {\n+            return createConversionError(value, targetType);\n+        }\n+\n+        Object newValue;\n+        switch (TypeChecker.getType(value).getTag()) {\n+            case TypeTags.XML_TAG:\n+            case TypeTags.XML_ELEMENT_TAG:\n+            case TypeTags.XML_COMMENT_TAG:\n+            case TypeTags.XML_PI_TAG:\n+            case TypeTags.XML_TEXT_TAG:\n+                newValue = ToString.toString(strand, value);\n+                break;\n+            case TypeTags.TUPLE_TAG:\n+            case TypeTags.ARRAY_TAG:\n+                newValue = convertArrayToJson((ArrayValue) value, unresolvedValues, strand);\n+                break;\n+            case TypeTags.TABLE_TAG:\n+                try {\n+                    newValue = JSONUtils.toJSON((TableValueImpl) value);\n+                } catch (Exception e) {\n+                    throw createConversionError(value, targetType, e.getMessage());\n+                }\n+                break;\n+            case TypeTags.RECORD_TYPE_TAG:\n+            case TypeTags.MAP_TAG:\n+                newValue = convertMapToJson((MapValue<?, ?>) value, new BMapType(BTypes.typeJSON),\n+                        unresolvedValues, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                List<BType> convertibleTypes = TypeConverter.getConvertibleTypes(value, BTypes.typeJSON);\n+                if (convertibleTypes.size() == 0) {\n+                    throw createConversionError(value, targetType);\n+                } else if (convertibleTypes.size() > 1) {\n+                    throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+                }\n+\n+                BType sourceType = TypeChecker.getType(value);\n+                BType matchingType = convertibleTypes.get(0);\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                } else {\n+                    throw createConversionError(value, targetType);\n+                }\n+                break;\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMapToJson(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                           Strand strand) {\n+        MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+        for (Map.Entry entry : map.entrySet()) {\n+            BType constraintType = ((BMapType) targetType).getConstrainedType();\n+            putToMap(newMap, entry, constraintType, unresolvedValues, strand);\n+        }\n+        return newMap;\n+    }\n+\n+    private static Object convertArrayToJson(ArrayValue array, List<TypeValuePair> unresolvedValues,\n+                                             Strand strand) {\n+        ArrayValueImpl newArray = new ArrayValueImpl(new BArrayType(BTypes.typeJSON));\n+        for (int i = 0; i < array.size(); i++) {\n+            Object newValue = convert(array.get(i), BTypes.typeJSON, unresolvedValues, strand);\n+            newArray.add(i, newValue);\n+        }\n+        return newArray;\n+    }\n+\n+    private static void putToMap(MapValue<BString, Object> map, Map.Entry entry, BType fieldType,", "originalCommit": "39bbe770806904ada758446ee80c9df6cfeed410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTU1Nzc5MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451557790", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-08T13:48:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY2OTU0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY3Mzg2Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449673862", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Test(enabled = true)\n          \n          \n            \n            @Test", "author": "MaryamZi", "createdAt": "2020-07-03T18:06:36Z", "path": "langlib/langlib-test/src/test/java/org/ballerinalang/langlib/test/LangLibValueTest.java", "diffHunk": "@@ -41,7 +41,7 @@\n  *\n  * @since 1.0\n  */\n-@Test(enabled = false)\n+@Test(enabled = true)", "originalCommit": "39bbe770806904ada758446ee80c9df6cfeed410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY3NzYzNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449677634", "bodyText": "We can just remove (enabled = false). Please fix everywhere.", "author": "MaryamZi", "createdAt": "2020-07-03T18:26:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY3Mzg2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg1MDY3NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451850674", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-08T22:04:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY3Mzg2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY3ODIyMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449678223", "bodyText": "Do we have to remove since we'll be creating a new list for each call to the method? Can you check others too.", "author": "MaryamZi", "createdAt": "2020-07-03T18:29:57Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                if (((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG &&\n+                        matchingType.getTag() <= TypeTags.XML_TEXT_TAG) || matchingType.getTag() == TypeTags.XML_TAG)) {\n+                    try {\n+                        newValue = XMLFactory.parse(((StringValue) value).getValue());\n+                        break;\n+                    } catch (Throwable e) {\n+                        throw createConversionError(value, targetType, e.getMessage());\n+                    }\n+                }\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                    break;\n+                }\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);", "originalCommit": "39bbe770806904ada758446ee80c9df6cfeed410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM4ODAzMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451388031", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-08T08:53:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY3ODIyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgwODI0NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451808244", "bodyText": "But, There can be situations like\npublic function main() {\n    json anObject = { name : \"anObject\", value : 10, sub : { subName : \"subObject\", subValue : 10 }};\n    string k = anObject.toJsonString();\n}\nif we remove this line :unresolvedValues.remove(typeValuePair); ,  10 will be duplicated inside unresolvedValues the fail. won't it?", "author": "dulajdilshan", "createdAt": "2020-07-08T20:31:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY3ODIyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY4MTQwMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r449681403", "bodyText": "We need to consider maps also right? And arrays/tuples?", "author": "MaryamZi", "createdAt": "2020-07-03T18:47:41Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java", "diffHunk": "@@ -263,7 +264,44 @@ static boolean isConvertibleToFloatingPointTypes(Object value) {\n         return convertibleTypes;\n     }\n \n-    private static boolean isConvertibleToRecordType(Object sourceValue, BRecordType targetType,\n+    public static List<BType> getConvertibleTypesFromJson(Object value, BType targetType,\n+                                                          List<TypeValuePair> unresolvedValues) {\n+        List<BType> convertibleTypes = new ArrayList<>();\n+\n+        int targetTypeTag = targetType.getTag();\n+\n+        convertibleTypes.addAll(TypeConverter.getConvertibleTypes(value, targetType));\n+\n+        if (convertibleTypes.size() == 0) {\n+            switch (targetTypeTag) {\n+                case TypeTags.RECORD_TYPE_TAG:", "originalCommit": "39bbe770806904ada758446ee80c9df6cfeed410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTM3MTI0MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r451371240", "bodyText": "They were caught in this method call in line: 310\nTypeConverter.getConvertibleTypes(value, targetType)", "author": "dulajdilshan", "createdAt": "2020-07-08T08:26:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY4MTQwMw=="}], "type": "inlineReview"}, {"oid": "4eab681541972b946f574cd3232aae86a19cb817", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4eab681541972b946f574cd3232aae86a19cb817", "message": "Do requested changes", "committedDate": "2020-07-08T23:16:23Z", "type": "forcePushed"}, {"oid": "2a31013c144b3612838e874c86d65cdfd2702d49", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2a31013c144b3612838e874c86d65cdfd2702d49", "message": "Do requested changes", "committedDate": "2020-07-09T01:05:22Z", "type": "forcePushed"}, {"oid": "69a619558a21aedaa2ac5727653f1b03e548c99e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/69a619558a21aedaa2ac5727653f1b03e548c99e", "message": "Add more tests", "committedDate": "2020-07-09T09:20:03Z", "type": "forcePushed"}, {"oid": "18319d65386ad7772f516aed1adbb4e5ba4896f8", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/18319d65386ad7772f516aed1adbb4e5ba4896f8", "message": "Add 'typeJsonArray' to BTypes", "committedDate": "2020-07-15T14:11:13Z", "type": "commit"}, {"oid": "584d1f4f88a7748393c236a367567ccd4113b8b1", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/584d1f4f88a7748393c236a367567ccd4113b8b1", "message": "Add 'fromJsonWithType' langlib method", "committedDate": "2020-07-15T14:11:13Z", "type": "commit"}, {"oid": "826fdf23b9d3eef7d7907a51ea8c768e957779b2", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/826fdf23b9d3eef7d7907a51ea8c768e957779b2", "message": "Add 'fromJsonStringWithType' langlib method", "committedDate": "2020-07-15T14:11:13Z", "type": "commit"}, {"oid": "08ec106ed797507f30ac84d2ddaabb73061138e2", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/08ec106ed797507f30ac84d2ddaabb73061138e2", "message": "Add 'toJson' langlib method", "committedDate": "2020-07-15T14:11:13Z", "type": "commit"}, {"oid": "5a1a546bf0e5c85fcee5e882af47e2000976f9fc", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5a1a546bf0e5c85fcee5e882af47e2000976f9fc", "message": "Allow \"toJsonString\" lanlib method to support for anydata type", "committedDate": "2020-07-15T14:11:13Z", "type": "commit"}, {"oid": "e16087ac3c123daff005349f682b357e8413bb76", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e16087ac3c123daff005349f682b357e8413bb76", "message": "Fix String to BString casting error", "committedDate": "2020-07-15T14:11:13Z", "type": "commit"}, {"oid": "7102f2b90bec1d8a9390d1ff8fafb1fc7ab3ad72", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7102f2b90bec1d8a9390d1ff8fafb1fc7ab3ad72", "message": "Add test cases", "committedDate": "2020-07-15T14:11:13Z", "type": "commit"}, {"oid": "5e950db86a85c766a500ff5549178165b5365e5d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5e950db86a85c766a500ff5549178165b5365e5d", "message": "Fix failing completion tests", "committedDate": "2020-07-15T14:11:13Z", "type": "commit"}, {"oid": "2b83515421b45e1e7d1b55aa65ed8409494cfeca", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2b83515421b45e1e7d1b55aa65ed8409494cfeca", "message": "Order langlib function descriptions", "committedDate": "2020-07-15T14:11:13Z", "type": "commit"}, {"oid": "bc38590c8df908dd7cf02cc1001c751330a02159", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bc38590c8df908dd7cf02cc1001c751330a02159", "message": "Change error message in 'fromJsonStringWithType' langlib method", "committedDate": "2020-07-15T14:11:13Z", "type": "commit"}, {"oid": "f34ad6fe935633d63c0a1756d276d4854db975cf", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f34ad6fe935633d63c0a1756d276d4854db975cf", "message": "Add support for xml-typed fields in table to json conversion", "committedDate": "2020-07-15T14:11:13Z", "type": "commit"}, {"oid": "c3d367ec5c9731c3200c4a7d8f36b58c2992d021", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c3d367ec5c9731c3200c4a7d8f36b58c2992d021", "message": "Add json to table conversion in \"fromJsonWithType\" langlib method", "committedDate": "2020-07-15T14:11:13Z", "type": "commit"}, {"oid": "4bdd9da0f1679bf81679e3ecea87298c3edb861c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4bdd9da0f1679bf81679e3ecea87298c3edb861c", "message": "Disable langlib value tests", "committedDate": "2020-07-15T14:11:13Z", "type": "commit"}, {"oid": "1bd08e5009ef6242c30a5e58f947ae8f68f8f289", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1bd08e5009ef6242c30a5e58f947ae8f68f8f289", "message": "Fix 24247", "committedDate": "2020-07-15T14:11:13Z", "type": "commit"}, {"oid": "1f0ac42e95261685d1ff9640a7e9840d94921fd4", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1f0ac42e95261685d1ff9640a7e9840d94921fd4", "message": "Fix errors in the langlib value tests", "committedDate": "2020-07-15T14:11:13Z", "type": "commit"}, {"oid": "2e69a1cd29698b34530672d87c94c48f962da06d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2e69a1cd29698b34530672d87c94c48f962da06d", "message": "Add more tests", "committedDate": "2020-07-15T14:11:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE3OTk0NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455179945", "bodyText": "This same method gets called for jsonutils:fromTable right? In that context, I am not sure if converting to string is the expected behaviour. I think what is expected is the result of applying jsonutils:fromXML. Shall we create an issue to track clarifying this with the stdlib team?\nI guess this is broken atm anyway, since record.getStringValue(key) is called for XML.", "author": "MaryamZi", "createdAt": "2020-07-15T16:32:09Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TableJSONDataSource.java", "diffHunk": "@@ -159,7 +159,9 @@ private static void constructJsonData(MapValueImpl record, MapValue<BString, Obj\n                         getStructData(record.getMapValue(key), structFields, index, key));\n                 break;\n             case TypeTags.XML_TAG:\n-                jsonObject.put(StringUtils.fromString(name), record.getStringValue(key));\n+                BString strVal = org.ballerinalang.jvm.StringUtils.fromString(\n+                        org.ballerinalang.jvm.values.utils.StringUtils.getStringValue(record.get(key)));", "originalCommit": "2e69a1cd29698b34530672d87c94c48f962da06d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE4MDU1OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455180559", "bodyText": "Checked with\nimport ballerina/jsonutils;\n\ntype Foo record {|\n    int i;\n    xml x;\n|};\n\npublic function main() {\n    table<Foo> tb = table [\n        {i: 1, x: xml `<foo>FOO</foo>`}\n    ];\n\n    json j = jsonutils:fromTable(tb);\n}\nFails with\n$ ballerina run qwe.bal \nCompiling source\n        qwe.bal\nRunning executables\n\nerror: java.lang.ClassCastException message=org.ballerinalang.jvm.values.XMLItem cannot be cast to org.ballerinalang.jvm.values.api.BString\n        at ballerina.0_5_0:externFromTable(jsonutils.bal:63)\n           ballerina.0_5_0:fromTable(jsonutils.bal:60)\n           qwe:main(qwe.bal:13)", "author": "MaryamZi", "createdAt": "2020-07-15T16:33:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE3OTk0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTIyNzM0MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455227341", "bodyText": "TypeConverter.getConvertibleTypes(value, targetType) calls isConvertibleToRecordType with isFromJson set to false right?\nWhat if targetType is a union of two records, say Foo|Bar, and the value is convertible to Foo even when  isFromJson is false in isConvertibleToRecordType, but it is only convertible to Bar when isFromJson is true?\nSo IINM, from L273 when we reach here convertibleTypes will only have Foo and we return that in L301. But if we actually check isConvertibleToRecordType(value, (BRecordType) targetType, true, unresolvedValues) it'll evaluate to true for Bar, and there'll actually be 2 convertible types?", "author": "MaryamZi", "createdAt": "2020-07-15T17:40:53Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java", "diffHunk": "@@ -263,7 +264,44 @@ static boolean isConvertibleToFloatingPointTypes(Object value) {\n         return convertibleTypes;\n     }\n \n-    private static boolean isConvertibleToRecordType(Object sourceValue, BRecordType targetType,\n+    public static List<BType> getConvertibleTypesFromJson(Object value, BType targetType,\n+                                                          List<TypeValuePair> unresolvedValues) {\n+        List<BType> convertibleTypes = new ArrayList<>();\n+\n+        int targetTypeTag = targetType.getTag();\n+\n+        convertibleTypes.addAll(TypeConverter.getConvertibleTypes(value, targetType));\n+\n+        if (convertibleTypes.size() == 0) {", "originalCommit": "2e69a1cd29698b34530672d87c94c48f962da06d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI1NDI5NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455254295", "bodyText": "For example\nimport ballerina/io;\n\ntype Foo record {|\n    int i;\n    xml x;\n|};\n\ntype Bar record {|\n    int i;\n    string x;\n|};\n\ntype FooBar Foo|Bar;\n\npublic function main() {\n    json j = {i: 1, x: \"<abc>ABC</abc>\"};\n\n    // No error.\n    io:println(j.fromJsonWithType(Foo)); // i=1 x=<abc>ABC</abc>\n    // No error.\n    io:println(j.fromJsonWithType(Bar)); // i=1 x=<abc>ABC</abc>\n\n    // Then this should be ambiguous?\n    io:println(j.fromJsonWithType(FooBar)); // i=1 x=<abc>ABC</abc>\n}", "author": "MaryamZi", "createdAt": "2020-07-15T18:24:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTIyNzM0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU4MDIzMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455580233", "bodyText": "Shouldn't this be okay according to this ?\nLet's take this\n io:println(j.fromJsonWithType(FooBar));\nWhen we reach L273, convertibleTypes will have only have Bar.  isn't it?", "author": "dulajdilshan", "createdAt": "2020-07-16T07:49:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTIyNzM0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY5NDM2Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455694367", "bodyText": "Ah, didn't know of the \"fromJsonWithType should only do something different from cloneWithType if cloneWithType would produce an error.\" part.\nYeah, this behaviour is correct then. Thanks!", "author": "MaryamZi", "createdAt": "2020-07-16T10:43:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTIyNzM0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI2Mzk3OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455263978", "bodyText": "Re: the constraint, the spec says\n\nThe type specified by a row-type-parameter must be a subtype of map<any|error>\n\nSo it is always a record or a map right? Do we need this check?", "author": "MaryamZi", "createdAt": "2020-07-15T18:41:07Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java", "diffHunk": "@@ -263,7 +264,44 @@ static boolean isConvertibleToFloatingPointTypes(Object value) {\n         return convertibleTypes;\n     }\n \n-    private static boolean isConvertibleToRecordType(Object sourceValue, BRecordType targetType,\n+    public static List<BType> getConvertibleTypesFromJson(Object value, BType targetType,\n+                                                          List<TypeValuePair> unresolvedValues) {\n+        List<BType> convertibleTypes = new ArrayList<>();\n+\n+        int targetTypeTag = targetType.getTag();\n+\n+        convertibleTypes.addAll(TypeConverter.getConvertibleTypes(value, targetType));\n+\n+        if (convertibleTypes.size() == 0) {\n+            switch (targetTypeTag) {\n+                case TypeTags.RECORD_TYPE_TAG:\n+                    if (isConvertibleToRecordType(value, (BRecordType) targetType, true, unresolvedValues)) {\n+                        convertibleTypes.add(targetType);\n+                    }\n+                    break;\n+                case TypeTags.TABLE_TAG:\n+                    if (((BTableType) targetType).getConstrainedType().getTag() == TypeTags.RECORD_TYPE_TAG ||\n+                            ((BTableType) targetType).getConstrainedType().getTag() == TypeTags.MAP_TAG) {", "originalCommit": "2e69a1cd29698b34530672d87c94c48f962da06d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYxMjg2MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455612860", "bodyText": "I think yes. because  If I remove the above-mentioned check,\ntype TableString table<string>;\npublic function main() {\n    json j = [\n        \"cake\",\n        \"buscuit\"\n    ];\n    table<string>|error tabString = j.fromJsonWithType(TableString);\n}\nThis works without giving a prior error for table<string>", "author": "dulajdilshan", "createdAt": "2020-07-16T08:25:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI2Mzk3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI3MzgwMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455273802", "bodyText": "Do we need this default case?", "author": "MaryamZi", "createdAt": "2020-07-15T18:58:22Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java", "diffHunk": "@@ -263,7 +264,44 @@ static boolean isConvertibleToFloatingPointTypes(Object value) {\n         return convertibleTypes;\n     }\n \n-    private static boolean isConvertibleToRecordType(Object sourceValue, BRecordType targetType,\n+    public static List<BType> getConvertibleTypesFromJson(Object value, BType targetType,\n+                                                          List<TypeValuePair> unresolvedValues) {\n+        List<BType> convertibleTypes = new ArrayList<>();\n+\n+        int targetTypeTag = targetType.getTag();\n+\n+        convertibleTypes.addAll(TypeConverter.getConvertibleTypes(value, targetType));\n+\n+        if (convertibleTypes.size() == 0) {\n+            switch (targetTypeTag) {\n+                case TypeTags.RECORD_TYPE_TAG:\n+                    if (isConvertibleToRecordType(value, (BRecordType) targetType, true, unresolvedValues)) {\n+                        convertibleTypes.add(targetType);\n+                    }\n+                    break;\n+                case TypeTags.TABLE_TAG:\n+                    if (((BTableType) targetType).getConstrainedType().getTag() == TypeTags.RECORD_TYPE_TAG ||\n+                            ((BTableType) targetType).getConstrainedType().getTag() == TypeTags.MAP_TAG) {\n+                        convertibleTypes.add(targetType);\n+                    }\n+                    break;\n+                case TypeTags.XML_TAG:\n+                case TypeTags.XML_ELEMENT_TAG:\n+                case TypeTags.XML_COMMENT_TAG:\n+                case TypeTags.XML_PI_TAG:\n+                case TypeTags.XML_TEXT_TAG:\n+                    if (TypeChecker.getType(value).getTag() == TypeTags.STRING_TAG) {\n+                        convertibleTypes.add(targetType);\n+                    }\n+                    break;\n+                default:\n+                    break;", "originalCommit": "2e69a1cd29698b34530672d87c94c48f962da06d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYxNTQ0Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455615446", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-16T08:29:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI3MzgwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI4MDM1Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455280352", "bodyText": "The only difference in the if and else blocks is the method called right? The arguments are all the same? Instead of the isFromJson parameter can we not use something like a functional interface, which I believe is what @rdhananjaya also suggested once.", "author": "MaryamZi", "createdAt": "2020-07-15T19:10:09Z", "path": "bvm/ballerina-runtime/src/main/java/org/ballerinalang/jvm/TypeConverter.java", "diffHunk": "@@ -299,17 +337,33 @@ private static boolean isConvertibleToRecordType(Object sourceValue, BRecordType\n             Map.Entry valueEntry = (Map.Entry) object;\n             String fieldName = valueEntry.getKey().toString();\n \n-            if (targetFieldTypes.containsKey(fieldName)) {\n-                if (getConvertibleTypes(valueEntry.getValue(), targetFieldTypes.get(fieldName),\n-                                        unresolvedValues).size() != 1) {\n+            if (isFromJson) {\n+                if (targetFieldTypes.containsKey(fieldName)) {\n+                    if (getConvertibleTypesFromJson(valueEntry.getValue(), targetFieldTypes.get(fieldName),", "originalCommit": "2e69a1cd29698b34530672d87c94c48f962da06d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI5MTEyOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455291129", "bodyText": "We need to check if the target type is nilable.\nThe folowing crashes.\ntype IntMap map<int>;\n\npublic function main() {\n    string s = \"null\";\n\n    map<int> m = checkpanic s.fromJsonStringWithType(IntMap); // doesn't panic\n\n    int i = m.get(\"first\");\n}\nThe get fails with an NPE in the internal log.\n[2020-07-16 00:57:59,786] SEVERE {b7a.log.crash} - null \njava.lang.NullPointerException\n\tat org.ballerinalang.langlib.map.Get.get(Get.java:45)\n\tat ballerina.lang_map.1_1_0.map.get(map.bal:51)\n\tat qwe.main(qwe.bal:8)\n\tat ___init.$lambda$main$(.)\n\tat org.ballerinalang.jvm.scheduling.SchedulerItem.execute(Scheduler.java:500)\n\tat org.ballerinalang.jvm.scheduling.Scheduler.run(Scheduler.java:276)\n\tat org.ballerinalang.jvm.scheduling.Scheduler.runSafely(Scheduler.java:244)\n\tat java.lang.Thread.run(Thread.java:745)", "author": "MaryamZi", "createdAt": "2020-07-15T19:29:32Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonStringWithType.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.JSONParser;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.CONSTRUCT_FROM_CONVERSION_ERROR;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ * Converts a string in JSON format to a user-specified type.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonStringWithType\",\n+        args = {\n+                @Argument(name = \"str\", type = TypeKind.STRING),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonStringWithType {\n+\n+    public static Object fromJsonStringWithType(Strand strand, BString value, TypedescValue t) {\n+\n+        String str = value.getValue();\n+        if (str.equals(\"null\")) {\n+            return null;", "originalCommit": "2e69a1cd29698b34530672d87c94c48f962da06d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI5MjY0OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455292649", "bodyText": "Do we need to special case \"null\" anyway? The JSONParser and FromJsonWithType.fromJsonWithType will handle this properly right?", "author": "MaryamZi", "createdAt": "2020-07-15T19:32:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI5MTEyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTUzODk4MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455538980", "bodyText": "Ack.", "author": "dulajdilshan", "createdAt": "2020-07-16T06:30:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI5MTEyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI5NjcyNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455296725", "bodyText": "A json value can never hold an error. Do we need this case?", "author": "MaryamZi", "createdAt": "2020-07-15T19:40:17Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());", "originalCommit": "2e69a1cd29698b34530672d87c94c48f962da06d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU0MzUxMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455543511", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-16T06:41:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI5NjcyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxMjg0OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455312848", "bodyText": "Can't we use org.ballerinalang.jvm.types.TypeTags#isXMLTypeTag here instead?", "author": "MaryamZi", "createdAt": "2020-07-15T20:10:33Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                if (((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG &&\n+                        matchingType.getTag() <= TypeTags.XML_TEXT_TAG) || matchingType.getTag() == TypeTags.XML_TAG)) {", "originalCommit": "2e69a1cd29698b34530672d87c94c48f962da06d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU1MDYyMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455550623", "bodyText": "Sure", "author": "dulajdilshan", "createdAt": "2020-07-16T06:56:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxMjg0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxOTI0OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455319249", "bodyText": "We should move this out of the for loop, or we'll be extracting the constraint per entry.", "author": "MaryamZi", "createdAt": "2020-07-15T20:22:39Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                if (((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG &&\n+                        matchingType.getTag() <= TypeTags.XML_TEXT_TAG) || matchingType.getTag() == TypeTags.XML_TAG)) {\n+                    try {\n+                        newValue = XMLFactory.parse(((StringValue) value).getValue());\n+                        break;\n+                    } catch (Throwable e) {\n+                        throw createConversionError(value, targetType, e.getMessage());\n+                    }\n+                }\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                    break;\n+                }\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMap(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                     TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+                MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType constraintType = ((BMapType) targetType).getConstrainedType();", "originalCommit": "2e69a1cd29698b34530672d87c94c48f962da06d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTU1NzE3MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455557170", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-16T07:10:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxOTI0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyMTA1Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455321052", "bodyText": "This also we don't need right?", "author": "MaryamZi", "createdAt": "2020-07-15T20:26:01Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                if (((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG &&\n+                        matchingType.getTag() <= TypeTags.XML_TEXT_TAG) || matchingType.getTag() == TypeTags.XML_TAG)) {\n+                    try {\n+                        newValue = XMLFactory.parse(((StringValue) value).getValue());\n+                        break;\n+                    } catch (Throwable e) {\n+                        throw createConversionError(value, targetType, e.getMessage());\n+                    }\n+                }\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                    break;\n+                }\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMap(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                     TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+                MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType constraintType = ((BMapType) targetType).getConstrainedType();\n+                    putToMap(newMap, entry, constraintType, unresolvedValues, t, strand);\n+                }\n+                return newMap;\n+            case TypeTags.RECORD_TYPE_TAG:\n+                BRecordType recordType = (BRecordType) targetType;\n+                MapValueImpl<BString, Object> newRecord;\n+                if (t != null && t.getDescribingType() == targetType) {\n+                    newRecord = (MapValueImpl<BString, Object>) t.instantiate(strand);\n+                } else {\n+                    newRecord = (MapValueImpl<BString, Object>) BallerinaValues\n+                            .createRecordValue(recordType.getPackage(), recordType.getName());\n+                }\n+\n+                BType restFieldType = recordType.restFieldType;\n+                Map<String, BType> targetTypeField = new HashMap<>();\n+                for (BField field : recordType.getFields().values()) {\n+                    targetTypeField.put(field.getFieldName(), field.getFieldType());\n+                }\n+\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType fieldType = targetTypeField.getOrDefault(entry.getKey().toString(), restFieldType);\n+                    putToMap(newRecord, entry, fieldType, unresolvedValues, t, strand);\n+                }\n+                return newRecord;\n+            case TypeTags.JSON_TAG:\n+                BType matchingType = TypeConverter.resolveMatchingTypeForUnion(map, targetType);\n+                return convert(map, matchingType, unresolvedValues, t, strand);\n+            default:", "originalCommit": "2e69a1cd29698b34530672d87c94c48f962da06d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYxODQ5NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455618495", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-16T08:34:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyMTA1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyMjc4NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455322784", "bodyText": "Better to pass the targetType itself instead of BTypes.typeJSON since it could be json & readonly.", "author": "MaryamZi", "createdAt": "2020-07-15T20:29:17Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                if (((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG &&\n+                        matchingType.getTag() <= TypeTags.XML_TEXT_TAG) || matchingType.getTag() == TypeTags.XML_TAG)) {\n+                    try {\n+                        newValue = XMLFactory.parse(((StringValue) value).getValue());\n+                        break;\n+                    } catch (Throwable e) {\n+                        throw createConversionError(value, targetType, e.getMessage());\n+                    }\n+                }\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                    break;\n+                }\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMap(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                     TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+                MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType constraintType = ((BMapType) targetType).getConstrainedType();\n+                    putToMap(newMap, entry, constraintType, unresolvedValues, t, strand);\n+                }\n+                return newMap;\n+            case TypeTags.RECORD_TYPE_TAG:\n+                BRecordType recordType = (BRecordType) targetType;\n+                MapValueImpl<BString, Object> newRecord;\n+                if (t != null && t.getDescribingType() == targetType) {\n+                    newRecord = (MapValueImpl<BString, Object>) t.instantiate(strand);\n+                } else {\n+                    newRecord = (MapValueImpl<BString, Object>) BallerinaValues\n+                            .createRecordValue(recordType.getPackage(), recordType.getName());\n+                }\n+\n+                BType restFieldType = recordType.restFieldType;\n+                Map<String, BType> targetTypeField = new HashMap<>();\n+                for (BField field : recordType.getFields().values()) {\n+                    targetTypeField.put(field.getFieldName(), field.getFieldType());\n+                }\n+\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType fieldType = targetTypeField.getOrDefault(entry.getKey().toString(), restFieldType);\n+                    putToMap(newRecord, entry, fieldType, unresolvedValues, t, strand);\n+                }\n+                return newRecord;\n+            case TypeTags.JSON_TAG:\n+                BType matchingType = TypeConverter.resolveMatchingTypeForUnion(map, targetType);\n+                return convert(map, matchingType, unresolvedValues, t, strand);\n+            default:\n+                break;\n+        }\n+        // should never reach here\n+        throw BallerinaErrors.createConversionError(map, targetType);\n+    }\n+\n+\n+    private static Object convertArray(ArrayValue array, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                       TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.ARRAY_TAG:\n+                BArrayType arrayType = (BArrayType) targetType;\n+                ArrayValueImpl newArray = new ArrayValueImpl(arrayType);\n+                for (int i = 0; i < array.size(); i++) {\n+                    Object newValue = convert(array.get(i), arrayType.getElementType(), unresolvedValues, t, strand);\n+                    newArray.add(i, newValue);\n+                }\n+                return newArray;\n+            case TypeTags.TUPLE_TAG:\n+                BTupleType tupleType = (BTupleType) targetType;\n+                TupleValueImpl newTuple = new TupleValueImpl(tupleType);\n+                int minLen = tupleType.getTupleTypes().size();\n+                for (int i = 0; i < array.size(); i++) {\n+                    BType elementType = (i < minLen) ? tupleType.getTupleTypes().get(i) : tupleType.getRestType();\n+                    Object newValue = convert(array.get(i), elementType, unresolvedValues, t, strand);\n+                    newTuple.add(i, newValue);\n+                }\n+                return newTuple;\n+            case TypeTags.JSON_TAG:\n+                newArray = new ArrayValueImpl((BArrayType) BTypes.typeJsonArray);\n+                for (int i = 0; i < array.size(); i++) {\n+                    Object newValue = convert(array.get(i), BTypes.typeJSON, unresolvedValues, t, strand);", "originalCommit": "2e69a1cd29698b34530672d87c94c48f962da06d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTcwMjgwNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455702807", "bodyText": "ok", "author": "dulajdilshan", "createdAt": "2020-07-16T10:59:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyMjc4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyMzgwNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455323807", "bodyText": "Why do we create a new type?", "author": "MaryamZi", "createdAt": "2020-07-15T20:31:12Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                if (((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG &&\n+                        matchingType.getTag() <= TypeTags.XML_TEXT_TAG) || matchingType.getTag() == TypeTags.XML_TAG)) {\n+                    try {\n+                        newValue = XMLFactory.parse(((StringValue) value).getValue());\n+                        break;\n+                    } catch (Throwable e) {\n+                        throw createConversionError(value, targetType, e.getMessage());\n+                    }\n+                }\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                    break;\n+                }\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMap(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                     TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+                MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType constraintType = ((BMapType) targetType).getConstrainedType();\n+                    putToMap(newMap, entry, constraintType, unresolvedValues, t, strand);\n+                }\n+                return newMap;\n+            case TypeTags.RECORD_TYPE_TAG:\n+                BRecordType recordType = (BRecordType) targetType;\n+                MapValueImpl<BString, Object> newRecord;\n+                if (t != null && t.getDescribingType() == targetType) {\n+                    newRecord = (MapValueImpl<BString, Object>) t.instantiate(strand);\n+                } else {\n+                    newRecord = (MapValueImpl<BString, Object>) BallerinaValues\n+                            .createRecordValue(recordType.getPackage(), recordType.getName());\n+                }\n+\n+                BType restFieldType = recordType.restFieldType;\n+                Map<String, BType> targetTypeField = new HashMap<>();\n+                for (BField field : recordType.getFields().values()) {\n+                    targetTypeField.put(field.getFieldName(), field.getFieldType());\n+                }\n+\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType fieldType = targetTypeField.getOrDefault(entry.getKey().toString(), restFieldType);\n+                    putToMap(newRecord, entry, fieldType, unresolvedValues, t, strand);\n+                }\n+                return newRecord;\n+            case TypeTags.JSON_TAG:\n+                BType matchingType = TypeConverter.resolveMatchingTypeForUnion(map, targetType);\n+                return convert(map, matchingType, unresolvedValues, t, strand);\n+            default:\n+                break;\n+        }\n+        // should never reach here\n+        throw BallerinaErrors.createConversionError(map, targetType);\n+    }\n+\n+\n+    private static Object convertArray(ArrayValue array, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                       TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.ARRAY_TAG:\n+                BArrayType arrayType = (BArrayType) targetType;\n+                ArrayValueImpl newArray = new ArrayValueImpl(arrayType);\n+                for (int i = 0; i < array.size(); i++) {\n+                    Object newValue = convert(array.get(i), arrayType.getElementType(), unresolvedValues, t, strand);\n+                    newArray.add(i, newValue);\n+                }\n+                return newArray;\n+            case TypeTags.TUPLE_TAG:\n+                BTupleType tupleType = (BTupleType) targetType;\n+                TupleValueImpl newTuple = new TupleValueImpl(tupleType);\n+                int minLen = tupleType.getTupleTypes().size();\n+                for (int i = 0; i < array.size(); i++) {\n+                    BType elementType = (i < minLen) ? tupleType.getTupleTypes().get(i) : tupleType.getRestType();\n+                    Object newValue = convert(array.get(i), elementType, unresolvedValues, t, strand);\n+                    newTuple.add(i, newValue);\n+                }\n+                return newTuple;\n+            case TypeTags.JSON_TAG:\n+                newArray = new ArrayValueImpl((BArrayType) BTypes.typeJsonArray);\n+                for (int i = 0; i < array.size(); i++) {\n+                    Object newValue = convert(array.get(i), BTypes.typeJSON, unresolvedValues, t, strand);\n+                    newArray.add(i, newValue);\n+                }\n+                return newArray;\n+            case TypeTags.TABLE_TAG:\n+                BTableType tableType = (BTableType) targetType;\n+\n+                BTableType newTableType = new BTableType(tableType.getConstrainedType(),", "originalCommit": "2e69a1cd29698b34530672d87c94c48f962da06d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY5OTc3Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455699773", "bodyText": "Removed", "author": "dulajdilshan", "createdAt": "2020-07-16T10:53:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyMzgwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMzNjg0Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455336846", "bodyText": "Do we ever reach here? All the numeric basic types are both anydata and json. So, I don't think you'll ever have to do a numeric conversion?", "author": "MaryamZi", "createdAt": "2020-07-15T20:55:57Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/ToJson.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.JSONUtils;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:toJson.\n+ * Converts a value of type `anydata` to `json`.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"toJson\",\n+        isPublic = true\n+)\n+public class ToJson {\n+\n+    public static Object toJson(Strand strand, Object value) {\n+        try {\n+            return convert(value, new ArrayList<>(), strand);\n+        } catch (Exception e) {\n+            return e;\n+        }\n+    }\n+\n+    private static Object convert(Object value, List<TypeValuePair> unresolvedValues, Strand strand) {\n+        BType jsonType = BTypes.typeJSON;\n+\n+        if (value == null) {\n+            return null;\n+        }\n+\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+            if (TypeChecker.checkIsType(value, jsonType)) {\n+                return value;\n+            } else {\n+                // Has to be a numeric conversion.", "originalCommit": "2e69a1cd29698b34530672d87c94c48f962da06d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTcxNzE5OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455717199", "bodyText": "Got it", "author": "dulajdilshan", "createdAt": "2020-07-16T11:28:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMzNjg0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYwOTcyOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455609729", "bodyText": "Do we need this null check here? t can never be null right?", "author": "pubudu91", "createdAt": "2020-07-16T08:20:17Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);\n+        } catch (ErrorValue e) {\n+            return e;\n+        } catch (BallerinaException e) {\n+            return createError(VALUE_LANG_LIB_CONVERSION_ERROR, e.getDetail());\n+        }\n+    }\n+\n+    private static Object convert(Object value, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                  TypedescValue t, Strand strand) {\n+\n+        TypeValuePair typeValuePair = new TypeValuePair(value, targetType);\n+        BType sourceType = TypeChecker.getType(value);\n+\n+        if (unresolvedValues.contains(typeValuePair)) {\n+            throw new BallerinaException(VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CYCLIC_VALUE_REFERENCE, sourceType));\n+        }\n+\n+        unresolvedValues.add(typeValuePair);\n+\n+        if (value == null) {\n+            if (targetType.isNilable()) {\n+                return null;\n+            }\n+            throw createError(VALUE_LANG_LIB_CONVERSION_ERROR,\n+                    BLangExceptionHelper.getErrorMessage(RuntimeErrors.CANNOT_CONVERT_NIL, targetType));\n+        }\n+\n+        List<BType> convertibleTypes = TypeConverter.getConvertibleTypesFromJson(value, targetType, new ArrayList<>());\n+        if (convertibleTypes.isEmpty()) {\n+            throw createConversionError(value, targetType);\n+        } else if (convertibleTypes.size() > 1) {\n+            throw createConversionError(value, targetType, AMBIGUOUS_TARGET);\n+        }\n+\n+        BType matchingType = convertibleTypes.get(0);\n+\n+        Object newValue;\n+        switch (sourceType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+            case TypeTags.RECORD_TYPE_TAG:\n+                newValue = convertMap((MapValue<?, ?>) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ARRAY_TAG:\n+            case TypeTags.TUPLE_TAG:\n+                newValue = convertArray((ArrayValue) value, matchingType, unresolvedValues, t, strand);\n+                break;\n+            case TypeTags.ERROR_TAG:\n+                newValue = ((RefValue) value).copy(new HashMap<>());\n+                break;\n+            default:\n+                if (((matchingType.getTag() >= TypeTags.XML_ELEMENT_TAG &&\n+                        matchingType.getTag() <= TypeTags.XML_TEXT_TAG) || matchingType.getTag() == TypeTags.XML_TAG)) {\n+                    try {\n+                        newValue = XMLFactory.parse(((StringValue) value).getValue());\n+                        break;\n+                    } catch (Throwable e) {\n+                        throw createConversionError(value, targetType, e.getMessage());\n+                    }\n+                }\n+\n+                // handle primitive values\n+                if (sourceType.getTag() <= TypeTags.BOOLEAN_TAG) {\n+                    if (TypeChecker.checkIsType(value, matchingType)) {\n+                        newValue = value;\n+                    } else {\n+                        // Has to be a numeric conversion.\n+                        newValue = TypeConverter.convertValues(matchingType, value);\n+                    }\n+                    break;\n+                }\n+                // should never reach here\n+                throw BallerinaErrors.createConversionError(value, targetType);\n+        }\n+\n+        unresolvedValues.remove(typeValuePair);\n+        return newValue;\n+    }\n+\n+    private static Object convertMap(MapValue<?, ?> map, BType targetType, List<TypeValuePair> unresolvedValues,\n+                                     TypedescValue t, Strand strand) {\n+        switch (targetType.getTag()) {\n+            case TypeTags.MAP_TAG:\n+                MapValueImpl<BString, Object> newMap = new MapValueImpl<>(targetType);\n+                for (Map.Entry entry : map.entrySet()) {\n+                    BType constraintType = ((BMapType) targetType).getConstrainedType();\n+                    putToMap(newMap, entry, constraintType, unresolvedValues, t, strand);\n+                }\n+                return newMap;\n+            case TypeTags.RECORD_TYPE_TAG:\n+                BRecordType recordType = (BRecordType) targetType;\n+                MapValueImpl<BString, Object> newRecord;\n+                if (t != null && t.getDescribingType() == targetType) {", "originalCommit": "2e69a1cd29698b34530672d87c94c48f962da06d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTcyMTMxNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455721314", "bodyText": "Ack", "author": "dulajdilshan", "createdAt": "2020-07-16T11:36:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYwOTcyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYxODY5NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455618694", "bodyText": "Is there a need to pass both t and describingType?", "author": "pubudu91", "createdAt": "2020-07-16T08:34:41Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonWithType.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.TypeChecker;\n+import org.ballerinalang.jvm.TypeConverter;\n+import org.ballerinalang.jvm.XMLFactory;\n+import org.ballerinalang.jvm.commons.TypeValuePair;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BField;\n+import org.ballerinalang.jvm.types.BMapType;\n+import org.ballerinalang.jvm.types.BRecordType;\n+import org.ballerinalang.jvm.types.BTableType;\n+import org.ballerinalang.jvm.types.BTupleType;\n+import org.ballerinalang.jvm.types.BType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.types.TypeTags;\n+import org.ballerinalang.jvm.util.exceptions.BLangExceptionHelper;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.util.exceptions.RuntimeErrors;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ArrayValueImpl;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.MapValueImpl;\n+import org.ballerinalang.jvm.values.RefValue;\n+import org.ballerinalang.jvm.values.StringValue;\n+import org.ballerinalang.jvm.values.TableValueImpl;\n+import org.ballerinalang.jvm.values.TupleValueImpl;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.ballerinalang.jvm.BallerinaErrors.createError;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CYCLIC_VALUE_REFERENCE_ERROR;\n+import static org.ballerinalang.jvm.util.exceptions.RuntimeErrors.INCOMPATIBLE_CONVERT_OPERATION;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonWithType\",\n+        isPublic = true\n+)\n+public class FromJsonWithType {\n+    private static final String AMBIGUOUS_TARGET = \"ambiguous target type\";\n+\n+    public static Object fromJsonWithType(Strand strand, Object v, TypedescValue t) {\n+        BType describingType = t.getDescribingType();\n+        try {\n+            return convert(v, describingType, new ArrayList<>(), t, strand);", "originalCommit": "2e69a1cd29698b34530672d87c94c48f962da06d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTc3Nzg5NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455777894", "bodyText": "I followed the same implementation as in the cloneWithType.\nconvert method is get called later. Sometimes, t and targetType both are  needed", "author": "dulajdilshan", "createdAt": "2020-07-16T13:17:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYxODY5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg1ODE2Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455858166", "bodyText": "My point was if you have t, you can always get the type from it. Anyways, not a major issue. Just gives the impression that target type can be some other type than what's described by t", "author": "pubudu91", "createdAt": "2020-07-16T15:06:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYxODY5NA=="}], "type": "inlineReview"}, {"oid": "32a33fc1798b697a55693b80a4d948526e932ea9", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/32a33fc1798b697a55693b80a4d948526e932ea9", "message": "Add fromJsonWIthType negative test", "committedDate": "2020-07-16T13:46:28Z", "type": "commit"}, {"oid": "e5430d4b59f2b4c5b8f768ef7a246d15c0d2f23a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e5430d4b59f2b4c5b8f768ef7a246d15c0d2f23a", "message": "Refactor \"toJson\" according to the code review suggestions", "committedDate": "2020-07-16T13:46:29Z", "type": "commit"}, {"oid": "470bf15ddd203933e41a785ab47c5c4be4ddd678", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/470bf15ddd203933e41a785ab47c5c4be4ddd678", "message": "Add value lang lib error message string", "committedDate": "2020-07-16T13:46:29Z", "type": "commit"}, {"oid": "7e5fbfb2ec384f5722593f972780e362dce450d2", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7e5fbfb2ec384f5722593f972780e362dce450d2", "message": "Refactor \"fromJsonWithType\" according to the code review suggestions", "committedDate": "2020-07-16T13:46:29Z", "type": "commit"}, {"oid": "f6adcd93547a952d138340eb1aa45e035622e6a9", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f6adcd93547a952d138340eb1aa45e035622e6a9", "message": "Fix error in the value lib test", "committedDate": "2020-07-16T13:46:29Z", "type": "commit"}, {"oid": "c7fb4adc13cf293ae82c9a318bf9c26eecca8b12", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c7fb4adc13cf293ae82c9a318bf9c26eecca8b12", "message": "Do requested changes", "committedDate": "2020-07-16T13:46:29Z", "type": "commit"}, {"oid": "558fb27f777cd1fb6fcf5f4d87aab7aac6f0b630", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/558fb27f777cd1fb6fcf5f4d87aab7aac6f0b630", "message": "Remove isConvertibleToJson method in TypeChecker", "committedDate": "2020-07-16T13:46:29Z", "type": "commit"}, {"oid": "04214fd7fd9ee8ac827123d407fa1c629fff0730", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/04214fd7fd9ee8ac827123d407fa1c629fff0730", "message": "Add more tests", "committedDate": "2020-07-16T13:46:30Z", "type": "commit"}, {"oid": "de711a0900748c01d3b478823bc6f073b2a2a285", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/de711a0900748c01d3b478823bc6f073b2a2a285", "message": "Change according to the suggestions", "committedDate": "2020-07-16T13:46:30Z", "type": "forcePushed"}, {"oid": "344e13a81c953c6fc2e2b7af0d156eba0227532d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/344e13a81c953c6fc2e2b7af0d156eba0227532d", "message": "Change according to the suggestions", "committedDate": "2020-07-16T14:22:18Z", "type": "commit"}, {"oid": "344e13a81c953c6fc2e2b7af0d156eba0227532d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/344e13a81c953c6fc2e2b7af0d156eba0227532d", "message": "Change according to the suggestions", "committedDate": "2020-07-16T14:22:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg2MTIyNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24057#discussion_r455861225", "bodyText": "I think what @MaryamZi meant was to simply pass str to the JSON parser without special casing \"null\".", "author": "pubudu91", "createdAt": "2020-07-16T15:10:12Z", "path": "langlib/lang.value/src/main/java/org/ballerinalang/langlib/value/FromJsonStringWithType.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.ballerinalang.langlib.value;\n+\n+import org.ballerinalang.jvm.BallerinaErrors;\n+import org.ballerinalang.jvm.JSONParser;\n+import org.ballerinalang.jvm.StringUtils;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.jvm.values.TypedescValue;\n+import org.ballerinalang.jvm.values.api.BString;\n+import org.ballerinalang.model.types.TypeKind;\n+import org.ballerinalang.natives.annotations.Argument;\n+import org.ballerinalang.natives.annotations.BallerinaFunction;\n+import org.ballerinalang.natives.annotations.ReturnType;\n+\n+import static org.ballerinalang.jvm.util.exceptions.BallerinaErrorReasons.VALUE_LANG_LIB_CONVERSION_ERROR;\n+import static org.ballerinalang.util.BLangCompilerConstants.VALUE_VERSION;\n+\n+/**\n+ * Extern function lang.values:fromJsonWithType.\n+ * Converts a string in JSON format to a user-specified type.\n+ *\n+ * @since 2.0\n+ */\n+@BallerinaFunction(\n+        orgName = \"ballerina\",\n+        packageName = \"lang.value\", version = VALUE_VERSION,\n+        functionName = \"fromJsonStringWithType\",\n+        args = {\n+                @Argument(name = \"str\", type = TypeKind.STRING),\n+                @Argument(name = \"t\", type = TypeKind.TYPEDESC)\n+        },\n+        returnType = {\n+                @ReturnType(type = TypeKind.ANYDATA),\n+                @ReturnType(type = TypeKind.ERROR)\n+        },\n+        isPublic = true\n+)\n+public class FromJsonStringWithType {\n+\n+    public static Object fromJsonStringWithType(Strand strand, BString value, TypedescValue t) {\n+\n+        String str = value.getValue();\n+        try {\n+            if (str.equals(\"null\")) {\n+                return FromJsonWithType.fromJsonWithType(strand, null, t);", "originalCommit": "344e13a81c953c6fc2e2b7af0d156eba0227532d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}