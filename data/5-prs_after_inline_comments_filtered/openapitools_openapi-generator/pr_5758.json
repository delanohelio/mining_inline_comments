{"pr_number": 5758, "pr_title": "New Generator: Scala akka-http server", "pr_createdAt": "2020-03-30T14:28:50Z", "pr_url": "https://github.com/OpenAPITools/openapi-generator/pull/5758", "timeline": [{"oid": "3bca919a6bc30cdbb37a65c2bd00ad4f62b6fe09", "url": "https://github.com/OpenAPITools/openapi-generator/commit/3bca919a6bc30cdbb37a65c2bd00ad4f62b6fe09", "message": "Scala akka-http server base implementation", "committedDate": "2020-03-28T03:45:59Z", "type": "commit"}, {"oid": "2c5230b583e18c0449ed627076aa245166a60756", "url": "https://github.com/OpenAPITools/openapi-generator/commit/2c5230b583e18c0449ed627076aa245166a60756", "message": "[scala-akka-http-server] petStore samples", "committedDate": "2020-03-28T03:46:13Z", "type": "commit"}, {"oid": "c6ee7be6047bb694a5837dfbebb998b71ca81d30", "url": "https://github.com/OpenAPITools/openapi-generator/commit/c6ee7be6047bb694a5837dfbebb998b71ca81d30", "message": "Improved the formatting of generated files", "committedDate": "2020-03-30T12:29:37Z", "type": "commit"}, {"oid": "0e4bf2e0145d416c5bac56dbb934d36440433aa4", "url": "https://github.com/OpenAPITools/openapi-generator/commit/0e4bf2e0145d416c5bac56dbb934d36440433aa4", "message": "Updated scala-akka-http server samples", "committedDate": "2020-03-30T12:29:57Z", "type": "commit"}, {"oid": "e5aa9f94b5dd9ae8ff59150136796855d83b2fe4", "url": "https://github.com/OpenAPITools/openapi-generator/commit/e5aa9f94b5dd9ae8ff59150136796855d83b2fe4", "message": "[scala-akka-http-server] the groupId, artifactId and artifactVersion default value are used as intended.", "committedDate": "2020-03-30T14:05:16Z", "type": "commit"}, {"oid": "1dcf064ac24d3ba1af8e326776bf89b1a15a6af0", "url": "https://github.com/OpenAPITools/openapi-generator/commit/1dcf064ac24d3ba1af8e326776bf89b1a15a6af0", "message": "Fixed the default operation not being correctly generated on parameterless operations", "committedDate": "2020-03-30T14:13:34Z", "type": "commit"}, {"oid": "d5f6028da3cc4b26ad3ac9cd27cfbbc91dfae665", "url": "https://github.com/OpenAPITools/openapi-generator/commit/d5f6028da3cc4b26ad3ac9cd27cfbbc91dfae665", "message": "Added build.sbt.mustache supporting file", "committedDate": "2020-03-30T14:14:07Z", "type": "commit"}, {"oid": "e1c7a43c453549a2b8955a4461309113996c18dc", "url": "https://github.com/OpenAPITools/openapi-generator/commit/e1c7a43c453549a2b8955a4461309113996c18dc", "message": "Updated scala-akka-http server samples", "committedDate": "2020-03-30T14:14:53Z", "type": "commit"}, {"oid": "673357420acfb6a48b1d954623423e7c4c227734", "url": "https://github.com/OpenAPITools/openapi-generator/commit/673357420acfb6a48b1d954623423e7c4c227734", "message": "ScalaAkkaHttpServer: Fixed a String.format call to use Locale.ROOT for locale", "committedDate": "2020-03-30T14:36:47Z", "type": "commit"}, {"oid": "1c513da61aa3ddfb0896d5a06bc11b7a7ed14a9c", "url": "https://github.com/OpenAPITools/openapi-generator/commit/1c513da61aa3ddfb0896d5a06bc11b7a7ed14a9c", "message": "[scala-akka-http-server] Fixed defaultValue being escaped during generation", "committedDate": "2020-03-30T15:32:43Z", "type": "commit"}, {"oid": "dde69cb0e5fc31a0b0fa656557477ff193a644f9", "url": "https://github.com/OpenAPITools/openapi-generator/commit/dde69cb0e5fc31a0b0fa656557477ff193a644f9", "message": "Added scala-akka-http.md", "committedDate": "2020-03-30T18:33:43Z", "type": "commit"}, {"oid": "5f980e7ffd44739a065252ff363f7844283be8a8", "url": "https://github.com/OpenAPITools/openapi-generator/commit/5f980e7ffd44739a065252ff363f7844283be8a8", "message": "Replaced all \"\u21d2\" character with \"=>\" to retain compatibility with scala 2.13", "committedDate": "2020-03-31T14:52:35Z", "type": "commit"}, {"oid": "de57a5d6aaf335f3cce75712691ea29262ed8437", "url": "https://github.com/OpenAPITools/openapi-generator/commit/de57a5d6aaf335f3cce75712691ea29262ed8437", "message": "[scala-akka-http] Added a config option akkaHttpVersion\nIt's set in the generated build.sbt.", "committedDate": "2020-03-31T14:54:00Z", "type": "commit"}, {"oid": "e31ab24ae746f97e34dbc95f140e077f0e70e214", "url": "https://github.com/OpenAPITools/openapi-generator/commit/e31ab24ae746f97e34dbc95f140e077f0e70e214", "message": "Updated scala-akka-http server samples", "committedDate": "2020-03-31T14:56:53Z", "type": "commit"}, {"oid": "e89e9afea27c506d52d7b211c72cb20ec48c2991", "url": "https://github.com/OpenAPITools/openapi-generator/commit/e89e9afea27c506d52d7b211c72cb20ec48c2991", "message": "Merge branch 'master' into scala-akka-http-server", "committedDate": "2020-03-31T14:59:10Z", "type": "commit"}, {"oid": "759370b5661ad2aaa50cfc3eaf1fa536fe3bc406", "url": "https://github.com/OpenAPITools/openapi-generator/commit/759370b5661ad2aaa50cfc3eaf1fa536fe3bc406", "message": "[scala-akka-http] More accurate akkaHttpVersion parsing", "committedDate": "2020-03-31T16:19:01Z", "type": "commit"}, {"oid": "0e50337e5d17e6d001110766cb68b864804c7398", "url": "https://github.com/OpenAPITools/openapi-generator/commit/0e50337e5d17e6d001110766cb68b864804c7398", "message": "Updated scala-akka-http.md", "committedDate": "2020-03-31T19:19:08Z", "type": "commit"}, {"oid": "a1742a3b86dab8e0ddcede66162359677f0b880a", "url": "https://github.com/OpenAPITools/openapi-generator/commit/a1742a3b86dab8e0ddcede66162359677f0b880a", "message": "Merge branch 'master' into scala-akka-http-server", "committedDate": "2020-04-02T09:00:47Z", "type": "commit"}, {"oid": "b3b769a353f36c6d9102cc3ef37a3c29c32e444f", "url": "https://github.com/OpenAPITools/openapi-generator/commit/b3b769a353f36c6d9102cc3ef37a3c29c32e444f", "message": "[scala-akka-http] Changed the akka-http version check to fix the generation of StringDirectives", "committedDate": "2020-04-03T16:41:39Z", "type": "commit"}, {"oid": "95bdbb865237712640de9057bb93cac8bc7a6410", "url": "https://github.com/OpenAPITools/openapi-generator/commit/95bdbb865237712640de9057bb93cac8bc7a6410", "message": "Updated scala-akka-http samples", "committedDate": "2020-04-03T16:42:08Z", "type": "commit"}, {"oid": "b86fdba8d36f5dabae309cc62786f9caca5255e9", "url": "https://github.com/OpenAPITools/openapi-generator/commit/b86fdba8d36f5dabae309cc62786f9caca5255e9", "message": "updated scala-akka-http.md", "committedDate": "2020-04-03T19:22:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ3ODU2Mw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5758#discussion_r403478563", "bodyText": "I'll rename it to \"scala-akka-http-server\" to follow our generator naming convention.", "author": "wing328", "createdAt": "2020-04-04T14:50:10Z", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/languages/ScalaAkkaHttpServerCodegen.java", "diffHunk": "@@ -0,0 +1,486 @@\n+package org.openapitools.codegen.languages;\n+\n+import io.swagger.v3.oas.models.Operation;\n+import io.swagger.v3.oas.models.parameters.Parameter;\n+import io.swagger.v3.oas.models.servers.Server;\n+import org.openapitools.codegen.*;\n+\n+import java.io.File;\n+import java.util.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.openapitools.codegen.meta.features.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ScalaAkkaHttpServerCodegen extends AbstractScalaCodegen implements CodegenConfig {\n+    protected String groupId;\n+    protected String artifactId;\n+    protected String artifactVersion;\n+    protected String invokerPackage;\n+\n+    protected String akkaHttpVersion;\n+\n+    public static final String AKKA_HTTP_VERSION = \"akkaHttpVersion\";\n+    public static final String AKKA_HTTP_VERSION_DESC = \"The version of akka-http\";\n+    public static final String DEFAULT_AKKA_HTTP_VERSION = \"10.1.10\";\n+\n+    static Logger LOGGER = LoggerFactory.getLogger(ScalaAkkaHttpServerCodegen.class);\n+\n+    public CodegenType getTag() {\n+        return CodegenType.SERVER;\n+    }\n+\n+    public String getName() {\n+        return \"scala-akka-http\";", "originalCommit": "b86fdba8d36f5dabae309cc62786f9caca5255e9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ4NDY5Mg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5758#discussion_r403484692", "bodyText": "We've trying to normalize the naming of vendor extensions. I wonder if you can rename hasDefaultValue to x-has-default-value instead.", "author": "wing328", "createdAt": "2020-04-04T15:49:30Z", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/languages/ScalaAkkaHttpServerCodegen.java", "diffHunk": "@@ -0,0 +1,486 @@\n+package org.openapitools.codegen.languages;\n+\n+import io.swagger.v3.oas.models.Operation;\n+import io.swagger.v3.oas.models.parameters.Parameter;\n+import io.swagger.v3.oas.models.servers.Server;\n+import org.openapitools.codegen.*;\n+\n+import java.io.File;\n+import java.util.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.openapitools.codegen.meta.features.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ScalaAkkaHttpServerCodegen extends AbstractScalaCodegen implements CodegenConfig {\n+    protected String groupId;\n+    protected String artifactId;\n+    protected String artifactVersion;\n+    protected String invokerPackage;\n+\n+    protected String akkaHttpVersion;\n+\n+    public static final String AKKA_HTTP_VERSION = \"akkaHttpVersion\";\n+    public static final String AKKA_HTTP_VERSION_DESC = \"The version of akka-http\";\n+    public static final String DEFAULT_AKKA_HTTP_VERSION = \"10.1.10\";\n+\n+    static Logger LOGGER = LoggerFactory.getLogger(ScalaAkkaHttpServerCodegen.class);\n+\n+    public CodegenType getTag() {\n+        return CodegenType.SERVER;\n+    }\n+\n+    public String getName() {\n+        return \"scala-akka-http\";\n+    }\n+\n+    public String getHelp() {\n+        return \"Generates a scala-akka-http server.\";\n+    }\n+\n+    public ScalaAkkaHttpServerCodegen() {\n+        super();\n+\n+        modifyFeatureSet(features -> features\n+                .includeDocumentationFeatures(DocumentationFeature.Readme)\n+                .wireFormatFeatures(EnumSet.of(WireFormatFeature.JSON, WireFormatFeature.XML, WireFormatFeature.Custom))\n+                .securityFeatures(EnumSet.of(\n+                        SecurityFeature.BasicAuth,\n+                        SecurityFeature.ApiKey,\n+                        SecurityFeature.BearerToken\n+                ))\n+                .excludeGlobalFeatures(\n+                        GlobalFeature.XMLStructureDefinitions,\n+                        GlobalFeature.Callbacks,\n+                        GlobalFeature.LinkObjects,\n+                        GlobalFeature.ParameterStyling\n+                )\n+                .excludeSchemaSupportFeatures(\n+                        SchemaSupportFeature.Polymorphism\n+                )\n+                .excludeParameterFeatures(\n+                        ParameterFeature.Cookie\n+                )\n+        );\n+\n+        outputFolder = \"generated-code\" + File.separator + \"scala-akka-http\";\n+        modelTemplateFiles.put(\"model.mustache\", \".scala\");\n+        apiTemplateFiles.put(\"api.mustache\", \".scala\");\n+        embeddedTemplateDir = templateDir = \"scala-akka-http-server\";\n+\n+        groupId = \"org.openapitools\";\n+        artifactId = \"openapi-scala-akka-http-server\";\n+        artifactVersion = \"1.0.0\";\n+        apiPackage = \"org.openapitools.server.api\";\n+        modelPackage = \"org.openapitools.server.model\";\n+        invokerPackage = \"org.openapitools.server\";\n+        akkaHttpVersion = DEFAULT_AKKA_HTTP_VERSION;\n+\n+        setReservedWordsLowerCase(\n+                Arrays.asList(\n+                        \"abstract\", \"case\", \"catch\", \"class\", \"def\", \"do\", \"else\", \"extends\",\n+                        \"false\", \"final\", \"finally\", \"for\", \"forSome\", \"if\", \"implicit\",\n+                        \"import\", \"lazy\", \"match\", \"new\", \"null\", \"object\", \"override\", \"package\",\n+                        \"private\", \"protected\", \"return\", \"sealed\", \"super\", \"this\", \"throw\",\n+                        \"trait\", \"try\", \"true\", \"type\", \"val\", \"var\", \"while\", \"with\", \"yield\")\n+        );\n+\n+        cliOptions.add(CliOption.newString(CodegenConstants.INVOKER_PACKAGE, CodegenConstants.INVOKER_PACKAGE_DESC).defaultValue(invokerPackage));\n+        cliOptions.add(CliOption.newString(CodegenConstants.GROUP_ID, CodegenConstants.GROUP_ID_DESC).defaultValue(groupId));\n+        cliOptions.add(CliOption.newString(CodegenConstants.ARTIFACT_ID, CodegenConstants.ARTIFACT_ID).defaultValue(artifactId));\n+        cliOptions.add(CliOption.newString(CodegenConstants.ARTIFACT_VERSION, CodegenConstants.ARTIFACT_VERSION_DESC).defaultValue(artifactVersion));\n+        cliOptions.add(CliOption.newString(AKKA_HTTP_VERSION, AKKA_HTTP_VERSION_DESC).defaultValue(akkaHttpVersion));\n+\n+        importMapping.remove(\"Seq\");\n+        importMapping.remove(\"List\");\n+        importMapping.remove(\"Set\");\n+        importMapping.remove(\"Map\");\n+\n+        typeMapping = new HashMap<>();\n+        typeMapping.put(\"array\", \"Seq\");\n+        typeMapping.put(\"set\", \"Set\");\n+        typeMapping.put(\"boolean\", \"Boolean\");\n+        typeMapping.put(\"string\", \"String\");\n+        typeMapping.put(\"int\", \"Int\");\n+        typeMapping.put(\"integer\", \"Int\");\n+        typeMapping.put(\"long\", \"Long\");\n+        typeMapping.put(\"float\", \"Float\");\n+        typeMapping.put(\"byte\", \"Byte\");\n+        typeMapping.put(\"short\", \"Short\");\n+        typeMapping.put(\"char\", \"Char\");\n+        typeMapping.put(\"double\", \"Double\");\n+        typeMapping.put(\"object\", \"Any\");\n+        typeMapping.put(\"file\", \"File\");\n+        typeMapping.put(\"binary\", \"File\");\n+        typeMapping.put(\"number\", \"Double\");\n+\n+        instantiationTypes.put(\"array\", \"ListBuffer\");\n+        instantiationTypes.put(\"map\", \"Map\");\n+\n+        supportingFiles.add(new SupportingFile(\"README.mustache\", \"\", \"README.md\"));\n+    }\n+\n+    @Override\n+    public void processOpts() {\n+        super.processOpts();\n+\n+        if (additionalProperties.containsKey(CodegenConstants.INVOKER_PACKAGE)) {\n+            invokerPackage = (String) additionalProperties.get(CodegenConstants.INVOKER_PACKAGE);\n+        } else {\n+            additionalProperties.put(CodegenConstants.INVOKER_PACKAGE, invokerPackage);\n+        }\n+\n+        if (additionalProperties.containsKey(CodegenConstants.GROUP_ID)) {\n+            groupId = (String) additionalProperties.get(CodegenConstants.GROUP_ID);\n+        } else {\n+            additionalProperties.put(CodegenConstants.GROUP_ID, groupId);\n+        }\n+\n+        if (additionalProperties.containsKey(CodegenConstants.ARTIFACT_ID)) {\n+            artifactId = (String) additionalProperties.get(CodegenConstants.ARTIFACT_ID);\n+        } else {\n+            additionalProperties.put(CodegenConstants.ARTIFACT_ID, artifactId);\n+        }\n+\n+        if (additionalProperties.containsKey(CodegenConstants.ARTIFACT_VERSION)) {\n+            artifactVersion = (String) additionalProperties.get(CodegenConstants.ARTIFACT_VERSION);\n+        } else {\n+            additionalProperties.put(CodegenConstants.ARTIFACT_VERSION, artifactVersion);\n+        }\n+\n+        if (additionalProperties.containsKey(AKKA_HTTP_VERSION)) {\n+            akkaHttpVersion = (String) additionalProperties.get(AKKA_HTTP_VERSION);\n+        } else {\n+            additionalProperties.put(AKKA_HTTP_VERSION, akkaHttpVersion);\n+        }\n+\n+        parseAkkaHttpVersion();\n+\n+        supportingFiles.add(new SupportingFile(\"build.sbt.mustache\", \"\", \"build.sbt\"));\n+        supportingFiles.add(new SupportingFile(\"controller.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"Controller.scala\"));\n+        supportingFiles.add(new SupportingFile(\"helper.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"AkkaHttpHelper.scala\"));\n+        supportingFiles.add(new SupportingFile(\"stringDirectives.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"StringDirectives.scala\"));\n+        supportingFiles.add(new SupportingFile(\"multipartDirectives.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"MultipartDirectives.scala\"));\n+    }\n+\n+    private static final String IS_10_1_10_PLUS = \"akkaHttp10_1_10_plus\";\n+    private boolean is10_1_10AndAbove = false;\n+\n+    private static final Pattern akkaVersionPattern = Pattern.compile(\"([0-9]+)(\\\\.([0-9]+))?(\\\\.([0-9]+))?(.\\\\+)?\");\n+    private void parseAkkaHttpVersion() {\n+        Matcher matcher = akkaVersionPattern.matcher(akkaHttpVersion);\n+        if (matcher.matches()) {\n+            String majorS = matcher.group(1);\n+            String minorS = matcher.group(3);\n+            String patchS = matcher.group(5);\n+            boolean andAbove = matcher.group(6) != null;\n+            int major = -1, minor = -1, patch = -1;\n+            try {\n+                if (majorS != null) {\n+                    major = Integer.parseInt(majorS);\n+                    if (minorS != null) {\n+                        minor = Integer.parseInt(minorS);\n+                        if (patchS != null) {\n+                            patch = Integer.parseInt(patchS);\n+                        }\n+                    }\n+                }\n+\n+\n+                if (major > 10 || major == -1 && andAbove) {\n+                    is10_1_10AndAbove = true;\n+                } else if (major == 10) {\n+                    if (minor > 1 || minor == -1 && andAbove) {\n+                        is10_1_10AndAbove = true;\n+                    } else if (minor == 1) {\n+                        if (patch >= 10 || patch == -1 && andAbove) {\n+                            is10_1_10AndAbove = true;\n+                        }\n+                    }\n+                }\n+\n+            } catch (NumberFormatException e) {\n+                LOGGER.warn(\"Unable to parse \" + AKKA_HTTP_VERSION + \": \" + akkaHttpVersion + \", fallback to \" + DEFAULT_AKKA_HTTP_VERSION);\n+                akkaHttpVersion = DEFAULT_AKKA_HTTP_VERSION;\n+                is10_1_10AndAbove = true;\n+            }\n+        }\n+\n+        additionalProperties.put(IS_10_1_10_PLUS, is10_1_10AndAbove);\n+    }\n+\n+    @Override\n+    public CodegenOperation fromOperation(String path, String httpMethod, Operation operation, List<Server> servers) {\n+        CodegenOperation codegenOperation = super.fromOperation(path, httpMethod, operation, servers);\n+        addPathMatcher(codegenOperation);\n+        return codegenOperation;\n+    }\n+\n+    @Override\n+    public CodegenParameter fromParameter(Parameter parameter, Set<String> imports) {\n+        CodegenParameter param = super.fromParameter(parameter, imports);\n+        // Removing unhandled types\n+        if(!primitiveParamTypes.contains(param.dataType)) {\n+            param.dataType = \"String\";\n+        }\n+        if (!param.required) {\n+            param.vendorExtensions.put(\"hasDefaultValue\", param.defaultValue != null);", "originalCommit": "b86fdba8d36f5dabae309cc62786f9caca5255e9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ4NDczNw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5758#discussion_r403484737", "bodyText": "We've trying to normalize the naming of vendor extensions. I wonder if you can rename paths to x-paths instead.", "author": "wing328", "createdAt": "2020-04-04T15:49:57Z", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/languages/ScalaAkkaHttpServerCodegen.java", "diffHunk": "@@ -0,0 +1,486 @@\n+package org.openapitools.codegen.languages;\n+\n+import io.swagger.v3.oas.models.Operation;\n+import io.swagger.v3.oas.models.parameters.Parameter;\n+import io.swagger.v3.oas.models.servers.Server;\n+import org.openapitools.codegen.*;\n+\n+import java.io.File;\n+import java.util.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.openapitools.codegen.meta.features.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ScalaAkkaHttpServerCodegen extends AbstractScalaCodegen implements CodegenConfig {\n+    protected String groupId;\n+    protected String artifactId;\n+    protected String artifactVersion;\n+    protected String invokerPackage;\n+\n+    protected String akkaHttpVersion;\n+\n+    public static final String AKKA_HTTP_VERSION = \"akkaHttpVersion\";\n+    public static final String AKKA_HTTP_VERSION_DESC = \"The version of akka-http\";\n+    public static final String DEFAULT_AKKA_HTTP_VERSION = \"10.1.10\";\n+\n+    static Logger LOGGER = LoggerFactory.getLogger(ScalaAkkaHttpServerCodegen.class);\n+\n+    public CodegenType getTag() {\n+        return CodegenType.SERVER;\n+    }\n+\n+    public String getName() {\n+        return \"scala-akka-http\";\n+    }\n+\n+    public String getHelp() {\n+        return \"Generates a scala-akka-http server.\";\n+    }\n+\n+    public ScalaAkkaHttpServerCodegen() {\n+        super();\n+\n+        modifyFeatureSet(features -> features\n+                .includeDocumentationFeatures(DocumentationFeature.Readme)\n+                .wireFormatFeatures(EnumSet.of(WireFormatFeature.JSON, WireFormatFeature.XML, WireFormatFeature.Custom))\n+                .securityFeatures(EnumSet.of(\n+                        SecurityFeature.BasicAuth,\n+                        SecurityFeature.ApiKey,\n+                        SecurityFeature.BearerToken\n+                ))\n+                .excludeGlobalFeatures(\n+                        GlobalFeature.XMLStructureDefinitions,\n+                        GlobalFeature.Callbacks,\n+                        GlobalFeature.LinkObjects,\n+                        GlobalFeature.ParameterStyling\n+                )\n+                .excludeSchemaSupportFeatures(\n+                        SchemaSupportFeature.Polymorphism\n+                )\n+                .excludeParameterFeatures(\n+                        ParameterFeature.Cookie\n+                )\n+        );\n+\n+        outputFolder = \"generated-code\" + File.separator + \"scala-akka-http\";\n+        modelTemplateFiles.put(\"model.mustache\", \".scala\");\n+        apiTemplateFiles.put(\"api.mustache\", \".scala\");\n+        embeddedTemplateDir = templateDir = \"scala-akka-http-server\";\n+\n+        groupId = \"org.openapitools\";\n+        artifactId = \"openapi-scala-akka-http-server\";\n+        artifactVersion = \"1.0.0\";\n+        apiPackage = \"org.openapitools.server.api\";\n+        modelPackage = \"org.openapitools.server.model\";\n+        invokerPackage = \"org.openapitools.server\";\n+        akkaHttpVersion = DEFAULT_AKKA_HTTP_VERSION;\n+\n+        setReservedWordsLowerCase(\n+                Arrays.asList(\n+                        \"abstract\", \"case\", \"catch\", \"class\", \"def\", \"do\", \"else\", \"extends\",\n+                        \"false\", \"final\", \"finally\", \"for\", \"forSome\", \"if\", \"implicit\",\n+                        \"import\", \"lazy\", \"match\", \"new\", \"null\", \"object\", \"override\", \"package\",\n+                        \"private\", \"protected\", \"return\", \"sealed\", \"super\", \"this\", \"throw\",\n+                        \"trait\", \"try\", \"true\", \"type\", \"val\", \"var\", \"while\", \"with\", \"yield\")\n+        );\n+\n+        cliOptions.add(CliOption.newString(CodegenConstants.INVOKER_PACKAGE, CodegenConstants.INVOKER_PACKAGE_DESC).defaultValue(invokerPackage));\n+        cliOptions.add(CliOption.newString(CodegenConstants.GROUP_ID, CodegenConstants.GROUP_ID_DESC).defaultValue(groupId));\n+        cliOptions.add(CliOption.newString(CodegenConstants.ARTIFACT_ID, CodegenConstants.ARTIFACT_ID).defaultValue(artifactId));\n+        cliOptions.add(CliOption.newString(CodegenConstants.ARTIFACT_VERSION, CodegenConstants.ARTIFACT_VERSION_DESC).defaultValue(artifactVersion));\n+        cliOptions.add(CliOption.newString(AKKA_HTTP_VERSION, AKKA_HTTP_VERSION_DESC).defaultValue(akkaHttpVersion));\n+\n+        importMapping.remove(\"Seq\");\n+        importMapping.remove(\"List\");\n+        importMapping.remove(\"Set\");\n+        importMapping.remove(\"Map\");\n+\n+        typeMapping = new HashMap<>();\n+        typeMapping.put(\"array\", \"Seq\");\n+        typeMapping.put(\"set\", \"Set\");\n+        typeMapping.put(\"boolean\", \"Boolean\");\n+        typeMapping.put(\"string\", \"String\");\n+        typeMapping.put(\"int\", \"Int\");\n+        typeMapping.put(\"integer\", \"Int\");\n+        typeMapping.put(\"long\", \"Long\");\n+        typeMapping.put(\"float\", \"Float\");\n+        typeMapping.put(\"byte\", \"Byte\");\n+        typeMapping.put(\"short\", \"Short\");\n+        typeMapping.put(\"char\", \"Char\");\n+        typeMapping.put(\"double\", \"Double\");\n+        typeMapping.put(\"object\", \"Any\");\n+        typeMapping.put(\"file\", \"File\");\n+        typeMapping.put(\"binary\", \"File\");\n+        typeMapping.put(\"number\", \"Double\");\n+\n+        instantiationTypes.put(\"array\", \"ListBuffer\");\n+        instantiationTypes.put(\"map\", \"Map\");\n+\n+        supportingFiles.add(new SupportingFile(\"README.mustache\", \"\", \"README.md\"));\n+    }\n+\n+    @Override\n+    public void processOpts() {\n+        super.processOpts();\n+\n+        if (additionalProperties.containsKey(CodegenConstants.INVOKER_PACKAGE)) {\n+            invokerPackage = (String) additionalProperties.get(CodegenConstants.INVOKER_PACKAGE);\n+        } else {\n+            additionalProperties.put(CodegenConstants.INVOKER_PACKAGE, invokerPackage);\n+        }\n+\n+        if (additionalProperties.containsKey(CodegenConstants.GROUP_ID)) {\n+            groupId = (String) additionalProperties.get(CodegenConstants.GROUP_ID);\n+        } else {\n+            additionalProperties.put(CodegenConstants.GROUP_ID, groupId);\n+        }\n+\n+        if (additionalProperties.containsKey(CodegenConstants.ARTIFACT_ID)) {\n+            artifactId = (String) additionalProperties.get(CodegenConstants.ARTIFACT_ID);\n+        } else {\n+            additionalProperties.put(CodegenConstants.ARTIFACT_ID, artifactId);\n+        }\n+\n+        if (additionalProperties.containsKey(CodegenConstants.ARTIFACT_VERSION)) {\n+            artifactVersion = (String) additionalProperties.get(CodegenConstants.ARTIFACT_VERSION);\n+        } else {\n+            additionalProperties.put(CodegenConstants.ARTIFACT_VERSION, artifactVersion);\n+        }\n+\n+        if (additionalProperties.containsKey(AKKA_HTTP_VERSION)) {\n+            akkaHttpVersion = (String) additionalProperties.get(AKKA_HTTP_VERSION);\n+        } else {\n+            additionalProperties.put(AKKA_HTTP_VERSION, akkaHttpVersion);\n+        }\n+\n+        parseAkkaHttpVersion();\n+\n+        supportingFiles.add(new SupportingFile(\"build.sbt.mustache\", \"\", \"build.sbt\"));\n+        supportingFiles.add(new SupportingFile(\"controller.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"Controller.scala\"));\n+        supportingFiles.add(new SupportingFile(\"helper.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"AkkaHttpHelper.scala\"));\n+        supportingFiles.add(new SupportingFile(\"stringDirectives.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"StringDirectives.scala\"));\n+        supportingFiles.add(new SupportingFile(\"multipartDirectives.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"MultipartDirectives.scala\"));\n+    }\n+\n+    private static final String IS_10_1_10_PLUS = \"akkaHttp10_1_10_plus\";\n+    private boolean is10_1_10AndAbove = false;\n+\n+    private static final Pattern akkaVersionPattern = Pattern.compile(\"([0-9]+)(\\\\.([0-9]+))?(\\\\.([0-9]+))?(.\\\\+)?\");\n+    private void parseAkkaHttpVersion() {\n+        Matcher matcher = akkaVersionPattern.matcher(akkaHttpVersion);\n+        if (matcher.matches()) {\n+            String majorS = matcher.group(1);\n+            String minorS = matcher.group(3);\n+            String patchS = matcher.group(5);\n+            boolean andAbove = matcher.group(6) != null;\n+            int major = -1, minor = -1, patch = -1;\n+            try {\n+                if (majorS != null) {\n+                    major = Integer.parseInt(majorS);\n+                    if (minorS != null) {\n+                        minor = Integer.parseInt(minorS);\n+                        if (patchS != null) {\n+                            patch = Integer.parseInt(patchS);\n+                        }\n+                    }\n+                }\n+\n+\n+                if (major > 10 || major == -1 && andAbove) {\n+                    is10_1_10AndAbove = true;\n+                } else if (major == 10) {\n+                    if (minor > 1 || minor == -1 && andAbove) {\n+                        is10_1_10AndAbove = true;\n+                    } else if (minor == 1) {\n+                        if (patch >= 10 || patch == -1 && andAbove) {\n+                            is10_1_10AndAbove = true;\n+                        }\n+                    }\n+                }\n+\n+            } catch (NumberFormatException e) {\n+                LOGGER.warn(\"Unable to parse \" + AKKA_HTTP_VERSION + \": \" + akkaHttpVersion + \", fallback to \" + DEFAULT_AKKA_HTTP_VERSION);\n+                akkaHttpVersion = DEFAULT_AKKA_HTTP_VERSION;\n+                is10_1_10AndAbove = true;\n+            }\n+        }\n+\n+        additionalProperties.put(IS_10_1_10_PLUS, is10_1_10AndAbove);\n+    }\n+\n+    @Override\n+    public CodegenOperation fromOperation(String path, String httpMethod, Operation operation, List<Server> servers) {\n+        CodegenOperation codegenOperation = super.fromOperation(path, httpMethod, operation, servers);\n+        addPathMatcher(codegenOperation);\n+        return codegenOperation;\n+    }\n+\n+    @Override\n+    public CodegenParameter fromParameter(Parameter parameter, Set<String> imports) {\n+        CodegenParameter param = super.fromParameter(parameter, imports);\n+        // Removing unhandled types\n+        if(!primitiveParamTypes.contains(param.dataType)) {\n+            param.dataType = \"String\";\n+        }\n+        if (!param.required) {\n+            param.vendorExtensions.put(\"hasDefaultValue\", param.defaultValue != null);\n+            // Escaping default string values\n+            if (param.defaultValue != null && param.dataType.equals(\"String\")) {\n+                param.defaultValue = String.format(Locale.ROOT, \"\\\"%s\\\"\", param.defaultValue);\n+            }\n+        }\n+        return param;\n+    }\n+\n+\n+\n+    @Override\n+    public Map<String, Object> postProcessOperationsWithModels(Map<String, Object> objs, List<Object> allModels) {\n+        Map<String, Object> baseObjs = super.postProcessOperationsWithModels(objs, allModels);\n+        pathMatcherPatternsPostProcessor(baseObjs);\n+        marshallingPostProcessor(baseObjs);\n+        return baseObjs;\n+    }\n+\n+    private static Set<String> primitiveParamTypes = new HashSet<String>(){{\n+        addAll(Arrays.asList(\n+                \"Int\",\n+                \"Long\",\n+                \"Float\",\n+                \"Double\",\n+                \"Boolean\",\n+                \"String\"\n+        ));\n+    }};\n+\n+    private static Map<String, String> pathTypeToMatcher = new HashMap<String, String>(){{\n+        put(\"Int\", \"IntNumber\");\n+        put(\"Long\", \"LongNumber\");\n+        put(\"Float\",\"FloatNumber\");\n+        put(\"Double\",\"DoubleNumber\");\n+        put(\"Boolean\",\"Boolean\");\n+        put(\"String\", \"Segment\");\n+    }};\n+\n+    protected static void addPathMatcher(CodegenOperation codegenOperation) {\n+        LinkedList<String> allPaths = new LinkedList<>(Arrays.asList(codegenOperation.path.split(\"/\")));\n+        allPaths.removeIf(\"\"::equals);\n+\n+        LinkedList<TextOrMatcher> pathMatchers = new LinkedList<>();\n+        for(String path: allPaths){\n+            TextOrMatcher textOrMatcher = new TextOrMatcher(\"\", true, true);\n+            if(path.startsWith(\"{\") && path.endsWith(\"}\")) {\n+                String parameterName = path.substring(1, path.length()-1);\n+                for(CodegenParameter pathParam: codegenOperation.pathParams){\n+                    if(pathParam.baseName.equals(parameterName)) {\n+                        String matcher = pathTypeToMatcher.get(pathParam.dataType);\n+                        if(matcher == null) {\n+                            LOGGER.warn(\"The path parameter \" + pathParam.baseName +\n+                                    \" with the datatype \" + pathParam.dataType +\n+                                    \" could not be translated to a corresponding path matcher of akka http\" +\n+                                    \" and therefore has been translated to string.\");\n+                            matcher = pathTypeToMatcher.get(\"String\");\n+                        }\n+                        if (pathParam.pattern != null && !pathParam.pattern.isEmpty()) {\n+                            matcher = pathMatcherPatternName(pathParam);\n+                        }\n+                        textOrMatcher.value = matcher;\n+                        textOrMatcher.isText = false;\n+                        pathMatchers.add(textOrMatcher);\n+                    }\n+                }\n+            } else {\n+                textOrMatcher.value = path;\n+                textOrMatcher.isText = true;\n+                pathMatchers.add(textOrMatcher);\n+            }\n+        }\n+        pathMatchers.getLast().hasMore = false;\n+\n+        codegenOperation.vendorExtensions.put(\"paths\", pathMatchers);", "originalCommit": "b86fdba8d36f5dabae309cc62786f9caca5255e9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ4NDc2MQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5758#discussion_r403484761", "bodyText": "We've trying to normalize the naming of vendor extensions. I wonder if you can rename x-isDefault to x-is-default instead.", "author": "wing328", "createdAt": "2020-04-04T15:50:22Z", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/languages/ScalaAkkaHttpServerCodegen.java", "diffHunk": "@@ -0,0 +1,486 @@\n+package org.openapitools.codegen.languages;\n+\n+import io.swagger.v3.oas.models.Operation;\n+import io.swagger.v3.oas.models.parameters.Parameter;\n+import io.swagger.v3.oas.models.servers.Server;\n+import org.openapitools.codegen.*;\n+\n+import java.io.File;\n+import java.util.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.openapitools.codegen.meta.features.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ScalaAkkaHttpServerCodegen extends AbstractScalaCodegen implements CodegenConfig {\n+    protected String groupId;\n+    protected String artifactId;\n+    protected String artifactVersion;\n+    protected String invokerPackage;\n+\n+    protected String akkaHttpVersion;\n+\n+    public static final String AKKA_HTTP_VERSION = \"akkaHttpVersion\";\n+    public static final String AKKA_HTTP_VERSION_DESC = \"The version of akka-http\";\n+    public static final String DEFAULT_AKKA_HTTP_VERSION = \"10.1.10\";\n+\n+    static Logger LOGGER = LoggerFactory.getLogger(ScalaAkkaHttpServerCodegen.class);\n+\n+    public CodegenType getTag() {\n+        return CodegenType.SERVER;\n+    }\n+\n+    public String getName() {\n+        return \"scala-akka-http\";\n+    }\n+\n+    public String getHelp() {\n+        return \"Generates a scala-akka-http server.\";\n+    }\n+\n+    public ScalaAkkaHttpServerCodegen() {\n+        super();\n+\n+        modifyFeatureSet(features -> features\n+                .includeDocumentationFeatures(DocumentationFeature.Readme)\n+                .wireFormatFeatures(EnumSet.of(WireFormatFeature.JSON, WireFormatFeature.XML, WireFormatFeature.Custom))\n+                .securityFeatures(EnumSet.of(\n+                        SecurityFeature.BasicAuth,\n+                        SecurityFeature.ApiKey,\n+                        SecurityFeature.BearerToken\n+                ))\n+                .excludeGlobalFeatures(\n+                        GlobalFeature.XMLStructureDefinitions,\n+                        GlobalFeature.Callbacks,\n+                        GlobalFeature.LinkObjects,\n+                        GlobalFeature.ParameterStyling\n+                )\n+                .excludeSchemaSupportFeatures(\n+                        SchemaSupportFeature.Polymorphism\n+                )\n+                .excludeParameterFeatures(\n+                        ParameterFeature.Cookie\n+                )\n+        );\n+\n+        outputFolder = \"generated-code\" + File.separator + \"scala-akka-http\";\n+        modelTemplateFiles.put(\"model.mustache\", \".scala\");\n+        apiTemplateFiles.put(\"api.mustache\", \".scala\");\n+        embeddedTemplateDir = templateDir = \"scala-akka-http-server\";\n+\n+        groupId = \"org.openapitools\";\n+        artifactId = \"openapi-scala-akka-http-server\";\n+        artifactVersion = \"1.0.0\";\n+        apiPackage = \"org.openapitools.server.api\";\n+        modelPackage = \"org.openapitools.server.model\";\n+        invokerPackage = \"org.openapitools.server\";\n+        akkaHttpVersion = DEFAULT_AKKA_HTTP_VERSION;\n+\n+        setReservedWordsLowerCase(\n+                Arrays.asList(\n+                        \"abstract\", \"case\", \"catch\", \"class\", \"def\", \"do\", \"else\", \"extends\",\n+                        \"false\", \"final\", \"finally\", \"for\", \"forSome\", \"if\", \"implicit\",\n+                        \"import\", \"lazy\", \"match\", \"new\", \"null\", \"object\", \"override\", \"package\",\n+                        \"private\", \"protected\", \"return\", \"sealed\", \"super\", \"this\", \"throw\",\n+                        \"trait\", \"try\", \"true\", \"type\", \"val\", \"var\", \"while\", \"with\", \"yield\")\n+        );\n+\n+        cliOptions.add(CliOption.newString(CodegenConstants.INVOKER_PACKAGE, CodegenConstants.INVOKER_PACKAGE_DESC).defaultValue(invokerPackage));\n+        cliOptions.add(CliOption.newString(CodegenConstants.GROUP_ID, CodegenConstants.GROUP_ID_DESC).defaultValue(groupId));\n+        cliOptions.add(CliOption.newString(CodegenConstants.ARTIFACT_ID, CodegenConstants.ARTIFACT_ID).defaultValue(artifactId));\n+        cliOptions.add(CliOption.newString(CodegenConstants.ARTIFACT_VERSION, CodegenConstants.ARTIFACT_VERSION_DESC).defaultValue(artifactVersion));\n+        cliOptions.add(CliOption.newString(AKKA_HTTP_VERSION, AKKA_HTTP_VERSION_DESC).defaultValue(akkaHttpVersion));\n+\n+        importMapping.remove(\"Seq\");\n+        importMapping.remove(\"List\");\n+        importMapping.remove(\"Set\");\n+        importMapping.remove(\"Map\");\n+\n+        typeMapping = new HashMap<>();\n+        typeMapping.put(\"array\", \"Seq\");\n+        typeMapping.put(\"set\", \"Set\");\n+        typeMapping.put(\"boolean\", \"Boolean\");\n+        typeMapping.put(\"string\", \"String\");\n+        typeMapping.put(\"int\", \"Int\");\n+        typeMapping.put(\"integer\", \"Int\");\n+        typeMapping.put(\"long\", \"Long\");\n+        typeMapping.put(\"float\", \"Float\");\n+        typeMapping.put(\"byte\", \"Byte\");\n+        typeMapping.put(\"short\", \"Short\");\n+        typeMapping.put(\"char\", \"Char\");\n+        typeMapping.put(\"double\", \"Double\");\n+        typeMapping.put(\"object\", \"Any\");\n+        typeMapping.put(\"file\", \"File\");\n+        typeMapping.put(\"binary\", \"File\");\n+        typeMapping.put(\"number\", \"Double\");\n+\n+        instantiationTypes.put(\"array\", \"ListBuffer\");\n+        instantiationTypes.put(\"map\", \"Map\");\n+\n+        supportingFiles.add(new SupportingFile(\"README.mustache\", \"\", \"README.md\"));\n+    }\n+\n+    @Override\n+    public void processOpts() {\n+        super.processOpts();\n+\n+        if (additionalProperties.containsKey(CodegenConstants.INVOKER_PACKAGE)) {\n+            invokerPackage = (String) additionalProperties.get(CodegenConstants.INVOKER_PACKAGE);\n+        } else {\n+            additionalProperties.put(CodegenConstants.INVOKER_PACKAGE, invokerPackage);\n+        }\n+\n+        if (additionalProperties.containsKey(CodegenConstants.GROUP_ID)) {\n+            groupId = (String) additionalProperties.get(CodegenConstants.GROUP_ID);\n+        } else {\n+            additionalProperties.put(CodegenConstants.GROUP_ID, groupId);\n+        }\n+\n+        if (additionalProperties.containsKey(CodegenConstants.ARTIFACT_ID)) {\n+            artifactId = (String) additionalProperties.get(CodegenConstants.ARTIFACT_ID);\n+        } else {\n+            additionalProperties.put(CodegenConstants.ARTIFACT_ID, artifactId);\n+        }\n+\n+        if (additionalProperties.containsKey(CodegenConstants.ARTIFACT_VERSION)) {\n+            artifactVersion = (String) additionalProperties.get(CodegenConstants.ARTIFACT_VERSION);\n+        } else {\n+            additionalProperties.put(CodegenConstants.ARTIFACT_VERSION, artifactVersion);\n+        }\n+\n+        if (additionalProperties.containsKey(AKKA_HTTP_VERSION)) {\n+            akkaHttpVersion = (String) additionalProperties.get(AKKA_HTTP_VERSION);\n+        } else {\n+            additionalProperties.put(AKKA_HTTP_VERSION, akkaHttpVersion);\n+        }\n+\n+        parseAkkaHttpVersion();\n+\n+        supportingFiles.add(new SupportingFile(\"build.sbt.mustache\", \"\", \"build.sbt\"));\n+        supportingFiles.add(new SupportingFile(\"controller.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"Controller.scala\"));\n+        supportingFiles.add(new SupportingFile(\"helper.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"AkkaHttpHelper.scala\"));\n+        supportingFiles.add(new SupportingFile(\"stringDirectives.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"StringDirectives.scala\"));\n+        supportingFiles.add(new SupportingFile(\"multipartDirectives.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"MultipartDirectives.scala\"));\n+    }\n+\n+    private static final String IS_10_1_10_PLUS = \"akkaHttp10_1_10_plus\";\n+    private boolean is10_1_10AndAbove = false;\n+\n+    private static final Pattern akkaVersionPattern = Pattern.compile(\"([0-9]+)(\\\\.([0-9]+))?(\\\\.([0-9]+))?(.\\\\+)?\");\n+    private void parseAkkaHttpVersion() {\n+        Matcher matcher = akkaVersionPattern.matcher(akkaHttpVersion);\n+        if (matcher.matches()) {\n+            String majorS = matcher.group(1);\n+            String minorS = matcher.group(3);\n+            String patchS = matcher.group(5);\n+            boolean andAbove = matcher.group(6) != null;\n+            int major = -1, minor = -1, patch = -1;\n+            try {\n+                if (majorS != null) {\n+                    major = Integer.parseInt(majorS);\n+                    if (minorS != null) {\n+                        minor = Integer.parseInt(minorS);\n+                        if (patchS != null) {\n+                            patch = Integer.parseInt(patchS);\n+                        }\n+                    }\n+                }\n+\n+\n+                if (major > 10 || major == -1 && andAbove) {\n+                    is10_1_10AndAbove = true;\n+                } else if (major == 10) {\n+                    if (minor > 1 || minor == -1 && andAbove) {\n+                        is10_1_10AndAbove = true;\n+                    } else if (minor == 1) {\n+                        if (patch >= 10 || patch == -1 && andAbove) {\n+                            is10_1_10AndAbove = true;\n+                        }\n+                    }\n+                }\n+\n+            } catch (NumberFormatException e) {\n+                LOGGER.warn(\"Unable to parse \" + AKKA_HTTP_VERSION + \": \" + akkaHttpVersion + \", fallback to \" + DEFAULT_AKKA_HTTP_VERSION);\n+                akkaHttpVersion = DEFAULT_AKKA_HTTP_VERSION;\n+                is10_1_10AndAbove = true;\n+            }\n+        }\n+\n+        additionalProperties.put(IS_10_1_10_PLUS, is10_1_10AndAbove);\n+    }\n+\n+    @Override\n+    public CodegenOperation fromOperation(String path, String httpMethod, Operation operation, List<Server> servers) {\n+        CodegenOperation codegenOperation = super.fromOperation(path, httpMethod, operation, servers);\n+        addPathMatcher(codegenOperation);\n+        return codegenOperation;\n+    }\n+\n+    @Override\n+    public CodegenParameter fromParameter(Parameter parameter, Set<String> imports) {\n+        CodegenParameter param = super.fromParameter(parameter, imports);\n+        // Removing unhandled types\n+        if(!primitiveParamTypes.contains(param.dataType)) {\n+            param.dataType = \"String\";\n+        }\n+        if (!param.required) {\n+            param.vendorExtensions.put(\"hasDefaultValue\", param.defaultValue != null);\n+            // Escaping default string values\n+            if (param.defaultValue != null && param.dataType.equals(\"String\")) {\n+                param.defaultValue = String.format(Locale.ROOT, \"\\\"%s\\\"\", param.defaultValue);\n+            }\n+        }\n+        return param;\n+    }\n+\n+\n+\n+    @Override\n+    public Map<String, Object> postProcessOperationsWithModels(Map<String, Object> objs, List<Object> allModels) {\n+        Map<String, Object> baseObjs = super.postProcessOperationsWithModels(objs, allModels);\n+        pathMatcherPatternsPostProcessor(baseObjs);\n+        marshallingPostProcessor(baseObjs);\n+        return baseObjs;\n+    }\n+\n+    private static Set<String> primitiveParamTypes = new HashSet<String>(){{\n+        addAll(Arrays.asList(\n+                \"Int\",\n+                \"Long\",\n+                \"Float\",\n+                \"Double\",\n+                \"Boolean\",\n+                \"String\"\n+        ));\n+    }};\n+\n+    private static Map<String, String> pathTypeToMatcher = new HashMap<String, String>(){{\n+        put(\"Int\", \"IntNumber\");\n+        put(\"Long\", \"LongNumber\");\n+        put(\"Float\",\"FloatNumber\");\n+        put(\"Double\",\"DoubleNumber\");\n+        put(\"Boolean\",\"Boolean\");\n+        put(\"String\", \"Segment\");\n+    }};\n+\n+    protected static void addPathMatcher(CodegenOperation codegenOperation) {\n+        LinkedList<String> allPaths = new LinkedList<>(Arrays.asList(codegenOperation.path.split(\"/\")));\n+        allPaths.removeIf(\"\"::equals);\n+\n+        LinkedList<TextOrMatcher> pathMatchers = new LinkedList<>();\n+        for(String path: allPaths){\n+            TextOrMatcher textOrMatcher = new TextOrMatcher(\"\", true, true);\n+            if(path.startsWith(\"{\") && path.endsWith(\"}\")) {\n+                String parameterName = path.substring(1, path.length()-1);\n+                for(CodegenParameter pathParam: codegenOperation.pathParams){\n+                    if(pathParam.baseName.equals(parameterName)) {\n+                        String matcher = pathTypeToMatcher.get(pathParam.dataType);\n+                        if(matcher == null) {\n+                            LOGGER.warn(\"The path parameter \" + pathParam.baseName +\n+                                    \" with the datatype \" + pathParam.dataType +\n+                                    \" could not be translated to a corresponding path matcher of akka http\" +\n+                                    \" and therefore has been translated to string.\");\n+                            matcher = pathTypeToMatcher.get(\"String\");\n+                        }\n+                        if (pathParam.pattern != null && !pathParam.pattern.isEmpty()) {\n+                            matcher = pathMatcherPatternName(pathParam);\n+                        }\n+                        textOrMatcher.value = matcher;\n+                        textOrMatcher.isText = false;\n+                        pathMatchers.add(textOrMatcher);\n+                    }\n+                }\n+            } else {\n+                textOrMatcher.value = path;\n+                textOrMatcher.isText = true;\n+                pathMatchers.add(textOrMatcher);\n+            }\n+        }\n+        pathMatchers.getLast().hasMore = false;\n+\n+        codegenOperation.vendorExtensions.put(\"paths\", pathMatchers);\n+    }\n+\n+    public static String PATH_MATCHER_PATTERNS_KEY = \"pathMatcherPatterns\";\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static void pathMatcherPatternsPostProcessor(Map<String, Object> objs) {\n+        if (objs != null) {\n+            HashMap<String, PathMatcherPattern> patternMap = new HashMap<>();\n+            Map<String, Object> operations = (Map<String, Object>) objs.get(\"operations\");\n+            if (operations != null) {\n+                List<CodegenOperation> ops = (List<CodegenOperation>) operations.get(\"operation\");\n+                for (CodegenOperation operation: ops) {\n+                    for (CodegenParameter parameter: operation.pathParams) {\n+                        if (parameter.pattern != null && !parameter.pattern.isEmpty()) {\n+                            String name = pathMatcherPatternName(parameter);\n+                            if (!patternMap.containsKey(name)) {\n+                                patternMap.put(name, new PathMatcherPattern(name, parameter.pattern.substring(1, parameter.pattern.length() - 1)));\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            objs.put(PATH_MATCHER_PATTERNS_KEY, new ArrayList<>(patternMap.values()));\n+        }\n+    }\n+\n+    private static String pathMatcherPatternName(CodegenParameter parameter) {\n+        return parameter.paramName + \"Pattern\";\n+    }\n+\n+    // Responsible for setting up Marshallers/Unmarshallers\n+    @SuppressWarnings(\"unchecked\")\n+    public static void marshallingPostProcessor(Map<String, Object> objs) {\n+\n+        if (objs == null) {\n+            return;\n+        }\n+\n+        Set<Marshaller> entityUnmarshallerTypes = new HashSet<>();\n+        Set<Marshaller> entityMarshallerTypes = new HashSet<>();\n+        Set<Marshaller> stringUnmarshallerTypes = new HashSet<>();\n+        boolean hasCookieParams = false;\n+        boolean hasMultipart = false;\n+\n+        Map<String, Object> operations = (Map<String, Object>) objs.get(\"operations\");\n+        if (operations != null) {\n+            List<CodegenOperation> operationList = (List<CodegenOperation>) operations.get(\"operation\");\n+\n+            for (CodegenOperation op : operationList) {\n+                boolean isMultipart = op.isMultipart;\n+                hasMultipart |= isMultipart;\n+                hasCookieParams |= op.getHasCookieParams();\n+                ArrayList<CodegenParameter> fileParams = new ArrayList<>();\n+                ArrayList<CodegenParameter> nonFileParams = new ArrayList<>();\n+                for (CodegenParameter parameter : op.allParams) {\n+                    if (parameter.isBodyParam || parameter.isFormParam) {\n+                        if (parameter.isFile) {\n+                            fileParams.add(parameter.copy());\n+                        } else {\n+                            nonFileParams.add(parameter.copy());\n+                        }\n+                        if (!parameter.isPrimitiveType) {\n+                            if (isMultipart) {\n+                                stringUnmarshallerTypes.add(new Marshaller(parameter));\n+                            } else {\n+                                entityUnmarshallerTypes.add(new Marshaller(parameter));\n+                            }\n+                        }\n+                    }\n+                }\n+                for (int i = 0, size = fileParams.size(); i < size; ++i) {\n+                    fileParams.get(i).hasMore = i < size - 1;\n+                }\n+                for (int i = 0, size = nonFileParams.size(); i < size; ++i) {\n+                    nonFileParams.get(i).hasMore = i < size - 1;\n+                }\n+\n+                HashSet<Marshaller> operationSpecificMarshallers = new HashSet<>();\n+                for (CodegenResponse response : op.responses) {\n+                    if (!response.primitiveType) {\n+                        Marshaller marshaller = new Marshaller(response);\n+                        entityMarshallerTypes.add(marshaller);\n+                        operationSpecificMarshallers.add(marshaller);\n+                    }\n+                    response.vendorExtensions.put(\"isDefault\", response.code.equals(\"0\"));", "originalCommit": "b86fdba8d36f5dabae309cc62786f9caca5255e9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ4NDg4OQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/5758#discussion_r403484889", "bodyText": "We're trying to normalize the naming of vendor extensions. I wonder if you can rename the extensions as followings:\n\nspecificMarshallers  to x-specific-marshallers \nfileParams to x-file-params\nnonFileParams to x-non-file-params", "author": "wing328", "createdAt": "2020-04-04T15:51:46Z", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/languages/ScalaAkkaHttpServerCodegen.java", "diffHunk": "@@ -0,0 +1,486 @@\n+package org.openapitools.codegen.languages;\n+\n+import io.swagger.v3.oas.models.Operation;\n+import io.swagger.v3.oas.models.parameters.Parameter;\n+import io.swagger.v3.oas.models.servers.Server;\n+import org.openapitools.codegen.*;\n+\n+import java.io.File;\n+import java.util.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.openapitools.codegen.meta.features.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ScalaAkkaHttpServerCodegen extends AbstractScalaCodegen implements CodegenConfig {\n+    protected String groupId;\n+    protected String artifactId;\n+    protected String artifactVersion;\n+    protected String invokerPackage;\n+\n+    protected String akkaHttpVersion;\n+\n+    public static final String AKKA_HTTP_VERSION = \"akkaHttpVersion\";\n+    public static final String AKKA_HTTP_VERSION_DESC = \"The version of akka-http\";\n+    public static final String DEFAULT_AKKA_HTTP_VERSION = \"10.1.10\";\n+\n+    static Logger LOGGER = LoggerFactory.getLogger(ScalaAkkaHttpServerCodegen.class);\n+\n+    public CodegenType getTag() {\n+        return CodegenType.SERVER;\n+    }\n+\n+    public String getName() {\n+        return \"scala-akka-http\";\n+    }\n+\n+    public String getHelp() {\n+        return \"Generates a scala-akka-http server.\";\n+    }\n+\n+    public ScalaAkkaHttpServerCodegen() {\n+        super();\n+\n+        modifyFeatureSet(features -> features\n+                .includeDocumentationFeatures(DocumentationFeature.Readme)\n+                .wireFormatFeatures(EnumSet.of(WireFormatFeature.JSON, WireFormatFeature.XML, WireFormatFeature.Custom))\n+                .securityFeatures(EnumSet.of(\n+                        SecurityFeature.BasicAuth,\n+                        SecurityFeature.ApiKey,\n+                        SecurityFeature.BearerToken\n+                ))\n+                .excludeGlobalFeatures(\n+                        GlobalFeature.XMLStructureDefinitions,\n+                        GlobalFeature.Callbacks,\n+                        GlobalFeature.LinkObjects,\n+                        GlobalFeature.ParameterStyling\n+                )\n+                .excludeSchemaSupportFeatures(\n+                        SchemaSupportFeature.Polymorphism\n+                )\n+                .excludeParameterFeatures(\n+                        ParameterFeature.Cookie\n+                )\n+        );\n+\n+        outputFolder = \"generated-code\" + File.separator + \"scala-akka-http\";\n+        modelTemplateFiles.put(\"model.mustache\", \".scala\");\n+        apiTemplateFiles.put(\"api.mustache\", \".scala\");\n+        embeddedTemplateDir = templateDir = \"scala-akka-http-server\";\n+\n+        groupId = \"org.openapitools\";\n+        artifactId = \"openapi-scala-akka-http-server\";\n+        artifactVersion = \"1.0.0\";\n+        apiPackage = \"org.openapitools.server.api\";\n+        modelPackage = \"org.openapitools.server.model\";\n+        invokerPackage = \"org.openapitools.server\";\n+        akkaHttpVersion = DEFAULT_AKKA_HTTP_VERSION;\n+\n+        setReservedWordsLowerCase(\n+                Arrays.asList(\n+                        \"abstract\", \"case\", \"catch\", \"class\", \"def\", \"do\", \"else\", \"extends\",\n+                        \"false\", \"final\", \"finally\", \"for\", \"forSome\", \"if\", \"implicit\",\n+                        \"import\", \"lazy\", \"match\", \"new\", \"null\", \"object\", \"override\", \"package\",\n+                        \"private\", \"protected\", \"return\", \"sealed\", \"super\", \"this\", \"throw\",\n+                        \"trait\", \"try\", \"true\", \"type\", \"val\", \"var\", \"while\", \"with\", \"yield\")\n+        );\n+\n+        cliOptions.add(CliOption.newString(CodegenConstants.INVOKER_PACKAGE, CodegenConstants.INVOKER_PACKAGE_DESC).defaultValue(invokerPackage));\n+        cliOptions.add(CliOption.newString(CodegenConstants.GROUP_ID, CodegenConstants.GROUP_ID_DESC).defaultValue(groupId));\n+        cliOptions.add(CliOption.newString(CodegenConstants.ARTIFACT_ID, CodegenConstants.ARTIFACT_ID).defaultValue(artifactId));\n+        cliOptions.add(CliOption.newString(CodegenConstants.ARTIFACT_VERSION, CodegenConstants.ARTIFACT_VERSION_DESC).defaultValue(artifactVersion));\n+        cliOptions.add(CliOption.newString(AKKA_HTTP_VERSION, AKKA_HTTP_VERSION_DESC).defaultValue(akkaHttpVersion));\n+\n+        importMapping.remove(\"Seq\");\n+        importMapping.remove(\"List\");\n+        importMapping.remove(\"Set\");\n+        importMapping.remove(\"Map\");\n+\n+        typeMapping = new HashMap<>();\n+        typeMapping.put(\"array\", \"Seq\");\n+        typeMapping.put(\"set\", \"Set\");\n+        typeMapping.put(\"boolean\", \"Boolean\");\n+        typeMapping.put(\"string\", \"String\");\n+        typeMapping.put(\"int\", \"Int\");\n+        typeMapping.put(\"integer\", \"Int\");\n+        typeMapping.put(\"long\", \"Long\");\n+        typeMapping.put(\"float\", \"Float\");\n+        typeMapping.put(\"byte\", \"Byte\");\n+        typeMapping.put(\"short\", \"Short\");\n+        typeMapping.put(\"char\", \"Char\");\n+        typeMapping.put(\"double\", \"Double\");\n+        typeMapping.put(\"object\", \"Any\");\n+        typeMapping.put(\"file\", \"File\");\n+        typeMapping.put(\"binary\", \"File\");\n+        typeMapping.put(\"number\", \"Double\");\n+\n+        instantiationTypes.put(\"array\", \"ListBuffer\");\n+        instantiationTypes.put(\"map\", \"Map\");\n+\n+        supportingFiles.add(new SupportingFile(\"README.mustache\", \"\", \"README.md\"));\n+    }\n+\n+    @Override\n+    public void processOpts() {\n+        super.processOpts();\n+\n+        if (additionalProperties.containsKey(CodegenConstants.INVOKER_PACKAGE)) {\n+            invokerPackage = (String) additionalProperties.get(CodegenConstants.INVOKER_PACKAGE);\n+        } else {\n+            additionalProperties.put(CodegenConstants.INVOKER_PACKAGE, invokerPackage);\n+        }\n+\n+        if (additionalProperties.containsKey(CodegenConstants.GROUP_ID)) {\n+            groupId = (String) additionalProperties.get(CodegenConstants.GROUP_ID);\n+        } else {\n+            additionalProperties.put(CodegenConstants.GROUP_ID, groupId);\n+        }\n+\n+        if (additionalProperties.containsKey(CodegenConstants.ARTIFACT_ID)) {\n+            artifactId = (String) additionalProperties.get(CodegenConstants.ARTIFACT_ID);\n+        } else {\n+            additionalProperties.put(CodegenConstants.ARTIFACT_ID, artifactId);\n+        }\n+\n+        if (additionalProperties.containsKey(CodegenConstants.ARTIFACT_VERSION)) {\n+            artifactVersion = (String) additionalProperties.get(CodegenConstants.ARTIFACT_VERSION);\n+        } else {\n+            additionalProperties.put(CodegenConstants.ARTIFACT_VERSION, artifactVersion);\n+        }\n+\n+        if (additionalProperties.containsKey(AKKA_HTTP_VERSION)) {\n+            akkaHttpVersion = (String) additionalProperties.get(AKKA_HTTP_VERSION);\n+        } else {\n+            additionalProperties.put(AKKA_HTTP_VERSION, akkaHttpVersion);\n+        }\n+\n+        parseAkkaHttpVersion();\n+\n+        supportingFiles.add(new SupportingFile(\"build.sbt.mustache\", \"\", \"build.sbt\"));\n+        supportingFiles.add(new SupportingFile(\"controller.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"Controller.scala\"));\n+        supportingFiles.add(new SupportingFile(\"helper.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"AkkaHttpHelper.scala\"));\n+        supportingFiles.add(new SupportingFile(\"stringDirectives.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"StringDirectives.scala\"));\n+        supportingFiles.add(new SupportingFile(\"multipartDirectives.mustache\",\n+                (sourceFolder + File.separator + invokerPackage).replace(\".\", java.io.File.separator), \"MultipartDirectives.scala\"));\n+    }\n+\n+    private static final String IS_10_1_10_PLUS = \"akkaHttp10_1_10_plus\";\n+    private boolean is10_1_10AndAbove = false;\n+\n+    private static final Pattern akkaVersionPattern = Pattern.compile(\"([0-9]+)(\\\\.([0-9]+))?(\\\\.([0-9]+))?(.\\\\+)?\");\n+    private void parseAkkaHttpVersion() {\n+        Matcher matcher = akkaVersionPattern.matcher(akkaHttpVersion);\n+        if (matcher.matches()) {\n+            String majorS = matcher.group(1);\n+            String minorS = matcher.group(3);\n+            String patchS = matcher.group(5);\n+            boolean andAbove = matcher.group(6) != null;\n+            int major = -1, minor = -1, patch = -1;\n+            try {\n+                if (majorS != null) {\n+                    major = Integer.parseInt(majorS);\n+                    if (minorS != null) {\n+                        minor = Integer.parseInt(minorS);\n+                        if (patchS != null) {\n+                            patch = Integer.parseInt(patchS);\n+                        }\n+                    }\n+                }\n+\n+\n+                if (major > 10 || major == -1 && andAbove) {\n+                    is10_1_10AndAbove = true;\n+                } else if (major == 10) {\n+                    if (minor > 1 || minor == -1 && andAbove) {\n+                        is10_1_10AndAbove = true;\n+                    } else if (minor == 1) {\n+                        if (patch >= 10 || patch == -1 && andAbove) {\n+                            is10_1_10AndAbove = true;\n+                        }\n+                    }\n+                }\n+\n+            } catch (NumberFormatException e) {\n+                LOGGER.warn(\"Unable to parse \" + AKKA_HTTP_VERSION + \": \" + akkaHttpVersion + \", fallback to \" + DEFAULT_AKKA_HTTP_VERSION);\n+                akkaHttpVersion = DEFAULT_AKKA_HTTP_VERSION;\n+                is10_1_10AndAbove = true;\n+            }\n+        }\n+\n+        additionalProperties.put(IS_10_1_10_PLUS, is10_1_10AndAbove);\n+    }\n+\n+    @Override\n+    public CodegenOperation fromOperation(String path, String httpMethod, Operation operation, List<Server> servers) {\n+        CodegenOperation codegenOperation = super.fromOperation(path, httpMethod, operation, servers);\n+        addPathMatcher(codegenOperation);\n+        return codegenOperation;\n+    }\n+\n+    @Override\n+    public CodegenParameter fromParameter(Parameter parameter, Set<String> imports) {\n+        CodegenParameter param = super.fromParameter(parameter, imports);\n+        // Removing unhandled types\n+        if(!primitiveParamTypes.contains(param.dataType)) {\n+            param.dataType = \"String\";\n+        }\n+        if (!param.required) {\n+            param.vendorExtensions.put(\"hasDefaultValue\", param.defaultValue != null);\n+            // Escaping default string values\n+            if (param.defaultValue != null && param.dataType.equals(\"String\")) {\n+                param.defaultValue = String.format(Locale.ROOT, \"\\\"%s\\\"\", param.defaultValue);\n+            }\n+        }\n+        return param;\n+    }\n+\n+\n+\n+    @Override\n+    public Map<String, Object> postProcessOperationsWithModels(Map<String, Object> objs, List<Object> allModels) {\n+        Map<String, Object> baseObjs = super.postProcessOperationsWithModels(objs, allModels);\n+        pathMatcherPatternsPostProcessor(baseObjs);\n+        marshallingPostProcessor(baseObjs);\n+        return baseObjs;\n+    }\n+\n+    private static Set<String> primitiveParamTypes = new HashSet<String>(){{\n+        addAll(Arrays.asList(\n+                \"Int\",\n+                \"Long\",\n+                \"Float\",\n+                \"Double\",\n+                \"Boolean\",\n+                \"String\"\n+        ));\n+    }};\n+\n+    private static Map<String, String> pathTypeToMatcher = new HashMap<String, String>(){{\n+        put(\"Int\", \"IntNumber\");\n+        put(\"Long\", \"LongNumber\");\n+        put(\"Float\",\"FloatNumber\");\n+        put(\"Double\",\"DoubleNumber\");\n+        put(\"Boolean\",\"Boolean\");\n+        put(\"String\", \"Segment\");\n+    }};\n+\n+    protected static void addPathMatcher(CodegenOperation codegenOperation) {\n+        LinkedList<String> allPaths = new LinkedList<>(Arrays.asList(codegenOperation.path.split(\"/\")));\n+        allPaths.removeIf(\"\"::equals);\n+\n+        LinkedList<TextOrMatcher> pathMatchers = new LinkedList<>();\n+        for(String path: allPaths){\n+            TextOrMatcher textOrMatcher = new TextOrMatcher(\"\", true, true);\n+            if(path.startsWith(\"{\") && path.endsWith(\"}\")) {\n+                String parameterName = path.substring(1, path.length()-1);\n+                for(CodegenParameter pathParam: codegenOperation.pathParams){\n+                    if(pathParam.baseName.equals(parameterName)) {\n+                        String matcher = pathTypeToMatcher.get(pathParam.dataType);\n+                        if(matcher == null) {\n+                            LOGGER.warn(\"The path parameter \" + pathParam.baseName +\n+                                    \" with the datatype \" + pathParam.dataType +\n+                                    \" could not be translated to a corresponding path matcher of akka http\" +\n+                                    \" and therefore has been translated to string.\");\n+                            matcher = pathTypeToMatcher.get(\"String\");\n+                        }\n+                        if (pathParam.pattern != null && !pathParam.pattern.isEmpty()) {\n+                            matcher = pathMatcherPatternName(pathParam);\n+                        }\n+                        textOrMatcher.value = matcher;\n+                        textOrMatcher.isText = false;\n+                        pathMatchers.add(textOrMatcher);\n+                    }\n+                }\n+            } else {\n+                textOrMatcher.value = path;\n+                textOrMatcher.isText = true;\n+                pathMatchers.add(textOrMatcher);\n+            }\n+        }\n+        pathMatchers.getLast().hasMore = false;\n+\n+        codegenOperation.vendorExtensions.put(\"paths\", pathMatchers);\n+    }\n+\n+    public static String PATH_MATCHER_PATTERNS_KEY = \"pathMatcherPatterns\";\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static void pathMatcherPatternsPostProcessor(Map<String, Object> objs) {\n+        if (objs != null) {\n+            HashMap<String, PathMatcherPattern> patternMap = new HashMap<>();\n+            Map<String, Object> operations = (Map<String, Object>) objs.get(\"operations\");\n+            if (operations != null) {\n+                List<CodegenOperation> ops = (List<CodegenOperation>) operations.get(\"operation\");\n+                for (CodegenOperation operation: ops) {\n+                    for (CodegenParameter parameter: operation.pathParams) {\n+                        if (parameter.pattern != null && !parameter.pattern.isEmpty()) {\n+                            String name = pathMatcherPatternName(parameter);\n+                            if (!patternMap.containsKey(name)) {\n+                                patternMap.put(name, new PathMatcherPattern(name, parameter.pattern.substring(1, parameter.pattern.length() - 1)));\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            objs.put(PATH_MATCHER_PATTERNS_KEY, new ArrayList<>(patternMap.values()));\n+        }\n+    }\n+\n+    private static String pathMatcherPatternName(CodegenParameter parameter) {\n+        return parameter.paramName + \"Pattern\";\n+    }\n+\n+    // Responsible for setting up Marshallers/Unmarshallers\n+    @SuppressWarnings(\"unchecked\")\n+    public static void marshallingPostProcessor(Map<String, Object> objs) {\n+\n+        if (objs == null) {\n+            return;\n+        }\n+\n+        Set<Marshaller> entityUnmarshallerTypes = new HashSet<>();\n+        Set<Marshaller> entityMarshallerTypes = new HashSet<>();\n+        Set<Marshaller> stringUnmarshallerTypes = new HashSet<>();\n+        boolean hasCookieParams = false;\n+        boolean hasMultipart = false;\n+\n+        Map<String, Object> operations = (Map<String, Object>) objs.get(\"operations\");\n+        if (operations != null) {\n+            List<CodegenOperation> operationList = (List<CodegenOperation>) operations.get(\"operation\");\n+\n+            for (CodegenOperation op : operationList) {\n+                boolean isMultipart = op.isMultipart;\n+                hasMultipart |= isMultipart;\n+                hasCookieParams |= op.getHasCookieParams();\n+                ArrayList<CodegenParameter> fileParams = new ArrayList<>();\n+                ArrayList<CodegenParameter> nonFileParams = new ArrayList<>();\n+                for (CodegenParameter parameter : op.allParams) {\n+                    if (parameter.isBodyParam || parameter.isFormParam) {\n+                        if (parameter.isFile) {\n+                            fileParams.add(parameter.copy());\n+                        } else {\n+                            nonFileParams.add(parameter.copy());\n+                        }\n+                        if (!parameter.isPrimitiveType) {\n+                            if (isMultipart) {\n+                                stringUnmarshallerTypes.add(new Marshaller(parameter));\n+                            } else {\n+                                entityUnmarshallerTypes.add(new Marshaller(parameter));\n+                            }\n+                        }\n+                    }\n+                }\n+                for (int i = 0, size = fileParams.size(); i < size; ++i) {\n+                    fileParams.get(i).hasMore = i < size - 1;\n+                }\n+                for (int i = 0, size = nonFileParams.size(); i < size; ++i) {\n+                    nonFileParams.get(i).hasMore = i < size - 1;\n+                }\n+\n+                HashSet<Marshaller> operationSpecificMarshallers = new HashSet<>();\n+                for (CodegenResponse response : op.responses) {\n+                    if (!response.primitiveType) {\n+                        Marshaller marshaller = new Marshaller(response);\n+                        entityMarshallerTypes.add(marshaller);\n+                        operationSpecificMarshallers.add(marshaller);\n+                    }\n+                    response.vendorExtensions.put(\"isDefault\", response.code.equals(\"0\"));\n+                }\n+                op.vendorExtensions.put(\"specificMarshallers\", operationSpecificMarshallers);\n+                op.vendorExtensions.put(\"fileParams\", fileParams);\n+                op.vendorExtensions.put(\"nonFileParams\", nonFileParams);", "originalCommit": "b86fdba8d36f5dabae309cc62786f9caca5255e9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}