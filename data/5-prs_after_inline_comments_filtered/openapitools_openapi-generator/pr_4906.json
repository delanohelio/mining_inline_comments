{"pr_number": 4906, "pr_title": "[CORE] Fixes composed schema discriminator map", "pr_createdAt": "2020-01-01T23:40:01Z", "pr_url": "https://github.com/OpenAPITools/openapi-generator/pull/4906", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDM2ODU4Ng==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r364368586", "bodyText": "It would be good to add function comments and essentially copy the text from the PR to help understand what this is doing.", "author": "sebastien-rosset", "createdAt": "2020-01-08T18:07:33Z", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2064,12 +2064,49 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n+    private void addComposedMappedModels(CodegenDiscriminator discriminator, ComposedSchema c, String discPropName) {", "originalCommit": "47477c0cf1949657b464ec4f7fd7c11bfeae1016", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDU0NjU2NQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r364546565", "bodyText": "Added a document comment describing what this function is doing", "author": "spacether", "createdAt": "2020-01-09T03:35:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDM2ODU4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NDQ0Mw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r370474443", "bodyText": "@spacether question... Could you include a test for the operation response model as well?\nThis test is great for direct Schema reference, but we often have issue with $ref processing to those schemas.", "author": "jimschubert", "createdAt": "2020-01-24T05:00:24Z", "path": "modules/openapi-generator/src/test/java/org/openapitools/codegen/java/JavaClientCodegenTest.java", "diffHunk": "@@ -548,14 +539,31 @@ public void testFreeFormObjects() {\n     public void testBearerAuth() {\n         final OpenAPI openAPI = TestUtils.parseSpec(\"src/test/resources/3_0/pingBearerAuth.yaml\");\n         JavaClientCodegen codegen = new JavaClientCodegen();\n-        \n+\n         List<CodegenSecurity> security = codegen.fromSecurity(openAPI.getComponents().getSecuritySchemes());\n         Assert.assertEquals(security.size(), 1);\n         Assert.assertEquals(security.get(0).isBasic, Boolean.TRUE);\n         Assert.assertEquals(security.get(0).isBasicBasic, Boolean.FALSE);\n         Assert.assertEquals(security.get(0).isBasicBearer, Boolean.TRUE);\n     }\n \n+    @Test\n+    public void testComposedSchemaOneOfDiscriminatorMap() {", "originalCommit": "93f29eda6fc8143c8f0ec7c524cf3a38704e186e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkwMDA1Ng==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r370900056", "bodyText": "I have added tests of:\n\ninline oneOf schemas\ninline oneOf schemas with inline oneOf schemas\n$ref oneOf schemas that include the discriminator in self (non-composed schema)\n$ref oneOf schemas that include the discriminator with oneOf $ref\n$ref oneOf schemas that include the discriminator with anyOf $ref\n$ref oneOf schemas that include the discriminator with allOf $ref\n$ref oneOf child model where the discriminator is in a composed schema grandparent (requires recursive functionality)", "author": "spacether", "createdAt": "2020-01-25T00:57:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NDQ0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE4ODQxMQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r373188411", "bodyText": "@jimschubert what tests do you want on Endpoint responses?\nOur inlinemodelresolver code does not extract inline schemas for composed models in the request body or the response per https://github.com/OpenAPITools/openapi-generator/blob/master/modules/openapi-generator/src/main/java/org/openapitools/codegen/InlineModelResolver.java#L257.\nChecking that the dataType is the referenced model name does not seem like a test that proves anything here as that is standard generator behavior.", "author": "spacether", "createdAt": "2020-01-30T20:55:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NDQ0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3MjMwNw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374472307", "bodyText": "@spacether I'm sorry, but I don't follow your question, or why you've linked to InlineModelResolver when I'd asked about $ref.  Responses are processed similarly to all other models (see: \n  \n    \n      openapi-generator/modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java\n    \n    \n         Line 2001\n      in\n      e45a1d0\n    \n    \n    \n    \n\n        \n          \n           String ref = ModelUtils.getSimpleRef(interfaceSchema.get$ref()); \n        \n    \n  \n\n). However, composed models have special rules around  how structure is defined in the presence of absence of discriminator and explicitly defines that inline models are ignored when using discriminator in most (all? I'd have to look again) cases. I'm confused because you appear to only be supporting discriminator based Schemas, and the spec says to drop inline models in those cases.\nJust for clarification so I understand what part of the spec is being done in the PR (it would help me in the review), can you describe your intended behaviors with respect to the three composed schemas, each with and without discriminator, and what you consider to be the outputs?  In reading your comments in Slack and in the PR, it's seems like you're only targeting inheritance (which is fine) and making some assumptions about the spec (which is fine as long as it's clearly explained to the user). I can't tell from the code or comments if this is intentional or not. That is, is the goal a short-term implementation path without breaking existing code?", "author": "jimschubert", "createdAt": "2020-02-04T04:45:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NDQ0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3NTU1MQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374475551", "bodyText": "Didn't I address your ref issue?\nYou asked 'Could you include a test for the operation response model' which I interpret as an endpoint operation response model. Can you describe what you want tested there? I don't know.", "author": "spacether", "createdAt": "2020-02-04T05:03:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NDQ0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3Njg0OQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374476849", "bodyText": "The test cases show the behavior that I intend.\nThis PR is filling the discriminator map when we have enough info to do so. It only fills it if the discriminator exists. For composed schemas with no discriminator it does nothing.\nCan you please let us know where the spec says to 'drop inline models in those cases'. Can you clarify what that phrase means? I don't understand it.", "author": "spacether", "createdAt": "2020-02-04T05:10:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NDQ0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYzNzAzNg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374637036", "bodyText": "Maybe I've missed the test cases that include the negative cases when these don't have discriminator, and that's lead to some confusion? Let me look at it again later, and if I have time I'll write any additional cases for it.\nThe code is bailing when there's no $ref on line 2220 (the continue with comment starting \"for schemas with no ref\"), but that comment provides the wrong reason for bailing on inline schemas.. it's not that we can't get a model name but that it's defined that way in the spec.\nAs you mentioned in another comment, there are times when we find a similar schema and convert to a ref to that schema. I don't think that's correct or intuitive behavior, and I think has lead to some confusion for me (as a reviewer) and for you (as it makes it impossible to match a few cases in the spec).\nSpecifically, the spec at https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#discriminator-object says:\n\nWhen using the discriminator, inline schemas will not be considered.\n\nIt doesn't say \"inline models with discriminator may automagically point to an existing $ref\".\nIn other words, when we're processing discriminator of composed models, we shouldn't be traversing and properties of something defined as an inline object. But, because we try to normalize/flatten these models before this path... we can't match the spec here.", "author": "jimschubert", "createdAt": "2020-02-04T12:18:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NDQ0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1OTkwNQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374859905", "bodyText": "Maybe I've missed the test cases that include the negative cases when these don't have discriminator\n\nThis code path is only used when a discriminator exists, so it does not make sense to add tests which lack a discriminator\nThe function addComposedMappedModels has been updated to now throw an exception if a null ref is seen. We also have a test of it.\nIn my opinion we should handle fixing the inline model resolver for composed schemas in a separate PR as that is scope creep. The scope here is defining the discriminator map.", "author": "spacether", "createdAt": "2020-02-04T18:56:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NDQ0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTk3MjU0MQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r375972541", "bodyText": "@jimschubert please let me know if your concerns have been addressed.\nA separate ticket has been made for the stack overflow work here\nA separate ticket has been filed to fix the inline model resolver here", "author": "spacether", "createdAt": "2020-02-06T17:21:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NDQ0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMxOTYzNg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r385319636", "bodyText": "Please see our added tests above in testComposedSchemaAllOfDiscriminatorMap", "author": "spacether", "createdAt": "2020-02-27T19:20:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NDQ0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NDk0MA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r370474940", "bodyText": "This will fail, as these schemas may also be defined inline rather than as a $ref.", "author": "jimschubert", "createdAt": "2020-01-24T05:03:41Z", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2064,12 +2064,61 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n+    /**\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * their parent's discriminator map if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown\n+     * @param discriminator The CodegenDiscriminator that we will add models to\n+     * @param c The ComposedSchema that contains the discriminator and oneOf/anyOf schemas\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private void addComposedMappedModels(CodegenDiscriminator discriminator, ComposedSchema c, String discPropName) {\n+        ArrayList<List<Schema>> listOLists = new ArrayList<List<Schema>>();\n+        listOLists.add(c.getOneOf());\n+        listOLists.add(c.getAnyOf());\n+        for (List<Schema> schemaList: listOLists) {\n+            if (schemaList == null) {\n+                continue;\n+            }\n+            for  (Schema sc: schemaList) {\n+                String modelName = ModelUtils.getSimpleRef(sc.get$ref());", "originalCommit": "93f29eda6fc8143c8f0ec7c524cf3a38704e186e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg5OTc1OQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r370899759", "bodyText": "Should I use ModelUtils.getReferencedSchema or ModelUtils.unaliasSchema here?", "author": "spacether", "createdAt": "2020-01-25T00:55:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NDk0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTAzODQ5NA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r371038494", "bodyText": "Changed to using ModelUtils.getReferencedSchema on the next line.\n@jimschubert because inlineModelResolver is invoked, won't inline Schemas always have $refs to the extracted inline schema?\n\nper https://github.com/OpenAPITools/openapi-generator/blob/master/modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultGenerator.java#L915\n\nIf so, then it looks like using String modelName = ModelUtils.getSimpleRef(sc.get$ref()); will always work here.", "author": "spacether", "createdAt": "2020-01-26T23:57:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NDk0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTA1NzQxNg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r371057416", "bodyText": "I'm not sure what you're referring to, but you won't always have a $ref here.\nIf you're referring to flatten in InlineModelResolver, I don't think that's doing what you think it's doing. Please review \n  \n    \n      openapi-generator/modules/openapi-generator/src/main/java/org/openapitools/codegen/InlineModelResolver.java\n    \n    \n         Line 330\n      in\n      ea55968\n    \n    \n    \n    \n\n        \n          \n           private void flattenComposedChildren(OpenAPI openAPI, String key, List<Schema> children) {", "author": "jimschubert", "createdAt": "2020-01-27T03:44:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NDk0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTA1OTI0MQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r371059241", "bodyText": "To explain further, in case it's not clear... You'll input have a $ref if you have a Schema defined (like #/components/Schemas/Dog. It's perfectly valid to have a spec with only inline models, and also to have something like allOf, anyOf, or oneOf which define inline models for those compositions. Although there not common, they'll fail here.", "author": "jimschubert", "createdAt": "2020-01-27T04:05:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NDk0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTA3MTMzMA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r371071330", "bodyText": "Hmm, I am having trouble understanding your example.\nInline OneOf: we have a schema which has a oneOf schema with an inline definition and using $ref works because the InlineModelResolver extracted the inline schema to a new base level schema and set the  $ref to it.\n\nAre you saying that when defining oneOf schemas I need to use a mix of inline and $ref to hit this null $ref use case?\nCan you provide a full example schema which has a oneOf definition in it where the oneOf schema will have a null $ref value?", "author": "spacether", "createdAt": "2020-01-27T05:50:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NDk0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkwOTkzOA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r371909938", "bodyText": "Are you saying that we can have a model with two levels of inline oneOf definition?\nIf so we are guaranteed that the first level is extracted to its own model per my explanation above. I will add that as a test case.", "author": "spacether", "createdAt": "2020-01-28T16:24:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NDk0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyMjg2MA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r372022860", "bodyText": "@jimschubert we now have a test with inline oneOf schemas with inline oneOf schemas which results in null refs. We now continue through and skip any schemas with no ref because it is impossible to build a discriminator map with them.\nFor now I am resolving this convo because I think that addresses your concern.\nIf it doesn't please let me know and I'll be happy to make more changes.", "author": "spacether", "createdAt": "2020-01-28T19:54:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NDk0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4MzM5OA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r372383398", "bodyText": "Yes, I think that addresses the concern. Sorry, I saw your question about providing an example, but I couldn't find the question when I came back to it (probably because of your additional commit).", "author": "jimschubert", "createdAt": "2020-01-29T13:33:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NDk0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NTYwOQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r370475609", "bodyText": "Looks like this would fail if allOf is null (like if the ComposedModel is oneOf)?", "author": "jimschubert", "createdAt": "2020-01-24T05:08:35Z", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2064,12 +2064,61 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n+    /**\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * their parent's discriminator map if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown\n+     * @param discriminator The CodegenDiscriminator that we will add models to\n+     * @param c The ComposedSchema that contains the discriminator and oneOf/anyOf schemas\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private void addComposedMappedModels(CodegenDiscriminator discriminator, ComposedSchema c, String discPropName) {\n+        ArrayList<List<Schema>> listOLists = new ArrayList<List<Schema>>();\n+        listOLists.add(c.getOneOf());\n+        listOLists.add(c.getAnyOf());\n+        for (List<Schema> schemaList: listOLists) {\n+            if (schemaList == null) {\n+                continue;\n+            }\n+            for  (Schema sc: schemaList) {\n+                String modelName = ModelUtils.getSimpleRef(sc.get$ref());\n+                Schema refSchema = ModelUtils.getSchema(this.openAPI, modelName);\n+                Schema discSchema = (Schema) refSchema.getProperties().get(discPropName);\n+                if (discSchema != null && ModelUtils.isStringSchema(discSchema)) {\n+                    discriminator.getMappedModels().add(new MappedModel(modelName, toModelName(modelName)));\n+                    continue;\n+                }\n+                Boolean mapped = false;\n+                if (ModelUtils.isComposedSchema(refSchema)) {\n+                    ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+                    for  (Schema allOf: composedSchema.getAllOf()) {", "originalCommit": "93f29eda6fc8143c8f0ec7c524cf3a38704e186e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkwMzI0OQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r370903249", "bodyText": "allOf/oneOf/anyOf access is now gated by null checks", "author": "spacether", "createdAt": "2020-01-25T01:24:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NTYwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NjA1MQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r370476051", "bodyText": "What about removing the mapped flag used as control flow and move the error message up? I think the logic around mapped is hard to follow, and could easily get messed up later.", "author": "jimschubert", "createdAt": "2020-01-24T05:11:40Z", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2064,12 +2064,61 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n+    /**\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * their parent's discriminator map if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown\n+     * @param discriminator The CodegenDiscriminator that we will add models to\n+     * @param c The ComposedSchema that contains the discriminator and oneOf/anyOf schemas\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private void addComposedMappedModels(CodegenDiscriminator discriminator, ComposedSchema c, String discPropName) {\n+        ArrayList<List<Schema>> listOLists = new ArrayList<List<Schema>>();\n+        listOLists.add(c.getOneOf());\n+        listOLists.add(c.getAnyOf());\n+        for (List<Schema> schemaList: listOLists) {\n+            if (schemaList == null) {\n+                continue;\n+            }\n+            for  (Schema sc: schemaList) {\n+                String modelName = ModelUtils.getSimpleRef(sc.get$ref());\n+                Schema refSchema = ModelUtils.getSchema(this.openAPI, modelName);\n+                Schema discSchema = (Schema) refSchema.getProperties().get(discPropName);\n+                if (discSchema != null && ModelUtils.isStringSchema(discSchema)) {\n+                    discriminator.getMappedModels().add(new MappedModel(modelName, toModelName(modelName)));\n+                    continue;\n+                }\n+                Boolean mapped = false;\n+                if (ModelUtils.isComposedSchema(refSchema)) {\n+                    ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+                    for  (Schema allOf: composedSchema.getAllOf()) {\n+                        String allmodelName = ModelUtils.getSimpleRef(allOf.get$ref());\n+                        refSchema = ModelUtils.getSchema(this.openAPI, allmodelName);\n+                        discSchema = (Schema) refSchema.getProperties().get(discPropName);\n+                        if (discSchema != null && ModelUtils.isStringSchema(discSchema)) {\n+                            discriminator.getMappedModels().add(new MappedModel(modelName, toModelName(modelName)));\n+                            mapped = true;\n+                            break;\n+                        }\n+                    }\n+                    if (mapped) {", "originalCommit": "93f29eda6fc8143c8f0ec7c524cf3a38704e186e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg4ODc4Mg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r370888782", "bodyText": "Removed the mapped variable and instead we now use a mappedModel variable.\nIf mappedModel == null, then we raise an error.", "author": "spacether", "createdAt": "2020-01-24T23:46:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NjA1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkwMDE3NQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r370900175", "bodyText": "This is needed if a schema omits allOf but includes anyOf or oneOf", "author": "spacether", "createdAt": "2020-01-25T00:58:09Z", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2109,20 +2196,26 @@ protected void addProperties(Map<String, Schema> properties, List<String> requir\n         if (schema instanceof ComposedSchema) {\n             ComposedSchema composedSchema = (ComposedSchema) schema;\n \n-            for (Schema component : composedSchema.getAllOf()) {\n-                addProperties(properties, required, component);\n+            if (composedSchema.getAllOf() != null) {", "originalCommit": "09f7275560afe0e12df830dd3074405c36c9fe8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkzMDUzNw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r404930537", "bodyText": "If it's oneOf/anyOf, getAllOf should return null or empty list, right?\nWe didn't include the null check before and I don't recall issues related to this in particular but it could be an edge case we've not encountered yet.", "author": "wing328", "createdAt": "2020-04-07T16:06:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkwMDE3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ5NzQ3MQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r413497471", "bodyText": "My new test cases include oneOf/anyOf with no allOf, and when that happens composedSchema.getAllOf() == null", "author": "spacether", "createdAt": "2020-04-23T04:20:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkwMDE3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUwMDUzMw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r413500533", "bodyText": "\ud83d\udc4c", "author": "wing328", "createdAt": "2020-04-23T04:30:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkwMDE3NQ=="}], "type": "inlineReview"}, {"oid": "ddb672aaa908b95d35293d287bd4a50092a265ff", "url": "https://github.com/OpenAPITools/openapi-generator/commit/ddb672aaa908b95d35293d287bd4a50092a265ff", "message": "Adds addComposedMappedModels and testComposedSchemaOneOfDiscriminatorMap", "committedDate": "2020-01-25T21:25:43Z", "type": "forcePushed"}, {"oid": "814b8a776a0159ded6444f52b0dc91517c86d289", "url": "https://github.com/OpenAPITools/openapi-generator/commit/814b8a776a0159ded6444f52b0dc91517c86d289", "message": "Adds addComposedMappedModels and testComposedSchemaOneOfDiscriminatorMap\n\nUses inlineModelResolver on openapi spec\n\nAdds ParseFlattenSpec\n\nReferts DefaultCodegenTest.java\n\nAdds null ref handling in addComposedMappedModels, adds test case\n\nAdds recursive search of dscriminator when examining a schema", "committedDate": "2020-02-04T03:27:05Z", "type": "forcePushed"}, {"oid": "85145d6ee8e0718d7595dc31c6ed2e6c49f80cc4", "url": "https://github.com/OpenAPITools/openapi-generator/commit/85145d6ee8e0718d7595dc31c6ed2e6c49f80cc4", "message": "Adds addComposedMappedModels and testComposedSchemaOneOfDiscriminatorMap\n\nUses inlineModelResolver on openapi spec\n\nAdds ParseFlattenSpec\n\nReferts DefaultCodegenTest.java\n\nAdds null ref handling in addComposedMappedModels, adds test case\n\nAdds recursive search of dscriminator when examining a schema", "committedDate": "2020-02-04T03:30:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ2MzM1NA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374463354", "bodyText": "I don't understand this error. allOf without a discriminator means composition, while allOf with a discriminator means inheritance. As a user I'd find this error very confusing.  From the spec:\n\nThe OpenAPI Specification allows combining and extending model definitions using the allOf property of JSON Schema, in effect offering model composition. allOf takes an array of object definitions that are validated independently but together compose a single object.\nWhile composition offers model extensibility, it does not imply a hierarchy between the models. To support polymorphism, the OpenAPI Specification adds the discriminator field. When used, the discriminator will be the name of the property that decides which schema definition validates the structure of the model. As such, the discriminator field MUST be a required field.\n\nWhen a discriminator exists, inline schemas won't be honored (only $ref). From the spec:\n\nWhen using the discriminator, inline schemas will not be considered.", "author": "jimschubert", "createdAt": "2020-02-04T03:56:44Z", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2141,12 +2141,102 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n+    /**\n+     * Recursively look in Schema sc for the discriminator discPropName\n+     * @param sc The Schema that may contain the discriminator\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private boolean discriminatorFound(Schema sc, String discPropName) {\n+        Schema refSchema = ModelUtils.getReferencedSchema(this.openAPI, sc);\n+        if (refSchema.getProperties() != null) {\n+            Schema discSchema = (Schema) refSchema.getProperties().get(discPropName);\n+            if (discSchema != null && ModelUtils.isStringSchema(discSchema)) {\n+                return true;\n+            }\n+        }\n+        if (ModelUtils.isComposedSchema(refSchema)) {\n+            ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+            if (composedSchema.getAllOf() != null) {\n+                // If our discriminator is in one of the allOf schemas break when we find it\n+                for  (Schema allOf: composedSchema.getAllOf()) {\n+                    if (discriminatorFound(allOf, discPropName)) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n+                // All oneOf definitions must contain the discriminator\n+                Integer hasDiscriminatorCnt = 0;\n+                for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    if (discriminatorFound(oneOf, discPropName)) {\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getOneOf().size()) {\n+                    return true;\n+                }\n+            }\n+            if (composedSchema.getAnyOf() != null && composedSchema.getAnyOf().size() != 0) {\n+                // All anyOf definitions must contain the discriminator because a min of one must be selected\n+                Integer hasDiscriminatorCnt = 0;\n+                for  (Schema anyOf: composedSchema.getAnyOf()) {\n+                    if (discriminatorFound(anyOf, discPropName)) {\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getAnyOf().size()) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * their parent's discriminator map if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown\n+     * @param discriminator The CodegenDiscriminator that we will add models to\n+     * @param c The ComposedSchema that contains the discriminator and oneOf/anyOf schemas\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private void addComposedMappedModels(CodegenDiscriminator discriminator, ComposedSchema c, String discPropName) {\n+        ArrayList<List<Schema>> listOLists = new ArrayList<List<Schema>>();\n+        listOLists.add(c.getOneOf());\n+        listOLists.add(c.getAnyOf());\n+        for (List<Schema> schemaList: listOLists) {\n+            if (schemaList == null) {\n+                continue;\n+            }\n+            for  (Schema sc: schemaList) {\n+                String ref = sc.get$ref();\n+                if (ref == null) {\n+                    // for schemas with no ref, it is not possible to build the discriminator map\n+                    // because ref is how we get the model name\n+                    // we only hit this use case for a schema with inline composed schemas, and one of those\n+                    // schemas also has inline composed schemas\n+                    continue;\n+                }\n+                Boolean discFound = discriminatorFound(sc, discPropName);\n+                String modelName = ModelUtils.getSimpleRef(ref);\n+                if (discFound == false) {\n+                    LOGGER.error(\"schema {} is lacking the required string discriminator {}\", modelName, discPropName);", "originalCommit": "85145d6ee8e0718d7595dc31c6ed2e6c49f80cc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3OTcxNQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374479715", "bodyText": "For context, this function is only run when a discriminator exists.\nWe are only looping through oneOf and anyOf schema lists here, so we will only see those errors if:\n\na discriminator was specified in the composed schema\noneOf and or anyOf schemas are defined in the composed schema\none of those oneOf or anyOf schemas is missing the required discriminator\n\nI only included the inline processing code because our inline resolver extracts inline schemas into new models.\nCould you let me know what you want me to change?\nDo you want me to throw an error when an inline schema is used resulting in a null ref?", "author": "spacether", "createdAt": "2020-02-04T05:24:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ2MzM1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYyNzcxNA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374627714", "bodyText": "Ah I see. I think a comment at this point in code could go a long way. Maybe rewording the error as well?\nI still have some concerns because the spec allows for moving the discriminator property out to the top level model, but that's probably an edge case that we don't need to account for immediately.", "author": "jimschubert", "createdAt": "2020-02-04T11:55:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ2MzM1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY0Mjc5OQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374642799", "bodyText": "Re: the reword recommendation...\nConsider a huge spec document with 1000 $refs and heavy use of composition. If there are types such as BrandedTool which requires a manufacturer property and HandmadeTool which does not: the spec author may easily mistype Hammer where they meant BrandedHammer leading to a message:\n\nschema Hammer is lacking the required string discriminator manufacturer\n\nWrapping these properties in single quotes would make this stand out as model and property names. Ideally the message would read something like:\n\n'BrandedTool' defines discriminator 'manufacturer', but the referenced schema 'Hammer' is missing this property.\n\nThis is probably something we'll want to add a validator for later as well.", "author": "jimschubert", "createdAt": "2020-02-04T12:31:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ2MzM1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1NzgzNg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374857836", "bodyText": "The error message has been changed to the suggested message", "author": "spacether", "createdAt": "2020-02-04T18:52:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ2MzM1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ2NDUxNg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374464516", "bodyText": "This isn't correct to throw an error for missing discriminator. Notice use of MAY in the spec and not MUST:\nIn OAS 3.0, a response payload MAY be described to be exactly one of any number of types:\nMyResponseType:\n  oneOf:\n  - $ref: '#/components/schemas/Cat'\n  - $ref: '#/components/schemas/Dog'\n  - $ref: '#/components/schemas/Lizard'\n\nwhich means the payload MUST, by validation, match exactly one of the schemas described by Cat, Dog, or Lizard. In this case, a discriminator MAY act as a \"hint\" to shortcut validation and selection of the matching schema which may be a costly operation, depending on the complexity of the schema.", "author": "jimschubert", "createdAt": "2020-02-04T04:02:47Z", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2141,12 +2141,102 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n+    /**\n+     * Recursively look in Schema sc for the discriminator discPropName\n+     * @param sc The Schema that may contain the discriminator\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private boolean discriminatorFound(Schema sc, String discPropName) {\n+        Schema refSchema = ModelUtils.getReferencedSchema(this.openAPI, sc);\n+        if (refSchema.getProperties() != null) {\n+            Schema discSchema = (Schema) refSchema.getProperties().get(discPropName);\n+            if (discSchema != null && ModelUtils.isStringSchema(discSchema)) {\n+                return true;\n+            }\n+        }\n+        if (ModelUtils.isComposedSchema(refSchema)) {\n+            ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+            if (composedSchema.getAllOf() != null) {\n+                // If our discriminator is in one of the allOf schemas break when we find it\n+                for  (Schema allOf: composedSchema.getAllOf()) {\n+                    if (discriminatorFound(allOf, discPropName)) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n+                // All oneOf definitions must contain the discriminator\n+                Integer hasDiscriminatorCnt = 0;\n+                for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    if (discriminatorFound(oneOf, discPropName)) {\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getOneOf().size()) {\n+                    return true;\n+                }\n+            }\n+            if (composedSchema.getAnyOf() != null && composedSchema.getAnyOf().size() != 0) {\n+                // All anyOf definitions must contain the discriminator because a min of one must be selected\n+                Integer hasDiscriminatorCnt = 0;\n+                for  (Schema anyOf: composedSchema.getAnyOf()) {\n+                    if (discriminatorFound(anyOf, discPropName)) {\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getAnyOf().size()) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * their parent's discriminator map if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown", "originalCommit": "85145d6ee8e0718d7595dc31c6ed2e6c49f80cc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3ODkwOA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374478908", "bodyText": "So I think you may misunderstand when this code is invoked.\nIf there is no discriminator in the composed schema, this function is not run.\nPer here: https://github.com/spacether/openapi-generator/blob/issue_4904_fix_composed_schema_discriminator_map/modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java#L2234\nwe return early if there is no discriminator.\nIf we do have a discriminator then we check for discriminator presence because it is required per the spec here: https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#discriminatorObject\nAnd we invoke our code path here: https://github.com/spacether/openapi-generator/blob/issue_4904_fix_composed_schema_discriminator_map/modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java#L2255", "author": "spacether", "createdAt": "2020-02-04T05:20:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ2NDUxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ4NjAxOA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374486018", "bodyText": "Please let me know if I can mark this as resolved.", "author": "spacether", "createdAt": "2020-02-04T05:54:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ2NDUxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYyNTE2MA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374625160", "bodyText": "I think a comment that this path is intended to be taken only when a schema had a discriminator would be helpful.", "author": "jimschubert", "createdAt": "2020-02-04T11:49:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ2NDUxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg2MDIyMw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374860223", "bodyText": "A comment has been added to the javadoc for this function This function is only used for composed schemas which have a discriminator", "author": "spacether", "createdAt": "2020-02-04T18:57:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ2NDUxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ2NjQ3OQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374466479", "bodyText": "We should actively disallow infinite loops, as circular references are allowed in the spec.", "author": "jimschubert", "createdAt": "2020-02-04T04:13:13Z", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2160,16 +2250,23 @@ protected CodegenDiscriminator createDiscriminator(String schemaName, Schema sch\n                 discriminator.getMappedModels().add(new MappedModel(e.getKey(), modelName));\n             }\n         } else {\n-            Map<String, Schema> allDefinitions = ModelUtils.getSchemas(this.openAPI);\n-            allDefinitions.forEach((childName, child) -> {\n-                if (child instanceof ComposedSchema && ((ComposedSchema) child).getAllOf() != null) {\n-\n-                    final List<String> parentSchemas = ModelUtils.getAllParentsName((ComposedSchema) child, allDefinitions, true);\n-                    if (parentSchemas.contains(schemaName)) {\n-                        discriminator.getMappedModels().add(new MappedModel(childName, toModelName(childName)));\n+            if (ModelUtils.isComposedSchema(schema)) {\n+                // if all oneOf/amyOf schemas contain the discriminator, then use it when mapping\n+                addComposedMappedModels(discriminator, (ComposedSchema) schema, discPropName);\n+            } else {\n+                // we have child models that include a parent with allOf: parent and the parent does NOT have composed schema\n+                // If the parent has composed schema we go an infinite loop parent->child-> parent in getAllParentsName and addProperties", "originalCommit": "85145d6ee8e0718d7595dc31c6ed2e6c49f80cc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ3OTkyMg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374479922", "bodyText": "Right now infinite loops cause a stack overflow or some similar failure and don't result in a client being generated.", "author": "spacether", "createdAt": "2020-02-04T05:25:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ2NjQ3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY0NTA0Ng==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374645046", "bodyText": "This code is not only used in our CLI and plugins. We need to prevent intentional stack overflow. Maybe including a depth count and terminating at something ridiculous like 20?", "author": "jimschubert", "createdAt": "2020-02-04T12:36:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ2NjQ3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg2MTUyMQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r374861521", "bodyText": "So none of my cases cover infinite loops. That is a separate issue from this PR and fixing the discriminator map.\nHow about we fix that in a separate PR? Especially since that infinite recursion fix will touch more call sites than my code here.", "author": "spacether", "createdAt": "2020-02-04T18:59:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ2NjQ3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTk3Mjg3NQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r375972875", "bodyText": "@jimschubert please let me know if your concerns have been addressed.\nA separate ticket has been made for the stack overflow work here", "author": "spacether", "createdAt": "2020-02-06T17:21:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ2NjQ3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE4MDM5OA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r377180398", "bodyText": "Should we include anyOf here?\nI don't thinks so. If one includes a discriminator with anyof then the discriminator must be used and the functionality is the same as oneof. Also because one is including the class name, it is not possible to match multiple schemas in that use case.", "author": "spacether", "createdAt": "2020-02-10T16:42:24Z", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2141,12 +2141,104 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n+    /**\n+     * Recursively look in Schema sc for the discriminator discPropName\n+     * @param sc The Schema that may contain the discriminator\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private boolean discriminatorFound(Schema sc, String discPropName) {\n+        Schema refSchema = ModelUtils.getReferencedSchema(this.openAPI, sc);\n+        if (refSchema.getProperties() != null) {\n+            Schema discSchema = (Schema) refSchema.getProperties().get(discPropName);\n+            if (discSchema != null && ModelUtils.isStringSchema(discSchema)) {\n+                return true;\n+            }\n+        }\n+        if (ModelUtils.isComposedSchema(refSchema)) {\n+            ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+            if (composedSchema.getAllOf() != null) {\n+                // If our discriminator is in one of the allOf schemas break when we find it\n+                for  (Schema allOf: composedSchema.getAllOf()) {\n+                    if (discriminatorFound(allOf, discPropName)) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n+                // All oneOf definitions must contain the discriminator\n+                Integer hasDiscriminatorCnt = 0;\n+                for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    if (discriminatorFound(oneOf, discPropName)) {\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getOneOf().size()) {\n+                    return true;\n+                }\n+            }\n+            if (composedSchema.getAnyOf() != null && composedSchema.getAnyOf().size() != 0) {\n+                // All anyOf definitions must contain the discriminator because a min of one must be selected\n+                Integer hasDiscriminatorCnt = 0;\n+                for  (Schema anyOf: composedSchema.getAnyOf()) {\n+                    if (discriminatorFound(anyOf, discPropName)) {\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getAnyOf().size()) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * This function is only used for composed schemas which have a discriminator\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * their parent's discriminator map if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown\n+     * @param composedSchemaName The String model name of the composed schema where we are setting the discriminator map\n+     * @param discriminator The CodegenDiscriminator that we will add models to\n+     * @param c The ComposedSchema that contains the discriminator and oneOf/anyOf schemas\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private void addComposedMappedModels(String composedSchemaName, CodegenDiscriminator discriminator, ComposedSchema c, String discPropName) {\n+        ArrayList<List<Schema>> listOLists = new ArrayList<List<Schema>>();\n+        listOLists.add(c.getOneOf());\n+        listOLists.add(c.getAnyOf());", "originalCommit": "53200bf33907c12cba6b769cef105fe76669399d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTkyMzI1Ng==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r379923256", "bodyText": "Yes we should per:\nhttps://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#discriminatorObject\nWhen used in conjunction with the anyOf construct, the use of the discriminator can avoid ambiguity where multiple schemas may satisfy a single payload.\n\nSo the spec wants us to allow anyOf to allow a discriminator map so it may act like oneOf", "author": "spacether", "createdAt": "2020-02-16T18:30:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE4MDM5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk2OTY4OQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r379969689", "bodyText": "Small typo: amyOf", "author": "sebastien-rosset", "createdAt": "2020-02-17T03:10:46Z", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2160,16 +2252,23 @@ protected CodegenDiscriminator createDiscriminator(String schemaName, Schema sch\n                 discriminator.getMappedModels().add(new MappedModel(e.getKey(), modelName));\n             }\n         } else {\n-            Map<String, Schema> allDefinitions = ModelUtils.getSchemas(this.openAPI);\n-            allDefinitions.forEach((childName, child) -> {\n-                if (child instanceof ComposedSchema && ((ComposedSchema) child).getAllOf() != null) {\n-\n-                    final List<String> parentSchemas = ModelUtils.getAllParentsName((ComposedSchema) child, allDefinitions, true);\n-                    if (parentSchemas.contains(schemaName)) {\n-                        discriminator.getMappedModels().add(new MappedModel(childName, toModelName(childName)));\n+            if (ModelUtils.isComposedSchema(schema)) {\n+                // if all oneOf/amyOf schemas contain the discriminator, then use it when mapping", "originalCommit": "53200bf33907c12cba6b769cef105fe76669399d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ1NjUxOA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r381456518", "bodyText": "This has been fixed", "author": "spacether", "createdAt": "2020-02-19T18:18:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk2OTY4OQ=="}], "type": "inlineReview"}, {"oid": "2cd595973b8ba21af0b0690f2ba4be8ee5ac8e4c", "url": "https://github.com/OpenAPITools/openapi-generator/commit/2cd595973b8ba21af0b0690f2ba4be8ee5ac8e4c", "message": "Adds addComposedMappedModels and testComposedSchemaOneOfDiscriminatorMap", "committedDate": "2020-02-19T18:16:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMxOTEzOQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r385319139", "bodyText": "We are adding more models to our discriminator map here than we have in the past.\nShould we add those models into the models import where this is called in fromModel?", "author": "spacether", "createdAt": "2020-02-27T19:19:52Z", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2267,35 +2284,242 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n+    /**\n+     * Recursively look in Schema sc for the discriminator discPropName\n+     * @param sc The Schema that may contain the discriminator\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private boolean discriminatorFound(Schema sc, String discPropName) {\n+        Schema refSchema = ModelUtils.getReferencedSchema(this.openAPI, sc);\n+        if (refSchema.getProperties() != null) {\n+            Schema discSchema = (Schema) refSchema.getProperties().get(discPropName);\n+            if (discSchema != null && ModelUtils.isStringSchema(discSchema)) {\n+                return true;\n+            }\n+        }\n+        if (ModelUtils.isComposedSchema(refSchema)) {\n+            ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+            if (composedSchema.getAllOf() != null) {\n+                // If our discriminator is in one of the allOf schemas break when we find it\n+                for  (Schema allOf: composedSchema.getAllOf()) {\n+                    if (discriminatorFound(allOf, discPropName)) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n+                // All oneOf definitions must contain the discriminator\n+                Integer hasDiscriminatorCnt = 0;\n+                for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    if (discriminatorFound(oneOf, discPropName)) {\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getOneOf().size()) {\n+                    return true;\n+                }\n+            }\n+            if (composedSchema.getAnyOf() != null && composedSchema.getAnyOf().size() != 0) {\n+                // All anyOf definitions must contain the discriminator because a min of one must be selected\n+                Integer hasDiscriminatorCnt = 0;\n+                for  (Schema anyOf: composedSchema.getAnyOf()) {\n+                    if (discriminatorFound(anyOf, discPropName)) {\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getAnyOf().size()) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Recursively look in Schema sc for the discriminator and return it\n+     * If we return it from allOf, oneOf, or anyOf, then do not include the\n+     * discriminator map from that location because it is not relevant at our\n+     * Schema sc location\n+     * @param sc The Schema that may contain the discriminator\n+     */\n+    private Discriminator recursiveGetDiscriminator(Schema sc) {\n+        Schema refSchema = ModelUtils.getReferencedSchema(this.openAPI, sc);\n+        Discriminator foundDisc = refSchema.getDiscriminator();\n+        if (foundDisc != null) {\n+            return foundDisc;\n+        }\n+        Discriminator disc = new Discriminator();\n+        if (ModelUtils.isComposedSchema(refSchema)) {\n+            ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+            if (composedSchema.getAllOf() != null) {\n+                // If our discriminator is in one of the allOf schemas break when we find it\n+                for  (Schema allOf: composedSchema.getAllOf()) {\n+                    foundDisc = recursiveGetDiscriminator(allOf);\n+                    if (foundDisc != null) {\n+                        disc.setPropertyName(foundDisc.getPropertyName());\n+                        return disc;\n+                    }\n+                }\n+            }\n+            if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n+                // All oneOf definitions must contain the discriminator\n+                Integer hasDiscriminatorCnt = 0;\n+                Set<String> discriminatorsPropNames = new HashSet<>();\n+                for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    foundDisc = recursiveGetDiscriminator(oneOf);\n+                    if (foundDisc != null) {\n+                        discriminatorsPropNames.add(foundDisc.getPropertyName());\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getOneOf().size() && discriminatorsPropNames.size() == 1) {\n+                    disc.setPropertyName(foundDisc.getPropertyName());\n+                    return disc;\n+                }\n+            }\n+            if (composedSchema.getAnyOf() != null && composedSchema.getAnyOf().size() != 0) {\n+                // All anyOf definitions must contain the discriminator because a min of one must be selected\n+                Integer hasDiscriminatorCnt = 0;\n+                Set<String> discriminatorsPropNames = new HashSet<>();\n+                for  (Schema anyOf: composedSchema.getAnyOf()) {\n+                    foundDisc = recursiveGetDiscriminator(anyOf);\n+                    if (foundDisc != null) {\n+                        discriminatorsPropNames.add(foundDisc.getPropertyName());\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getAnyOf().size() && discriminatorsPropNames.size() == 1) {\n+                    disc.setPropertyName(foundDisc.getPropertyName());\n+                    return disc;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * This function is only used for composed schemas which have a discriminator\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * a list if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown\n+     * @param composedSchemaName The String model name of the composed schema where we are setting the discriminator map\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     * @param c The ComposedSchema that contains the discriminator and oneOf/anyOf schemas\n+     * @return the list of oneOf and anyOf schema names that need to be added to the discriminator map\n+     */\n+    protected List<String> getOneOfAnyOfSchemaNames(String composedSchemaName, String discPropName, ComposedSchema c) {\n+        ArrayList<List<Schema>> listOLists = new ArrayList<List<Schema>>();\n+        listOLists.add(c.getOneOf());\n+        listOLists.add(c.getAnyOf());\n+        Set<String> descendentSchemas = new HashSet<>();\n+        for (List<Schema> schemaList: listOLists) {\n+            if (schemaList == null) {\n+                continue;\n+            }\n+            for  (Schema sc: schemaList) {\n+                String ref = sc.get$ref();\n+                if (ref == null) {\n+                    // for schemas with no ref, it is not possible to build the discriminator map\n+                    // because ref is how we get the model name\n+                    // we only hit this use case for a schema with inline composed schemas, and one of those\n+                    // schemas also has inline composed schemas\n+                    throw new RuntimeException(\"Invalid inline schema defined in oneOf/anyOf in '\" + composedSchemaName + \"'. Per the OpenApi spec, for this case when a composed schema defines a discriminator, the oneOf/anyOf schemas must use $ref. Change this inline definition to a $ref definition\");\n+                }\n+                Boolean discFound = discriminatorFound(sc, discPropName);\n+                String modelName = ModelUtils.getSimpleRef(ref);\n+                if (discFound == false) {\n+                    throw new RuntimeException(\"'\" + composedSchemaName + \"' defines discriminator '\" + discPropName + \"', but the referenced schema '\" + modelName + \"' is missing this property\");\n+                }\n+                descendentSchemas.add(modelName);\n+            }\n+        }\n+        List<String> modelNames = new ArrayList<>(descendentSchemas);\n+        Collections.sort(modelNames);\n+        return modelNames;\n+    }\n+\n+    protected List<String> getDescendentSchemaNames(String thisSchemaName) {\n+        ArrayList<String> queue = new ArrayList<String>();\n+        Set<String> descendentSchemas = new HashSet<>();\n+        Map<String, Schema> schemas = ModelUtils.getSchemas(this.openAPI);\n+        String currentSchemaName = thisSchemaName;\n+        while (true) {\n+            for (String childName : schemas.keySet()) {\n+                if (childName == thisSchemaName) {\n+                    continue;\n+                }\n+                Schema child = schemas.get(childName);\n+                if (ModelUtils.isComposedSchema(child)) {\n+                    ComposedSchema composedChild = (ComposedSchema) child;\n+                    List<Schema> parents = composedChild.getAllOf();\n+                    if (parents != null) {\n+                        for  (Schema parent: parents) {\n+                            String ref = parent.get$ref();\n+                            if (ref == null) {\n+                                // for schemas with no ref, it is not possible to build the discriminator map\n+                                // because ref is how we get the model name\n+                                // we only hit this use case for a schema with inline composed schemas, and one of those\n+                                // schemas also has inline composed schemas\n+                                throw new RuntimeException(\"Invalid inline schema defined in allOf in '\" + childName + \"'. Per the OpenApi spec, for this case when a composed schema defines a discriminator, the allOf schemas must use $ref. Change this inline definition to a $ref definition\");\n+                            }\n+                            String parentName = ModelUtils.getSimpleRef(ref);\n+                            if (parentName.equals(currentSchemaName)) {\n+                                if (queue.contains(childName) || descendentSchemas.contains(childName)) {\n+                                    throw new RuntimeException(\"Stack overflow hit when looking for \"+thisSchemaName+\" an infinite loop starting and ending at \"+childName+\" was seen\");\n+                                }\n+                                queue.add(childName);\n+                                break;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            if (queue.size() == 0) {\n+                break;\n+            }\n+            currentSchemaName = queue.remove(queue.size()-1);\n+            descendentSchemas.add(currentSchemaName);\n+        }\n+        List<String> modelNames = new ArrayList<>(descendentSchemas);\n+        Collections.sort(modelNames);\n+        return modelNames;\n+    }\n+\n     protected CodegenDiscriminator createDiscriminator(String schemaName, Schema schema) {\n-        if (schema.getDiscriminator() == null) {\n+        Discriminator sourceDiscriminator = recursiveGetDiscriminator(schema);\n+        if (sourceDiscriminator == null) {\n             return null;\n         }\n         CodegenDiscriminator discriminator = new CodegenDiscriminator();\n-        discriminator.setPropertyName(toVarName(schema.getDiscriminator().getPropertyName()));\n-        discriminator.setPropertyBaseName(schema.getDiscriminator().getPropertyName());\n+        String discPropName = sourceDiscriminator.getPropertyName();\n+        discriminator.setPropertyName(toVarName(discPropName));\n+        discriminator.setPropertyBaseName(sourceDiscriminator.getPropertyName());\n         discriminator.setPropertyGetter(toGetter(discriminator.getPropertyName()));\n         // FIXME: for now, we assume that the discriminator property is String\n         discriminator.setPropertyType(typeMapping.get(\"string\"));\n-        discriminator.setMapping(schema.getDiscriminator().getMapping());\n-        if (schema.getDiscriminator().getMapping() != null && !schema.getDiscriminator().getMapping().isEmpty()) {\n-            for (Entry<String, String> e : schema.getDiscriminator().getMapping().entrySet()) {\n+        discriminator.setMapping(sourceDiscriminator.getMapping());\n+        if (sourceDiscriminator.getMapping() != null && !sourceDiscriminator.getMapping().isEmpty()) {\n+            for (Entry<String, String> e : sourceDiscriminator.getMapping().entrySet()) {\n                 String nameOrRef = e.getValue();\n                 String name = nameOrRef.indexOf('/') >= 0 ? ModelUtils.getSimpleRef(nameOrRef) : nameOrRef;\n                 String modelName = toModelName(name);\n                 discriminator.getMappedModels().add(new MappedModel(e.getKey(), modelName));\n             }\n         } else {\n-            Map<String, Schema> allDefinitions = ModelUtils.getSchemas(this.openAPI);\n-            allDefinitions.forEach((childName, child) -> {\n-                if (child instanceof ComposedSchema && ((ComposedSchema) child).getAllOf() != null) {\n-\n-                    final List<String> parentSchemas = ModelUtils.getAllParentsName((ComposedSchema) child, allDefinitions, true);\n-                    if (parentSchemas.contains(schemaName)) {\n-                        discriminator.getMappedModels().add(new MappedModel(childName, toModelName(childName)));\n-                    }\n+            // for schemas that allOf inherit from this schema, add those descendents to this discriminator map\n+            List<String> allOfDescendents = getDescendentSchemaNames(schemaName);\n+            for (String allOfDescendent: allOfDescendents) {\n+                discriminator.getMappedModels().add(new MappedModel(allOfDescendent, toModelName(allOfDescendent)));", "originalCommit": "9b7be7dfbb0549ef31e34d6e55f192a8f970b435", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8b36c9750d07354e2cfeee53b9c2ab53187d5dbf", "url": "https://github.com/OpenAPITools/openapi-generator/commit/8b36c9750d07354e2cfeee53b9c2ab53187d5dbf", "message": "Runs ensure-up-to-date", "committedDate": "2020-03-02T17:32:45Z", "type": "forcePushed"}, {"oid": "19bbac94742c09111817327bbe49b64180ce69e3", "url": "https://github.com/OpenAPITools/openapi-generator/commit/19bbac94742c09111817327bbe49b64180ce69e3", "message": "[core] Additional oneOf/allOf testing", "committedDate": "2020-03-01T15:17:49Z", "type": "forcePushed"}, {"oid": "19bbac94742c09111817327bbe49b64180ce69e3", "url": "https://github.com/OpenAPITools/openapi-generator/commit/19bbac94742c09111817327bbe49b64180ce69e3", "message": "[core] Additional oneOf/allOf testing", "committedDate": "2020-03-01T15:17:49Z", "type": "forcePushed"}, {"oid": "19bbac94742c09111817327bbe49b64180ce69e3", "url": "https://github.com/OpenAPITools/openapi-generator/commit/19bbac94742c09111817327bbe49b64180ce69e3", "message": "[core] Additional oneOf/allOf testing", "committedDate": "2020-03-01T15:17:49Z", "type": "forcePushed"}, {"oid": "b74ee76959b0b018e404e379ee2e1728dff4c515", "url": "https://github.com/OpenAPITools/openapi-generator/commit/b74ee76959b0b018e404e379ee2e1728dff4c515", "message": "Adds addComposedMappedModels and testComposedSchemaOneOfDiscriminatorMap", "committedDate": "2020-03-07T04:30:52Z", "type": "forcePushed"}, {"oid": "01aaf89159c906e8ce86802b91564e7650054ef3", "url": "https://github.com/OpenAPITools/openapi-generator/commit/01aaf89159c906e8ce86802b91564e7650054ef3", "message": "Adds addComposedMappedModels and testComposedSchemaOneOfDiscriminatorMap", "committedDate": "2020-03-07T04:32:51Z", "type": "forcePushed"}, {"oid": "9320957e403e86470de7be64c5624049c736ffb0", "url": "https://github.com/OpenAPITools/openapi-generator/commit/9320957e403e86470de7be64c5624049c736ffb0", "message": "Adds back recursive getAllOfDescendants functionality, handles the case where a descendent is composed and has properties, don't add its children to the ancestor's discriminator map", "committedDate": "2020-03-17T02:17:37Z", "type": "forcePushed"}, {"oid": "9daca2de5438d2f46d6753069ec102b26a439e31", "url": "https://github.com/OpenAPITools/openapi-generator/commit/9daca2de5438d2f46d6753069ec102b26a439e31", "message": "Adds addComposedMappedModels and testComposedSchemaOneOfDiscriminatorMap", "committedDate": "2020-03-19T20:35:27Z", "type": "forcePushed"}, {"oid": "0d31ce2f90deb738e1daf592ebb95512d985c784", "url": "https://github.com/OpenAPITools/openapi-generator/commit/0d31ce2f90deb738e1daf592ebb95512d985c784", "message": "Adds addComposedMappedModels and testComposedSchemaOneOfDiscriminatorMap", "committedDate": "2020-03-19T20:44:55Z", "type": "forcePushed"}, {"oid": "71c60e067ef0bc2d06493a185fd832cc32374c79", "url": "https://github.com/OpenAPITools/openapi-generator/commit/71c60e067ef0bc2d06493a185fd832cc32374c79", "message": "Changes expected string in testLoginUser in openapi3 sample", "committedDate": "2020-03-26T16:38:13Z", "type": "forcePushed"}, {"oid": "662eaffea7f95660f1cc13c4f3512e0397dd5be3", "url": "https://github.com/OpenAPITools/openapi-generator/commit/662eaffea7f95660f1cc13c4f3512e0397dd5be3", "message": "Runs ensure up to date", "committedDate": "2020-03-26T16:41:33Z", "type": "forcePushed"}, {"oid": "035436f960c508d9b73fa2acaebec3f6e0ea7195", "url": "https://github.com/OpenAPITools/openapi-generator/commit/035436f960c508d9b73fa2acaebec3f6e0ea7195", "message": "Adds updates from Sebastien Rosset", "committedDate": "2020-04-01T22:28:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgyNzA1Mg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r401827052", "bodyText": "I have a OAS document where this code is invoked and getMappingName() return null. This happens because this.mappingName is null. Should we test for getMappingName() being null and returning a RuntimeException with a message that helps troubleshoot (including the value of this.modelName)? Or should compareTo return != 0 when mappingName is null?\nAlso, is it done on purpose that the implementation of compareTo is different from the equals implementation logic?\nOr should the null value be caught earlier, such as when the MappedModel constructor is invoked?", "author": "sebastien-rosset", "createdAt": "2020-04-01T18:36:35Z", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/CodegenDiscriminator.java", "diffHunk": "@@ -72,6 +72,11 @@ public MappedModel(String mappingName, String modelName) {\n             this.modelName = modelName;\n         }\n \n+        @Override\n+        public int compareTo(MappedModel other) {\n+            return getMappingName().compareTo(other.getMappingName());", "originalCommit": "dcd45406ec048643f6e1b90de843ec5ecbde9895", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg1NjM1MA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r401856350", "bodyText": "Update: I found one reason why the value is null. I can submit a PR. Do you want me to submit a PR to your branch?", "author": "sebastien-rosset", "createdAt": "2020-04-01T19:27:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgyNzA1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY0OTY3Mw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r403649673", "bodyText": "Yes, please submit a PR to my branch. I saw that you threw the error at assignment mappingName which is preferable to throwing the error later.\nThe only null that I saw was in a test. Why would it be null?", "author": "spacether", "createdAt": "2020-04-05T05:02:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgyNzA1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY1NTM1Ng==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r403655356", "bodyText": "github is not allowing me to open a PR against your fork. I have this fix in my branch, I will ask William to merge after you. This happens for example when there is at least one vendor extension but not the discriminator extension. Also, since I don't think mappingName should be null, it would be good to catch early to make it easier to troubleshoot issues.", "author": "sebastien-rosset", "createdAt": "2020-04-05T06:18:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgyNzA1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg4MDY4Nw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r406880687", "bodyText": "This PR now works for the use case where there is at least one vendor extension but not the discriminator extension. Let's handle the null issue in your PR. I'd prefer not to have this very large PR grow in any more scope.\nI purposefully implemented of compareTo is differently than the equals implementation logic because compareTo is used for sorting. When discriminatorExplicitMappingVerbose ==True, we use this to have deterministic alphabetical sorting of the mappedModels.", "author": "spacether", "createdAt": "2020-04-10T18:18:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgyNzA1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg4Mjg0Mg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r406882842", "bodyText": "@sebastien-rosset can you include me in the review process of your later PR?", "author": "spacether", "createdAt": "2020-04-10T18:24:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgyNzA1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIzNDkyMg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r407234922", "bodyText": "So it looks like I have more time to work on this now. Given that, I included your suggested exception raising in the MappedModel instantiation if the mappingName is null.", "author": "spacether", "createdAt": "2020-04-12T18:23:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgyNzA1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxMTg1Mg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r410711852", "bodyText": "@spacether this is a potential NPE. You're protected in the constructor, but not in the property setter. This method should have a null check, something like this:\npublic int compareTo(MappedModel other) {\n    if (null == getMappingName()) return 1;\n    return getMappingName().compareTo(other.getMappingName());", "author": "jimschubert", "createdAt": "2020-04-18T15:25:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgyNzA1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxMzY3Mw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r410713673", "bodyText": "Why not protect the setter also?\nWhy would null be a valid value for a mappingName?", "author": "spacether", "createdAt": "2020-04-18T15:40:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgyNzA1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgwODE3Nw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r410808177", "bodyText": "@spacether it doesn't look like it should be an acceptable value in code, but this type is public with a getter/setter so it should cover all places where an NPE might be possible. It's not really common, and probably frowned upon to throw an exception in a property setter.", "author": "jimschubert", "createdAt": "2020-04-19T04:00:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgyNzA1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUwMTQ5MQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r413501491", "bodyText": "I removed the exception raising.\nThis now returns int results for null and null to string comparisons.", "author": "spacether", "createdAt": "2020-04-23T04:33:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgyNzA1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2MDUyMA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r401860520", "bodyText": "The \"setMappingName\" function is not used anywhere. Does it make sense to remove it? I find it complicates troubleshooting and code maintenance when unused methods are added. This is because the code maintainer has to consider multiple ways the data can change.", "author": "sebastien-rosset", "createdAt": "2020-04-01T19:35:21Z", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/CodegenDiscriminator.java", "diffHunk": "@@ -72,6 +72,11 @@ public MappedModel(String mappingName, String modelName) {\n             this.modelName = modelName;\n         }\n \n+        @Override\n+        public int compareTo(MappedModel other) {\n+            return getMappingName().compareTo(other.getMappingName());\n+        }\n+", "originalCommit": "dcd45406ec048643f6e1b90de843ec5ecbde9895", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY0OTcyOQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r403649729", "bodyText": "How about we table that for a later PR? I don't want to remove a public interface if I don't have to.", "author": "spacether", "createdAt": "2020-04-05T05:03:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2MDUyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY1NTM4MQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r403655381", "bodyText": "ok", "author": "sebastien-rosset", "createdAt": "2020-04-05T06:18:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2MDUyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2MTAyOA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r401861028", "bodyText": "It would be helpful to add documentation.", "author": "sebastien-rosset", "createdAt": "2020-04-01T19:36:22Z", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -1111,6 +1120,14 @@ public void setEnsureUniqueParams(Boolean ensureUniqueParams) {\n         this.ensureUniqueParams = ensureUniqueParams;\n     }\n \n+    public Boolean getDiscriminatorExplicitMappingVerbose() {\n+        return discriminatorExplicitMappingVerbose;", "originalCommit": "dcd45406ec048643f6e1b90de843ec5ecbde9895", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY0OTkzMg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r403649932", "bodyText": "We already have documentation in the discriminatorExplicitMappingVerbose flag documentation.", "author": "spacether", "createdAt": "2020-04-05T05:06:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2MTAyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2OTM3NQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r401869375", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            String xDiscriminatorValue = (String) vendorExtensions.get(\"x-discriminator-value\");\n          \n          \n            \n                           if (xDiscriminatorValue != null) {\n          \n          \n            \n                               mm = new MappedModel(xDiscriminatorValue, toModelName(currentSchemaName));\n          \n          \n            \n                               descendentSchemas.add(mm);\n          \n          \n            \n                           }", "author": "sebastien-rosset", "createdAt": "2020-04-01T19:51:11Z", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2338,36 +2381,314 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n-    protected CodegenDiscriminator createDiscriminator(String schemaName, Schema schema) {\n-        if (schema.getDiscriminator() == null) {\n+    /**\n+     * Recursively look in Schema sc for the discriminator discPropName\n+     * and return a CodegenProperty with the dataType and required params set\n+     * the returned CodegenProperty may not be required and it may not be of type string\n+     * @param composedSchemaName The name of the sc Schema\n+     * @param sc The Schema that may contain the discriminator\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private CodegenProperty discriminatorFound(String composedSchemaName, Schema sc, String discPropName, OpenAPI openAPI) {\n+        Schema refSchema = ModelUtils.getReferencedSchema(openAPI, sc);\n+        if (refSchema.getProperties() != null && refSchema.getProperties().get(discPropName) != null) {\n+            Schema discSchema = (Schema) refSchema.getProperties().get(discPropName);\n+            CodegenProperty cp = new CodegenProperty();\n+            cp.setDatatype(discSchema.getType());\n+            cp.setRequired(false);\n+            if (refSchema.getRequired() != null && refSchema.getRequired().contains(discPropName)) {\n+                cp.setRequired(true);\n+            }\n+            return cp;\n+        }\n+        if (ModelUtils.isComposedSchema(refSchema)) {\n+            ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+            if (composedSchema.getAllOf() != null) {\n+                // If our discriminator is in one of the allOf schemas break when we find it\n+                for  (Schema allOf: composedSchema.getAllOf()) {\n+                    CodegenProperty cp = discriminatorFound(composedSchemaName, allOf, discPropName, openAPI);\n+                    if (cp != null) {\n+                        return cp;\n+                    }\n+                }\n+            }\n+            if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n+                // All oneOf definitions must contain the discriminator\n+                CodegenProperty cp = new CodegenProperty();\n+                for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    String modelName = ModelUtils.getSimpleRef(oneOf.get$ref());\n+                    CodegenProperty thisCp = discriminatorFound(composedSchemaName, oneOf, discPropName, openAPI);\n+                    if (thisCp == null) {\n+                        throw new RuntimeException(\"'\" + composedSchemaName + \"' defines discriminator '\" + discPropName + \"', but the referenced OneOf schema '\" + modelName + \"' is missing \"+discPropName);\n+                    }\n+                    if (cp.dataType == null) {\n+                        cp = thisCp;\n+                        continue;\n+                    }\n+                    if (cp != thisCp) {\n+                        throw new RuntimeException(\"'\" + composedSchemaName + \"' defines discriminator '\" + discPropName + \"', but the OneOf schema '\" + modelName + \"' has a different \"+discPropName+\" definition than the prior OneOf schema's. Make sure the \"+discPropName+\" type and required values are the same\");\n+                    }\n+                }\n+                return cp;\n+            }\n+            if (composedSchema.getAnyOf() != null && composedSchema.getAnyOf().size() != 0) {\n+                // All anyOf definitions must contain the discriminator because a min of one must be selected\n+                CodegenProperty cp = new CodegenProperty();\n+                for  (Schema anyOf: composedSchema.getAnyOf()) {\n+                    String modelName = ModelUtils.getSimpleRef(anyOf.get$ref());\n+                    CodegenProperty thisCp = discriminatorFound(composedSchemaName, anyOf, discPropName, openAPI);\n+                    if (thisCp == null) {\n+                        throw new RuntimeException(\"'\" + composedSchemaName + \"' defines discriminator '\" + discPropName + \"', but the referenced AnyOf schema '\" + modelName + \"' is missing \"+discPropName);\n+                    }\n+                    if (cp.dataType == null) {\n+                        cp = thisCp;\n+                        continue;\n+                    }\n+                    if (cp != thisCp) {\n+                        throw new RuntimeException(\"'\" + composedSchemaName + \"' defines discriminator '\" + discPropName + \"', but the AnyOf schema '\" + modelName + \"' has a different \"+discPropName+\" definition than the prior AnyOf schema's. Make sure the \"+discPropName+\" type and required values are the same\");\n+                    }\n+                }\n+                return cp;\n+\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Recursively look in Schema sc for the discriminator and return it\n+     * Schema sc location\n+     * OpenAPI openAPI the spec where we are searching for the discriminator\n+     * @param sc The Schema that may contain the discriminator\n+     */\n+    private Discriminator recursiveGetDiscriminator(Schema sc, OpenAPI openAPI) {\n+        Schema refSchema = ModelUtils.getReferencedSchema(openAPI, sc);\n+        Discriminator foundDisc = refSchema.getDiscriminator();\n+        if (foundDisc != null) {\n+            return foundDisc;\n+        }\n+        if (!this.getDiscriminatorExplicitMappingVerbose()) {\n+            return null;\n+        }\n+        Discriminator disc = new Discriminator();\n+        if (ModelUtils.isComposedSchema(refSchema)) {\n+            ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+            if (composedSchema.getAllOf() != null) {\n+                // If our discriminator is in one of the allOf schemas break when we find it\n+                for  (Schema allOf: composedSchema.getAllOf()) {\n+                    foundDisc = recursiveGetDiscriminator(allOf, openAPI);\n+                    if (foundDisc != null) {\n+                        disc.setPropertyName(foundDisc.getPropertyName());\n+                        disc.setMapping(foundDisc.getMapping());\n+                        return disc;\n+                    }\n+                }\n+            }\n+            if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n+                // All oneOf definitions must contain the discriminator\n+                Integer hasDiscriminatorCnt = 0;\n+                Set<String> discriminatorsPropNames = new HashSet<>();\n+                for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    foundDisc = recursiveGetDiscriminator(oneOf, openAPI);\n+                    if (foundDisc != null) {\n+                        discriminatorsPropNames.add(foundDisc.getPropertyName());\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getOneOf().size() && discriminatorsPropNames.size() == 1) {\n+                    disc.setPropertyName(foundDisc.getPropertyName());\n+                    disc.setMapping(foundDisc.getMapping());\n+                    return disc;\n+                }\n+            }\n+            if (composedSchema.getAnyOf() != null && composedSchema.getAnyOf().size() != 0) {\n+                // All anyOf definitions must contain the discriminator because a min of one must be selected\n+                Integer hasDiscriminatorCnt = 0;\n+                Set<String> discriminatorsPropNames = new HashSet<>();\n+                for  (Schema anyOf: composedSchema.getAnyOf()) {\n+                    foundDisc = recursiveGetDiscriminator(anyOf, openAPI);\n+                    if (foundDisc != null) {\n+                        discriminatorsPropNames.add(foundDisc.getPropertyName());\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getAnyOf().size() && discriminatorsPropNames.size() == 1) {\n+                    disc.setPropertyName(foundDisc.getPropertyName());\n+                    disc.setMapping(foundDisc.getMapping());\n+                    return disc;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * This function is only used for composed schemas which have a discriminator\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * a list if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown\n+     * @param composedSchemaName The String model name of the composed schema where we are setting the discriminator map\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     * @param c The ComposedSchema that contains the discriminator and oneOf/anyOf schemas\n+     * @param openAPI The OpenAPI spec that we are using\n+     * @return the list of oneOf and anyOf MappedModel that need to be added to the discriminator map\n+     */\n+    protected List<MappedModel> getOneOfAnyOfDescendants(String composedSchemaName, String discPropName, ComposedSchema c, OpenAPI openAPI) {\n+        ArrayList<List<Schema>> listOLists = new ArrayList<List<Schema>>();\n+        listOLists.add(c.getOneOf());\n+        listOLists.add(c.getAnyOf());\n+        List<MappedModel> descendentSchemas = new ArrayList();\n+        for (List<Schema> schemaList: listOLists) {\n+            if (schemaList == null) {\n+                continue;\n+            }\n+            for  (Schema sc: schemaList) {\n+                String ref = sc.get$ref();\n+                if (ref == null) {\n+                    // for schemas with no ref, it is not possible to build the discriminator map\n+                    // because ref is how we get the model name\n+                    // we only hit this use case for a schema with inline composed schemas, and one of those\n+                    // schemas also has inline composed schemas\n+                    // Note: if it is only inline one level, then the inline model resolver will move it into its own\n+                    // schema and make it a $ref schema in the oneOf/anyOf location\n+                    throw new RuntimeException(\"Invalid inline schema defined in oneOf/anyOf in '\" + composedSchemaName + \"'. Per the OpenApi spec, for this case when a composed schema defines a discriminator, the oneOf/anyOf schemas must use $ref. Change this inline definition to a $ref definition\");\n+                }\n+                CodegenProperty df = discriminatorFound(composedSchemaName, sc, discPropName, openAPI);\n+                String modelName = ModelUtils.getSimpleRef(ref);\n+                if (df == null || !\"string\".equals(df.dataType) || df.required != true) {\n+                    String msgSuffix = \"\";\n+                    if (df == null) {\n+                        msgSuffix += discPropName+\" is missing from the schema, define it as required and type string\";\n+                    } else {\n+                        if (!\"string\".equals(df.dataType)) {\n+                            msgSuffix += \"invalid type for \"+discPropName+\", set it to string\";\n+                        }\n+                        if (df.required != true) {\n+                            String spacer = \"\";\n+                            if (msgSuffix.length() != 0) {\n+                                spacer = \". \";\n+                            }\n+                            msgSuffix += spacer+\"invalid optional definition of \"+discPropName+\", include it in required\";\n+                        }\n+                    }\n+                    throw new RuntimeException(\"'\" + composedSchemaName + \"' defines discriminator '\" + discPropName + \"', but the referenced schema '\" + modelName + \"' is incorrect. \"+msgSuffix);\n+                }\n+                MappedModel mm = new MappedModel(modelName, toModelName(modelName));\n+                descendentSchemas.add(mm);\n+                Schema cs = ModelUtils.getSchema(openAPI, modelName);\n+                Map<String, Object> vendorExtensions = cs.getExtensions();\n+                if (vendorExtensions != null && !vendorExtensions.isEmpty()) {\n+                    String xDiscriminatorValue = (String) vendorExtensions.get(\"x-discriminator-value\");\n+                    mm = new MappedModel(xDiscriminatorValue, toModelName(modelName));\n+                    descendentSchemas.add(mm);\n+                }\n+\n+            }\n+        }\n+        return descendentSchemas;\n+    }\n+\n+    protected List<MappedModel> getAllOfDescendants(String thisSchemaName, OpenAPI openAPI) {\n+        ArrayList<String> queue = new ArrayList();;\n+        List<MappedModel> descendentSchemas = new ArrayList();\n+        Map<String, Schema> schemas = ModelUtils.getSchemas(openAPI);\n+        String currentSchemaName = thisSchemaName;\n+        while (true) {\n+            for (String childName : schemas.keySet()) {\n+                if (childName == thisSchemaName) {\n+                    continue;\n+                }\n+                Schema child = schemas.get(childName);\n+                if (ModelUtils.isComposedSchema(child)) {\n+                    ComposedSchema composedChild = (ComposedSchema) child;\n+                    List<Schema> parents = composedChild.getAllOf();\n+                    if (parents != null) {\n+                        for  (Schema parent: parents) {\n+                            String ref = parent.get$ref();\n+                            if (ref == null) {\n+                                // for schemas with no ref, it is not possible to build the discriminator map\n+                                // because ref is how we get the model name\n+                                // we only hit this use case for a schema with inline composed schemas, and one of those\n+                                // schemas also has inline composed schemas\n+                                throw new RuntimeException(\"Invalid inline schema defined in allOf in '\" + childName + \"'. Per the OpenApi spec, for this case when a composed schema defines a discriminator, the allOf schemas must use $ref. Change this inline definition to a $ref definition\");\n+                            }\n+                            String parentName = ModelUtils.getSimpleRef(ref);\n+                            if (parentName.equals(currentSchemaName)) {\n+                                if (queue.contains(childName) || descendentSchemas.contains(childName)) {\n+                                    throw new RuntimeException(\"Stack overflow hit when looking for \"+thisSchemaName+\" an infinite loop starting and ending at \"+childName+\" was seen\");\n+                                }\n+                                queue.add(childName);\n+                                break;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            if (queue.size() == 0) {\n+                break;\n+            }\n+            currentSchemaName = queue.remove(0);\n+            MappedModel mm = new MappedModel(currentSchemaName, toModelName(currentSchemaName));\n+            descendentSchemas.add(mm);\n+            Schema cs = schemas.get(currentSchemaName);\n+            Map<String, Object> vendorExtensions = cs.getExtensions();\n+            if (vendorExtensions != null && !vendorExtensions.isEmpty()) {\n+                String xDiscriminatorValue = (String) vendorExtensions.get(\"x-discriminator-value\");", "originalCommit": "dcd45406ec048643f6e1b90de843ec5ecbde9895", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY1MDAzOQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r403650039", "bodyText": "This was already updated to the simpler:\nif (vendorExtensions != null && !vendorExtensions.isEmpty() && vendorExtensions.containsKey(\"x-discriminator-value\")) {", "author": "spacether", "createdAt": "2020-04-05T05:07:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2OTM3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM3MjkzMw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r402372933", "bodyText": "It would be useful to document how the mappedModels field is populated.\nOne way to think about it when reading the code is \"oh this must be the explicit discriminator mappings as written in the OpenAPI document\", without any transformation.\nBut since codegen typically transforms the data, mappedModels could include mappings that have been resolved by codegen through a recursive discovery process.", "author": "sebastien-rosset", "createdAt": "2020-04-02T14:48:14Z", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/CodegenDiscriminator.java", "diffHunk": "@@ -7,7 +7,18 @@\n import java.util.Objects;\n import java.util.Set;\n \n+/**\n+ * This class encapsulates the OpenAPI discriminator construct, as specified at\n+ * https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.3.md#discriminatorObject.\n+ *\n+ * When request bodies or response payloads may be one of a number of different schemas,\n+ * a discriminator object can be used to aid in serialization, deserialization, and validation.\n+ * The discriminator is a specific object in a schema which is used to inform the consumer of\n+ * the specification of an alternative schema based on the value associated with it.\n+ */\n public class CodegenDiscriminator {\n+    // The name of the property in the payload that will hold the discriminator value.\n+    // This is the propertyName as specified in the OpenAPI discriminator object.", "originalCommit": "75ff63c1e606b563dbe559b2bc191de62659a7ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg3MjEzMQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r406872131", "bodyText": "This comment has been added:\n    // mappedModels is populated differently if discriminatorExplicitMappingVerbose is\n    // True or False. When:\n    //\n    // discriminatorExplicitMappingVerbose == False, this contains:\n    // - the name to schema map info in the discriminator mapping entry in your openapi spec OR\n    // - child schemas that allOf inherit self schema\n    //\n    // discriminatorExplicitMappingVerbose == True, this contains:\n    // - the name to schema map info in the discriminator mapping entry in your openapi spec AND\n    // - x-discriminator-value mappings in child oneOf + anyOf schemas + descendant schemas that allOf inherit self schema AND\n    // - descendant schemas that allOf inherit self schema AND\n    // - child oneOf + anyOf schemas\n    //\n    // see the method createDiscriminator in DefaultCodegen.java", "author": "spacether", "createdAt": "2020-04-10T17:57:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM3MjkzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkyNTk4MQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r404925981", "bodyText": "Not all languages use \"string\". What about using df.isString to check if it's a string instead?\nSame for line 2568.", "author": "wing328", "createdAt": "2020-04-07T16:00:51Z", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -2341,36 +2384,314 @@ public int compare(CodegenProperty one, CodegenProperty another) {\n         return m;\n     }\n \n-    protected CodegenDiscriminator createDiscriminator(String schemaName, Schema schema) {\n-        if (schema.getDiscriminator() == null) {\n+    /**\n+     * Recursively look in Schema sc for the discriminator discPropName\n+     * and return a CodegenProperty with the dataType and required params set\n+     * the returned CodegenProperty may not be required and it may not be of type string\n+     * @param composedSchemaName The name of the sc Schema\n+     * @param sc The Schema that may contain the discriminator\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     */\n+    private CodegenProperty discriminatorFound(String composedSchemaName, Schema sc, String discPropName, OpenAPI openAPI) {\n+        Schema refSchema = ModelUtils.getReferencedSchema(openAPI, sc);\n+        if (refSchema.getProperties() != null && refSchema.getProperties().get(discPropName) != null) {\n+            Schema discSchema = (Schema) refSchema.getProperties().get(discPropName);\n+            CodegenProperty cp = new CodegenProperty();\n+            cp.setDatatype(discSchema.getType());\n+            cp.setRequired(false);\n+            if (refSchema.getRequired() != null && refSchema.getRequired().contains(discPropName)) {\n+                cp.setRequired(true);\n+            }\n+            return cp;\n+        }\n+        if (ModelUtils.isComposedSchema(refSchema)) {\n+            ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+            if (composedSchema.getAllOf() != null) {\n+                // If our discriminator is in one of the allOf schemas break when we find it\n+                for  (Schema allOf: composedSchema.getAllOf()) {\n+                    CodegenProperty cp = discriminatorFound(composedSchemaName, allOf, discPropName, openAPI);\n+                    if (cp != null) {\n+                        return cp;\n+                    }\n+                }\n+            }\n+            if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n+                // All oneOf definitions must contain the discriminator\n+                CodegenProperty cp = new CodegenProperty();\n+                for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    String modelName = ModelUtils.getSimpleRef(oneOf.get$ref());\n+                    CodegenProperty thisCp = discriminatorFound(composedSchemaName, oneOf, discPropName, openAPI);\n+                    if (thisCp == null) {\n+                        throw new RuntimeException(\"'\" + composedSchemaName + \"' defines discriminator '\" + discPropName + \"', but the referenced OneOf schema '\" + modelName + \"' is missing \"+discPropName);\n+                    }\n+                    if (cp.dataType == null) {\n+                        cp = thisCp;\n+                        continue;\n+                    }\n+                    if (cp != thisCp) {\n+                        throw new RuntimeException(\"'\" + composedSchemaName + \"' defines discriminator '\" + discPropName + \"', but the OneOf schema '\" + modelName + \"' has a different \"+discPropName+\" definition than the prior OneOf schema's. Make sure the \"+discPropName+\" type and required values are the same\");\n+                    }\n+                }\n+                return cp;\n+            }\n+            if (composedSchema.getAnyOf() != null && composedSchema.getAnyOf().size() != 0) {\n+                // All anyOf definitions must contain the discriminator because a min of one must be selected\n+                CodegenProperty cp = new CodegenProperty();\n+                for  (Schema anyOf: composedSchema.getAnyOf()) {\n+                    String modelName = ModelUtils.getSimpleRef(anyOf.get$ref());\n+                    CodegenProperty thisCp = discriminatorFound(composedSchemaName, anyOf, discPropName, openAPI);\n+                    if (thisCp == null) {\n+                        throw new RuntimeException(\"'\" + composedSchemaName + \"' defines discriminator '\" + discPropName + \"', but the referenced AnyOf schema '\" + modelName + \"' is missing \"+discPropName);\n+                    }\n+                    if (cp.dataType == null) {\n+                        cp = thisCp;\n+                        continue;\n+                    }\n+                    if (cp != thisCp) {\n+                        throw new RuntimeException(\"'\" + composedSchemaName + \"' defines discriminator '\" + discPropName + \"', but the AnyOf schema '\" + modelName + \"' has a different \"+discPropName+\" definition than the prior AnyOf schema's. Make sure the \"+discPropName+\" type and required values are the same\");\n+                    }\n+                }\n+                return cp;\n+\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Recursively look in Schema sc for the discriminator and return it\n+     * Schema sc location\n+     * OpenAPI openAPI the spec where we are searching for the discriminator\n+     * @param sc The Schema that may contain the discriminator\n+     */\n+    private Discriminator recursiveGetDiscriminator(Schema sc, OpenAPI openAPI) {\n+        Schema refSchema = ModelUtils.getReferencedSchema(openAPI, sc);\n+        Discriminator foundDisc = refSchema.getDiscriminator();\n+        if (foundDisc != null) {\n+            return foundDisc;\n+        }\n+        if (!this.getDiscriminatorExplicitMappingVerbose()) {\n+            return null;\n+        }\n+        Discriminator disc = new Discriminator();\n+        if (ModelUtils.isComposedSchema(refSchema)) {\n+            ComposedSchema composedSchema = (ComposedSchema) refSchema;\n+            if (composedSchema.getAllOf() != null) {\n+                // If our discriminator is in one of the allOf schemas break when we find it\n+                for  (Schema allOf: composedSchema.getAllOf()) {\n+                    foundDisc = recursiveGetDiscriminator(allOf, openAPI);\n+                    if (foundDisc != null) {\n+                        disc.setPropertyName(foundDisc.getPropertyName());\n+                        disc.setMapping(foundDisc.getMapping());\n+                        return disc;\n+                    }\n+                }\n+            }\n+            if (composedSchema.getOneOf() != null && composedSchema.getOneOf().size() != 0) {\n+                // All oneOf definitions must contain the discriminator\n+                Integer hasDiscriminatorCnt = 0;\n+                Set<String> discriminatorsPropNames = new HashSet<>();\n+                for  (Schema oneOf: composedSchema.getOneOf()) {\n+                    foundDisc = recursiveGetDiscriminator(oneOf, openAPI);\n+                    if (foundDisc != null) {\n+                        discriminatorsPropNames.add(foundDisc.getPropertyName());\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getOneOf().size() && discriminatorsPropNames.size() == 1) {\n+                    disc.setPropertyName(foundDisc.getPropertyName());\n+                    disc.setMapping(foundDisc.getMapping());\n+                    return disc;\n+                }\n+            }\n+            if (composedSchema.getAnyOf() != null && composedSchema.getAnyOf().size() != 0) {\n+                // All anyOf definitions must contain the discriminator because a min of one must be selected\n+                Integer hasDiscriminatorCnt = 0;\n+                Set<String> discriminatorsPropNames = new HashSet<>();\n+                for  (Schema anyOf: composedSchema.getAnyOf()) {\n+                    foundDisc = recursiveGetDiscriminator(anyOf, openAPI);\n+                    if (foundDisc != null) {\n+                        discriminatorsPropNames.add(foundDisc.getPropertyName());\n+                        hasDiscriminatorCnt++;\n+                    }\n+                }\n+                if (hasDiscriminatorCnt == composedSchema.getAnyOf().size() && discriminatorsPropNames.size() == 1) {\n+                    disc.setPropertyName(foundDisc.getPropertyName());\n+                    disc.setMapping(foundDisc.getMapping());\n+                    return disc;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * This function is only used for composed schemas which have a discriminator\n+     * Process oneOf and anyOf models in a composed schema and adds them into\n+     * a list if the oneOf and anyOf models contain\n+     * the required discriminator. If they don't contain the required\n+     * discriminator or the discriminator is the wrong type then an error is\n+     * thrown\n+     * @param composedSchemaName The String model name of the composed schema where we are setting the discriminator map\n+     * @param discPropName The String that is the discriminator propertyName in the schema\n+     * @param c The ComposedSchema that contains the discriminator and oneOf/anyOf schemas\n+     * @param openAPI The OpenAPI spec that we are using\n+     * @return the list of oneOf and anyOf MappedModel that need to be added to the discriminator map\n+     */\n+    protected List<MappedModel> getOneOfAnyOfDescendants(String composedSchemaName, String discPropName, ComposedSchema c, OpenAPI openAPI) {\n+        ArrayList<List<Schema>> listOLists = new ArrayList<List<Schema>>();\n+        listOLists.add(c.getOneOf());\n+        listOLists.add(c.getAnyOf());\n+        List<MappedModel> descendentSchemas = new ArrayList();\n+        for (List<Schema> schemaList: listOLists) {\n+            if (schemaList == null) {\n+                continue;\n+            }\n+            for  (Schema sc: schemaList) {\n+                String ref = sc.get$ref();\n+                if (ref == null) {\n+                    // for schemas with no ref, it is not possible to build the discriminator map\n+                    // because ref is how we get the model name\n+                    // we only hit this use case for a schema with inline composed schemas, and one of those\n+                    // schemas also has inline composed schemas\n+                    // Note: if it is only inline one level, then the inline model resolver will move it into its own\n+                    // schema and make it a $ref schema in the oneOf/anyOf location\n+                    throw new RuntimeException(\"Invalid inline schema defined in oneOf/anyOf in '\" + composedSchemaName + \"'. Per the OpenApi spec, for this case when a composed schema defines a discriminator, the oneOf/anyOf schemas must use $ref. Change this inline definition to a $ref definition\");\n+                }\n+                CodegenProperty df = discriminatorFound(composedSchemaName, sc, discPropName, openAPI);\n+                String modelName = ModelUtils.getSimpleRef(ref);\n+                if (df == null || !\"string\".equals(df.dataType) || df.required != true) {", "originalCommit": "c7f1bce202ff72ab096548cc20094cdeda9afae8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTAxMzQ1OA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r405013458", "bodyText": "Switched to using df.isString", "author": "spacether", "createdAt": "2020-04-07T18:12:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkyNTk4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxMjAxMQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r410712011", "bodyText": "This option needs clarification since it's currently doing a lot.\n\nCan we remove the \"verbose\" since that's not really relevant to the user?\nThe term mapping would indicate to users who are familiar with our options that this would take a string in the format key=value, which is not the case.\nThe option is triggering OpenAPI 3.x logic, but doesn't indicate that clearly here.\n\nMight I recommend changing this to something more like:\n@Option(name = {\"--legacy-discriminators\"}, title = \"Support legacy logic for evaluating discriminators\", description = CodegenConstants.DISCRIMINATOR_EXPLICIT_MAPPING_VERBOSE_DESC)\nprivate Boolean legacyDiscriminators;\n\nThis value would need to default to true until the new logic becomes default (I don't recall if it's now default or not).\nThe value would then have to be applied to CodegenConfigurator, which is not done in Generate.java here. The same default would have to be done in the Maven and Gradle plugins, with a task to add the feature option to those. We also have a new SBT plugin (pending first release) where this would have to be added.", "author": "jimschubert", "createdAt": "2020-04-18T15:27:03Z", "path": "modules/openapi-generator-cli/src/main/java/org/openapitools/codegen/cmd/Generate.java", "diffHunk": "@@ -240,6 +240,9 @@\n     @Option(name = {\"--generate-alias-as-model\"}, title = \"generate alias (array, map) as model\", description = CodegenConstants.GENERATE_ALIAS_AS_MODEL_DESC)\n     private Boolean generateAliasAsModel;\n \n+    @Option(name = {\"--discriminator-explicit-mapping-verbose\"}, title = \"explicitly define a discriminator on all models which have one, add verbose mapping to that discriminator, validate discriminators\", description = CodegenConstants.DISCRIMINATOR_EXPLICIT_MAPPING_VERBOSE_DESC)", "originalCommit": "29bc8e65542eaad84f277957c14028a7fe44de84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDczNTUxNg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r410735516", "bodyText": "This option needs clarification since it's currently doing a lot.\n\nCan we remove the \"verbose\" since that's not really relevant to the user?\nThe term mapping would indicate to users who are familiar with our options that this would take a string in the format key=value, which is not the case.\nThe option is triggering OpenAPI 3.x logic, but doesn't indicate that clearly here.\n\nMight I recommend changing this to something more like:\n@Option(name = {\"--legacy-discriminators\"}, title = \"Support legacy logic for evaluating discriminators\", description = CodegenConstants.DISCRIMINATOR_EXPLICIT_MAPPING_VERBOSE_DESC)\nprivate Boolean legacyDiscriminators;\n\nThis value would need to default to true until the new logic becomes default (I don't recall if it's now default or not).\nThe value would then have to be applied to CodegenConfigurator, which is not done in Generate.java here. The same default would have to be done in the Maven and Gradle plugins, with a task to add the feature option to those. We also have a new SBT plugin (pending first release) where this would have to be added.\n\nI think the name should be even more explicit. Without this PR, the existing OAS v3 is buggy. It's not just that it would be legacy, it is not fully compliant with the OAS oneOf/allOf/anyOf spec. At least that's my assessment for python, python-experimental, go, go-experimental, powershell and all java clients. Until a language generator enables this parameter, it should not claim support for anyOf/allOf/oneOf, or maybe it should only claim partial support.", "author": "sebastien-rosset", "createdAt": "2020-04-18T18:48:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxMjAxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc0NjYzMw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r410746633", "bodyText": "@sebastien-rosset allowing the user to continue using the same previous behavior (legacy), means we don't break people who have written customization to overcome any limitations.\nMaybe \"legacy discriminator behavior\"? As it is now, I don't think we could meet this with such a confusing option.\nConsider for instance someone with a 2.0 spec shouldn't assume that setting this value to true gets them 3.0 behavior. As it is now, that's what it sounds like. A 3.0 spec shouldn't change generated output drastically. I agree this makes the logic more correct, but again people are about to extend generators as well as templates. Any user who has specified vendor extensions or written a custom generator would be blocked from updates because of this change, and such a user inspections options wouldn't understand this is the option to change.", "author": "jimschubert", "createdAt": "2020-04-18T20:29:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxMjAxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc1MjI4Nw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r410752287", "bodyText": "@sebastien-rosset allowing the user to continue using the same previous behavior (legacy), means we don't break people who have written customization to overcome any limitations.\nMaybe \"legacy discriminator behavior\"? As it is now, I don't think we could meet this with such a confusing option.\n\nI agree the current option name could be improved.\n\nConsider for instance someone with a 2.0 spec shouldn't assume that setting this value to true gets them 3.0 behavior. As it is now, that's what it sounds like. A 3.0 spec shouldn't change generated output drastically. I agree this makes the logic more correct, but again people are about to extend generators as well as templates. Any user who has specified vendor extensions or written a custom generator would be blocked from updates because of this change, and such a user inspections options wouldn't understand this is the option to change.\n\nSure, but don't you think at some point all language generators should enable the new behavior by default (as implemented in this PR)? The tool should support all OAS 3.x features by default. Otherwise, somebody who is downloading OpenAPITools for the first time and compiles a OAS v3 spec that contains oneOf/allOf/anyOf.\nIf there needs to be a differentiation between 2.x and 3.x maybe that could be done selectively based on the version?", "author": "sebastien-rosset", "createdAt": "2020-04-18T21:19:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxMjAxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc2ODk0MA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r410768940", "bodyText": "Yes, but unfortunately you can't really have non-breaking behavior for 3.0 (bug fix, spec support) and potentially break the behavior for 2.0 at the same time. We have to play it safer, especially since feature requests indicate more people are on 2.0 specs still, and we don't have telemetry to know differently. If we can do these simultaneously, then there's no need to a user-facing option.", "author": "jimschubert", "createdAt": "2020-04-18T23:20:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxMjAxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU0Njc2OQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r413546769", "bodyText": "This has been changed to legacyDiscriminatorBehavior", "author": "spacether", "createdAt": "2020-04-23T06:36:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxMjAxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxMjM0MA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r410712340", "bodyText": "This is a confusing use of configuration. It's created in Generate.java as a CLI option, but then pulled from additionalProperties here. We should stick to one or the other (not both).\nI think it makes sense to add it to WorkflowSettings because we're defining the workflow for geneation.\nLet me know if you'd like help and I can contribute that directly to your branch.", "author": "jimschubert", "createdAt": "2020-04-18T15:29:27Z", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -306,6 +309,11 @@ public void processOpts() {\n             this.setRemoveEnumValuePrefix(Boolean.valueOf(additionalProperties\n                     .get(CodegenConstants.REMOVE_ENUM_VALUE_PREFIX).toString()));\n         }\n+\n+        if (additionalProperties.containsKey(CodegenConstants.DISCRIMINATOR_EXPLICIT_MAPPING_VERBOSE)) {", "originalCommit": "29bc8e65542eaad84f277957c14028a7fe44de84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU0Njk5Mw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r413546993", "bodyText": "This has been changed to legacyDiscriminatorBehavior\nI will update to the suggested integration", "author": "spacether", "createdAt": "2020-04-23T06:36:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxMjM0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxMzU1NQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r410713555", "bodyText": "This option needs better definition. If it's a CLI option (in Generate.java), it should be hooked up to CodegenConfigurator and applied as a way to configure this generation.\nCliOptions is a place to define generator-specific (*Codegen types) logic, and not \"global\" workflows.\nFor instance, the option in Generate.java will show via cli help generate while the option here would show via cli config-help -g generator_name. The latter is intended only for those configurations which don't apply to all generators.\nA good rule for these:  only define things in CliOptions if they are template customizable, put others via CodegenConfigurator and extend via additionalProperties.  I open to clarify and clean this all up by 5.0.", "author": "jimschubert", "createdAt": "2020-04-18T15:39:27Z", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultCodegen.java", "diffHunk": "@@ -1423,6 +1440,9 @@ public DefaultCodegen() {\n         // option to change the order of form/body parameter\n         cliOptions.add(CliOption.newBoolean(CodegenConstants.PREPEND_FORM_OR_BODY_PARAMETERS,\n                 CodegenConstants.PREPEND_FORM_OR_BODY_PARAMETERS_DESC).defaultValue(Boolean.FALSE.toString()));\n+        cliOptions.add(CliOption.newBoolean(CodegenConstants.DISCRIMINATOR_EXPLICIT_MAPPING_VERBOSE,", "originalCommit": "29bc8e65542eaad84f277957c14028a7fe44de84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU0NzQ0Mg==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r413547442", "bodyText": "This has been changed to LEGACY_DISCRIMINATOR_BEHAVIOR\nI will update to the suggested integration", "author": "spacether", "createdAt": "2020-04-23T06:37:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxMzU1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxMzgxMw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r410713813", "bodyText": "This should not be protected. If you're doing this for testing, please remove the modifier and treat this as package-private. By adding protected, you're telling users that we expect them to customize this and modify the method. That would be a maintenance nightmare for us if we don't even know how the tool's properties are applied.", "author": "jimschubert", "createdAt": "2020-04-18T15:42:08Z", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultGenerator.java", "diffHunk": "@@ -156,7 +156,7 @@ private Boolean getGeneratorPropertyDefaultSwitch(final String key, final Boolea\n         return defaultValue;\n     }\n \n-    private void configureGeneratorProperties() {\n+    protected void configureGeneratorProperties() {", "originalCommit": "29bc8e65542eaad84f277957c14028a7fe44de84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ5Njc4NQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r413496785", "bodyText": "This update is needed for tests, changed it to package private", "author": "spacether", "createdAt": "2020-04-23T04:18:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxMzgxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxMzgyNQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r410713825", "bodyText": "Same. This should not be protected. If you're doing this for testing, please remove the modifier and treat this as package-private.", "author": "jimschubert", "createdAt": "2020-04-18T15:42:21Z", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/DefaultGenerator.java", "diffHunk": "@@ -394,7 +394,7 @@ private void generateModel(List<File> files, Map<String, Object> models, String\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    private void generateModels(List<File> files, List<Object> allModels, List<String> unusedModels) {\n+    protected void generateModels(List<File> files, List<Object> allModels, List<String> unusedModels) {", "originalCommit": "29bc8e65542eaad84f277957c14028a7fe44de84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ5Njk0NA==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r413496944", "bodyText": "This update is needed for tests, changed it to package private", "author": "spacether", "createdAt": "2020-04-23T04:18:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxMzgyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxNDM0MQ==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r410714341", "bodyText": "This isn't an appropriate place for this option. If someone were to extend this generator and modify the value (maybe they don't support this explicitly mapping in their templates), you're potentially overwriting their value.\nPlease move this to the constructor here and elsewhere. This would also allow our tooling to understand the defaults for the generator. Putting a default here, it's not known until execution time (via a \"real\" generate). See hideGenerationTimestamp in this constructor.", "author": "jimschubert", "createdAt": "2020-04-18T15:46:44Z", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/languages/GoClientExperimentalCodegen.java", "diffHunk": "@@ -77,6 +77,7 @@ public String getHelp() {\n \n     @Override\n     public void processOpts() {\n+        this.setDiscriminatorExplicitMappingVerbose(true);", "originalCommit": "29bc8e65542eaad84f277957c14028a7fe44de84", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxNDM2Mw==", "url": "https://github.com/OpenAPITools/openapi-generator/pull/4906#discussion_r410714363", "bodyText": "Please move default option to constructor.", "author": "jimschubert", "createdAt": "2020-04-18T15:47:08Z", "path": "modules/openapi-generator/src/main/java/org/openapitools/codegen/languages/PythonClientExperimentalCodegen.java", "diffHunk": "@@ -111,6 +111,8 @@ public PythonClientExperimentalCodegen() {\n \n     @Override\n     public void processOpts() {\n+        this.setDiscriminatorExplicitMappingVerbose(true);", "originalCommit": "29bc8e65542eaad84f277957c14028a7fe44de84", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a7a5ccaaeb971ddce9badd8c497c1becda9aa93f", "url": "https://github.com/OpenAPITools/openapi-generator/commit/a7a5ccaaeb971ddce9badd8c497c1becda9aa93f", "message": "Adds addComposedMappedModels and testComposedSchemaOneOfDiscriminatorMap", "committedDate": "2020-04-23T04:48:58Z", "type": "commit"}, {"oid": "cb6c4bd20deb5c7bf7bc53647ff070a224dbc835", "url": "https://github.com/OpenAPITools/openapi-generator/commit/cb6c4bd20deb5c7bf7bc53647ff070a224dbc835", "message": "Requires that discriminators be required properties", "committedDate": "2020-04-23T04:48:59Z", "type": "commit"}, {"oid": "53ba1fa0e6a259406cfbfb91dea7b672f7b9bfb3", "url": "https://github.com/OpenAPITools/openapi-generator/commit/53ba1fa0e6a259406cfbfb91dea7b672f7b9bfb3", "message": "Strengthens discriminaotr validation, adds better error messages, adds schema oneof samples", "committedDate": "2020-04-23T04:48:59Z", "type": "commit"}, {"oid": "23c5c3882486eacbf51b8a0db71ec8b9391dd015", "url": "https://github.com/OpenAPITools/openapi-generator/commit/23c5c3882486eacbf51b8a0db71ec8b9391dd015", "message": "Adds oneOf and anyOf invalidDiscriminator tests", "committedDate": "2020-04-23T04:48:59Z", "type": "commit"}, {"oid": "e3b6522282c59d036f1b83fdc9e59e89cd1a5187", "url": "https://github.com/OpenAPITools/openapi-generator/commit/e3b6522282c59d036f1b83fdc9e59e89cd1a5187", "message": "Updates incorrect addOneOfInterfaceModel invocation", "committedDate": "2020-04-23T04:49:00Z", "type": "commit"}, {"oid": "7b85b2d55d5233bed6cb19364dfe8356dee7787f", "url": "https://github.com/OpenAPITools/openapi-generator/commit/7b85b2d55d5233bed6cb19364dfe8356dee7787f", "message": "Runs ensure-up-to-date", "committedDate": "2020-04-23T04:49:00Z", "type": "commit"}, {"oid": "53ab46b6f11a11c39b6dbac7f87ffeb6ef333f93", "url": "https://github.com/OpenAPITools/openapi-generator/commit/53ab46b6f11a11c39b6dbac7f87ffeb6ef333f93", "message": "Adds updates from Sebastien Rosset", "committedDate": "2020-04-23T04:49:00Z", "type": "commit"}, {"oid": "7242b940046082a5de6736417c02dc00677b5d2a", "url": "https://github.com/OpenAPITools/openapi-generator/commit/7242b940046082a5de6736417c02dc00677b5d2a", "message": "Removes newlines", "committedDate": "2020-04-23T04:49:00Z", "type": "commit"}, {"oid": "ddefbea34453b47de69a474b2d87670f06792baf", "url": "https://github.com/OpenAPITools/openapi-generator/commit/ddefbea34453b47de69a474b2d87670f06792baf", "message": "Uses df.isString", "committedDate": "2020-04-23T04:49:01Z", "type": "commit"}, {"oid": "831c99a892a785adb148b6c2192b13e74759faf6", "url": "https://github.com/OpenAPITools/openapi-generator/commit/831c99a892a785adb148b6c2192b13e74759faf6", "message": "Fixes tests be correctly setting df.isString", "committedDate": "2020-04-23T04:49:01Z", "type": "commit"}, {"oid": "6ab57c86f9a888a6921846f8efbaf818ee4afb40", "url": "https://github.com/OpenAPITools/openapi-generator/commit/6ab57c86f9a888a6921846f8efbaf818ee4afb40", "message": "Updates discriminatorExplicitMappingVerbose description per PR feedback", "committedDate": "2020-04-23T04:53:35Z", "type": "commit"}, {"oid": "607f638301fec5019b64e38d2e2faab46cdf75e6", "url": "https://github.com/OpenAPITools/openapi-generator/commit/607f638301fec5019b64e38d2e2faab46cdf75e6", "message": "Adds description of how mappedModels is populated", "committedDate": "2020-04-23T04:53:35Z", "type": "commit"}, {"oid": "bc23d3e2b4a78c68b6a54a80b584cb79235663ba", "url": "https://github.com/OpenAPITools/openapi-generator/commit/bc23d3e2b4a78c68b6a54a80b584cb79235663ba", "message": "Adds the suggestion exception raising when a MappedModel mappingName is null", "committedDate": "2020-04-23T04:53:35Z", "type": "commit"}, {"oid": "052bccc86b7ff84f7c7b255befae6938fcbb1b77", "url": "https://github.com/OpenAPITools/openapi-generator/commit/052bccc86b7ff84f7c7b255befae6938fcbb1b77", "message": "Actually resolves merge conflicts", "committedDate": "2020-04-23T04:57:58Z", "type": "commit"}, {"oid": "89c8025dc75af769225802840209ead5a7277a5d", "url": "https://github.com/OpenAPITools/openapi-generator/commit/89c8025dc75af769225802840209ead5a7277a5d", "message": "Switches two methods to package private because they are needed for testing", "committedDate": "2020-04-23T04:57:59Z", "type": "commit"}, {"oid": "936c0b1a3b4fa675791190a3dcab594e3e1c6ad6", "url": "https://github.com/OpenAPITools/openapi-generator/commit/936c0b1a3b4fa675791190a3dcab594e3e1c6ad6", "message": "Allow nulls in MappedModel.getMappingName", "committedDate": "2020-04-23T04:57:59Z", "type": "commit"}, {"oid": "936c0b1a3b4fa675791190a3dcab594e3e1c6ad6", "url": "https://github.com/OpenAPITools/openapi-generator/commit/936c0b1a3b4fa675791190a3dcab594e3e1c6ad6", "message": "Allow nulls in MappedModel.getMappingName", "committedDate": "2020-04-23T04:57:59Z", "type": "forcePushed"}, {"oid": "5b2563f0a56368748f08add1d281b830d1026982", "url": "https://github.com/OpenAPITools/openapi-generator/commit/5b2563f0a56368748f08add1d281b830d1026982", "message": "Updates CLI flag name to legacyDiscriminatorBehavior, default=true", "committedDate": "2020-04-23T06:27:35Z", "type": "commit"}, {"oid": "f8c95d8865e0a4a7a2e3dc1b20a3c909f0205ca6", "url": "https://github.com/OpenAPITools/openapi-generator/commit/f8c95d8865e0a4a7a2e3dc1b20a3c909f0205ca6", "message": "Merge branch 'master' into issue_4904_fix_composed_schema_discriminator_map", "committedDate": "2020-04-24T09:57:58Z", "type": "commit"}]}