{"pr_number": 1156, "pr_title": "Protobuf-backed FieldValues", "pr_createdAt": "2020-01-23T01:06:08Z", "pr_url": "https://github.com/firebase/firebase-android-sdk/pull/1156", "timeline": [{"oid": "5d3f44dbe37c5ef91bb90e4ad6fbf9e71e68f2d3", "url": "https://github.com/firebase/firebase-android-sdk/commit/5d3f44dbe37c5ef91bb90e4ad6fbf9e71e68f2d3", "message": "Adding Proto-based equality and comparison\n\nThis will be used (and tested) in the follow-up CL that adds the FieldValue tpes.", "committedDate": "2020-01-23T16:50:09Z", "type": "commit"}, {"oid": "5d006f0d59f7fa8df29414201376a61e1b54a355", "url": "https://github.com/firebase/firebase-android-sdk/commit/5d006f0d59f7fa8df29414201376a61e1b54a355", "message": "Adding test utilities to create Value types\n\nThis exposes a similar interface as wrap() and allows me to change the existing FieldValue test to use Value protos", "committedDate": "2020-01-23T16:57:17Z", "type": "commit"}, {"oid": "8440ced4f5f4e42b0269ad464e5362ffc8fbafd1", "url": "https://github.com/firebase/firebase-android-sdk/commit/8440ced4f5f4e42b0269ad464e5362ffc8fbafd1", "message": "Merge branch 'mrschmidt/comparisons' into mrschmidt/testhelpers", "committedDate": "2020-01-23T18:01:10Z", "type": "commit"}, {"oid": "c315cdceb0a40023ddfcd0d966171b06c42e888d", "url": "https://github.com/firebase/firebase-android-sdk/commit/c315cdceb0a40023ddfcd0d966171b06c42e888d", "message": "Address feeback", "committedDate": "2020-01-23T19:14:44Z", "type": "commit"}, {"oid": "a6f880ae8b4e4b11b91dfaeaec5b1ae86e40f12c", "url": "https://github.com/firebase/firebase-android-sdk/commit/a6f880ae8b4e4b11b91dfaeaec5b1ae86e40f12c", "message": "Address feeback", "committedDate": "2020-01-23T19:40:29Z", "type": "commit"}, {"oid": "529881b881c7c9c40a6a01bb9151e298086074f4", "url": "https://github.com/firebase/firebase-android-sdk/commit/529881b881c7c9c40a6a01bb9151e298086074f4", "message": "Merge branch 'mrschmidt/comparisons' into mrschmidt/testhelpers", "committedDate": "2020-01-23T19:41:14Z", "type": "commit"}, {"oid": "c8d1ce8f68fe2cca448d4965bf6ec5272b057c91", "url": "https://github.com/firebase/firebase-android-sdk/commit/c8d1ce8f68fe2cca448d4965bf6ec5272b057c91", "message": "Review feedback", "committedDate": "2020-01-23T19:53:14Z", "type": "commit"}, {"oid": "7bd837f763dd44966f4f5be1fdd9957d85a2c4d0", "url": "https://github.com/firebase/firebase-android-sdk/commit/7bd837f763dd44966f4f5be1fdd9957d85a2c4d0", "message": "Add Protobuf-backed FieldValue", "committedDate": "2020-01-23T22:08:02Z", "type": "forcePushed"}, {"oid": "074f88af805ba4e84c732fb25dff4683085e1cfd", "url": "https://github.com/firebase/firebase-android-sdk/commit/074f88af805ba4e84c732fb25dff4683085e1cfd", "message": "Add Protobuf-backed FieldValue", "committedDate": "2020-01-23T22:27:45Z", "type": "commit"}, {"oid": "074f88af805ba4e84c732fb25dff4683085e1cfd", "url": "https://github.com/firebase/firebase-android-sdk/commit/074f88af805ba4e84c732fb25dff4683085e1cfd", "message": "Add Protobuf-backed FieldValue", "committedDate": "2020-01-23T22:27:45Z", "type": "forcePushed"}, {"oid": "85e9fff50ba52fed1d64d01df56c1759eaaf6780", "url": "https://github.com/firebase/firebase-android-sdk/commit/85e9fff50ba52fed1d64d01df56c1759eaaf6780", "message": "Fix compile", "committedDate": "2020-01-24T00:27:46Z", "type": "commit"}, {"oid": "74f88959a003cf89a6623afd9658f06acb67d909", "url": "https://github.com/firebase/firebase-android-sdk/commit/74f88959a003cf89a6623afd9658f06acb67d909", "message": "More compile fixes", "committedDate": "2020-01-24T00:41:49Z", "type": "commit"}, {"oid": "618f903cc44c3d8e4dace9e9f24b6bd3b2758957", "url": "https://github.com/firebase/firebase-android-sdk/commit/618f903cc44c3d8e4dace9e9f24b6bd3b2758957", "message": "Format", "committedDate": "2020-01-24T01:14:23Z", "type": "commit"}, {"oid": "27509284649e4bbf162d84fb94cd3a8f6f4c63d2", "url": "https://github.com/firebase/firebase-android-sdk/commit/27509284649e4bbf162d84fb94cd3a8f6f4c63d2", "message": "Merge", "committedDate": "2020-01-24T05:37:28Z", "type": "commit"}, {"oid": "c59910665915602fd659fec1b88947935cd8a011", "url": "https://github.com/firebase/firebase-android-sdk/commit/c59910665915602fd659fec1b88947935cd8a011", "message": "Remove duplicate file", "committedDate": "2020-01-24T05:38:29Z", "type": "commit"}, {"oid": "9354a50d365664965d5bdb50d6bbfe3330478bcc", "url": "https://github.com/firebase/firebase-android-sdk/commit/9354a50d365664965d5bdb50d6bbfe3330478bcc", "message": "Remove exceess newline", "committedDate": "2020-01-24T17:02:13Z", "type": "commit"}, {"oid": "2baaba1143ee179a10f278a541f7274b8cefa08f", "url": "https://github.com/firebase/firebase-android-sdk/commit/2baaba1143ee179a10f278a541f7274b8cefa08f", "message": "Imports", "committedDate": "2020-01-24T17:18:38Z", "type": "commit"}, {"oid": "7bf5e40e48c1f367e83e5d46fdc791dcb9dc2418", "url": "https://github.com/firebase/firebase-android-sdk/commit/7bf5e40e48c1f367e83e5d46fdc791dcb9dc2418", "message": "Add package-info.java", "committedDate": "2020-01-24T19:03:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTM4NzYzOA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1156#discussion_r371387638", "bodyText": "Comments?", "author": "wilhuff", "createdAt": "2020-01-27T17:47:16Z", "path": "firebase-firestore/src/main/java/com/google/firebase/firestore/model/protovalue/PrimitiveValue.java", "diffHunk": "@@ -0,0 +1,149 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.firestore.model.protovalue;\n+\n+import static com.google.firebase.firestore.util.Assert.fail;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import com.google.firebase.Timestamp;\n+import com.google.firebase.firestore.Blob;\n+import com.google.firebase.firestore.GeoPoint;\n+import com.google.firebase.firestore.model.DocumentKey;\n+import com.google.firebase.firestore.model.ResourcePath;\n+import com.google.firebase.firestore.model.value.FieldValue;\n+import com.google.firebase.firestore.model.value.ProtoValues;\n+import com.google.firebase.firestore.model.value.ServerTimestampValue;\n+import com.google.firebase.firestore.util.Assert;\n+import com.google.firestore.v1.ArrayValue;\n+import com.google.firestore.v1.Value;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class PrimitiveValue extends FieldValue {", "originalCommit": "7bf5e40e48c1f367e83e5d46fdc791dcb9dc2418", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEzMjQ3MA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1156#discussion_r372132470", "bodyText": "Added. FWIW, I am debating merging this with FieldValue before the final merge.", "author": "schmidt-sebastian", "createdAt": "2020-01-29T00:24:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTM4NzYzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU0OTMyNg==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1156#discussion_r372549326", "bodyText": "Merging SGTM. There seems to be little reason to keep this separate.", "author": "wilhuff", "createdAt": "2020-01-29T18:17:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTM4NzYzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkyODQ0NA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1156#discussion_r371928444", "bodyText": "It might be worth pointing out that MapValues aren't completely banned. Empty objects are stored in the overlay map intact.", "author": "wilhuff", "createdAt": "2020-01-28T16:53:25Z", "path": "firebase-firestore/src/main/java/com/google/firebase/firestore/model/protovalue/ObjectValue.java", "diffHunk": "@@ -0,0 +1,266 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.firestore.model.protovalue;\n+\n+import static com.google.firebase.firestore.model.value.ProtoValues.isType;\n+import static com.google.firebase.firestore.util.Assert.hardAssert;\n+\n+import androidx.annotation.Nullable;\n+import com.google.firebase.firestore.model.FieldPath;\n+import com.google.firebase.firestore.model.mutation.FieldMask;\n+import com.google.firebase.firestore.model.value.FieldValue;\n+import com.google.firestore.v1.MapValue;\n+import com.google.firestore.v1.Value;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+public class ObjectValue extends PrimitiveValue {\n+  private static final ObjectValue EMPTY_VALUE =\n+      new ObjectValue(\n+          com.google.firestore.v1.Value.newBuilder()\n+              .setMapValue(com.google.firestore.v1.MapValue.getDefaultInstance())\n+              .build());\n+\n+  public static ObjectValue emptyObject() {\n+    return EMPTY_VALUE;\n+  }\n+\n+  public ObjectValue(Value value) {\n+    super(value);\n+    hardAssert(isType(value, TYPE_ORDER_OBJECT), \"ObjectValues must be backed by a MapValue\");\n+  }\n+\n+  /**\n+   * Returns the value at the given path or null.\n+   *\n+   * @param fieldPath the path to search\n+   * @return The value at the path or if there it doesn't exist.\n+   */\n+  public @Nullable FieldValue get(FieldPath fieldPath) {\n+    Value value = internalValue;\n+\n+    for (int i = 0; i < fieldPath.length() - 1; ++i) {\n+      value = value.getMapValue().getFieldsOrDefault(fieldPath.getSegment(i), null);\n+      if (!isType(value, TYPE_ORDER_OBJECT)) {\n+        return null;\n+      }\n+    }\n+\n+    value = value.getMapValue().getFieldsOrDefault(fieldPath.getLastSegment(), null);\n+    return value != null ? FieldValue.of(value) : null;\n+  }\n+\n+  /** Recursively extracts the FieldPaths that are set in this ObjectValue. */\n+  public FieldMask getFieldMask() {\n+    return extractFieldMask(internalValue.getMapValue());\n+  }\n+\n+  private FieldMask extractFieldMask(MapValue value) {\n+    Set<FieldPath> fields = new HashSet<>();\n+    for (Map.Entry<String, Value> entry : value.getFieldsMap().entrySet()) {\n+      FieldPath currentPath = FieldPath.fromSingleSegment(entry.getKey());\n+      if (isType(entry.getValue(), TYPE_ORDER_OBJECT)) {\n+        FieldMask nestedMask = extractFieldMask(entry.getValue().getMapValue());\n+        Set<FieldPath> nestedFields = nestedMask.getMask();\n+        if (nestedFields.isEmpty()) {\n+          // Preserve the empty map by adding it to the FieldMask.\n+          fields.add(currentPath);\n+        } else {\n+          // For nested and non-empty ObjectValues, add the FieldPath of the leaf nodes.\n+          for (FieldPath nestedPath : nestedFields) {\n+            fields.add(currentPath.append(nestedPath));\n+          }\n+        }\n+      } else {\n+        fields.add(currentPath);\n+      }\n+    }\n+    return FieldMask.fromSet(fields);\n+  }\n+\n+  /** Creates a ObjectValue.Builder instance that is based on the current value. */\n+  public ObjectValue.Builder toBuilder() {\n+    return new Builder(this);\n+  }\n+\n+  /** An ObjectValue.Builder provides APIs to set and delete fields from an ObjectValue. */\n+  public static class Builder {\n+\n+    /** The existing data to mutate. */\n+    private ObjectValue baseObject;\n+\n+    /**\n+     * A list of FieldPath/Value pairs to apply to the base object. `null` values indicate field\n+     * deletes. MapValues are expanded before they are stored in the overlay map, so that an entry\n+     * exists for each leaf node.", "originalCommit": "7bf5e40e48c1f367e83e5d46fdc791dcb9dc2418", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEyODI1NQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1156#discussion_r372128255", "bodyText": "I changed the algorithm to no longer expand maps and updated the comment to reflect this change.", "author": "schmidt-sebastian", "createdAt": "2020-01-29T00:08:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkyODQ0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkzNjQ2Mg==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1156#discussion_r371936462", "bodyText": "Shouldn't this be a null byte ('\\0')?", "author": "wilhuff", "createdAt": "2020-01-28T17:06:55Z", "path": "firebase-firestore/src/main/java/com/google/firebase/firestore/model/protovalue/ObjectValue.java", "diffHunk": "@@ -0,0 +1,266 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.firestore.model.protovalue;\n+\n+import static com.google.firebase.firestore.model.value.ProtoValues.isType;\n+import static com.google.firebase.firestore.util.Assert.hardAssert;\n+\n+import androidx.annotation.Nullable;\n+import com.google.firebase.firestore.model.FieldPath;\n+import com.google.firebase.firestore.model.mutation.FieldMask;\n+import com.google.firebase.firestore.model.value.FieldValue;\n+import com.google.firestore.v1.MapValue;\n+import com.google.firestore.v1.Value;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+public class ObjectValue extends PrimitiveValue {\n+  private static final ObjectValue EMPTY_VALUE =\n+      new ObjectValue(\n+          com.google.firestore.v1.Value.newBuilder()\n+              .setMapValue(com.google.firestore.v1.MapValue.getDefaultInstance())\n+              .build());\n+\n+  public static ObjectValue emptyObject() {\n+    return EMPTY_VALUE;\n+  }\n+\n+  public ObjectValue(Value value) {\n+    super(value);\n+    hardAssert(isType(value, TYPE_ORDER_OBJECT), \"ObjectValues must be backed by a MapValue\");\n+  }\n+\n+  /**\n+   * Returns the value at the given path or null.\n+   *\n+   * @param fieldPath the path to search\n+   * @return The value at the path or if there it doesn't exist.\n+   */\n+  public @Nullable FieldValue get(FieldPath fieldPath) {\n+    Value value = internalValue;\n+\n+    for (int i = 0; i < fieldPath.length() - 1; ++i) {\n+      value = value.getMapValue().getFieldsOrDefault(fieldPath.getSegment(i), null);\n+      if (!isType(value, TYPE_ORDER_OBJECT)) {\n+        return null;\n+      }\n+    }\n+\n+    value = value.getMapValue().getFieldsOrDefault(fieldPath.getLastSegment(), null);\n+    return value != null ? FieldValue.of(value) : null;\n+  }\n+\n+  /** Recursively extracts the FieldPaths that are set in this ObjectValue. */\n+  public FieldMask getFieldMask() {\n+    return extractFieldMask(internalValue.getMapValue());\n+  }\n+\n+  private FieldMask extractFieldMask(MapValue value) {\n+    Set<FieldPath> fields = new HashSet<>();\n+    for (Map.Entry<String, Value> entry : value.getFieldsMap().entrySet()) {\n+      FieldPath currentPath = FieldPath.fromSingleSegment(entry.getKey());\n+      if (isType(entry.getValue(), TYPE_ORDER_OBJECT)) {\n+        FieldMask nestedMask = extractFieldMask(entry.getValue().getMapValue());\n+        Set<FieldPath> nestedFields = nestedMask.getMask();\n+        if (nestedFields.isEmpty()) {\n+          // Preserve the empty map by adding it to the FieldMask.\n+          fields.add(currentPath);\n+        } else {\n+          // For nested and non-empty ObjectValues, add the FieldPath of the leaf nodes.\n+          for (FieldPath nestedPath : nestedFields) {\n+            fields.add(currentPath.append(nestedPath));\n+          }\n+        }\n+      } else {\n+        fields.add(currentPath);\n+      }\n+    }\n+    return FieldMask.fromSet(fields);\n+  }\n+\n+  /** Creates a ObjectValue.Builder instance that is based on the current value. */\n+  public ObjectValue.Builder toBuilder() {\n+    return new Builder(this);\n+  }\n+\n+  /** An ObjectValue.Builder provides APIs to set and delete fields from an ObjectValue. */\n+  public static class Builder {\n+\n+    /** The existing data to mutate. */\n+    private ObjectValue baseObject;\n+\n+    /**\n+     * A list of FieldPath/Value pairs to apply to the base object. `null` values indicate field\n+     * deletes. MapValues are expanded before they are stored in the overlay map, so that an entry\n+     * exists for each leaf node.\n+     */\n+    private SortedMap<FieldPath, Value> overlayMap;\n+\n+    Builder(ObjectValue baseObject) {\n+      this.baseObject = baseObject;\n+      this.overlayMap = new TreeMap<>();\n+    }\n+\n+    /**\n+     * Sets the field to the provided value.\n+     *\n+     * @param path The field path to set.\n+     * @param value The value to set.\n+     * @return The current Builder instance.\n+     */\n+    public Builder set(FieldPath path, Value value) {\n+      hardAssert(!path.isEmpty(), \"Cannot set field for empty path on ObjectValue\");\n+      removeConflictingOverlays(path);\n+      setOverlay(path, value);\n+      return this;\n+    }\n+\n+    /**\n+     * Removes the field at the specified path. If there is no field at the specified path nothing\n+     * is changed.\n+     *\n+     * @param path The field path to remove\n+     * @return The current Builder instance.\n+     */\n+    public Builder delete(FieldPath path) {\n+      hardAssert(!path.isEmpty(), \"Cannot delete field for empty path on ObjectValue\");\n+      removeConflictingOverlays(path);\n+      setOverlay(path, null);\n+      return this;\n+    }\n+\n+    /** Remove any existing overlays that would be replaced by setting `path` to a new value. */\n+    private void removeConflictingOverlays(FieldPath path) {\n+      Iterator<FieldPath> iterator =\n+          overlayMap.subMap(path, createSuccessor(path)).keySet().iterator();\n+      while (iterator.hasNext()) {\n+        iterator.next();\n+        iterator.remove();\n+      }\n+    }\n+\n+    /**\n+     * Adds `value` to the overlay map at `path`. MapValues are recursively expanded into one\n+     * overlay per leaf node.\n+     */\n+    private void setOverlay(FieldPath path, @Nullable Value value) {\n+      if (!isType(value, TYPE_ORDER_OBJECT) || value.getMapValue().getFieldsCount() == 0) {\n+        overlayMap.put(path, value);\n+      } else {\n+        for (Map.Entry<String, Value> entry : value.getMapValue().getFieldsMap().entrySet()) {\n+          setOverlay(path.append(entry.getKey()), entry.getValue());\n+        }\n+      }\n+    }\n+\n+    /** Returns an ObjectValue with all mutations applied. */\n+    public ObjectValue build() {\n+      if (overlayMap.isEmpty()) {\n+        return baseObject;\n+      } else {\n+        MapValue.Builder result = baseObject.internalValue.getMapValue().toBuilder();\n+        applyOverlay(FieldPath.EMPTY_PATH, result);\n+        return new ObjectValue(Value.newBuilder().setMapValue(result).build());\n+      }\n+    }\n+\n+    /**\n+     * Applies any overlays from `overlayMap` that exist at `currentPath` to the `resultAtPath` map.\n+     * Overlays are expanded recursively based on their location in the backing ObjectValue's\n+     * subtree and are processed by nesting level.\n+     *\n+     * <p>Example: Overlays { 'a.b.c' : 'foo', 'a.b.d' : 'bar', 'a.e' : 'foobar' }\n+     *\n+     * <p>To apply these overlays, the methods first creates a MapValue.Builder for `a`. It then\n+     * calls applyOverlay() with a current path of `a` and the newly created MapValue.Builder. In\n+     * its second call, `applyOverlay` assigns `a.b` to a new MapBuilder and `a.e` to 'foobar'. The\n+     * third call assigns `a.b.c` and `a.b.d` to the MapValue.Builder created in the second step.\n+     *\n+     * <p>The overall aim of this method is to minimize conversions between MapValues and their\n+     * builders.\n+     *\n+     * @param currentPath The path at the current nesting level. Can be set toFieldValue.EMPTY_PATH\n+     *     to represent the root.\n+     * @param resultAtPath A mutable copy of the existing data at the current nesting level.\n+     *     Overlays are applied to this argument.\n+     * @return Whether any modifications were applied (in any part of the subtree under\n+     *     currentPath).\n+     */\n+    private boolean applyOverlay(FieldPath currentPath, MapValue.Builder resultAtPath) {\n+      // Extract the data that exists at or below the current path. Te extracted subtree is\n+      // subdivided during each iteration. The iteration stops when the slice becomes empty.\n+      SortedMap<FieldPath, Value> currentSlice =\n+          currentPath.isEmpty()\n+              ? overlayMap\n+              : overlayMap.subMap(currentPath, createSuccessor(currentPath));\n+\n+      boolean modified = false;\n+\n+      while (!currentSlice.isEmpty()) {\n+        FieldPath fieldPath = currentSlice.firstKey();\n+\n+        if (fieldPath.length() == currentPath.length() + 1) {\n+          // The key in the slice is a leaf node. We can apply the value directly.\n+          String fieldName = fieldPath.getLastSegment();\n+          Value overlayValue = overlayMap.get(fieldPath);\n+          if (overlayValue != null) {\n+            resultAtPath.putFields(fieldName, overlayValue);\n+            modified = true;\n+          } else if (resultAtPath.containsFields(fieldName)) {\n+            resultAtPath.removeFields(fieldName);\n+            modified = true;\n+          }\n+        } else {\n+          // Since we need a MapValue.Builder at each nesting level (e.g. to create the field for\n+          // `a.b.c` we need to create a MapValue.Builder for `a` as well as `a.b`), we invoke\n+          // applyOverlay() recursively with the next nesting level.\n+          FieldPath nextSliceStart = fieldPath.keepFirst(currentPath.length() + 1);\n+          @Nullable FieldValue existingValue = baseObject.get(nextSliceStart);\n+          MapValue.Builder nextSliceBuilder =\n+              existingValue instanceof ObjectValue\n+                  // If there is already data at the current path, base our modifications on top\n+                  // of the existing data.\n+                  ? ((ObjectValue) existingValue).internalValue.getMapValue().toBuilder()\n+                  : MapValue.newBuilder();\n+          modified = applyOverlay(nextSliceStart, nextSliceBuilder) || modified;\n+          if (modified) {\n+            // Only apply the result if a field has been modified. This avoids adding an empty\n+            // map entry for deletes of non-existing fields.\n+            resultAtPath.putFields(\n+                nextSliceStart.getLastSegment(),\n+                Value.newBuilder().setMapValue(nextSliceBuilder).build());\n+          }\n+        }\n+\n+        // Shrink the subtree to contain only values after the current field path. Note that we are\n+        // still bound by the subtree created at the initial method invocation. The current loop\n+        // exits when the subtree becomes empty.\n+        currentSlice = currentSlice.tailMap(createSuccessor(fieldPath));\n+      }\n+\n+      return modified;\n+    }\n+\n+    /** Create the first field path that is not part of the subtree created by `currentPath`. */\n+    private FieldPath createSuccessor(FieldPath currentPath) {\n+      hardAssert(!currentPath.isEmpty(), \"Can't create a successor for an empty path\");\n+      return currentPath.popLast().append(currentPath.getLastSegment() + '0');", "originalCommit": "7bf5e40e48c1f367e83e5d46fdc791dcb9dc2418", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEzMTc1Nw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1156#discussion_r372131757", "bodyText": "This is also no longer needed (yay for simpler code).\nI chose '0' because it is the first ASCII code that can be part of a valid field path. '\\0' may trigger validation errors in our field value handling.", "author": "schmidt-sebastian", "createdAt": "2020-01-29T00:22:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkzNjQ2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk0MDAwMA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1156#discussion_r371940000", "bodyText": "This method is quite complex and pretty hard to follow. You could extract a few methods here that would make this clearer. For example, you could extract a applyOverlayLeaf(String, @Nullable Value) which would pull lines 219 through 228 out.\nYou might also consider pulling some part of 230 through 240 out into a existingMapValueBuilder(FieldPath) or similar.", "author": "wilhuff", "createdAt": "2020-01-28T17:12:54Z", "path": "firebase-firestore/src/main/java/com/google/firebase/firestore/model/protovalue/ObjectValue.java", "diffHunk": "@@ -0,0 +1,266 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.firestore.model.protovalue;\n+\n+import static com.google.firebase.firestore.model.value.ProtoValues.isType;\n+import static com.google.firebase.firestore.util.Assert.hardAssert;\n+\n+import androidx.annotation.Nullable;\n+import com.google.firebase.firestore.model.FieldPath;\n+import com.google.firebase.firestore.model.mutation.FieldMask;\n+import com.google.firebase.firestore.model.value.FieldValue;\n+import com.google.firestore.v1.MapValue;\n+import com.google.firestore.v1.Value;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+public class ObjectValue extends PrimitiveValue {\n+  private static final ObjectValue EMPTY_VALUE =\n+      new ObjectValue(\n+          com.google.firestore.v1.Value.newBuilder()\n+              .setMapValue(com.google.firestore.v1.MapValue.getDefaultInstance())\n+              .build());\n+\n+  public static ObjectValue emptyObject() {\n+    return EMPTY_VALUE;\n+  }\n+\n+  public ObjectValue(Value value) {\n+    super(value);\n+    hardAssert(isType(value, TYPE_ORDER_OBJECT), \"ObjectValues must be backed by a MapValue\");\n+  }\n+\n+  /**\n+   * Returns the value at the given path or null.\n+   *\n+   * @param fieldPath the path to search\n+   * @return The value at the path or if there it doesn't exist.\n+   */\n+  public @Nullable FieldValue get(FieldPath fieldPath) {\n+    Value value = internalValue;\n+\n+    for (int i = 0; i < fieldPath.length() - 1; ++i) {\n+      value = value.getMapValue().getFieldsOrDefault(fieldPath.getSegment(i), null);\n+      if (!isType(value, TYPE_ORDER_OBJECT)) {\n+        return null;\n+      }\n+    }\n+\n+    value = value.getMapValue().getFieldsOrDefault(fieldPath.getLastSegment(), null);\n+    return value != null ? FieldValue.of(value) : null;\n+  }\n+\n+  /** Recursively extracts the FieldPaths that are set in this ObjectValue. */\n+  public FieldMask getFieldMask() {\n+    return extractFieldMask(internalValue.getMapValue());\n+  }\n+\n+  private FieldMask extractFieldMask(MapValue value) {\n+    Set<FieldPath> fields = new HashSet<>();\n+    for (Map.Entry<String, Value> entry : value.getFieldsMap().entrySet()) {\n+      FieldPath currentPath = FieldPath.fromSingleSegment(entry.getKey());\n+      if (isType(entry.getValue(), TYPE_ORDER_OBJECT)) {\n+        FieldMask nestedMask = extractFieldMask(entry.getValue().getMapValue());\n+        Set<FieldPath> nestedFields = nestedMask.getMask();\n+        if (nestedFields.isEmpty()) {\n+          // Preserve the empty map by adding it to the FieldMask.\n+          fields.add(currentPath);\n+        } else {\n+          // For nested and non-empty ObjectValues, add the FieldPath of the leaf nodes.\n+          for (FieldPath nestedPath : nestedFields) {\n+            fields.add(currentPath.append(nestedPath));\n+          }\n+        }\n+      } else {\n+        fields.add(currentPath);\n+      }\n+    }\n+    return FieldMask.fromSet(fields);\n+  }\n+\n+  /** Creates a ObjectValue.Builder instance that is based on the current value. */\n+  public ObjectValue.Builder toBuilder() {\n+    return new Builder(this);\n+  }\n+\n+  /** An ObjectValue.Builder provides APIs to set and delete fields from an ObjectValue. */\n+  public static class Builder {\n+\n+    /** The existing data to mutate. */\n+    private ObjectValue baseObject;\n+\n+    /**\n+     * A list of FieldPath/Value pairs to apply to the base object. `null` values indicate field\n+     * deletes. MapValues are expanded before they are stored in the overlay map, so that an entry\n+     * exists for each leaf node.\n+     */\n+    private SortedMap<FieldPath, Value> overlayMap;\n+\n+    Builder(ObjectValue baseObject) {\n+      this.baseObject = baseObject;\n+      this.overlayMap = new TreeMap<>();\n+    }\n+\n+    /**\n+     * Sets the field to the provided value.\n+     *\n+     * @param path The field path to set.\n+     * @param value The value to set.\n+     * @return The current Builder instance.\n+     */\n+    public Builder set(FieldPath path, Value value) {\n+      hardAssert(!path.isEmpty(), \"Cannot set field for empty path on ObjectValue\");\n+      removeConflictingOverlays(path);\n+      setOverlay(path, value);\n+      return this;\n+    }\n+\n+    /**\n+     * Removes the field at the specified path. If there is no field at the specified path nothing\n+     * is changed.\n+     *\n+     * @param path The field path to remove\n+     * @return The current Builder instance.\n+     */\n+    public Builder delete(FieldPath path) {\n+      hardAssert(!path.isEmpty(), \"Cannot delete field for empty path on ObjectValue\");\n+      removeConflictingOverlays(path);\n+      setOverlay(path, null);\n+      return this;\n+    }\n+\n+    /** Remove any existing overlays that would be replaced by setting `path` to a new value. */\n+    private void removeConflictingOverlays(FieldPath path) {\n+      Iterator<FieldPath> iterator =\n+          overlayMap.subMap(path, createSuccessor(path)).keySet().iterator();\n+      while (iterator.hasNext()) {\n+        iterator.next();\n+        iterator.remove();\n+      }\n+    }\n+\n+    /**\n+     * Adds `value` to the overlay map at `path`. MapValues are recursively expanded into one\n+     * overlay per leaf node.\n+     */\n+    private void setOverlay(FieldPath path, @Nullable Value value) {\n+      if (!isType(value, TYPE_ORDER_OBJECT) || value.getMapValue().getFieldsCount() == 0) {\n+        overlayMap.put(path, value);\n+      } else {\n+        for (Map.Entry<String, Value> entry : value.getMapValue().getFieldsMap().entrySet()) {\n+          setOverlay(path.append(entry.getKey()), entry.getValue());\n+        }\n+      }\n+    }\n+\n+    /** Returns an ObjectValue with all mutations applied. */\n+    public ObjectValue build() {\n+      if (overlayMap.isEmpty()) {\n+        return baseObject;\n+      } else {\n+        MapValue.Builder result = baseObject.internalValue.getMapValue().toBuilder();\n+        applyOverlay(FieldPath.EMPTY_PATH, result);\n+        return new ObjectValue(Value.newBuilder().setMapValue(result).build());\n+      }\n+    }\n+\n+    /**\n+     * Applies any overlays from `overlayMap` that exist at `currentPath` to the `resultAtPath` map.\n+     * Overlays are expanded recursively based on their location in the backing ObjectValue's\n+     * subtree and are processed by nesting level.\n+     *\n+     * <p>Example: Overlays { 'a.b.c' : 'foo', 'a.b.d' : 'bar', 'a.e' : 'foobar' }\n+     *\n+     * <p>To apply these overlays, the methods first creates a MapValue.Builder for `a`. It then\n+     * calls applyOverlay() with a current path of `a` and the newly created MapValue.Builder. In\n+     * its second call, `applyOverlay` assigns `a.b` to a new MapBuilder and `a.e` to 'foobar'. The\n+     * third call assigns `a.b.c` and `a.b.d` to the MapValue.Builder created in the second step.\n+     *\n+     * <p>The overall aim of this method is to minimize conversions between MapValues and their\n+     * builders.\n+     *\n+     * @param currentPath The path at the current nesting level. Can be set toFieldValue.EMPTY_PATH\n+     *     to represent the root.\n+     * @param resultAtPath A mutable copy of the existing data at the current nesting level.\n+     *     Overlays are applied to this argument.\n+     * @return Whether any modifications were applied (in any part of the subtree under\n+     *     currentPath).\n+     */\n+    private boolean applyOverlay(FieldPath currentPath, MapValue.Builder resultAtPath) {", "originalCommit": "7bf5e40e48c1f367e83e5d46fdc791dcb9dc2418", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEyOTY2Nw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1156#discussion_r372129667", "bodyText": "I believe this was close to impossible to follow, but it was the cleanest design I could come up with given the data structure I chose. I have now chosen a different data structure for the overlap map, which allowed me to drastically simplify the code.", "author": "schmidt-sebastian", "createdAt": "2020-01-29T00:14:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk0MDAwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk0MTI3MQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1156#discussion_r371941271", "bodyText": "Why not just remove fieldPath?", "author": "wilhuff", "createdAt": "2020-01-28T17:15:09Z", "path": "firebase-firestore/src/main/java/com/google/firebase/firestore/model/protovalue/ObjectValue.java", "diffHunk": "@@ -0,0 +1,266 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.firestore.model.protovalue;\n+\n+import static com.google.firebase.firestore.model.value.ProtoValues.isType;\n+import static com.google.firebase.firestore.util.Assert.hardAssert;\n+\n+import androidx.annotation.Nullable;\n+import com.google.firebase.firestore.model.FieldPath;\n+import com.google.firebase.firestore.model.mutation.FieldMask;\n+import com.google.firebase.firestore.model.value.FieldValue;\n+import com.google.firestore.v1.MapValue;\n+import com.google.firestore.v1.Value;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+public class ObjectValue extends PrimitiveValue {\n+  private static final ObjectValue EMPTY_VALUE =\n+      new ObjectValue(\n+          com.google.firestore.v1.Value.newBuilder()\n+              .setMapValue(com.google.firestore.v1.MapValue.getDefaultInstance())\n+              .build());\n+\n+  public static ObjectValue emptyObject() {\n+    return EMPTY_VALUE;\n+  }\n+\n+  public ObjectValue(Value value) {\n+    super(value);\n+    hardAssert(isType(value, TYPE_ORDER_OBJECT), \"ObjectValues must be backed by a MapValue\");\n+  }\n+\n+  /**\n+   * Returns the value at the given path or null.\n+   *\n+   * @param fieldPath the path to search\n+   * @return The value at the path or if there it doesn't exist.\n+   */\n+  public @Nullable FieldValue get(FieldPath fieldPath) {\n+    Value value = internalValue;\n+\n+    for (int i = 0; i < fieldPath.length() - 1; ++i) {\n+      value = value.getMapValue().getFieldsOrDefault(fieldPath.getSegment(i), null);\n+      if (!isType(value, TYPE_ORDER_OBJECT)) {\n+        return null;\n+      }\n+    }\n+\n+    value = value.getMapValue().getFieldsOrDefault(fieldPath.getLastSegment(), null);\n+    return value != null ? FieldValue.of(value) : null;\n+  }\n+\n+  /** Recursively extracts the FieldPaths that are set in this ObjectValue. */\n+  public FieldMask getFieldMask() {\n+    return extractFieldMask(internalValue.getMapValue());\n+  }\n+\n+  private FieldMask extractFieldMask(MapValue value) {\n+    Set<FieldPath> fields = new HashSet<>();\n+    for (Map.Entry<String, Value> entry : value.getFieldsMap().entrySet()) {\n+      FieldPath currentPath = FieldPath.fromSingleSegment(entry.getKey());\n+      if (isType(entry.getValue(), TYPE_ORDER_OBJECT)) {\n+        FieldMask nestedMask = extractFieldMask(entry.getValue().getMapValue());\n+        Set<FieldPath> nestedFields = nestedMask.getMask();\n+        if (nestedFields.isEmpty()) {\n+          // Preserve the empty map by adding it to the FieldMask.\n+          fields.add(currentPath);\n+        } else {\n+          // For nested and non-empty ObjectValues, add the FieldPath of the leaf nodes.\n+          for (FieldPath nestedPath : nestedFields) {\n+            fields.add(currentPath.append(nestedPath));\n+          }\n+        }\n+      } else {\n+        fields.add(currentPath);\n+      }\n+    }\n+    return FieldMask.fromSet(fields);\n+  }\n+\n+  /** Creates a ObjectValue.Builder instance that is based on the current value. */\n+  public ObjectValue.Builder toBuilder() {\n+    return new Builder(this);\n+  }\n+\n+  /** An ObjectValue.Builder provides APIs to set and delete fields from an ObjectValue. */\n+  public static class Builder {\n+\n+    /** The existing data to mutate. */\n+    private ObjectValue baseObject;\n+\n+    /**\n+     * A list of FieldPath/Value pairs to apply to the base object. `null` values indicate field\n+     * deletes. MapValues are expanded before they are stored in the overlay map, so that an entry\n+     * exists for each leaf node.\n+     */\n+    private SortedMap<FieldPath, Value> overlayMap;\n+\n+    Builder(ObjectValue baseObject) {\n+      this.baseObject = baseObject;\n+      this.overlayMap = new TreeMap<>();\n+    }\n+\n+    /**\n+     * Sets the field to the provided value.\n+     *\n+     * @param path The field path to set.\n+     * @param value The value to set.\n+     * @return The current Builder instance.\n+     */\n+    public Builder set(FieldPath path, Value value) {\n+      hardAssert(!path.isEmpty(), \"Cannot set field for empty path on ObjectValue\");\n+      removeConflictingOverlays(path);\n+      setOverlay(path, value);\n+      return this;\n+    }\n+\n+    /**\n+     * Removes the field at the specified path. If there is no field at the specified path nothing\n+     * is changed.\n+     *\n+     * @param path The field path to remove\n+     * @return The current Builder instance.\n+     */\n+    public Builder delete(FieldPath path) {\n+      hardAssert(!path.isEmpty(), \"Cannot delete field for empty path on ObjectValue\");\n+      removeConflictingOverlays(path);\n+      setOverlay(path, null);\n+      return this;\n+    }\n+\n+    /** Remove any existing overlays that would be replaced by setting `path` to a new value. */\n+    private void removeConflictingOverlays(FieldPath path) {\n+      Iterator<FieldPath> iterator =\n+          overlayMap.subMap(path, createSuccessor(path)).keySet().iterator();\n+      while (iterator.hasNext()) {\n+        iterator.next();\n+        iterator.remove();\n+      }\n+    }\n+\n+    /**\n+     * Adds `value` to the overlay map at `path`. MapValues are recursively expanded into one\n+     * overlay per leaf node.\n+     */\n+    private void setOverlay(FieldPath path, @Nullable Value value) {\n+      if (!isType(value, TYPE_ORDER_OBJECT) || value.getMapValue().getFieldsCount() == 0) {\n+        overlayMap.put(path, value);\n+      } else {\n+        for (Map.Entry<String, Value> entry : value.getMapValue().getFieldsMap().entrySet()) {\n+          setOverlay(path.append(entry.getKey()), entry.getValue());\n+        }\n+      }\n+    }\n+\n+    /** Returns an ObjectValue with all mutations applied. */\n+    public ObjectValue build() {\n+      if (overlayMap.isEmpty()) {\n+        return baseObject;\n+      } else {\n+        MapValue.Builder result = baseObject.internalValue.getMapValue().toBuilder();\n+        applyOverlay(FieldPath.EMPTY_PATH, result);\n+        return new ObjectValue(Value.newBuilder().setMapValue(result).build());\n+      }\n+    }\n+\n+    /**\n+     * Applies any overlays from `overlayMap` that exist at `currentPath` to the `resultAtPath` map.\n+     * Overlays are expanded recursively based on their location in the backing ObjectValue's\n+     * subtree and are processed by nesting level.\n+     *\n+     * <p>Example: Overlays { 'a.b.c' : 'foo', 'a.b.d' : 'bar', 'a.e' : 'foobar' }\n+     *\n+     * <p>To apply these overlays, the methods first creates a MapValue.Builder for `a`. It then\n+     * calls applyOverlay() with a current path of `a` and the newly created MapValue.Builder. In\n+     * its second call, `applyOverlay` assigns `a.b` to a new MapBuilder and `a.e` to 'foobar'. The\n+     * third call assigns `a.b.c` and `a.b.d` to the MapValue.Builder created in the second step.\n+     *\n+     * <p>The overall aim of this method is to minimize conversions between MapValues and their\n+     * builders.\n+     *\n+     * @param currentPath The path at the current nesting level. Can be set toFieldValue.EMPTY_PATH\n+     *     to represent the root.\n+     * @param resultAtPath A mutable copy of the existing data at the current nesting level.\n+     *     Overlays are applied to this argument.\n+     * @return Whether any modifications were applied (in any part of the subtree under\n+     *     currentPath).\n+     */\n+    private boolean applyOverlay(FieldPath currentPath, MapValue.Builder resultAtPath) {\n+      // Extract the data that exists at or below the current path. Te extracted subtree is\n+      // subdivided during each iteration. The iteration stops when the slice becomes empty.\n+      SortedMap<FieldPath, Value> currentSlice =\n+          currentPath.isEmpty()\n+              ? overlayMap\n+              : overlayMap.subMap(currentPath, createSuccessor(currentPath));\n+\n+      boolean modified = false;\n+\n+      while (!currentSlice.isEmpty()) {\n+        FieldPath fieldPath = currentSlice.firstKey();\n+\n+        if (fieldPath.length() == currentPath.length() + 1) {\n+          // The key in the slice is a leaf node. We can apply the value directly.\n+          String fieldName = fieldPath.getLastSegment();\n+          Value overlayValue = overlayMap.get(fieldPath);\n+          if (overlayValue != null) {\n+            resultAtPath.putFields(fieldName, overlayValue);\n+            modified = true;\n+          } else if (resultAtPath.containsFields(fieldName)) {\n+            resultAtPath.removeFields(fieldName);\n+            modified = true;\n+          }\n+        } else {\n+          // Since we need a MapValue.Builder at each nesting level (e.g. to create the field for\n+          // `a.b.c` we need to create a MapValue.Builder for `a` as well as `a.b`), we invoke\n+          // applyOverlay() recursively with the next nesting level.\n+          FieldPath nextSliceStart = fieldPath.keepFirst(currentPath.length() + 1);\n+          @Nullable FieldValue existingValue = baseObject.get(nextSliceStart);\n+          MapValue.Builder nextSliceBuilder =\n+              existingValue instanceof ObjectValue\n+                  // If there is already data at the current path, base our modifications on top\n+                  // of the existing data.\n+                  ? ((ObjectValue) existingValue).internalValue.getMapValue().toBuilder()\n+                  : MapValue.newBuilder();\n+          modified = applyOverlay(nextSliceStart, nextSliceBuilder) || modified;\n+          if (modified) {\n+            // Only apply the result if a field has been modified. This avoids adding an empty\n+            // map entry for deletes of non-existing fields.\n+            resultAtPath.putFields(\n+                nextSliceStart.getLastSegment(),\n+                Value.newBuilder().setMapValue(nextSliceBuilder).build());\n+          }\n+        }\n+\n+        // Shrink the subtree to contain only values after the current field path. Note that we are\n+        // still bound by the subtree created at the initial method invocation. The current loop\n+        // exits when the subtree becomes empty.\n+        currentSlice = currentSlice.tailMap(createSuccessor(fieldPath));", "originalCommit": "7bf5e40e48c1f367e83e5d46fdc791dcb9dc2418", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEzMTQzMA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1156#discussion_r372131430", "bodyText": "This is no longer part of the PR, but a remove here would make this method non-idempotent and might incur additional tree re-balancing.", "author": "schmidt-sebastian", "createdAt": "2020-01-29T00:20:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk0MTI3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk1ODA5NA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1156#discussion_r371958094", "bodyText": "High level comment: this representation of SortedMap<FieldPath, Value> creates some non-trivial complexity because you need to use subMaps and tailMaps based on successors to simulate non-leaf maps.\nThere's also the issue that patching in a sub-object explodes it into leaf values which is pretty pessimistic. In the common case mutation queues for any given document are not deep, this seems like it could be a waste.\nHave you considered a HashMap of segment to object, similar to the way the baseObject is stored, except mutable? With that approach you could put MapValues in directly and then only explode them along the update path if there's a nested update.\nThe major benefit of that approach is that applyOverlay can now just be a simple loop through the immediate children at the current level in the object. In the common case where successive updates aren't nested, the MapValue of the update could be used directly without exploding it.\nAnother benefit is that exploding a level in the tree is just O(n), where the tree-based implementation is O(n lg(n)).", "author": "wilhuff", "createdAt": "2020-01-28T17:46:58Z", "path": "firebase-firestore/src/main/java/com/google/firebase/firestore/model/protovalue/ObjectValue.java", "diffHunk": "@@ -0,0 +1,266 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.firestore.model.protovalue;\n+\n+import static com.google.firebase.firestore.model.value.ProtoValues.isType;\n+import static com.google.firebase.firestore.util.Assert.hardAssert;\n+\n+import androidx.annotation.Nullable;\n+import com.google.firebase.firestore.model.FieldPath;\n+import com.google.firebase.firestore.model.mutation.FieldMask;\n+import com.google.firebase.firestore.model.value.FieldValue;\n+import com.google.firestore.v1.MapValue;\n+import com.google.firestore.v1.Value;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+public class ObjectValue extends PrimitiveValue {\n+  private static final ObjectValue EMPTY_VALUE =\n+      new ObjectValue(\n+          com.google.firestore.v1.Value.newBuilder()\n+              .setMapValue(com.google.firestore.v1.MapValue.getDefaultInstance())\n+              .build());\n+\n+  public static ObjectValue emptyObject() {\n+    return EMPTY_VALUE;\n+  }\n+\n+  public ObjectValue(Value value) {\n+    super(value);\n+    hardAssert(isType(value, TYPE_ORDER_OBJECT), \"ObjectValues must be backed by a MapValue\");\n+  }\n+\n+  /**\n+   * Returns the value at the given path or null.\n+   *\n+   * @param fieldPath the path to search\n+   * @return The value at the path or if there it doesn't exist.\n+   */\n+  public @Nullable FieldValue get(FieldPath fieldPath) {\n+    Value value = internalValue;\n+\n+    for (int i = 0; i < fieldPath.length() - 1; ++i) {\n+      value = value.getMapValue().getFieldsOrDefault(fieldPath.getSegment(i), null);\n+      if (!isType(value, TYPE_ORDER_OBJECT)) {\n+        return null;\n+      }\n+    }\n+\n+    value = value.getMapValue().getFieldsOrDefault(fieldPath.getLastSegment(), null);\n+    return value != null ? FieldValue.of(value) : null;\n+  }\n+\n+  /** Recursively extracts the FieldPaths that are set in this ObjectValue. */\n+  public FieldMask getFieldMask() {\n+    return extractFieldMask(internalValue.getMapValue());\n+  }\n+\n+  private FieldMask extractFieldMask(MapValue value) {\n+    Set<FieldPath> fields = new HashSet<>();\n+    for (Map.Entry<String, Value> entry : value.getFieldsMap().entrySet()) {\n+      FieldPath currentPath = FieldPath.fromSingleSegment(entry.getKey());\n+      if (isType(entry.getValue(), TYPE_ORDER_OBJECT)) {\n+        FieldMask nestedMask = extractFieldMask(entry.getValue().getMapValue());\n+        Set<FieldPath> nestedFields = nestedMask.getMask();\n+        if (nestedFields.isEmpty()) {\n+          // Preserve the empty map by adding it to the FieldMask.\n+          fields.add(currentPath);\n+        } else {\n+          // For nested and non-empty ObjectValues, add the FieldPath of the leaf nodes.\n+          for (FieldPath nestedPath : nestedFields) {\n+            fields.add(currentPath.append(nestedPath));\n+          }\n+        }\n+      } else {\n+        fields.add(currentPath);\n+      }\n+    }\n+    return FieldMask.fromSet(fields);\n+  }\n+\n+  /** Creates a ObjectValue.Builder instance that is based on the current value. */\n+  public ObjectValue.Builder toBuilder() {\n+    return new Builder(this);\n+  }\n+\n+  /** An ObjectValue.Builder provides APIs to set and delete fields from an ObjectValue. */\n+  public static class Builder {\n+\n+    /** The existing data to mutate. */\n+    private ObjectValue baseObject;\n+\n+    /**\n+     * A list of FieldPath/Value pairs to apply to the base object. `null` values indicate field\n+     * deletes. MapValues are expanded before they are stored in the overlay map, so that an entry\n+     * exists for each leaf node.\n+     */\n+    private SortedMap<FieldPath, Value> overlayMap;\n+\n+    Builder(ObjectValue baseObject) {\n+      this.baseObject = baseObject;\n+      this.overlayMap = new TreeMap<>();\n+    }\n+\n+    /**\n+     * Sets the field to the provided value.\n+     *\n+     * @param path The field path to set.\n+     * @param value The value to set.\n+     * @return The current Builder instance.\n+     */\n+    public Builder set(FieldPath path, Value value) {\n+      hardAssert(!path.isEmpty(), \"Cannot set field for empty path on ObjectValue\");\n+      removeConflictingOverlays(path);\n+      setOverlay(path, value);\n+      return this;\n+    }\n+\n+    /**\n+     * Removes the field at the specified path. If there is no field at the specified path nothing\n+     * is changed.\n+     *\n+     * @param path The field path to remove\n+     * @return The current Builder instance.\n+     */\n+    public Builder delete(FieldPath path) {\n+      hardAssert(!path.isEmpty(), \"Cannot delete field for empty path on ObjectValue\");\n+      removeConflictingOverlays(path);\n+      setOverlay(path, null);\n+      return this;\n+    }\n+\n+    /** Remove any existing overlays that would be replaced by setting `path` to a new value. */\n+    private void removeConflictingOverlays(FieldPath path) {\n+      Iterator<FieldPath> iterator =\n+          overlayMap.subMap(path, createSuccessor(path)).keySet().iterator();\n+      while (iterator.hasNext()) {\n+        iterator.next();\n+        iterator.remove();\n+      }\n+    }\n+\n+    /**\n+     * Adds `value` to the overlay map at `path`. MapValues are recursively expanded into one\n+     * overlay per leaf node.\n+     */\n+    private void setOverlay(FieldPath path, @Nullable Value value) {\n+      if (!isType(value, TYPE_ORDER_OBJECT) || value.getMapValue().getFieldsCount() == 0) {\n+        overlayMap.put(path, value);\n+      } else {\n+        for (Map.Entry<String, Value> entry : value.getMapValue().getFieldsMap().entrySet()) {\n+          setOverlay(path.append(entry.getKey()), entry.getValue());\n+        }\n+      }\n+    }\n+\n+    /** Returns an ObjectValue with all mutations applied. */\n+    public ObjectValue build() {\n+      if (overlayMap.isEmpty()) {\n+        return baseObject;\n+      } else {\n+        MapValue.Builder result = baseObject.internalValue.getMapValue().toBuilder();\n+        applyOverlay(FieldPath.EMPTY_PATH, result);\n+        return new ObjectValue(Value.newBuilder().setMapValue(result).build());\n+      }\n+    }\n+\n+    /**\n+     * Applies any overlays from `overlayMap` that exist at `currentPath` to the `resultAtPath` map.\n+     * Overlays are expanded recursively based on their location in the backing ObjectValue's\n+     * subtree and are processed by nesting level.\n+     *\n+     * <p>Example: Overlays { 'a.b.c' : 'foo', 'a.b.d' : 'bar', 'a.e' : 'foobar' }\n+     *\n+     * <p>To apply these overlays, the methods first creates a MapValue.Builder for `a`. It then\n+     * calls applyOverlay() with a current path of `a` and the newly created MapValue.Builder. In\n+     * its second call, `applyOverlay` assigns `a.b` to a new MapBuilder and `a.e` to 'foobar'. The\n+     * third call assigns `a.b.c` and `a.b.d` to the MapValue.Builder created in the second step.\n+     *\n+     * <p>The overall aim of this method is to minimize conversions between MapValues and their\n+     * builders.\n+     *\n+     * @param currentPath The path at the current nesting level. Can be set toFieldValue.EMPTY_PATH\n+     *     to represent the root.\n+     * @param resultAtPath A mutable copy of the existing data at the current nesting level.\n+     *     Overlays are applied to this argument.\n+     * @return Whether any modifications were applied (in any part of the subtree under\n+     *     currentPath).\n+     */\n+    private boolean applyOverlay(FieldPath currentPath, MapValue.Builder resultAtPath) {\n+      // Extract the data that exists at or below the current path. Te extracted subtree is\n+      // subdivided during each iteration. The iteration stops when the slice becomes empty.\n+      SortedMap<FieldPath, Value> currentSlice =\n+          currentPath.isEmpty()\n+              ? overlayMap\n+              : overlayMap.subMap(currentPath, createSuccessor(currentPath));\n+\n+      boolean modified = false;\n+\n+      while (!currentSlice.isEmpty()) {", "originalCommit": "7bf5e40e48c1f367e83e5d46fdc791dcb9dc2418", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEzMDg2MQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1156#discussion_r372130861", "bodyText": "I mainly used the TreeMap representation because it allowed me to store a <FieldPath, Value> map, which is more typesafe than any nested data structure I could come up with. If I trade type safety for readable code, the end result looks pretty much like you suggested. I am now storing the overlays in a <String, Object> map, where the key represents a single field segment and the value represents either:\n\nA Value proto for a leaf node (this includes MapValues that were set as part of a single user operation)\nA Map<String, Value> value that indicates additional nesting\nnull to indicate field removals\n\nThis drastically simplifies the code  and reduce the runtime of applyOverlay()  to  O(n * m) (where n is the number of entries and m the nesting level). I believe before it was O(n log n * m).", "author": "schmidt-sebastian", "createdAt": "2020-01-29T00:18:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk1ODA5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk2MTAwOA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1156#discussion_r371961008", "bodyText": "Nearly all of the entries in here now seem axiomatic. Previously by forcing these groups to be constructed differently we were also verifying that wrap was behaving sanely.\nCould we employ Values.valueOf for the right hand sides? Something like wrap(valueOf(false))?", "author": "wilhuff", "createdAt": "2020-01-28T17:52:40Z", "path": "firebase-firestore/src/test/java/com/google/firebase/firestore/model/FieldValueTest.java", "diffHunk": "@@ -233,46 +223,45 @@ public void testDeletesMultipleNewFields() {\n   @Test\n   public void testValueEquality() {\n     new EqualsTester()\n-        .addEqualityGroup(wrap(true), BooleanValue.valueOf(true))\n-        .addEqualityGroup(wrap(false), BooleanValue.valueOf(false))\n-        .addEqualityGroup(wrap(null), NullValue.nullValue())\n+        .addEqualityGroup(wrap(true), wrap(true))", "originalCommit": "7bf5e40e48c1f367e83e5d46fdc791dcb9dc2418", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEzMzQ2MA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1156#discussion_r372133460", "bodyText": "The test verifies that the equality works across different instances of the same object.  Since I agree that wrap(valueOf(false)) is more visually pleasing (and makes the test's purpose less questionable), I employed your suggestion.", "author": "schmidt-sebastian", "createdAt": "2020-01-29T00:28:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk2MTAwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk2MTc4OA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1156#discussion_r371961788", "bodyText": "The map argument seems wrong here given that you're casting to PrimitiveValue.", "author": "wilhuff", "createdAt": "2020-01-28T17:54:11Z", "path": "firebase-firestore/src/test/java/com/google/firebase/firestore/model/FieldValueTest.java", "diffHunk": "@@ -367,19 +356,38 @@ public void testValueOrdering() {\n         .addEqualityGroup(wrap(Arrays.asList(\"foo\", \"0\")))\n \n         // objects\n-        .addEqualityGroup(wrapObject(map(\"bar\", 0)))\n-        .addEqualityGroup(wrapObject(map(\"bar\", 0, \"foo\", 1)))\n-        .addEqualityGroup(wrapObject(map(\"foo\", 1)))\n-        .addEqualityGroup(wrapObject(map(\"foo\", 2)))\n-        .addEqualityGroup(wrapObject(map(\"foo\", \"0\")))\n+        .addEqualityGroup(wrapObject(\"bar\", 0))\n+        .addEqualityGroup(wrapObject(\"bar\", 0, \"foo\", 1))\n+        .addEqualityGroup(wrapObject(\"foo\", 1))\n+        .addEqualityGroup(wrapObject(\"foo\", 2))\n+        .addEqualityGroup(wrapObject(\"foo\", \"0\"))\n         .testCompare();\n   }\n \n-  private ObjectValue setField(ObjectValue objectValue, String fieldPath, FieldValue value) {\n+  private ObjectValue setField(ObjectValue objectValue, String fieldPath, PrimitiveValue value) {\n+    return objectValue.toBuilder().set(field(fieldPath), value.toProto()).build();\n+  }\n+\n+  private ObjectValue setField(ObjectValue objectValue, String fieldPath, Value value) {\n     return objectValue.toBuilder().set(field(fieldPath), value).build();\n   }\n \n   private ObjectValue deleteField(ObjectValue objectValue, String fieldPath) {\n     return objectValue.toBuilder().delete(field(fieldPath)).build();\n   }\n+\n+  // TODO(mrschmidt): Clean up the helpers and merge wrap() with TestUtil.wrap()\n+  private ObjectValue wrapObject(Object... entries) {\n+    FieldValue object = FieldValue.of(map(entries));\n+    assertTrue(object instanceof ObjectValue);\n+    return (ObjectValue) object;\n+  }\n+\n+  private PrimitiveValue wrap(Object map) {", "originalCommit": "7bf5e40e48c1f367e83e5d46fdc791dcb9dc2418", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEzMzY0MA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1156#discussion_r372133640", "bodyText": "Changed to value.", "author": "schmidt-sebastian", "createdAt": "2020-01-29T00:29:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk2MTc4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk2Mjg5NQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1156#discussion_r371962895", "bodyText": "Is this test verifying that wrapObject with no parameters results in an empty object?\nIt seems like this should really be assertEquals(ObjectValue.emptyObject(), object).", "author": "wilhuff", "createdAt": "2020-01-28T17:56:15Z", "path": "firebase-firestore/src/test/java/com/google/firebase/firestore/model/ObjectValueBuilderTest.java", "diffHunk": "@@ -0,0 +1,228 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.firestore.model;\n+\n+import static com.google.firebase.firestore.Values.map;\n+import static com.google.firebase.firestore.Values.valueOf;\n+import static com.google.firebase.firestore.testutil.TestUtil.field;\n+import static junit.framework.TestCase.assertEquals;\n+import static junit.framework.TestCase.assertTrue;\n+\n+import com.google.firebase.firestore.model.protovalue.ObjectValue;\n+import com.google.firebase.firestore.model.value.FieldValue;\n+import com.google.firestore.v1.Value;\n+import java.util.Collections;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.annotation.Config;\n+\n+@RunWith(RobolectricTestRunner.class)\n+@Config(manifest = Config.NONE)\n+public class ObjectValueBuilderTest {\n+  private Value fooValue = valueOf(\"foo\");\n+  private Value barValue = valueOf(\"bar\");\n+  private Value emptyObject = valueOf(Collections.emptyMap());\n+\n+  @Test\n+  public void emptyBuilder() {\n+    ObjectValue.Builder builder = ObjectValue.emptyObject().toBuilder();\n+    ObjectValue object = builder.build();\n+    assertEquals(wrapObject(), object);", "originalCommit": "7bf5e40e48c1f367e83e5d46fdc791dcb9dc2418", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEzMzg3NQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1156#discussion_r372133875", "bodyText": "Good catch. It is meant to verify that a build on an empty builder works.", "author": "schmidt-sebastian", "createdAt": "2020-01-29T00:30:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk2Mjg5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk2MzY3Mw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1156#discussion_r371963673", "bodyText": "Consider naming these methods as phrases with an implicit leading \"it\" (in this case setsASingleField). This makes the names directly portable to our typescript tests.", "author": "wilhuff", "createdAt": "2020-01-28T17:57:53Z", "path": "firebase-firestore/src/test/java/com/google/firebase/firestore/model/ObjectValueBuilderTest.java", "diffHunk": "@@ -0,0 +1,228 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.firestore.model;\n+\n+import static com.google.firebase.firestore.Values.map;\n+import static com.google.firebase.firestore.Values.valueOf;\n+import static com.google.firebase.firestore.testutil.TestUtil.field;\n+import static junit.framework.TestCase.assertEquals;\n+import static junit.framework.TestCase.assertTrue;\n+\n+import com.google.firebase.firestore.model.protovalue.ObjectValue;\n+import com.google.firebase.firestore.model.value.FieldValue;\n+import com.google.firestore.v1.Value;\n+import java.util.Collections;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.annotation.Config;\n+\n+@RunWith(RobolectricTestRunner.class)\n+@Config(manifest = Config.NONE)\n+public class ObjectValueBuilderTest {\n+  private Value fooValue = valueOf(\"foo\");\n+  private Value barValue = valueOf(\"bar\");\n+  private Value emptyObject = valueOf(Collections.emptyMap());\n+\n+  @Test\n+  public void emptyBuilder() {\n+    ObjectValue.Builder builder = ObjectValue.emptyObject().toBuilder();\n+    ObjectValue object = builder.build();\n+    assertEquals(wrapObject(), object);\n+  }\n+\n+  @Test\n+  public void setSingleField() {", "originalCommit": "7bf5e40e48c1f367e83e5d46fdc791dcb9dc2418", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEzNTI2Mw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1156#discussion_r372135263", "bodyText": "Done", "author": "schmidt-sebastian", "createdAt": "2020-01-29T00:36:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk2MzY3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk2NDU5Mw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1156#discussion_r371964593", "bodyText": "I could have sworn we added an ObjectValue.newBuilder or some short form like that. Could we use that to cut down some of the verbosity here?", "author": "wilhuff", "createdAt": "2020-01-28T17:59:30Z", "path": "firebase-firestore/src/test/java/com/google/firebase/firestore/model/ObjectValueBuilderTest.java", "diffHunk": "@@ -0,0 +1,228 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.firestore.model;\n+\n+import static com.google.firebase.firestore.Values.map;\n+import static com.google.firebase.firestore.Values.valueOf;\n+import static com.google.firebase.firestore.testutil.TestUtil.field;\n+import static junit.framework.TestCase.assertEquals;\n+import static junit.framework.TestCase.assertTrue;\n+\n+import com.google.firebase.firestore.model.protovalue.ObjectValue;\n+import com.google.firebase.firestore.model.value.FieldValue;\n+import com.google.firestore.v1.Value;\n+import java.util.Collections;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.annotation.Config;\n+\n+@RunWith(RobolectricTestRunner.class)\n+@Config(manifest = Config.NONE)\n+public class ObjectValueBuilderTest {\n+  private Value fooValue = valueOf(\"foo\");\n+  private Value barValue = valueOf(\"bar\");\n+  private Value emptyObject = valueOf(Collections.emptyMap());\n+\n+  @Test\n+  public void emptyBuilder() {\n+    ObjectValue.Builder builder = ObjectValue.emptyObject().toBuilder();\n+    ObjectValue object = builder.build();\n+    assertEquals(wrapObject(), object);\n+  }\n+\n+  @Test\n+  public void setSingleField() {\n+    ObjectValue.Builder builder = ObjectValue.emptyObject().toBuilder();", "originalCommit": "7bf5e40e48c1f367e83e5d46fdc791dcb9dc2418", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEzNTk1MA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1156#discussion_r372135950", "bodyText": "This only exists in the old value.ObjectValue. I also added it to protovalue.ObjectValue", "author": "schmidt-sebastian", "createdAt": "2020-01-29T00:38:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk2NDU5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk2Njc1MA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1156#discussion_r371966750", "bodyText": "Your current successor implementation would break if you also had a value with a character with an ordinal less than 0 (U+0030), e.g. space (U+0020) or bang (U+0021).", "author": "wilhuff", "createdAt": "2020-01-28T18:03:40Z", "path": "firebase-firestore/src/test/java/com/google/firebase/firestore/model/ObjectValueBuilderTest.java", "diffHunk": "@@ -0,0 +1,228 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.firestore.model;\n+\n+import static com.google.firebase.firestore.Values.map;\n+import static com.google.firebase.firestore.Values.valueOf;\n+import static com.google.firebase.firestore.testutil.TestUtil.field;\n+import static junit.framework.TestCase.assertEquals;\n+import static junit.framework.TestCase.assertTrue;\n+\n+import com.google.firebase.firestore.model.protovalue.ObjectValue;\n+import com.google.firebase.firestore.model.value.FieldValue;\n+import com.google.firestore.v1.Value;\n+import java.util.Collections;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.annotation.Config;\n+\n+@RunWith(RobolectricTestRunner.class)\n+@Config(manifest = Config.NONE)\n+public class ObjectValueBuilderTest {\n+  private Value fooValue = valueOf(\"foo\");\n+  private Value barValue = valueOf(\"bar\");\n+  private Value emptyObject = valueOf(Collections.emptyMap());\n+\n+  @Test\n+  public void emptyBuilder() {\n+    ObjectValue.Builder builder = ObjectValue.emptyObject().toBuilder();\n+    ObjectValue object = builder.build();\n+    assertEquals(wrapObject(), object);\n+  }\n+\n+  @Test\n+  public void setSingleField() {\n+    ObjectValue.Builder builder = ObjectValue.emptyObject().toBuilder();\n+    builder.set(field(\"foo\"), fooValue);\n+    ObjectValue object = builder.build();\n+    assertEquals(wrapObject(\"foo\", fooValue), object);\n+  }\n+\n+  @Test\n+  public void setEmptyObject() {\n+    ObjectValue.Builder builder = ObjectValue.emptyObject().toBuilder();\n+    builder.set(field(\"foo\"), emptyObject);\n+    ObjectValue object = builder.build();\n+    assertEquals(wrapObject(\"foo\", emptyObject), object);\n+  }\n+\n+  @Test\n+  public void setMultipleFields() {\n+    ObjectValue.Builder builder = ObjectValue.emptyObject().toBuilder();\n+    builder.set(field(\"foo\"), fooValue);\n+    builder.set(field(\"bar\"), fooValue);\n+    ObjectValue object = builder.build();\n+    assertEquals(wrapObject(\"foo\", fooValue, \"bar\", fooValue), object);\n+  }\n+\n+  @Test\n+  public void setSuccessorField() {\n+    ObjectValue.Builder builder = ObjectValue.emptyObject().toBuilder();\n+    builder.set(field(\"a\"), fooValue);\n+    builder.set(field(\"a0\"), fooValue);", "originalCommit": "7bf5e40e48c1f367e83e5d46fdc791dcb9dc2418", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk4MTk4OQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1156#discussion_r371981989", "bodyText": "Also consider a test where you set a nested object at a more-than-one-level difference of depth.", "author": "wilhuff", "createdAt": "2020-01-28T18:33:37Z", "path": "firebase-firestore/src/test/java/com/google/firebase/firestore/model/ObjectValueBuilderTest.java", "diffHunk": "@@ -0,0 +1,228 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.firestore.model;\n+\n+import static com.google.firebase.firestore.Values.map;\n+import static com.google.firebase.firestore.Values.valueOf;\n+import static com.google.firebase.firestore.testutil.TestUtil.field;\n+import static junit.framework.TestCase.assertEquals;\n+import static junit.framework.TestCase.assertTrue;\n+\n+import com.google.firebase.firestore.model.protovalue.ObjectValue;\n+import com.google.firebase.firestore.model.value.FieldValue;\n+import com.google.firestore.v1.Value;\n+import java.util.Collections;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.annotation.Config;\n+\n+@RunWith(RobolectricTestRunner.class)\n+@Config(manifest = Config.NONE)\n+public class ObjectValueBuilderTest {\n+  private Value fooValue = valueOf(\"foo\");\n+  private Value barValue = valueOf(\"bar\");\n+  private Value emptyObject = valueOf(Collections.emptyMap());\n+\n+  @Test\n+  public void emptyBuilder() {\n+    ObjectValue.Builder builder = ObjectValue.emptyObject().toBuilder();\n+    ObjectValue object = builder.build();\n+    assertEquals(wrapObject(), object);\n+  }\n+\n+  @Test\n+  public void setSingleField() {\n+    ObjectValue.Builder builder = ObjectValue.emptyObject().toBuilder();\n+    builder.set(field(\"foo\"), fooValue);\n+    ObjectValue object = builder.build();\n+    assertEquals(wrapObject(\"foo\", fooValue), object);\n+  }\n+\n+  @Test\n+  public void setEmptyObject() {\n+    ObjectValue.Builder builder = ObjectValue.emptyObject().toBuilder();\n+    builder.set(field(\"foo\"), emptyObject);\n+    ObjectValue object = builder.build();\n+    assertEquals(wrapObject(\"foo\", emptyObject), object);\n+  }\n+\n+  @Test\n+  public void setMultipleFields() {\n+    ObjectValue.Builder builder = ObjectValue.emptyObject().toBuilder();\n+    builder.set(field(\"foo\"), fooValue);\n+    builder.set(field(\"bar\"), fooValue);\n+    ObjectValue object = builder.build();\n+    assertEquals(wrapObject(\"foo\", fooValue, \"bar\", fooValue), object);\n+  }\n+\n+  @Test\n+  public void setSuccessorField() {\n+    ObjectValue.Builder builder = ObjectValue.emptyObject().toBuilder();\n+    builder.set(field(\"a\"), fooValue);\n+    builder.set(field(\"a0\"), fooValue);\n+    ObjectValue object = builder.build();\n+    assertEquals(wrapObject(\"a\", fooValue, \"a0\", fooValue), object);\n+  }\n+\n+  @Test\n+  public void setNestedField() {\n+    ObjectValue.Builder builder = ObjectValue.emptyObject().toBuilder();\n+    builder.set(field(\"a.b\"), fooValue);\n+    builder.set(field(\"c.d.e\"), fooValue);\n+    ObjectValue object = builder.build();\n+    assertEquals(wrapObject(\"a\", map(\"b\", fooValue), \"c\", map(\"d\", map(\"e\", fooValue))), object);\n+  }\n+\n+  @Test\n+  public void setTwoFieldsInNestedObject() {\n+    ObjectValue.Builder builder = ObjectValue.emptyObject().toBuilder();\n+    builder.set(field(\"a.b\"), fooValue);\n+    builder.set(field(\"a.c\"), fooValue);\n+    ObjectValue object = builder.build();\n+    assertEquals(wrapObject(\"a\", map(\"b\", fooValue, \"c\", fooValue)), object);\n+  }\n+\n+  @Test\n+  public void setFieldInNestedObject() {\n+    ObjectValue.Builder builder = ObjectValue.emptyObject().toBuilder();\n+    builder.set(field(\"a\"), map(\"b\", fooValue));\n+    builder.set(field(\"a.c\"), fooValue);", "originalCommit": "7bf5e40e48c1f367e83e5d46fdc791dcb9dc2418", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEzNjQ3Ng==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1156#discussion_r372136476", "bodyText": "Sure thing. Added setsDeeplyNestedFieldInNestedObject()", "author": "schmidt-sebastian", "createdAt": "2020-01-29T00:40:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk4MTk4OQ=="}], "type": "inlineReview"}, {"oid": "035970b6ce75f03b48449fa314c40688e3cefd2c", "url": "https://github.com/firebase/firebase-android-sdk/commit/035970b6ce75f03b48449fa314c40688e3cefd2c", "message": "Review comments", "committedDate": "2020-01-29T00:51:38Z", "type": "commit"}, {"oid": "035970b6ce75f03b48449fa314c40688e3cefd2c", "url": "https://github.com/firebase/firebase-android-sdk/commit/035970b6ce75f03b48449fa314c40688e3cefd2c", "message": "Review comments", "committedDate": "2020-01-29T00:51:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU0ODAzMA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1156#discussion_r372548030", "bodyText": "null is pretty overloaded. I wonder if it would be helpful to store a sentinel in here instead.\nSomething like this up top:\nprivate static final Object DELETED = new Object();\nAnd then this would read as\nsetOverlay(path, DELETED);\nI don't think this changes any of the handling below, so probably not worth it, but it has some visual appeal.\nFeel free to ignore.", "author": "wilhuff", "createdAt": "2020-01-29T18:15:02Z", "path": "firebase-firestore/src/main/java/com/google/firebase/firestore/model/protovalue/ObjectValue.java", "diffHunk": "@@ -0,0 +1,237 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.firestore.model.protovalue;\n+\n+import static com.google.firebase.firestore.model.value.ProtoValues.isType;\n+import static com.google.firebase.firestore.util.Assert.hardAssert;\n+\n+import androidx.annotation.Nullable;\n+import com.google.firebase.firestore.model.FieldPath;\n+import com.google.firebase.firestore.model.mutation.FieldMask;\n+import com.google.firebase.firestore.model.value.FieldValue;\n+import com.google.firestore.v1.MapValue;\n+import com.google.firestore.v1.Value;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class ObjectValue extends PrimitiveValue {\n+  private static final ObjectValue EMPTY_VALUE =\n+      new ObjectValue(\n+          com.google.firestore.v1.Value.newBuilder()\n+              .setMapValue(com.google.firestore.v1.MapValue.getDefaultInstance())\n+              .build());\n+\n+  public ObjectValue(Value value) {\n+    super(value);\n+    hardAssert(isType(value, TYPE_ORDER_OBJECT), \"ObjectValues must be backed by a MapValue\");\n+  }\n+\n+  public static ObjectValue emptyObject() {\n+    return EMPTY_VALUE;\n+  }\n+\n+  /** Returns a new Builder instance that is based on an empty object. */\n+  public static ObjectValue.Builder newBuilder() {\n+    return EMPTY_VALUE.toBuilder();\n+  }\n+\n+  /**\n+   * Returns the value at the given path or null.\n+   *\n+   * @param fieldPath the path to search\n+   * @return The value at the path or if there it doesn't exist.\n+   */\n+  public @Nullable FieldValue get(FieldPath fieldPath) {\n+    if (fieldPath.isEmpty()) {\n+      return this;\n+    } else {\n+      Value value = internalValue;\n+      for (int i = 0; i < fieldPath.length() - 1; ++i) {\n+        value = value.getMapValue().getFieldsOrDefault(fieldPath.getSegment(i), null);\n+        if (!isType(value, TYPE_ORDER_OBJECT)) {\n+          return null;\n+        }\n+      }\n+      value = value.getMapValue().getFieldsOrDefault(fieldPath.getLastSegment(), null);\n+      return value != null ? FieldValue.of(value) : null;\n+    }\n+  }\n+\n+  /** Recursively extracts the FieldPaths that are set in this ObjectValue. */\n+  public FieldMask getFieldMask() {\n+    return extractFieldMask(internalValue.getMapValue());\n+  }\n+\n+  private FieldMask extractFieldMask(MapValue value) {\n+    Set<FieldPath> fields = new HashSet<>();\n+    for (Map.Entry<String, Value> entry : value.getFieldsMap().entrySet()) {\n+      FieldPath currentPath = FieldPath.fromSingleSegment(entry.getKey());\n+      if (isType(entry.getValue(), TYPE_ORDER_OBJECT)) {\n+        FieldMask nestedMask = extractFieldMask(entry.getValue().getMapValue());\n+        Set<FieldPath> nestedFields = nestedMask.getMask();\n+        if (nestedFields.isEmpty()) {\n+          // Preserve the empty map by adding it to the FieldMask.\n+          fields.add(currentPath);\n+        } else {\n+          // For nested and non-empty ObjectValues, add the FieldPath of the leaf nodes.\n+          for (FieldPath nestedPath : nestedFields) {\n+            fields.add(currentPath.append(nestedPath));\n+          }\n+        }\n+      } else {\n+        fields.add(currentPath);\n+      }\n+    }\n+    return FieldMask.fromSet(fields);\n+  }\n+\n+  /** Creates a ObjectValue.Builder instance that is based on the current value. */\n+  public ObjectValue.Builder toBuilder() {\n+    return new Builder(this);\n+  }\n+\n+  /** An ObjectValue.Builder provides APIs to set and delete fields from an ObjectValue. */\n+  public static class Builder {\n+\n+    /** The existing data to mutate. */\n+    private ObjectValue baseObject;\n+\n+    /**\n+     * A nested map that contains the accumulated changes in this builder. Values can either be\n+     * `Value` protos, `Map<String, Object>` values (to represent additional nesting) or `null` (to\n+     * represent field deletes).\n+     */\n+    private Map<String, Object> overlayMap;\n+\n+    Builder(ObjectValue baseObject) {\n+      this.baseObject = baseObject;\n+      this.overlayMap = new HashMap<>();\n+    }\n+\n+    /**\n+     * Sets the field to the provided value.\n+     *\n+     * @param path The field path to set.\n+     * @param value The value to set.\n+     * @return The current Builder instance.\n+     */\n+    public Builder set(FieldPath path, Value value) {\n+      hardAssert(!path.isEmpty(), \"Cannot set field for empty path on ObjectValue\");\n+      setOverlay(path, value);\n+      return this;\n+    }\n+\n+    /**\n+     * Removes the field at the specified path. If there is no field at the specified path nothing\n+     * is changed.\n+     *\n+     * @param path The field path to remove\n+     * @return The current Builder instance.\n+     */\n+    public Builder delete(FieldPath path) {\n+      hardAssert(!path.isEmpty(), \"Cannot delete field for empty path on ObjectValue\");\n+      setOverlay(path, null);", "originalCommit": "035970b6ce75f03b48449fa314c40688e3cefd2c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU5NjA0NQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1156#discussion_r372596045", "bodyText": "I am leaving this as is for now. The reason is the DELETE sentinel would need to of type Value so I can pass it to setOverlay. That makes my instanceof checks more complicated, as I now have to differentiate between user-provided values and the sentinel.", "author": "schmidt-sebastian", "createdAt": "2020-01-29T19:50:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU0ODAzMA=="}], "type": "inlineReview"}]}