{"pr_number": 1224, "pr_title": "Add CrashlyticsReport persistence", "pr_createdAt": "2020-02-07T20:35:24Z", "pr_url": "https://github.com/firebase/firebase-android-sdk/pull/1224", "timeline": [{"oid": "693252685c961ffe67187019ae0ed4fd599064b4", "url": "https://github.com/firebase/firebase-android-sdk/commit/693252685c961ffe67187019ae0ed4fd599064b4", "message": "Add CrashlyticsReport persistence\n\nSerializes to JSON files on disk", "committedDate": "2020-02-07T20:34:14Z", "type": "commit"}, {"oid": "f6be7dd334d8f1dbce171fcf4e925e0cdc85d5a8", "url": "https://github.com/firebase/firebase-android-sdk/commit/f6be7dd334d8f1dbce171fcf4e925e0cdc85d5a8", "message": "Fix class visibility", "committedDate": "2020-02-07T20:38:48Z", "type": "commit"}, {"oid": "812320dd50a74b92f29778f1b62906227c5616e2", "url": "https://github.com/firebase/firebase-android-sdk/commit/812320dd50a74b92f29778f1b62906227c5616e2", "message": "Formatting", "committedDate": "2020-02-07T20:39:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYwOTk1NA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1224#discussion_r376609954", "bodyText": "It's probably a better test if these aren't all 0.", "author": "bklimt", "createdAt": "2020-02-07T21:13:07Z", "path": "firebase-crashlytics/src/androidTest/java/com/google/firebase/crashlytics/internal/persistence/CrashlyticsReportPersistenceTest.java", "diffHunk": "@@ -0,0 +1,261 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.crashlytics.internal.persistence;\n+\n+import static org.junit.Assert.*;\n+\n+import androidx.test.runner.AndroidJUnit4;\n+import com.google.firebase.crashlytics.internal.model.CrashlyticsReport;\n+import com.google.firebase.crashlytics.internal.model.CrashlyticsReport.Session;\n+import com.google.firebase.crashlytics.internal.model.CrashlyticsReport.Session.Application;\n+import com.google.firebase.crashlytics.internal.model.CrashlyticsReport.Session.Event;\n+import com.google.firebase.crashlytics.internal.model.CrashlyticsReport.Session.Event.Application.Execution;\n+import com.google.firebase.crashlytics.internal.model.CrashlyticsReport.Session.Event.Application.Execution.Signal;\n+import com.google.firebase.crashlytics.internal.model.CrashlyticsReport.Session.Event.Application.Execution.Thread.Frame;\n+import com.google.firebase.crashlytics.internal.model.ImmutableList;\n+import java.util.List;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+\n+@RunWith(AndroidJUnit4.class)\n+public class CrashlyticsReportPersistenceTest {\n+\n+  private CrashlyticsReportPersistence reportPersistence;\n+\n+  @Rule public TemporaryFolder folder = new TemporaryFolder();\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    reportPersistence = new CrashlyticsReportPersistence(folder.newFolder());\n+  }\n+\n+  @Test\n+  public void testLoadFinalizeReports_noReports_returnsNothing() {\n+    assertTrue(reportPersistence.loadFinalizedReports().isEmpty());\n+  }\n+\n+  @Test\n+  public void testLoadFinalizedReports_reportWithNoEvents_returnsNothing() {\n+    final String sessionId = \"testSession\";\n+    reportPersistence.persistReport(makeTestReport(sessionId));\n+    reportPersistence.finalizeReports(sessionId);\n+    assertTrue(reportPersistence.loadFinalizedReports().isEmpty());\n+  }\n+\n+  @Test\n+  public void testLoadFinalizedReports_reportThenEvent_returnsReportWithEvent() {\n+    final String sessionId = \"testSession\";\n+    final CrashlyticsReport testReport = makeTestReport(sessionId);\n+    final CrashlyticsReport.Session.Event testEvent = makeTestEvent();\n+\n+    reportPersistence.persistReport(testReport);\n+    reportPersistence.persistEvent(testEvent, sessionId);\n+    reportPersistence.finalizeReports(\"skippedSession\");\n+\n+    final List<CrashlyticsReport> finalizedReports = reportPersistence.loadFinalizedReports();\n+    assertEquals(1, finalizedReports.size());\n+    final CrashlyticsReport finalizedReport = finalizedReports.get(0);\n+    assertEquals(finalizedReport, testReport.withEvents(ImmutableList.from(testEvent)));\n+  }\n+\n+  @Test\n+  public void testLoadFinalizedReports_reportThenMultipleEvents_returnsReportWithMultipleEvents() {\n+    final String sessionId = \"testSession\";\n+    final CrashlyticsReport testReport = makeTestReport(sessionId);\n+    final CrashlyticsReport.Session.Event testEvent = makeTestEvent();\n+    final CrashlyticsReport.Session.Event testEvent2 = makeTestEvent();\n+\n+    reportPersistence.persistReport(testReport);\n+    reportPersistence.persistEvent(testEvent, sessionId);\n+    reportPersistence.persistEvent(testEvent2, sessionId);\n+\n+    reportPersistence.finalizeReports(\"skippedSession\");\n+\n+    final List<CrashlyticsReport> finalizedReports = reportPersistence.loadFinalizedReports();\n+    assertEquals(1, finalizedReports.size());\n+    final CrashlyticsReport finalizedReport = finalizedReports.get(0);\n+    assertEquals(finalizedReport, testReport.withEvents(ImmutableList.from(testEvent, testEvent2)));\n+  }\n+\n+  @Test\n+  public void\n+      testLoadFinalizedReports_reportsWithEventsInMultipleSessions_returnsReportsWithProperEvents() {\n+    final String sessionId1 = \"testSession1\";\n+    final CrashlyticsReport testReport1 = makeTestReport(sessionId1);\n+    final String sessionId2 = \"testSession2\";\n+    final CrashlyticsReport testReport2 = makeTestReport(sessionId2);\n+    final CrashlyticsReport.Session.Event testEvent1 = makeTestEvent();\n+    final CrashlyticsReport.Session.Event testEvent2 = makeTestEvent();\n+\n+    reportPersistence.persistReport(testReport1);\n+    reportPersistence.persistReport(testReport2);\n+    reportPersistence.persistEvent(testEvent1, sessionId1);\n+    reportPersistence.persistEvent(testEvent2, sessionId2);\n+\n+    reportPersistence.finalizeReports(\"skippedSession\");\n+\n+    final List<CrashlyticsReport> finalizedReports = reportPersistence.loadFinalizedReports();\n+    assertEquals(2, finalizedReports.size());\n+    final CrashlyticsReport finalizedReport1 = finalizedReports.get(0);\n+    assertEquals(finalizedReport1, testReport1.withEvents(ImmutableList.from(testEvent1)));\n+    final CrashlyticsReport finalizedReport2 = finalizedReports.get(1);\n+    assertEquals(finalizedReport2, testReport2.withEvents(ImmutableList.from(testEvent2)));\n+  }\n+\n+  @Test\n+  public void testDeleteFinalizedReport_removesReports() {\n+    final String sessionId = \"testSession\";\n+    final CrashlyticsReport testReport = makeTestReport(sessionId);\n+    final CrashlyticsReport.Session.Event testEvent = makeTestEvent();\n+\n+    reportPersistence.persistReport(testReport);\n+    reportPersistence.persistEvent(testEvent, sessionId);\n+    reportPersistence.finalizeReports(\"skippedSession\");\n+\n+    assertEquals(1, reportPersistence.loadFinalizedReports().size());\n+\n+    reportPersistence.deleteFinalizedReport(sessionId);\n+\n+    assertEquals(0, reportPersistence.loadFinalizedReports().size());\n+  }\n+\n+  @Test\n+  public void testDeleteFinalizedReport_withWrongSessionId_doesNotRemoveReports() {\n+    final String sessionId = \"testSession\";\n+    final CrashlyticsReport testReport = makeTestReport(sessionId);\n+    final CrashlyticsReport.Session.Event testEvent = makeTestEvent();\n+\n+    reportPersistence.persistReport(testReport);\n+    reportPersistence.persistEvent(testEvent, sessionId);\n+    reportPersistence.finalizeReports(\"skippedSession\");\n+\n+    assertEquals(1, reportPersistence.loadFinalizedReports().size());\n+\n+    reportPersistence.deleteFinalizedReport(\"wrongSessionId\");\n+\n+    assertEquals(1, reportPersistence.loadFinalizedReports().size());\n+  }\n+\n+  private static CrashlyticsReport makeTestReport(String sessionId) {\n+    return CrashlyticsReport.builder()\n+        .setSdkVersion(\"sdkVersion\")\n+        .setGmpAppId(\"gmpAppId\")\n+        .setPlatform(1)\n+        .setInstallationUuid(\"installationId\")\n+        .setBuildVersion(\"1\")\n+        .setDisplayVersion(\"1.0.0\")\n+        .setSession(makeTestSession(sessionId))\n+        .build();\n+  }\n+\n+  private static CrashlyticsReport.Session makeTestSession(String sessionId) {\n+    return Session.builder()\n+        .setGenerator(\"generator\")\n+        .setIdentifier(sessionId)\n+        .setStartedAt(0)\n+        .setApp(makeTestApplication())\n+        .build();\n+  }\n+\n+  private static Application makeTestApplication() {\n+    return Application.builder()\n+        .setIdentifier(\"applicationId\")\n+        .setVersion(\"version\")\n+        .setDisplayVersion(\"displayVersion\")\n+        .build();\n+  }\n+\n+  private static Event makeTestEvent() {\n+    return Event.builder()\n+        .setType(\"type\")\n+        .setTimestamp(1000)\n+        .setApp(\n+            Session.Event.Application.builder()\n+                .setBackground(false)\n+                .setExecution(\n+                    Execution.builder()\n+                        .setBinaries(\n+                            ImmutableList.from(\n+                                Execution.BinaryImage.builder()\n+                                    .setBaseAddress(0)\n+                                    .setName(\"name\")\n+                                    .setSize(100000)\n+                                    .setUuid(\"uuid\")\n+                                    .build()))\n+                        .setException(\n+                            Execution.Exception.builder()\n+                                .setFrames(makeTestFrames())\n+                                .setOverflowCount(0)\n+                                .setReason(\"reason\")\n+                                .setType(\"java.lang.Exception\")\n+                                .build())\n+                        .setSignal(Signal.builder().setCode(\"0\").setName(\"0\").setAddress(0).build())\n+                        .setThreads(\n+                            ImmutableList.from(\n+                                Session.Event.Application.Execution.Thread.builder()\n+                                    .setName(\"name\")\n+                                    .setImportance(4)\n+                                    .setFrames(makeTestFrames())\n+                                    .build()))\n+                        .build())\n+                .setUiOrientation(1)\n+                .build())\n+        .setDevice(\n+            Session.Event.Device.builder()\n+                .setBatteryLevel(0.5)\n+                .setBatteryVelocity(3)\n+                .setDiskUsed(10000000)\n+                .setOrientation(1)\n+                .setProximityOn(true)\n+                .setRamUsed(10000000)\n+                .build())\n+        .build();\n+  }\n+\n+  private static ImmutableList<Frame> makeTestFrames() {\n+    return ImmutableList.from(\n+        Frame.builder()\n+            .setPc(0)", "originalCommit": "812320dd50a74b92f29778f1b62906227c5616e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYyMDYyMw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1224#discussion_r376620623", "bodyText": "Good call, I'll update this.", "author": "mrwillis21", "createdAt": "2020-02-07T21:40:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYwOTk1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYxNzMyMQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1224#discussion_r376617321", "bodyText": "These methods already deleted elsewhere in the SDK, correct? So is the plan to delete the other versions?", "author": "bklimt", "createdAt": "2020-02-07T21:32:10Z", "path": "firebase-crashlytics/src/main/java/com/google/firebase/crashlytics/internal/persistence/CrashlyticsReportPersistence.java", "diffHunk": "@@ -0,0 +1,236 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.crashlytics.internal.persistence;\n+\n+import com.google.firebase.crashlytics.internal.model.CrashlyticsReport;\n+import com.google.firebase.crashlytics.internal.model.CrashlyticsReport.Session.Event;\n+import com.google.firebase.crashlytics.internal.model.ImmutableList;\n+import com.google.firebase.crashlytics.internal.model.serialization.CrashlyticsReportJsonTransform;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileFilter;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.FilenameFilter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * This class handles persisting report and event data to disk, combining reports with their\n+ * associated events into \"finalized\" report files, reading reports from disk, parsing them to be\n+ * returned as CrashlyticsReport objects, and deleting them.\n+ */\n+public class CrashlyticsReportPersistence {\n+\n+  private static final Charset UTF_8 = Charset.forName(\"UTF-8\");\n+\n+  private static final String WORKING_DIRECTORY_NAME = \"fl\";\n+  private static final String OPEN_SESSIONS_DIRECTORY_NAME = \"sessions\";\n+  private static final String FATAL_DIRECTORY_NAME = \"fatal\";\n+  private static final String NON_FATAL_DIRECTORY_NAME = \"non-fatal\";\n+\n+  private static final String REPORT_FILE_NAME = \"report.json\";\n+  private static final String EVENT_FILE_NAME_PREFIX = \"event\";\n+  private static final String EVENT_FILE_NAME_FORMAT = EVENT_FILE_NAME_PREFIX + \"%s.json\";\n+  private static final String EVENT_COUNTER_FORMAT = \"%010d\";\n+\n+  private static final String EVENT_TYPE_FATAL = \"crash\";\n+\n+  private static final CrashlyticsReportJsonTransform TRANSFORM =\n+      new CrashlyticsReportJsonTransform();\n+\n+  private final AtomicInteger eventCounter = new AtomicInteger(0);\n+\n+  // Storage for sessions that are still being written to\n+  private File openSessionsDirectory;\n+\n+  // Storage for finalized reports\n+  // Keep finalized reports organized by whether or not they contain a fatal event.\n+  private File fatalReportsDirectory;\n+  private File nonFatalReportsDirectory;\n+\n+  public CrashlyticsReportPersistence(File rootDirectory) {\n+    final File workingDirectory = new File(rootDirectory, WORKING_DIRECTORY_NAME);\n+    openSessionsDirectory = new File(workingDirectory, OPEN_SESSIONS_DIRECTORY_NAME);\n+    fatalReportsDirectory = new File(workingDirectory, FATAL_DIRECTORY_NAME);\n+    nonFatalReportsDirectory = new File(workingDirectory, NON_FATAL_DIRECTORY_NAME);\n+  }\n+\n+  public void persistReport(CrashlyticsReport report) {\n+    final String sessionId = report.getSession().getIdentifier();\n+    final File sessionDirectory = prepareDirectory(getSessionDirectoryById(sessionId));\n+    final String json = TRANSFORM.reportToJson(report);\n+    writeTextFile(new File(sessionDirectory, REPORT_FILE_NAME), json);\n+  }\n+\n+  public void persistEvent(CrashlyticsReport.Session.Event event, String sessionId) {\n+    final File sessionDirectory = getSessionDirectoryById(sessionId);\n+    if (!sessionDirectory.isDirectory()) {\n+      // No open session for this ID\n+      // TODO: Just drop the event? Log? Throw?\n+      return;\n+    }\n+    final String json = TRANSFORM.eventToJson(event);\n+    final String eventNumber =\n+        String.format(Locale.US, EVENT_COUNTER_FORMAT, eventCounter.getAndIncrement());\n+    final String fileName = String.format(EVENT_FILE_NAME_FORMAT, eventNumber);\n+    writeTextFile(new File(sessionDirectory, fileName), json);\n+  }\n+\n+  public void deleteFinalizedReport(String sessionId) {\n+    final List<File> reportFiles = new ArrayList<>();\n+    final FilenameFilter filter = (d, f) -> f.startsWith(sessionId);\n+    // Could be in either fatal reports or non-fatal reports\n+    reportFiles.addAll(getFilesInDirectory(fatalReportsDirectory, filter));\n+    reportFiles.addAll(getFilesInDirectory(nonFatalReportsDirectory, filter));\n+    for (File reportFile : reportFiles) {\n+      reportFile.delete();\n+    }\n+  }\n+\n+  // TODO: Deal with potential runtime exceptions\n+  public void finalizeReports(String currentSessionId) {\n+    // TODO: Trim down to maximum allowed # of open sessions\n+\n+    // TODO: Trim down to maximum allowed # of complete reports, deleting non-fatal reports first.\n+\n+    // TODO: Need to implement procedure to skip finalizing the current session when this is\n+    //  called on app start, but keep the current session when called at crash time. Currently\n+    //  this only works when called at app start.\n+    final FileFilter sessionDirectoryFilter =\n+        (f) -> f.isDirectory() && !f.getName().equals(currentSessionId);\n+\n+    final List<File> sessionDirectories =\n+        getFilesInDirectory(openSessionsDirectory, sessionDirectoryFilter);\n+    for (File sessionDirectory : sessionDirectories) {\n+      final List<File> eventFiles =\n+          getFilesInDirectory(\n+              sessionDirectory, (f, name) -> name.startsWith(EVENT_FILE_NAME_PREFIX));\n+      Collections.sort(eventFiles);\n+      // TODO: Fix nulls\n+      // Only process the session if it has associated events\n+      if (!eventFiles.isEmpty()) {\n+        final CrashlyticsReport report =\n+            TRANSFORM.reportFromJson(readTextFile(new File(sessionDirectory, REPORT_FILE_NAME)));\n+        final String sessionId = report.getSession().getIdentifier();\n+        final List<Event> events = new ArrayList<>();\n+        boolean hasFatal = false;\n+        for (File eventFile : eventFiles) {\n+          final Event event = TRANSFORM.eventFromJson(readTextFile(eventFile));\n+          hasFatal = hasFatal || event.getType().equals(EVENT_TYPE_FATAL);\n+          events.add(event);\n+        }\n+        // FIXME: If we fail to parse the events, we'll need to bail.\n+        final File outputDirectory =\n+            prepareDirectory(hasFatal ? fatalReportsDirectory : nonFatalReportsDirectory);\n+        writeTextFile(\n+            new File(outputDirectory, sessionId),\n+            TRANSFORM.reportToJson(report.withEvents(ImmutableList.from(events))));\n+      }\n+      recursiveDelete(sessionDirectory);\n+    }\n+  }\n+\n+  public List<CrashlyticsReport> loadFinalizedReports() {\n+    final List<CrashlyticsReport> reports = new ArrayList<>();\n+    final List<File> fatalReports = getAllFilesInDirectory(fatalReportsDirectory);\n+    for (File reportFile : fatalReports) {\n+      reports.add(TRANSFORM.reportFromJson(readTextFile(reportFile)));\n+    }\n+    final List<File> nonFatalReports = getAllFilesInDirectory(nonFatalReportsDirectory);\n+    for (File reportFile : nonFatalReports) {\n+      reports.add(TRANSFORM.reportFromJson(readTextFile(reportFile)));\n+    }\n+    return reports;\n+  }\n+\n+  private File getSessionDirectoryById(String sessionId) {\n+    return new File(openSessionsDirectory, sessionId);\n+  }\n+\n+  private static List<File> getAllFilesInDirectory(File directory) {\n+    return getFilesInDirectory(directory, (FileFilter) null);\n+  }\n+\n+  private static List<File> getFilesInDirectory(File directory, FilenameFilter filter) {\n+    if (directory == null || !directory.isDirectory()) {\n+      return Collections.emptyList();\n+    }\n+    final File[] files = (filter == null) ? directory.listFiles() : directory.listFiles(filter);\n+    return (files != null) ? Arrays.asList(files) : Collections.emptyList();\n+  }\n+\n+  private static List<File> getFilesInDirectory(File directory, FileFilter filter) {\n+    if (directory == null || !directory.isDirectory()) {\n+      return Collections.emptyList();\n+    }\n+    final File[] files = (filter == null) ? directory.listFiles() : directory.listFiles(filter);\n+    return (files != null) ? Arrays.asList(files) : Collections.emptyList();\n+  }\n+\n+  private static File prepareDirectory(File directory) {\n+    if (directory == null) {\n+      return null;\n+    }\n+\n+    if (directory.exists() || directory.mkdirs()) {\n+      return directory;\n+    }\n+\n+    // TODO: Couldn't create directory. Log? Throw?\n+    return null;\n+  }\n+\n+  private static void writeTextFile(File file, String text) {\n+    try (OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(file), UTF_8)) {\n+      writer.write(text);\n+    } catch (IOException e) {\n+      // TODO: Exception writing file to disk. Log? Throw?\n+    }\n+  }\n+\n+  private static String readTextFile(File file) {\n+    final byte[] readBuffer = new byte[8192];\n+    final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    try (FileInputStream fileInput = new FileInputStream(file)) {\n+      int read;\n+      while ((read = fileInput.read(readBuffer)) > 0) {\n+        bos.write(readBuffer, 0, read);\n+      }\n+      return new String(bos.toByteArray(), UTF_8);\n+    } catch (IOException e) {\n+      return null;\n+    }\n+  }\n+\n+  private static void recursiveDelete(File file) {", "originalCommit": "812320dd50a74b92f29778f1b62906227c5616e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYyMDUyNQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1224#discussion_r376620525", "bodyText": "Ultimately, yes. My goal in the long term is to reduce \"Utils\" classes, so for now I went with the Go proverb \"A little copying is better than a little dependency.\"", "author": "mrwillis21", "createdAt": "2020-02-07T21:40:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYxNzMyMQ=="}], "type": "inlineReview"}, {"oid": "8d30b711fb21e624d23bd7f9a0e91bdfc5440238", "url": "https://github.com/firebase/firebase-android-sdk/commit/8d30b711fb21e624d23bd7f9a0e91bdfc5440238", "message": "PR feedback", "committedDate": "2020-02-07T21:42:04Z", "type": "commit"}]}