{"pr_number": 1624, "pr_title": "init implementation for decoder", "pr_createdAt": "2020-06-05T17:21:49Z", "pr_url": "https://github.com/firebase/firebase-android-sdk/pull/1624", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3NDQ4NQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1624#discussion_r436274485", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              Boolean getBoolean(@NonNull FieldRef.Primitive<Boolean> ref);\n          \n          \n            \n            \n          \n          \n            \n              @NonNull\n          \n          \n            \n              Integer getInteger(@NonNull FieldRef.Primitive<Integer> ref);\n          \n          \n            \n              boolean getBoolean(@NonNull FieldRef.Primitive<Boolean> ref);\n          \n          \n            \n            \n          \n          \n            \n              @NonNull\n          \n          \n            \n              int getInteger(@NonNull FieldRef.Primitive<Integer> ref);\n          \n      \n    \n    \n  \n\nWe need these to be primitive as boxed types can be handled by the generic get() above.", "author": "vkryachko", "createdAt": "2020-06-06T14:49:02Z", "path": "encoders/firebase-decoders-json/src/main/java/com/google/firebase/decoders/CreationContext.java", "diffHunk": "@@ -0,0 +1,30 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders;\n+\n+import androidx.annotation.NonNull;\n+\n+public interface CreationContext<T> {\n+  @NonNull\n+  <TField> TField get(@NonNull FieldRef.Boxed<TField> ref);\n+\n+  @NonNull\n+  Boolean getBoolean(@NonNull FieldRef.Primitive<Boolean> ref);\n+\n+  @NonNull\n+  Integer getInteger(@NonNull FieldRef.Primitive<Integer> ref);", "originalCommit": "2d18d6ddcb9f5d2c25a5ed9de3e74b4fde323e77", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3NDY4NA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1624#discussion_r436274684", "bodyText": "good call, I think it's fine to punt on this until we formalize required vs optional better.", "author": "vkryachko", "createdAt": "2020-06-06T14:52:01Z", "path": "encoders/firebase-decoders-json/src/main/java/com/google/firebase/decoders/FieldRef.java", "diffHunk": "@@ -0,0 +1,72 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders;\n+\n+import androidx.annotation.NonNull;\n+\n+//TODO: support required, optional.", "originalCommit": "2d18d6ddcb9f5d2c25a5ed9de3e74b4fde323e77", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAyMTEyOQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1624#discussion_r437021129", "bodyText": "+1", "author": "rlazo", "createdAt": "2020-06-08T21:49:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3NDY4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3NTAzOA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1624#discussion_r436275038", "bodyText": "What was your motivation to make  Primitive and Boxed extend FieldRef rather than being unrelated classes?", "author": "vkryachko", "createdAt": "2020-06-06T14:55:07Z", "path": "encoders/firebase-decoders-json/src/main/java/com/google/firebase/decoders/FieldRef.java", "diffHunk": "@@ -0,0 +1,72 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders;\n+\n+import androidx.annotation.NonNull;\n+\n+//TODO: support required, optional.\n+public abstract class FieldRef<T> {\n+  @NonNull\n+  protected String name;\n+\n+  @NonNull\n+  public String getName() {\n+    return name;\n+  }\n+\n+  protected FieldRef(@NonNull String name) {\n+    this.name = name;\n+  }\n+\n+  public static class Primitive<T> extends FieldRef<T> {", "originalCommit": "2d18d6ddcb9f5d2c25a5ed9de3e74b4fde323e77", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjgzOTYwMQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1624#discussion_r436839601", "bodyText": "Each ObjectDecoder keeps its decoding logics into a ObjectDecoderContextIml where each field name corresponds to a FieldRef. The decoding logic inside ObjectDecoderContextIml is simply an container Map<String, FieldRef<?>> refs which refers each field name and its corresponding FieldRef.\nEach ObjectDecoder keeps its decoding value from given inputStream into a CreationContext. The decoding values inside CreationContext is also an container Map<FieldRef<?>, Object> ctx which contains all the values the FieldRef are refering to.\nTherefore, whenever we are given the new InputStream, We wouldn't create ObjectDecoderContextIml again, but only update the values each FieldRef pointing to.\nThe reason we need a rawType inside Primitive<T> or ClassToken inside Boxed<T> is that:\neach ObjectDecoderContextIml should not only knows where each field is referring to but also its anticipated type. Therefore, I nested their type information into FiedRef, getting these types information make it possible to determine which method to use when looping the json data, such as nextInt(), nextBoolean, etc.\nThe reason I make Primitive and Boxed extennd FieldRef is that\nno matter they are primitive or object, they are field references. Besides, I want to make the containers inside  ObjectDecoderContextIml and CreationContext be simple Map<String, FieldRef<?>>\n@vkryachko\nwdyt? are there any better ways to do it?", "author": "James201311", "createdAt": "2020-06-08T16:32:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3NTAzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkwMTAwMg==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1624#discussion_r436901002", "bodyText": "The reason we need a rawType inside Primitive or ClassToken inside Boxed\n\nI see that makes sense, I would suggest though that both store a typeToken exposed through the FieldRef's abstract getTypeToken() so that you don't have to cast in your implementation code.\n\nThe reason I make Primitive and Boxed extennd FieldRef is that no matter they are primitive or object, they are field references\n\nsgtm\n\nCreationContext is also an container Map<FieldRef<?>, Object> ctx which contains all the values\nThis would be a performance challenge later as we don't want to \"auto-box\" primitives\n\n\nWe wouldn't create ObjectDecoderContextIml again, but only update the values each FieldRef pointing to\n\nLet's make sure this approach works with recursively defined types and does not overwrite things in unexpected ways, i.e. the type like the following might have a problem:\nclass Foo {\n  String field;\n  @Nullable Foo foo;", "author": "vkryachko", "createdAt": "2020-06-08T18:14:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3NTAzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxNjcwNQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1624#discussion_r436916705", "bodyText": "That is a very good call!\nActually it will take care of these recursively defined types well after I enable it to read null since each object will have its own CreationContext and it won't overwrite things.", "author": "James201311", "createdAt": "2020-06-08T18:43:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3NTAzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkzNDc5OA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1624#discussion_r436934798", "bodyText": "Also, TypeToken didn't support TypeVariable right now, but in order to support decode nested Generic type it should. I will have a PR for that first, then come back to support the recursively defined type.", "author": "James201311", "createdAt": "2020-06-08T19:09:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3NTAzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3NTIyMQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1624#discussion_r436275221", "bodyText": "Do Primitive and Boxed need any state inside? Is it used somehow by the implementation? afaict they can just be empty \"marker\" types, i.e. public static final class Primitive<T> {}. Note that their only purpose is supposed to be to provide type-safe tokens that provide access to their underlying T values.", "author": "vkryachko", "createdAt": "2020-06-06T14:57:49Z", "path": "encoders/firebase-decoders-json/src/main/java/com/google/firebase/decoders/FieldRef.java", "diffHunk": "@@ -0,0 +1,72 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders;\n+\n+import androidx.annotation.NonNull;\n+\n+//TODO: support required, optional.\n+public abstract class FieldRef<T> {\n+  @NonNull\n+  protected String name;\n+\n+  @NonNull\n+  public String getName() {\n+    return name;\n+  }\n+\n+  protected FieldRef(@NonNull String name) {\n+    this.name = name;\n+  }\n+\n+  public static class Primitive<T> extends FieldRef<T> {\n+\n+    private Class<T> rawType;", "originalCommit": "2d18d6ddcb9f5d2c25a5ed9de3e74b4fde323e77", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3NTU5NA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1624#discussion_r436275594", "bodyText": "nit: at some later point we should think of how to avoid auto-boxing for primitives, i.e. decodeObject returns T which will automatically auto-box any primitive type like int in a Integer only to unpack it back when it's injected into the class that is being decoded. So this is an optimization opportunity that can be saved for later.", "author": "vkryachko", "createdAt": "2020-06-06T15:03:24Z", "path": "encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java", "diffHunk": "@@ -0,0 +1,119 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders.json;\n+\n+import android.util.JsonReader;\n+\n+import androidx.annotation.NonNull;\n+\n+import com.google.firebase.decoders.DataDecoder;\n+import com.google.firebase.decoders.FieldRef;\n+import com.google.firebase.decoders.ObjectDecoder;\n+import com.google.firebase.decoders.TypeCreator;\n+import com.google.firebase.decoders.TypeToken;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.util.HashMap;\n+import java.util.Map;\n+//TODO: remove Exception from method header\n+//TODO: surpass warnings\n+//TODO: Java Docs\n+public class JsonDataDecoderBuilderContext implements DataDecoder {\n+  private Map<TypeToken.ClassToken<?>, ObjectDecoderContextImpl<?>> objectDecodersCtx = new HashMap<>();\n+  private Map<TypeToken.ClassToken<?>, TypeCreator<?>> typeCreators = new HashMap<>();\n+  private JsonReader reader;\n+\n+  public JsonDataDecoderBuilderContext(@NonNull Map<TypeToken.ClassToken<?>, ObjectDecoder<?>> objectDecoders) {\n+    for (Map.Entry<TypeToken.ClassToken<?>, ObjectDecoder<?>> entry : objectDecoders.entrySet()) {\n+      TypeToken.ClassToken<?> classToken = entry.getKey();\n+      ObjectDecoder objectDecoder = entry.getValue();\n+      ObjectDecoderContextImpl objectDecoderCtx = ObjectDecoderContextImpl.of(classToken);\n+      objectDecoder.decode(objectDecoderCtx);\n+      TypeCreator<?> creator = objectDecoder.decode(objectDecoderCtx);\n+      objectDecodersCtx.put(classToken, objectDecoderCtx);\n+      typeCreators.put(classToken, creator);\n+    }\n+  }\n+\n+  @NonNull\n+  @Override\n+  public <T> T decode(@NonNull InputStream input, @NonNull TypeToken<T> typeToken) throws IOException {\n+    this.reader = new JsonReader(new InputStreamReader(input, \"UTF-8\"));\n+    return decode(typeToken);\n+  }\n+\n+  private <T> T decode(TypeToken<T> typeToken) throws IOException {\n+    if (typeToken instanceof TypeToken.ClassToken) {\n+      TypeToken.ClassToken classToken = (TypeToken.ClassToken<T>) typeToken;\n+      T val = (T) decodeObject(classToken);\n+      return val;\n+    } else if (typeToken instanceof TypeToken.ArrayToken) {\n+      //TODO: Change typeParameter T in ArrayToken<T> to represent component type.\n+      /**\n+       * reader.beginArray();\n+       * List<T> l = new LinkedList<>();\n+       * while reader.hasNext:\n+       *  T val = decode(arrayToken.getComponentType());\n+       *  l.add(val);\n+       * reader.endArray();\n+       * return l.toArray();\n+       */\n+    }\n+    return null;\n+  }\n+\n+  private <T> T decodeObject(TypeToken.ClassToken<T> classToken) throws IOException {\n+    if(classToken.getRawType().isPrimitive() || classToken.getRawType().equals(String.class))\n+      return decodePrimitives(classToken.getRawType());", "originalCommit": "2d18d6ddcb9f5d2c25a5ed9de3e74b4fde323e77", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3NTg2MQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1624#discussion_r436275861", "bodyText": "Ideally we should make this processing only on demand, as doing this upfront may be wasteful if most registered decoders are never needed.", "author": "vkryachko", "createdAt": "2020-06-06T15:07:40Z", "path": "encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java", "diffHunk": "@@ -0,0 +1,119 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders.json;\n+\n+import android.util.JsonReader;\n+\n+import androidx.annotation.NonNull;\n+\n+import com.google.firebase.decoders.DataDecoder;\n+import com.google.firebase.decoders.FieldRef;\n+import com.google.firebase.decoders.ObjectDecoder;\n+import com.google.firebase.decoders.TypeCreator;\n+import com.google.firebase.decoders.TypeToken;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.util.HashMap;\n+import java.util.Map;\n+//TODO: remove Exception from method header\n+//TODO: surpass warnings\n+//TODO: Java Docs\n+public class JsonDataDecoderBuilderContext implements DataDecoder {\n+  private Map<TypeToken.ClassToken<?>, ObjectDecoderContextImpl<?>> objectDecodersCtx = new HashMap<>();\n+  private Map<TypeToken.ClassToken<?>, TypeCreator<?>> typeCreators = new HashMap<>();\n+  private JsonReader reader;\n+\n+  public JsonDataDecoderBuilderContext(@NonNull Map<TypeToken.ClassToken<?>, ObjectDecoder<?>> objectDecoders) {\n+    for (Map.Entry<TypeToken.ClassToken<?>, ObjectDecoder<?>> entry : objectDecoders.entrySet()) {", "originalCommit": "2d18d6ddcb9f5d2c25a5ed9de3e74b4fde323e77", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3NTk0MA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1624#discussion_r436275940", "bodyText": "nit: Boolean.class is not primitive, boolean.class is. same for Integer vs int, etc.", "author": "vkryachko", "createdAt": "2020-06-06T15:08:52Z", "path": "encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java", "diffHunk": "@@ -0,0 +1,119 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders.json;\n+\n+import android.util.JsonReader;\n+\n+import androidx.annotation.NonNull;\n+\n+import com.google.firebase.decoders.DataDecoder;\n+import com.google.firebase.decoders.FieldRef;\n+import com.google.firebase.decoders.ObjectDecoder;\n+import com.google.firebase.decoders.TypeCreator;\n+import com.google.firebase.decoders.TypeToken;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.util.HashMap;\n+import java.util.Map;\n+//TODO: remove Exception from method header\n+//TODO: surpass warnings\n+//TODO: Java Docs\n+public class JsonDataDecoderBuilderContext implements DataDecoder {\n+  private Map<TypeToken.ClassToken<?>, ObjectDecoderContextImpl<?>> objectDecodersCtx = new HashMap<>();\n+  private Map<TypeToken.ClassToken<?>, TypeCreator<?>> typeCreators = new HashMap<>();\n+  private JsonReader reader;\n+\n+  public JsonDataDecoderBuilderContext(@NonNull Map<TypeToken.ClassToken<?>, ObjectDecoder<?>> objectDecoders) {\n+    for (Map.Entry<TypeToken.ClassToken<?>, ObjectDecoder<?>> entry : objectDecoders.entrySet()) {\n+      TypeToken.ClassToken<?> classToken = entry.getKey();\n+      ObjectDecoder objectDecoder = entry.getValue();\n+      ObjectDecoderContextImpl objectDecoderCtx = ObjectDecoderContextImpl.of(classToken);\n+      objectDecoder.decode(objectDecoderCtx);\n+      TypeCreator<?> creator = objectDecoder.decode(objectDecoderCtx);\n+      objectDecodersCtx.put(classToken, objectDecoderCtx);\n+      typeCreators.put(classToken, creator);\n+    }\n+  }\n+\n+  @NonNull\n+  @Override\n+  public <T> T decode(@NonNull InputStream input, @NonNull TypeToken<T> typeToken) throws IOException {\n+    this.reader = new JsonReader(new InputStreamReader(input, \"UTF-8\"));\n+    return decode(typeToken);\n+  }\n+\n+  private <T> T decode(TypeToken<T> typeToken) throws IOException {\n+    if (typeToken instanceof TypeToken.ClassToken) {\n+      TypeToken.ClassToken classToken = (TypeToken.ClassToken<T>) typeToken;\n+      T val = (T) decodeObject(classToken);\n+      return val;\n+    } else if (typeToken instanceof TypeToken.ArrayToken) {\n+      //TODO: Change typeParameter T in ArrayToken<T> to represent component type.\n+      /**\n+       * reader.beginArray();\n+       * List<T> l = new LinkedList<>();\n+       * while reader.hasNext:\n+       *  T val = decode(arrayToken.getComponentType());\n+       *  l.add(val);\n+       * reader.endArray();\n+       * return l.toArray();\n+       */\n+    }\n+    return null;\n+  }\n+\n+  private <T> T decodeObject(TypeToken.ClassToken<T> classToken) throws IOException {\n+    if(classToken.getRawType().isPrimitive() || classToken.getRawType().equals(String.class))\n+      return decodePrimitives(classToken.getRawType());\n+\n+    CreationContextImpl<T> creationCtx = new CreationContextImpl<>();\n+    ObjectDecoderContextImpl<T> decoderCtx = (ObjectDecoderContextImpl<T>) objectDecodersCtx.get(classToken);\n+    reader.beginObject();\n+    while (reader.hasNext()) {\n+      String fieldName = reader.nextName();\n+      FieldRef<?> fieldRef = decoderCtx.getFieldRef(fieldName);\n+      // TODO: fieldRef is null (ObjectDecoder didn't handle that field)\n+      if (fieldRef instanceof FieldRef.Primitive) {\n+        creationCtx.put(fieldRef,\n+                decodePrimitives(((FieldRef.Primitive<?>) fieldRef).getRawType()));\n+      } else if (fieldRef instanceof FieldRef.Boxed) {\n+        creationCtx.put(fieldRef,\n+                decode(((FieldRef.Boxed<?>) fieldRef).getTypeToken()));\n+      }\n+    }\n+    reader.endObject();\n+\n+    TypeCreator<T> creator = (TypeCreator<T>) typeCreators.get(classToken);\n+    return (T) creator.create(creationCtx);\n+  }\n+\n+  private <T> T decodePrimitives(Class<T> clazz) throws IOException {\n+    //TODO: try catch\n+    if (clazz.equals(Boolean.class)) {", "originalCommit": "2d18d6ddcb9f5d2c25a5ed9de3e74b4fde323e77", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3NjAxNA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1624#discussion_r436276014", "bodyText": "nit: we may want to swap the argument order to be consistent with DataEncoder", "author": "vkryachko", "createdAt": "2020-06-06T15:09:53Z", "path": "encoders/firebase-decoders-json/src/main/java/com/google/firebase/decoders/DataDecoder.java", "diffHunk": "@@ -0,0 +1,27 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders;\n+\n+import androidx.annotation.NonNull;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+\n+public interface DataDecoder {\n+  //TODO: remove Exception from method header\n+  @NonNull\n+  <T> T decode(@NonNull InputStream input, @NonNull TypeToken<T> typeToken) throws IOException;", "originalCommit": "2d18d6ddcb9f5d2c25a5ed9de3e74b4fde323e77", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3NjEzNQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1624#discussion_r436276135", "bodyText": "curious why you had to cast to (T) here?", "author": "vkryachko", "createdAt": "2020-06-06T15:11:17Z", "path": "encoders/firebase-decoders-json/src/test/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContextTest.java", "diffHunk": "@@ -0,0 +1,137 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders.json;\n+\n+import androidx.annotation.NonNull;\n+\n+import com.google.firebase.decoders.FieldRef;\n+import com.google.firebase.decoders.ObjectDecoder;\n+import com.google.firebase.decoders.ObjectDecoderContext;\n+import com.google.firebase.decoders.Safe;\n+import com.google.firebase.decoders.TypeCreator;\n+import com.google.firebase.decoders.TypeToken;\n+import com.google.firebase.decoders.json.JsonDataDecoderBuilderContext;\n+import com.google.firebase.encoders.FieldDescriptor;\n+import com.google.firebase.encoders.annotations.Encodable;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.junit.Assert.assertThrows;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.robolectric.RobolectricTestRunner;\n+/**\n+ * TODO: TypeToken support TypeVariable, inorder to support decode nested Generic type\n+ * class Foo<T> {\n+ *   SubFoo<T>\n+ * }\n+ */\n+@RunWith(RobolectricTestRunner.class)\n+public class JsonDataDecoderBuilderContextTest {\n+\n+  static class Foo<T> {\n+    int a;\n+    boolean b;\n+    T t;\n+    SubFoo<String> subFoo;\n+\n+    public Foo(int a, boolean b, T t, SubFoo<String> subFoo) {\n+      this.a = a;\n+      this.b = b;\n+      this.t = t;\n+      this.subFoo = subFoo;\n+    }\n+  }\n+\n+  static class SubFoo<T> {\n+    int a;\n+    boolean b;\n+    T t;\n+\n+    public SubFoo(int a, boolean b, T t) {\n+      this.a = a;\n+      this.b = b;\n+      this.t = t;\n+    }\n+  }\n+\n+  static class FooObjectDecoder<T> implements ObjectDecoder<Foo<T>> {\n+    @NonNull\n+    @Override\n+    public TypeCreator<Foo<T>> decode(@NonNull ObjectDecoderContext<Foo<T>> ctx) {\n+      FieldRef.Primitive<Integer> aField = ctx.decodeInteger(FieldDescriptor.of(\"a\"));\n+      FieldRef.Primitive<Boolean> bField = ctx.decodeBoolean(FieldDescriptor.of(\"b\"));\n+      FieldRef.Boxed<T> tField = ctx.decode(FieldDescriptor.of(\"t\"), (TypeToken.ClassToken) ctx.getTypeArguments().at(0));\n+      FieldRef.Boxed<SubFoo<String>> subFooField = ctx.decode(FieldDescriptor.of(\"subFoo\"), TypeToken.of(new Safe<SubFoo<String>>(){}));\n+\n+      return (creationCtx ->\n+              new Foo<T>(\n+                      creationCtx.getInteger(aField),\n+                      creationCtx.getBoolean(bField),\n+                      (T) creationCtx.get(tField),", "originalCommit": "2d18d6ddcb9f5d2c25a5ed9de3e74b4fde323e77", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk0NTgyMg==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1624#discussion_r436945822", "bodyText": "since generic type T in Box<T> is downgrade to Object at runtime, then creationCtx.get(tField) give us an Object type, therefore i have to explicitly cast it to T.\nI will have more investigations on it to see how can I avoid explicitly casting it.", "author": "James201311", "createdAt": "2020-06-08T19:21:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3NjEzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk2MTMyNA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1624#discussion_r436961324", "bodyText": "At runtime sure, but it should not matter at compile time where it is T which is exactly what Foo's constructor expects", "author": "vkryachko", "createdAt": "2020-06-08T19:50:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3NjEzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk2NDU5NA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1624#discussion_r436964594", "bodyText": "Oh, I think I see the problem, you need to remove <T> on CreationContext<T> and make it just CreationContext, without this the TypeCreator interface is defined with a raw type, hence all generics inference gets disabled and .get() return Object instead of T.", "author": "vkryachko", "createdAt": "2020-06-08T19:57:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3NjEzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3NjI2NA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1624#discussion_r436276264", "bodyText": "Did you have to cast to (TypeToken.ClassToken) here? I think the types should align correctly without the cast.", "author": "vkryachko", "createdAt": "2020-06-06T15:13:12Z", "path": "encoders/firebase-decoders-json/src/test/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContextTest.java", "diffHunk": "@@ -0,0 +1,137 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders.json;\n+\n+import androidx.annotation.NonNull;\n+\n+import com.google.firebase.decoders.FieldRef;\n+import com.google.firebase.decoders.ObjectDecoder;\n+import com.google.firebase.decoders.ObjectDecoderContext;\n+import com.google.firebase.decoders.Safe;\n+import com.google.firebase.decoders.TypeCreator;\n+import com.google.firebase.decoders.TypeToken;\n+import com.google.firebase.decoders.json.JsonDataDecoderBuilderContext;\n+import com.google.firebase.encoders.FieldDescriptor;\n+import com.google.firebase.encoders.annotations.Encodable;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.junit.Assert.assertThrows;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.robolectric.RobolectricTestRunner;\n+/**\n+ * TODO: TypeToken support TypeVariable, inorder to support decode nested Generic type\n+ * class Foo<T> {\n+ *   SubFoo<T>\n+ * }\n+ */\n+@RunWith(RobolectricTestRunner.class)\n+public class JsonDataDecoderBuilderContextTest {\n+\n+  static class Foo<T> {\n+    int a;\n+    boolean b;\n+    T t;\n+    SubFoo<String> subFoo;\n+\n+    public Foo(int a, boolean b, T t, SubFoo<String> subFoo) {\n+      this.a = a;\n+      this.b = b;\n+      this.t = t;\n+      this.subFoo = subFoo;\n+    }\n+  }\n+\n+  static class SubFoo<T> {\n+    int a;\n+    boolean b;\n+    T t;\n+\n+    public SubFoo(int a, boolean b, T t) {\n+      this.a = a;\n+      this.b = b;\n+      this.t = t;\n+    }\n+  }\n+\n+  static class FooObjectDecoder<T> implements ObjectDecoder<Foo<T>> {\n+    @NonNull\n+    @Override\n+    public TypeCreator<Foo<T>> decode(@NonNull ObjectDecoderContext<Foo<T>> ctx) {\n+      FieldRef.Primitive<Integer> aField = ctx.decodeInteger(FieldDescriptor.of(\"a\"));\n+      FieldRef.Primitive<Boolean> bField = ctx.decodeBoolean(FieldDescriptor.of(\"b\"));\n+      FieldRef.Boxed<T> tField = ctx.decode(FieldDescriptor.of(\"t\"), (TypeToken.ClassToken) ctx.getTypeArguments().at(0));\n+      FieldRef.Boxed<SubFoo<String>> subFooField = ctx.decode(FieldDescriptor.of(\"subFoo\"), TypeToken.of(new Safe<SubFoo<String>>(){}));\n+\n+      return (creationCtx ->\n+              new Foo<T>(\n+                      creationCtx.getInteger(aField),\n+                      creationCtx.getBoolean(bField),\n+                      (T) creationCtx.get(tField),\n+                      (SubFoo<String>) creationCtx.get(subFooField)\n+                      )\n+      );\n+    }\n+  }\n+\n+  static class SubFooObjectDecoder<T> implements ObjectDecoder<SubFoo<T>> {\n+\n+    @NonNull\n+    @Override\n+    public TypeCreator<SubFoo<T>> decode(@NonNull ObjectDecoderContext<SubFoo<T>> ctx) {\n+      FieldRef.Primitive<Integer> aField = ctx.decodeInteger(FieldDescriptor.of(\"a\"));\n+      FieldRef.Primitive<Boolean> bField = ctx.decodeBoolean(FieldDescriptor.of(\"b\"));\n+      FieldRef.Boxed<T> tField = ctx.decode(FieldDescriptor.of(\"t\"), (TypeToken.ClassToken) ctx.getTypeArguments().at(0));", "originalCommit": "2d18d6ddcb9f5d2c25a5ed9de3e74b4fde323e77", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAyMDU5Mg==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1624#discussion_r437020592", "bodyText": "are these functions (here and below) actually decoding? seems like they are only creating refs.", "author": "rlazo", "createdAt": "2020-06-08T21:48:44Z", "path": "encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/ObjectDecoderContextImpl.java", "diffHunk": "@@ -0,0 +1,81 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders.json;\n+\n+import androidx.annotation.NonNull;\n+\n+import com.google.firebase.decoders.FieldRef;\n+import com.google.firebase.decoders.ObjectDecoderContext;\n+import com.google.firebase.decoders.TypeToken;\n+import com.google.firebase.decoders.TypeTokenContainer;\n+import com.google.firebase.encoders.FieldDescriptor;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class ObjectDecoderContextImpl<T> implements ObjectDecoderContext<T> {\n+  private Map<String, FieldRef<?>> refs = new HashMap<>();\n+  private TypeToken.ClassToken<T> classToken;\n+\n+  @NonNull\n+  public static <T> ObjectDecoderContextImpl<T> of(@NonNull TypeToken.ClassToken<T> classToken) {\n+    return new ObjectDecoderContextImpl<T>(classToken);\n+  }\n+\n+  private ObjectDecoderContextImpl(TypeToken.ClassToken<T> classToken) {\n+    this.classToken = classToken;\n+  }\n+\n+  @NonNull\n+  public FieldRef<?> getFieldRef(@NonNull String fieldName){\n+    return refs.get(fieldName);\n+  }\n+\n+  @NonNull\n+  @Override\n+  public TypeToken.ClassToken<T> getTypeToken() {\n+    return classToken;\n+  }\n+\n+  @NonNull\n+  @Override\n+  public TypeTokenContainer getTypeArguments() {\n+    return classToken.getTypeArguments();\n+  }\n+\n+  @NonNull\n+  @Override\n+  public <TField> FieldRef.Boxed<TField> decode(@NonNull FieldDescriptor fileDescriptor, @NonNull TypeToken<TField> typeToken) {", "originalCommit": "2d18d6ddcb9f5d2c25a5ed9de3e74b4fde323e77", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "54302b819d8c2ef92bdc47226d2f70e99fe8a665", "url": "https://github.com/firebase/firebase-android-sdk/commit/54302b819d8c2ef92bdc47226d2f70e99fe8a665", "message": "init implementation for decoder", "committedDate": "2020-06-10T14:43:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM4MDIwNw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1624#discussion_r438380207", "bodyText": "hm, this does not look right. Capital B Booleans are not primitive, they are boxed booleans that extend java.lang.Object. So you'd want to use boolean.class here, as well as in the rest of primitive methods below.", "author": "vkryachko", "createdAt": "2020-06-10T20:10:03Z", "path": "encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/ObjectDecoderContextImpl.java", "diffHunk": "@@ -0,0 +1,117 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders.json;\n+\n+import androidx.annotation.NonNull;\n+import com.google.firebase.decoders.FieldRef;\n+import com.google.firebase.decoders.ObjectDecoderContext;\n+import com.google.firebase.decoders.TypeToken;\n+import com.google.firebase.decoders.TypeTokenContainer;\n+import com.google.firebase.encoders.FieldDescriptor;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class ObjectDecoderContextImpl<T> implements ObjectDecoderContext<T> {\n+  private Map<String, FieldRef<?>> refs = new HashMap<>();\n+  private TypeToken.ClassToken<T> classToken;\n+\n+  @NonNull\n+  public static <T> ObjectDecoderContextImpl<T> of(@NonNull TypeToken.ClassToken<T> classToken) {\n+    return new ObjectDecoderContextImpl<T>(classToken);\n+  }\n+\n+  private ObjectDecoderContextImpl(TypeToken.ClassToken<T> classToken) {\n+    this.classToken = classToken;\n+  }\n+\n+  @NonNull\n+  FieldRef<?> getFieldRef(@NonNull String fieldName) {\n+    if (refs.containsKey(fieldName)) {\n+      return Objects.requireNonNull(refs.get(fieldName));\n+    } else {\n+      throw new IllegalArgumentException(fieldName + \" was not register in ObjectDecoder.\");\n+    }\n+  }\n+\n+  @NonNull\n+  @Override\n+  public TypeToken.ClassToken<T> getTypeToken() {\n+    return classToken;\n+  }\n+\n+  @NonNull\n+  @Override\n+  public TypeTokenContainer getTypeArguments() {\n+    return classToken.getTypeArguments();\n+  }\n+\n+  @NonNull\n+  @Override\n+  public <TField> FieldRef.Boxed<TField> decode(\n+      @NonNull FieldDescriptor fileDescriptor, @NonNull TypeToken<TField> typeToken) {\n+    FieldRef.Boxed<TField> ref = FieldRef.Boxed.of(typeToken);\n+    refs.put(fileDescriptor.getName(), ref);\n+    return ref;\n+  }\n+\n+  @NonNull\n+  @Override\n+  public FieldRef.Primitive<Boolean> decodeBoolean(@NonNull FieldDescriptor fileDescriptor) {\n+    FieldRef.Primitive<Boolean> ref = FieldRef.Primitive.of(Boolean.class);", "originalCommit": "54302b819d8c2ef92bdc47226d2f70e99fe8a665", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM4MDI2MA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1624#discussion_r438380260", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public FieldRef.Primitive<Short> decodeIShort(@NonNull FieldDescriptor fileDescriptor) {\n          \n          \n            \n              public FieldRef.Primitive<Short> decodeShort(@NonNull FieldDescriptor fileDescriptor) {", "author": "vkryachko", "createdAt": "2020-06-10T20:10:10Z", "path": "encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/ObjectDecoderContextImpl.java", "diffHunk": "@@ -0,0 +1,117 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders.json;\n+\n+import androidx.annotation.NonNull;\n+import com.google.firebase.decoders.FieldRef;\n+import com.google.firebase.decoders.ObjectDecoderContext;\n+import com.google.firebase.decoders.TypeToken;\n+import com.google.firebase.decoders.TypeTokenContainer;\n+import com.google.firebase.encoders.FieldDescriptor;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class ObjectDecoderContextImpl<T> implements ObjectDecoderContext<T> {\n+  private Map<String, FieldRef<?>> refs = new HashMap<>();\n+  private TypeToken.ClassToken<T> classToken;\n+\n+  @NonNull\n+  public static <T> ObjectDecoderContextImpl<T> of(@NonNull TypeToken.ClassToken<T> classToken) {\n+    return new ObjectDecoderContextImpl<T>(classToken);\n+  }\n+\n+  private ObjectDecoderContextImpl(TypeToken.ClassToken<T> classToken) {\n+    this.classToken = classToken;\n+  }\n+\n+  @NonNull\n+  FieldRef<?> getFieldRef(@NonNull String fieldName) {\n+    if (refs.containsKey(fieldName)) {\n+      return Objects.requireNonNull(refs.get(fieldName));\n+    } else {\n+      throw new IllegalArgumentException(fieldName + \" was not register in ObjectDecoder.\");\n+    }\n+  }\n+\n+  @NonNull\n+  @Override\n+  public TypeToken.ClassToken<T> getTypeToken() {\n+    return classToken;\n+  }\n+\n+  @NonNull\n+  @Override\n+  public TypeTokenContainer getTypeArguments() {\n+    return classToken.getTypeArguments();\n+  }\n+\n+  @NonNull\n+  @Override\n+  public <TField> FieldRef.Boxed<TField> decode(\n+      @NonNull FieldDescriptor fileDescriptor, @NonNull TypeToken<TField> typeToken) {\n+    FieldRef.Boxed<TField> ref = FieldRef.Boxed.of(typeToken);\n+    refs.put(fileDescriptor.getName(), ref);\n+    return ref;\n+  }\n+\n+  @NonNull\n+  @Override\n+  public FieldRef.Primitive<Boolean> decodeBoolean(@NonNull FieldDescriptor fileDescriptor) {\n+    FieldRef.Primitive<Boolean> ref = FieldRef.Primitive.of(Boolean.class);\n+    refs.put(fileDescriptor.getName(), ref);\n+    return ref;\n+  }\n+\n+  @NonNull\n+  @Override\n+  public FieldRef.Primitive<Short> decodeIShort(@NonNull FieldDescriptor fileDescriptor) {", "originalCommit": "54302b819d8c2ef92bdc47226d2f70e99fe8a665", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM4MjU3OA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1624#discussion_r438382578", "bodyText": "As we discussed we need to think what to do when these primitives are not present. Not to lose track, a few options that come to mind:\n\nHave the default value stored in the FieldDescriptor\nHave the FieldDescriptor contain a required flag, in which case this method would throw\nHave this method take a default value argument, which will be returned if value not present in the input.", "author": "vkryachko", "createdAt": "2020-06-10T20:15:04Z", "path": "encoders/firebase-decoders-json/src/main/java/com/google/firebase/decoders/CreationContext.java", "diffHunk": "@@ -0,0 +1,48 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders;\n+\n+import androidx.annotation.NonNull;\n+\n+/**\n+ * {@link CreationContext} is used by {@link TypeCreator} to get type-safe data of given {@link\n+ * FieldRef} to create instance of corresponding type.\n+ *\n+ * <p>A class implemented {@link CreationContext} should be initialized to store decoded data of a\n+ * single instance, and should be able to provide type-safe data of given {@link FieldRef}.\n+ */\n+public interface CreationContext {\n+  /** Get type-safe instance of type {@code TField} by given {@code FieldRef.Boxed<TField>} */\n+  @NonNull\n+  <TField> TField get(@NonNull FieldRef.Boxed<TField> ref);\n+\n+  /** Get boolean by given {@code FieldRef.Primitive<Boolean>} */\n+  boolean getBoolean(@NonNull FieldRef.Primitive<Boolean> ref);", "originalCommit": "54302b819d8c2ef92bdc47226d2f70e99fe8a665", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM5OTYxOQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1624#discussion_r438399619", "bodyText": "Exposing this could be \"dangerous\" as I can pass any class and get e.g. a Primitive<List> which is definitely not primitive, would it be possible to have static constants of all primitives we care about, such that we don't expose this method?", "author": "vkryachko", "createdAt": "2020-06-10T20:48:50Z", "path": "encoders/firebase-decoders-json/src/main/java/com/google/firebase/decoders/FieldRef.java", "diffHunk": "@@ -0,0 +1,68 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders;\n+\n+import androidx.annotation.NonNull;\n+\n+// TODO: support required, optional.\n+\n+/**\n+ * {@link FieldRef} act as an wire to put decoded information to {@link ObjectDecoderContext} and\n+ * get decoded information from {@link CreationContext}. It also provide {@link DataDecoder} the\n+ * ability to obtain the data type of nextToken.\n+ */\n+public abstract class FieldRef<T> {\n+\n+  /** Used to represent primitive data type. */\n+  public static class Primitive<T> extends FieldRef<T> {\n+\n+    private Class<T> rawType;\n+\n+    @NonNull\n+    public static <T> Primitive<T> of(@NonNull Class<T> clazz) {", "originalCommit": "54302b819d8c2ef92bdc47226d2f70e99fe8a665", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQwMDY0Ng==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1624#discussion_r438400646", "bodyText": "I think I mentioned it before, but can both Primitive and Boxed have a TypeToken inside for consistence(even though the TypeToken inside of Primitive will be a token of a primitive type)?", "author": "vkryachko", "createdAt": "2020-06-10T20:51:00Z", "path": "encoders/firebase-decoders-json/src/main/java/com/google/firebase/decoders/FieldRef.java", "diffHunk": "@@ -0,0 +1,68 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders;\n+\n+import androidx.annotation.NonNull;\n+\n+// TODO: support required, optional.\n+\n+/**\n+ * {@link FieldRef} act as an wire to put decoded information to {@link ObjectDecoderContext} and\n+ * get decoded information from {@link CreationContext}. It also provide {@link DataDecoder} the\n+ * ability to obtain the data type of nextToken.\n+ */\n+public abstract class FieldRef<T> {\n+\n+  /** Used to represent primitive data type. */\n+  public static class Primitive<T> extends FieldRef<T> {\n+\n+    private Class<T> rawType;", "originalCommit": "54302b819d8c2ef92bdc47226d2f70e99fe8a665", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQwMTA2Ng==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1624#discussion_r438401066", "bodyText": "nit\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public static class Primitive<T> extends FieldRef<T> {\n          \n          \n            \n              public static final class Primitive<T> extends FieldRef<T> {", "author": "vkryachko", "createdAt": "2020-06-10T20:51:47Z", "path": "encoders/firebase-decoders-json/src/main/java/com/google/firebase/decoders/FieldRef.java", "diffHunk": "@@ -0,0 +1,68 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders;\n+\n+import androidx.annotation.NonNull;\n+\n+// TODO: support required, optional.\n+\n+/**\n+ * {@link FieldRef} act as an wire to put decoded information to {@link ObjectDecoderContext} and\n+ * get decoded information from {@link CreationContext}. It also provide {@link DataDecoder} the\n+ * ability to obtain the data type of nextToken.\n+ */\n+public abstract class FieldRef<T> {\n+\n+  /** Used to represent primitive data type. */\n+  public static class Primitive<T> extends FieldRef<T> {", "originalCommit": "54302b819d8c2ef92bdc47226d2f70e99fe8a665", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQwMTE2MQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1624#discussion_r438401161", "bodyText": "nit\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public static class Boxed<T> extends FieldRef<T> {\n          \n          \n            \n              public static final class Boxed<T> extends FieldRef<T> {", "author": "vkryachko", "createdAt": "2020-06-10T20:52:00Z", "path": "encoders/firebase-decoders-json/src/main/java/com/google/firebase/decoders/FieldRef.java", "diffHunk": "@@ -0,0 +1,68 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders;\n+\n+import androidx.annotation.NonNull;\n+\n+// TODO: support required, optional.\n+\n+/**\n+ * {@link FieldRef} act as an wire to put decoded information to {@link ObjectDecoderContext} and\n+ * get decoded information from {@link CreationContext}. It also provide {@link DataDecoder} the\n+ * ability to obtain the data type of nextToken.\n+ */\n+public abstract class FieldRef<T> {\n+\n+  /** Used to represent primitive data type. */\n+  public static class Primitive<T> extends FieldRef<T> {\n+\n+    private Class<T> rawType;\n+\n+    @NonNull\n+    public static <T> Primitive<T> of(@NonNull Class<T> clazz) {\n+      final Primitive<T> ref = new Primitive<>(clazz);\n+      return ref;\n+    }\n+\n+    private Primitive(@NonNull Class<T> rawType) {\n+      this.rawType = rawType;\n+    }\n+\n+    @NonNull\n+    public Class<T> getRawType() {\n+      return rawType;\n+    }\n+  }\n+\n+  /** Use it to represent Boxed Data type */\n+  public static class Boxed<T> extends FieldRef<T> {", "originalCommit": "54302b819d8c2ef92bdc47226d2f70e99fe8a665", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQwMjYwNw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1624#discussion_r438402607", "bodyText": "To make it more ergonomic, can we provide a convenience method like ctx.getTypeArgument(0) instead of exposing the container?\ncontext: https://en.wikipedia.org/wiki/Law_of_Demeter", "author": "vkryachko", "createdAt": "2020-06-10T20:54:47Z", "path": "encoders/firebase-decoders-json/src/main/java/com/google/firebase/decoders/ObjectDecoderContext.java", "diffHunk": "@@ -0,0 +1,89 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders;\n+\n+import androidx.annotation.NonNull;\n+import com.google.firebase.encoders.FieldDescriptor;\n+\n+// TODO: decodeInline() and setUnknownBehavior(), implementation\n+/**\n+ * {@link ObjectDecoderContext} enables {@link ObjectDecoder} to decode objects. {@link\n+ * ObjectDecoder} should keep its decoding logic into a {@link ObjectDecoderContext} where each\n+ * {@link FieldDescriptor} corresponds to a {@link FieldRef}.\n+ */\n+public interface ObjectDecoderContext<T> {\n+\n+  /**\n+   * Get {@link com.google.firebase.decoders.TypeToken.ClassToken} of decoding type {@code T}.\n+   *\n+   * <p>Use it when decode a field which have the same type as the of type {@code T}\n+   *\n+   * <p>For Example:\n+   *\n+   * <p>if a {@code class NodeObjectDecoder<T> implements ObjectDecoder<Node<T>>}, we want to get\n+   * its type token {@code Node<T>}, we will do:\n+   *\n+   * <p>{@code FieldRef.Boxed<Node<T>> nodeField =\n+   * objectDecoderContext.decode(FieldDescriptor.of(\"node\"), objectDecoderContext.getTypeToken()); }\n+   */\n+  @NonNull\n+  TypeToken.ClassToken<T> getTypeToken();\n+\n+  /**\n+   * Get {@link TypeTokenContainer} of decoding type {@code T} if type {@code T} contains type\n+   * arguments, otherwise an empty {@link TypeTokenContainer} will be given.\n+   *\n+   * <p>Use it when decode a field which have the same type as the of type argument of {@code T}\n+   *\n+   * <p>For Example:\n+   *\n+   * <p>if a {@code class NodeObjectDecoder<T> implements ObjectDecoder<Node<T>>}, we want to get\n+   * its type argument {@code T}, we will do:\n+   *\n+   * <p>{@code FieldRef.Boxed<T> tField = ctx.decode(FieldDescriptor.of(\"t\"),\n+   * ctx.getTypeArguments().at(0)); }", "originalCommit": "54302b819d8c2ef92bdc47226d2f70e99fe8a665", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQwNDE0MQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1624#discussion_r438404141", "bodyText": "I think this class only handles non-primitives, so passing in e.g. int.class will throw, am I missing something?", "author": "vkryachko", "createdAt": "2020-06-10T20:57:37Z", "path": "encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java", "diffHunk": "@@ -0,0 +1,150 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders.json;\n+\n+import android.util.JsonReader;\n+import android.util.JsonToken;\n+import androidx.annotation.NonNull;\n+import com.google.firebase.decoders.DataDecoder;\n+import com.google.firebase.decoders.FieldRef;\n+import com.google.firebase.decoders.ObjectDecoder;\n+import com.google.firebase.decoders.TypeCreator;\n+import com.google.firebase.decoders.TypeToken;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class JsonDataDecoderBuilderContext implements DataDecoder {\n+  private Map<Class<?>, ObjectDecoder<?>> objectDecoders = new HashMap<>();\n+  private Map<TypeToken.ClassToken<?>, ObjectDecoderContextImpl<?>> objectDecoderContexts =\n+      new HashMap<>();\n+  private Map<TypeToken.ClassToken<?>, TypeCreator<?>> typeCreators = new HashMap<>();\n+  private JsonReader reader;\n+\n+  JsonDataDecoderBuilderContext(@NonNull Map<Class<?>, ObjectDecoder<?>> objectDecoders) {\n+    this.objectDecoders = objectDecoders;\n+  }\n+\n+  @NonNull\n+  @Override\n+  public <T> T decode(@NonNull InputStream input, @NonNull TypeToken<T> typeToken)\n+      throws IOException {\n+    this.reader = new JsonReader(new InputStreamReader(input, \"UTF-8\"));\n+    return Objects.requireNonNull(decode(typeToken));\n+  }\n+\n+  private <T> T decode(TypeToken<T> typeToken) throws IOException {\n+    if (reader.peek().equals(JsonToken.NULL)) {\n+      reader.nextNull();\n+      return null;\n+    }\n+\n+    if (typeToken instanceof TypeToken.ClassToken) {\n+      TypeToken.ClassToken<T> classToken = (TypeToken.ClassToken<T>) typeToken;\n+      return (T) decodeObject(classToken);\n+    } else if (typeToken instanceof TypeToken.ArrayToken) {\n+      // TODO: Change typeParameter T in ArrayToken<T> to represent component type.\n+      /**\n+       * reader.beginArray(); List<T> l = new LinkedList<>(); while reader.hasNext: T val =\n+       * decode(arrayToken.getComponentType()); l.add(val); reader.endArray(); return l.toArray();\n+       */\n+    }\n+    return null;\n+  }\n+\n+  private <T> T decodeObject(TypeToken.ClassToken<T> classToken) throws IOException {\n+    if (isSingleValue(classToken.getRawType())) return decodeSingleValue(classToken.getRawType());\n+    CreationContextImpl creationCtx = new CreationContextImpl();\n+    ObjectDecoderContextImpl<T> decoderCtx = getObjectDecodersCtx(classToken);\n+    reader.beginObject();\n+    while (reader.hasNext()) {\n+      String fieldName = reader.nextName();\n+      FieldRef<?> fieldRef = decoderCtx.getFieldRef(fieldName);\n+      if (fieldRef instanceof FieldRef.Primitive) {\n+        creationCtx.put(\n+            fieldRef, decodeSingleValue(((FieldRef.Primitive<?>) fieldRef).getRawType()));\n+      } else if (fieldRef instanceof FieldRef.Boxed) {\n+        TypeToken<?> typeToken = ((FieldRef.Boxed<?>) fieldRef).getTypeToken();\n+        creationCtx.put(fieldRef, decode(typeToken));\n+      }\n+    }\n+    reader.endObject();\n+    @SuppressWarnings(\"unchecked\")\n+    // Safe,\n+    // because key and value of objectDecoderContexts always have the same actual type parameter\n+    TypeCreator<T> creator = (TypeCreator<T>) typeCreators.get(classToken);\n+    if (creator == null)\n+      throw new IllegalArgumentException(\n+          \"TypeCreator of \" + classToken.getRawType() + \" is not register.\");\n+    return (T) creator.create(creationCtx);\n+  }\n+\n+  private <T> boolean isSingleValue(Class<T> clazz) {\n+    return clazz.isPrimitive()\n+        || clazz.equals(Character.class)\n+        || clazz.equals(Byte.class)\n+        || clazz.equals(Short.class)\n+        || clazz.equals(Integer.class)\n+        || clazz.equals(Long.class)\n+        || clazz.equals(Float.class)\n+        || clazz.equals(Double.class)\n+        || clazz.equals(String.class)\n+        || clazz.equals(Boolean.class);\n+  }\n+\n+  // TODO: support Date\n+  private <T> T decodeSingleValue(Class<T> clazz) throws IOException {", "originalCommit": "54302b819d8c2ef92bdc47226d2f70e99fe8a665", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQwNDMzNw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1624#discussion_r438404337", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private Map<String, FieldRef<?>> refs = new HashMap<>();\n          \n          \n            \n              private TypeToken.ClassToken<T> classToken;\n          \n          \n            \n              private final Map<String, FieldRef<?>> refs = new HashMap<>();\n          \n          \n            \n              private final TypeToken.ClassToken<T> classToken;", "author": "vkryachko", "createdAt": "2020-06-10T20:57:58Z", "path": "encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/ObjectDecoderContextImpl.java", "diffHunk": "@@ -0,0 +1,117 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders.json;\n+\n+import androidx.annotation.NonNull;\n+import com.google.firebase.decoders.FieldRef;\n+import com.google.firebase.decoders.ObjectDecoderContext;\n+import com.google.firebase.decoders.TypeToken;\n+import com.google.firebase.decoders.TypeTokenContainer;\n+import com.google.firebase.encoders.FieldDescriptor;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class ObjectDecoderContextImpl<T> implements ObjectDecoderContext<T> {\n+  private Map<String, FieldRef<?>> refs = new HashMap<>();\n+  private TypeToken.ClassToken<T> classToken;", "originalCommit": "54302b819d8c2ef92bdc47226d2f70e99fe8a665", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQwNDYwNQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1624#discussion_r438404605", "bodyText": "nit: You don't want to use Objects as it's only available in jdk7+ while we need to support 6+, here and throughout the PR.", "author": "vkryachko", "createdAt": "2020-06-10T20:58:30Z", "path": "encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/ObjectDecoderContextImpl.java", "diffHunk": "@@ -0,0 +1,117 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders.json;\n+\n+import androidx.annotation.NonNull;\n+import com.google.firebase.decoders.FieldRef;\n+import com.google.firebase.decoders.ObjectDecoderContext;\n+import com.google.firebase.decoders.TypeToken;\n+import com.google.firebase.decoders.TypeTokenContainer;\n+import com.google.firebase.encoders.FieldDescriptor;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class ObjectDecoderContextImpl<T> implements ObjectDecoderContext<T> {\n+  private Map<String, FieldRef<?>> refs = new HashMap<>();\n+  private TypeToken.ClassToken<T> classToken;\n+\n+  @NonNull\n+  public static <T> ObjectDecoderContextImpl<T> of(@NonNull TypeToken.ClassToken<T> classToken) {\n+    return new ObjectDecoderContextImpl<T>(classToken);\n+  }\n+\n+  private ObjectDecoderContextImpl(TypeToken.ClassToken<T> classToken) {\n+    this.classToken = classToken;\n+  }\n+\n+  @NonNull\n+  FieldRef<?> getFieldRef(@NonNull String fieldName) {\n+    if (refs.containsKey(fieldName)) {\n+      return Objects.requireNonNull(refs.get(fieldName));", "originalCommit": "54302b819d8c2ef92bdc47226d2f70e99fe8a665", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQwNTMwMQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1624#discussion_r438405301", "bodyText": "Could you rename this test into something more descriptive of its intent?", "author": "vkryachko", "createdAt": "2020-06-10T21:00:00Z", "path": "encoders/firebase-decoders-json/src/test/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContextTest.java", "diffHunk": "@@ -0,0 +1,188 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders.json;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import androidx.annotation.NonNull;\n+import com.google.firebase.decoders.FieldRef;\n+import com.google.firebase.decoders.ObjectDecoder;\n+import com.google.firebase.decoders.ObjectDecoderContext;\n+import com.google.firebase.decoders.Safe;\n+import com.google.firebase.decoders.TypeCreator;\n+import com.google.firebase.decoders.TypeToken;\n+import com.google.firebase.encoders.FieldDescriptor;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.RobolectricTestRunner;\n+\n+@RunWith(RobolectricTestRunner.class)\n+public class JsonDataDecoderBuilderContextTest {\n+\n+  static class Foo<T> {\n+    int a;\n+    boolean b;\n+    T t;\n+    SubFoo<String> subFoo;\n+\n+    Foo(int a, boolean b, T t, SubFoo<String> subFoo) {\n+      this.a = a;\n+      this.b = b;\n+      this.t = t;\n+      this.subFoo = subFoo;\n+    }\n+  }\n+\n+  static class SubFoo<T> {\n+    int a;\n+    boolean b;\n+    T t;\n+\n+    SubFoo(int a, boolean b, T t) {\n+      this.a = a;\n+      this.b = b;\n+      this.t = t;\n+    }\n+  }\n+\n+  static class FooObjectDecoder<T> implements ObjectDecoder<Foo<T>> {\n+    @NonNull\n+    @Override\n+    public TypeCreator<Foo<T>> decode(@NonNull ObjectDecoderContext<Foo<T>> ctx) {\n+      FieldRef.Primitive<Integer> aField = ctx.decodeInteger(FieldDescriptor.of(\"a\"));\n+      FieldRef.Primitive<Boolean> bField = ctx.decodeBoolean(FieldDescriptor.of(\"b\"));\n+      FieldRef.Boxed<T> tField = ctx.decode(FieldDescriptor.of(\"t\"), ctx.getTypeArguments().at(0));\n+      FieldRef.Boxed<SubFoo<String>> subFooField =\n+          ctx.decode(FieldDescriptor.of(\"subFoo\"), TypeToken.of(new Safe<SubFoo<String>>() {}));\n+\n+      return (creationCtx ->\n+          new Foo<T>(\n+              creationCtx.getInteger(aField),\n+              creationCtx.getBoolean(bField),\n+              (T) creationCtx.get(tField),\n+              (SubFoo<String>) creationCtx.get(subFooField)));\n+    }\n+  }\n+\n+  static class SubFooObjectDecoder<T> implements ObjectDecoder<SubFoo<T>> {\n+\n+    @NonNull\n+    @Override\n+    public TypeCreator<SubFoo<T>> decode(@NonNull ObjectDecoderContext<SubFoo<T>> ctx) {\n+      FieldRef.Primitive<Integer> aField = ctx.decodeInteger(FieldDescriptor.of(\"a\"));\n+      FieldRef.Primitive<Boolean> bField = ctx.decodeBoolean(FieldDescriptor.of(\"b\"));\n+      FieldRef.Boxed<T> tField = ctx.decode(FieldDescriptor.of(\"t\"), ctx.getTypeArguments().at(0));\n+\n+      return (creationCtx ->\n+          new SubFoo<T>(\n+              creationCtx.getInteger(aField),\n+              creationCtx.getBoolean(bField),\n+              creationCtx.get(tField)));\n+    }\n+  }\n+\n+  @Test\n+  public <T> void test123() throws IOException {", "originalCommit": "54302b819d8c2ef92bdc47226d2f70e99fe8a665", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b70cb476d93faf64fc4e1bac57fad3f4961953f4", "url": "https://github.com/firebase/firebase-android-sdk/commit/b70cb476d93faf64fc4e1bac57fad3f4961953f4", "message": "init implementation for decoder", "committedDate": "2020-06-11T20:27:13Z", "type": "forcePushed"}, {"oid": "b2c216809523c5e5acf1f84d7c93c605ee346b81", "url": "https://github.com/firebase/firebase-android-sdk/commit/b2c216809523c5e5acf1f84d7c93c605ee346b81", "message": "init implementation for decoder", "committedDate": "2020-06-11T22:16:24Z", "type": "commit"}, {"oid": "5b0f3553e616bc32bba2285bf12af1bff3a46c17", "url": "https://github.com/firebase/firebase-android-sdk/commit/5b0f3553e616bc32bba2285bf12af1bff3a46c17", "message": "address comments", "committedDate": "2020-06-11T22:26:23Z", "type": "commit"}, {"oid": "5b0f3553e616bc32bba2285bf12af1bff3a46c17", "url": "https://github.com/firebase/firebase-android-sdk/commit/5b0f3553e616bc32bba2285bf12af1bff3a46c17", "message": "address comments", "committedDate": "2020-06-11T22:26:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQxNTQ4MA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1624#discussion_r439415480", "bodyText": "Since these auto-box anyway, consider removing these methods altogether for now.", "author": "vkryachko", "createdAt": "2020-06-12T13:23:40Z", "path": "encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/CreationContextImpl.java", "diffHunk": "@@ -0,0 +1,101 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders.json;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import com.google.firebase.decoders.CreationContext;\n+import com.google.firebase.decoders.FieldRef;\n+import java.util.HashMap;\n+\n+public class CreationContextImpl implements CreationContext {\n+  private HashMap<FieldRef<?>, Object> ctx = new HashMap<>();\n+\n+  CreationContextImpl() {}\n+\n+  void put(@NonNull FieldRef<?> ref, @Nullable Object val) {\n+    ctx.put(ref, val);\n+  }\n+\n+  // TODO: avoid auto-boxing for all primitive types\n+  void put(@NonNull FieldRef<?> ref, int val) {\n+    ctx.put(ref, val);\n+  }\n+\n+  void put(@NonNull FieldRef<?> ref, short val) {\n+    ctx.put(ref, val);\n+  }\n+\n+  void put(@NonNull FieldRef<?> ref, long val) {\n+    ctx.put(ref, val);\n+  }\n+\n+  void put(@NonNull FieldRef<?> ref, float val) {\n+    ctx.put(ref, val);\n+  }\n+\n+  void put(@NonNull FieldRef<?> ref, double val) {\n+    ctx.put(ref, val);\n+  }\n+\n+  void put(@NonNull FieldRef<?> ref, boolean val) {\n+    ctx.put(ref, val);\n+  }", "originalCommit": "5b0f3553e616bc32bba2285bf12af1bff3a46c17", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQxNzIwMg==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1624#discussion_r439417202", "bodyText": "nit, pls make them all final, otherwise anyone can reassign them.", "author": "vkryachko", "createdAt": "2020-06-12T13:27:02Z", "path": "encoders/firebase-decoders-json/src/main/java/com/google/firebase/decoders/FieldRef.java", "diffHunk": "@@ -0,0 +1,77 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders;\n+\n+import androidx.annotation.NonNull;\n+\n+// TODO: support required, optional.\n+\n+/**\n+ * {@link FieldRef} act as an wire to put decoded information to {@link ObjectDecoderContext} and\n+ * get decoded information from {@link CreationContext}. It also provide {@link DataDecoder} the\n+ * ability to obtain the data type of nextToken.\n+ */\n+public abstract class FieldRef<T> {\n+  private TypeToken<T> typeToken;\n+\n+  @NonNull\n+  public abstract TypeToken<T> getTypeToken();\n+\n+  /** Used to represent primitive data type. */\n+  public static final class Primitive<T> extends FieldRef<T> {\n+    @NonNull public static Primitive<Integer> INT = new Primitive<>(TypeToken.of(int.class));", "originalCommit": "5b0f3553e616bc32bba2285bf12af1bff3a46c17", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQxOTQzOQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1624#discussion_r439419439", "bodyText": "Additionally, I'd suggest you move these constants out into FieldRef itself, and also move Boxed#of() into FieldRef as sell. It will make the public interface to FieldRefs less hierarchical which might make it simpler, i.e.:\nclass FieldRef<T> {\n  static Primitive<Boolean> BOOLEAN = //...;\n  static Primitive<Short> SHORT = //...;\n  // etc,\n  static Boxed<T> of(TypeToken<T> token) {}\n}", "author": "vkryachko", "createdAt": "2020-06-12T13:30:55Z", "path": "encoders/firebase-decoders-json/src/main/java/com/google/firebase/decoders/FieldRef.java", "diffHunk": "@@ -0,0 +1,77 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders;\n+\n+import androidx.annotation.NonNull;\n+\n+// TODO: support required, optional.\n+\n+/**\n+ * {@link FieldRef} act as an wire to put decoded information to {@link ObjectDecoderContext} and\n+ * get decoded information from {@link CreationContext}. It also provide {@link DataDecoder} the\n+ * ability to obtain the data type of nextToken.\n+ */\n+public abstract class FieldRef<T> {\n+  private TypeToken<T> typeToken;\n+\n+  @NonNull\n+  public abstract TypeToken<T> getTypeToken();\n+\n+  /** Used to represent primitive data type. */\n+  public static final class Primitive<T> extends FieldRef<T> {\n+    @NonNull public static Primitive<Integer> INT = new Primitive<>(TypeToken.of(int.class));", "originalCommit": "5b0f3553e616bc32bba2285bf12af1bff3a46c17", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQxOTg2Ng==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1624#discussion_r439419866", "bodyText": "let's make a precondition check that typeToken is not in fact primitive and throw IllegalArgumentException if it is, wdyt?", "author": "vkryachko", "createdAt": "2020-06-12T13:31:40Z", "path": "encoders/firebase-decoders-json/src/main/java/com/google/firebase/decoders/FieldRef.java", "diffHunk": "@@ -0,0 +1,77 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders;\n+\n+import androidx.annotation.NonNull;\n+\n+// TODO: support required, optional.\n+\n+/**\n+ * {@link FieldRef} act as an wire to put decoded information to {@link ObjectDecoderContext} and\n+ * get decoded information from {@link CreationContext}. It also provide {@link DataDecoder} the\n+ * ability to obtain the data type of nextToken.\n+ */\n+public abstract class FieldRef<T> {\n+  private TypeToken<T> typeToken;\n+\n+  @NonNull\n+  public abstract TypeToken<T> getTypeToken();\n+\n+  /** Used to represent primitive data type. */\n+  public static final class Primitive<T> extends FieldRef<T> {\n+    @NonNull public static Primitive<Integer> INT = new Primitive<>(TypeToken.of(int.class));\n+\n+    @NonNull\n+    public static Primitive<Boolean> BOOLEAN = new Primitive<>(TypeToken.of(boolean.class));\n+\n+    @NonNull public static Primitive<Short> SHORT = new Primitive<>(TypeToken.of(short.class));\n+\n+    @NonNull public static Primitive<Long> LONG = new Primitive<>(TypeToken.of(long.class));\n+\n+    @NonNull public static Primitive<Float> FLOAT = new Primitive<>(TypeToken.of(float.class));\n+\n+    @NonNull public static Primitive<Double> DOUBLE = new Primitive<>(TypeToken.of(double.class));\n+\n+    @NonNull public static Primitive<Character> CHAR = new Primitive<>(TypeToken.of(char.class));\n+\n+    private Primitive(@NonNull TypeToken<T> typeToken) {\n+      super.typeToken = typeToken;\n+    }\n+\n+    @NonNull\n+    @Override\n+    public TypeToken<T> getTypeToken() {\n+      return super.typeToken;\n+    }\n+  }\n+\n+  /** Use it to represent Boxed Data type */\n+  public static final class Boxed<T> extends FieldRef<T> {\n+    @NonNull\n+    public static <T> Boxed<T> of(@NonNull TypeToken<T> typeToken) {\n+      return new Boxed<T>(typeToken);\n+    }\n+\n+    private Boxed(@NonNull TypeToken<T> typeToken) {\n+      super.typeToken = typeToken;", "originalCommit": "5b0f3553e616bc32bba2285bf12af1bff3a46c17", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ2NDkwNQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1624#discussion_r439464905", "bodyText": "I agree! this way we can ensure Boxed only contains non-primitive types and force to create Primitive by a pre-defined constant value.", "author": "James201311", "createdAt": "2020-06-12T14:48:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQxOTg2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ4MDg4Nw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1624#discussion_r439480887", "bodyText": "\ud83d\udc4d can you also add a test for it?", "author": "vkryachko", "createdAt": "2020-06-12T15:14:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQxOTg2Ng=="}], "type": "inlineReview"}, {"oid": "55c4da8a93a816aef97abe566a1b1e24431511dc", "url": "https://github.com/firebase/firebase-android-sdk/commit/55c4da8a93a816aef97abe566a1b1e24431511dc", "message": "address comment", "committedDate": "2020-06-12T15:08:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ4MDIzOA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1624#discussion_r439480238", "bodyText": "looks like you forgot to move INT", "author": "vkryachko", "createdAt": "2020-06-12T15:13:27Z", "path": "encoders/firebase-decoders-json/src/main/java/com/google/firebase/decoders/FieldRef.java", "diffHunk": "@@ -29,22 +29,29 @@\n   @NonNull\n   public abstract TypeToken<T> getTypeToken();\n \n-  /** Used to represent primitive data type. */\n-  public static final class Primitive<T> extends FieldRef<T> {\n-    @NonNull public static Primitive<Integer> INT = new Primitive<>(TypeToken.of(int.class));\n+  @NonNull\n+  public static final Primitive<Boolean> BOOLEAN = new Primitive<>(TypeToken.of(boolean.class));\n \n-    @NonNull\n-    public static Primitive<Boolean> BOOLEAN = new Primitive<>(TypeToken.of(boolean.class));\n+  @NonNull public static final Primitive<Short> SHORT = new Primitive<>(TypeToken.of(short.class));\n \n-    @NonNull public static Primitive<Short> SHORT = new Primitive<>(TypeToken.of(short.class));\n+  @NonNull public static final Primitive<Long> LONG = new Primitive<>(TypeToken.of(long.class));\n \n-    @NonNull public static Primitive<Long> LONG = new Primitive<>(TypeToken.of(long.class));\n+  @NonNull public static final Primitive<Float> FLOAT = new Primitive<>(TypeToken.of(float.class));\n \n-    @NonNull public static Primitive<Float> FLOAT = new Primitive<>(TypeToken.of(float.class));\n+  @NonNull\n+  public static final Primitive<Double> DOUBLE = new Primitive<>(TypeToken.of(double.class));\n \n-    @NonNull public static Primitive<Double> DOUBLE = new Primitive<>(TypeToken.of(double.class));\n+  @NonNull\n+  public static final Primitive<Character> CHAR = new Primitive<>(TypeToken.of(char.class));\n \n-    @NonNull public static Primitive<Character> CHAR = new Primitive<>(TypeToken.of(char.class));\n+  @NonNull\n+  public static <T> Boxed<T> of(@NonNull TypeToken<T> typeToken) {\n+    return new Boxed<T>(typeToken);\n+  }\n+\n+  /** Used to represent primitive data type. */\n+  public static final class Primitive<T> extends FieldRef<T> {\n+    @NonNull public static Primitive<Integer> INT = new Primitive<>(TypeToken.of(int.class));", "originalCommit": "55c4da8a93a816aef97abe566a1b1e24431511dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f09389179539975328e774c975ccdb8a5ca7c25f", "url": "https://github.com/firebase/firebase-android-sdk/commit/f09389179539975328e774c975ccdb8a5ca7c25f", "message": "added test for Field Ref", "committedDate": "2020-06-12T15:26:58Z", "type": "commit"}, {"oid": "d6f2af3e7bbd3b9cb8762cdd2da30e654c7f23d6", "url": "https://github.com/firebase/firebase-android-sdk/commit/d6f2af3e7bbd3b9cb8762cdd2da30e654c7f23d6", "message": "updated api file", "committedDate": "2020-06-15T13:57:58Z", "type": "commit"}, {"oid": "ba070162cdc0635f0db1940d95c35f8b761f877a", "url": "https://github.com/firebase/firebase-android-sdk/commit/ba070162cdc0635f0db1940d95c35f8b761f877a", "message": "updated api file", "committedDate": "2020-06-15T14:01:50Z", "type": "commit"}]}