{"pr_number": 1157, "pr_title": "Adding Proto-based equality and comparison", "pr_createdAt": "2020-01-23T16:51:56Z", "pr_url": "https://github.com/firebase/firebase-android-sdk/pull/1157", "timeline": [{"oid": "5d3f44dbe37c5ef91bb90e4ad6fbf9e71e68f2d3", "url": "https://github.com/firebase/firebase-android-sdk/commit/5d3f44dbe37c5ef91bb90e4ad6fbf9e71e68f2d3", "message": "Adding Proto-based equality and comparison\n\nThis will be used (and tested) in the follow-up CL that adds the FieldValue tpes.", "committedDate": "2020-01-23T16:50:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI5MTg0OQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1157#discussion_r370291849", "bodyText": "Same comment about naming: how about ProtoValues?", "author": "wilhuff", "createdAt": "2020-01-23T18:47:10Z", "path": "firebase-firestore/src/main/java/com/google/firebase/firestore/util/ProtoValueUtil.java", "diffHunk": "@@ -0,0 +1,266 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.firestore.util;\n+\n+import static com.google.firebase.firestore.util.Assert.fail;\n+import static com.google.firebase.firestore.util.Assert.hardAssert;\n+\n+import androidx.annotation.Nullable;\n+import com.google.common.base.Splitter;\n+import com.google.firebase.firestore.model.value.FieldValue;\n+import com.google.firestore.v1.ArrayValue;\n+import com.google.firestore.v1.MapValue;\n+import com.google.firestore.v1.Value;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+public class ProtoValueUtil {", "originalCommit": "5d3f44dbe37c5ef91bb90e4ad6fbf9e71e68f2d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMwMjQzNw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1157#discussion_r370302437", "bodyText": "Renamed", "author": "schmidt-sebastian", "createdAt": "2020-01-23T19:09:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI5MTg0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI5MjQwNg==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1157#discussion_r370292406", "bodyText": "Putting this class in the util package creates a cyclic reference between packages that isn't going to work in C++. Since we're using these utilities in the service of building models, might as well just put this in the model package.", "author": "wilhuff", "createdAt": "2020-01-23T18:48:12Z", "path": "firebase-firestore/src/main/java/com/google/firebase/firestore/util/ProtoValueUtil.java", "diffHunk": "@@ -0,0 +1,266 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.firestore.util;\n+\n+import static com.google.firebase.firestore.util.Assert.fail;\n+import static com.google.firebase.firestore.util.Assert.hardAssert;\n+\n+import androidx.annotation.Nullable;\n+import com.google.common.base.Splitter;\n+import com.google.firebase.firestore.model.value.FieldValue;\n+import com.google.firestore.v1.ArrayValue;\n+import com.google.firestore.v1.MapValue;\n+import com.google.firestore.v1.Value;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+public class ProtoValueUtil {\n+\n+  public static int typeOrder(Value value) {\n+\n+    switch (value.getValueTypeCase()) {\n+      case NULL_VALUE:\n+        return FieldValue.TYPE_ORDER_NULL;", "originalCommit": "5d3f44dbe37c5ef91bb90e4ad6fbf9e71e68f2d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMwMzc3NA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1157#discussion_r370303774", "bodyText": "Done. I believe that means that this class can then be package-private. I did not yet make it so since my next PR temporarily adds a new package for the new ObjectValue to avoid breaking all existing code. Added a TODO to change the visibility.", "author": "schmidt-sebastian", "createdAt": "2020-01-23T19:12:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI5MjQwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI5MzE2Ng==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1157#discussion_r370293166", "bodyText": "Nit: consider ordering the switch cases consistently so that it's easier to audit/reason about differences (in this case, that would mean number, array, object).", "author": "wilhuff", "createdAt": "2020-01-23T18:49:56Z", "path": "firebase-firestore/src/main/java/com/google/firebase/firestore/util/ProtoValueUtil.java", "diffHunk": "@@ -0,0 +1,266 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.firestore.util;\n+\n+import static com.google.firebase.firestore.util.Assert.fail;\n+import static com.google.firebase.firestore.util.Assert.hardAssert;\n+\n+import androidx.annotation.Nullable;\n+import com.google.common.base.Splitter;\n+import com.google.firebase.firestore.model.value.FieldValue;\n+import com.google.firestore.v1.ArrayValue;\n+import com.google.firestore.v1.MapValue;\n+import com.google.firestore.v1.Value;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+public class ProtoValueUtil {\n+\n+  public static int typeOrder(Value value) {\n+\n+    switch (value.getValueTypeCase()) {\n+      case NULL_VALUE:\n+        return FieldValue.TYPE_ORDER_NULL;\n+      case BOOLEAN_VALUE:\n+        return FieldValue.TYPE_ORDER_BOOLEAN;\n+      case INTEGER_VALUE:\n+        return FieldValue.TYPE_ORDER_NUMBER;\n+      case DOUBLE_VALUE:\n+        return FieldValue.TYPE_ORDER_NUMBER;\n+      case TIMESTAMP_VALUE:\n+        return FieldValue.TYPE_ORDER_TIMESTAMP;\n+      case STRING_VALUE:\n+        return FieldValue.TYPE_ORDER_STRING;\n+      case BYTES_VALUE:\n+        return FieldValue.TYPE_ORDER_BLOB;\n+      case REFERENCE_VALUE:\n+        return FieldValue.TYPE_ORDER_REFERENCE;\n+      case GEO_POINT_VALUE:\n+        return FieldValue.TYPE_ORDER_GEOPOINT;\n+      case ARRAY_VALUE:\n+        return FieldValue.TYPE_ORDER_ARRAY;\n+      case MAP_VALUE:\n+        return FieldValue.TYPE_ORDER_OBJECT;\n+      default:\n+        throw fail(\"Invalid value type: \" + value.getValueTypeCase());\n+    }\n+  }\n+\n+  /** Returns whether `value` is non-null and corresponds to the given type order. */\n+  public static boolean isType(@Nullable Value value, int typeOrder) {\n+    return value != null && typeOrder(value) == typeOrder;\n+  }\n+\n+  public static boolean equals(Value left, Value right) {\n+    int leftType = typeOrder(left);\n+    int rightType = typeOrder(right);\n+    if (leftType != rightType) {\n+      return false;\n+    }\n+\n+    switch (leftType) {\n+      case FieldValue.TYPE_ORDER_ARRAY:\n+        return arrayEquals(left, right);\n+      case FieldValue.TYPE_ORDER_NUMBER:", "originalCommit": "5d3f44dbe37c5ef91bb90e4ad6fbf9e71e68f2d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMwMzk0MA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1157#discussion_r370303940", "bodyText": "Done (here and everywhere). I am following the type order constants.", "author": "schmidt-sebastian", "createdAt": "2020-01-23T19:12:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI5MzE2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI5MzU2MQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1157#discussion_r370293561", "bodyText": "Nit: consider ordering these methods in the file in the order you're using them in equals, above.", "author": "wilhuff", "createdAt": "2020-01-23T18:50:43Z", "path": "firebase-firestore/src/main/java/com/google/firebase/firestore/util/ProtoValueUtil.java", "diffHunk": "@@ -0,0 +1,266 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.firestore.util;\n+\n+import static com.google.firebase.firestore.util.Assert.fail;\n+import static com.google.firebase.firestore.util.Assert.hardAssert;\n+\n+import androidx.annotation.Nullable;\n+import com.google.common.base.Splitter;\n+import com.google.firebase.firestore.model.value.FieldValue;\n+import com.google.firestore.v1.ArrayValue;\n+import com.google.firestore.v1.MapValue;\n+import com.google.firestore.v1.Value;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+public class ProtoValueUtil {\n+\n+  public static int typeOrder(Value value) {\n+\n+    switch (value.getValueTypeCase()) {\n+      case NULL_VALUE:\n+        return FieldValue.TYPE_ORDER_NULL;\n+      case BOOLEAN_VALUE:\n+        return FieldValue.TYPE_ORDER_BOOLEAN;\n+      case INTEGER_VALUE:\n+        return FieldValue.TYPE_ORDER_NUMBER;\n+      case DOUBLE_VALUE:\n+        return FieldValue.TYPE_ORDER_NUMBER;\n+      case TIMESTAMP_VALUE:\n+        return FieldValue.TYPE_ORDER_TIMESTAMP;\n+      case STRING_VALUE:\n+        return FieldValue.TYPE_ORDER_STRING;\n+      case BYTES_VALUE:\n+        return FieldValue.TYPE_ORDER_BLOB;\n+      case REFERENCE_VALUE:\n+        return FieldValue.TYPE_ORDER_REFERENCE;\n+      case GEO_POINT_VALUE:\n+        return FieldValue.TYPE_ORDER_GEOPOINT;\n+      case ARRAY_VALUE:\n+        return FieldValue.TYPE_ORDER_ARRAY;\n+      case MAP_VALUE:\n+        return FieldValue.TYPE_ORDER_OBJECT;\n+      default:\n+        throw fail(\"Invalid value type: \" + value.getValueTypeCase());\n+    }\n+  }\n+\n+  /** Returns whether `value` is non-null and corresponds to the given type order. */\n+  public static boolean isType(@Nullable Value value, int typeOrder) {\n+    return value != null && typeOrder(value) == typeOrder;\n+  }\n+\n+  public static boolean equals(Value left, Value right) {\n+    int leftType = typeOrder(left);\n+    int rightType = typeOrder(right);\n+    if (leftType != rightType) {\n+      return false;\n+    }\n+\n+    switch (leftType) {\n+      case FieldValue.TYPE_ORDER_ARRAY:\n+        return arrayEquals(left, right);\n+      case FieldValue.TYPE_ORDER_NUMBER:\n+        return numberEquals(left, right);\n+      case FieldValue.TYPE_ORDER_OBJECT:\n+        return objectEquals(left, right);\n+      default:\n+        return left.equals(right);\n+    }\n+  }\n+\n+  private static boolean objectEquals(Value left, Value right) {", "originalCommit": "5d3f44dbe37c5ef91bb90e4ad6fbf9e71e68f2d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMwMzk5OA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1157#discussion_r370303998", "bodyText": "Done", "author": "schmidt-sebastian", "createdAt": "2020-01-23T19:13:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI5MzU2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI5NTQxNg==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1157#discussion_r370295416", "bodyText": "Nit: consider ordering these to match their usage above.", "author": "wilhuff", "createdAt": "2020-01-23T18:54:39Z", "path": "firebase-firestore/src/main/java/com/google/firebase/firestore/util/ProtoValueUtil.java", "diffHunk": "@@ -0,0 +1,266 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.firestore.util;\n+\n+import static com.google.firebase.firestore.util.Assert.fail;\n+import static com.google.firebase.firestore.util.Assert.hardAssert;\n+\n+import androidx.annotation.Nullable;\n+import com.google.common.base.Splitter;\n+import com.google.firebase.firestore.model.value.FieldValue;\n+import com.google.firestore.v1.ArrayValue;\n+import com.google.firestore.v1.MapValue;\n+import com.google.firestore.v1.Value;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+public class ProtoValueUtil {\n+\n+  public static int typeOrder(Value value) {\n+\n+    switch (value.getValueTypeCase()) {\n+      case NULL_VALUE:\n+        return FieldValue.TYPE_ORDER_NULL;\n+      case BOOLEAN_VALUE:\n+        return FieldValue.TYPE_ORDER_BOOLEAN;\n+      case INTEGER_VALUE:\n+        return FieldValue.TYPE_ORDER_NUMBER;\n+      case DOUBLE_VALUE:\n+        return FieldValue.TYPE_ORDER_NUMBER;\n+      case TIMESTAMP_VALUE:\n+        return FieldValue.TYPE_ORDER_TIMESTAMP;\n+      case STRING_VALUE:\n+        return FieldValue.TYPE_ORDER_STRING;\n+      case BYTES_VALUE:\n+        return FieldValue.TYPE_ORDER_BLOB;\n+      case REFERENCE_VALUE:\n+        return FieldValue.TYPE_ORDER_REFERENCE;\n+      case GEO_POINT_VALUE:\n+        return FieldValue.TYPE_ORDER_GEOPOINT;\n+      case ARRAY_VALUE:\n+        return FieldValue.TYPE_ORDER_ARRAY;\n+      case MAP_VALUE:\n+        return FieldValue.TYPE_ORDER_OBJECT;\n+      default:\n+        throw fail(\"Invalid value type: \" + value.getValueTypeCase());\n+    }\n+  }\n+\n+  /** Returns whether `value` is non-null and corresponds to the given type order. */\n+  public static boolean isType(@Nullable Value value, int typeOrder) {\n+    return value != null && typeOrder(value) == typeOrder;\n+  }\n+\n+  public static boolean equals(Value left, Value right) {\n+    int leftType = typeOrder(left);\n+    int rightType = typeOrder(right);\n+    if (leftType != rightType) {\n+      return false;\n+    }\n+\n+    switch (leftType) {\n+      case FieldValue.TYPE_ORDER_ARRAY:\n+        return arrayEquals(left, right);\n+      case FieldValue.TYPE_ORDER_NUMBER:\n+        return numberEquals(left, right);\n+      case FieldValue.TYPE_ORDER_OBJECT:\n+        return objectEquals(left, right);\n+      default:\n+        return left.equals(right);\n+    }\n+  }\n+\n+  private static boolean objectEquals(Value left, Value right) {\n+    MapValue leftMap = left.getMapValue();\n+    MapValue rightMap = right.getMapValue();\n+\n+    if (leftMap.getFieldsCount() != rightMap.getFieldsCount()) {\n+      return false;\n+    }\n+\n+    for (Map.Entry<String, Value> entry : leftMap.getFieldsMap().entrySet()) {\n+      Value otherEntry = rightMap.getFieldsMap().get(entry.getKey());\n+      if (!entry.getValue().equals(otherEntry)) {\n+        return false;\n+      }\n+    }\n+\n+    return true;\n+  }\n+\n+  private static boolean numberEquals(Value left, Value right) {\n+    if (left.getValueTypeCase() == Value.ValueTypeCase.INTEGER_VALUE\n+        && right.getValueTypeCase() == Value.ValueTypeCase.INTEGER_VALUE) {\n+      return left.equals(right);\n+    } else if (left.getValueTypeCase() == Value.ValueTypeCase.DOUBLE_VALUE\n+        && right.getValueTypeCase() == Value.ValueTypeCase.DOUBLE_VALUE) {\n+      return Double.doubleToLongBits(left.getDoubleValue())\n+          == Double.doubleToLongBits(right.getDoubleValue());\n+    }\n+\n+    return false;\n+  }\n+\n+  private static boolean arrayEquals(Value left, Value right) {\n+    ArrayValue leftArray = left.getArrayValue();\n+    ArrayValue rightArray = right.getArrayValue();\n+\n+    if (leftArray.getValuesCount() != rightArray.getValuesCount()) {\n+      return false;\n+    }\n+\n+    for (int i = 0; i < leftArray.getValuesCount(); ++i) {\n+      if (!equals(leftArray.getValues(i), rightArray.getValues(i))) {\n+        return false;\n+      }\n+    }\n+\n+    return true;\n+  }\n+\n+  public static int compare(Value left, Value right) {\n+    int leftType = typeOrder(left);\n+    int rightType = typeOrder(right);\n+\n+    if (leftType != rightType) {\n+      return Util.compareIntegers(leftType, rightType);\n+    }\n+\n+    switch (leftType) {\n+      case FieldValue.TYPE_ORDER_NULL:\n+        return 0;\n+      case FieldValue.TYPE_ORDER_BOOLEAN:\n+        return Util.compareBooleans(left.getBooleanValue(), right.getBooleanValue());\n+      case FieldValue.TYPE_ORDER_NUMBER:\n+        return compareNumbers(left, right);\n+      case FieldValue.TYPE_ORDER_TIMESTAMP:\n+        return compareTimestamps(left, right);\n+      case FieldValue.TYPE_ORDER_STRING:\n+        return left.getStringValue().compareTo(right.getStringValue());\n+      case FieldValue.TYPE_ORDER_BLOB:\n+        return Util.compareByteString(left.getBytesValue(), right.getBytesValue());\n+      case FieldValue.TYPE_ORDER_REFERENCE:\n+        return compareReferences(left, right);\n+      case FieldValue.TYPE_ORDER_GEOPOINT:\n+        return compareGeoPoints(left, right);\n+      case FieldValue.TYPE_ORDER_ARRAY:\n+        return compareArrays(left, right);\n+      case FieldValue.TYPE_ORDER_OBJECT:\n+        return compareMaps(left, right);\n+      default:\n+        throw fail(\"Invalid value type: \" + leftType);\n+    }\n+  }\n+\n+  private static int compareMaps(Value left, Value right) {", "originalCommit": "5d3f44dbe37c5ef91bb90e4ad6fbf9e71e68f2d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMwNDA3Mg==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1157#discussion_r370304072", "bodyText": "Done", "author": "schmidt-sebastian", "createdAt": "2020-01-23T19:13:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI5NTQxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI5Njg1Mg==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1157#discussion_r370296852", "bodyText": "You could express this with less code if you handled all the unexpected cases in one place, below:\nif (left is double) {\n  if (right is double) {\n    return ...;\n  } else if (right is int) {\n    return ...;\n  }\n} else if (left is int) {\n  if (right is double) {\n    return ...;\n  } else if (right is int) {\n    return ...;\n  }\n}\n\nhardAssert(\"Unexpected types %s and %s, left, right);", "author": "wilhuff", "createdAt": "2020-01-23T18:57:47Z", "path": "firebase-firestore/src/main/java/com/google/firebase/firestore/util/ProtoValueUtil.java", "diffHunk": "@@ -0,0 +1,266 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.firestore.util;\n+\n+import static com.google.firebase.firestore.util.Assert.fail;\n+import static com.google.firebase.firestore.util.Assert.hardAssert;\n+\n+import androidx.annotation.Nullable;\n+import com.google.common.base.Splitter;\n+import com.google.firebase.firestore.model.value.FieldValue;\n+import com.google.firestore.v1.ArrayValue;\n+import com.google.firestore.v1.MapValue;\n+import com.google.firestore.v1.Value;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+public class ProtoValueUtil {\n+\n+  public static int typeOrder(Value value) {\n+\n+    switch (value.getValueTypeCase()) {\n+      case NULL_VALUE:\n+        return FieldValue.TYPE_ORDER_NULL;\n+      case BOOLEAN_VALUE:\n+        return FieldValue.TYPE_ORDER_BOOLEAN;\n+      case INTEGER_VALUE:\n+        return FieldValue.TYPE_ORDER_NUMBER;\n+      case DOUBLE_VALUE:\n+        return FieldValue.TYPE_ORDER_NUMBER;\n+      case TIMESTAMP_VALUE:\n+        return FieldValue.TYPE_ORDER_TIMESTAMP;\n+      case STRING_VALUE:\n+        return FieldValue.TYPE_ORDER_STRING;\n+      case BYTES_VALUE:\n+        return FieldValue.TYPE_ORDER_BLOB;\n+      case REFERENCE_VALUE:\n+        return FieldValue.TYPE_ORDER_REFERENCE;\n+      case GEO_POINT_VALUE:\n+        return FieldValue.TYPE_ORDER_GEOPOINT;\n+      case ARRAY_VALUE:\n+        return FieldValue.TYPE_ORDER_ARRAY;\n+      case MAP_VALUE:\n+        return FieldValue.TYPE_ORDER_OBJECT;\n+      default:\n+        throw fail(\"Invalid value type: \" + value.getValueTypeCase());\n+    }\n+  }\n+\n+  /** Returns whether `value` is non-null and corresponds to the given type order. */\n+  public static boolean isType(@Nullable Value value, int typeOrder) {\n+    return value != null && typeOrder(value) == typeOrder;\n+  }\n+\n+  public static boolean equals(Value left, Value right) {\n+    int leftType = typeOrder(left);\n+    int rightType = typeOrder(right);\n+    if (leftType != rightType) {\n+      return false;\n+    }\n+\n+    switch (leftType) {\n+      case FieldValue.TYPE_ORDER_ARRAY:\n+        return arrayEquals(left, right);\n+      case FieldValue.TYPE_ORDER_NUMBER:\n+        return numberEquals(left, right);\n+      case FieldValue.TYPE_ORDER_OBJECT:\n+        return objectEquals(left, right);\n+      default:\n+        return left.equals(right);\n+    }\n+  }\n+\n+  private static boolean objectEquals(Value left, Value right) {\n+    MapValue leftMap = left.getMapValue();\n+    MapValue rightMap = right.getMapValue();\n+\n+    if (leftMap.getFieldsCount() != rightMap.getFieldsCount()) {\n+      return false;\n+    }\n+\n+    for (Map.Entry<String, Value> entry : leftMap.getFieldsMap().entrySet()) {\n+      Value otherEntry = rightMap.getFieldsMap().get(entry.getKey());\n+      if (!entry.getValue().equals(otherEntry)) {\n+        return false;\n+      }\n+    }\n+\n+    return true;\n+  }\n+\n+  private static boolean numberEquals(Value left, Value right) {\n+    if (left.getValueTypeCase() == Value.ValueTypeCase.INTEGER_VALUE\n+        && right.getValueTypeCase() == Value.ValueTypeCase.INTEGER_VALUE) {\n+      return left.equals(right);\n+    } else if (left.getValueTypeCase() == Value.ValueTypeCase.DOUBLE_VALUE\n+        && right.getValueTypeCase() == Value.ValueTypeCase.DOUBLE_VALUE) {\n+      return Double.doubleToLongBits(left.getDoubleValue())\n+          == Double.doubleToLongBits(right.getDoubleValue());\n+    }\n+\n+    return false;\n+  }\n+\n+  private static boolean arrayEquals(Value left, Value right) {\n+    ArrayValue leftArray = left.getArrayValue();\n+    ArrayValue rightArray = right.getArrayValue();\n+\n+    if (leftArray.getValuesCount() != rightArray.getValuesCount()) {\n+      return false;\n+    }\n+\n+    for (int i = 0; i < leftArray.getValuesCount(); ++i) {\n+      if (!equals(leftArray.getValues(i), rightArray.getValues(i))) {\n+        return false;\n+      }\n+    }\n+\n+    return true;\n+  }\n+\n+  public static int compare(Value left, Value right) {\n+    int leftType = typeOrder(left);\n+    int rightType = typeOrder(right);\n+\n+    if (leftType != rightType) {\n+      return Util.compareIntegers(leftType, rightType);\n+    }\n+\n+    switch (leftType) {\n+      case FieldValue.TYPE_ORDER_NULL:\n+        return 0;\n+      case FieldValue.TYPE_ORDER_BOOLEAN:\n+        return Util.compareBooleans(left.getBooleanValue(), right.getBooleanValue());\n+      case FieldValue.TYPE_ORDER_NUMBER:\n+        return compareNumbers(left, right);\n+      case FieldValue.TYPE_ORDER_TIMESTAMP:\n+        return compareTimestamps(left, right);\n+      case FieldValue.TYPE_ORDER_STRING:\n+        return left.getStringValue().compareTo(right.getStringValue());\n+      case FieldValue.TYPE_ORDER_BLOB:\n+        return Util.compareByteString(left.getBytesValue(), right.getBytesValue());\n+      case FieldValue.TYPE_ORDER_REFERENCE:\n+        return compareReferences(left, right);\n+      case FieldValue.TYPE_ORDER_GEOPOINT:\n+        return compareGeoPoints(left, right);\n+      case FieldValue.TYPE_ORDER_ARRAY:\n+        return compareArrays(left, right);\n+      case FieldValue.TYPE_ORDER_OBJECT:\n+        return compareMaps(left, right);\n+      default:\n+        throw fail(\"Invalid value type: \" + leftType);\n+    }\n+  }\n+\n+  private static int compareMaps(Value left, Value right) {\n+    Iterator<Map.Entry<String, Value>> iterator1 =\n+        new TreeMap<>(left.getMapValue().getFieldsMap()).entrySet().iterator();\n+    Iterator<Map.Entry<String, Value>> iterator2 =\n+        new TreeMap<>(right.getMapValue().getFieldsMap()).entrySet().iterator();\n+    while (iterator1.hasNext() && iterator2.hasNext()) {\n+      Map.Entry<String, Value> entry1 = iterator1.next();\n+      Map.Entry<String, Value> entry2 = iterator2.next();\n+      int keyCompare = entry1.getKey().compareTo(entry2.getKey());\n+      if (keyCompare != 0) {\n+        return keyCompare;\n+      }\n+      int valueCompare = compare(entry1.getValue(), entry2.getValue());\n+      if (valueCompare != 0) {\n+        return valueCompare;\n+      }\n+    }\n+\n+    // Only equal if both iterators are exhausted.\n+    return Util.compareBooleans(iterator1.hasNext(), iterator2.hasNext());\n+  }\n+\n+  private static int compareArrays(Value left, Value right) {\n+    int minLength =\n+        Math.min(left.getArrayValue().getValuesCount(), right.getArrayValue().getValuesCount());\n+    for (int i = 0; i < minLength; i++) {\n+      int cmp = compare(left.getArrayValue().getValues(i), right.getArrayValue().getValues(i));\n+      if (cmp != 0) {\n+        return cmp;\n+      }\n+    }\n+    return Util.compareIntegers(\n+        left.getArrayValue().getValuesCount(), right.getArrayValue().getValuesCount());\n+  }\n+\n+  private static int compareGeoPoints(Value left, Value right) {\n+    int comparison =\n+        Util.compareDoubles(\n+            left.getGeoPointValue().getLatitude(), right.getGeoPointValue().getLatitude());\n+    if (comparison == 0) {\n+      return Util.compareDoubles(\n+          left.getGeoPointValue().getLongitude(), right.getGeoPointValue().getLongitude());\n+    }\n+    return comparison;\n+  }\n+\n+  private static int compareReferences(Value left, Value right) {\n+    List<String> leftSegments = Splitter.on('/').splitToList(left.getReferenceValue());\n+    List<String> rightSegments = Splitter.on('/').splitToList(right.getReferenceValue());\n+    int minLength = Math.min(leftSegments.size(), rightSegments.size());\n+    for (int i = 0; i < minLength; i++) {\n+      int cmp = leftSegments.get(i).compareTo(rightSegments.get(i));\n+      if (cmp != 0) {\n+        return cmp;\n+      }\n+    }\n+    return Util.compareIntegers(leftSegments.size(), rightSegments.size());\n+  }\n+\n+  private static int compareTimestamps(Value left, Value right) {\n+    if (left.getTimestampValue().getSeconds() == right.getTimestampValue().getSeconds()) {\n+      return Integer.signum(\n+          left.getTimestampValue().getNanos() - right.getTimestampValue().getNanos());\n+    }\n+    return Long.signum(\n+        left.getTimestampValue().getSeconds() - right.getTimestampValue().getSeconds());\n+  }\n+\n+  private static int compareNumbers(Value left, Value right) {\n+    if (left.getValueTypeCase() == Value.ValueTypeCase.DOUBLE_VALUE) {\n+      double thisDouble = left.getDoubleValue();\n+      if (right.getValueTypeCase() == Value.ValueTypeCase.DOUBLE_VALUE) {\n+        return Util.compareDoubles(thisDouble, right.getDoubleValue());\n+      } else {", "originalCommit": "5d3f44dbe37c5ef91bb90e4ad6fbf9e71e68f2d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMwNDMzOA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1157#discussion_r370304338", "bodyText": "Great suggestion. Updated.", "author": "schmidt-sebastian", "createdAt": "2020-01-23T19:13:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI5Njg1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI5NzUyNg==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1157#discussion_r370297526", "bodyText": "Other compare methods are plural (e.g. compareIntegers). compareByteStrings?", "author": "wilhuff", "createdAt": "2020-01-23T18:59:08Z", "path": "firebase-firestore/src/main/java/com/google/firebase/firestore/Blob.java", "diffHunk": "@@ -82,18 +82,6 @@ public int hashCode() {\n \n   @Override\n   public int compareTo(@NonNull Blob other) {\n-    int size = Math.min(bytes.size(), other.bytes.size());\n-    for (int i = 0; i < size; i++) {\n-      // Make sure the bytes are unsigned\n-      int thisByte = bytes.byteAt(i) & 0xff;\n-      int otherByte = other.bytes.byteAt(i) & 0xff;\n-      if (thisByte < otherByte) {\n-        return -1;\n-      } else if (thisByte > otherByte) {\n-        return 1;\n-      }\n-      // Byte values are equal, continue with comparison\n-    }\n-    return Util.compareIntegers(bytes.size(), other.bytes.size());\n+    return Util.compareByteString(bytes, other.bytes);", "originalCommit": "5d3f44dbe37c5ef91bb90e4ad6fbf9e71e68f2d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMwMjM5Mw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1157#discussion_r370302393", "bodyText": "Fixed", "author": "schmidt-sebastian", "createdAt": "2020-01-23T19:09:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI5NzUyNg=="}], "type": "inlineReview"}, {"oid": "a6f880ae8b4e4b11b91dfaeaec5b1ae86e40f12c", "url": "https://github.com/firebase/firebase-android-sdk/commit/a6f880ae8b4e4b11b91dfaeaec5b1ae86e40f12c", "message": "Address feeback", "committedDate": "2020-01-23T19:40:29Z", "type": "commit"}, {"oid": "7bdc88a1a8026eb256eb3a89dbf821b7647f5a13", "url": "https://github.com/firebase/firebase-android-sdk/commit/7bdc88a1a8026eb256eb3a89dbf821b7647f5a13", "message": "Fix package", "committedDate": "2020-01-23T23:59:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ0MTIxOA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1157#discussion_r370441218", "bodyText": "Elsewhere we compare and then if non-zero do the second one. Consider rephrasing as:\nint cmp = Util.compareIntegers(left.getTimestampValue().getSeconds(), right.getTimestampValue().getSeconds());\nif (cmp != 0) return cmp;\n\nreturn Util.compareIntegers(left.getTimestampValue().getNanos(), right.getTimestampValue().getNanos());\nThis has two benefits:\n\nit makes the hierarchy of comparison linear; and\nit avoids using subtraction for comparison, which is specious in the general case due to the possibility of overflow. I think it's the case that timestamp values are defined in such a way that subtraction can't possibly overflow, but there's no reason not to reuse the comparator we already have, in which case we don't have to think about it.", "author": "wilhuff", "createdAt": "2020-01-24T01:39:11Z", "path": "firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/ProtoValues.java", "diffHunk": "@@ -166,39 +166,46 @@ public static int compare(Value left, Value right) {\n     }\n   }\n \n-  private static int compareMaps(Value left, Value right) {\n-    Iterator<Map.Entry<String, Value>> iterator1 =\n-        new TreeMap<>(left.getMapValue().getFieldsMap()).entrySet().iterator();\n-    Iterator<Map.Entry<String, Value>> iterator2 =\n-        new TreeMap<>(right.getMapValue().getFieldsMap()).entrySet().iterator();\n-    while (iterator1.hasNext() && iterator2.hasNext()) {\n-      Map.Entry<String, Value> entry1 = iterator1.next();\n-      Map.Entry<String, Value> entry2 = iterator2.next();\n-      int keyCompare = entry1.getKey().compareTo(entry2.getKey());\n-      if (keyCompare != 0) {\n-        return keyCompare;\n+  private static int compareNumbers(Value left, Value right) {\n+    if (left.getValueTypeCase() == Value.ValueTypeCase.DOUBLE_VALUE) {\n+      double thisDouble = left.getDoubleValue();\n+      if (right.getValueTypeCase() == Value.ValueTypeCase.DOUBLE_VALUE) {\n+        return Util.compareDoubles(thisDouble, right.getDoubleValue());\n+      } else if (right.getValueTypeCase() == Value.ValueTypeCase.INTEGER_VALUE) {\n+        return Util.compareMixed(thisDouble, right.getIntegerValue());\n       }\n-      int valueCompare = compare(entry1.getValue(), entry2.getValue());\n-      if (valueCompare != 0) {\n-        return valueCompare;\n+    } else if (left.getValueTypeCase() == Value.ValueTypeCase.INTEGER_VALUE) {\n+      long thisLong = left.getIntegerValue();\n+      if (right.getValueTypeCase() == Value.ValueTypeCase.INTEGER_VALUE) {\n+        return Util.compareLongs(thisLong, right.getIntegerValue());\n+      } else if (right.getValueTypeCase() == Value.ValueTypeCase.DOUBLE_VALUE) {\n+        return -1 * Util.compareMixed(right.getDoubleValue(), thisLong);\n       }\n     }\n \n-    // Only equal if both iterators are exhausted.\n-    return Util.compareBooleans(iterator1.hasNext(), iterator2.hasNext());\n+    throw fail(\"Unexpected values: %s vs %s\", left, right);\n   }\n \n-  private static int compareArrays(Value left, Value right) {\n-    int minLength =\n-        Math.min(left.getArrayValue().getValuesCount(), right.getArrayValue().getValuesCount());\n+  private static int compareTimestamps(Value left, Value right) {\n+    if (left.getTimestampValue().getSeconds() == right.getTimestampValue().getSeconds()) {", "originalCommit": "7bdc88a1a8026eb256eb3a89dbf821b7647f5a13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3ODcxNQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1157#discussion_r370478715", "bodyText": "This code is actually based on the original code. I do think the comparisons in the other functions are easier to follow, so I updated it.\nAs part of this, I changed the method to take TimestampValues (along with the rest). This avoids a bunch of extra linebreaks since it removes the calls to getTimestampValue() from here.", "author": "schmidt-sebastian", "createdAt": "2020-01-24T05:28:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ0MTIxOA=="}], "type": "inlineReview"}, {"oid": "6e4ddde2298e95f933bcefe9e552c187466bd0a1", "url": "https://github.com/firebase/firebase-android-sdk/commit/6e4ddde2298e95f933bcefe9e552c187466bd0a1", "message": "Format", "committedDate": "2020-01-24T05:29:18Z", "type": "commit"}, {"oid": "6e4ddde2298e95f933bcefe9e552c187466bd0a1", "url": "https://github.com/firebase/firebase-android-sdk/commit/6e4ddde2298e95f933bcefe9e552c187466bd0a1", "message": "Format", "committedDate": "2020-01-24T05:29:18Z", "type": "forcePushed"}]}