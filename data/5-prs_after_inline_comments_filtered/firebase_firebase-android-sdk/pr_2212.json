{"pr_number": 2212, "pr_title": "Adding get Model for local downloads", "pr_createdAt": "2020-11-30T17:07:36Z", "pr_url": "https://github.com/firebase/firebase-android-sdk/pull/2212", "timeline": [{"oid": "38692fc1c98a60d608646d18d65d4955dc17e480", "url": "https://github.com/firebase/firebase-android-sdk/commit/38692fc1c98a60d608646d18d65d4955dc17e480", "message": "Adding get Model for local downloads - only handles local model and unconditional downloads at this time.", "committedDate": "2020-11-30T17:06:51Z", "type": "commit"}, {"oid": "657ce4cf3e340175abaabaf0581c475bf25da025", "url": "https://github.com/firebase/firebase-android-sdk/commit/657ce4cf3e340175abaabaf0581c475bf25da025", "message": "Adding loadNewlyDownloadedFiles to listModels.", "committedDate": "2020-11-30T21:54:05Z", "type": "commit"}, {"oid": "8da2644464539d7e10189c6abac1bff75545f04a", "url": "https://github.com/firebase/firebase-android-sdk/commit/8da2644464539d7e10189c6abac1bff75545f04a", "message": "Adding loadNewlyDownloadedFiles to listModels.", "committedDate": "2020-12-01T21:01:59Z", "type": "commit"}, {"oid": "e8f7dad27de642888c24c96525c9730ab4ea06b3", "url": "https://github.com/firebase/firebase-android-sdk/commit/e8f7dad27de642888c24c96525c9730ab4ea06b3", "message": "Adding loadNewlyDownloadedFiles to listModels.", "committedDate": "2020-12-01T21:18:13Z", "type": "commit"}, {"oid": "b270c4efe700860814b5078d60f38b2966934500", "url": "https://github.com/firebase/firebase-android-sdk/commit/b270c4efe700860814b5078d60f38b2966934500", "message": "Update formatting.", "committedDate": "2020-12-01T21:19:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg0NDk4Mw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/2212#discussion_r533844983", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @return the local file associated with the model, if the original file download is still in\n          \n          \n            \n               *     progress, returns null, if file update is in progress returns last fully uploaded model.\n          \n          \n            \n               * @return the local file associated with the model. If the original file download is still in\n          \n          \n            \n               *     progress, returns null. If file update is in progress, returns the last fully uploaded model.", "author": "rlazo", "createdAt": "2020-12-02T01:59:31Z", "path": "firebase-ml-modeldownloader/src/main/java/com/google/firebase/ml/modeldownloader/CustomModel.java", "diffHunk": "@@ -127,11 +129,29 @@ public String getName() {\n    *     progress, returns null, if file update is in progress returns last fully uploaded model.\n    */\n   @Nullable\n-  public File getFile() {\n+  public File getFile() throws Exception {\n+    return getFile(ModelFileDownloadService.getInstance());\n+  }\n+\n+  /**\n+   * The local model file. If null is returned, use the download Id to check the download status.\n+   *\n+   * @return the local file associated with the model, if the original file download is still in\n+   *     progress, returns null, if file update is in progress returns last fully uploaded model.", "originalCommit": "b270c4efe700860814b5078d60f38b2966934500", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg0NTg4MA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/2212#discussion_r533845880", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Triggers the move to permanent storage of successful model downloads and list all models\n          \n          \n            \n               * Triggers the move to permanent storage of successful model downloads and lists all models", "author": "rlazo", "createdAt": "2020-12-02T02:02:31Z", "path": "firebase-ml-modeldownloader/src/main/java/com/google/firebase/ml/modeldownloader/FirebaseModelDownloader.java", "diffHunk": "@@ -95,21 +112,77 @@ public static FirebaseModelDownloader getInstance(@NonNull FirebaseApp app) {\n   public Task<CustomModel> getModel(\n       @NonNull String modelName,\n       @NonNull DownloadType downloadType,\n-      @Nullable CustomModelDownloadConditions conditions) {\n+      @Nullable CustomModelDownloadConditions conditions)\n+      throws Exception {\n+    CustomModel localModel = sharedPreferencesUtil.getCustomModelDetails(modelName);\n+    switch (downloadType) {\n+      case LOCAL_MODEL:\n+        if (localModel != null) {\n+          return Tasks.forResult(localModel);\n+        }\n+        Task<CustomModel> modelDetails =\n+            modelDownloadService.getCustomModelDetails(\n+                firebaseOptions.getProjectId(), modelName, null);\n+\n+        // no local model - start download.\n+        return modelDetails.continueWithTask(\n+            executor,\n+            modelDetailTask -> {\n+              if (modelDetailTask.isSuccessful()) {\n+                // start download\n+                return fileDownloadService\n+                    .download(modelDetailTask.getResult(), conditions)\n+                    .continueWithTask(\n+                        executor,\n+                        downloadTask -> {\n+                          if (downloadTask.isSuccessful()) {\n+                            // read the updated model\n+                            CustomModel downloadedModel =\n+                                sharedPreferencesUtil.getCustomModelDetails(modelName);\n+                            // TODO(annz) trigger file move here as well... right now it's temp\n+                            // call loadNewlyDownloadedModelFile\n+                            return Tasks.forResult(downloadedModel);\n+                          }\n+                          return Tasks.forException(new Exception(\"File download failed.\"));\n+                        });\n+              }\n+              return Tasks.forException(modelDetailTask.getException());\n+            });\n+      case LATEST_MODEL:\n+        // check for latest model and download newest\n+        break;\n+      case LOCAL_MODEL_UPDATE_IN_BACKGROUND:\n+        // start download in back ground return current model if not null.\n+        break;\n+    }\n     throw new UnsupportedOperationException(\"Not yet implemented.\");\n   }\n \n-  /** @return The set of all models that are downloaded to this device. */\n+  /**\n+   * Triggers the move to permanent storage of successful model downloads and list all models", "originalCommit": "b270c4efe700860814b5078d60f38b2966934500", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg0NjAwOQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/2212#discussion_r533846009", "bodyText": "Log maybe?", "author": "rlazo", "createdAt": "2020-12-02T02:02:54Z", "path": "firebase-ml-modeldownloader/src/main/java/com/google/firebase/ml/modeldownloader/FirebaseModelDownloader.java", "diffHunk": "@@ -95,21 +112,77 @@ public static FirebaseModelDownloader getInstance(@NonNull FirebaseApp app) {\n   public Task<CustomModel> getModel(\n       @NonNull String modelName,\n       @NonNull DownloadType downloadType,\n-      @Nullable CustomModelDownloadConditions conditions) {\n+      @Nullable CustomModelDownloadConditions conditions)\n+      throws Exception {\n+    CustomModel localModel = sharedPreferencesUtil.getCustomModelDetails(modelName);\n+    switch (downloadType) {\n+      case LOCAL_MODEL:\n+        if (localModel != null) {\n+          return Tasks.forResult(localModel);\n+        }\n+        Task<CustomModel> modelDetails =\n+            modelDownloadService.getCustomModelDetails(\n+                firebaseOptions.getProjectId(), modelName, null);\n+\n+        // no local model - start download.\n+        return modelDetails.continueWithTask(\n+            executor,\n+            modelDetailTask -> {\n+              if (modelDetailTask.isSuccessful()) {\n+                // start download\n+                return fileDownloadService\n+                    .download(modelDetailTask.getResult(), conditions)\n+                    .continueWithTask(\n+                        executor,\n+                        downloadTask -> {\n+                          if (downloadTask.isSuccessful()) {\n+                            // read the updated model\n+                            CustomModel downloadedModel =\n+                                sharedPreferencesUtil.getCustomModelDetails(modelName);\n+                            // TODO(annz) trigger file move here as well... right now it's temp\n+                            // call loadNewlyDownloadedModelFile\n+                            return Tasks.forResult(downloadedModel);\n+                          }\n+                          return Tasks.forException(new Exception(\"File download failed.\"));\n+                        });\n+              }\n+              return Tasks.forException(modelDetailTask.getException());\n+            });\n+      case LATEST_MODEL:\n+        // check for latest model and download newest\n+        break;\n+      case LOCAL_MODEL_UPDATE_IN_BACKGROUND:\n+        // start download in back ground return current model if not null.\n+        break;\n+    }\n     throw new UnsupportedOperationException(\"Not yet implemented.\");\n   }\n \n-  /** @return The set of all models that are downloaded to this device. */\n+  /**\n+   * Triggers the move to permanent storage of successful model downloads and list all models\n+   * downloaded to device.\n+   *\n+   * @return The set of all models that are downloaded to this device, triggers completion of file\n+   *     moves for completed model downloads.\n+   */\n   @NonNull\n   public Task<Set<CustomModel>> listDownloadedModels() {\n+    // trigger completion of file moves for download files.\n+    try {\n+      fileDownloadService.maybeCheckDownloadingComplete();\n+    } catch (Exception ex) {\n+      System.out.println(\"Error checking for in progress downloads: \" + ex.getMessage());", "originalCommit": "b270c4efe700860814b5078d60f38b2966934500", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDIxMzQ1NQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/2212#discussion_r534213455", "bodyText": "Yes - changing all these to logs in the next major PR. Just started working on it this morning.", "author": "annzimmer", "createdAt": "2020-12-02T14:34:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg0NjAwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDIyMjY0Ng==", "url": "https://github.com/firebase/firebase-android-sdk/pull/2212#discussion_r534222646", "bodyText": "Happy to change it earlier if you want - was just trying to keep this change as small as possible.", "author": "annzimmer", "createdAt": "2020-12-02T14:45:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg0NjAwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDIyNTkyNg==", "url": "https://github.com/firebase/firebase-android-sdk/pull/2212#discussion_r534225926", "bodyText": "That's OK, you can do it later.", "author": "rlazo", "createdAt": "2020-12-02T14:49:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg0NjAwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg0NzMzOQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/2212#discussion_r533847339", "bodyText": "Log maybe?", "author": "rlazo", "createdAt": "2020-12-02T02:07:16Z", "path": "firebase-ml-modeldownloader/src/main/java/com/google/firebase/ml/modeldownloader/internal/ModelFileDownloadService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.ml.modeldownloader.internal;\n+\n+import android.app.DownloadManager;\n+import android.app.DownloadManager.Query;\n+import android.app.DownloadManager.Request;\n+import android.content.BroadcastReceiver;\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.IntentFilter;\n+import android.database.Cursor;\n+import android.net.Uri;\n+import android.os.Build.VERSION;\n+import android.os.Build.VERSION_CODES;\n+import android.os.ParcelFileDescriptor;\n+import android.util.LongSparseArray;\n+import androidx.annotation.GuardedBy;\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.annotation.VisibleForTesting;\n+import androidx.annotation.WorkerThread;\n+import com.google.android.gms.tasks.Task;\n+import com.google.android.gms.tasks.TaskCompletionSource;\n+import com.google.android.gms.tasks.Tasks;\n+import com.google.firebase.FirebaseApp;\n+import com.google.firebase.ml.modeldownloader.CustomModel;\n+import com.google.firebase.ml.modeldownloader.CustomModelDownloadConditions;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Calls the Android Download service to copy the model file to device (temp location) and then\n+ * moves file to it's permanent location, updating the model details in shared preferences\n+ * throughout.\n+ *\n+ * @hide\n+ */\n+public class ModelFileDownloadService {\n+\n+  private final DownloadManager downloadManager;\n+  private final Context context;\n+  private final ModelFileManager fileManager;\n+  private final SharedPreferencesUtil sharedPreferencesUtil;\n+\n+  @GuardedBy(\"this\")\n+  // Mapping from download id to broadcast receiver. Because models can update, we cannot just keep\n+  // one instance of DownloadBroadcastReceiver per RemoteModelDownloadManager object.\n+  private final LongSparseArray<DownloadBroadcastReceiver> receiverMaps = new LongSparseArray<>();\n+\n+  @GuardedBy(\"this\")\n+  // Mapping from download id to TaskCompletionSource. Because models can update, we cannot just\n+  // keep one instance of TaskCompletionSource per RemoteModelDownloadManager object.\n+  private final LongSparseArray<TaskCompletionSource<Void>> taskCompletionSourceMaps =\n+      new LongSparseArray<>();\n+\n+  private CustomModelDownloadConditions downloadConditions =\n+      new CustomModelDownloadConditions.Builder().build();\n+\n+  public ModelFileDownloadService(@NonNull FirebaseApp firebaseApp) {\n+    this.context = firebaseApp.getApplicationContext();\n+    downloadManager = (DownloadManager) context.getSystemService(Context.DOWNLOAD_SERVICE);\n+    this.fileManager = ModelFileManager.getInstance();\n+    this.sharedPreferencesUtil = new SharedPreferencesUtil(firebaseApp);\n+  }\n+\n+  @VisibleForTesting\n+  ModelFileDownloadService(\n+      @NonNull FirebaseApp firebaseApp,\n+      DownloadManager downloadManager,\n+      ModelFileManager fileManager,\n+      SharedPreferencesUtil sharedPreferencesUtil) {\n+    this.context = firebaseApp.getApplicationContext();\n+    this.downloadManager = downloadManager;\n+    this.fileManager = fileManager;\n+    this.sharedPreferencesUtil = sharedPreferencesUtil;\n+  }\n+\n+  /**\n+   * Get ModelFileDownloadService instance using the firebase app returned by {@link\n+   * FirebaseApp#getInstance()}\n+   *\n+   * @return ModelFileDownloadService\n+   */\n+  @NonNull\n+  public static ModelFileDownloadService getInstance() {\n+    return FirebaseApp.getInstance().get(ModelFileDownloadService.class);\n+  }\n+\n+  public Task<Void> download(\n+      CustomModel customModel, CustomModelDownloadConditions downloadConditions) {\n+    this.downloadConditions = downloadConditions;\n+    // todo add url tests here\n+    return ensureModelDownloaded(customModel);\n+  }\n+\n+  @VisibleForTesting\n+  Task<Void> ensureModelDownloaded(CustomModel customModel) {\n+    // todo check model not already in progress of being downloaded\n+\n+    // todo remove any failed download attempts\n+\n+    // schedule new download of model file\n+    Long newDownloadId = scheduleModelDownload(customModel);\n+    if (newDownloadId == null) {\n+      return Tasks.forException(new Exception(\"Failed to schedule the download task\"));\n+    }\n+\n+    return registerReceiverForDownloadId(newDownloadId);\n+  }\n+\n+  private synchronized DownloadBroadcastReceiver getReceiverInstance(long downloadId) {\n+    DownloadBroadcastReceiver receiver = receiverMaps.get(downloadId);\n+    if (receiver == null) {\n+      receiver =\n+          new DownloadBroadcastReceiver(downloadId, getTaskCompletionSourceInstance(downloadId));\n+      receiverMaps.put(downloadId, receiver);\n+    }\n+    return receiver;\n+  }\n+\n+  private Task<Void> registerReceiverForDownloadId(long downloadId) {\n+    BroadcastReceiver broadcastReceiver = getReceiverInstance(downloadId);\n+    // It is okay to always register here. Since the broadcast receiver is the same via the lookup\n+    // for the same download id, the same broadcast receiver will be notified only once.\n+    context.registerReceiver(\n+        broadcastReceiver, new IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE));\n+\n+    return getTaskCompletionSourceInstance(downloadId).getTask();\n+  }\n+\n+  @VisibleForTesting\n+  synchronized TaskCompletionSource<Void> getTaskCompletionSourceInstance(long downloadId) {\n+    TaskCompletionSource<Void> taskCompletionSource = taskCompletionSourceMaps.get(downloadId);\n+    if (taskCompletionSource == null) {\n+      taskCompletionSource = new TaskCompletionSource<>();\n+      taskCompletionSourceMaps.put(downloadId, taskCompletionSource);\n+    }\n+\n+    return taskCompletionSource;\n+  }\n+\n+  @VisibleForTesting\n+  synchronized Long scheduleModelDownload(@NonNull CustomModel customModel) {\n+    if (downloadManager == null) {\n+      return null;\n+    }\n+\n+    if (customModel.getDownloadUrl() == null || customModel.getDownloadUrl().isEmpty()) {\n+      return null;\n+    }\n+    // todo handle expired url here and figure out what to do about delayed downloads too..\n+\n+    // Schedule a new downloading\n+    Request downloadRequest = new Request(Uri.parse(customModel.getDownloadUrl()));\n+    // check Url is not expired - get new one if necessary...\n+\n+    // By setting the destination uri to null, the downloaded file will be stored in\n+    // DownloadManager's purgeable cache. As a result, WRITE_EXTERNAL_STORAGE permission is not\n+    // needed.\n+    downloadRequest.setDestinationUri(null);\n+    if (VERSION.SDK_INT >= VERSION_CODES.N) {\n+      downloadRequest.setRequiresCharging(downloadConditions.isChargingRequired());\n+      downloadRequest.setRequiresDeviceIdle(downloadConditions.isDeviceIdleRequired());\n+    }\n+\n+    if (downloadConditions.isWifiRequired()) {\n+      downloadRequest.setAllowedNetworkTypes(Request.NETWORK_WIFI);\n+    }\n+\n+    long id = downloadManager.enqueue(downloadRequest);\n+    // update the custom model to store the download id - do not lose current local file - in case\n+    // this is a background update.\n+    sharedPreferencesUtil.setDownloadingCustomModelDetails(\n+        new CustomModel(\n+            customModel.getName(),\n+            customModel.getModelHash(),\n+            customModel.getSize(),\n+            id,\n+            customModel.getLocalFilePath()));\n+    return id;\n+  }\n+\n+  @Nullable\n+  @VisibleForTesting\n+  synchronized Integer getDownloadingModelStatusCode(Long downloadingId) {\n+    if (downloadManager == null || downloadingId == null) {\n+      return null;\n+    }\n+\n+    Integer statusCode = null;\n+\n+    try (Cursor cursor = downloadManager.query(new Query().setFilterById(downloadingId))) {\n+\n+      if (cursor != null && cursor.moveToFirst()) {\n+        statusCode = cursor.getInt(cursor.getColumnIndex(DownloadManager.COLUMN_STATUS));\n+      }\n+\n+      if (statusCode == null) {\n+        return null;\n+      }\n+\n+      if (statusCode != DownloadManager.STATUS_RUNNING\n+          && statusCode != DownloadManager.STATUS_PAUSED\n+          && statusCode != DownloadManager.STATUS_PENDING\n+          && statusCode != DownloadManager.STATUS_SUCCESSFUL\n+          && statusCode != DownloadManager.STATUS_FAILED) {\n+        // Unknown status\n+        statusCode = null;\n+      }\n+      return statusCode;\n+    }\n+  }\n+\n+  @Nullable\n+  private synchronized ParcelFileDescriptor getDownloadedFile(Long downloadingId) {\n+    if (downloadManager == null || downloadingId == null) {\n+      return null;\n+    }\n+\n+    ParcelFileDescriptor fileDescriptor = null;\n+    try {\n+      fileDescriptor = downloadManager.openDownloadedFile(downloadingId);\n+    } catch (FileNotFoundException e) {\n+      System.out.println(\"Downloaded file is not found\");", "originalCommit": "b270c4efe700860814b5078d60f38b2966934500", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDIxMzM5MA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/2212#discussion_r534213390", "bodyText": "Yes - changing all these to logs in the next major PR. Just started working on it this morning.", "author": "annzimmer", "createdAt": "2020-12-02T14:34:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg0NzMzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg0ODM5OQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/2212#discussion_r533848399", "bodyText": "same", "author": "rlazo", "createdAt": "2020-12-02T02:10:25Z", "path": "firebase-ml-modeldownloader/src/main/java/com/google/firebase/ml/modeldownloader/internal/ModelFileDownloadService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.ml.modeldownloader.internal;\n+\n+import android.app.DownloadManager;\n+import android.app.DownloadManager.Query;\n+import android.app.DownloadManager.Request;\n+import android.content.BroadcastReceiver;\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.IntentFilter;\n+import android.database.Cursor;\n+import android.net.Uri;\n+import android.os.Build.VERSION;\n+import android.os.Build.VERSION_CODES;\n+import android.os.ParcelFileDescriptor;\n+import android.util.LongSparseArray;\n+import androidx.annotation.GuardedBy;\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.annotation.VisibleForTesting;\n+import androidx.annotation.WorkerThread;\n+import com.google.android.gms.tasks.Task;\n+import com.google.android.gms.tasks.TaskCompletionSource;\n+import com.google.android.gms.tasks.Tasks;\n+import com.google.firebase.FirebaseApp;\n+import com.google.firebase.ml.modeldownloader.CustomModel;\n+import com.google.firebase.ml.modeldownloader.CustomModelDownloadConditions;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Calls the Android Download service to copy the model file to device (temp location) and then\n+ * moves file to it's permanent location, updating the model details in shared preferences\n+ * throughout.\n+ *\n+ * @hide\n+ */\n+public class ModelFileDownloadService {\n+\n+  private final DownloadManager downloadManager;\n+  private final Context context;\n+  private final ModelFileManager fileManager;\n+  private final SharedPreferencesUtil sharedPreferencesUtil;\n+\n+  @GuardedBy(\"this\")\n+  // Mapping from download id to broadcast receiver. Because models can update, we cannot just keep\n+  // one instance of DownloadBroadcastReceiver per RemoteModelDownloadManager object.\n+  private final LongSparseArray<DownloadBroadcastReceiver> receiverMaps = new LongSparseArray<>();\n+\n+  @GuardedBy(\"this\")\n+  // Mapping from download id to TaskCompletionSource. Because models can update, we cannot just\n+  // keep one instance of TaskCompletionSource per RemoteModelDownloadManager object.\n+  private final LongSparseArray<TaskCompletionSource<Void>> taskCompletionSourceMaps =\n+      new LongSparseArray<>();\n+\n+  private CustomModelDownloadConditions downloadConditions =\n+      new CustomModelDownloadConditions.Builder().build();\n+\n+  public ModelFileDownloadService(@NonNull FirebaseApp firebaseApp) {\n+    this.context = firebaseApp.getApplicationContext();\n+    downloadManager = (DownloadManager) context.getSystemService(Context.DOWNLOAD_SERVICE);\n+    this.fileManager = ModelFileManager.getInstance();\n+    this.sharedPreferencesUtil = new SharedPreferencesUtil(firebaseApp);\n+  }\n+\n+  @VisibleForTesting\n+  ModelFileDownloadService(\n+      @NonNull FirebaseApp firebaseApp,\n+      DownloadManager downloadManager,\n+      ModelFileManager fileManager,\n+      SharedPreferencesUtil sharedPreferencesUtil) {\n+    this.context = firebaseApp.getApplicationContext();\n+    this.downloadManager = downloadManager;\n+    this.fileManager = fileManager;\n+    this.sharedPreferencesUtil = sharedPreferencesUtil;\n+  }\n+\n+  /**\n+   * Get ModelFileDownloadService instance using the firebase app returned by {@link\n+   * FirebaseApp#getInstance()}\n+   *\n+   * @return ModelFileDownloadService\n+   */\n+  @NonNull\n+  public static ModelFileDownloadService getInstance() {\n+    return FirebaseApp.getInstance().get(ModelFileDownloadService.class);\n+  }\n+\n+  public Task<Void> download(\n+      CustomModel customModel, CustomModelDownloadConditions downloadConditions) {\n+    this.downloadConditions = downloadConditions;\n+    // todo add url tests here\n+    return ensureModelDownloaded(customModel);\n+  }\n+\n+  @VisibleForTesting\n+  Task<Void> ensureModelDownloaded(CustomModel customModel) {\n+    // todo check model not already in progress of being downloaded\n+\n+    // todo remove any failed download attempts\n+\n+    // schedule new download of model file\n+    Long newDownloadId = scheduleModelDownload(customModel);\n+    if (newDownloadId == null) {\n+      return Tasks.forException(new Exception(\"Failed to schedule the download task\"));\n+    }\n+\n+    return registerReceiverForDownloadId(newDownloadId);\n+  }\n+\n+  private synchronized DownloadBroadcastReceiver getReceiverInstance(long downloadId) {\n+    DownloadBroadcastReceiver receiver = receiverMaps.get(downloadId);\n+    if (receiver == null) {\n+      receiver =\n+          new DownloadBroadcastReceiver(downloadId, getTaskCompletionSourceInstance(downloadId));\n+      receiverMaps.put(downloadId, receiver);\n+    }\n+    return receiver;\n+  }\n+\n+  private Task<Void> registerReceiverForDownloadId(long downloadId) {\n+    BroadcastReceiver broadcastReceiver = getReceiverInstance(downloadId);\n+    // It is okay to always register here. Since the broadcast receiver is the same via the lookup\n+    // for the same download id, the same broadcast receiver will be notified only once.\n+    context.registerReceiver(\n+        broadcastReceiver, new IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE));\n+\n+    return getTaskCompletionSourceInstance(downloadId).getTask();\n+  }\n+\n+  @VisibleForTesting\n+  synchronized TaskCompletionSource<Void> getTaskCompletionSourceInstance(long downloadId) {\n+    TaskCompletionSource<Void> taskCompletionSource = taskCompletionSourceMaps.get(downloadId);\n+    if (taskCompletionSource == null) {\n+      taskCompletionSource = new TaskCompletionSource<>();\n+      taskCompletionSourceMaps.put(downloadId, taskCompletionSource);\n+    }\n+\n+    return taskCompletionSource;\n+  }\n+\n+  @VisibleForTesting\n+  synchronized Long scheduleModelDownload(@NonNull CustomModel customModel) {\n+    if (downloadManager == null) {\n+      return null;\n+    }\n+\n+    if (customModel.getDownloadUrl() == null || customModel.getDownloadUrl().isEmpty()) {\n+      return null;\n+    }\n+    // todo handle expired url here and figure out what to do about delayed downloads too..\n+\n+    // Schedule a new downloading\n+    Request downloadRequest = new Request(Uri.parse(customModel.getDownloadUrl()));\n+    // check Url is not expired - get new one if necessary...\n+\n+    // By setting the destination uri to null, the downloaded file will be stored in\n+    // DownloadManager's purgeable cache. As a result, WRITE_EXTERNAL_STORAGE permission is not\n+    // needed.\n+    downloadRequest.setDestinationUri(null);\n+    if (VERSION.SDK_INT >= VERSION_CODES.N) {\n+      downloadRequest.setRequiresCharging(downloadConditions.isChargingRequired());\n+      downloadRequest.setRequiresDeviceIdle(downloadConditions.isDeviceIdleRequired());\n+    }\n+\n+    if (downloadConditions.isWifiRequired()) {\n+      downloadRequest.setAllowedNetworkTypes(Request.NETWORK_WIFI);\n+    }\n+\n+    long id = downloadManager.enqueue(downloadRequest);\n+    // update the custom model to store the download id - do not lose current local file - in case\n+    // this is a background update.\n+    sharedPreferencesUtil.setDownloadingCustomModelDetails(\n+        new CustomModel(\n+            customModel.getName(),\n+            customModel.getModelHash(),\n+            customModel.getSize(),\n+            id,\n+            customModel.getLocalFilePath()));\n+    return id;\n+  }\n+\n+  @Nullable\n+  @VisibleForTesting\n+  synchronized Integer getDownloadingModelStatusCode(Long downloadingId) {\n+    if (downloadManager == null || downloadingId == null) {\n+      return null;\n+    }\n+\n+    Integer statusCode = null;\n+\n+    try (Cursor cursor = downloadManager.query(new Query().setFilterById(downloadingId))) {\n+\n+      if (cursor != null && cursor.moveToFirst()) {\n+        statusCode = cursor.getInt(cursor.getColumnIndex(DownloadManager.COLUMN_STATUS));\n+      }\n+\n+      if (statusCode == null) {\n+        return null;\n+      }\n+\n+      if (statusCode != DownloadManager.STATUS_RUNNING\n+          && statusCode != DownloadManager.STATUS_PAUSED\n+          && statusCode != DownloadManager.STATUS_PENDING\n+          && statusCode != DownloadManager.STATUS_SUCCESSFUL\n+          && statusCode != DownloadManager.STATUS_FAILED) {\n+        // Unknown status\n+        statusCode = null;\n+      }\n+      return statusCode;\n+    }\n+  }\n+\n+  @Nullable\n+  private synchronized ParcelFileDescriptor getDownloadedFile(Long downloadingId) {\n+    if (downloadManager == null || downloadingId == null) {\n+      return null;\n+    }\n+\n+    ParcelFileDescriptor fileDescriptor = null;\n+    try {\n+      fileDescriptor = downloadManager.openDownloadedFile(downloadingId);\n+    } catch (FileNotFoundException e) {\n+      System.out.println(\"Downloaded file is not found\");\n+    }\n+    return fileDescriptor;\n+  }\n+\n+  public void maybeCheckDownloadingComplete() throws Exception {\n+    for (String key : sharedPreferencesUtil.getSharedPreferenceKeySet()) {\n+      // if a local file path is present - get model details.\n+      Matcher matcher =\n+          Pattern.compile(SharedPreferencesUtil.DOWNLOADING_MODEL_ID_MATCHER).matcher(key);\n+      if (matcher.find()) {\n+        String modelName = matcher.group(matcher.groupCount());\n+        CustomModel downloadingModel = sharedPreferencesUtil.getCustomModelDetails(modelName);\n+        Integer statusCode = getDownloadingModelStatusCode(downloadingModel.getDownloadId());\n+        if (statusCode == DownloadManager.STATUS_SUCCESSFUL\n+            || statusCode == DownloadManager.STATUS_FAILED) {\n+          loadNewlyDownloadedModelFile(downloadingModel);\n+        }\n+      }\n+    }\n+  }\n+\n+  @Nullable\n+  @WorkerThread\n+  public File loadNewlyDownloadedModelFile(CustomModel model) throws Exception {\n+    Long downloadingId = model.getDownloadId();\n+    String downloadingModelHash = model.getModelHash();\n+\n+    if (downloadingId == null || downloadingModelHash == null) {\n+      // no downloading model file or incomplete info.\n+      return null;\n+    }\n+\n+    Integer statusCode = getDownloadingModelStatusCode(downloadingId);\n+    if (statusCode == null) {\n+      return null;\n+    }\n+\n+    if (statusCode == DownloadManager.STATUS_SUCCESSFUL) {\n+      // Get downloaded file.\n+      ParcelFileDescriptor fileDescriptor = getDownloadedFile(downloadingId);\n+      if (fileDescriptor == null) {\n+        // reset original model - removing download id.\n+        sharedPreferencesUtil.setFailedUploadedCustomModelDetails(model.getName());\n+        // todo call the download register?\n+        return null;\n+      }\n+\n+      // Try to move it to destination folder.\n+      File newModelFile = fileManager.moveModelToDestinationFolder(model, fileDescriptor);\n+\n+      if (newModelFile == null) {\n+        // reset original model - removing download id.\n+        // todo call the download register?\n+        sharedPreferencesUtil.setFailedUploadedCustomModelDetails(model.getName());\n+        return null;\n+      }\n+\n+      // Successfully moved,  update share preferences\n+      sharedPreferencesUtil.setUploadedCustomModelDetails(\n+          new CustomModel(\n+              model.getName(), model.getModelHash(), model.getSize(), 0, newModelFile.getPath()));\n+\n+      // Cleans up the old files if it is the initial creation.\n+      return newModelFile;\n+    } else if (statusCode == DownloadManager.STATUS_FAILED) {\n+      // reset original model - removing download id.\n+      sharedPreferencesUtil.setFailedUploadedCustomModelDetails(model.getName());\n+      // todo - determine if the temp files need to be clean up? Does one exist?\n+    }\n+    // Other cases, return as null and wait for download finish.\n+    return null;\n+  }\n+\n+  // This class runs totally on worker thread because we registered the receiver with a worker\n+  // thread handler.\n+  @WorkerThread\n+  private class DownloadBroadcastReceiver extends BroadcastReceiver {\n+\n+    // Download Id is captured inside this class in memory. So there is no concern of inconsistency\n+    // with the persisted download id in shared preferences.\n+    private final long downloadId;\n+    private final TaskCompletionSource<Void> taskCompletionSource;\n+\n+    private DownloadBroadcastReceiver(\n+        long downloadId, TaskCompletionSource<Void> taskCompletionSource) {\n+      this.downloadId = downloadId;\n+      this.taskCompletionSource = taskCompletionSource;\n+    }\n+\n+    @Override\n+    public void onReceive(Context context, Intent intent) {\n+      long id = intent.getLongExtra(DownloadManager.EXTRA_DOWNLOAD_ID, -1);\n+      if (id != downloadId) {\n+        return;\n+      }\n+\n+      Integer statusCode = getDownloadingModelStatusCode(downloadId);\n+      synchronized (ModelFileDownloadService.this) {\n+        try {\n+          context.getApplicationContext().unregisterReceiver(this);\n+        } catch (IllegalArgumentException e) {\n+          // If we try to unregister a receiver that was never registered or has been unregistered,\n+          // IllegalArgumentException will be thrown by the Android Framework.\n+          // Our current code does not have this problem. However, in order to be safer in the\n+          // future, we just ignore the exception here, because it is not a big deal. The code can\n+          // move on.\n+        }\n+\n+        receiverMaps.remove(downloadId);\n+        taskCompletionSourceMaps.remove(downloadId);\n+      }\n+\n+      if (statusCode != null) {\n+        if (statusCode == DownloadManager.STATUS_FAILED) {\n+          // todo add failure reason and logging\n+          System.out.println(\"Download Failed for id: \" + id);", "originalCommit": "b270c4efe700860814b5078d60f38b2966934500", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDIxMzM0NA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/2212#discussion_r534213344", "bodyText": "same", "author": "annzimmer", "createdAt": "2020-12-02T14:34:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg0ODM5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg0ODYzNA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/2212#discussion_r533848634", "bodyText": "same", "author": "rlazo", "createdAt": "2020-12-02T02:11:08Z", "path": "firebase-ml-modeldownloader/src/main/java/com/google/firebase/ml/modeldownloader/internal/ModelFileDownloadService.java", "diffHunk": "@@ -0,0 +1,371 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.ml.modeldownloader.internal;\n+\n+import android.app.DownloadManager;\n+import android.app.DownloadManager.Query;\n+import android.app.DownloadManager.Request;\n+import android.content.BroadcastReceiver;\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.IntentFilter;\n+import android.database.Cursor;\n+import android.net.Uri;\n+import android.os.Build.VERSION;\n+import android.os.Build.VERSION_CODES;\n+import android.os.ParcelFileDescriptor;\n+import android.util.LongSparseArray;\n+import androidx.annotation.GuardedBy;\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.annotation.VisibleForTesting;\n+import androidx.annotation.WorkerThread;\n+import com.google.android.gms.tasks.Task;\n+import com.google.android.gms.tasks.TaskCompletionSource;\n+import com.google.android.gms.tasks.Tasks;\n+import com.google.firebase.FirebaseApp;\n+import com.google.firebase.ml.modeldownloader.CustomModel;\n+import com.google.firebase.ml.modeldownloader.CustomModelDownloadConditions;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Calls the Android Download service to copy the model file to device (temp location) and then\n+ * moves file to it's permanent location, updating the model details in shared preferences\n+ * throughout.\n+ *\n+ * @hide\n+ */\n+public class ModelFileDownloadService {\n+\n+  private final DownloadManager downloadManager;\n+  private final Context context;\n+  private final ModelFileManager fileManager;\n+  private final SharedPreferencesUtil sharedPreferencesUtil;\n+\n+  @GuardedBy(\"this\")\n+  // Mapping from download id to broadcast receiver. Because models can update, we cannot just keep\n+  // one instance of DownloadBroadcastReceiver per RemoteModelDownloadManager object.\n+  private final LongSparseArray<DownloadBroadcastReceiver> receiverMaps = new LongSparseArray<>();\n+\n+  @GuardedBy(\"this\")\n+  // Mapping from download id to TaskCompletionSource. Because models can update, we cannot just\n+  // keep one instance of TaskCompletionSource per RemoteModelDownloadManager object.\n+  private final LongSparseArray<TaskCompletionSource<Void>> taskCompletionSourceMaps =\n+      new LongSparseArray<>();\n+\n+  private CustomModelDownloadConditions downloadConditions =\n+      new CustomModelDownloadConditions.Builder().build();\n+\n+  public ModelFileDownloadService(@NonNull FirebaseApp firebaseApp) {\n+    this.context = firebaseApp.getApplicationContext();\n+    downloadManager = (DownloadManager) context.getSystemService(Context.DOWNLOAD_SERVICE);\n+    this.fileManager = ModelFileManager.getInstance();\n+    this.sharedPreferencesUtil = new SharedPreferencesUtil(firebaseApp);\n+  }\n+\n+  @VisibleForTesting\n+  ModelFileDownloadService(\n+      @NonNull FirebaseApp firebaseApp,\n+      DownloadManager downloadManager,\n+      ModelFileManager fileManager,\n+      SharedPreferencesUtil sharedPreferencesUtil) {\n+    this.context = firebaseApp.getApplicationContext();\n+    this.downloadManager = downloadManager;\n+    this.fileManager = fileManager;\n+    this.sharedPreferencesUtil = sharedPreferencesUtil;\n+  }\n+\n+  /**\n+   * Get ModelFileDownloadService instance using the firebase app returned by {@link\n+   * FirebaseApp#getInstance()}\n+   *\n+   * @return ModelFileDownloadService\n+   */\n+  @NonNull\n+  public static ModelFileDownloadService getInstance() {\n+    return FirebaseApp.getInstance().get(ModelFileDownloadService.class);\n+  }\n+\n+  public Task<Void> download(\n+      CustomModel customModel, CustomModelDownloadConditions downloadConditions) {\n+    this.downloadConditions = downloadConditions;\n+    // todo add url tests here\n+    return ensureModelDownloaded(customModel);\n+  }\n+\n+  @VisibleForTesting\n+  Task<Void> ensureModelDownloaded(CustomModel customModel) {\n+    // todo check model not already in progress of being downloaded\n+\n+    // todo remove any failed download attempts\n+\n+    // schedule new download of model file\n+    Long newDownloadId = scheduleModelDownload(customModel);\n+    if (newDownloadId == null) {\n+      return Tasks.forException(new Exception(\"Failed to schedule the download task\"));\n+    }\n+\n+    return registerReceiverForDownloadId(newDownloadId);\n+  }\n+\n+  private synchronized DownloadBroadcastReceiver getReceiverInstance(long downloadId) {\n+    DownloadBroadcastReceiver receiver = receiverMaps.get(downloadId);\n+    if (receiver == null) {\n+      receiver =\n+          new DownloadBroadcastReceiver(downloadId, getTaskCompletionSourceInstance(downloadId));\n+      receiverMaps.put(downloadId, receiver);\n+    }\n+    return receiver;\n+  }\n+\n+  private Task<Void> registerReceiverForDownloadId(long downloadId) {\n+    BroadcastReceiver broadcastReceiver = getReceiverInstance(downloadId);\n+    // It is okay to always register here. Since the broadcast receiver is the same via the lookup\n+    // for the same download id, the same broadcast receiver will be notified only once.\n+    context.registerReceiver(\n+        broadcastReceiver, new IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE));\n+\n+    return getTaskCompletionSourceInstance(downloadId).getTask();\n+  }\n+\n+  @VisibleForTesting\n+  synchronized TaskCompletionSource<Void> getTaskCompletionSourceInstance(long downloadId) {\n+    TaskCompletionSource<Void> taskCompletionSource = taskCompletionSourceMaps.get(downloadId);\n+    if (taskCompletionSource == null) {\n+      taskCompletionSource = new TaskCompletionSource<>();\n+      taskCompletionSourceMaps.put(downloadId, taskCompletionSource);\n+    }\n+\n+    return taskCompletionSource;\n+  }\n+\n+  @VisibleForTesting\n+  synchronized Long scheduleModelDownload(@NonNull CustomModel customModel) {\n+    if (downloadManager == null) {\n+      return null;\n+    }\n+\n+    if (customModel.getDownloadUrl() == null || customModel.getDownloadUrl().isEmpty()) {\n+      return null;\n+    }\n+    // todo handle expired url here and figure out what to do about delayed downloads too..\n+\n+    // Schedule a new downloading\n+    Request downloadRequest = new Request(Uri.parse(customModel.getDownloadUrl()));\n+    // check Url is not expired - get new one if necessary...\n+\n+    // By setting the destination uri to null, the downloaded file will be stored in\n+    // DownloadManager's purgeable cache. As a result, WRITE_EXTERNAL_STORAGE permission is not\n+    // needed.\n+    downloadRequest.setDestinationUri(null);\n+    if (VERSION.SDK_INT >= VERSION_CODES.N) {\n+      downloadRequest.setRequiresCharging(downloadConditions.isChargingRequired());\n+      downloadRequest.setRequiresDeviceIdle(downloadConditions.isDeviceIdleRequired());\n+    }\n+\n+    if (downloadConditions.isWifiRequired()) {\n+      downloadRequest.setAllowedNetworkTypes(Request.NETWORK_WIFI);\n+    }\n+\n+    long id = downloadManager.enqueue(downloadRequest);\n+    // update the custom model to store the download id - do not lose current local file - in case\n+    // this is a background update.\n+    sharedPreferencesUtil.setDownloadingCustomModelDetails(\n+        new CustomModel(\n+            customModel.getName(),\n+            customModel.getModelHash(),\n+            customModel.getSize(),\n+            id,\n+            customModel.getLocalFilePath()));\n+    return id;\n+  }\n+\n+  @Nullable\n+  @VisibleForTesting\n+  synchronized Integer getDownloadingModelStatusCode(Long downloadingId) {\n+    if (downloadManager == null || downloadingId == null) {\n+      return null;\n+    }\n+\n+    Integer statusCode = null;\n+\n+    try (Cursor cursor = downloadManager.query(new Query().setFilterById(downloadingId))) {\n+\n+      if (cursor != null && cursor.moveToFirst()) {\n+        statusCode = cursor.getInt(cursor.getColumnIndex(DownloadManager.COLUMN_STATUS));\n+      }\n+\n+      if (statusCode == null) {\n+        return null;\n+      }\n+\n+      if (statusCode != DownloadManager.STATUS_RUNNING\n+          && statusCode != DownloadManager.STATUS_PAUSED\n+          && statusCode != DownloadManager.STATUS_PENDING\n+          && statusCode != DownloadManager.STATUS_SUCCESSFUL\n+          && statusCode != DownloadManager.STATUS_FAILED) {\n+        // Unknown status\n+        statusCode = null;\n+      }\n+      return statusCode;\n+    }\n+  }\n+\n+  @Nullable\n+  private synchronized ParcelFileDescriptor getDownloadedFile(Long downloadingId) {\n+    if (downloadManager == null || downloadingId == null) {\n+      return null;\n+    }\n+\n+    ParcelFileDescriptor fileDescriptor = null;\n+    try {\n+      fileDescriptor = downloadManager.openDownloadedFile(downloadingId);\n+    } catch (FileNotFoundException e) {\n+      System.out.println(\"Downloaded file is not found\");\n+    }\n+    return fileDescriptor;\n+  }\n+\n+  public void maybeCheckDownloadingComplete() throws Exception {\n+    for (String key : sharedPreferencesUtil.getSharedPreferenceKeySet()) {\n+      // if a local file path is present - get model details.\n+      Matcher matcher =\n+          Pattern.compile(SharedPreferencesUtil.DOWNLOADING_MODEL_ID_MATCHER).matcher(key);\n+      if (matcher.find()) {\n+        String modelName = matcher.group(matcher.groupCount());\n+        CustomModel downloadingModel = sharedPreferencesUtil.getCustomModelDetails(modelName);\n+        Integer statusCode = getDownloadingModelStatusCode(downloadingModel.getDownloadId());\n+        if (statusCode == DownloadManager.STATUS_SUCCESSFUL\n+            || statusCode == DownloadManager.STATUS_FAILED) {\n+          loadNewlyDownloadedModelFile(downloadingModel);\n+        }\n+      }\n+    }\n+  }\n+\n+  @Nullable\n+  @WorkerThread\n+  public File loadNewlyDownloadedModelFile(CustomModel model) throws Exception {\n+    Long downloadingId = model.getDownloadId();\n+    String downloadingModelHash = model.getModelHash();\n+\n+    if (downloadingId == null || downloadingModelHash == null) {\n+      // no downloading model file or incomplete info.\n+      return null;\n+    }\n+\n+    Integer statusCode = getDownloadingModelStatusCode(downloadingId);\n+    if (statusCode == null) {\n+      return null;\n+    }\n+\n+    if (statusCode == DownloadManager.STATUS_SUCCESSFUL) {\n+      // Get downloaded file.\n+      ParcelFileDescriptor fileDescriptor = getDownloadedFile(downloadingId);\n+      if (fileDescriptor == null) {\n+        // reset original model - removing download id.\n+        sharedPreferencesUtil.setFailedUploadedCustomModelDetails(model.getName());\n+        // todo call the download register?\n+        return null;\n+      }\n+\n+      // Try to move it to destination folder.\n+      File newModelFile = fileManager.moveModelToDestinationFolder(model, fileDescriptor);\n+\n+      if (newModelFile == null) {\n+        // reset original model - removing download id.\n+        // todo call the download register?\n+        sharedPreferencesUtil.setFailedUploadedCustomModelDetails(model.getName());\n+        return null;\n+      }\n+\n+      // Successfully moved,  update share preferences\n+      sharedPreferencesUtil.setUploadedCustomModelDetails(\n+          new CustomModel(\n+              model.getName(), model.getModelHash(), model.getSize(), 0, newModelFile.getPath()));\n+\n+      // Cleans up the old files if it is the initial creation.\n+      return newModelFile;\n+    } else if (statusCode == DownloadManager.STATUS_FAILED) {\n+      // reset original model - removing download id.\n+      sharedPreferencesUtil.setFailedUploadedCustomModelDetails(model.getName());\n+      // todo - determine if the temp files need to be clean up? Does one exist?\n+    }\n+    // Other cases, return as null and wait for download finish.\n+    return null;\n+  }\n+\n+  // This class runs totally on worker thread because we registered the receiver with a worker\n+  // thread handler.\n+  @WorkerThread\n+  private class DownloadBroadcastReceiver extends BroadcastReceiver {\n+\n+    // Download Id is captured inside this class in memory. So there is no concern of inconsistency\n+    // with the persisted download id in shared preferences.\n+    private final long downloadId;\n+    private final TaskCompletionSource<Void> taskCompletionSource;\n+\n+    private DownloadBroadcastReceiver(\n+        long downloadId, TaskCompletionSource<Void> taskCompletionSource) {\n+      this.downloadId = downloadId;\n+      this.taskCompletionSource = taskCompletionSource;\n+    }\n+\n+    @Override\n+    public void onReceive(Context context, Intent intent) {\n+      long id = intent.getLongExtra(DownloadManager.EXTRA_DOWNLOAD_ID, -1);\n+      if (id != downloadId) {\n+        return;\n+      }\n+\n+      Integer statusCode = getDownloadingModelStatusCode(downloadId);\n+      synchronized (ModelFileDownloadService.this) {\n+        try {\n+          context.getApplicationContext().unregisterReceiver(this);\n+        } catch (IllegalArgumentException e) {\n+          // If we try to unregister a receiver that was never registered or has been unregistered,\n+          // IllegalArgumentException will be thrown by the Android Framework.\n+          // Our current code does not have this problem. However, in order to be safer in the\n+          // future, we just ignore the exception here, because it is not a big deal. The code can\n+          // move on.\n+        }\n+\n+        receiverMaps.remove(downloadId);\n+        taskCompletionSourceMaps.remove(downloadId);\n+      }\n+\n+      if (statusCode != null) {\n+        if (statusCode == DownloadManager.STATUS_FAILED) {\n+          // todo add failure reason and logging\n+          System.out.println(\"Download Failed for id: \" + id);\n+          taskCompletionSource.setException(new Exception(\"Failed\"));\n+          return;\n+        }\n+\n+        if (statusCode == DownloadManager.STATUS_SUCCESSFUL) {\n+          System.out.println(\"Download Succeeded for id: \" + id);", "originalCommit": "b270c4efe700860814b5078d60f38b2966934500", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDIxMzMxMQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/2212#discussion_r534213311", "bodyText": "same", "author": "annzimmer", "createdAt": "2020-12-02T14:34:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg0ODYzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg0ODk3Mw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/2212#discussion_r533848973", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private @Nullable File getModelDirUnsafe(@NonNull String modelName) {\n          \n          \n            \n              @Nullable private File getModelDirUnsafe(@NonNull String modelName) {", "author": "rlazo", "createdAt": "2020-12-02T02:12:12Z", "path": "firebase-ml-modeldownloader/src/main/java/com/google/firebase/ml/modeldownloader/internal/ModelFileManager.java", "diffHunk": "@@ -0,0 +1,165 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+package com.google.firebase.ml.modeldownloader.internal;\n+\n+import android.content.Context;\n+import android.os.Build.VERSION;\n+import android.os.Build.VERSION_CODES;\n+import android.os.ParcelFileDescriptor;\n+import android.os.ParcelFileDescriptor.AutoCloseInputStream;\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.annotation.VisibleForTesting;\n+import androidx.annotation.WorkerThread;\n+import com.google.firebase.FirebaseApp;\n+import com.google.firebase.ml.modeldownloader.CustomModel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+\n+/** Model File Manager is used to move the downloaded file to the appropriate locations. */\n+public class ModelFileManager {\n+\n+  @VisibleForTesting\n+  static final String CUSTOM_MODEL_ROOT_PATH = \"com.google.firebase.ml.custom.models\";\n+\n+  private static final int INVALID_INDEX = -1;\n+  private final Context context;\n+  private final FirebaseApp firebaseApp;\n+\n+  public ModelFileManager(@NonNull FirebaseApp firebaseApp) {\n+    this.context = firebaseApp.getApplicationContext();\n+    this.firebaseApp = firebaseApp;\n+  }\n+\n+  /**\n+   * Get ModelFileDownloadService instance using the firebase app returned by {@link\n+   * FirebaseApp#getInstance()}\n+   *\n+   * @return ModelFileDownloadService\n+   */\n+  @NonNull\n+  public static ModelFileManager getInstance() {\n+    return FirebaseApp.getInstance().get(ModelFileManager.class);\n+  }\n+\n+  /**\n+   * Get the directory where the model is supposed to reside. This method does not ensure that the\n+   * directory specified does exist. If you need to ensure its existence, you should call\n+   * getDirImpl.\n+   */\n+  private @Nullable File getModelDirUnsafe(@NonNull String modelName) {", "originalCommit": "b270c4efe700860814b5078d60f38b2966934500", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg0OTM4NA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/2212#discussion_r533849384", "bodyText": "same", "author": "rlazo", "createdAt": "2020-12-02T02:13:24Z", "path": "firebase-ml-modeldownloader/src/main/java/com/google/firebase/ml/modeldownloader/internal/ModelFileManager.java", "diffHunk": "@@ -0,0 +1,165 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+package com.google.firebase.ml.modeldownloader.internal;\n+\n+import android.content.Context;\n+import android.os.Build.VERSION;\n+import android.os.Build.VERSION_CODES;\n+import android.os.ParcelFileDescriptor;\n+import android.os.ParcelFileDescriptor.AutoCloseInputStream;\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.annotation.VisibleForTesting;\n+import androidx.annotation.WorkerThread;\n+import com.google.firebase.FirebaseApp;\n+import com.google.firebase.ml.modeldownloader.CustomModel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+\n+/** Model File Manager is used to move the downloaded file to the appropriate locations. */\n+public class ModelFileManager {\n+\n+  @VisibleForTesting\n+  static final String CUSTOM_MODEL_ROOT_PATH = \"com.google.firebase.ml.custom.models\";\n+\n+  private static final int INVALID_INDEX = -1;\n+  private final Context context;\n+  private final FirebaseApp firebaseApp;\n+\n+  public ModelFileManager(@NonNull FirebaseApp firebaseApp) {\n+    this.context = firebaseApp.getApplicationContext();\n+    this.firebaseApp = firebaseApp;\n+  }\n+\n+  /**\n+   * Get ModelFileDownloadService instance using the firebase app returned by {@link\n+   * FirebaseApp#getInstance()}\n+   *\n+   * @return ModelFileDownloadService\n+   */\n+  @NonNull\n+  public static ModelFileManager getInstance() {\n+    return FirebaseApp.getInstance().get(ModelFileManager.class);\n+  }\n+\n+  /**\n+   * Get the directory where the model is supposed to reside. This method does not ensure that the\n+   * directory specified does exist. If you need to ensure its existence, you should call\n+   * getDirImpl.\n+   */\n+  private @Nullable File getModelDirUnsafe(@NonNull String modelName) {\n+    String modelTypeSpecificRoot = CUSTOM_MODEL_ROOT_PATH;\n+    File root;\n+    if (VERSION.SDK_INT >= VERSION_CODES.LOLLIPOP) {\n+      root = new File(context.getNoBackupFilesDir(), modelTypeSpecificRoot);\n+    } else {\n+      root = context.getApplicationContext().getDir(modelTypeSpecificRoot, Context.MODE_PRIVATE);\n+    }\n+    File firebaseAppDir = new File(root, firebaseApp.getPersistenceKey());\n+    return new File(firebaseAppDir, modelName);\n+  }\n+\n+  /**\n+   * Gets the directory in the following schema:\n+   * app_root/model_type_specific_root/[temp]/firebase_app_persistence_key/model_name.\n+   */\n+  @VisibleForTesting\n+  @WorkerThread\n+  File getDirImpl(@NonNull String modelName) throws Exception {\n+    File modelDir = getModelDirUnsafe(modelName);\n+    if (!modelDir.exists()) {\n+      if (!modelDir.mkdirs()) {\n+        throw new Exception(\"Failed to create model folder: \" + modelDir);\n+      }\n+    } else if (!modelDir.isDirectory()) {\n+      throw new Exception(\n+          \"Can not create model folder, since an existing file has the same name: \" + modelDir);\n+    }\n+    return modelDir;\n+  }\n+\n+  /**\n+   * Since the model files under the model folder are named with numbers, and the later one is the\n+   * newer, the latest model is the file name with largest number.\n+   */\n+  @WorkerThread\n+  private int getLatestCachedModelVersion(@NonNull File modelDir) {\n+    File[] modelFiles = modelDir.listFiles();\n+    if (modelFiles == null || modelFiles.length == 0) {\n+      return INVALID_INDEX;\n+    }\n+\n+    int index = INVALID_INDEX;\n+    for (File modelFile : modelFiles) {\n+      try {\n+        index = Math.max(index, Integer.parseInt(modelFile.getName()));\n+      } catch (NumberFormatException e) {\n+        System.out.println(\"Contains non-integer file name \" + modelFile.getName());", "originalCommit": "b270c4efe700860814b5078d60f38b2966934500", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDIxMzI2Ng==", "url": "https://github.com/firebase/firebase-android-sdk/pull/2212#discussion_r534213266", "bodyText": "same", "author": "annzimmer", "createdAt": "2020-12-02T14:34:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg0OTM4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg0OTcwNg==", "url": "https://github.com/firebase/firebase-android-sdk/pull/2212#discussion_r533849706", "bodyText": "same", "author": "rlazo", "createdAt": "2020-12-02T02:14:31Z", "path": "firebase-ml-modeldownloader/src/main/java/com/google/firebase/ml/modeldownloader/internal/ModelFileManager.java", "diffHunk": "@@ -0,0 +1,165 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+package com.google.firebase.ml.modeldownloader.internal;\n+\n+import android.content.Context;\n+import android.os.Build.VERSION;\n+import android.os.Build.VERSION_CODES;\n+import android.os.ParcelFileDescriptor;\n+import android.os.ParcelFileDescriptor.AutoCloseInputStream;\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.annotation.VisibleForTesting;\n+import androidx.annotation.WorkerThread;\n+import com.google.firebase.FirebaseApp;\n+import com.google.firebase.ml.modeldownloader.CustomModel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+\n+/** Model File Manager is used to move the downloaded file to the appropriate locations. */\n+public class ModelFileManager {\n+\n+  @VisibleForTesting\n+  static final String CUSTOM_MODEL_ROOT_PATH = \"com.google.firebase.ml.custom.models\";\n+\n+  private static final int INVALID_INDEX = -1;\n+  private final Context context;\n+  private final FirebaseApp firebaseApp;\n+\n+  public ModelFileManager(@NonNull FirebaseApp firebaseApp) {\n+    this.context = firebaseApp.getApplicationContext();\n+    this.firebaseApp = firebaseApp;\n+  }\n+\n+  /**\n+   * Get ModelFileDownloadService instance using the firebase app returned by {@link\n+   * FirebaseApp#getInstance()}\n+   *\n+   * @return ModelFileDownloadService\n+   */\n+  @NonNull\n+  public static ModelFileManager getInstance() {\n+    return FirebaseApp.getInstance().get(ModelFileManager.class);\n+  }\n+\n+  /**\n+   * Get the directory where the model is supposed to reside. This method does not ensure that the\n+   * directory specified does exist. If you need to ensure its existence, you should call\n+   * getDirImpl.\n+   */\n+  private @Nullable File getModelDirUnsafe(@NonNull String modelName) {\n+    String modelTypeSpecificRoot = CUSTOM_MODEL_ROOT_PATH;\n+    File root;\n+    if (VERSION.SDK_INT >= VERSION_CODES.LOLLIPOP) {\n+      root = new File(context.getNoBackupFilesDir(), modelTypeSpecificRoot);\n+    } else {\n+      root = context.getApplicationContext().getDir(modelTypeSpecificRoot, Context.MODE_PRIVATE);\n+    }\n+    File firebaseAppDir = new File(root, firebaseApp.getPersistenceKey());\n+    return new File(firebaseAppDir, modelName);\n+  }\n+\n+  /**\n+   * Gets the directory in the following schema:\n+   * app_root/model_type_specific_root/[temp]/firebase_app_persistence_key/model_name.\n+   */\n+  @VisibleForTesting\n+  @WorkerThread\n+  File getDirImpl(@NonNull String modelName) throws Exception {\n+    File modelDir = getModelDirUnsafe(modelName);\n+    if (!modelDir.exists()) {\n+      if (!modelDir.mkdirs()) {\n+        throw new Exception(\"Failed to create model folder: \" + modelDir);\n+      }\n+    } else if (!modelDir.isDirectory()) {\n+      throw new Exception(\n+          \"Can not create model folder, since an existing file has the same name: \" + modelDir);\n+    }\n+    return modelDir;\n+  }\n+\n+  /**\n+   * Since the model files under the model folder are named with numbers, and the later one is the\n+   * newer, the latest model is the file name with largest number.\n+   */\n+  @WorkerThread\n+  private int getLatestCachedModelVersion(@NonNull File modelDir) {\n+    File[] modelFiles = modelDir.listFiles();\n+    if (modelFiles == null || modelFiles.length == 0) {\n+      return INVALID_INDEX;\n+    }\n+\n+    int index = INVALID_INDEX;\n+    for (File modelFile : modelFiles) {\n+      try {\n+        index = Math.max(index, Integer.parseInt(modelFile.getName()));\n+      } catch (NumberFormatException e) {\n+        System.out.println(\"Contains non-integer file name \" + modelFile.getName());\n+      }\n+    }\n+    return index;\n+  }\n+\n+  @VisibleForTesting\n+  @Nullable\n+  File getModelFileDestination(@NonNull CustomModel model) throws Exception {\n+    File destFolder = getDirImpl(model.getName());\n+    int index = getLatestCachedModelVersion(destFolder);\n+    return new File(destFolder, String.valueOf(index + 1));\n+  }\n+\n+  /**\n+   * Moves a downloaded file from external storage to private folder.\n+   *\n+   * <p>The private file path pattern is /%private_folder%/%firebaseapp_persistentkey%/%model_name%/\n+   *\n+   * <p>The model file under the model folder are named with numbers starting from 0. The larger one\n+   * is the newer model downloaded from cloud.\n+   *\n+   * <p>The caller is supposed to cleanup the previous downloaded files after this call, even when\n+   * this call throws exception.\n+   *\n+   * @return null if the movement failed. Otherwise, return the destination file.\n+   */\n+  @Nullable\n+  @WorkerThread\n+  public synchronized File moveModelToDestinationFolder(\n+      @NonNull CustomModel customModel, @NonNull ParcelFileDescriptor modelFileDescriptor)\n+      throws Exception {\n+    File modelFileDestination = getModelFileDestination(customModel);\n+\n+    // Moves to the final destination file in app private folder to avoid the downloaded file from\n+    // being changed by\n+    // other apps.\n+    try (FileInputStream fis = new AutoCloseInputStream(modelFileDescriptor);\n+        FileOutputStream fos = new FileOutputStream(modelFileDestination)) {\n+      byte[] buffer = new byte[4096];\n+      int read;\n+      while ((read = fis.read(buffer)) != -1) {\n+        fos.write(buffer, 0, read);\n+      }\n+      // Let's be extra sure it is all written before we return.\n+      fos.getFD().sync();\n+    } catch (IOException e) {\n+      // Failed to copy to destination - clean up.\n+      System.out.println(\"Failed to copy downloaded model file to destination folder: \" + e);", "originalCommit": "b270c4efe700860814b5078d60f38b2966934500", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDIxMzI1MA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/2212#discussion_r534213250", "bodyText": "same", "author": "annzimmer", "createdAt": "2020-12-02T14:34:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzg0OTcwNg=="}], "type": "inlineReview"}, {"oid": "2f8dc9d34b83ca5d9206de4165f651ea3e02d48d", "url": "https://github.com/firebase/firebase-android-sdk/commit/2f8dc9d34b83ca5d9206de4165f651ea3e02d48d", "message": "Update firebase-ml-modeldownloader/src/main/java/com/google/firebase/ml/modeldownloader/CustomModel.java\n\nCo-authored-by: Rodrigo Lazo <rlazo@users.noreply.github.com>", "committedDate": "2020-12-02T14:32:13Z", "type": "commit"}, {"oid": "ad66c713aebf083655e43139951ea8d9c1766d72", "url": "https://github.com/firebase/firebase-android-sdk/commit/ad66c713aebf083655e43139951ea8d9c1766d72", "message": "Update firebase-ml-modeldownloader/src/main/java/com/google/firebase/ml/modeldownloader/FirebaseModelDownloader.java\n\nCo-authored-by: Rodrigo Lazo <rlazo@users.noreply.github.com>", "committedDate": "2020-12-02T14:32:31Z", "type": "commit"}, {"oid": "adba84f41ab130467adb7c09ba5c5d3f2284c798", "url": "https://github.com/firebase/firebase-android-sdk/commit/adba84f41ab130467adb7c09ba5c5d3f2284c798", "message": "Update firebase-ml-modeldownloader/src/main/java/com/google/firebase/ml/modeldownloader/internal/ModelFileManager.java\n\nCo-authored-by: Rodrigo Lazo <rlazo@users.noreply.github.com>", "committedDate": "2020-12-02T14:33:47Z", "type": "commit"}, {"oid": "1357344c179dd046d67d1665f512a835158c76d2", "url": "https://github.com/firebase/firebase-android-sdk/commit/1357344c179dd046d67d1665f512a835158c76d2", "message": "Updating formatting after reviewer sugggested changes.", "committedDate": "2020-12-02T20:30:45Z", "type": "commit"}, {"oid": "a838a77b6c3196dbb53e86f3c9577633669b6217", "url": "https://github.com/firebase/firebase-android-sdk/commit/a838a77b6c3196dbb53e86f3c9577633669b6217", "message": "Updating firebaseInstallationApi component to avoid error message.", "committedDate": "2020-12-02T20:54:38Z", "type": "commit"}, {"oid": "999a7dca614c8fff9e5a3d3dd0f79086358b5604", "url": "https://github.com/firebase/firebase-android-sdk/commit/999a7dca614c8fff9e5a3d3dd0f79086358b5604", "message": "Updating firebaseInstallationApi component to avoid error message.", "committedDate": "2020-12-02T20:55:45Z", "type": "commit"}]}