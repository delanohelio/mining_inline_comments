{"pr_number": 1600, "pr_title": "inital implementation of typeToken for decoder", "pr_createdAt": "2020-05-27T18:34:39Z", "pr_url": "https://github.com/firebase/firebase-android-sdk/pull/1600", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM2MjcwMg==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1600#discussion_r431362702", "bodyText": "make final?", "author": "vkryachko", "createdAt": "2020-05-27T18:41:30Z", "path": "encoders/firebase-decoders-json/src/main/java/com/google/firebase/decoders/ArrayToken.java", "diffHunk": "@@ -0,0 +1,27 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders;\n+\n+class ArrayToken<T> extends TypeToken<T> {\n+  private TypeToken<?> componentType;", "originalCommit": "24fe0161073938bcab3fe01aca2cf704db0cd7a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM2Mjg2Nw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1600#discussion_r431362867", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private Class<T> rawType;\n          \n          \n            \n              private TypeTokenContainer typeArguments;\n          \n          \n            \n              private final Class<T> rawType;\n          \n          \n            \n              private final TypeTokenContainer typeArguments;", "author": "vkryachko", "createdAt": "2020-05-27T18:41:50Z", "path": "encoders/firebase-decoders-json/src/main/java/com/google/firebase/decoders/ClassToken.java", "diffHunk": "@@ -0,0 +1,38 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders;\n+\n+class ClassToken<T> extends TypeToken<T> {\n+  private Class<T> rawType;\n+  private TypeTokenContainer typeArguments;", "originalCommit": "24fe0161073938bcab3fe01aca2cf704db0cd7a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM2MzY1OA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1600#discussion_r431363658", "bodyText": "consider making this class empty and moving this logic to TypeToken#of(Safe)", "author": "vkryachko", "createdAt": "2020-05-27T18:43:12Z", "path": "encoders/firebase-decoders-json/src/main/java/com/google/firebase/decoders/Safe.java", "diffHunk": "@@ -0,0 +1,35 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+\n+public abstract class Safe<T> {\n+\n+  private final Type type;\n+\n+  Safe() {\n+    Type superclass = getClass().getGenericSuperclass();\n+    if (superclass instanceof Class) {\n+      throw new RuntimeException(\"Missing type parameters\");\n+    }\n+    this.type = ((ParameterizedType) superclass).getActualTypeArguments()[0];", "originalCommit": "24fe0161073938bcab3fe01aca2cf704db0cd7a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM2NjU0Mw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1600#discussion_r431366543", "bodyText": "We would want to forbid any subclasses of this class other than ClassToken and ArrayToken effectively making this class \"sealed\". The only way to achieve it in java is to statically nest ClassToken and ArrayToken inside TypeToken and make its constructor private.", "author": "vkryachko", "createdAt": "2020-05-27T18:48:34Z", "path": "encoders/firebase-decoders-json/src/main/java/com/google/firebase/decoders/TypeToken.java", "diffHunk": "@@ -0,0 +1,73 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders;\n+\n+import androidx.annotation.NonNull;\n+\n+import java.lang.reflect.GenericArrayType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.WildcardType;\n+\n+public abstract class TypeToken<T> {", "originalCommit": "24fe0161073938bcab3fe01aca2cf704db0cd7a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA1NDkxMg==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1600#discussion_r432054912", "bodyText": "afaict this still needs a private constructor, to forbid other subclasses", "author": "vkryachko", "createdAt": "2020-05-28T19:00:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM2NjU0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM2NzY1Ng==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1600#discussion_r431367656", "bodyText": "we have to handle the case when getUpperBounds() is empty and throw an exception. This could happen if I specify TypeToken.of(new Safe<List<? super Foo>>() {})", "author": "vkryachko", "createdAt": "2020-05-27T18:50:35Z", "path": "encoders/firebase-decoders-json/src/main/java/com/google/firebase/decoders/TypeToken.java", "diffHunk": "@@ -0,0 +1,73 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders;\n+\n+import androidx.annotation.NonNull;\n+\n+import java.lang.reflect.GenericArrayType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.WildcardType;\n+\n+public abstract class TypeToken<T> {\n+\n+\n+  @NonNull\n+  public static <T> TypeToken<T> of(@NonNull Safe<T> token) {\n+    Type type = token.getType();\n+    return of(type);\n+  }\n+\n+  @NonNull\n+  private static <T> TypeToken<T> of(@NonNull Type type) {\n+    if(type instanceof WildcardType) {\n+      return of(((WildcardType) type).getUpperBounds()[0]);", "originalCommit": "24fe0161073938bcab3fe01aca2cf704db0cd7a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAzOTc0Ng==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1600#discussion_r432039746", "bodyText": "It turns out that upperBounds() of TypeToken.of(new Safe<List<? super Foo>>() {}) is Object.class.  And we cannot compare it with Object.class, since the upperBound of TypeToken.of(new Safe<List<? extend Object>>() {}) is Object.class as well.\nInstead, lowerBouds() is empty when I specify TypeToken.of(new Safe<List<? extend Foo>>() {}).\nSince bounded wild card type only has those two options, we can prevent it as follow:\n      if(((WildcardType) type).getLowerBounds().length == 0) {\n        return of(((WildcardType) type).getUpperBounds()[0]);\n      }\n      throw new RuntimeException(\"<? super T> is not supported\");\n\n@vkryachko\nWdyt?", "author": "James201311", "createdAt": "2020-05-28T18:33:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM2NzY1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM4ODI5MQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1600#discussion_r431388291", "bodyText": "to make types align a bit better, consider changing to:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            class ArrayToken<T> extends TypeToken<T> {\n          \n          \n            \n              private TypeToken<?> componentType;\n          \n          \n            \n            class ArrayToken<T> extends TypeToken<T[]> {\n          \n          \n            \n              private TypeToken<T> componentType;\n          \n      \n    \n    \n  \n\nThis might make it harder to implement TypeToken#of() but having the types align externally is a useful property to have.", "author": "vkryachko", "createdAt": "2020-05-27T19:20:49Z", "path": "encoders/firebase-decoders-json/src/main/java/com/google/firebase/decoders/ArrayToken.java", "diffHunk": "@@ -0,0 +1,27 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders;\n+\n+class ArrayToken<T> extends TypeToken<T> {\n+  private TypeToken<?> componentType;", "originalCommit": "24fe0161073938bcab3fe01aca2cf704db0cd7a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgyMjU5NQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1600#discussion_r431822595", "bodyText": "Haven't figured out a way to do T[], but find another easy way to align types a bit better. what do you think? @vkryachko\n  public static class ArrayToken<T, C> extends TypeToken<T> {\n    private final TypeToken<C> componentType;\n\n    private ArrayToken(TypeToken<C> componentType) {\n      this.componentType = componentType;\n    }\n\n    @NonNull\n    public TypeToken<C> getComponentType() {\n      return componentType;\n    }\n  }", "author": "James201311", "createdAt": "2020-05-28T13:11:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM4ODI5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg0MTMwNg==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1600#discussion_r431841306", "bodyText": "One thing to consider in the T,C approach is that T and C are completely unconstrained and unrelated, so even though the only sensible instantiation of such an array token would be ArrayToken<T[], T>, I can construct arbitrary pairs like ArrayToken<List<String>, Boolean>, which arguably does not make much sense.\nWhereas with the T[] approach it is guaranteed that ArrayToken<T>s have components of type T while also - at the type level - being TypeToken<T[]>s, inherently indicating the fact that they are indeed arrays. wdyt?", "author": "vkryachko", "createdAt": "2020-05-28T13:39:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM4ODI5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg3MDE3OQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1600#discussion_r431870179", "bodyText": "Haven't figured out a way to do T[]\n\nWe can pair on this one offline if you like", "author": "vkryachko", "createdAt": "2020-05-28T14:18:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM4ODI5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg5NDE4NQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1600#discussion_r431894185", "bodyText": "Actually, having thought more about it, it might not be such a good idea to have T[] as it makes it hard to work with ArrayTokens in generic code, i.e. if I have a TypeToken<T> there is no way I can correctly cast it to ArrayToken<???> as I cannot take away the array-ness off of T. Maybe for now let's leave it as you have it currently: with a ? component type", "author": "vkryachko", "createdAt": "2020-05-28T14:45:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM4ODI5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk2Mjk4OQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1600#discussion_r431962989", "bodyText": "Yes, I agree. Let's leave it as ? type.", "author": "James201311", "createdAt": "2020-05-28T16:20:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM4ODI5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM4OTM0MA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1600#discussion_r431389340", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              ArrayToken(TypeToken<?> componentType) {\n          \n          \n            \n              ArrayToken(TypeToken<T> componentType) {", "author": "vkryachko", "createdAt": "2020-05-27T19:22:56Z", "path": "encoders/firebase-decoders-json/src/main/java/com/google/firebase/decoders/ArrayToken.java", "diffHunk": "@@ -0,0 +1,27 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders;\n+\n+class ArrayToken<T> extends TypeToken<T> {\n+  private TypeToken<?> componentType;\n+\n+  ArrayToken(TypeToken<?> componentType) {", "originalCommit": "24fe0161073938bcab3fe01aca2cf704db0cd7a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM4OTQxMA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1600#discussion_r431389410", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public TypeToken<?> getComponentType() {\n          \n          \n            \n              public TypeToken<T> getComponentType() {", "author": "vkryachko", "createdAt": "2020-05-27T19:23:03Z", "path": "encoders/firebase-decoders-json/src/main/java/com/google/firebase/decoders/ArrayToken.java", "diffHunk": "@@ -0,0 +1,27 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders;\n+\n+class ArrayToken<T> extends TypeToken<T> {\n+  private TypeToken<?> componentType;\n+\n+  ArrayToken(TypeToken<?> componentType) {\n+    this.componentType = componentType;\n+  }\n+\n+  public TypeToken<?> getComponentType() {", "originalCommit": "24fe0161073938bcab3fe01aca2cf704db0cd7a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM5MDQwMw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1600#discussion_r431390403", "bodyText": "Additionally all of these classes need hashCode() and equals() implementations(as well as toString() to be developer friendly), these can be done in a follow up PR but please add a TODO comment about it.", "author": "vkryachko", "createdAt": "2020-05-27T19:25:02Z", "path": "encoders/firebase-decoders-json/src/main/java/com/google/firebase/decoders/TypeToken.java", "diffHunk": "@@ -0,0 +1,73 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders;\n+\n+import androidx.annotation.NonNull;\n+\n+import java.lang.reflect.GenericArrayType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.WildcardType;\n+\n+public abstract class TypeToken<T> {", "originalCommit": "24fe0161073938bcab3fe01aca2cf704db0cd7a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM5MzcwNg==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1600#discussion_r431393706", "bodyText": "It's not common to use raw asserts in java, see: go/java-practices/assertions\nAdditionally components type can never be null since you check for isArray() above, pls consider remove this line.", "author": "vkryachko", "createdAt": "2020-05-27T19:31:07Z", "path": "encoders/firebase-decoders-json/src/main/java/com/google/firebase/decoders/TypeToken.java", "diffHunk": "@@ -0,0 +1,73 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders;\n+\n+import androidx.annotation.NonNull;\n+\n+import java.lang.reflect.GenericArrayType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.WildcardType;\n+\n+public abstract class TypeToken<T> {\n+\n+\n+  @NonNull\n+  public static <T> TypeToken<T> of(@NonNull Safe<T> token) {\n+    Type type = token.getType();\n+    return of(type);\n+  }\n+\n+  @NonNull\n+  private static <T> TypeToken<T> of(@NonNull Type type) {\n+    if(type instanceof WildcardType) {\n+      return of(((WildcardType) type).getUpperBounds()[0]);\n+    }\n+\n+    if (type instanceof GenericArrayType) {\n+      Type componentType = ((GenericArrayType) type).getGenericComponentType();\n+      return new ArrayToken<T>(TypeToken.of(componentType));\n+    }\n+\n+    //Regular Class Type || Primitive Type || Non-Generic Array Type\n+    if (type instanceof Class<?>) {\n+      Class<T> typeToken = (Class<T>) type;\n+      return of(typeToken);\n+    }\n+\n+    ParameterizedType parameterizedType = (ParameterizedType) type;\n+    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n+    Class<T> rawType = (Class<T>) (parameterizedType.getRawType());\n+\n+    TypeTokenContainer container = new TypeTokenContainer() {\n+      @NonNull\n+      @Override\n+      public <T> TypeToken<T> at(int index) {\n+        return TypeToken.of(actualTypeArguments[index]);\n+      }\n+    };\n+    return new ClassToken<T>(rawType, container);\n+  }\n+\n+  @NonNull\n+  public static <T> TypeToken<T> of(@NonNull Class<T> typeToken) {\n+    if (typeToken.isArray()) {\n+      Class<?> componentTypeToken = typeToken.getComponentType();\n+      assert componentTypeToken != null;", "originalCommit": "24fe0161073938bcab3fe01aca2cf704db0cd7a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk3NDA3Ng==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1600#discussion_r431974076", "bodyText": "i don't have access to go/java-practices/.\nwondering is the content as same as http://google.github.io/styleguide/javaguide.html?", "author": "James201311", "createdAt": "2020-05-28T16:38:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM5MzcwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM5Njk1Mg==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1600#discussion_r431396952", "bodyText": "Instead of unconditionally casting to ClassToken I suggest you make explicit checks for instanceof, this will make test failures more clear and explicit.\nI'd recommend a pattern like:\nTypeToken<Integer> token = TypeToken.of(int.class);\nassertThat(token).isInstanceOf(ClassToken.class);\n\nClassToken<Integer> intToken = (ClassToken<Integer>) token;\n// test the rest\n\nAdditionally it might not be required to test all primitives, a couple should be enough.", "author": "vkryachko", "createdAt": "2020-05-27T19:37:14Z", "path": "encoders/firebase-decoders-json/src/test/java/com/google/firebase/decoders/TypeTokenTest.java", "diffHunk": "@@ -0,0 +1,109 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+@RunWith(JUnit4.class)\n+public class TypeTokenTest {\n+  static class Foo {}\n+\n+  //Primitive type\n+  @Test\n+  public void primitiveType_typeIsCorrectlyCaptured(){\n+    ClassToken<?> intToken = (ClassToken<?>) TypeToken.of(int.class);", "originalCommit": "24fe0161073938bcab3fe01aca2cf704db0cd7a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM5NzU1MQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1600#discussion_r431397551", "bodyText": "we use https://truth.dev/ in this repo, please consider using it as well instead of plain junit asserts.", "author": "vkryachko", "createdAt": "2020-05-27T19:38:28Z", "path": "encoders/firebase-decoders-json/src/test/java/com/google/firebase/decoders/TypeTokenTest.java", "diffHunk": "@@ -0,0 +1,109 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+@RunWith(JUnit4.class)\n+public class TypeTokenTest {\n+  static class Foo {}\n+\n+  //Primitive type\n+  @Test\n+  public void primitiveType_typeIsCorrectlyCaptured(){\n+    ClassToken<?> intToken = (ClassToken<?>) TypeToken.of(int.class);\n+    ClassToken<?> doubleToken = (ClassToken<?>) TypeToken.of(double.class);\n+    ClassToken<?> floatToken = (ClassToken<?>) TypeToken.of(float.class);\n+    ClassToken<?> longToken = (ClassToken<?>) TypeToken.of(long.class);\n+    ClassToken<?> byteToken = (ClassToken<?>) TypeToken.of(byte.class);\n+    ClassToken<?> charToken = (ClassToken<?>) TypeToken.of(char.class);\n+    ClassToken<?> shortToken = (ClassToken<?>) TypeToken.of(short.class);\n+    ClassToken<?> booleanToken = (ClassToken<?>) TypeToken.of(boolean.class);\n+\n+    assertEquals(intToken.getRawType(), int.class);", "originalCommit": "24fe0161073938bcab3fe01aca2cf704db0cd7a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM5ODAwMA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1600#discussion_r431398000", "bodyText": "Same here regarding raw casts.", "author": "vkryachko", "createdAt": "2020-05-27T19:39:22Z", "path": "encoders/firebase-decoders-json/src/test/java/com/google/firebase/decoders/TypeTokenTest.java", "diffHunk": "@@ -0,0 +1,109 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+@RunWith(JUnit4.class)\n+public class TypeTokenTest {\n+  static class Foo {}\n+\n+  //Primitive type\n+  @Test\n+  public void primitiveType_typeIsCorrectlyCaptured(){\n+    ClassToken<?> intToken = (ClassToken<?>) TypeToken.of(int.class);\n+    ClassToken<?> doubleToken = (ClassToken<?>) TypeToken.of(double.class);\n+    ClassToken<?> floatToken = (ClassToken<?>) TypeToken.of(float.class);\n+    ClassToken<?> longToken = (ClassToken<?>) TypeToken.of(long.class);\n+    ClassToken<?> byteToken = (ClassToken<?>) TypeToken.of(byte.class);\n+    ClassToken<?> charToken = (ClassToken<?>) TypeToken.of(char.class);\n+    ClassToken<?> shortToken = (ClassToken<?>) TypeToken.of(short.class);\n+    ClassToken<?> booleanToken = (ClassToken<?>) TypeToken.of(boolean.class);\n+\n+    assertEquals(intToken.getRawType(), int.class);\n+    assertEquals(doubleToken.getRawType(), double.class);\n+    assertEquals(floatToken.getRawType(), float.class);\n+    assertEquals(longToken.getRawType(), long.class);\n+    assertEquals(byteToken.getRawType(), byte.class);\n+    assertEquals(charToken.getRawType(), char.class);\n+    assertEquals(shortToken.getRawType(), short.class);\n+    assertEquals(booleanToken.getRawType(), boolean.class);\n+  }\n+\n+  //Array type\n+  @Test\n+  public void generalArrayTypeWithSafe_componentTypeIsCorrectlyCaptured() {\n+    ClassToken<?> fooComponentType = (ClassToken<?>) ((ArrayToken<?>)TypeToken.of(new Safe<Foo[]>() {})).getComponentType();", "originalCommit": "24fe0161073938bcab3fe01aca2cf704db0cd7a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM5ODkwMA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1600#discussion_r431398900", "bodyText": "it also looks like you're testing 2 things here, even though they are similar consider separating into 2 separate unit tests(context: go/unit-test-practices) , here and throughout", "author": "vkryachko", "createdAt": "2020-05-27T19:41:07Z", "path": "encoders/firebase-decoders-json/src/test/java/com/google/firebase/decoders/TypeTokenTest.java", "diffHunk": "@@ -0,0 +1,109 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+@RunWith(JUnit4.class)\n+public class TypeTokenTest {\n+  static class Foo {}\n+\n+  //Primitive type\n+  @Test\n+  public void primitiveType_typeIsCorrectlyCaptured(){\n+    ClassToken<?> intToken = (ClassToken<?>) TypeToken.of(int.class);\n+    ClassToken<?> doubleToken = (ClassToken<?>) TypeToken.of(double.class);\n+    ClassToken<?> floatToken = (ClassToken<?>) TypeToken.of(float.class);\n+    ClassToken<?> longToken = (ClassToken<?>) TypeToken.of(long.class);\n+    ClassToken<?> byteToken = (ClassToken<?>) TypeToken.of(byte.class);\n+    ClassToken<?> charToken = (ClassToken<?>) TypeToken.of(char.class);\n+    ClassToken<?> shortToken = (ClassToken<?>) TypeToken.of(short.class);\n+    ClassToken<?> booleanToken = (ClassToken<?>) TypeToken.of(boolean.class);\n+\n+    assertEquals(intToken.getRawType(), int.class);\n+    assertEquals(doubleToken.getRawType(), double.class);\n+    assertEquals(floatToken.getRawType(), float.class);\n+    assertEquals(longToken.getRawType(), long.class);\n+    assertEquals(byteToken.getRawType(), byte.class);\n+    assertEquals(charToken.getRawType(), char.class);\n+    assertEquals(shortToken.getRawType(), short.class);\n+    assertEquals(booleanToken.getRawType(), boolean.class);\n+  }\n+\n+  //Array type\n+  @Test\n+  public void generalArrayTypeWithSafe_componentTypeIsCorrectlyCaptured() {\n+    ClassToken<?> fooComponentType = (ClassToken<?>) ((ArrayToken<?>)TypeToken.of(new Safe<Foo[]>() {})).getComponentType();\n+    ClassToken<?> intComponentType = (ClassToken<?>) ((ArrayToken<?>)TypeToken.of(new Safe<int[]>() {})).getComponentType();\n+\n+    assertEquals(Foo.class, fooComponentType.getRawType());\n+    assertEquals(int.class, intComponentType.getRawType());", "originalCommit": "24fe0161073938bcab3fe01aca2cf704db0cd7a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA1NTM3Ng==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1600#discussion_r432055376", "bodyText": "How does this test work? afaict typeArguments is null in your implementation.", "author": "vkryachko", "createdAt": "2020-05-28T19:01:39Z", "path": "encoders/firebase-decoders-json/src/test/java/com/google/firebase/decoders/TypeTokenTest.java", "diffHunk": "@@ -0,0 +1,151 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders;\n+\n+import static org.junit.Assert.assertThrows;\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+@RunWith(JUnit4.class)\n+public class TypeTokenTest {\n+  static class Foo {}\n+\n+  //Primitive type\n+  @Test\n+  public void primitiveType_typeIsCorrectlyCaptured(){\n+    TypeToken<Integer> integerTypeToken = TypeToken.of(int.class);\n+    assertThat(integerTypeToken).isInstanceOf(TypeToken.ClassToken.class);\n+    TypeToken.ClassToken<Integer> intToken = (TypeToken.ClassToken<Integer>) integerTypeToken;\n+    assertThat(intToken.getRawType()).isEqualTo(int.class);\n+\n+    TypeToken<Boolean> booleanTypeToken = TypeToken.of(boolean.class);\n+    assertThat(booleanTypeToken).isInstanceOf(TypeToken.ClassToken.class);\n+    TypeToken.ClassToken<Boolean> booleanToken = (TypeToken.ClassToken<Boolean>) booleanTypeToken;\n+    assertThat(booleanToken.getRawType()).isEqualTo(boolean.class);\n+  }\n+\n+  //Array type\n+  @Test\n+  public void generalArrayTypeWithSafe_componentTypeIsCorrectlyCaptured() {\n+    TypeToken<Foo[]> typeToken = TypeToken.of(new Safe<Foo[]>() {});\n+    assertThat(typeToken).isInstanceOf(TypeToken.ArrayToken.class);\n+    TypeToken.ArrayToken<Foo[]> arrayToken = (TypeToken.ArrayToken<Foo[]>) typeToken;\n+    TypeToken<?> componentTypeToken = arrayToken.getComponentType();\n+    assertThat(componentTypeToken).isInstanceOf(TypeToken.ClassToken.class);\n+    TypeToken.ClassToken<Foo> componentToken = (TypeToken.ClassToken<Foo>) componentTypeToken;\n+    assertThat(componentToken.getRawType()).isEqualTo(Foo.class);\n+  }\n+\n+  @Test\n+  public void generalArrayTypeWithoutSafe_componentTypeIsCorrectlyCaptured() {\n+    TypeToken<Foo[]> typeToken = TypeToken.of(Foo[].class);\n+    assertThat(typeToken).isInstanceOf(TypeToken.ArrayToken.class);\n+    TypeToken.ArrayToken<Foo[]> arrayToken = (TypeToken.ArrayToken<Foo[]>) typeToken;\n+    TypeToken<?> componentTypeToken = arrayToken.getComponentType();\n+    assertThat(componentTypeToken).isInstanceOf(TypeToken.ClassToken.class);\n+    TypeToken.ClassToken<Foo> componentToken = (TypeToken.ClassToken<Foo>) componentTypeToken;\n+    assertThat(componentToken.getRawType()).isEqualTo(Foo.class);\n+  }\n+\n+  @Test\n+  public void genericArrayType_rawTypeIsCorrectlyCaptured() {\n+    TypeToken<List<String>[]> typeToken = TypeToken.of(new Safe<List<String>[]>(){});\n+    assertThat(typeToken).isInstanceOf(TypeToken.ArrayToken.class);\n+    TypeToken.ArrayToken<List<String>[]> arrayToken = (TypeToken.ArrayToken<List<String>[]>) typeToken;\n+    TypeToken<List<String>> componentType = (TypeToken<List<String>>) arrayToken.getComponentType();\n+    assertThat(componentType).isInstanceOf(TypeToken.ClassToken.class);\n+    TypeToken.ClassToken<List<String>> componentClassType = (TypeToken.ClassToken<List<String>>) componentType;\n+    assertThat(componentClassType.getRawType()).isEqualTo(List.class);\n+    TypeToken<String> argumentType = ((TypeToken.ClassToken<List<String>>) componentType).getTypeArguments().at(0);\n+    assertThat(argumentType).isInstanceOf(TypeToken.ClassToken.class);\n+    TypeToken.ClassToken<String> argumentClassType = (TypeToken.ClassToken<String>) argumentType;\n+    assertThat(argumentClassType.getRawType()).isEqualTo(String.class);\n+  }\n+\n+  //Plain Class Type\n+  @Test\n+  public void plainClassTypeWithSafe_rawTypeIsCorrectlyCaptured() {\n+    TypeToken<Foo> typeToken = TypeToken.of(new Safe<Foo>() {});\n+    assertThat(typeToken).isInstanceOf(TypeToken.ClassToken.class);\n+    TypeToken.ClassToken<Foo> typeClassToken = (TypeToken.ClassToken<Foo>) typeToken;\n+    assertThat(typeClassToken.getRawType()).isEqualTo(Foo.class);\n+  }\n+\n+  @Test\n+  public void plainClassTypeWithoutSafe_rawTypeIsCorrectlyCaptured() {\n+    TypeToken<Foo> typeToken = TypeToken.of(Foo.class);\n+    assertThat(typeToken).isInstanceOf(TypeToken.ClassToken.class);\n+    TypeToken.ClassToken<Foo> typeClassToken = (TypeToken.ClassToken<Foo>) typeToken;\n+    assertThat(typeClassToken.getRawType()).isEqualTo(Foo.class);\n+  }\n+\n+  //Generic Type\n+  @Test\n+  public void genericType_actualTypeParametersAreCorrectlyCaptured(){\n+    TypeToken<Map<String, Foo>> mapTypeToken = TypeToken.of(new Safe<Map<String, Foo>>() {});\n+    assertThat(mapTypeToken).isInstanceOf(TypeToken.ClassToken.class);\n+    TypeToken.ClassToken<Map<String, Foo>> mapClassToken = (TypeToken.ClassToken<Map<String, Foo>>) mapTypeToken;\n+    TypeTokenContainer typeTokenContainer = mapClassToken.getTypeArguments();\n+    TypeToken<String> firstArgumentToken = typeTokenContainer.at(0);\n+    TypeToken<Foo> secondArgumentTypeToken = typeTokenContainer.at(1);\n+    assertThat(firstArgumentToken).isInstanceOf(TypeToken.ClassToken.class);\n+    assertThat(secondArgumentTypeToken).isInstanceOf(TypeToken.ClassToken.class);\n+    TypeToken.ClassToken<String> firstArgumentClassToken = (TypeToken.ClassToken<String>) firstArgumentToken;\n+    TypeToken.ClassToken<Foo> secondArgumentClassToken = (TypeToken.ClassToken<Foo>) secondArgumentTypeToken;\n+    assertThat(firstArgumentClassToken.getRawType()).isEqualTo(String.class);\n+    assertThat(secondArgumentClassToken.getRawType()).isEqualTo(Foo.class);\n+  }\n+\n+  @Test\n+  public void nestedGenericType_actualTypeParametersAreCorrectlyCaptured(){\n+    TypeToken<List<List<String>>> typeToken = TypeToken.of(new Safe<List<List<String>>>(){});\n+    assertThat(typeToken).isInstanceOf(TypeToken.ClassToken.class);\n+    TypeToken.ClassToken<List<List<String>>> typeClassToken = (TypeToken.ClassToken<List<List<String>>>) typeToken;\n+    TypeToken<List<String>> componentToken = typeClassToken.getTypeArguments().at(0);", "originalCommit": "b53777538931a51ada76504292538ee2e4d854c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjExODk1Mg==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1600#discussion_r432118952", "bodyText": "typeArguments is null only if the ClassToken contains non-generic class type. Otherwise, it will be able to get its actual type parameters.\nThis test makes sure every actual type parameters(as well as the inner component type) can be captured correctly.", "author": "James201311", "createdAt": "2020-05-28T20:57:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA1NTM3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIyODQ2OA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1600#discussion_r432228468", "bodyText": "instead of returning null, can we return an empty TypeTokenContainer instead? Also might be worth making TypeTokenContainer a class instead of an interface.\nOn second thought it's fine this way for this PR, but please address this in a follow up pr.", "author": "vkryachko", "createdAt": "2020-05-29T02:51:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA1NTM3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA1NzA5Mw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1600#discussion_r432057093", "bodyText": "pls throw a more specific exception, e.g. IllegalArgumentException is a good candidate in this case.", "author": "vkryachko", "createdAt": "2020-05-28T19:04:51Z", "path": "encoders/firebase-decoders-json/src/main/java/com/google/firebase/decoders/TypeToken.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders;\n+\n+import androidx.annotation.NonNull;\n+\n+import java.lang.reflect.GenericArrayType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.WildcardType;\n+\n+//TODO: implement hashCode(), equals(), and toString().\n+public abstract class TypeToken<T> {\n+\n+  @NonNull\n+  public static <T> TypeToken<T> of(@NonNull Safe<T> token) {\n+    Type superclass = token.getClass().getGenericSuperclass();\n+    if (superclass instanceof Class) {\n+      throw new RuntimeException(\"Missing type parameters\");", "originalCommit": "b53777538931a51ada76504292538ee2e4d854c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA1NzIzNw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1600#discussion_r432057237", "bodyText": "IllegalArgumentException as well pls", "author": "vkryachko", "createdAt": "2020-05-28T19:05:05Z", "path": "encoders/firebase-decoders-json/src/main/java/com/google/firebase/decoders/TypeToken.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders;\n+\n+import androidx.annotation.NonNull;\n+\n+import java.lang.reflect.GenericArrayType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.WildcardType;\n+\n+//TODO: implement hashCode(), equals(), and toString().\n+public abstract class TypeToken<T> {\n+\n+  @NonNull\n+  public static <T> TypeToken<T> of(@NonNull Safe<T> token) {\n+    Type superclass = token.getClass().getGenericSuperclass();\n+    if (superclass instanceof Class) {\n+      throw new RuntimeException(\"Missing type parameters\");\n+    }\n+    Type type = ((ParameterizedType) superclass).getActualTypeArguments()[0];\n+    return of(type);\n+  }\n+\n+  @NonNull\n+  private static <T> TypeToken<T> of(@NonNull Type type) {\n+    if(type instanceof WildcardType) {\n+      if(((WildcardType) type).getLowerBounds().length == 0) {\n+        return of(((WildcardType) type).getUpperBounds()[0]);\n+      }\n+      throw new RuntimeException(\"<? super T> is not supported\");", "originalCommit": "b53777538931a51ada76504292538ee2e4d854c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA1ODg1Nw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1600#discussion_r432058857", "bodyText": "since Class<T> is an instanceof Type, would it make sense to move this logic to the private method above and have this method just call that?", "author": "vkryachko", "createdAt": "2020-05-28T19:08:06Z", "path": "encoders/firebase-decoders-json/src/main/java/com/google/firebase/decoders/TypeToken.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders;\n+\n+import androidx.annotation.NonNull;\n+\n+import java.lang.reflect.GenericArrayType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.WildcardType;\n+\n+//TODO: implement hashCode(), equals(), and toString().\n+public abstract class TypeToken<T> {\n+\n+  @NonNull\n+  public static <T> TypeToken<T> of(@NonNull Safe<T> token) {\n+    Type superclass = token.getClass().getGenericSuperclass();\n+    if (superclass instanceof Class) {\n+      throw new RuntimeException(\"Missing type parameters\");\n+    }\n+    Type type = ((ParameterizedType) superclass).getActualTypeArguments()[0];\n+    return of(type);\n+  }\n+\n+  @NonNull\n+  private static <T> TypeToken<T> of(@NonNull Type type) {\n+    if(type instanceof WildcardType) {\n+      if(((WildcardType) type).getLowerBounds().length == 0) {\n+        return of(((WildcardType) type).getUpperBounds()[0]);\n+      }\n+      throw new RuntimeException(\"<? super T> is not supported\");\n+    }\n+\n+    if (type instanceof GenericArrayType) {\n+      Type componentType = ((GenericArrayType) type).getGenericComponentType();\n+      return new ArrayToken<T>(TypeToken.of(componentType));\n+    }\n+\n+    //Regular Class Type || Primitive Type || Non-Generic Array Type\n+    if (type instanceof Class<?>) {\n+      Class<T> typeToken = (Class<T>) type;\n+      return of(typeToken);\n+    }\n+\n+    ParameterizedType parameterizedType = (ParameterizedType) type;\n+    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n+    Class<T> rawType = (Class<T>) (parameterizedType.getRawType());\n+\n+    TypeTokenContainer container = new TypeTokenContainer() {\n+      @NonNull\n+      @Override\n+      public <T> TypeToken<T> at(int index) {\n+        return TypeToken.of(actualTypeArguments[index]);\n+      }\n+    };\n+    return new ClassToken<T>(rawType, container);\n+  }\n+\n+  @NonNull\n+  public static <T> TypeToken<T> of(@NonNull Class<T> typeToken) {\n+    if (typeToken.isArray()) {\n+      Class<?> componentTypeToken = typeToken.getComponentType();\n+      return new ArrayToken<T>(TypeToken.of(componentTypeToken));\n+    }\n+    return new ClassToken<T>((Class<T>) typeToken);", "originalCommit": "b53777538931a51ada76504292538ee2e4d854c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxMTMwNQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1600#discussion_r432211305", "bodyText": "Totally agree with that!", "author": "James201311", "createdAt": "2020-05-29T01:37:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA1ODg1Nw=="}], "type": "inlineReview"}, {"oid": "9c089739b79b355c07c50710339e7ff4e3df3e01", "url": "https://github.com/firebase/firebase-android-sdk/commit/9c089739b79b355c07c50710339e7ff4e3df3e01", "message": "generated API file, and reformated", "committedDate": "2020-05-29T15:47:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjczODAwMA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1600#discussion_r432738000", "bodyText": "In the spirit of https://en.wikipedia.org/wiki/Fail-fast, Ideally the exception should be thrown at this point, not when one tries to get the type arguments of a type token. Feel free to address this in a separate PR.", "author": "vkryachko", "createdAt": "2020-05-29T21:12:58Z", "path": "encoders/firebase-decoders-json/src/test/java/com/google/firebase/decoders/TypeTokenTest.java", "diffHunk": "@@ -0,0 +1,167 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.decoders;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.junit.Assert.assertThrows;\n+\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+@RunWith(JUnit4.class)\n+public class TypeTokenTest {\n+  static class Foo {}\n+\n+  // Primitive type\n+  @Test\n+  public void primitiveType_typeIsCorrectlyCaptured() {\n+    TypeToken<Integer> integerTypeToken = TypeToken.of(int.class);\n+    assertThat(integerTypeToken).isInstanceOf(TypeToken.ClassToken.class);\n+    TypeToken.ClassToken<Integer> intToken = (TypeToken.ClassToken<Integer>) integerTypeToken;\n+    assertThat(intToken.getRawType()).isEqualTo(int.class);\n+\n+    TypeToken<Boolean> booleanTypeToken = TypeToken.of(boolean.class);\n+    assertThat(booleanTypeToken).isInstanceOf(TypeToken.ClassToken.class);\n+    TypeToken.ClassToken<Boolean> booleanToken = (TypeToken.ClassToken<Boolean>) booleanTypeToken;\n+    assertThat(booleanToken.getRawType()).isEqualTo(boolean.class);\n+  }\n+\n+  // Array type\n+  @Test\n+  public void generalArrayTypeWithSafe_componentTypeIsCorrectlyCaptured() {\n+    TypeToken<Foo[]> typeToken = TypeToken.of(new Safe<Foo[]>() {});\n+    assertThat(typeToken).isInstanceOf(TypeToken.ArrayToken.class);\n+    TypeToken.ArrayToken<Foo[]> arrayToken = (TypeToken.ArrayToken<Foo[]>) typeToken;\n+    TypeToken<?> componentTypeToken = arrayToken.getComponentType();\n+    assertThat(componentTypeToken).isInstanceOf(TypeToken.ClassToken.class);\n+    TypeToken.ClassToken<Foo> componentToken = (TypeToken.ClassToken<Foo>) componentTypeToken;\n+    assertThat(componentToken.getRawType()).isEqualTo(Foo.class);\n+  }\n+\n+  @Test\n+  public void generalArrayTypeWithoutSafe_componentTypeIsCorrectlyCaptured() {\n+    TypeToken<Foo[]> typeToken = TypeToken.of(Foo[].class);\n+    assertThat(typeToken).isInstanceOf(TypeToken.ArrayToken.class);\n+    TypeToken.ArrayToken<Foo[]> arrayToken = (TypeToken.ArrayToken<Foo[]>) typeToken;\n+    TypeToken<?> componentTypeToken = arrayToken.getComponentType();\n+    assertThat(componentTypeToken).isInstanceOf(TypeToken.ClassToken.class);\n+    TypeToken.ClassToken<Foo> componentToken = (TypeToken.ClassToken<Foo>) componentTypeToken;\n+    assertThat(componentToken.getRawType()).isEqualTo(Foo.class);\n+  }\n+\n+  @Test\n+  public void genericArrayType_rawTypeIsCorrectlyCaptured() {\n+    TypeToken<List<String>[]> typeToken = TypeToken.of(new Safe<List<String>[]>() {});\n+    assertThat(typeToken).isInstanceOf(TypeToken.ArrayToken.class);\n+    TypeToken.ArrayToken<List<String>[]> arrayToken =\n+        (TypeToken.ArrayToken<List<String>[]>) typeToken;\n+    TypeToken<List<String>> componentType = (TypeToken<List<String>>) arrayToken.getComponentType();\n+    assertThat(componentType).isInstanceOf(TypeToken.ClassToken.class);\n+    TypeToken.ClassToken<List<String>> componentClassType =\n+        (TypeToken.ClassToken<List<String>>) componentType;\n+    assertThat(componentClassType.getRawType()).isEqualTo(List.class);\n+    TypeToken<String> argumentType =\n+        ((TypeToken.ClassToken<List<String>>) componentType).getTypeArguments().at(0);\n+    assertThat(argumentType).isInstanceOf(TypeToken.ClassToken.class);\n+    TypeToken.ClassToken<String> argumentClassType = (TypeToken.ClassToken<String>) argumentType;\n+    assertThat(argumentClassType.getRawType()).isEqualTo(String.class);\n+  }\n+\n+  // Plain Class Type\n+  @Test\n+  public void plainClassTypeWithSafe_rawTypeIsCorrectlyCaptured() {\n+    TypeToken<Foo> typeToken = TypeToken.of(new Safe<Foo>() {});\n+    assertThat(typeToken).isInstanceOf(TypeToken.ClassToken.class);\n+    TypeToken.ClassToken<Foo> typeClassToken = (TypeToken.ClassToken<Foo>) typeToken;\n+    assertThat(typeClassToken.getRawType()).isEqualTo(Foo.class);\n+  }\n+\n+  @Test\n+  public void plainClassTypeWithoutSafe_rawTypeIsCorrectlyCaptured() {\n+    TypeToken<Foo> typeToken = TypeToken.of(Foo.class);\n+    assertThat(typeToken).isInstanceOf(TypeToken.ClassToken.class);\n+    TypeToken.ClassToken<Foo> typeClassToken = (TypeToken.ClassToken<Foo>) typeToken;\n+    assertThat(typeClassToken.getRawType()).isEqualTo(Foo.class);\n+  }\n+\n+  // Generic Type\n+  @Test\n+  public void genericType_actualTypeParametersAreCorrectlyCaptured() {\n+    TypeToken<Map<String, Foo>> mapTypeToken = TypeToken.of(new Safe<Map<String, Foo>>() {});\n+    assertThat(mapTypeToken).isInstanceOf(TypeToken.ClassToken.class);\n+    TypeToken.ClassToken<Map<String, Foo>> mapClassToken =\n+        (TypeToken.ClassToken<Map<String, Foo>>) mapTypeToken;\n+    TypeTokenContainer typeTokenContainer = mapClassToken.getTypeArguments();\n+    TypeToken<String> firstArgumentToken = typeTokenContainer.at(0);\n+    TypeToken<Foo> secondArgumentTypeToken = typeTokenContainer.at(1);\n+    assertThat(firstArgumentToken).isInstanceOf(TypeToken.ClassToken.class);\n+    assertThat(secondArgumentTypeToken).isInstanceOf(TypeToken.ClassToken.class);\n+    TypeToken.ClassToken<String> firstArgumentClassToken =\n+        (TypeToken.ClassToken<String>) firstArgumentToken;\n+    TypeToken.ClassToken<Foo> secondArgumentClassToken =\n+        (TypeToken.ClassToken<Foo>) secondArgumentTypeToken;\n+    assertThat(firstArgumentClassToken.getRawType()).isEqualTo(String.class);\n+    assertThat(secondArgumentClassToken.getRawType()).isEqualTo(Foo.class);\n+  }\n+\n+  @Test\n+  public void nestedGenericType_actualTypeParametersAreCorrectlyCaptured() {\n+    TypeToken<List<List<String>>> typeToken = TypeToken.of(new Safe<List<List<String>>>() {});\n+    assertThat(typeToken).isInstanceOf(TypeToken.ClassToken.class);\n+    TypeToken.ClassToken<List<List<String>>> typeClassToken =\n+        (TypeToken.ClassToken<List<List<String>>>) typeToken;\n+    TypeToken<List<String>> componentToken = typeClassToken.getTypeArguments().at(0);\n+    assertThat(componentToken).isInstanceOf(TypeToken.ClassToken.class);\n+    TypeToken.ClassToken<List<String>> componentClassToken =\n+        (TypeToken.ClassToken<List<String>>) componentToken;\n+    assertThat(componentClassToken.getRawType()).isEqualTo(List.class);\n+    TypeToken<String> innerComponentToken = componentClassToken.getTypeArguments().at(0);\n+    assertThat(innerComponentToken).isInstanceOf(TypeToken.ClassToken.class);\n+    TypeToken.ClassToken<String> innerComponentClassToken =\n+        (TypeToken.ClassToken<String>) innerComponentToken;\n+    assertThat(innerComponentClassToken.getRawType()).isEqualTo(String.class);\n+  }\n+\n+  // Bounded Wildcard Type\n+  @Test\n+  public void boundedWildcardTypeWithExtend_actualTypeParameterIsCastedToUpperBound() {\n+    TypeToken<List<? extends Number>> typeToken =\n+        TypeToken.of(new Safe<List<? extends Number>>() {});\n+    assertThat(typeToken).isInstanceOf(TypeToken.ClassToken.class);\n+    TypeToken.ClassToken<List<? extends Number>> typeClassToken =\n+        (TypeToken.ClassToken<List<? extends Number>>) typeToken;\n+    TypeToken<Number> componentType = typeClassToken.getTypeArguments().at(0);\n+    assertThat(componentType).isInstanceOf(TypeToken.ClassToken.class);\n+    TypeToken.ClassToken<Number> componentClassType = (TypeToken.ClassToken<Number>) componentType;\n+    assertThat(componentClassType.getRawType()).isEqualTo(Number.class);\n+  }\n+\n+  @Test\n+  public void boundedWildcardTypeWithSuper_notSupported() {\n+    TypeToken<List<? super Foo>> typeToken = TypeToken.of(new Safe<List<? super Foo>>() {});", "originalCommit": "9c089739b79b355c07c50710339e7ff4e3df3e01", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3d97309164442228f27a5a35e577de94d539132a", "url": "https://github.com/firebase/firebase-android-sdk/commit/3d97309164442228f27a5a35e577de94d539132a", "message": "inital implementation of typeToken for decoder", "committedDate": "2020-05-31T13:37:44Z", "type": "commit"}, {"oid": "3d97309164442228f27a5a35e577de94d539132a", "url": "https://github.com/firebase/firebase-android-sdk/commit/3d97309164442228f27a5a35e577de94d539132a", "message": "inital implementation of typeToken for decoder", "committedDate": "2020-05-31T13:37:44Z", "type": "forcePushed"}]}