{"pr_number": 1511, "pr_title": "Scope validation for not associated federated user using idp role maping", "pr_createdAt": "2020-12-07T03:44:41Z", "pr_url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQ3MTAwMg==", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537471002", "bodyText": "can this cause any null point exceptions if getIdpManager() returns null?", "author": "pamodaaw", "createdAt": "2020-12-07T12:33:21Z", "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/util/OAuth2Util.java", "diffHunk": "@@ -3877,4 +3879,53 @@ public static boolean isAllowedScope(List<String> allowedScopesList, String scop\n         }\n         return false;\n     }\n+\n+    /**\n+     * Util method to get Identity Provider by name and tenant domain.\n+     *\n+     * @param identityProviderName Identity provider\n+     * @param tenantDomain         Tenant domain\n+     * @return Identity Provider\n+     * @throws IdentityOAuth2Exception If were unable to get Identity provider.\n+     */\n+    public static IdentityProvider getIdentityProvider(String identityProviderName, String tenantDomain)\n+            throws IdentityOAuth2Exception {\n+\n+        try {\n+            return OAuth2ServiceComponentHolder.getInstance().getIdpManager().getIdPByName(identityProviderName,", "originalCommit": "dfc2db380d7dee0ff40cf5a459d0bb08f99b20a7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e5c216674443a2579aec7f15b6b391c1c1858f5b", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/commit/e5c216674443a2579aec7f15b6b391c1c1858f5b", "message": "Scope validation for not associated federated user using idp role mapping\n\nnull issue checked", "committedDate": "2020-12-07T13:32:07Z", "type": "forcePushed"}, {"oid": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/commit/94424f60a3188f7b58ae391f7eccc9a5aaf6b739", "message": "Scope validation for not associated federated user using idp role mapping\n\nnull issue checked\n\nnull issue checked", "committedDate": "2020-12-07T13:35:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUxMjgxNA==", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537512814", "bodyText": "can this cause a ClassCastException if getUserStoreManager() returns null?", "author": "chamathns", "createdAt": "2020-12-07T13:39:41Z", "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/util/OAuth2Util.java", "diffHunk": "@@ -3877,4 +3879,59 @@ public static boolean isAllowedScope(List<String> allowedScopesList, String scop\n         }\n         return false;\n     }\n+\n+    /**\n+     * Util method to get Identity Provider by name and tenant domain.\n+     *\n+     * @param identityProviderName Identity provider\n+     * @param tenantDomain         Tenant domain\n+     * @return Identity Provider\n+     * @throws IdentityOAuth2Exception If were unable to get Identity provider.\n+     */\n+    public static IdentityProvider getIdentityProvider(String identityProviderName, String tenantDomain)\n+            throws IdentityOAuth2Exception {\n+\n+        try {\n+            if (OAuth2ServiceComponentHolder.getInstance().getIdpManager() != null) {\n+                return OAuth2ServiceComponentHolder.getInstance().getIdpManager().getIdPByName(identityProviderName,\n+                        tenantDomain);\n+            } else {\n+                String errorMsg = String.format(\"Unable to retrieve Idp manager. Error while \" +\n+                        \"getting '%s' Identity  Provider of '%s' tenant.\", identityProviderName, tenantDomain);\n+                throw new IdentityOAuth2Exception(errorMsg);\n+            }\n+        } catch (IdentityProviderManagementException e) {\n+            String errorMsg =\n+                    String.format(\"Error while getting '%s' Identity Provider of '%s' tenant.\", identityProviderName,\n+                            tenantDomain);\n+            throw new IdentityOAuth2Exception(errorMsg, e);\n+        }\n+    }\n+\n+    /**\n+     * Get Internal/everyone role for corresponding user using realm configuration.\n+     *\n+     * @param user Authenticated user\n+     * @return Internal/everyone role\n+     * @throws IdentityOAuth2Exception IdentityOAuth2Exception\n+     */\n+    public static String getInternalEveryoneRole(AuthenticatedUser user) throws IdentityOAuth2Exception {\n+\n+        try {\n+            RealmConfiguration realmConfiguration = null;\n+            RealmService realmService = OAuthComponentServiceHolder.getInstance().getRealmService();\n+            int tenantId = getTenantId(user.getTenantDomain());\n+            if (realmService != null && tenantId != org.wso2.carbon.base.MultitenantConstants.INVALID_TENANT_ID) {\n+                UserStoreManager userStoreManager = null;\n+                userStoreManager = (UserStoreManager) realmService.getTenantUserRealm(tenantId).getUserStoreManager();", "originalCommit": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk5NTQ4Nw==", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537995487", "bodyText": "can cast null to any reference type without getting any exception, but I get your point added a null check after that.", "author": "Thumimku", "createdAt": "2020-12-08T02:57:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUxMjgxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUxNDgwMA==", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537514800", "bodyText": "Do we really need an 'else' block here?", "author": "chamathns", "createdAt": "2020-12-07T13:42:34Z", "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCPermissionBasedInternalScopeValidator.java", "diffHunk": "@@ -192,6 +233,90 @@\n         return userAllowedScopes;\n     }\n \n+    private boolean isSPAlwaysSendMappedLocalSubjectId(String clientId) throws IdentityOAuth2Exception {\n+\n+        ServiceProvider serviceProvider = OAuth2Util.getServiceProvider(clientId);\n+        if (serviceProvider != null) {\n+            ClaimConfig claimConfig = serviceProvider.getClaimConfig();\n+            if (claimConfig != null) {\n+                return claimConfig.isAlwaysSendMappedLocalSubjectId();\n+            } else {\n+                throw new IdentityOAuth2Exception(\"Unable to find claim configuration for service provider of client \" +\n+                        \"id \" + clientId);", "originalCommit": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUxNzQ4Ng==", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537517486", "bodyText": "We can do without the 'else' nesting here since we return in the 'if' block.", "author": "chamathns", "createdAt": "2020-12-07T13:46:36Z", "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCPermissionBasedInternalScopeValidator.java", "diffHunk": "@@ -192,6 +233,90 @@\n         return userAllowedScopes;\n     }\n \n+    private boolean isSPAlwaysSendMappedLocalSubjectId(String clientId) throws IdentityOAuth2Exception {\n+\n+        ServiceProvider serviceProvider = OAuth2Util.getServiceProvider(clientId);\n+        if (serviceProvider != null) {\n+            ClaimConfig claimConfig = serviceProvider.getClaimConfig();\n+            if (claimConfig != null) {\n+                return claimConfig.isAlwaysSendMappedLocalSubjectId();\n+            } else {\n+                throw new IdentityOAuth2Exception(\"Unable to find claim configuration for service provider of client \" +\n+                        \"id \" + clientId);\n+            }\n+        } else {\n+            throw new IdentityOAuth2Exception(\"Unable to find service provider for client id \" + clientId);\n+        }", "originalCommit": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUxOTkyNA==", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537519924", "bodyText": "Can't we use forEach() here?", "author": "chamathns", "createdAt": "2020-12-07T13:50:10Z", "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCPermissionBasedInternalScopeValidator.java", "diffHunk": "@@ -192,6 +233,90 @@\n         return userAllowedScopes;\n     }\n \n+    private boolean isSPAlwaysSendMappedLocalSubjectId(String clientId) throws IdentityOAuth2Exception {\n+\n+        ServiceProvider serviceProvider = OAuth2Util.getServiceProvider(clientId);\n+        if (serviceProvider != null) {\n+            ClaimConfig claimConfig = serviceProvider.getClaimConfig();\n+            if (claimConfig != null) {\n+                return claimConfig.isAlwaysSendMappedLocalSubjectId();\n+            } else {\n+                throw new IdentityOAuth2Exception(\"Unable to find claim configuration for service provider of client \" +\n+                        \"id \" + clientId);\n+            }\n+        } else {\n+            throw new IdentityOAuth2Exception(\"Unable to find service provider for client id \" + clientId);\n+        }\n+    }\n+\n+    /**\n+     * Method user to get list of federated users permissions using idp role mapping for not account associated\n+     * federated users.\n+     * @param authenticatedUser    FederatedAuthenticatedUser\n+     * @param authorizationManager AuthorizationManager\n+     * @return List of permissions\n+     * @throws UserStoreException      UserStoreException\n+     * @throws IdentityOAuth2Exception IdentityOAuth2Exception\n+     */\n+    private String[] getAllowedUIResourcesForNotAssociatedFederatedUser(AuthenticatedUser authenticatedUser,\n+                                                                        AuthorizationManager authorizationManager)\n+            throws UserStoreException, IdentityOAuth2Exception {\n+\n+        List<String> userRolesList = new ArrayList<>();\n+        List<String> allowedUIResourcesListForUser = new ArrayList<>();\n+        IdentityProvider identityProvider =\n+                OAuth2Util.getIdentityProvider(authenticatedUser.getFederatedIdPName(),\n+                        authenticatedUser.getTenantDomain());\n+        /*\n+        Values of Groups consists mapped local roles and Internal/everyone corresponding to\n+        authenticated user.\n+        Role mapping consists mapped federated roles with local roles corresponding to IDP.\n+        By cross checking role mapped local roles and values of groups we can filter valid local roles which mapped\n+        to a federated role of authenticated user.\n+         */\n+        List<String> valuesOfGroups = getValuesOfGroupsFromUserAttributes(authenticatedUser.getUserAttributes());\n+        if (CollectionUtils.isNotEmpty(valuesOfGroups)) {\n+            for (RoleMapping roleMapping : identityProvider.getPermissionAndRoleConfig().getRoleMappings()) {", "originalCommit": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk5NjIyNQ==", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537996225", "bodyText": "forEach method works with Java lists, here we are looping object arrays. IMO, it's optimized. please correct me if I am wrong.", "author": "Thumimku", "createdAt": "2020-12-08T02:59:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUxOTkyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUyMjA2MQ==", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537522061", "bodyText": "Can we guarantee the getRemoteClaim() would not return null?", "author": "chamathns", "createdAt": "2020-12-07T13:53:12Z", "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCPermissionBasedInternalScopeValidator.java", "diffHunk": "@@ -192,6 +233,90 @@\n         return userAllowedScopes;\n     }\n \n+    private boolean isSPAlwaysSendMappedLocalSubjectId(String clientId) throws IdentityOAuth2Exception {\n+\n+        ServiceProvider serviceProvider = OAuth2Util.getServiceProvider(clientId);\n+        if (serviceProvider != null) {\n+            ClaimConfig claimConfig = serviceProvider.getClaimConfig();\n+            if (claimConfig != null) {\n+                return claimConfig.isAlwaysSendMappedLocalSubjectId();\n+            } else {\n+                throw new IdentityOAuth2Exception(\"Unable to find claim configuration for service provider of client \" +\n+                        \"id \" + clientId);\n+            }\n+        } else {\n+            throw new IdentityOAuth2Exception(\"Unable to find service provider for client id \" + clientId);\n+        }\n+    }\n+\n+    /**\n+     * Method user to get list of federated users permissions using idp role mapping for not account associated\n+     * federated users.\n+     * @param authenticatedUser    FederatedAuthenticatedUser\n+     * @param authorizationManager AuthorizationManager\n+     * @return List of permissions\n+     * @throws UserStoreException      UserStoreException\n+     * @throws IdentityOAuth2Exception IdentityOAuth2Exception\n+     */\n+    private String[] getAllowedUIResourcesForNotAssociatedFederatedUser(AuthenticatedUser authenticatedUser,\n+                                                                        AuthorizationManager authorizationManager)\n+            throws UserStoreException, IdentityOAuth2Exception {\n+\n+        List<String> userRolesList = new ArrayList<>();\n+        List<String> allowedUIResourcesListForUser = new ArrayList<>();\n+        IdentityProvider identityProvider =\n+                OAuth2Util.getIdentityProvider(authenticatedUser.getFederatedIdPName(),\n+                        authenticatedUser.getTenantDomain());\n+        /*\n+        Values of Groups consists mapped local roles and Internal/everyone corresponding to\n+        authenticated user.\n+        Role mapping consists mapped federated roles with local roles corresponding to IDP.\n+        By cross checking role mapped local roles and values of groups we can filter valid local roles which mapped\n+        to a federated role of authenticated user.\n+         */\n+        List<String> valuesOfGroups = getValuesOfGroupsFromUserAttributes(authenticatedUser.getUserAttributes());\n+        if (CollectionUtils.isNotEmpty(valuesOfGroups)) {\n+            for (RoleMapping roleMapping : identityProvider.getPermissionAndRoleConfig().getRoleMappings()) {\n+                if (roleMapping != null && roleMapping.getLocalRole() != null) {\n+                    if (valuesOfGroups.contains(roleMapping.getLocalRole().getLocalRoleName())) {\n+                        userRolesList.add(roleMapping.getLocalRole().getLocalRoleName());\n+                    }\n+                }\n+            }\n+        }\n+        // Loop through each local role and get permissions.\n+        for (String userRole : userRolesList) {\n+            for (String allowedUIResource : authorizationManager.getAllowedUIResourcesForRole(userRole, \"/\")) {\n+                if (!allowedUIResourcesListForUser.contains(allowedUIResource)) {\n+                    allowedUIResourcesListForUser.add(allowedUIResource);\n+                }\n+            }\n+        }\n+        // Add everyone permission to allowed permission.\n+        allowedUIResourcesListForUser.add(EVERYONE_PERMISSION);\n+\n+        return allowedUIResourcesListForUser.toArray(new String[0]);\n+    }\n+\n+    /**\n+     * Get groups params Roles from User attributes.\n+     *\n+     * @param userAttributes User Attributes\n+     * @return User attribute map\n+     */\n+    private List<String> getValuesOfGroupsFromUserAttributes(Map<ClaimMapping, String> userAttributes) {\n+\n+        if (isNotEmpty(userAttributes)) {\n+            for (Map.Entry<ClaimMapping, String> entry : userAttributes.entrySet()) {\n+                if (StringUtils.equals(entry.getKey().getRemoteClaim().getClaimUri(), OAuth2Constants.GROUPS)) {", "originalCommit": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUyMjI2MA==", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537522260", "bodyText": "Unnecessary new line", "author": "chamathns", "createdAt": "2020-12-07T13:53:31Z", "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCPermissionBasedInternalScopeValidator.java", "diffHunk": "@@ -192,6 +233,90 @@\n         return userAllowedScopes;\n     }\n \n+    private boolean isSPAlwaysSendMappedLocalSubjectId(String clientId) throws IdentityOAuth2Exception {\n+\n+        ServiceProvider serviceProvider = OAuth2Util.getServiceProvider(clientId);\n+        if (serviceProvider != null) {\n+            ClaimConfig claimConfig = serviceProvider.getClaimConfig();\n+            if (claimConfig != null) {\n+                return claimConfig.isAlwaysSendMappedLocalSubjectId();\n+            } else {\n+                throw new IdentityOAuth2Exception(\"Unable to find claim configuration for service provider of client \" +\n+                        \"id \" + clientId);\n+            }\n+        } else {\n+            throw new IdentityOAuth2Exception(\"Unable to find service provider for client id \" + clientId);\n+        }\n+    }\n+\n+    /**\n+     * Method user to get list of federated users permissions using idp role mapping for not account associated\n+     * federated users.\n+     * @param authenticatedUser    FederatedAuthenticatedUser\n+     * @param authorizationManager AuthorizationManager\n+     * @return List of permissions\n+     * @throws UserStoreException      UserStoreException\n+     * @throws IdentityOAuth2Exception IdentityOAuth2Exception\n+     */\n+    private String[] getAllowedUIResourcesForNotAssociatedFederatedUser(AuthenticatedUser authenticatedUser,\n+                                                                        AuthorizationManager authorizationManager)\n+            throws UserStoreException, IdentityOAuth2Exception {\n+\n+        List<String> userRolesList = new ArrayList<>();\n+        List<String> allowedUIResourcesListForUser = new ArrayList<>();\n+        IdentityProvider identityProvider =\n+                OAuth2Util.getIdentityProvider(authenticatedUser.getFederatedIdPName(),\n+                        authenticatedUser.getTenantDomain());\n+        /*\n+        Values of Groups consists mapped local roles and Internal/everyone corresponding to\n+        authenticated user.\n+        Role mapping consists mapped federated roles with local roles corresponding to IDP.\n+        By cross checking role mapped local roles and values of groups we can filter valid local roles which mapped\n+        to a federated role of authenticated user.\n+         */\n+        List<String> valuesOfGroups = getValuesOfGroupsFromUserAttributes(authenticatedUser.getUserAttributes());\n+        if (CollectionUtils.isNotEmpty(valuesOfGroups)) {\n+            for (RoleMapping roleMapping : identityProvider.getPermissionAndRoleConfig().getRoleMappings()) {\n+                if (roleMapping != null && roleMapping.getLocalRole() != null) {\n+                    if (valuesOfGroups.contains(roleMapping.getLocalRole().getLocalRoleName())) {\n+                        userRolesList.add(roleMapping.getLocalRole().getLocalRoleName());\n+                    }\n+                }\n+            }\n+        }\n+        // Loop through each local role and get permissions.\n+        for (String userRole : userRolesList) {\n+            for (String allowedUIResource : authorizationManager.getAllowedUIResourcesForRole(userRole, \"/\")) {\n+                if (!allowedUIResourcesListForUser.contains(allowedUIResource)) {\n+                    allowedUIResourcesListForUser.add(allowedUIResource);\n+                }\n+            }\n+        }\n+        // Add everyone permission to allowed permission.\n+        allowedUIResourcesListForUser.add(EVERYONE_PERMISSION);\n+\n+        return allowedUIResourcesListForUser.toArray(new String[0]);\n+    }\n+\n+    /**\n+     * Get groups params Roles from User attributes.\n+     *\n+     * @param userAttributes User Attributes\n+     * @return User attribute map\n+     */\n+    private List<String> getValuesOfGroupsFromUserAttributes(Map<ClaimMapping, String> userAttributes) {\n+\n+        if (isNotEmpty(userAttributes)) {\n+            for (Map.Entry<ClaimMapping, String> entry : userAttributes.entrySet()) {\n+                if (StringUtils.equals(entry.getKey().getRemoteClaim().getClaimUri(), OAuth2Constants.GROUPS)) {\n+                    return Arrays.asList(entry.getValue().split(Pattern.quote(ATTRIBUTE_SEPARATOR)));\n+", "originalCommit": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUyNDc0Mw==", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537524743", "bodyText": "Wouldn't this make the L285 unreachable?", "author": "chamathns", "createdAt": "2020-12-07T13:56:58Z", "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCScopeValidator.java", "diffHunk": "@@ -224,22 +239,117 @@ private boolean validateScope(String[] requestedScopes, AuthenticatedUser user)\n             return true;\n         }\n \n+        String[] userRoles = null;\n         int tenantId = getTenantId(user);\n-        String[] userRoles = getUserRoles(user);\n \n-        for (String scope : requestedScopes) {\n-            if (!isScopeValid(scope, tenantId)) {\n-                //If the scope is not registered return false\n-                log.error(\"Requested scope \" + scope + \" is invalid\");\n-                return false;\n+        /*\n+        Here we handle scope validation for federated user and local user separately.\n+        For local users - user store is used to get user roles.\n+        For federated user - get user roles from user attributes.\n+        Note that if there is association between a federated user and local user () 'Assert identity using mapped local\n+        subject identifier' flag will be set as true. So authenticated user will be associated local user not\n+        federated user.\n+         */\n+        if (user.isFederatedUser()) {\n+            /*\n+            There is a flow where 'Assert identity using mapped local subject identifier' flag enabled but the\n+            federated user doesn't have any association in localIDP, to handle this case we check for 'Assert\n+            identity using mapped local subject identifier' flag and get roles from userStore.\n+             */\n+            if (isSPAlwaysSendMappedLocalSubjectId(clientId)) {\n+                userRoles = getUserRoles(user);\n+            } else {\n+                // Handle not account associated federated users.\n+                userRoles = getUserRolesForNotAssociatedFederatedUser(user);\n             }\n-            if (!isUserAuthorizedForScope(scope, userRoles, tenantId)) {\n-                return false;\n+        } else {\n+            userRoles = getUserRoles(user);\n+        }\n+        if (ArrayUtils.isNotEmpty(userRoles)) {\n+            for (String scope : requestedScopes) {\n+                if (!isScopeValid(scope, tenantId)) {\n+                    // If the scope is not registered return false.\n+                    log.error(\"Requested scope \" + scope + \" is invalid\");\n+                    return false;\n+                }\n+                if (!isUserAuthorizedForScope(scope, userRoles, tenantId)) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"User \" + user.getUserName() + \"in not authorised for scope \" + scope);\n+                    }\n+                    return false;\n+                }\n             }\n+        } else {\n+            return false;", "originalCommit": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUyNjkwMQ==", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537526901", "bodyText": "does the 'else' nesting serve any value?", "author": "chamathns", "createdAt": "2020-12-07T13:59:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUyNDc0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk3MTE0OA==", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537971148", "bodyText": "L282 - if user roles remain empty for any user method returns false.\nL285 - Yes reachable, we remove all negative case and in L285 we return valid cases.", "author": "Thumimku", "createdAt": "2020-12-08T01:52:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUyNDc0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUyNzY0NA==", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537527644", "bodyText": "Can't we do without the 'else' nesting?", "author": "chamathns", "createdAt": "2020-12-07T14:00:59Z", "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCScopeValidator.java", "diffHunk": "@@ -224,22 +239,117 @@ private boolean validateScope(String[] requestedScopes, AuthenticatedUser user)\n             return true;\n         }\n \n+        String[] userRoles = null;\n         int tenantId = getTenantId(user);\n-        String[] userRoles = getUserRoles(user);\n \n-        for (String scope : requestedScopes) {\n-            if (!isScopeValid(scope, tenantId)) {\n-                //If the scope is not registered return false\n-                log.error(\"Requested scope \" + scope + \" is invalid\");\n-                return false;\n+        /*\n+        Here we handle scope validation for federated user and local user separately.\n+        For local users - user store is used to get user roles.\n+        For federated user - get user roles from user attributes.\n+        Note that if there is association between a federated user and local user () 'Assert identity using mapped local\n+        subject identifier' flag will be set as true. So authenticated user will be associated local user not\n+        federated user.\n+         */\n+        if (user.isFederatedUser()) {\n+            /*\n+            There is a flow where 'Assert identity using mapped local subject identifier' flag enabled but the\n+            federated user doesn't have any association in localIDP, to handle this case we check for 'Assert\n+            identity using mapped local subject identifier' flag and get roles from userStore.\n+             */\n+            if (isSPAlwaysSendMappedLocalSubjectId(clientId)) {\n+                userRoles = getUserRoles(user);\n+            } else {\n+                // Handle not account associated federated users.\n+                userRoles = getUserRolesForNotAssociatedFederatedUser(user);\n             }\n-            if (!isUserAuthorizedForScope(scope, userRoles, tenantId)) {\n-                return false;\n+        } else {\n+            userRoles = getUserRoles(user);\n+        }\n+        if (ArrayUtils.isNotEmpty(userRoles)) {\n+            for (String scope : requestedScopes) {\n+                if (!isScopeValid(scope, tenantId)) {\n+                    // If the scope is not registered return false.\n+                    log.error(\"Requested scope \" + scope + \" is invalid\");\n+                    return false;\n+                }\n+                if (!isUserAuthorizedForScope(scope, userRoles, tenantId)) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"User \" + user.getUserName() + \"in not authorised for scope \" + scope);\n+                    }\n+                    return false;\n+                }\n             }\n+        } else {\n+            return false;\n         }\n         return true;\n     }\n \n+    private boolean isSPAlwaysSendMappedLocalSubjectId(String clientId) throws IdentityOAuth2Exception {\n+\n+        ServiceProvider serviceProvider = OAuth2Util.getServiceProvider(clientId);\n+        if (serviceProvider != null) {\n+            ClaimConfig claimConfig = serviceProvider.getClaimConfig();\n+            if (claimConfig != null) {\n+                return claimConfig.isAlwaysSendMappedLocalSubjectId();\n+            } else {\n+                throw new IdentityOAuth2Exception(\"Unable to find claim configuration for service provider of client \" +\n+                        \"id \" + clientId);\n+            }", "originalCommit": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUyNzc1NQ==", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537527755", "bodyText": "Can't we do without the 'else' nesting?", "author": "chamathns", "createdAt": "2020-12-07T14:01:08Z", "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCScopeValidator.java", "diffHunk": "@@ -224,22 +239,117 @@ private boolean validateScope(String[] requestedScopes, AuthenticatedUser user)\n             return true;\n         }\n \n+        String[] userRoles = null;\n         int tenantId = getTenantId(user);\n-        String[] userRoles = getUserRoles(user);\n \n-        for (String scope : requestedScopes) {\n-            if (!isScopeValid(scope, tenantId)) {\n-                //If the scope is not registered return false\n-                log.error(\"Requested scope \" + scope + \" is invalid\");\n-                return false;\n+        /*\n+        Here we handle scope validation for federated user and local user separately.\n+        For local users - user store is used to get user roles.\n+        For federated user - get user roles from user attributes.\n+        Note that if there is association between a federated user and local user () 'Assert identity using mapped local\n+        subject identifier' flag will be set as true. So authenticated user will be associated local user not\n+        federated user.\n+         */\n+        if (user.isFederatedUser()) {\n+            /*\n+            There is a flow where 'Assert identity using mapped local subject identifier' flag enabled but the\n+            federated user doesn't have any association in localIDP, to handle this case we check for 'Assert\n+            identity using mapped local subject identifier' flag and get roles from userStore.\n+             */\n+            if (isSPAlwaysSendMappedLocalSubjectId(clientId)) {\n+                userRoles = getUserRoles(user);\n+            } else {\n+                // Handle not account associated federated users.\n+                userRoles = getUserRolesForNotAssociatedFederatedUser(user);\n             }\n-            if (!isUserAuthorizedForScope(scope, userRoles, tenantId)) {\n-                return false;\n+        } else {\n+            userRoles = getUserRoles(user);\n+        }\n+        if (ArrayUtils.isNotEmpty(userRoles)) {\n+            for (String scope : requestedScopes) {\n+                if (!isScopeValid(scope, tenantId)) {\n+                    // If the scope is not registered return false.\n+                    log.error(\"Requested scope \" + scope + \" is invalid\");\n+                    return false;\n+                }\n+                if (!isUserAuthorizedForScope(scope, userRoles, tenantId)) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"User \" + user.getUserName() + \"in not authorised for scope \" + scope);\n+                    }\n+                    return false;\n+                }\n             }\n+        } else {\n+            return false;\n         }\n         return true;\n     }\n \n+    private boolean isSPAlwaysSendMappedLocalSubjectId(String clientId) throws IdentityOAuth2Exception {\n+\n+        ServiceProvider serviceProvider = OAuth2Util.getServiceProvider(clientId);\n+        if (serviceProvider != null) {\n+            ClaimConfig claimConfig = serviceProvider.getClaimConfig();\n+            if (claimConfig != null) {\n+                return claimConfig.isAlwaysSendMappedLocalSubjectId();\n+            } else {\n+                throw new IdentityOAuth2Exception(\"Unable to find claim configuration for service provider of client \" +\n+                        \"id \" + clientId);\n+            }\n+        } else {\n+            throw new IdentityOAuth2Exception(\"Unable to find service provider for client id \" + clientId);\n+        }", "originalCommit": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUzMDAyMA==", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537530020", "bodyText": "Can't we use forEach() instead?", "author": "chamathns", "createdAt": "2020-12-07T14:04:15Z", "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCScopeValidator.java", "diffHunk": "@@ -224,22 +239,117 @@ private boolean validateScope(String[] requestedScopes, AuthenticatedUser user)\n             return true;\n         }\n \n+        String[] userRoles = null;\n         int tenantId = getTenantId(user);\n-        String[] userRoles = getUserRoles(user);\n \n-        for (String scope : requestedScopes) {\n-            if (!isScopeValid(scope, tenantId)) {\n-                //If the scope is not registered return false\n-                log.error(\"Requested scope \" + scope + \" is invalid\");\n-                return false;\n+        /*\n+        Here we handle scope validation for federated user and local user separately.\n+        For local users - user store is used to get user roles.\n+        For federated user - get user roles from user attributes.\n+        Note that if there is association between a federated user and local user () 'Assert identity using mapped local\n+        subject identifier' flag will be set as true. So authenticated user will be associated local user not\n+        federated user.\n+         */\n+        if (user.isFederatedUser()) {\n+            /*\n+            There is a flow where 'Assert identity using mapped local subject identifier' flag enabled but the\n+            federated user doesn't have any association in localIDP, to handle this case we check for 'Assert\n+            identity using mapped local subject identifier' flag and get roles from userStore.\n+             */\n+            if (isSPAlwaysSendMappedLocalSubjectId(clientId)) {\n+                userRoles = getUserRoles(user);\n+            } else {\n+                // Handle not account associated federated users.\n+                userRoles = getUserRolesForNotAssociatedFederatedUser(user);\n             }\n-            if (!isUserAuthorizedForScope(scope, userRoles, tenantId)) {\n-                return false;\n+        } else {\n+            userRoles = getUserRoles(user);\n+        }\n+        if (ArrayUtils.isNotEmpty(userRoles)) {\n+            for (String scope : requestedScopes) {", "originalCommit": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk5NjMwNA==", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537996304", "bodyText": "forEach method works with Java lists, here we are looping object arrays. IMO, it's optimized. please correct me if I am wrong.", "author": "Thumimku", "createdAt": "2020-12-08T02:59:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUzMDAyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUzMTg4Mg==", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537531882", "bodyText": "Shall we use the full qualified method here instead of importing MapUtils.isNotEmpty()?", "author": "chamathns", "createdAt": "2020-12-07T14:06:39Z", "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCPermissionBasedInternalScopeValidator.java", "diffHunk": "@@ -192,6 +233,90 @@\n         return userAllowedScopes;\n     }\n \n+    private boolean isSPAlwaysSendMappedLocalSubjectId(String clientId) throws IdentityOAuth2Exception {\n+\n+        ServiceProvider serviceProvider = OAuth2Util.getServiceProvider(clientId);\n+        if (serviceProvider != null) {\n+            ClaimConfig claimConfig = serviceProvider.getClaimConfig();\n+            if (claimConfig != null) {\n+                return claimConfig.isAlwaysSendMappedLocalSubjectId();\n+            } else {\n+                throw new IdentityOAuth2Exception(\"Unable to find claim configuration for service provider of client \" +\n+                        \"id \" + clientId);\n+            }\n+        } else {\n+            throw new IdentityOAuth2Exception(\"Unable to find service provider for client id \" + clientId);\n+        }\n+    }\n+\n+    /**\n+     * Method user to get list of federated users permissions using idp role mapping for not account associated\n+     * federated users.\n+     * @param authenticatedUser    FederatedAuthenticatedUser\n+     * @param authorizationManager AuthorizationManager\n+     * @return List of permissions\n+     * @throws UserStoreException      UserStoreException\n+     * @throws IdentityOAuth2Exception IdentityOAuth2Exception\n+     */\n+    private String[] getAllowedUIResourcesForNotAssociatedFederatedUser(AuthenticatedUser authenticatedUser,\n+                                                                        AuthorizationManager authorizationManager)\n+            throws UserStoreException, IdentityOAuth2Exception {\n+\n+        List<String> userRolesList = new ArrayList<>();\n+        List<String> allowedUIResourcesListForUser = new ArrayList<>();\n+        IdentityProvider identityProvider =\n+                OAuth2Util.getIdentityProvider(authenticatedUser.getFederatedIdPName(),\n+                        authenticatedUser.getTenantDomain());\n+        /*\n+        Values of Groups consists mapped local roles and Internal/everyone corresponding to\n+        authenticated user.\n+        Role mapping consists mapped federated roles with local roles corresponding to IDP.\n+        By cross checking role mapped local roles and values of groups we can filter valid local roles which mapped\n+        to a federated role of authenticated user.\n+         */\n+        List<String> valuesOfGroups = getValuesOfGroupsFromUserAttributes(authenticatedUser.getUserAttributes());\n+        if (CollectionUtils.isNotEmpty(valuesOfGroups)) {\n+            for (RoleMapping roleMapping : identityProvider.getPermissionAndRoleConfig().getRoleMappings()) {\n+                if (roleMapping != null && roleMapping.getLocalRole() != null) {\n+                    if (valuesOfGroups.contains(roleMapping.getLocalRole().getLocalRoleName())) {\n+                        userRolesList.add(roleMapping.getLocalRole().getLocalRoleName());\n+                    }\n+                }\n+            }\n+        }\n+        // Loop through each local role and get permissions.\n+        for (String userRole : userRolesList) {\n+            for (String allowedUIResource : authorizationManager.getAllowedUIResourcesForRole(userRole, \"/\")) {\n+                if (!allowedUIResourcesListForUser.contains(allowedUIResource)) {\n+                    allowedUIResourcesListForUser.add(allowedUIResource);\n+                }\n+            }\n+        }\n+        // Add everyone permission to allowed permission.\n+        allowedUIResourcesListForUser.add(EVERYONE_PERMISSION);\n+\n+        return allowedUIResourcesListForUser.toArray(new String[0]);\n+    }\n+\n+    /**\n+     * Get groups params Roles from User attributes.\n+     *\n+     * @param userAttributes User Attributes\n+     * @return User attribute map\n+     */\n+    private List<String> getValuesOfGroupsFromUserAttributes(Map<ClaimMapping, String> userAttributes) {\n+\n+        if (isNotEmpty(userAttributes)) {", "originalCommit": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUzMzg0Ng==", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537533846", "bodyText": "Shall we extract this out as a separate method since the same logic is used at L311?", "author": "chamathns", "createdAt": "2020-12-07T14:08:47Z", "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCScopeValidator.java", "diffHunk": "@@ -224,22 +239,117 @@ private boolean validateScope(String[] requestedScopes, AuthenticatedUser user)\n             return true;\n         }\n \n+        String[] userRoles = null;\n         int tenantId = getTenantId(user);\n-        String[] userRoles = getUserRoles(user);\n \n-        for (String scope : requestedScopes) {\n-            if (!isScopeValid(scope, tenantId)) {\n-                //If the scope is not registered return false\n-                log.error(\"Requested scope \" + scope + \" is invalid\");\n-                return false;\n+        /*\n+        Here we handle scope validation for federated user and local user separately.\n+        For local users - user store is used to get user roles.\n+        For federated user - get user roles from user attributes.\n+        Note that if there is association between a federated user and local user () 'Assert identity using mapped local\n+        subject identifier' flag will be set as true. So authenticated user will be associated local user not\n+        federated user.\n+         */\n+        if (user.isFederatedUser()) {\n+            /*\n+            There is a flow where 'Assert identity using mapped local subject identifier' flag enabled but the\n+            federated user doesn't have any association in localIDP, to handle this case we check for 'Assert\n+            identity using mapped local subject identifier' flag and get roles from userStore.\n+             */\n+            if (isSPAlwaysSendMappedLocalSubjectId(clientId)) {\n+                userRoles = getUserRoles(user);\n+            } else {\n+                // Handle not account associated federated users.\n+                userRoles = getUserRolesForNotAssociatedFederatedUser(user);\n             }\n-            if (!isUserAuthorizedForScope(scope, userRoles, tenantId)) {\n-                return false;\n+        } else {\n+            userRoles = getUserRoles(user);\n+        }\n+        if (ArrayUtils.isNotEmpty(userRoles)) {\n+            for (String scope : requestedScopes) {\n+                if (!isScopeValid(scope, tenantId)) {\n+                    // If the scope is not registered return false.\n+                    log.error(\"Requested scope \" + scope + \" is invalid\");\n+                    return false;\n+                }\n+                if (!isUserAuthorizedForScope(scope, userRoles, tenantId)) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"User \" + user.getUserName() + \"in not authorised for scope \" + scope);\n+                    }\n+                    return false;\n+                }\n             }\n+        } else {\n+            return false;\n         }\n         return true;\n     }\n \n+    private boolean isSPAlwaysSendMappedLocalSubjectId(String clientId) throws IdentityOAuth2Exception {\n+\n+        ServiceProvider serviceProvider = OAuth2Util.getServiceProvider(clientId);\n+        if (serviceProvider != null) {\n+            ClaimConfig claimConfig = serviceProvider.getClaimConfig();\n+            if (claimConfig != null) {\n+                return claimConfig.isAlwaysSendMappedLocalSubjectId();\n+            } else {\n+                throw new IdentityOAuth2Exception(\"Unable to find claim configuration for service provider of client \" +\n+                        \"id \" + clientId);\n+            }\n+        } else {\n+            throw new IdentityOAuth2Exception(\"Unable to find service provider for client id \" + clientId);\n+        }\n+    }\n+\n+    private String[] getUserRolesForNotAssociatedFederatedUser(AuthenticatedUser user)\n+            throws IdentityOAuth2Exception {\n+\n+        List<String> userRolesList = new ArrayList<>();\n+        IdentityProvider identityProvider =\n+                OAuth2Util.getIdentityProvider(user.getFederatedIdPName(), user.getTenantDomain());\n+        /*\n+        Values of Groups consists unmapped federated roles, mapped local roles and Internal/everyone corresponding to\n+        authenticated user.\n+        Role mapping consists mapped federated roles with local roles corresponding to IDP.\n+        By cross checking federated role mapped local roles and values of groups we can filter valid local roles which\n+        mapped to the federated role of authenticated user.\n+         */\n+        List<String> valuesOfGroups = getValuesOfGroupsFromUserAttributes(user.getUserAttributes());\n+        if (CollectionUtils.isNotEmpty(valuesOfGroups)) {\n+            for (RoleMapping roleMapping : identityProvider.getPermissionAndRoleConfig().getRoleMappings()) {\n+                if (roleMapping != null && roleMapping.getLocalRole() != null) {\n+                    if (valuesOfGroups.contains(roleMapping.getLocalRole().getLocalRoleName())) {\n+                        userRolesList.add(roleMapping.getLocalRole().getLocalRoleName());\n+                    }\n+                }\n+            }\n+        }\n+        // By default we provide Internal/everyone role for all users.\n+        String internalEveryoneRole = OAuth2Util.getInternalEveryoneRole(user);\n+        if (StringUtils.isNotBlank(internalEveryoneRole)) {\n+            userRolesList.add(internalEveryoneRole);\n+        }\n+        return userRolesList.toArray(new String[0]);\n+    }\n+\n+    /**\n+     * Get groups params Roles from User attributes.\n+     *\n+     * @param userAttributes User Attributes\n+     * @return User attribute map\n+     */\n+    private List<String> getValuesOfGroupsFromUserAttributes(Map<ClaimMapping, String> userAttributes) {\n+\n+        if (MapUtils.isNotEmpty(userAttributes)) {\n+            for (Map.Entry<ClaimMapping, String> entry : userAttributes.entrySet()) {\n+                if (StringUtils.equals(entry.getKey().getRemoteClaim().getClaimUri(), OAuth2Constants.GROUPS)) {\n+                    return Arrays.asList(entry.getValue().split(Pattern.quote(ATTRIBUTE_SEPARATOR)));\n+                }\n+            }", "originalCommit": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk3MjkzNg==", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537972936", "bodyText": "It's a separate private method, and L311 serves different logic. Please correct me if I am wrong.", "author": "Thumimku", "createdAt": "2020-12-08T01:56:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUzMzg0Ng=="}], "type": "inlineReview"}, {"oid": "32f3f5b0e256bbc515085fd7503c1fde237a9300", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/commit/32f3f5b0e256bbc515085fd7503c1fde237a9300", "message": "Scope validation for not associated federated user using idp role mapping\n\nnull issue checked\n\nnull issue checked\n\ncomments resolved", "committedDate": "2020-12-08T02:55:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODAxOTgwNA==", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r538019804", "bodyText": "formatting issue", "author": "chamathns", "createdAt": "2020-12-08T04:10:10Z", "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCScopeValidator.java", "diffHunk": "@@ -181,27 +194,29 @@ public boolean validateScope(AccessTokenDO accessTokenDO, String resource) throw\n     public boolean validateScope(OAuthTokenReqMessageContext tokReqMsgCtx) throws\n             UserStoreException, IdentityOAuth2Exception {\n \n-        return validateScope(tokReqMsgCtx.getScope(), tokReqMsgCtx.getAuthorizedUser());\n-    }\n+        return validateScope(tokReqMsgCtx.getScope(), tokReqMsgCtx.getAuthorizedUser(),\n+                tokReqMsgCtx.getOauth2AccessTokenReqDTO().getClientId());    }", "originalCommit": "32f3f5b0e256bbc515085fd7503c1fde237a9300", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8fa8b831b576be452425601c762f110c83b6ca24", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/commit/8fa8b831b576be452425601c762f110c83b6ca24", "message": "Scope validation for not associated federated user using idp role mapping\n\nnull issue checked\n\nnull issue checked\n\ncomments resolved\n\nresolve comments", "committedDate": "2020-12-08T04:15:53Z", "type": "commit"}, {"oid": "8fa8b831b576be452425601c762f110c83b6ca24", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/commit/8fa8b831b576be452425601c762f110c83b6ca24", "message": "Scope validation for not associated federated user using idp role mapping\n\nnull issue checked\n\nnull issue checked\n\ncomments resolved\n\nresolve comments", "committedDate": "2020-12-08T04:15:53Z", "type": "forcePushed"}]}