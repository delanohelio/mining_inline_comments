{"pr_number": 1106, "pr_title": "Kapp2termcons", "pr_createdAt": "2020-02-18T14:50:41Z", "pr_url": "https://github.com/kframework/k/pull/1106", "timeline": [{"oid": "6b20251bd0dcb4d1ef9248294e871cdc76d19c80", "url": "https://github.com/kframework/k/commit/6b20251bd0dcb4d1ef9248294e871cdc76d19c80", "message": "Fix TermCons.toString for bracket productions", "committedDate": "2020-02-13T20:16:28Z", "type": "commit"}, {"oid": "3a31897d2374bdea264c3aa2076bd0db2f7f1df6", "url": "https://github.com/kframework/k/commit/3a31897d2374bdea264c3aa2076bd0db2f7f1df6", "message": "Adding KApp to TermCons filter\n\nNeeds tests", "committedDate": "2020-02-15T21:23:05Z", "type": "commit"}, {"oid": "40ab08b6ab3d93bd5b8233748428931adc9ea84f", "url": "https://github.com/kframework/k/commit/40ab08b6ab3d93bd5b8233748428931adc9ea84f", "message": "Work on transformer\n\nand adding unit test", "committedDate": "2020-02-18T14:43:44Z", "type": "commit"}, {"oid": "e2c025d45bcd2a9c9863cb0165468d429158dffc", "url": "https://github.com/kframework/k/commit/e2c025d45bcd2a9c9863cb0165468d429158dffc", "message": "Merge branch 'master' into kapp2termcons", "committedDate": "2020-02-18T14:50:50Z", "type": "commit"}, {"oid": "f6a5262cdb512b68a38fbb72f5e140221ee84795", "url": "https://github.com/kframework/k/commit/f6a5262cdb512b68a38fbb72f5e140221ee84795", "message": "Fix a failing test.", "committedDate": "2020-02-18T20:25:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk4NTYyMQ==", "url": "https://github.com/kframework/k/pull/1106#discussion_r380985621", "bodyText": "Not sure about adding a warning here.", "author": "radumereuta", "createdAt": "2020-02-18T22:56:39Z", "path": "kernel/src/main/java/org/kframework/parser/concrete2kore/disambiguation/KAppToTermConsVisitor.java", "diffHunk": "@@ -0,0 +1,99 @@\n+// Copyright (c) 2015-2019 K Team. All Rights Reserved.\n+package org.kframework.parser.concrete2kore.disambiguation;\n+\n+import com.google.common.collect.Sets;\n+import org.kframework.builtin.Sorts;\n+import org.kframework.definition.Module;\n+import org.kframework.definition.Production;\n+import org.kframework.parser.Ambiguity;\n+import org.kframework.parser.Constant;\n+import org.kframework.parser.SetsTransformerWithErrors;\n+import org.kframework.parser.Term;\n+import org.kframework.parser.TermCons;\n+import org.kframework.utils.StringUtil;\n+import org.kframework.utils.errorsystem.KEMException;\n+import org.pcollections.ConsPStack;\n+import org.pcollections.PStack;\n+import scala.collection.immutable.Set$;\n+import scala.util.Either;\n+import scala.util.Left;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.kframework.Collections.*;\n+import static org.kframework.kore.KORE.*;\n+\n+\n+/**\n+ * Transform the KApps found in a term into the corresponding TermCons so type checking and\n+ * variable type inference takes place correctly. Must be applied between type inference and\n+ * priority filter.\n+ */\n+public class KAppToTermConsVisitor extends SetsTransformerWithErrors<KEMException> {\n+\n+    private final Module mod;\n+    public KAppToTermConsVisitor(Module mod) {\n+        super();\n+        this.mod = mod;\n+    }\n+\n+    @Override\n+    public Either<java.util.Set<KEMException>, Term> apply(TermCons tc) {\n+        assert tc.production() != null : this.getClass() + \":\" + \" production not found.\" + tc;\n+        if (tc.production().klabel().isDefined() && tc.production().klabel().get().name().equals(\"#KApply\")) {\n+            if (!(tc.items().get(1) instanceof Constant) || !((Constant) tc.items().get(1)).production().sort().equals(Sorts.KLabel()))\n+                // TODO: maybe return a hidden warning?", "originalCommit": "f6a5262cdb512b68a38fbb72f5e140221ee84795", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ4ODUwMQ==", "url": "https://github.com/kframework/k/pull/1106#discussion_r381488501", "bodyText": "Let's use TermCons.get everywhere so we don't get confused by the reversed indices", "author": "dwightguth", "createdAt": "2020-02-19T19:16:26Z", "path": "kernel/src/main/java/org/kframework/parser/concrete2kore/disambiguation/KAppToTermConsVisitor.java", "diffHunk": "@@ -0,0 +1,99 @@\n+// Copyright (c) 2015-2019 K Team. All Rights Reserved.\n+package org.kframework.parser.concrete2kore.disambiguation;\n+\n+import com.google.common.collect.Sets;\n+import org.kframework.builtin.Sorts;\n+import org.kframework.definition.Module;\n+import org.kframework.definition.Production;\n+import org.kframework.parser.Ambiguity;\n+import org.kframework.parser.Constant;\n+import org.kframework.parser.SetsTransformerWithErrors;\n+import org.kframework.parser.Term;\n+import org.kframework.parser.TermCons;\n+import org.kframework.utils.StringUtil;\n+import org.kframework.utils.errorsystem.KEMException;\n+import org.pcollections.ConsPStack;\n+import org.pcollections.PStack;\n+import scala.collection.immutable.Set$;\n+import scala.util.Either;\n+import scala.util.Left;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.kframework.Collections.*;\n+import static org.kframework.kore.KORE.*;\n+\n+\n+/**\n+ * Transform the KApps found in a term into the corresponding TermCons so type checking and\n+ * variable type inference takes place correctly. Must be applied between type inference and\n+ * priority filter.\n+ */\n+public class KAppToTermConsVisitor extends SetsTransformerWithErrors<KEMException> {\n+\n+    private final Module mod;\n+    public KAppToTermConsVisitor(Module mod) {\n+        super();\n+        this.mod = mod;\n+    }\n+\n+    @Override\n+    public Either<java.util.Set<KEMException>, Term> apply(TermCons tc) {\n+        assert tc.production() != null : this.getClass() + \":\" + \" production not found.\" + tc;\n+        if (tc.production().klabel().isDefined() && tc.production().klabel().get().name().equals(\"#KApply\")) {\n+            if (!(tc.items().get(1) instanceof Constant) || !((Constant) tc.items().get(1)).production().sort().equals(Sorts.KLabel()))", "originalCommit": "f6a5262cdb512b68a38fbb72f5e140221ee84795", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ5MDAxMA==", "url": "https://github.com/kframework/k/pull/1106#discussion_r381490010", "bodyText": "The logic in this block doesn't look sound to me. You are basically dropping some of the parses in the forest", "author": "dwightguth", "createdAt": "2020-02-19T19:19:10Z", "path": "kernel/src/main/java/org/kframework/parser/concrete2kore/disambiguation/KAppToTermConsVisitor.java", "diffHunk": "@@ -0,0 +1,99 @@\n+// Copyright (c) 2015-2019 K Team. All Rights Reserved.\n+package org.kframework.parser.concrete2kore.disambiguation;\n+\n+import com.google.common.collect.Sets;\n+import org.kframework.builtin.Sorts;\n+import org.kframework.definition.Module;\n+import org.kframework.definition.Production;\n+import org.kframework.parser.Ambiguity;\n+import org.kframework.parser.Constant;\n+import org.kframework.parser.SetsTransformerWithErrors;\n+import org.kframework.parser.Term;\n+import org.kframework.parser.TermCons;\n+import org.kframework.utils.StringUtil;\n+import org.kframework.utils.errorsystem.KEMException;\n+import org.pcollections.ConsPStack;\n+import org.pcollections.PStack;\n+import scala.collection.immutable.Set$;\n+import scala.util.Either;\n+import scala.util.Left;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.kframework.Collections.*;\n+import static org.kframework.kore.KORE.*;\n+\n+\n+/**\n+ * Transform the KApps found in a term into the corresponding TermCons so type checking and\n+ * variable type inference takes place correctly. Must be applied between type inference and\n+ * priority filter.\n+ */\n+public class KAppToTermConsVisitor extends SetsTransformerWithErrors<KEMException> {\n+\n+    private final Module mod;\n+    public KAppToTermConsVisitor(Module mod) {\n+        super();\n+        this.mod = mod;\n+    }\n+\n+    @Override\n+    public Either<java.util.Set<KEMException>, Term> apply(TermCons tc) {\n+        assert tc.production() != null : this.getClass() + \":\" + \" production not found.\" + tc;\n+        if (tc.production().klabel().isDefined() && tc.production().klabel().get().name().equals(\"#KApply\")) {\n+            if (!(tc.items().get(1) instanceof Constant) || !((Constant) tc.items().get(1)).production().sort().equals(Sorts.KLabel()))\n+                // TODO: maybe return a hidden warning?\n+                return super.apply(tc); // don't do anything if the label is not a token KLabel (in case of variable or casted variable)\n+            Constant kl = (Constant) tc.items().get(1);\n+            PStack<Term> items = flattenKList(tc.items().get(0));\n+            String klvalue = kl.value();\n+            try { klvalue = StringUtil.unescapeKoreKLabel(kl.value()); } catch (IllegalArgumentException e) { /* ignore */ } // if possible, unescape\n+            Set<Production> prods = mutable(mod.productionsFor().get(KLabel(klvalue))\n+                    .getOrElse(Set$.MODULE$::emptyInstance)\n+                    .filter(x -> ((Production) x).arity() == items.size()).toSet());\n+            if (prods.size() == 0) {\n+                String msg = \"Could not find any production with arity \" + items.size() + \" for label \" + kl.value();\n+                return Left.apply(Sets.newHashSet(KEMException.innerParserError(msg, kl)));\n+            } else if (prods.size() == 1)\n+                return super.apply(TermCons.apply(items, prods.iterator().next(), tc.location(), tc.source()));\n+            else {\n+                // instantiate all labels found and let the type checker filter them out\n+                Set<Term> tcs = new HashSet<>();\n+                for (Production prd : prods)\n+                    tcs.add(TermCons.apply(items, prd, tc.location(), tc.source()));\n+                return super.apply(Ambiguity.apply(tcs, tc.location(), tc.source()));\n+            }\n+        }\n+        return super.apply(tc);\n+    }\n+\n+    /**  Recurse under #KList and flatten all the terms */\n+    private static PStack<Term> flattenKList(Term t) {\n+        if (t instanceof Ambiguity) {\n+            Ambiguity amb = (Ambiguity) t;", "originalCommit": "f6a5262cdb512b68a38fbb72f5e140221ee84795", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAzMzIxMQ==", "url": "https://github.com/kframework/k/pull/1106#discussion_r382033211", "bodyText": "I am applying an early prefer filter, only for #KList. If I get a KApp, I gather all the KList items and put them in a single list. If I get different ambiguities, like user lists, I discard them since I'm only interested in KList in this place.\nI want to apply this filter in exactly this place because it simplifies this part. It is possible to have user lists mixed in, then the number of KList items is going to be smaller. That's why I'm only taking the list with the highest amount of elements. Since KList has the left attribute, I'm only going to find one element with the highest amount of items.\nIt's possible that I have a production with arity 2, but a KList with 3 elements. Then that's going to be an error. You can still write that if you add a set of braces (see test:495)\nIf I make it the first filter, I have to handle more cases when flattening KList. It could also hinder priorities. I can write mul(plus(1,2),3) but when I transform it into TermCons, it's going to be rejected by the priority filter.", "author": "radumereuta", "createdAt": "2020-02-20T14:29:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ5MDAxMA=="}], "type": "inlineReview"}, {"oid": "100366d025f23e31bddc9fb8b687b263981f8f4c", "url": "https://github.com/kframework/k/commit/100366d025f23e31bddc9fb8b687b263981f8f4c", "message": "Fix PR issues.", "committedDate": "2020-02-20T13:45:20Z", "type": "commit"}, {"oid": "8008917be7f876a13386a583092dd0c48be90b1c", "url": "https://github.com/kframework/k/commit/8008917be7f876a13386a583092dd0c48be90b1c", "message": "Merge branch 'master' into kapp2termcons", "committedDate": "2020-02-20T13:45:37Z", "type": "commit"}, {"oid": "7572658bb8fd57dfea5a6d36c796003bebcb17c8", "url": "https://github.com/kframework/k/commit/7572658bb8fd57dfea5a6d36c796003bebcb17c8", "message": "Accept multiple possible parses under KApp", "committedDate": "2020-02-23T21:13:03Z", "type": "commit"}, {"oid": "ab3add6197841f21cd2447a77f7f3c076808767d", "url": "https://github.com/kframework/k/commit/ab3add6197841f21cd2447a77f7f3c076808767d", "message": "Merge branch 'master' into kapp2termcons", "committedDate": "2020-02-23T21:13:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg2MzQ4MQ==", "url": "https://github.com/kframework/k/pull/1106#discussion_r383863481", "bodyText": "Pretty sure this is reversed from the order you want.", "author": "dwightguth", "createdAt": "2020-02-25T13:01:19Z", "path": "kernel/src/main/java/org/kframework/parser/concrete2kore/disambiguation/KAppToTermConsVisitor.java", "diffHunk": "@@ -43,57 +51,68 @@ public KAppToTermConsVisitor(Module mod) {\n     @Override\n     public Either<java.util.Set<KEMException>, Term> apply(TermCons tc) {\n         assert tc.production() != null : this.getClass() + \":\" + \" production not found.\" + tc;\n-        if (tc.production().klabel().isDefined() && tc.production().klabel().get().name().equals(\"#KApply\")) {\n-            if (!(tc.items().get(1) instanceof Constant) || !((Constant) tc.items().get(1)).production().sort().equals(Sorts.KLabel()))\n-                // TODO: maybe return a hidden warning?\n+        if (tc.production().klabel().isDefined() && tc.production().klabel().get().equals(KLabels.KAPP)) {\n+            if (!(tc.get(0) instanceof Constant) || !((Constant) tc.get(0)).production().sort().equals(Sorts.KLabel()))\n+                // TODO: remove check once the java and ocaml backends are no longer supported.\n                 return super.apply(tc); // don't do anything if the label is not a token KLabel (in case of variable or casted variable)\n-            Constant kl = (Constant) tc.items().get(1);\n-            PStack<Term> items = flattenKList(tc.items().get(0));\n+            Constant kl = (Constant) tc.get(0);\n             String klvalue = kl.value();\n             try { klvalue = StringUtil.unescapeKoreKLabel(kl.value()); } catch (IllegalArgumentException e) { /* ignore */ } // if possible, unescape\n             Set<Production> prods = mutable(mod.productionsFor().get(KLabel(klvalue))\n-                    .getOrElse(Set$.MODULE$::emptyInstance)\n-                    .filter(x -> ((Production) x).arity() == items.size()).toSet());\n-            if (prods.size() == 0) {\n-                String msg = \"Could not find any production with arity \" + items.size() + \" for label \" + kl.value();\n+                    .getOrElse(Set$.MODULE$::emptyInstance).toSet());\n+            Set<Term> sol = new HashSet<>();\n+            Term t = new PushTopAmbiguityUp2().apply(tc.get(1));\n+            Stream<Term> uppedAmb = t instanceof Ambiguity ? ((Ambiguity) t).items().stream() : Lists.newArrayList(t).stream();\n+            Map<Integer, List<PStack<Term>>> flattKLists = uppedAmb\n+                    .map(KAppToTermConsVisitor::flattenKList)\n+                    .collect(Collectors.groupingBy(PStack::size));\n+            for (Production prd : prods)\n+                for (PStack<Term> terms : flattKLists.getOrDefault(prd.arity(), Lists.newArrayList()))\n+                    sol.add(TermCons.apply(terms, prd, tc.location(), tc.source()));\n+\n+            if (sol.size() == 0) {\n+                String msg = \"Could not find any suitable production for label \" + kl.value();\n                 return Left.apply(Sets.newHashSet(KEMException.innerParserError(msg, kl)));\n-            } else if (prods.size() == 1)\n-                return super.apply(TermCons.apply(items, prods.iterator().next(), tc.location(), tc.source()));\n-            else {\n-                // instantiate all labels found and let the type checker filter them out\n-                Set<Term> tcs = new HashSet<>();\n-                for (Production prd : prods)\n-                    tcs.add(TermCons.apply(items, prd, tc.location(), tc.source()));\n-                return super.apply(Ambiguity.apply(tcs, tc.location(), tc.source()));\n-            }\n+            } else if (sol.size() == 1) {\n+                return super.apply(sol.iterator().next());\n+            } else\n+                return super.apply(Ambiguity.apply(sol, tc.location(), tc.source()));\n         }\n         return super.apply(tc);\n     }\n \n     /**  Recurse under #KList and flatten all the terms */\n     private static PStack<Term> flattenKList(Term t) {\n         if (t instanceof Ambiguity) {\n-            Ambiguity amb = (Ambiguity) t;\n-            // prefer KList if they exist, otherwise return t\n-            List<PStack<Term>> klists = amb.items().stream()\n-                    .filter(x -> x instanceof TermCons\n-                            && ((TermCons) x).production().klabel().isDefined()\n-                            && ((TermCons) x).production().klabel().get().name().equals(\"#KList\"))\n-                    .map(KAppToTermConsVisitor::flattenKList)\n-                    .sorted((o1, o2) -> o2.size() - o1.size()).collect(Collectors.toList());\n-\n-            // expecting the first ambiguity branch to have the highest amount of elements\n-            assert klists.size() <= 1 || klists.get(0).size() != klists.get(1).size():\n-                    KAppToTermConsVisitor.class + \":\" + \" unexpected ambiguity pattern found under KApp \" + amb;\n-            if (klists.size() != 0)\n-                return klists.get(0);\n+            assert false : KAppToTermConsVisitor.class + \" expected all ambiguities to already be pushed to the top:\\n\" +\n+                    \"   Source: \" + ((Ambiguity) t).items().iterator().next().source().orElse(null) + \"\\n\" +\n+                    \"   Location: \" + ((Ambiguity) t).items().iterator().next().location().orElse(null);\n         } else if (t instanceof TermCons) {\n             TermCons tc = (TermCons) t;\n-            if (tc.production().klabel().isDefined() && tc.production().klabel().get().name().equals(\"#KList\"))\n-                return flattenKList(tc.items().get(1)).plusAll(flattenKList(tc.items().get(0)));\n-            else if (tc.production().klabel().isDefined() && tc.production().klabel().get().name().equals(\"#EmptyKList\"))\n+            if (tc.production().klabel().isDefined() && tc.production().klabel().get().equals(KLabels.KLIST))\n+                return flattenKList(tc.get(0)).plusAll(flattenKList(tc.get(1)));\n+            else if (tc.production().klabel().isDefined() && tc.production().klabel().get().equals(KLabels.EMPTYKLIST))\n                 return ConsPStack.empty();\n         }\n         return ConsPStack.singleton(t);\n     }\n+\n+    // push ambiguities top so we can get easy access to KList\n+    private static class PushTopAmbiguityUp2 extends SafeTransformer {\n+        @Override\n+        public Term apply(TermCons tc) {\n+            if (tc.production().klabel().isDefined() && tc.production().klabel().get().head().equals(KLabels.KLIST)) {\n+                Term v0 = super.apply(tc.get(0));\n+                Term v1 = super.apply(tc.get(1));\n+                Set<Term> t0 = v0 instanceof Ambiguity ? ((Ambiguity) v0).items() : Sets.newHashSet(v0);\n+                Set<Term> t1 = v1 instanceof Ambiguity ? ((Ambiguity) v1).items() : Sets.newHashSet(v1);\n+                Set<Term> rez = Sets.newHashSet();\n+                for (Term t00 : t0)\n+                    for (Term t11 : t1)\n+                        rez.add(TermCons.apply(ConsPStack.singleton(t00).plus(t11), tc.production(), tc.location(), tc.source()));", "originalCommit": "ab3add6197841f21cd2447a77f7f3c076808767d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA3MTMxOQ==", "url": "https://github.com/kframework/k/pull/1106#discussion_r384071319", "bodyText": "This is wrong, I misunderstood that plus does a prepend in constant time rather than an append.", "author": "dwightguth", "createdAt": "2020-02-25T19:17:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg2MzQ4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg2NDU2Nw==", "url": "https://github.com/kframework/k/pull/1106#discussion_r383864567", "bodyText": "Pretty sure this is reversed too", "author": "dwightguth", "createdAt": "2020-02-25T13:03:29Z", "path": "kernel/src/main/java/org/kframework/parser/concrete2kore/disambiguation/KAppToTermConsVisitor.java", "diffHunk": "@@ -43,57 +51,68 @@ public KAppToTermConsVisitor(Module mod) {\n     @Override\n     public Either<java.util.Set<KEMException>, Term> apply(TermCons tc) {\n         assert tc.production() != null : this.getClass() + \":\" + \" production not found.\" + tc;\n-        if (tc.production().klabel().isDefined() && tc.production().klabel().get().name().equals(\"#KApply\")) {\n-            if (!(tc.items().get(1) instanceof Constant) || !((Constant) tc.items().get(1)).production().sort().equals(Sorts.KLabel()))\n-                // TODO: maybe return a hidden warning?\n+        if (tc.production().klabel().isDefined() && tc.production().klabel().get().equals(KLabels.KAPP)) {\n+            if (!(tc.get(0) instanceof Constant) || !((Constant) tc.get(0)).production().sort().equals(Sorts.KLabel()))\n+                // TODO: remove check once the java and ocaml backends are no longer supported.\n                 return super.apply(tc); // don't do anything if the label is not a token KLabel (in case of variable or casted variable)\n-            Constant kl = (Constant) tc.items().get(1);\n-            PStack<Term> items = flattenKList(tc.items().get(0));\n+            Constant kl = (Constant) tc.get(0);\n             String klvalue = kl.value();\n             try { klvalue = StringUtil.unescapeKoreKLabel(kl.value()); } catch (IllegalArgumentException e) { /* ignore */ } // if possible, unescape\n             Set<Production> prods = mutable(mod.productionsFor().get(KLabel(klvalue))\n-                    .getOrElse(Set$.MODULE$::emptyInstance)\n-                    .filter(x -> ((Production) x).arity() == items.size()).toSet());\n-            if (prods.size() == 0) {\n-                String msg = \"Could not find any production with arity \" + items.size() + \" for label \" + kl.value();\n+                    .getOrElse(Set$.MODULE$::emptyInstance).toSet());\n+            Set<Term> sol = new HashSet<>();\n+            Term t = new PushTopAmbiguityUp2().apply(tc.get(1));\n+            Stream<Term> uppedAmb = t instanceof Ambiguity ? ((Ambiguity) t).items().stream() : Lists.newArrayList(t).stream();\n+            Map<Integer, List<PStack<Term>>> flattKLists = uppedAmb\n+                    .map(KAppToTermConsVisitor::flattenKList)\n+                    .collect(Collectors.groupingBy(PStack::size));\n+            for (Production prd : prods)\n+                for (PStack<Term> terms : flattKLists.getOrDefault(prd.arity(), Lists.newArrayList()))\n+                    sol.add(TermCons.apply(terms, prd, tc.location(), tc.source()));\n+\n+            if (sol.size() == 0) {\n+                String msg = \"Could not find any suitable production for label \" + kl.value();\n                 return Left.apply(Sets.newHashSet(KEMException.innerParserError(msg, kl)));\n-            } else if (prods.size() == 1)\n-                return super.apply(TermCons.apply(items, prods.iterator().next(), tc.location(), tc.source()));\n-            else {\n-                // instantiate all labels found and let the type checker filter them out\n-                Set<Term> tcs = new HashSet<>();\n-                for (Production prd : prods)\n-                    tcs.add(TermCons.apply(items, prd, tc.location(), tc.source()));\n-                return super.apply(Ambiguity.apply(tcs, tc.location(), tc.source()));\n-            }\n+            } else if (sol.size() == 1) {\n+                return super.apply(sol.iterator().next());\n+            } else\n+                return super.apply(Ambiguity.apply(sol, tc.location(), tc.source()));\n         }\n         return super.apply(tc);\n     }\n \n     /**  Recurse under #KList and flatten all the terms */\n     private static PStack<Term> flattenKList(Term t) {\n         if (t instanceof Ambiguity) {\n-            Ambiguity amb = (Ambiguity) t;\n-            // prefer KList if they exist, otherwise return t\n-            List<PStack<Term>> klists = amb.items().stream()\n-                    .filter(x -> x instanceof TermCons\n-                            && ((TermCons) x).production().klabel().isDefined()\n-                            && ((TermCons) x).production().klabel().get().name().equals(\"#KList\"))\n-                    .map(KAppToTermConsVisitor::flattenKList)\n-                    .sorted((o1, o2) -> o2.size() - o1.size()).collect(Collectors.toList());\n-\n-            // expecting the first ambiguity branch to have the highest amount of elements\n-            assert klists.size() <= 1 || klists.get(0).size() != klists.get(1).size():\n-                    KAppToTermConsVisitor.class + \":\" + \" unexpected ambiguity pattern found under KApp \" + amb;\n-            if (klists.size() != 0)\n-                return klists.get(0);\n+            assert false : KAppToTermConsVisitor.class + \" expected all ambiguities to already be pushed to the top:\\n\" +\n+                    \"   Source: \" + ((Ambiguity) t).items().iterator().next().source().orElse(null) + \"\\n\" +\n+                    \"   Location: \" + ((Ambiguity) t).items().iterator().next().location().orElse(null);\n         } else if (t instanceof TermCons) {\n             TermCons tc = (TermCons) t;\n-            if (tc.production().klabel().isDefined() && tc.production().klabel().get().name().equals(\"#KList\"))\n-                return flattenKList(tc.items().get(1)).plusAll(flattenKList(tc.items().get(0)));\n-            else if (tc.production().klabel().isDefined() && tc.production().klabel().get().name().equals(\"#EmptyKList\"))\n+            if (tc.production().klabel().isDefined() && tc.production().klabel().get().equals(KLabels.KLIST))\n+                return flattenKList(tc.get(0)).plusAll(flattenKList(tc.get(1)));", "originalCommit": "ab3add6197841f21cd2447a77f7f3c076808767d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA3MjQwOQ==", "url": "https://github.com/kframework/k/pull/1106#discussion_r384072409", "bodyText": "I was wrong here too; plusAll prepends the argument in reverse order, so if I have ((1, 2),(3, 4)) as the children, I am going to end up with 1,2,4,3 as the final arguments.", "author": "dwightguth", "createdAt": "2020-02-25T19:19:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg2NDU2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA3MjYzOQ==", "url": "https://github.com/kframework/k/pull/1106#discussion_r384072639", "bodyText": "the second flattenKList call needs to be reversed.", "author": "dwightguth", "createdAt": "2020-02-25T19:20:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg2NDU2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA1NjUxMg==", "url": "https://github.com/kframework/k/pull/1106#discussion_r384056512", "bodyText": "Test 1", "author": "radumereuta", "createdAt": "2020-02-25T18:50:16Z", "path": "kernel/src/test/java/org/kframework/parser/concrete2kore/RuleGrammarTest.java", "diffHunk": "@@ -472,4 +474,35 @@ public void testLayout() {\n         parseProgram(\"0 (; some text ;) + 3\", customLayout, \"Int\", 0, false);\n         parseProgram(\"0 + 3 // some text\"   , customLayout, \"Int\", 0, true);\n     }\n+\n+    // test KAppToTermConsVisitor for issue #985\n+    @Test\n+    public void test25() {\n+        String def = \"\" +\n+                \"module TEST\\n\" +\n+                \"  syntax E ::= \\\"a\\\"         [klabel(elma), symbol]\\n\" +\n+                \"  syntax Lst ::= E \\\",\\\" Lst [klabel(constr), symbol]\\n\" +\n+                \"  syntax Lst2 ::= E \\\",\\\" Lst2 [klabel(constr), symbol]\\n\" +\n+                \"                | Lst \\n\" +\n+                \"endmodule\";\n+        parseRule(\"constr(I, L) => L\", def, 0,", "originalCommit": "ab3add6197841f21cd2447a77f7f3c076808767d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA1NjU5OQ==", "url": "https://github.com/kframework/k/pull/1106#discussion_r384056599", "bodyText": "Test 2", "author": "radumereuta", "createdAt": "2020-02-25T18:50:26Z", "path": "kernel/src/test/java/org/kframework/parser/concrete2kore/RuleGrammarTest.java", "diffHunk": "@@ -472,4 +474,35 @@ public void testLayout() {\n         parseProgram(\"0 (; some text ;) + 3\", customLayout, \"Int\", 0, false);\n         parseProgram(\"0 + 3 // some text\"   , customLayout, \"Int\", 0, true);\n     }\n+\n+    // test KAppToTermConsVisitor for issue #985\n+    @Test\n+    public void test25() {\n+        String def = \"\" +\n+                \"module TEST\\n\" +\n+                \"  syntax E ::= \\\"a\\\"         [klabel(elma), symbol]\\n\" +\n+                \"  syntax Lst ::= E \\\",\\\" Lst [klabel(constr), symbol]\\n\" +\n+                \"  syntax Lst2 ::= E \\\",\\\" Lst2 [klabel(constr), symbol]\\n\" +\n+                \"                | Lst \\n\" +\n+                \"endmodule\";\n+        parseRule(\"constr(I, L) => L\", def, 0,\n+                KApply(KLabel(\"#ruleNoConditions\"),KApply(KLabel(\"#KRewrite\"),\n+                        KApply(KLabel(\"constr\"),\n+                                KApply(KLabel(\"#SemanticCastToE\"), KToken(\"I\",Sort(\"#KVariable\"))),\n+                                KApply(KLabel(\"#SemanticCastToLst2\"), KToken(\"L\",Sort(\"#KVariable\")))),\n+                        KApply(KLabel(\"#SemanticCastToLst2\"), KToken(\"L\",Sort(\"#KVariable\")))\n+                )));\n+        parseRule(\"`constr`(I, (a, L)) => L\", def, 0,", "originalCommit": "ab3add6197841f21cd2447a77f7f3c076808767d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "002bddc157fa6c926f1e52f8959d665256a18176", "url": "https://github.com/kframework/k/commit/002bddc157fa6c926f1e52f8959d665256a18176", "message": "Fix reverse order and extend test.", "committedDate": "2020-02-25T20:13:06Z", "type": "commit"}, {"oid": "f94a92bd8a0d7fbae8acddb1b2363376408fb388", "url": "https://github.com/kframework/k/commit/f94a92bd8a0d7fbae8acddb1b2363376408fb388", "message": "Merge branch 'master' into kapp2termcons", "committedDate": "2020-02-25T20:13:23Z", "type": "commit"}, {"oid": "4ca19af785796ebf8700679a8db12e876d5e100e", "url": "https://github.com/kframework/k/commit/4ca19af785796ebf8700679a8db12e876d5e100e", "message": "Merge branch 'master' into kapp2termcons", "committedDate": "2020-02-25T20:59:26Z", "type": "commit"}]}