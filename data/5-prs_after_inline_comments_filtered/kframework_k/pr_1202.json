{"pr_number": 1202, "pr_title": "Cell maps ceil rules", "pr_createdAt": "2020-04-07T06:25:00Z", "pr_url": "https://github.com/kframework/k/pull/1202", "timeline": [{"oid": "05a9347aeda6b9a4910d5b44419db457946c6ded", "url": "https://github.com/kframework/k/commit/05a9347aeda6b9a4910d5b44419db457946c6ded", "message": "tmp", "committedDate": "2020-04-08T06:29:01Z", "type": "forcePushed"}, {"oid": "06255af022d23f7a2ade82e1f8591e77f8b82034", "url": "https://github.com/kframework/k/commit/06255af022d23f7a2ade82e1f8591e77f8b82034", "message": "Generating in_keys and ceil rules for map cells.", "committedDate": "2020-04-09T10:24:44Z", "type": "commit"}, {"oid": "ffa7ea6c889ac920af93204785d36c3d4246a360", "url": "https://github.com/kframework/k/commit/ffa7ea6c889ac920af93204785d36c3d4246a360", "message": "Updated axioms for in_keys", "committedDate": "2020-04-09T10:32:47Z", "type": "forcePushed"}, {"oid": "f038220bcf67c520e5c41ddb7e4612ea50a2c94b", "url": "https://github.com/kframework/k/commit/f038220bcf67c520e5c41ddb7e4612ea50a2c94b", "message": "Updated axioms for in_keys", "committedDate": "2020-04-09T14:30:45Z", "type": "commit"}, {"oid": "f038220bcf67c520e5c41ddb7e4612ea50a2c94b", "url": "https://github.com/kframework/k/commit/f038220bcf67c520e5c41ddb7e4612ea50a2c94b", "message": "Updated axioms for in_keys", "committedDate": "2020-04-09T14:30:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU1MTc4OA==", "url": "https://github.com/kframework/k/pull/1202#discussion_r406551788", "bodyText": "What's going on with the pairs of set and element variables?", "author": "ttuegel", "createdAt": "2020-04-10T00:51:40Z", "path": "kernel/src/main/java/org/kframework/backend/kore/ModuleToKORE.java", "diffHunk": "@@ -499,6 +498,98 @@ private void genUnitAxiom(Production prod, StringBuilder sb) {\n         sb.append(\") [unit{}()] // left unit\\n\");\n     }\n \n+    private void genMapCeilAxioms(Production prod, Collection<Rule> rules) {\n+        Sort mapSort = prod.nonterminal(1).sort();\n+        scala.collection.Set<Production> mapProds = module.productionsForSort().apply(mapSort.head());\n+        Production concatProd = mapProds.find(p -> hasHookValue(p.att(), \"MAP.concat\")).get();\n+        Production elementProd = mapProds.find(p -> hasHookValue(p.att(), \"MAP.element\")).get();\n+        List<K> args = new ArrayList<>();\n+        List<K> setArgs = new ArrayList<>();\n+        Seq<NonTerminal> nonterminals = elementProd.nonterminals();\n+        K restMap = KVariable(\"Rest\", Att.empty().add(Sort.class, mapSort));\n+        K restMapSet = KVariable(\"@Rest\", Att.empty().add(Sort.class, mapSort));", "originalCommit": "f038220bcf67c520e5c41ddb7e4612ea50a2c94b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcyMTQ0Nw==", "url": "https://github.com/kframework/k/pull/1202#discussion_r406721447", "bodyText": "the element variables are used for the in_keys rules. The set variables are used for the ceil rules.", "author": "traiansf", "createdAt": "2020-04-10T11:41:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU1MTc4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg5NjgyMQ==", "url": "https://github.com/kframework/k/pull/1202#discussion_r406896821", "bodyText": "I find it difficult to follow how the rules are constructed because the construction of the rules is interleaved in this way, but it's not difficult enough that I'm going to hold up this pull request.", "author": "ttuegel", "createdAt": "2020-04-10T18:58:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU1MTc4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM2ODA4OQ==", "url": "https://github.com/kframework/k/pull/1202#discussion_r407368089", "bodyText": "I've refactored the code and added comments with the rules. hope it is clearer now.", "author": "traiansf", "createdAt": "2020-04-13T08:04:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU1MTc4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU1MTg4MQ==", "url": "https://github.com/kframework/k/pull/1202#discussion_r406551881", "bodyText": "Should the #Ceil and #And constants be defined somewhere?", "author": "ttuegel", "createdAt": "2020-04-10T00:52:07Z", "path": "kernel/src/main/java/org/kframework/backend/kore/ModuleToKORE.java", "diffHunk": "@@ -499,6 +498,98 @@ private void genUnitAxiom(Production prod, StringBuilder sb) {\n         sb.append(\") [unit{}()] // left unit\\n\");\n     }\n \n+    private void genMapCeilAxioms(Production prod, Collection<Rule> rules) {\n+        Sort mapSort = prod.nonterminal(1).sort();\n+        scala.collection.Set<Production> mapProds = module.productionsForSort().apply(mapSort.head());\n+        Production concatProd = mapProds.find(p -> hasHookValue(p.att(), \"MAP.concat\")).get();\n+        Production elementProd = mapProds.find(p -> hasHookValue(p.att(), \"MAP.element\")).get();\n+        List<K> args = new ArrayList<>();\n+        List<K> setArgs = new ArrayList<>();\n+        Seq<NonTerminal> nonterminals = elementProd.nonterminals();\n+        K restMap = KVariable(\"Rest\", Att.empty().add(Sort.class, mapSort));\n+        K restMapSet = KVariable(\"@Rest\", Att.empty().add(Sort.class, mapSort));\n+        Sort sortParam = Sort(AddSortInjections.SORTPARAM_NAME, Sort(\"Q\"));\n+        KLabel ceilMapLabel = KLabel(\"#Ceil\", mapSort, sortParam);", "originalCommit": "f038220bcf67c520e5c41ddb7e4612ea50a2c94b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwODU5Nw==", "url": "https://github.com/kframework/k/pull/1202#discussion_r406708597", "bodyText": "What is the anywhere for?", "author": "ttuegel", "createdAt": "2020-04-10T10:55:36Z", "path": "kernel/src/main/java/org/kframework/backend/kore/ModuleToKORE.java", "diffHunk": "@@ -499,6 +498,98 @@ private void genUnitAxiom(Production prod, StringBuilder sb) {\n         sb.append(\") [unit{}()] // left unit\\n\");\n     }\n \n+    private void genMapCeilAxioms(Production prod, Collection<Rule> rules) {\n+        Sort mapSort = prod.nonterminal(1).sort();\n+        scala.collection.Set<Production> mapProds = module.productionsForSort().apply(mapSort.head());\n+        Production concatProd = mapProds.find(p -> hasHookValue(p.att(), \"MAP.concat\")).get();\n+        Production elementProd = mapProds.find(p -> hasHookValue(p.att(), \"MAP.element\")).get();\n+        List<K> args = new ArrayList<>();\n+        List<K> setArgs = new ArrayList<>();\n+        Seq<NonTerminal> nonterminals = elementProd.nonterminals();\n+        K restMap = KVariable(\"Rest\", Att.empty().add(Sort.class, mapSort));\n+        K restMapSet = KVariable(\"@Rest\", Att.empty().add(Sort.class, mapSort));\n+        Sort sortParam = Sort(AddSortInjections.SORTPARAM_NAME, Sort(\"Q\"));\n+        KLabel ceilMapLabel = KLabel(\"#Ceil\", mapSort, sortParam);\n+        KLabel andLabel = KLabel(\"#And\", sortParam);\n+        K setArgsCeil = KApply(ceilMapLabel, restMapSet);\n+        for (int i = 0; i< nonterminals.length(); i++) {\n+            Sort sort = nonterminals.apply(i).sort();\n+            args.add(KVariable(\"K\" + i, Att.empty().add(Sort.class, sort)));\n+            KVariable setVar = KVariable(\"@K\" + i, Att.empty().add(Sort.class, sort));\n+            setArgs.add(setVar);\n+            KLabel ceilVarLabel = KLabel(\"#Ceil\", sort, sortParam);\n+            setArgsCeil = KApply(andLabel, setArgsCeil, KApply(ceilVarLabel, setVar));\n+        }\n+        Seq<K> argsSeq = JavaConverters.iterableAsScalaIterable(args).toSeq();\n+        Seq<K> setArgsSeq = JavaConverters.iterableAsScalaIterable(setArgs).toSeq();\n+        Rule inKeysRule1 = Rule(\n+                KRewrite(\n+                        KApply(prod.klabel().get(),\n+                                args.get(0),\n+                                KApply(concatProd.klabel().get(),\n+                                        KApply(elementProd.klabel().get(),\n+                                                argsSeq,\n+                                                Att.empty()\n+                                        ),\n+                                        restMap\n+                                )\n+                        ),\n+                        BooleanUtils.TRUE\n+                ),\n+                BooleanUtils.TRUE,\n+                BooleanUtils.TRUE\n+        );\n+        rules.add(inKeysRule1);\n+        Rule inKeysRule2 = Rule(\n+                KRewrite(\n+                        KApply(prod.klabel().get(),\n+                                args.get(0),\n+                                restMap\n+                        ),\n+                        BooleanUtils.FALSE\n+                ),\n+                BooleanUtils.TRUE,\n+                BooleanUtils.TRUE,\n+                Att.empty().add(\"owise\")\n+        );\n+        rules.add(inKeysRule2);\n+        KLabel equalsLabel = KLabel(\"#Equals\", Sorts.Bool(), sortParam);\n+        Rule ceilMapRule =\n+                Rule(\n+                        KRewrite(\n+                                KApply(ceilMapLabel,\n+                                        KApply(concatProd.klabel().get(),\n+                                                KApply(elementProd.klabel().get(),\n+                                                        setArgsSeq,\n+                                                        Att.empty()\n+                                                ),\n+                                                restMapSet\n+                                        )\n+                                )\n+                                ,\n+                                KApply(andLabel,\n+                                        KApply(equalsLabel,\n+                                                KApply(prod.klabel().get(),\n+                                                        setArgs.get(0),\n+                                                        restMapSet\n+                                                ),\n+                                                BooleanUtils.FALSE\n+                                        ),\n+                                        setArgsCeil\n+                                )\n+                        )\n+                        , BooleanUtils.TRUE\n+                        , BooleanUtils.TRUE\n+                        , Att.empty().add(\"anywhere\").add(\"simplification\")", "originalCommit": "f038220bcf67c520e5c41ddb7e4612ea50a2c94b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcyMjM5Mw==", "url": "https://github.com/kframework/k/pull/1202#discussion_r406722393", "bodyText": "That's awkward, but since #Ceil is not a function, we usually need to annotate #Ceil rules with anywhere to prevent them from being completed with <k> and stuff. Maybe here I didn't need to add them, as we're late in the compilation process, but I added them for consistency.", "author": "traiansf", "createdAt": "2020-04-10T11:45:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwODU5Nw=="}], "type": "inlineReview"}, {"oid": "4acefe74d8024a0f2f232acb40c03b5054956f59", "url": "https://github.com/kframework/k/commit/4acefe74d8024a0f2f232acb40c03b5054956f59", "message": "separated MAP rules for haskell backend", "committedDate": "2020-04-10T11:14:18Z", "type": "commit"}, {"oid": "0aea835074168fe561bdcca1409f92ba08065a19", "url": "https://github.com/kframework/k/commit/0aea835074168fe561bdcca1409f92ba08065a19", "message": "Ceil rules for maps", "committedDate": "2020-04-10T11:33:26Z", "type": "commit"}, {"oid": "381602b381d5ab5304ea0b70e305c39e640e9f7f", "url": "https://github.com/kframework/k/commit/381602b381d5ab5304ea0b70e305c39e640e9f7f", "message": "Addressing reviews", "committedDate": "2020-04-10T12:57:04Z", "type": "commit"}, {"oid": "6c52b3d8920b1ff9f3c8d42d1862a6b301e90e63", "url": "https://github.com/kframework/k/commit/6c52b3d8920b1ff9f3c8d42d1862a6b301e90e63", "message": "Merge remote-tracking branch 'upstream/master' into cell-maps-ceil-rules", "committedDate": "2020-04-10T12:57:29Z", "type": "commit"}, {"oid": "6c52b3d8920b1ff9f3c8d42d1862a6b301e90e63", "url": "https://github.com/kframework/k/commit/6c52b3d8920b1ff9f3c8d42d1862a6b301e90e63", "message": "Merge remote-tracking branch 'upstream/master' into cell-maps-ceil-rules", "committedDate": "2020-04-10T12:57:29Z", "type": "forcePushed"}, {"oid": "9100cce53332687287b87d33fbe809040dac45e8", "url": "https://github.com/kframework/k/commit/9100cce53332687287b87d33fbe809040dac45e8", "message": "Merge branch 'master' into cell-maps-ceil-rules", "committedDate": "2020-04-10T18:14:17Z", "type": "commit"}, {"oid": "c10f818ae9f7522efa41281137f30b4b5e84d8ae", "url": "https://github.com/kframework/k/commit/c10f818ae9f7522efa41281137f30b4b5e84d8ae", "message": "Generating rules for default map, too.\nRefactorings to improve readability.", "committedDate": "2020-04-13T07:43:11Z", "type": "commit"}, {"oid": "1da7523a8397698b759da498f8e49baaebb64aa9", "url": "https://github.com/kframework/k/commit/1da7523a8397698b759da498f8e49baaebb64aa9", "message": "Merge branch 'cell-maps-ceil-rules' of github.com:traiansf/k into cell-maps-ceil-rules", "committedDate": "2020-04-13T07:45:03Z", "type": "commit"}]}