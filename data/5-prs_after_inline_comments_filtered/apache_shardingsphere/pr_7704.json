{"pr_number": 7704, "pr_title": "add create function and procedure validator", "pr_createdAt": "2020-10-06T12:34:03Z", "pr_url": "https://github.com/apache/shardingsphere/pull/7704", "timeline": [{"oid": "c9bf40034f230ddd78869f5e88ace716cbdf1dad", "url": "https://github.com/apache/shardingsphere/commit/c9bf40034f230ddd78869f5e88ace716cbdf1dad", "message": "add create function and procedure validator", "committedDate": "2020-10-06T10:09:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk1ODk1Ng==", "url": "https://github.com/apache/shardingsphere/pull/7704#discussion_r500958956", "bodyText": "Carefully examined. \ud83d\udc4d", "author": "tristaZero", "createdAt": "2020-10-07T12:09:07Z", "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-statement/src/test/java/org/apache/shardingsphere/sql/parser/sql/dialect/handler/ddl/DropIndexStatementHandlerTest.java", "diffHunk": "@@ -28,7 +28,7 @@\n import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertTrue;\n \n-public class DropIndexStatementHandlerTest {\n+public final class DropIndexStatementHandlerTest {", "originalCommit": "c9bf40034f230ddd78869f5e88ace716cbdf1dad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk4Mzc4Nw==", "url": "https://github.com/apache/shardingsphere/pull/7704#discussion_r500983787", "bodyText": "if MySQLDMLVisitor is necessary, do you think moving the content of MySQLDMLVisitor to MySQLVisitor will be better than createParseTreeVisitor?", "author": "tristaZero", "createdAt": "2020-10-07T12:48:28Z", "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-dialect/shardingsphere-sql-parser-mysql/src/main/java/org/apache/shardingsphere/sql/parser/mysql/visitor/impl/MySQLDDLVisitor.java", "diffHunk": "@@ -461,92 +483,256 @@ public ASTNode visitKeyParts_(final KeyParts_Context ctx) {\n         }\n         return result;\n     }\n-\n+    \n     @Override\n     public ASTNode visitCreateProcedure(final CreateProcedureContext ctx) {\n-        return new MySQLCreateProcedureStatement();\n+        MySQLCreateProcedureStatement result = new MySQLCreateProcedureStatement();\n+        result.setRoutineBody((RoutineBodySegment) visit(ctx.routineBody()));\n+        return result;\n     }\n-\n+    \n     @Override\n     public ASTNode visitAlterProcedure(final AlterProcedureContext ctx) {\n         return new MySQLAlterProcedureStatement();\n     }\n-\n+    \n     @Override\n     public ASTNode visitDropProcedure(final DropProcedureContext ctx) {\n         return new MySQLDropProcedureStatement();\n     }\n-\n+    \n     @Override\n     public ASTNode visitCreateFunction(final CreateFunctionContext ctx) {\n-        return new MySQLCreateFunctionStatement();\n+        MySQLCreateFunctionStatement result = new MySQLCreateFunctionStatement();\n+        result.setRoutineBody((RoutineBodySegment) visit(ctx.routineBody()));\n+        return result;\n     }\n-\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public ASTNode visitRoutineBody(final RoutineBodyContext ctx) {\n+        RoutineBodySegment result = new RoutineBodySegment(ctx.start.getStartIndex(), ctx.stop.getStopIndex());\n+        CollectionValue<ValidStatementSegment> validStatements;\n+        if (null != ctx.simpleStatement()) {\n+            validStatements = (CollectionValue<ValidStatementSegment>) visit(ctx.simpleStatement());\n+        } else {\n+            validStatements = (CollectionValue<ValidStatementSegment>) visit(ctx.compoundStatement());\n+        }\n+        result.getValidStatements().addAll(validStatements.getValue());\n+        return result;\n+    }\n+    \n+    @Override\n+    public ASTNode visitSimpleStatement(final SimpleStatementContext ctx) {\n+        return visit(ctx.validStatement());\n+    }\n+    \n+    @Override\n+    public ASTNode visitCompoundStatement(final CompoundStatementContext ctx) {\n+        return visit(ctx.beginStatement());\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public ASTNode visitBeginStatement(final BeginStatementContext ctx) {\n+        CollectionValue<ValidStatementSegment> result = new CollectionValue<>();\n+        for (ValidStatementContext each : ctx.validStatement()) {\n+            result.combine((CollectionValue<ValidStatementSegment>) visit(each));\n+        }\n+        return result;\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public ASTNode visitValidStatement(final ValidStatementContext ctx) {\n+        CollectionValue<ValidStatementSegment> result = new CollectionValue<>();\n+        ValidStatementSegment validStatement = new ValidStatementSegment(ctx.start.getStartIndex(), ctx.stop.getStopIndex());\n+        if (null != ctx.createTable()) {\n+            validStatement.setCreateTable((MySQLCreateTableStatement) visit(ctx.createTable()));\n+            result.getValue().add(validStatement);\n+        } else if (null != ctx.alterTable()) {\n+            validStatement.setAlterTable((MySQLAlterTableStatement) visit(ctx.alterTable()));\n+            result.getValue().add(validStatement);\n+        } else if (null != ctx.dropTable()) {\n+            validStatement.setDropTable((MySQLDropTableStatement) visit(ctx.dropTable()));\n+            result.getValue().add(validStatement);\n+        } else if (null != ctx.truncateTable()) {\n+            validStatement.setTruncate((MySQLTruncateStatement) visit(ctx.truncateTable()));\n+            result.getValue().add(validStatement);\n+        }\n+        if (null != ctx.validDMLStatement()) {\n+            result.combine((CollectionValue<ValidStatementSegment>) visit(ctx.validDMLStatement()));\n+        }\n+        if (null != ctx.beginStatement()) {\n+            result.combine((CollectionValue<ValidStatementSegment>) visit(ctx.beginStatement()));\n+        }\n+        if (null != ctx.flowControlStatement()) {\n+            result.combine((CollectionValue<ValidStatementSegment>) visit(ctx.flowControlStatement()));\n+        }\n+        return result;\n+    }\n+    \n+    @Override\n+    public ASTNode visitValidDMLStatement(final ValidDMLStatementContext ctx) {\n+        CollectionValue<ValidStatementSegment> result = new CollectionValue<>();\n+        ValidStatementSegment validStatement = new ValidStatementSegment(ctx.start.getStartIndex(), ctx.stop.getStopIndex());\n+        if (null != ctx.insert()) {\n+            validStatement.setInsert((MySQLInsertStatement) createParseTreeVisitor(ctx.insert().getClass()).visit(ctx.insert()));\n+        } else if (null != ctx.replace()) {\n+            validStatement.setReplace((MySQLInsertStatement) createParseTreeVisitor(ctx.replace().getClass()).visit(ctx.replace()));\n+        } else if (null != ctx.update()) {\n+            validStatement.setUpdate((MySQLUpdateStatement) createParseTreeVisitor(ctx.update().getClass()).visit(ctx.update()));\n+        } else if (null != ctx.delete()) {\n+            validStatement.setDelete((MySQLDeleteStatement) createParseTreeVisitor(ctx.delete().getClass()).visit(ctx.delete()));\n+        } else if (null != ctx.select()) {\n+            validStatement.setSelect((MySQLSelectStatement) createParseTreeVisitor(ctx.select().getClass()).visit(ctx.select()));\n+        }\n+        result.getValue().add(validStatement);\n+        return result;\n+    }\n+    \n+    @SuppressWarnings(\"rawtypes\")\n+    private ParseTreeVisitor createParseTreeVisitor(final Class<? extends ParseTree> parseTreeClass) {", "originalCommit": "c9bf40034f230ddd78869f5e88ace716cbdf1dad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAzMzM2Mw==", "url": "https://github.com/apache/shardingsphere/pull/7704#discussion_r501033363", "bodyText": "if MySQLDMLVisitor is necessary, do you think moving the content of MySQLDMLVisitor to MySQLVisitor will be better than createParseTreeVisitor?\n\n@tristaZero The stored routine supports a variety of DML and DAL statements, and migrating the implementation of these statements to the MySQLVisitor would cause the MySQLVisitor to become bloated.\nIn addition, the MySQLVisitor seems to be more suited to processing some generic syntax fragments than the entire statement.", "author": "strongduanmu", "createdAt": "2020-10-07T13:56:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk4Mzc4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQzNzYwOA==", "url": "https://github.com/apache/shardingsphere/pull/7704#discussion_r501437608", "bodyText": "Yep, I buy that  MySQLVisitor is supposed to contain the generic functions and items. But if MySQLDDLVisitor needs to use these functions of MySQLDMLVisitor,  the relevant ones will become shared one for DMLVisitor and DDLVisitor, and is possible to move them to MySQLVisitor, though which will create a bloated father class.\nWhat's more, as you know, the currentParameterIndex makes MySQLVisitor not as a simple utility. If you create a new instance of DMLVisitor in DDLVisitor, I guess there will be an incorrect parameterIndex.\nHonestly speaking, I have no better method to handle this issue. :-(\nActually, for some of the other SQL parser engines like druid or hive, they put all the visitors and g4 files together, as they do not have a complete and an awful lot of SQL definitions. \ud83d\ude05", "author": "tristaZero", "createdAt": "2020-10-08T04:12:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk4Mzc4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTY3NzUyMQ==", "url": "https://github.com/apache/shardingsphere/pull/7704#discussion_r501677521", "bodyText": "@tristaZero Thank you very much for your advice, the setting of parameter currentParameterIndex is really a problem, I will optimize it by migrating the common function from the MySQLDMLVisitor to the MySQLVisitor. \ud83d\ude00", "author": "strongduanmu", "createdAt": "2020-10-08T12:23:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk4Mzc4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk4ODQxNg==", "url": "https://github.com/apache/shardingsphere/pull/7704#discussion_r500988416", "bodyText": "A function will make it intelligible. :-)", "author": "tristaZero", "createdAt": "2020-10-07T12:55:15Z", "path": "shardingsphere-features/shardingsphere-sharding/shardingsphere-sharding-route/src/main/java/org/apache/shardingsphere/sharding/route/engine/validator/impl/ShardingCreateFunctionStatementValidator.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.shardingsphere.sharding.route.engine.validator.impl;\n+\n+import org.apache.shardingsphere.infra.exception.ShardingSphereException;\n+import org.apache.shardingsphere.infra.metadata.ShardingSphereMetaData;\n+import org.apache.shardingsphere.infra.route.context.RouteContext;\n+import org.apache.shardingsphere.sharding.route.engine.exception.NoSuchTableException;\n+import org.apache.shardingsphere.sharding.route.engine.exception.TableExistsException;\n+import org.apache.shardingsphere.sharding.route.engine.validator.ShardingStatementValidator;\n+import org.apache.shardingsphere.sharding.rule.ShardingRule;\n+import org.apache.shardingsphere.sql.parser.binder.statement.SQLStatementContext;\n+import org.apache.shardingsphere.sql.parser.binder.statement.ddl.CreateFunctionStatementContext;\n+import org.apache.shardingsphere.sql.parser.sql.common.segment.generic.table.SimpleTableSegment;\n+import org.apache.shardingsphere.sql.parser.sql.common.statement.ddl.CreateFunctionStatement;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Sharding create function statement validator.\n+ */\n+public final class ShardingCreateFunctionStatementValidator implements ShardingStatementValidator<CreateFunctionStatement> {\n+    \n+    @Override\n+    public void preValidate(final ShardingRule shardingRule, final SQLStatementContext<CreateFunctionStatement> sqlStatementContext,\n+                            final List<Object> parameters, final ShardingSphereMetaData metaData) {\n+        for (SimpleTableSegment each : ((CreateFunctionStatementContext) sqlStatementContext).getExistTables()) {\n+            String tableName = each.getTableName().getIdentifier().getValue();\n+            if (metaData.getRuleSchemaMetaData().getConfiguredSchemaMetaData().getAllTableNames().contains(tableName)) {\n+                throw new ShardingSphereException(\"Create function statement can not support sharding table '%s'.\", tableName);\n+            }\n+            for (Map.Entry<String, Collection<String>> entry : metaData.getRuleSchemaMetaData().getUnconfiguredSchemaMetaDataMap().entrySet()) {\n+                if (!entry.getValue().contains(tableName)) {\n+                    throw new NoSuchTableException(entry.getKey(), tableName);\n+                }", "originalCommit": "c9bf40034f230ddd78869f5e88ace716cbdf1dad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA0OTM0OA==", "url": "https://github.com/apache/shardingsphere/pull/7704#discussion_r501049348", "bodyText": "A function will make it intelligible. :-)\n\n@tristaZero I will optimize it. \ud83d\ude00", "author": "strongduanmu", "createdAt": "2020-10-07T14:16:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk4ODQxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk5MDE3MQ==", "url": "https://github.com/apache/shardingsphere/pull/7704#discussion_r500990171", "bodyText": "Same. But it is not a big problem.  Just an optional tip.", "author": "tristaZero", "createdAt": "2020-10-07T12:57:54Z", "path": "shardingsphere-features/shardingsphere-sharding/shardingsphere-sharding-route/src/main/java/org/apache/shardingsphere/sharding/route/engine/validator/impl/ShardingCreateFunctionStatementValidator.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.shardingsphere.sharding.route.engine.validator.impl;\n+\n+import org.apache.shardingsphere.infra.exception.ShardingSphereException;\n+import org.apache.shardingsphere.infra.metadata.ShardingSphereMetaData;\n+import org.apache.shardingsphere.infra.route.context.RouteContext;\n+import org.apache.shardingsphere.sharding.route.engine.exception.NoSuchTableException;\n+import org.apache.shardingsphere.sharding.route.engine.exception.TableExistsException;\n+import org.apache.shardingsphere.sharding.route.engine.validator.ShardingStatementValidator;\n+import org.apache.shardingsphere.sharding.rule.ShardingRule;\n+import org.apache.shardingsphere.sql.parser.binder.statement.SQLStatementContext;\n+import org.apache.shardingsphere.sql.parser.binder.statement.ddl.CreateFunctionStatementContext;\n+import org.apache.shardingsphere.sql.parser.sql.common.segment.generic.table.SimpleTableSegment;\n+import org.apache.shardingsphere.sql.parser.sql.common.statement.ddl.CreateFunctionStatement;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Sharding create function statement validator.\n+ */\n+public final class ShardingCreateFunctionStatementValidator implements ShardingStatementValidator<CreateFunctionStatement> {\n+    \n+    @Override\n+    public void preValidate(final ShardingRule shardingRule, final SQLStatementContext<CreateFunctionStatement> sqlStatementContext,\n+                            final List<Object> parameters, final ShardingSphereMetaData metaData) {\n+        for (SimpleTableSegment each : ((CreateFunctionStatementContext) sqlStatementContext).getExistTables()) {\n+            String tableName = each.getTableName().getIdentifier().getValue();\n+            if (metaData.getRuleSchemaMetaData().getConfiguredSchemaMetaData().getAllTableNames().contains(tableName)) {\n+                throw new ShardingSphereException(\"Create function statement can not support sharding table '%s'.\", tableName);\n+            }\n+            for (Map.Entry<String, Collection<String>> entry : metaData.getRuleSchemaMetaData().getUnconfiguredSchemaMetaDataMap().entrySet()) {\n+                if (!entry.getValue().contains(tableName)) {\n+                    throw new NoSuchTableException(entry.getKey(), tableName);\n+                }\n+            }\n+        }\n+        for (SimpleTableSegment each : ((CreateFunctionStatementContext) sqlStatementContext).getNotExistTables()) {\n+            String tableName = each.getTableName().getIdentifier().getValue();\n+            if (metaData.getRuleSchemaMetaData().getAllTableNames().contains(tableName)) {\n+                throw new TableExistsException(tableName);\n+            }\n+        }\n+    }", "originalCommit": "c9bf40034f230ddd78869f5e88ace716cbdf1dad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA0OTg2MA==", "url": "https://github.com/apache/shardingsphere/pull/7704#discussion_r501049860", "bodyText": "Same. But it is not a big problem. Just an optional tip.\n\n@tristaZero I will optimize it too.", "author": "strongduanmu", "createdAt": "2020-10-07T14:17:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk5MDE3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk5Mjk2OQ==", "url": "https://github.com/apache/shardingsphere/pull/7704#discussion_r500992969", "bodyText": "From your changes,  I suppose two of there are no more than checking,  aren't they?\nThat way, why do not we move routineBody -> existTables.addAll(extractor.extractExistTableFromRoutineBody(routineBody) to validator?", "author": "tristaZero", "createdAt": "2020-10-07T13:02:05Z", "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-binder/src/main/java/org/apache/shardingsphere/sql/parser/binder/statement/ddl/CreateFunctionStatementContext.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.shardingsphere.sql.parser.binder.statement.ddl;\n+\n+import lombok.Getter;\n+import org.apache.shardingsphere.sql.parser.binder.statement.CommonSQLStatementContext;\n+import org.apache.shardingsphere.sql.parser.sql.common.extractor.TableExtractor;\n+import org.apache.shardingsphere.sql.parser.sql.common.segment.ddl.routine.RoutineBodySegment;\n+import org.apache.shardingsphere.sql.parser.sql.common.segment.generic.table.SimpleTableSegment;\n+import org.apache.shardingsphere.sql.parser.sql.common.statement.ddl.CreateFunctionStatement;\n+import org.apache.shardingsphere.sql.parser.sql.dialect.handler.ddl.CreateFunctionStatementHandler;\n+\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.Optional;\n+\n+/**\n+ * Create function statement context.\n+ */\n+@Getter\n+public final class CreateFunctionStatementContext extends CommonSQLStatementContext<CreateFunctionStatement> {\n+    \n+    private final Collection<SimpleTableSegment> existTables = new LinkedList<>();", "originalCommit": "c9bf40034f230ddd78869f5e88ace716cbdf1dad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA1MTE2Ng==", "url": "https://github.com/apache/shardingsphere/pull/7704#discussion_r501051166", "bodyText": "From your changes, I suppose two of there are no more than checking, aren't they?\nThat way, why do not we move routineBody -> existTables.addAll(extractor.extractExistTableFromRoutineBody(routineBody) to validator?\n\n@tristaZero Yes, this logic can be extracted into the Validator.", "author": "strongduanmu", "createdAt": "2020-10-07T14:19:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk5Mjk2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAwMzgyMw==", "url": "https://github.com/apache/shardingsphere/pull/7704#discussion_r501003823", "bodyText": "There only will be one of them at a time, right?  Plus, currently, do we indeed care about the concrete class type of this object?  I mean, do you think it is possible to merge them as a SQLStatement?", "author": "tristaZero", "createdAt": "2020-10-07T13:17:51Z", "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-statement/src/main/java/org/apache/shardingsphere/sql/parser/sql/common/segment/ddl/routine/ValidStatementSegment.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.shardingsphere.sql.parser.sql.common.segment.ddl.routine;\n+\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import org.apache.shardingsphere.sql.parser.sql.common.segment.SQLSegment;\n+import org.apache.shardingsphere.sql.parser.sql.common.statement.ddl.AlterTableStatement;\n+import org.apache.shardingsphere.sql.parser.sql.common.statement.ddl.CreateTableStatement;\n+import org.apache.shardingsphere.sql.parser.sql.common.statement.ddl.DropTableStatement;\n+import org.apache.shardingsphere.sql.parser.sql.common.statement.ddl.TruncateStatement;\n+import org.apache.shardingsphere.sql.parser.sql.common.statement.dml.DeleteStatement;\n+import org.apache.shardingsphere.sql.parser.sql.common.statement.dml.InsertStatement;\n+import org.apache.shardingsphere.sql.parser.sql.common.statement.dml.SelectStatement;\n+import org.apache.shardingsphere.sql.parser.sql.common.statement.dml.UpdateStatement;\n+\n+import java.util.Optional;\n+\n+/**\n+ * Valid statement segment.\n+ */\n+@RequiredArgsConstructor\n+@Getter\n+@Setter\n+public class ValidStatementSegment implements SQLSegment {\n+    \n+    private final int startIndex;\n+    \n+    private final int stopIndex;\n+    \n+    private CreateTableStatement createTable;\n+    \n+    private AlterTableStatement alterTable;\n+    \n+    private DropTableStatement dropTable;\n+    \n+    private TruncateStatement truncate;\n+    \n+    private InsertStatement insert;\n+    \n+    private InsertStatement replace;\n+    \n+    private UpdateStatement update;\n+    \n+    private DeleteStatement delete;\n+    \n+    private SelectStatement select;", "originalCommit": "c9bf40034f230ddd78869f5e88ace716cbdf1dad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA1ODEzOA==", "url": "https://github.com/apache/shardingsphere/pull/7704#discussion_r501058138", "bodyText": "There only will be one of them at a time, right? Plus, currently, do we indeed care about the concrete class type of this object? I mean, do you think it is possible to merge them as a SQLStatement?\n\n@tristaZero For now, we are only concerned with the tables contained in these statements, which are then used for validation, and perhaps sharding routing and rewriting will be supported in the future.\nIf we combine these statements into a single statement, we need to extract the tables contained in the various statements during parsing. This will add a lot of logic to the visitor. Is that ok? \ud83e\udd14", "author": "strongduanmu", "createdAt": "2020-10-07T14:27:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAwMzgyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQzMjcxOA==", "url": "https://github.com/apache/shardingsphere/pull/7704#discussion_r501432718", "bodyText": "we need to extract the tables contained in the various statements during parsing.\n\nI think the visitor handling could retain the same, even though here its member is SQLStatement.\nWe should visit out the concrete SQLStatement, IMO, since that is in line with its g4 definition. However, I wonder whether a generic SQLStatment instead of a list of possible types is adequate to reflect its composition. What's more, the following functions like getCreateTable() seem to help give more descriptions of a SQLStatement to the outer calls.\nIt seems these public functions rather than its members are more likely to be called,  doesn't it?  That way, do you think this list of member options seems a lit bloated (as you said before:-))?", "author": "tristaZero", "createdAt": "2020-10-08T03:51:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAwMzgyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTY4NTE2Ng==", "url": "https://github.com/apache/shardingsphere/pull/7704#discussion_r501685166", "bodyText": "@tristaZero I like your suggestion that using SQLStatement to receive different types of statements, and then use public methods to provide external calls. \ud83d\udc4d", "author": "strongduanmu", "createdAt": "2020-10-08T12:36:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAwMzgyMw=="}], "type": "inlineReview"}, {"oid": "17a9e2eff8ceb0bad8a73b8c7e4efb4bca3ac4b0", "url": "https://github.com/apache/shardingsphere/commit/17a9e2eff8ceb0bad8a73b8c7e4efb4bca3ac4b0", "message": "optimize create function and procedure validator", "committedDate": "2020-10-08T15:13:38Z", "type": "commit"}]}