{"pr_number": 8116, "pr_title": "Add sql formart visitor", "pr_createdAt": "2020-11-10T09:34:05Z", "pr_url": "https://github.com/apache/shardingsphere/pull/8116", "timeline": [{"oid": "483df6d36181f412f8829d90d3fad9fae964eb3e", "url": "https://github.com/apache/shardingsphere/commit/483df6d36181f412f8829d90d3fad9fae964eb3e", "message": "add sql format visitor", "committedDate": "2020-11-10T07:39:37Z", "type": "commit"}, {"oid": "0fcb38a6ff6c153d042d9a0a71bf081146e6c314", "url": "https://github.com/apache/shardingsphere/commit/0fcb38a6ff6c153d042d9a0a71bf081146e6c314", "message": "fix", "committedDate": "2020-11-10T07:46:37Z", "type": "commit"}, {"oid": "a1b9079298f4c8bead227302e4fb13ebcf43b89f", "url": "https://github.com/apache/shardingsphere/commit/a1b9079298f4c8bead227302e4fb13ebcf43b89f", "message": "fix", "committedDate": "2020-11-10T09:30:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAxMjMzNA==", "url": "https://github.com/apache/shardingsphere/pull/8116#discussion_r521012334", "bodyText": "A blank line is needed above. Besides, why do we not use the result returned by each visitXXX() immediately (Currently, those returned results seem unused)?  That way, we could keep the same way as StatementVisitors.", "author": "tristaZero", "createdAt": "2020-11-11T01:54:03Z", "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-dialect/shardingsphere-sql-parser-mysql/src/main/java/org/apache/shardingsphere/sql/parser/mysql/visitor/format/impl/MySQLFormatSQLVisitor.java", "diffHunk": "@@ -19,11 +19,423 @@\n \n import lombok.AccessLevel;\n import lombok.Getter;\n+import org.antlr.v4.runtime.tree.ParseTree;\n+import org.antlr.v4.runtime.tree.RuleNode;\n+import org.antlr.v4.runtime.tree.TerminalNode;\n import org.apache.shardingsphere.sql.parser.autogen.MySQLStatementBaseVisitor;\n+import org.apache.shardingsphere.sql.parser.autogen.MySQLStatementParser;\n \n /**\n  * MySQL Format SQL visitor for MySQL.\n  */\n @Getter(AccessLevel.PROTECTED)\n public abstract class MySQLFormatSQLVisitor extends MySQLStatementBaseVisitor<String> {\n+    private StringBuilder result = new StringBuilder();", "originalCommit": "a1b9079298f4c8bead227302e4fb13ebcf43b89f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA1MjY2OA==", "url": "https://github.com/apache/shardingsphere/pull/8116#discussion_r521052668", "bodyText": "First, FormartVisitor is different from StatementVisitors, StatementVisitors need create different type Segment,  FormartVisitor just need StringBuilder, so using shared variables can reduce the cost of creating objects.\nSecond, there is no need to processe the return value of child elements when using shared variables\n,just call visit(childrule),\nWhen a visitor function is added, we do not need to modify  its parent function.ItWill reduce the amount of code, otherwise, you need to create a visitor function for each rule. @tristaZero", "author": "jingshanglu", "createdAt": "2020-11-11T02:51:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAxMjMzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAxNDE0Nw==", "url": "https://github.com/apache/shardingsphere/pull/8116#discussion_r521014147", "bodyText": "Given the code standard instruction in doc , null  == this.result  is preferable, right?", "author": "tristaZero", "createdAt": "2020-11-11T01:56:34Z", "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-dialect/shardingsphere-sql-parser-mysql/src/main/java/org/apache/shardingsphere/sql/parser/mysql/visitor/format/impl/MySQLFormatSQLVisitor.java", "diffHunk": "@@ -19,11 +19,423 @@\n \n import lombok.AccessLevel;\n import lombok.Getter;\n+import org.antlr.v4.runtime.tree.ParseTree;\n+import org.antlr.v4.runtime.tree.RuleNode;\n+import org.antlr.v4.runtime.tree.TerminalNode;\n import org.apache.shardingsphere.sql.parser.autogen.MySQLStatementBaseVisitor;\n+import org.apache.shardingsphere.sql.parser.autogen.MySQLStatementParser;\n \n /**\n  * MySQL Format SQL visitor for MySQL.\n  */\n @Getter(AccessLevel.PROTECTED)\n public abstract class MySQLFormatSQLVisitor extends MySQLStatementBaseVisitor<String> {\n+    private StringBuilder result = new StringBuilder();\n+\n+    private final boolean uperCase = true;\n+\n+    private int indentCount;\n+\n+    private int lines;\n+\n+    private int projectionsCountOfLine = 3;\n+\n+    @Override\n+    public String visitSelect(final MySQLStatementParser.SelectContext ctx) {\n+        if (null != ctx.queryExpression()) {\n+            visit(ctx.queryExpression());\n+            if (null != ctx.lockClauseList()) {\n+                result.append(\" \");\n+                visit(ctx.lockClauseList());\n+            }\n+        } else if (null != ctx.queryExpressionParens()) {\n+            visit(ctx.queryExpressionParens());\n+        } else {\n+            visit(ctx.selectWithInto());\n+        }\n+        print(\";\");\n+        return result.toString();\n+    }\n+\n+    @Override\n+    public String visitQueryExpression(final MySQLStatementParser.QueryExpressionContext ctx) {\n+        if (null != ctx.withClause()) {\n+            visit(ctx.withClause());\n+            print(\" \");\n+        }\n+        if (null != ctx.queryExpressionBody()) {\n+            visit(ctx.queryExpressionBody());\n+        } else {\n+            visit(ctx.queryExpressionParens());\n+        }\n+        if (null != ctx.orderByClause()) {\n+            print(\" \");\n+            visit(ctx.orderByClause());\n+        }\n+        if (null != ctx.limitClause()) {\n+            print(\" \");\n+            visit(ctx.limitClause());\n+        }\n+        return result.toString();\n+    }\n+\n+    @Override\n+    public String visitQueryExpressionParens(final MySQLStatementParser.QueryExpressionParensContext ctx) {\n+        println();\n+        this.indentCount++;\n+        print(\"(\");\n+        println();\n+        if (null != ctx.queryExpressionParens()) {\n+            visit(ctx.queryExpressionParens());\n+        } else {\n+            visit(ctx.queryExpression());\n+            if (null != ctx.lockClauseList()) {\n+                result.append(\" \");\n+                visit(ctx.lockClauseList());\n+            }\n+        }\n+        this.indentCount--;\n+        println();\n+        print(\")\");\n+        return result.toString();\n+    }\n+\n+    @Override\n+    public String visitQueryExpressionBody(final MySQLStatementParser.QueryExpressionBodyContext ctx) {\n+        if (1 == ctx.getChildCount()) {\n+            visit(ctx.queryPrimary());\n+        } else {\n+            visit(ctx.queryExpressionParens(0));\n+            result.append(\"\\nUNION\\n\");\n+            if (null != ctx.unionOption()) {\n+                visit(ctx.unionOption());\n+                result.append(\" \");\n+            }\n+            if (null != ctx.queryPrimary()) {\n+                visit(ctx.queryPrimary());\n+            } else {\n+                visit(ctx.queryExpressionParens(1));\n+            }\n+        }\n+        return result.toString();\n+    }\n+\n+    @Override\n+    public String visitQuerySpecification(final MySQLStatementParser.QuerySpecificationContext ctx) {\n+        print(\"SELECT \");\n+        int selectSpecCount = ctx.selectSpecification().size();\n+        for (int i = 0; i < selectSpecCount; i++) {\n+            visit(ctx.selectSpecification(i));\n+            print(\" \");\n+        }\n+        visit(ctx.projections());\n+        if (null != ctx.fromClause()) {\n+            println();\n+            visit(ctx.fromClause());\n+        }\n+        if (null != ctx.whereClause()) {\n+            println();\n+            visit(ctx.whereClause());\n+        }\n+        if (null != ctx.groupByClause()) {\n+            println();\n+            visit(ctx.groupByClause());\n+        }\n+        if (null != ctx.havingClause()) {\n+            println();\n+            visit(ctx.havingClause());\n+        }\n+        if (null != ctx.windowClause()) {\n+            println();\n+            visit(ctx.windowClause());\n+        }\n+        return result.toString();\n+    }\n+\n+    @Override\n+    public String visitExplicitTable(final MySQLStatementParser.ExplicitTableContext ctx) {\n+        print(\"TABLE \");\n+        visit(ctx.tableName());\n+        return result.toString();\n+    }\n+\n+    @Override\n+    public String visitTableName(final MySQLStatementParser.TableNameContext ctx) {\n+        if (null != ctx.owner()) {\n+            print(ctx.owner().getText());\n+            print(\".\");\n+        }\n+        print(ctx.name().getText());\n+        return result.toString();\n+    }\n+\n+    @Override\n+    public String visitTableValueConstructor(final MySQLStatementParser.TableValueConstructorContext ctx) {\n+        print(\"VALUES \");\n+        visit(ctx.rowConstructorList());\n+        return result.toString();\n+    }\n+\n+    @Override\n+    public String visitRowConstructorList(final MySQLStatementParser.RowConstructorListContext ctx) {\n+        int rowCount = ctx.assignmentValues().size();\n+        for (int i = 0; i < rowCount; i++) {\n+            if (i != 0 && i != rowCount) {\n+                print(\", ROW\");\n+                visit(ctx.assignmentValues(i));\n+\n+            } else {\n+                print(\"ROW\");\n+                visit(ctx.assignmentValues(i));\n+            }\n+        }\n+        return result.toString();\n+    }\n+\n+    @Override\n+    public String visitAssignmentValues(final MySQLStatementParser.AssignmentValuesContext ctx) {\n+        print(\"(\");\n+        int assignCount = ctx.assignmentValue().size();\n+        for (int i = 0; i < assignCount; i++) {\n+            if (i != 0) {\n+                print(\", \");\n+                visit(ctx.assignmentValue(i));\n+            } else {\n+                visit(ctx.assignmentValue(i));\n+            }\n+        }\n+        print(\")\");\n+        return result.toString();\n+    }\n+\n+    @Override\n+    public String visitWhereClause(final MySQLStatementParser.WhereClauseContext ctx) {\n+        visit(ctx.WHERE());\n+        print(\" \");\n+        this.indentCount++;\n+        println();\n+        visit(ctx.expr());\n+        this.indentCount--;\n+        return result.toString();\n+    }\n+\n+    @Override\n+    public String visitExpr(final MySQLStatementParser.ExprContext ctx) {\n+        if (null != ctx.logicalOperator()) {\n+            MySQLStatementParser.ExprContext left = ctx.expr(0);\n+            visit(left);\n+            println();\n+            MySQLStatementParser.ExprContext right = ctx.expr(1);\n+            print(ctx.logicalOperator().getText());\n+            visit(right);\n+        } else if (null != ctx.notOperator()) {\n+            print(ctx.notOperator().getText());\n+            visit(ctx.expr(0));\n+        } else {\n+            visitChildren(ctx);\n+        }\n+        return result.toString();\n+    }\n+\n+    @Override\n+    public String visitAlias(final MySQLStatementParser.AliasContext ctx) {\n+        print(ctx.getText());\n+        return result.toString();\n+    }\n+\n+    @Override\n+    public String visitProjections(final MySQLStatementParser.ProjectionsContext ctx) {\n+        this.indentCount++;\n+        if (null != ctx.unqualifiedShorthand()) {\n+            visit(ctx.unqualifiedShorthand());\n+            result.append(\" \");\n+        }\n+        int projectionCount = ctx.projection().size();\n+        int lineItemCount = 0;\n+        for (int i = 0; i < projectionCount; i++) {\n+            if (0 != i) {\n+                result.append(\", \");\n+                if (lineItemCount >= projectionsCountOfLine) {\n+                    lineItemCount = 0;\n+                    println();\n+                }\n+            }\n+            visit(ctx.projection(i));\n+            lineItemCount++;\n+        }\n+        this.indentCount--;\n+        return result.toString();\n+    }\n+\n+    @Override\n+    public String visitProjection(final MySQLStatementParser.ProjectionContext ctx) {\n+        if (null != ctx.expr()) {\n+            visit(ctx.expr());\n+            print(\" \");\n+        }\n+        if (null != ctx.AS()) {\n+            print(\"AS \");\n+        }\n+        if (null != ctx.alias()) {\n+            visit(ctx.alias());\n+        }\n+        if (null != ctx.qualifiedShorthand()) {\n+            visit(ctx.qualifiedShorthand());\n+        }\n+        return result.toString();\n+    }\n+\n+    @Override\n+    public String visitTerminal(final TerminalNode node) {\n+        if (isUperCase()) {\n+            print(node.getText().toUpperCase());\n+        } else {\n+            print(node.getText().toLowerCase());\n+        }\n+        return result.toString();\n+    }\n+\n+    @Override\n+    public String visitIdentifier(final MySQLStatementParser.IdentifierContext ctx) {\n+        print(ctx.getText());\n+        return result.toString();\n+    }\n+\n+    @Override\n+    public String visitLiterals(final MySQLStatementParser.LiteralsContext ctx) {\n+        print(\"?\");\n+        return result.toString();\n+    }\n+\n+    @Override\n+    public String visitStringLiterals(final MySQLStatementParser.StringLiteralsContext ctx) {\n+        print(\"?\");\n+        return result.toString();\n+    }\n+\n+    @Override\n+    public String visitNumberLiterals(final MySQLStatementParser.NumberLiteralsContext ctx) {\n+        print(\"?\");\n+        return result.toString();\n+    }\n+\n+    @Override\n+    public String visitWithClause(final MySQLStatementParser.WithClauseContext ctx) {\n+        print(\"WITH \");\n+        if (null != ctx.RECURSIVE()) {\n+            visit(ctx.RECURSIVE());\n+            result.append(\" \");\n+        }\n+        for (int i = 0; i < ctx.cteClause().size(); i++) {\n+            if (i != 0 && i < ctx.cteClause().size() - 1) {\n+                result.append(\", \");\n+            }\n+            visit(ctx.cteClause(i));\n+        }\n+        if (null != ctx.parent) {\n+            result.append(\"\\n\");\n+        }\n+        return result.toString();\n+    }\n+\n+    @Override\n+    public String visitCteClause(final MySQLStatementParser.CteClauseContext ctx) {\n+        visit(ctx.ignoredIdentifier());\n+        result.append(\" \");\n+        if (null != ctx.columnNames()) {\n+            visit(ctx.columnNames());\n+            result.append(\" \");\n+        }\n+        result.append(\"AS \");\n+        visit(ctx.subquery());\n+        return result.toString();\n+    }\n+\n+    @Override\n+    public String visitIgnoredIdentifier(final MySQLStatementParser.IgnoredIdentifierContext ctx) {\n+        visit(ctx.identifier(0));\n+        if (null != ctx.DOT_()) {\n+            visit(ctx.DOT_());\n+            visit(ctx.identifier(1));\n+        }\n+        return result.toString();\n+    }\n+\n+    @Override\n+    public String visitColumnNames(final MySQLStatementParser.ColumnNamesContext ctx) {\n+        if (null != ctx.LP_()) {\n+            visit(ctx.LP_());\n+        }\n+        int columnCount = ctx.columnName().size();\n+        for (int i = 0; i < columnCount; i++) {\n+            if (i != 0 && i < columnCount - 1) {\n+                result.append(\", \");\n+            } else {\n+                visit(ctx.columnName(i));\n+            }\n+        }\n+        if (null != ctx.RP_()) {\n+            visit(ctx.RP_());\n+        }\n+        return result.toString();\n+    }\n+\n+    @Override\n+    public String visitColumnName(final MySQLStatementParser.ColumnNameContext ctx) {\n+        if (null != ctx.owner()) {\n+            visit(ctx.owner());\n+            visit(ctx.DOT_(0));\n+        }\n+        visit(ctx.name());\n+        return result.toString();\n+    }\n+\n+    @Override\n+    public String visitChildren(final RuleNode node) {\n+        String result = defaultResult();\n+\n+        int n = node.getChildCount();\n+        for (int i = 0; i < n; i++) {\n+            if (i != 0) {\n+                print(\" \");\n+            }\n+            if (!shouldVisitNextChild(node, result)) {\n+                break;\n+            }\n+\n+            ParseTree c = node.getChild(i);\n+            String childResult = c.accept(this);\n+            result = aggregateResult(result, childResult);\n+        }\n+        return result;\n+    }\n+\n+    private void print(final char value) {\n+        if (this.result == null) {", "originalCommit": "a1b9079298f4c8bead227302e4fb13ebcf43b89f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA2MjUyNg==", "url": "https://github.com/apache/shardingsphere/pull/8116#discussion_r521062526", "bodyText": "OK", "author": "jingshanglu", "createdAt": "2020-11-11T03:01:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAxNDE0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAxNTI3NA==", "url": "https://github.com/apache/shardingsphere/pull/8116#discussion_r521015274", "bodyText": "Please make it   final unless it has any child classes.", "author": "tristaZero", "createdAt": "2020-11-11T01:58:07Z", "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-dialect/shardingsphere-sql-parser-mysql/src/test/java/org/apache/shardingsphere/sql/parser/mysql/MySQLFormartTest.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.shardingsphere.sql.parser.mysql;\n+\n+import lombok.Getter;\n+import org.antlr.v4.runtime.CodePointBuffer;\n+import org.antlr.v4.runtime.CodePointCharStream;\n+import org.antlr.v4.runtime.CommonTokenStream;\n+import org.antlr.v4.runtime.tree.ParseTree;\n+import org.apache.shardingsphere.sql.parser.core.parser.ParseASTNode;\n+import org.apache.shardingsphere.sql.parser.mysql.parser.MySQLLexer;\n+import org.apache.shardingsphere.sql.parser.mysql.parser.MySQLParser;\n+import org.apache.shardingsphere.sql.parser.mysql.visitor.format.impl.MySQLDMLFormatSQLVisitor;\n+import org.apache.shardingsphere.sql.parser.mysql.visitor.format.impl.MySQLFormatSQLVisitor;\n+import org.junit.Test;\n+\n+import java.nio.CharBuffer;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+public class MySQLFormartTest {", "originalCommit": "a1b9079298f4c8bead227302e4fb13ebcf43b89f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAxNjE2Mg==", "url": "https://github.com/apache/shardingsphere/pull/8116#discussion_r521016162", "bodyText": "final member?", "author": "tristaZero", "createdAt": "2020-11-11T01:59:26Z", "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-dialect/shardingsphere-sql-parser-mysql/src/test/java/org/apache/shardingsphere/sql/parser/mysql/MySQLFormartTest.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.shardingsphere.sql.parser.mysql;\n+\n+import lombok.Getter;\n+import org.antlr.v4.runtime.CodePointBuffer;\n+import org.antlr.v4.runtime.CodePointCharStream;\n+import org.antlr.v4.runtime.CommonTokenStream;\n+import org.antlr.v4.runtime.tree.ParseTree;\n+import org.apache.shardingsphere.sql.parser.core.parser.ParseASTNode;\n+import org.apache.shardingsphere.sql.parser.mysql.parser.MySQLLexer;\n+import org.apache.shardingsphere.sql.parser.mysql.parser.MySQLParser;\n+import org.apache.shardingsphere.sql.parser.mysql.visitor.format.impl.MySQLDMLFormatSQLVisitor;\n+import org.apache.shardingsphere.sql.parser.mysql.visitor.format.impl.MySQLFormatSQLVisitor;\n+import org.junit.Test;\n+\n+import java.nio.CharBuffer;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+public class MySQLFormartTest {\n+\n+    @Getter\n+    private static List<String[]> testUnits = new LinkedList();", "originalCommit": "a1b9079298f4c8bead227302e4fb13ebcf43b89f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAxODEwOA==", "url": "https://github.com/apache/shardingsphere/pull/8116#discussion_r521018108", "bodyText": "This name seems to be vague for this test assertion", "author": "tristaZero", "createdAt": "2020-11-11T02:02:12Z", "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-dialect/shardingsphere-sql-parser-mysql/src/test/java/org/apache/shardingsphere/sql/parser/mysql/MySQLFormartTest.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.shardingsphere.sql.parser.mysql;\n+\n+import lombok.Getter;\n+import org.antlr.v4.runtime.CodePointBuffer;\n+import org.antlr.v4.runtime.CodePointCharStream;\n+import org.antlr.v4.runtime.CommonTokenStream;\n+import org.antlr.v4.runtime.tree.ParseTree;\n+import org.apache.shardingsphere.sql.parser.core.parser.ParseASTNode;\n+import org.apache.shardingsphere.sql.parser.mysql.parser.MySQLLexer;\n+import org.apache.shardingsphere.sql.parser.mysql.parser.MySQLParser;\n+import org.apache.shardingsphere.sql.parser.mysql.visitor.format.impl.MySQLDMLFormatSQLVisitor;\n+import org.apache.shardingsphere.sql.parser.mysql.visitor.format.impl.MySQLFormatSQLVisitor;\n+import org.junit.Test;\n+\n+import java.nio.CharBuffer;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+public class MySQLFormartTest {\n+\n+    @Getter\n+    private static List<String[]> testUnits = new LinkedList();\n+\n+    {\n+        testUnits.add(new String[]{\"test\", \"select a+1 as b, name n from table1 join table2 where id=1 and name='lu';\", \"SELECT a + ? AS b, name n\\n\"\n+                + \"FROM table1 JOIN table2\\n\"\n+                + \"WHERE \\n\"\n+                + \"\\tid = ?\\n\"\n+                + \"\\tandname = ?;\"});\n+        testUnits.add(new String[]{\"\", \"select id, name, age, sex, ss, yy from table1 where id=1\", \"SELECT id , name , age , \\n\"\n+                + \"\\tsex , ss , yy \\n\"\n+                + \"FROM table1\\n\"\n+                + \"WHERE \\n\"\n+                + \"\\tid = ?;\"});\n+        testUnits.add(new String[]{\"\", \"select id, name, age, count(*) as n, (select id, name, age, sex from table2 where id=2) as sid, yyyy from table1 where id=1\", \"SELECT id , name , age , \\n\"\n+                + \"\\tCOUNT ( * ) AS n, \\n\"\n+                + \"\\t(\\n\"\n+                + \"\\t\\tSELECT id , name , age , \\n\"\n+                + \"\\t\\t\\tsex \\n\"\n+                + \"\\t\\tFROM table2\\n\"\n+                + \"\\t\\tWHERE \\n\"\n+                + \"\\t\\t\\tid = ?\\n\"\n+                + \"\\t) AS sid, yyyy \\n\"\n+                + \"FROM table1\\n\"\n+                + \"WHERE \\n\"\n+                + \"\\tid = ?;\"});\n+        testUnits.add(new String[]{\"\", \"select id, name, age, sex, ss, yy from table1 where id=1 and name=1 and a=1 and b=2 and c=4 and d=3\", \"SELECT id , name , age , \\n\"\n+                + \"\\tsex , ss , yy \\n\"\n+                + \"FROM table1\\n\"\n+                + \"WHERE \\n\"\n+                + \"\\tid = ?\\n\"\n+                + \"\\tandname = ?\\n\"\n+                + \"\\tanda = ?\\n\"\n+                + \"\\tandb = ?\\n\"\n+                + \"\\tandc = ?\\n\"\n+                + \"\\tandd = ?;\"});\n+        testUnits.add(new String[]{\"\", \"ALTER TABLE t_log ADD name varchar(10)\", \"ALTER TABLE t_log ADD name VARCHAR ( 10 )\"});\n+    }\n+\n+    @Test\n+    public final void assertTest() {", "originalCommit": "a1b9079298f4c8bead227302e4fb13ebcf43b89f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAxOTczOA==", "url": "https://github.com/apache/shardingsphere/pull/8116#discussion_r521019738", "bodyText": "So this test...just intends to get an error assertion result? How about getting a standard and correct assertion?", "author": "tristaZero", "createdAt": "2020-11-11T02:04:29Z", "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-dialect/shardingsphere-sql-parser-mysql/src/test/java/org/apache/shardingsphere/sql/parser/mysql/MySQLFormartTest.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.shardingsphere.sql.parser.mysql;\n+\n+import lombok.Getter;\n+import org.antlr.v4.runtime.CodePointBuffer;\n+import org.antlr.v4.runtime.CodePointCharStream;\n+import org.antlr.v4.runtime.CommonTokenStream;\n+import org.antlr.v4.runtime.tree.ParseTree;\n+import org.apache.shardingsphere.sql.parser.core.parser.ParseASTNode;\n+import org.apache.shardingsphere.sql.parser.mysql.parser.MySQLLexer;\n+import org.apache.shardingsphere.sql.parser.mysql.parser.MySQLParser;\n+import org.apache.shardingsphere.sql.parser.mysql.visitor.format.impl.MySQLDMLFormatSQLVisitor;\n+import org.apache.shardingsphere.sql.parser.mysql.visitor.format.impl.MySQLFormatSQLVisitor;\n+import org.junit.Test;\n+\n+import java.nio.CharBuffer;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+public class MySQLFormartTest {\n+\n+    @Getter\n+    private static List<String[]> testUnits = new LinkedList();\n+\n+    {\n+        testUnits.add(new String[]{\"test\", \"select a+1 as b, name n from table1 join table2 where id=1 and name='lu';\", \"SELECT a + ? AS b, name n\\n\"\n+                + \"FROM table1 JOIN table2\\n\"\n+                + \"WHERE \\n\"\n+                + \"\\tid = ?\\n\"\n+                + \"\\tandname = ?;\"});\n+        testUnits.add(new String[]{\"\", \"select id, name, age, sex, ss, yy from table1 where id=1\", \"SELECT id , name , age , \\n\"\n+                + \"\\tsex , ss , yy \\n\"\n+                + \"FROM table1\\n\"\n+                + \"WHERE \\n\"\n+                + \"\\tid = ?;\"});\n+        testUnits.add(new String[]{\"\", \"select id, name, age, count(*) as n, (select id, name, age, sex from table2 where id=2) as sid, yyyy from table1 where id=1\", \"SELECT id , name , age , \\n\"\n+                + \"\\tCOUNT ( * ) AS n, \\n\"\n+                + \"\\t(\\n\"\n+                + \"\\t\\tSELECT id , name , age , \\n\"\n+                + \"\\t\\t\\tsex \\n\"\n+                + \"\\t\\tFROM table2\\n\"\n+                + \"\\t\\tWHERE \\n\"\n+                + \"\\t\\t\\tid = ?\\n\"\n+                + \"\\t) AS sid, yyyy \\n\"\n+                + \"FROM table1\\n\"\n+                + \"WHERE \\n\"\n+                + \"\\tid = ?;\"});\n+        testUnits.add(new String[]{\"\", \"select id, name, age, sex, ss, yy from table1 where id=1 and name=1 and a=1 and b=2 and c=4 and d=3\", \"SELECT id , name , age , \\n\"\n+                + \"\\tsex , ss , yy \\n\"\n+                + \"FROM table1\\n\"\n+                + \"WHERE \\n\"\n+                + \"\\tid = ?\\n\"\n+                + \"\\tandname = ?\\n\"\n+                + \"\\tanda = ?\\n\"\n+                + \"\\tandb = ?\\n\"\n+                + \"\\tandc = ?\\n\"\n+                + \"\\tandd = ?;\"});\n+        testUnits.add(new String[]{\"\", \"ALTER TABLE t_log ADD name varchar(10)\", \"ALTER TABLE t_log ADD name VARCHAR ( 10 )\"});\n+    }\n+\n+    @Test\n+    public final void assertTest() {\n+        for (String[] each : testUnits) {\n+            CodePointBuffer buffer = CodePointBuffer.withChars(CharBuffer.wrap(each[1].toCharArray()));\n+            MySQLLexer lexer = new MySQLLexer(CodePointCharStream.fromBuffer(buffer));\n+            MySQLParser parser = new MySQLParser(new CommonTokenStream(lexer));\n+            ParseTree tree = ((ParseASTNode) parser.parse()).getRootNode();\n+            MySQLFormatSQLVisitor visitor = new MySQLDMLFormatSQLVisitor();\n+            String result = visitor.visit(tree);\n+            assertTrue(\"SQL format error\", each[2].equals(result));", "originalCommit": "a1b9079298f4c8bead227302e4fb13ebcf43b89f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA3Mjk1Mg==", "url": "https://github.com/apache/shardingsphere/pull/8116#discussion_r521072952", "bodyText": "Is UT to verify whether the actual output is consistent with the expected output? @tristaZero", "author": "jingshanglu", "createdAt": "2020-11-11T03:13:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAxOTczOA=="}], "type": "inlineReview"}, {"oid": "08c7481e98b66182a73dab7230d140f29679c599", "url": "https://github.com/apache/shardingsphere/commit/08c7481e98b66182a73dab7230d140f29679c599", "message": "fix", "committedDate": "2020-11-11T03:17:41Z", "type": "commit"}, {"oid": "3b3ac107a3d551873a72e05fbc21cde528b1167c", "url": "https://github.com/apache/shardingsphere/commit/3b3ac107a3d551873a72e05fbc21cde528b1167c", "message": "fix", "committedDate": "2020-11-11T06:02:02Z", "type": "commit"}, {"oid": "c1d8f16aa87a7b412120afade13fe41c5fee2ab2", "url": "https://github.com/apache/shardingsphere/commit/c1d8f16aa87a7b412120afade13fe41c5fee2ab2", "message": "fix", "committedDate": "2020-11-11T10:03:37Z", "type": "commit"}, {"oid": "7eeafe44f118a4aa61f7743175507f0d603dabf6", "url": "https://github.com/apache/shardingsphere/commit/7eeafe44f118a4aa61f7743175507f0d603dabf6", "message": "fix", "committedDate": "2020-11-11T10:30:44Z", "type": "commit"}, {"oid": "ef6bb6a6425a61ba7f15290eccb207b316663553", "url": "https://github.com/apache/shardingsphere/commit/ef6bb6a6425a61ba7f15290eccb207b316663553", "message": "fix", "committedDate": "2020-11-11T12:10:05Z", "type": "commit"}]}