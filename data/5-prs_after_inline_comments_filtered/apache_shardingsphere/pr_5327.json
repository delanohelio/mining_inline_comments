{"pr_number": 5327, "pr_title": "create RANGE sharding algorithm", "pr_createdAt": "2020-04-26T15:30:08Z", "pr_url": "https://github.com/apache/shardingsphere/pull/5327", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ3OTA4MA==", "url": "https://github.com/apache/shardingsphere/pull/5327#discussion_r415479080", "bodyText": "for line 61 and 73:\ndoSharding() method will be called while route value, it may be not efficient to build partitionRangeMap in doSharding method, I think it can be used as a static field and  built once while initing instance.", "author": "SanmuWangZJU", "createdAt": "2020-04-27T03:07:46Z", "path": "sharding-core/sharding-core-common/src/main/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/RangeShardingAlgorithm.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.shardingsphere.core.strategy.algorithm.sharding;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Range;\n+import com.google.common.primitives.Longs;\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.shardingsphere.api.sharding.standard.PreciseShardingValue;\n+import org.apache.shardingsphere.api.sharding.standard.RangeShardingValue;\n+import org.apache.shardingsphere.api.sharding.standard.StandardShardingAlgorithm;\n+\n+import java.util.Collection;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Properties;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Range sharding algorithm.\n+ * <p>\n+ * Range sharding algorithm is similar to the rule of partition table.\n+ * User can specify the range by setting the `range.partition.split.value` parameter.\n+ * The `range.partition.split.value` parameter is an ordered list of numbers, separated by commas.\n+ * </p>\n+ * <p>\n+ * For example: If the `range.partition.split.value` parameter is set to `1,5,10`,\n+ * the parameter will split all values into four intervals\u2014\u2014(-\u221e, 1), [1,5), [5,10), [10, +\u221e),\n+ * which corresponding to partition_0, partition_1, partition_2, partition_3.\n+ * The sharding values will be divided into different partition by its value.\n+ * </p>\n+ */\n+public final class RangeShardingAlgorithm implements StandardShardingAlgorithm<Long> {\n+\n+    private static final String RANGE_PARTITION_SPLIT_VALUE = \"range.partition.split.value\";\n+\n+    private Properties properties = new Properties();\n+\n+    @Override\n+    public String doSharding(final Collection<String> availableTargetNames, final PreciseShardingValue<Long> shardingValue) {\n+        Preconditions.checkNotNull(properties.get(RANGE_PARTITION_SPLIT_VALUE), \"Range sharding algorithm range partition split value cannot be null.\");\n+        Map<Integer, Range<Long>> partitionRangeMap = getPartitionRangeMap();\n+        for (String each : availableTargetNames) {\n+            if (each.endsWith(getPartition(partitionRangeMap, shardingValue.getValue()))) {\n+                return each;\n+            }\n+        }\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Collection<String> doSharding(final Collection<String> availableTargetNames, final RangeShardingValue<Long> shardingValue) {\n+        Preconditions.checkNotNull(properties.get(RANGE_PARTITION_SPLIT_VALUE), \"Range sharding algorithm range partition split value cannot be null.\");\n+        Map<Integer, Range<Long>> partitionRangeMap = getPartitionRangeMap();", "originalCommit": "fa505b2aa55581e505a412951255cf4e876107a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTUxMzM5Mg==", "url": "https://github.com/apache/shardingsphere/pull/5327#discussion_r415513392", "bodyText": "for line 61 and 73:\ndoSharding() method will be called while route value, it may be not efficient to build partitionRangeMap in doSharding method, I think it can be used as a static field and built once while initing instance.\n\nGood suggestion, I will optimize this question.", "author": "strongduanmu", "createdAt": "2020-04-27T05:07:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ3OTA4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTUzMzY0MQ==", "url": "https://github.com/apache/shardingsphere/pull/5327#discussion_r415533641", "bodyText": "@SanmuWangZJU Thanks. :)", "author": "tristaZero", "createdAt": "2020-04-27T06:04:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ3OTA4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgyMzUwMQ==", "url": "https://github.com/apache/shardingsphere/pull/5327#discussion_r415823501", "bodyText": "for line 61 and 73:\ndoSharding() method will be called while route value, it may be not efficient to build partitionRangeMap in doSharding method, I think it can be used as a static field and built once while initing instance.\n\n@SanmuWangZJU @tristaZero\nHi, I have tried to use static field to define partitionRangeMap, but I found that it is not suitable. Users may instantiate multiple different range partition rules in the same application instance to correspond to different requirements. Static initialization means same range partition rule. Perhaps the instance field is more suitable.", "author": "strongduanmu", "createdAt": "2020-04-27T13:43:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ3OTA4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjI4NzkyNA==", "url": "https://github.com/apache/shardingsphere/pull/5327#discussion_r416287924", "bodyText": "@strongduanmu Got it. Maybe we need a init() interface function to initialize some local members so as to avoid calculating some local values like partitionRangeMap", "author": "tristaZero", "createdAt": "2020-04-28T02:52:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ3OTA4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTUzODk2NQ==", "url": "https://github.com/apache/shardingsphere/pull/5327#discussion_r415538965", "bodyText": "@Setter and @getter are recommended.", "author": "tristaZero", "createdAt": "2020-04-27T06:17:13Z", "path": "sharding-core/sharding-core-common/src/main/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/RangeShardingAlgorithm.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.shardingsphere.core.strategy.algorithm.sharding;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Range;\n+import com.google.common.primitives.Longs;\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.shardingsphere.api.sharding.standard.PreciseShardingValue;\n+import org.apache.shardingsphere.api.sharding.standard.RangeShardingValue;\n+import org.apache.shardingsphere.api.sharding.standard.StandardShardingAlgorithm;\n+\n+import java.util.Collection;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Properties;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Range sharding algorithm.\n+ * <p>\n+ * Range sharding algorithm is similar to the rule of partition table.\n+ * User can specify the range by setting the `range.partition.split.value` parameter.\n+ * The `range.partition.split.value` parameter is an ordered list of numbers, separated by commas.\n+ * </p>\n+ * <p>\n+ * For example: If the `range.partition.split.value` parameter is set to `1,5,10`,\n+ * the parameter will split all values into four intervals\u2014\u2014(-\u221e, 1), [1,5), [5,10), [10, +\u221e),\n+ * which corresponding to partition_0, partition_1, partition_2, partition_3.\n+ * The sharding values will be divided into different partition by its value.\n+ * </p>\n+ */\n+public final class RangeShardingAlgorithm implements StandardShardingAlgorithm<Long> {\n+\n+    private static final String RANGE_PARTITION_SPLIT_VALUE = \"range.partition.split.value\";\n+\n+    private Properties properties = new Properties();\n+\n+    @Override\n+    public String doSharding(final Collection<String> availableTargetNames, final PreciseShardingValue<Long> shardingValue) {\n+        Preconditions.checkNotNull(properties.get(RANGE_PARTITION_SPLIT_VALUE), \"Range sharding algorithm range partition split value cannot be null.\");\n+        Map<Integer, Range<Long>> partitionRangeMap = getPartitionRangeMap();\n+        for (String each : availableTargetNames) {\n+            if (each.endsWith(getPartition(partitionRangeMap, shardingValue.getValue()))) {\n+                return each;\n+            }\n+        }\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Collection<String> doSharding(final Collection<String> availableTargetNames, final RangeShardingValue<Long> shardingValue) {\n+        Preconditions.checkNotNull(properties.get(RANGE_PARTITION_SPLIT_VALUE), \"Range sharding algorithm range partition split value cannot be null.\");\n+        Map<Integer, Range<Long>> partitionRangeMap = getPartitionRangeMap();\n+        Collection<String> result = new LinkedHashSet<>(availableTargetNames.size());\n+        for (long value = shardingValue.getValueRange().lowerEndpoint(); value <= shardingValue.getValueRange().upperEndpoint(); value++) {\n+            for (String each : availableTargetNames) {\n+                if (each.endsWith(getPartition(partitionRangeMap, value))) {\n+                    result.add(each);\n+                }\n+            }\n+        }\n+        return result;\n+    }\n+\n+    private Map<Integer, Range<Long>> getPartitionRangeMap() {\n+        List<Long> splitValues = Splitter.on(\",\").trimResults().splitToList(properties.get(RANGE_PARTITION_SPLIT_VALUE).toString())\n+                .stream().map(Longs::tryParse).filter(Objects::nonNull).sorted().collect(Collectors.toList());\n+        Preconditions.checkArgument(CollectionUtils.isNotEmpty(splitValues), \"Range sharding algorithm range partition split value is not valid.\");\n+        Map<Integer, Range<Long>> partitionRangeMap = Maps.newHashMapWithExpectedSize(splitValues.size() + 1);\n+        for (int i = 0; i < splitValues.size(); i++) {\n+            Long splitValue = splitValues.get(i);\n+            if (i == 0) {\n+                partitionRangeMap.put(i, Range.lessThan(splitValue));\n+            } else {\n+                Long previousSplitValue = splitValues.get(i - 1);\n+                partitionRangeMap.put(i, Range.closedOpen(previousSplitValue, splitValue));\n+            }\n+            if (i == splitValues.size() - 1) {\n+                partitionRangeMap.put(i + 1, Range.atLeast(splitValue));\n+            }\n+        }\n+        return partitionRangeMap;\n+    }\n+\n+    private String getPartition(final Map<Integer, Range<Long>> partitionRangeMap, final Long value) {\n+        for (Map.Entry<Integer, Range<Long>> entry : partitionRangeMap.entrySet()) {\n+            if (entry.getValue().contains(value)) {\n+                return entry.getKey().toString();\n+            }\n+        }\n+        return partitionRangeMap.keySet().stream().mapToInt(Integer::valueOf).max().toString();\n+    }\n+\n+    @Override\n+    public String getType() {\n+        return \"RANGE\";\n+    }\n+\n+    @Override", "originalCommit": "fa505b2aa55581e505a412951255cf4e876107a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU2NzAxMw==", "url": "https://github.com/apache/shardingsphere/pull/5327#discussion_r415567013", "bodyText": "Thank you, i will modify it.", "author": "strongduanmu", "createdAt": "2020-04-27T07:14:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTUzODk2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU0NzE2Mw==", "url": "https://github.com/apache/shardingsphere/pull/5327#discussion_r415547163", "bodyText": "It is suggested to assert some of the specific targets, not only size().", "author": "tristaZero", "createdAt": "2020-04-27T06:35:09Z", "path": "sharding-core/sharding-core-common/src/test/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/range/RangeShardingAlgorithmTest.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.shardingsphere.core.strategy.algorithm.sharding.range;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Range;\n+import org.apache.shardingsphere.api.config.sharding.strategy.StandardShardingStrategyConfiguration;\n+import org.apache.shardingsphere.core.strategy.algorithm.sharding.RangeShardingAlgorithm;\n+import org.apache.shardingsphere.core.strategy.route.standard.StandardShardingStrategy;\n+import org.apache.shardingsphere.core.strategy.route.value.ListRouteValue;\n+import org.apache.shardingsphere.core.strategy.route.value.RangeRouteValue;\n+import org.apache.shardingsphere.core.strategy.route.value.RouteValue;\n+import org.apache.shardingsphere.underlying.common.config.properties.ConfigurationProperties;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.Assert.assertThat;\n+\n+public final class RangeShardingAlgorithmTest {\n+\n+    private StandardShardingStrategy shardingStrategy;\n+\n+    @Before\n+    public void setUp() {\n+        RangeShardingAlgorithm shardingAlgorithm = new RangeShardingAlgorithm();\n+        shardingAlgorithm.getProperties().setProperty(\"range.partition.split.value\", \"1,5,10\");\n+        StandardShardingStrategyConfiguration shardingStrategyConfig = new StandardShardingStrategyConfiguration(\"order_id\", shardingAlgorithm);\n+        shardingStrategy = new StandardShardingStrategy(shardingStrategyConfig);\n+    }\n+\n+    @Test\n+    public void assertPreciseDoSharding() {\n+        List<String> availableTargetNames = Lists.newArrayList(\"t_order_0\", \"t_order_1\", \"t_order_2\", \"t_order_3\");\n+        List<RouteValue> shardingValues = Lists.newArrayList(new ListRouteValue<>(\"order_id\", \"t_order\", Lists.newArrayList(0L, 1L, 2L, 4L, 7L)));\n+        Collection<String> actual = shardingStrategy.doSharding(availableTargetNames, shardingValues, new ConfigurationProperties(new Properties()));\n+        assertThat(actual.size(), is(3));", "originalCommit": "fa505b2aa55581e505a412951255cf4e876107a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU2NzY0Mg==", "url": "https://github.com/apache/shardingsphere/pull/5327#discussion_r415567642", "bodyText": "I got it, thanks!", "author": "strongduanmu", "createdAt": "2020-04-27T07:15:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU0NzE2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU0NzIyNQ==", "url": "https://github.com/apache/shardingsphere/pull/5327#discussion_r415547225", "bodyText": "It is likely thatvalue++ is time-consuming if there is a vast range.\nHere are some of my ideas.\nFor instance,the shardings are as follows,\n1,2 | 3,4,5 | 6,7,8,9 | 10,11\nSo the range.partition.split.value is 2,5,9,11\nImaging the query condition is 2 =< x <= 9, then we just need to calcute 2==2 and 9<11, therefore the results is 0,1,2.\nThat is, we can get the critical values from range.partition.split.value, so we only need to compare the bottom point and the top point with those critical values.", "author": "tristaZero", "createdAt": "2020-04-27T06:35:18Z", "path": "sharding-core/sharding-core-common/src/main/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/RangeShardingAlgorithm.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.shardingsphere.core.strategy.algorithm.sharding;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Range;\n+import com.google.common.primitives.Longs;\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.shardingsphere.api.sharding.standard.PreciseShardingValue;\n+import org.apache.shardingsphere.api.sharding.standard.RangeShardingValue;\n+import org.apache.shardingsphere.api.sharding.standard.StandardShardingAlgorithm;\n+\n+import java.util.Collection;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Properties;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Range sharding algorithm.\n+ * <p>\n+ * Range sharding algorithm is similar to the rule of partition table.\n+ * User can specify the range by setting the `range.partition.split.value` parameter.\n+ * The `range.partition.split.value` parameter is an ordered list of numbers, separated by commas.\n+ * </p>\n+ * <p>\n+ * For example: If the `range.partition.split.value` parameter is set to `1,5,10`,\n+ * the parameter will split all values into four intervals\u2014\u2014(-\u221e, 1), [1,5), [5,10), [10, +\u221e),\n+ * which corresponding to partition_0, partition_1, partition_2, partition_3.\n+ * The sharding values will be divided into different partition by its value.\n+ * </p>\n+ */\n+public final class RangeShardingAlgorithm implements StandardShardingAlgorithm<Long> {\n+\n+    private static final String RANGE_PARTITION_SPLIT_VALUE = \"range.partition.split.value\";\n+\n+    private Properties properties = new Properties();\n+\n+    @Override\n+    public String doSharding(final Collection<String> availableTargetNames, final PreciseShardingValue<Long> shardingValue) {\n+        Preconditions.checkNotNull(properties.get(RANGE_PARTITION_SPLIT_VALUE), \"Range sharding algorithm range partition split value cannot be null.\");\n+        Map<Integer, Range<Long>> partitionRangeMap = getPartitionRangeMap();\n+        for (String each : availableTargetNames) {\n+            if (each.endsWith(getPartition(partitionRangeMap, shardingValue.getValue()))) {\n+                return each;\n+            }\n+        }\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Collection<String> doSharding(final Collection<String> availableTargetNames, final RangeShardingValue<Long> shardingValue) {\n+        Preconditions.checkNotNull(properties.get(RANGE_PARTITION_SPLIT_VALUE), \"Range sharding algorithm range partition split value cannot be null.\");\n+        Map<Integer, Range<Long>> partitionRangeMap = getPartitionRangeMap();\n+        Collection<String> result = new LinkedHashSet<>(availableTargetNames.size());\n+        for (long value = shardingValue.getValueRange().lowerEndpoint(); value <= shardingValue.getValueRange().upperEndpoint(); value++) {", "originalCommit": "fa505b2aa55581e505a412951255cf4e876107a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU2OTgwNg==", "url": "https://github.com/apache/shardingsphere/pull/5327#discussion_r415569806", "bodyText": "It is likely thatvalue++ is time-consuming if there is a vast range.\nHere are some of my ideas.\nFor instance,the shardings are as follows,\n1,2 | 3,4,5 | 6,7,8,9 | 10,11\nSo the range.partition.split.value is 2,5,9,11\nImaging the query condition is 2 =< x <= 9, then we just need to calcute 2==2 and 9<11, therefore the results is 0,1,2.\nThat is, we can get the critical values from range.partition.split.value, so we only need to compare the bottom point and the top point with those critical values.\n\nThis suggestion is great, and I will optimize it.", "author": "strongduanmu", "createdAt": "2020-04-27T07:19:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU0NzIyNQ=="}], "type": "inlineReview"}, {"oid": "fae31a02fc22b88e8e28cafe5ddea8c5af52d894", "url": "https://github.com/apache/shardingsphere/commit/fae31a02fc22b88e8e28cafe5ddea8c5af52d894", "message": "create RANGE sharding algorithm", "committedDate": "2020-04-27T11:58:18Z", "type": "commit"}, {"oid": "b441c11738e70a05fd60a5a7be73fa32e154332b", "url": "https://github.com/apache/shardingsphere/commit/b441c11738e70a05fd60a5a7be73fa32e154332b", "message": "optimize RANGE sharding algorithm", "committedDate": "2020-04-27T13:57:31Z", "type": "commit"}, {"oid": "b441c11738e70a05fd60a5a7be73fa32e154332b", "url": "https://github.com/apache/shardingsphere/commit/b441c11738e70a05fd60a5a7be73fa32e154332b", "message": "optimize RANGE sharding algorithm", "committedDate": "2020-04-27T13:57:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjI5MDQzMg==", "url": "https://github.com/apache/shardingsphere/pull/5327#discussion_r416290432", "bodyText": "Do you think there is any better names for range.partition.split.value to make users easy get its meaning. Like range.partition.upper.points or range.partition.boundary.points?", "author": "tristaZero", "createdAt": "2020-04-28T03:00:16Z", "path": "sharding-core/sharding-core-common/src/main/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/RangeShardingAlgorithm.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.shardingsphere.core.strategy.algorithm.sharding;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Range;\n+import com.google.common.primitives.Longs;\n+import lombok.Getter;\n+import lombok.Setter;\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.shardingsphere.api.sharding.standard.PreciseShardingValue;\n+import org.apache.shardingsphere.api.sharding.standard.RangeShardingValue;\n+import org.apache.shardingsphere.api.sharding.standard.StandardShardingAlgorithm;\n+\n+import java.util.Collection;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Properties;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Range sharding algorithm.\n+ * <p>\n+ * Range sharding algorithm is similar to the rule of partition table.\n+ * User can specify the range by setting the `range.partition.split.value` parameter.\n+ * The `range.partition.split.value` parameter is an ordered list of numbers, separated by commas.\n+ * </p>\n+ * <p>\n+ * For example: If the `range.partition.split.value` parameter is set to `1,5,10`,\n+ * the parameter will split all values into four intervals\u2014\u2014(-\u221e, 1), [1,5), [5,10), [10, +\u221e),\n+ * which corresponding to partition_0, partition_1, partition_2, partition_3.\n+ * The sharding values will be divided into different partition by its value.\n+ * </p>\n+ */\n+public final class RangeShardingAlgorithm implements StandardShardingAlgorithm<Long> {\n+\n+    private static final String RANGE_PARTITION_SPLIT_VALUE = \"range.partition.split.value\";", "originalCommit": "b441c11738e70a05fd60a5a7be73fa32e154332b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}