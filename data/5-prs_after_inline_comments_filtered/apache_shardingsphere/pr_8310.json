{"pr_number": 8310, "pr_title": "feature: add subquery valid in ShardingInsertStatementValidator and ShardingSelectStatementValidator", "pr_createdAt": "2020-11-24T06:25:52Z", "pr_url": "https://github.com/apache/shardingsphere/pull/8310", "timeline": [{"oid": "549f86848a831506366b7267375bea47efb08faa", "url": "https://github.com/apache/shardingsphere/commit/549f86848a831506366b7267375bea47efb08faa", "message": "feature: add subquery valid in ShardingInsertStatementValidator and ShardingSelectStatementValidator.", "committedDate": "2020-11-24T06:23:12Z", "type": "commit"}, {"oid": "e21b80e545140d481febe70cf6d8b1333fd40519", "url": "https://github.com/apache/shardingsphere/commit/e21b80e545140d481febe70cf6d8b1333fd40519", "message": "style: modify code style.", "committedDate": "2020-11-24T13:22:26Z", "type": "commit"}, {"oid": "52c7f93af57500e864eb42c49527ea6f97257937", "url": "https://github.com/apache/shardingsphere/commit/52c7f93af57500e864eb42c49527ea6f97257937", "message": "fix: bugs in getDMLStatementValidator() method.", "committedDate": "2020-11-24T13:41:09Z", "type": "commit"}, {"oid": "e0d71dee29ebe19dd7b56177e96fcc3d326c4290", "url": "https://github.com/apache/shardingsphere/commit/e0d71dee29ebe19dd7b56177e96fcc3d326c4290", "message": "fix: bugs in preValidate().", "committedDate": "2020-11-25T13:36:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc3NTY5OA==", "url": "https://github.com/apache/shardingsphere/pull/8310#discussion_r530775698", "bodyText": "Please remove this extra blank line. \ud83d\ude09", "author": "strongduanmu", "createdAt": "2020-11-26T05:05:01Z", "path": "shardingsphere-features/shardingsphere-sharding/shardingsphere-sharding-route/src/main/java/org/apache/shardingsphere/sharding/route/engine/validator/dml/impl/ShardingSelectStatementValidator.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.shardingsphere.sharding.route.engine.validator.dml.impl;\n+\n+import org.apache.shardingsphere.infra.binder.statement.SQLStatementContext;\n+import org.apache.shardingsphere.infra.binder.statement.dml.SelectStatementContext;\n+import org.apache.shardingsphere.infra.hint.HintManager;\n+import org.apache.shardingsphere.infra.metadata.schema.ShardingSphereSchema;\n+import org.apache.shardingsphere.infra.route.context.RouteContext;\n+import org.apache.shardingsphere.sharding.api.config.strategy.sharding.HintShardingStrategyConfiguration;\n+import org.apache.shardingsphere.sharding.route.engine.condition.ShardingCondition;\n+import org.apache.shardingsphere.sharding.route.engine.condition.ShardingConditions;\n+import org.apache.shardingsphere.sharding.route.engine.condition.engine.ShardingConditionEngine;\n+import org.apache.shardingsphere.sharding.route.engine.condition.engine.impl.WhereClauseShardingConditionEngine;\n+import org.apache.shardingsphere.sharding.route.engine.condition.value.ListShardingConditionValue;\n+import org.apache.shardingsphere.sharding.route.engine.condition.value.RangeShardingConditionValue;\n+import org.apache.shardingsphere.sharding.route.engine.condition.value.ShardingConditionValue;\n+import org.apache.shardingsphere.sharding.route.engine.validator.dml.ShardingDMLStatementValidator;\n+import org.apache.shardingsphere.sharding.rule.BindingTableRule;\n+import org.apache.shardingsphere.sharding.rule.ShardingRule;\n+import org.apache.shardingsphere.sharding.rule.TableRule;\n+import org.apache.shardingsphere.sql.parser.sql.common.statement.dml.DMLStatement;\n+import org.apache.shardingsphere.sql.parser.sql.common.statement.dml.SelectStatement;\n+import org.apache.shardingsphere.sql.parser.sql.common.util.SafeNumberOperationUtils;\n+\n+import com.google.common.base.Preconditions;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * Sharding select statement validator.\n+ */\n+public final class ShardingSelectStatementValidator extends ShardingDMLStatementValidator<SelectStatement> {\n+    \n+    @Override\n+    public void preValidate(final ShardingRule shardingRule, final SQLStatementContext<SelectStatement> sqlStatementContext, \n+                            final List<Object> parameters, final ShardingSphereSchema schema) {\n+        if (isNeedMergeShardingValues(sqlStatementContext, shardingRule)) {\n+            checkSubqueryShardingValues(shardingRule, sqlStatementContext, parameters, schema);\n+        }\n+    }\n+    \n+    private boolean isNeedMergeShardingValues(final SQLStatementContext<?> sqlStatementContext, final ShardingRule rule) {\n+        boolean selectContainsSubquery = sqlStatementContext instanceof SelectStatementContext && ((SelectStatementContext) sqlStatementContext).isContainsSubquery();\n+        return selectContainsSubquery && !rule.getShardingLogicTableNames(sqlStatementContext.getTablesContext().getTableNames()).isEmpty();\n+    }\n+    \n+    private void checkSubqueryShardingValues(final ShardingRule shardingRule, final SQLStatementContext<SelectStatement> sqlStatementContext,\n+        final List<Object> parameters, final ShardingSphereSchema schema) {\n+        for (String each : sqlStatementContext.getTablesContext().getTableNames()) {\n+            Optional<TableRule> tableRule = shardingRule.findTableRule(each);\n+            if (tableRule.isPresent() && isRoutingByHint(shardingRule, tableRule.get())\n+                && !HintManager.getDatabaseShardingValues(each).isEmpty() && !HintManager.getTableShardingValues(each).isEmpty()) {\n+                return;\n+            }\n+        }\n+        ShardingConditions shardingConditions = createShardingConditions(sqlStatementContext, parameters, schema, shardingRule);\n+        if (shardingConditions.getConditions().size() > 1) {\n+            Preconditions.checkState(isSameShardingCondition(shardingRule, shardingConditions), \"Sharding value must same with subquery.\");\n+        }\n+    }\n+    \n+    private boolean isRoutingByHint(final ShardingRule shardingRule, final TableRule tableRule) {\n+        return shardingRule.getDatabaseShardingStrategyConfiguration(tableRule) instanceof HintShardingStrategyConfiguration\n+            && shardingRule.getTableShardingStrategyConfiguration(tableRule) instanceof HintShardingStrategyConfiguration;\n+    }\n+    \n+    private boolean isSameShardingCondition(final ShardingRule shardingRule, final ShardingConditions shardingConditions) {\n+        ShardingCondition example = shardingConditions.getConditions().remove(shardingConditions.getConditions().size() - 1);\n+        for (ShardingCondition each : shardingConditions.getConditions()) {\n+            if (!isSameShardingCondition(shardingRule, example, each)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    \n+    private boolean isSameShardingCondition(final ShardingRule shardingRule, final ShardingCondition shardingCondition1, final ShardingCondition shardingCondition2) {\n+        if (shardingCondition1.getValues().size() != shardingCondition2.getValues().size()) {\n+            return false;\n+        }\n+        for (int i = 0; i < shardingCondition1.getValues().size(); i++) {\n+            ShardingConditionValue shardingConditionValue1 = shardingCondition1.getValues().get(i);\n+            ShardingConditionValue shardingConditionValue2 = shardingCondition2.getValues().get(i);\n+            if (!isSameShardingConditionValue(shardingRule, shardingConditionValue1, shardingConditionValue2)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    \n+    private boolean isSameShardingConditionValue(final ShardingRule shardingRule, final ShardingConditionValue shardingConditionValue1, final ShardingConditionValue shardingConditionValue2) {\n+        return isSameLogicTable(shardingRule, shardingConditionValue1, shardingConditionValue2) && shardingConditionValue1.getColumnName().equals(shardingConditionValue2.getColumnName());\n+    }\n+    \n+    private boolean isSameLogicTable(final ShardingRule shardingRule, final ShardingConditionValue shardingValue1, final ShardingConditionValue shardingValue2) {\n+        return shardingValue1.getTableName().equals(shardingValue2.getTableName()) || isBindingTable(shardingRule, shardingValue1, shardingValue2);\n+    }\n+    \n+    private boolean isBindingTable(final ShardingRule shardingRule, final ShardingConditionValue shardingValue1, final ShardingConditionValue shardingValue2) {\n+        Optional<BindingTableRule> bindingRule = shardingRule.findBindingTableRule(shardingValue1.getTableName());\n+        return bindingRule.isPresent() && bindingRule.get().hasLogicTable(shardingValue2.getTableName());\n+    }\n+    \n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    private boolean isSameValue(final ShardingConditionValue shardingConditionValue1, final ShardingConditionValue shardingConditionValue2) {\n+        if (shardingConditionValue1 instanceof ListShardingConditionValue && shardingConditionValue2 instanceof ListShardingConditionValue) {\n+            return SafeNumberOperationUtils.safeCollectionEquals(\n+                ((ListShardingConditionValue) shardingConditionValue1).getValues(), ((ListShardingConditionValue) shardingConditionValue2).getValues());\n+        } else if (shardingConditionValue1 instanceof RangeShardingConditionValue && shardingConditionValue2 instanceof RangeShardingConditionValue) {\n+            return SafeNumberOperationUtils.safeRangeEquals(\n+                ((RangeShardingConditionValue) shardingConditionValue1).getValueRange(), ((RangeShardingConditionValue) shardingConditionValue2).getValueRange());\n+        }\n+        return false;\n+    }\n+    \n+    private ShardingConditions createShardingConditions(final SQLStatementContext<SelectStatement> sqlStatementContext,\n+        final List<Object> parameters, final ShardingSphereSchema schema, final ShardingRule rule) {\n+        List<ShardingCondition> shardingConditions;\n+        if (sqlStatementContext.getSqlStatement() instanceof DMLStatement) {\n+            ShardingConditionEngine shardingConditionEngine = new WhereClauseShardingConditionEngine(rule, schema);\n+            shardingConditions = shardingConditionEngine.createShardingConditions(sqlStatementContext, parameters);\n+        } else {\n+            shardingConditions = Collections.emptyList();\n+        }\n+        return new ShardingConditions(shardingConditions);\n+    }\n+    \n+    @Override\n+    public void postValidate(final SelectStatement sqlStatement, final RouteContext routeContext) {\n+    }\n+    ", "originalCommit": "e0d71dee29ebe19dd7b56177e96fcc3d326c4290", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjI5MzE4MQ==", "url": "https://github.com/apache/shardingsphere/pull/8310#discussion_r532293181", "bodyText": "OK", "author": "wgy8283335", "createdAt": "2020-11-30T00:24:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc3NTY5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjA0NTQ4MQ==", "url": "https://github.com/apache/shardingsphere/pull/8310#discussion_r532045481", "bodyText": "The checkSubqueryShardingValues method is duplicated with the method in ShardingSelectStatementValidator class, and it might be better to extract it into ShardingDMLStatementValidator class.", "author": "strongduanmu", "createdAt": "2020-11-28T14:21:32Z", "path": "shardingsphere-features/shardingsphere-sharding/shardingsphere-sharding-route/src/main/java/org/apache/shardingsphere/sharding/route/engine/validator/dml/impl/ShardingInsertStatementValidator.java", "diffHunk": "@@ -84,6 +103,94 @@ private boolean isContainsKeyGenerateColumn(final ShardingRule shardingRule, fin\n     private boolean isAllSameTables(final Collection<String> tableNames) {\n         return 1 == tableNames.stream().distinct().count();\n     }\n+\n+    private void checkSubqueryShardingValues(final ShardingRule shardingRule, final SQLStatementContext<InsertStatement> sqlStatementContext,", "originalCommit": "e0d71dee29ebe19dd7b56177e96fcc3d326c4290", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjI5Njg2Mg==", "url": "https://github.com/apache/shardingsphere/pull/8310#discussion_r532296862", "bodyText": "OK", "author": "wgy8283335", "createdAt": "2020-11-30T00:48:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjA0NTQ4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjA0NjM2MQ==", "url": "https://github.com/apache/shardingsphere/pull/8310#discussion_r532046361", "bodyText": "I think this check is redundant because we've already judged insertSelectSegment.isPresent(), and we can use insertSelectStatement directly to determine whether sub-queries are included. BTW, this method can also be extracted into the ShardingDMLStatementValidator class. What do you think ?", "author": "strongduanmu", "createdAt": "2020-11-28T14:30:44Z", "path": "shardingsphere-features/shardingsphere-sharding/shardingsphere-sharding-route/src/main/java/org/apache/shardingsphere/sharding/route/engine/validator/dml/impl/ShardingInsertStatementValidator.java", "diffHunk": "@@ -84,6 +103,94 @@ private boolean isContainsKeyGenerateColumn(final ShardingRule shardingRule, fin\n     private boolean isAllSameTables(final Collection<String> tableNames) {\n         return 1 == tableNames.stream().distinct().count();\n     }\n+\n+    private void checkSubqueryShardingValues(final ShardingRule shardingRule, final SQLStatementContext<InsertStatement> sqlStatementContext,\n+        final List<Object> parameters, final ShardingSphereSchema schema) {\n+        for (String each : sqlStatementContext.getTablesContext().getTableNames()) {\n+            Optional<TableRule> tableRule = shardingRule.findTableRule(each);\n+            if (tableRule.isPresent() && isRoutingByHint(shardingRule, tableRule.get())\n+                && !HintManager.getDatabaseShardingValues(each).isEmpty() && !HintManager.getTableShardingValues(each).isEmpty()) {\n+                return;\n+            }\n+        }\n+        ShardingConditions shardingConditions = createShardingConditions(sqlStatementContext, parameters, schema, shardingRule);\n+        if (shardingConditions.getConditions().size() > 1) {\n+            Preconditions.checkState(isSameShardingCondition(shardingRule, shardingConditions), \"Sharding value must same with subquery.\");\n+        }\n+    }\n+\n+    private boolean isRoutingByHint(final ShardingRule shardingRule, final TableRule tableRule) {\n+        return shardingRule.getDatabaseShardingStrategyConfiguration(tableRule) instanceof HintShardingStrategyConfiguration\n+            && shardingRule.getTableShardingStrategyConfiguration(tableRule) instanceof HintShardingStrategyConfiguration;\n+    }\n+\n+    private boolean isSameShardingCondition(final ShardingRule shardingRule, final ShardingConditions shardingConditions) {\n+        ShardingCondition example = shardingConditions.getConditions().remove(shardingConditions.getConditions().size() - 1);\n+        for (ShardingCondition each : shardingConditions.getConditions()) {\n+            if (!isSameShardingCondition(shardingRule, example, each)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean isSameShardingCondition(final ShardingRule shardingRule, final ShardingCondition shardingCondition1, final ShardingCondition shardingCondition2) {\n+        if (shardingCondition1.getValues().size() != shardingCondition2.getValues().size()) {\n+            return false;\n+        }\n+        for (int i = 0; i < shardingCondition1.getValues().size(); i++) {\n+            ShardingConditionValue shardingConditionValue1 = shardingCondition1.getValues().get(i);\n+            ShardingConditionValue shardingConditionValue2 = shardingCondition2.getValues().get(i);\n+            if (!isSameShardingConditionValue(shardingRule, shardingConditionValue1, shardingConditionValue2)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean isSameShardingConditionValue(final ShardingRule shardingRule, final ShardingConditionValue shardingConditionValue1, final ShardingConditionValue shardingConditionValue2) {\n+        return isSameLogicTable(shardingRule, shardingConditionValue1, shardingConditionValue2) && shardingConditionValue1.getColumnName().equals(shardingConditionValue2.getColumnName())\n+            && isSameValue(shardingConditionValue1, shardingConditionValue2);\n+    }\n+\n+    private boolean isSameLogicTable(final ShardingRule shardingRule, final ShardingConditionValue shardingValue1, final ShardingConditionValue shardingValue2) {\n+        return shardingValue1.getTableName().equals(shardingValue2.getTableName()) || isBindingTable(shardingRule, shardingValue1, shardingValue2);\n+    }\n+\n+    private boolean isBindingTable(final ShardingRule shardingRule, final ShardingConditionValue shardingValue1, final ShardingConditionValue shardingValue2) {\n+        Optional<BindingTableRule> bindingRule = shardingRule.findBindingTableRule(shardingValue1.getTableName());\n+        return bindingRule.isPresent() && bindingRule.get().hasLogicTable(shardingValue2.getTableName());\n+    }\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    private boolean isSameValue(final ShardingConditionValue shardingConditionValue1, final ShardingConditionValue shardingConditionValue2) {\n+        if (shardingConditionValue1 instanceof ListShardingConditionValue && shardingConditionValue2 instanceof ListShardingConditionValue) {\n+            return SafeNumberOperationUtils.safeCollectionEquals(\n+                ((ListShardingConditionValue) shardingConditionValue1).getValues(), ((ListShardingConditionValue) shardingConditionValue2).getValues());\n+        } else if (shardingConditionValue1 instanceof RangeShardingConditionValue && shardingConditionValue2 instanceof RangeShardingConditionValue) {\n+            return SafeNumberOperationUtils.safeRangeEquals(\n+                ((RangeShardingConditionValue) shardingConditionValue1).getValueRange(), ((RangeShardingConditionValue) shardingConditionValue2).getValueRange());\n+        }\n+        return false;\n+    }\n+\n+    private ShardingConditions createShardingConditions(final SQLStatementContext<InsertStatement> sqlStatementContext,\n+        final List<Object> parameters, final ShardingSphereSchema schema, final ShardingRule rule) {\n+        List<ShardingCondition> shardingConditions;\n+        if (sqlStatementContext.getSqlStatement() instanceof DMLStatement) {\n+            ShardingConditionEngine shardingConditionEngine = new WhereClauseShardingConditionEngine(rule, schema);\n+            shardingConditions = shardingConditionEngine.createShardingConditions(sqlStatementContext, parameters);\n+        } else {\n+            shardingConditions = Collections.emptyList();\n+        }\n+        return new ShardingConditions(shardingConditions);\n+    }\n+\n+    private boolean isNeedMergeShardingValues(final SQLStatementContext<?> sqlStatementContext, final ShardingRule rule) {\n+        boolean insertSelectContainsSubquery = sqlStatementContext instanceof InsertStatementContext && null != ((InsertStatementContext) sqlStatementContext).getInsertSelectContext()\n+            && ((InsertStatementContext) sqlStatementContext).getInsertSelectContext().getSelectStatementContext().isContainsSubquery();", "originalCommit": "e0d71dee29ebe19dd7b56177e96fcc3d326c4290", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjI5NzUzMA==", "url": "https://github.com/apache/shardingsphere/pull/8310#discussion_r532297530", "bodyText": "I think to move this method to the ShardingDMLStatementValidator is better.", "author": "wgy8283335", "createdAt": "2020-11-30T00:52:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjA0NjM2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjA0NzA3MQ==", "url": "https://github.com/apache/shardingsphere/pull/8310#discussion_r532047071", "bodyText": "Have you forgotten to remove the checkSubqueryShardingValues method from the ShardingSQLRouter class? \ud83d\ude09", "author": "strongduanmu", "createdAt": "2020-11-28T14:38:26Z", "path": "shardingsphere-features/shardingsphere-sharding/shardingsphere-sharding-route/src/main/java/org/apache/shardingsphere/sharding/route/engine/validator/dml/impl/ShardingInsertStatementValidator.java", "diffHunk": "@@ -62,6 +78,9 @@ public void preValidate(final ShardingRule shardingRule, final SQLStatementConte\n         if (insertSelectSegment.isPresent() && !isAllSameTables(tablesContext.getTableNames()) && !shardingRule.isAllBindingTables(tablesContext.getTableNames())) {\n             throw new ShardingSphereException(\"The table inserted and the table selected must be the same or bind tables.\");\n         }\n+        if (insertSelectSegment.isPresent() && isNeedMergeShardingValues(sqlStatementContext, shardingRule)) {\n+            checkSubqueryShardingValues(shardingRule, sqlStatementContext, parameters, schema);", "originalCommit": "e0d71dee29ebe19dd7b56177e96fcc3d326c4290", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjI5Njg3Ng==", "url": "https://github.com/apache/shardingsphere/pull/8310#discussion_r532296876", "bodyText": "OK", "author": "wgy8283335", "createdAt": "2020-11-30T00:48:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjA0NzA3MQ=="}], "type": "inlineReview"}, {"oid": "9e7ad85275226ba914bf206de397dffe33c96d2a", "url": "https://github.com/apache/shardingsphere/commit/9e7ad85275226ba914bf206de397dffe33c96d2a", "message": "refacor: prevalidate() method.", "committedDate": "2020-11-30T01:05:37Z", "type": "commit"}]}