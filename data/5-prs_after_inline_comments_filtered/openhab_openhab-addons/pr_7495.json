{"pr_number": 7495, "pr_title": "[homekit] upgrade to latest HAP library. add optional attributes.", "pr_createdAt": "2020-04-28T10:18:09Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/7495", "timeline": [{"oid": "6d71b4def9c901c4d4471fab83edd11a47049fd5", "url": "https://github.com/openhab/openhab-addons/commit/6d71b4def9c901c4d4471fab83edd11a47049fd5", "message": "Merge pull request #1 from openhab/2.5.x\n\nmerge to latest master", "committedDate": "2020-04-25T23:11:39Z", "type": "commit"}, {"oid": "e485e21142ce3990a7e9bce04154654146d772a3", "url": "https://github.com/openhab/openhab-addons/commit/e485e21142ce3990a7e9bce04154654146d772a3", "message": "WIP upgrade to latest HAP library. major refactoring to add support for optional homekit characteristics\n\nSigned-off-by: Eugen Freiter <freiter@gmx.de>", "committedDate": "2020-04-28T11:16:37Z", "type": "forcePushed"}, {"oid": "b4c1bba476ec0a464676397686f83d94a3f0fda7", "url": "https://github.com/openhab/openhab-addons/commit/b4c1bba476ec0a464676397686f83d94a3f0fda7", "message": "WIP upgrade to latest HAP library. major refactoring to add support for optional homekit characteristics\nSigned-off-by: Eugen Freiter <freiter@gmx.de>", "committedDate": "2020-04-28T11:19:25Z", "type": "forcePushed"}, {"oid": "1af473d4b61d76c463f1dcbbba27c17734809932", "url": "https://github.com/openhab/openhab-addons/commit/1af473d4b61d76c463f1dcbbba27c17734809932", "message": "Merge branch '2.5.x' of https://github.com/yfre/openhab-addons into 2.5.x", "committedDate": "2020-04-28T11:27:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjczMTQ0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r416731447", "bodyText": "Why not use an Optional here?", "author": "J-N-K", "createdAt": "2020-04-28T15:57:33Z", "path": "bundles/org.openhab.io.homekit/src/main/java/org/openhab/io/homekit/internal/HomekitAccessoryType.java", "diffHunk": "@@ -75,22 +81,29 @@ public static HomekitAccessoryType valueOfTag(String tag) {\n         return TAG_MAP.get(tag);\n     }\n \n+    /**\n+     * get accessoryType for a given Item\n+     *\n+     * @param tags the item\n+     * @return accessoryType or null if not found\n+     */\n+    public static HomekitAccessoryType fromTags(ArrayList<String> tags) {", "originalCommit": "b4c1bba476ec0a464676397686f83d94a3f0fda7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ2ODQxMw==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r418468413", "bodyText": "good idea. done. switched to Optional", "author": "yfre", "createdAt": "2020-05-01T08:56:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjczMTQ0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjczNDAyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r416734029", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        getItemOptional(name).ifPresent(i -> createRootAccessories(i));\n          \n          \n            \n                        getItemOptional(name).ifPresent(this::createRootAccessories);", "author": "J-N-K", "createdAt": "2020-04-28T16:00:56Z", "path": "bundles/org.openhab.io.homekit/src/main/java/org/openhab/io/homekit/internal/HomekitChangeListener.java", "diffHunk": "@@ -122,10 +127,7 @@ private synchronized void applyUpdates() {\n         while (iter.hasNext()) {\n             String name = iter.next();\n             accessoryRegistry.remove(name);\n-\n-            getItemOptional(name).map(i -> new HomekitTaggedItem(i, itemRegistry))\n-                    .filter(i -> i.isAccessory() && !i.isMemberOfAccessoryGroup())\n-                    .ifPresent(rootItem -> createRootAccessory(rootItem));\n+            getItemOptional(name).ifPresent(i -> createRootAccessories(i));", "originalCommit": "b4c1bba476ec0a464676397686f83d94a3f0fda7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjczNzYyOA==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r416737628", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return tags.stream().map(tag -> TAG_MAP.get(tag)).filter(Objects::nonNull).findFirst().orElse(null);\n          \n          \n            \n                    return tags.stream().map(TAG_MAP::get).filter(Objects::nonNull).findFirst().orElse(null);\n          \n      \n    \n    \n  \n\nWhy not use an Optional here?", "author": "J-N-K", "createdAt": "2020-04-28T16:05:52Z", "path": "bundles/org.openhab.io.homekit/src/main/java/org/openhab/io/homekit/internal/HomekitCharacteristicType.java", "diffHunk": "@@ -66,13 +133,14 @@ public static HomekitCharacteristicType valueOfTag(String tag) {\n         return TAG_MAP.get(tag);\n     }\n \n+\n     /**\n      * get characteristicType for a given Item\n      *\n-     * @param item the item\n+     * @param tags array list of tags\n      * @return characteristicType or null if not found\n      */\n-    public static HomekitCharacteristicType fromItem(Item item) {\n-        return item.getTags().stream().map(tag -> TAG_MAP.get(tag)).filter(Objects::nonNull).findFirst().orElse(null);\n+    public static HomekitCharacteristicType fromTags(ArrayList<String> tags) {\n+        return tags.stream().map(tag -> TAG_MAP.get(tag)).filter(Objects::nonNull).findFirst().orElse(null);", "originalCommit": "b4c1bba476ec0a464676397686f83d94a3f0fda7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ2ODgyNg==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r418468826", "bodyText": "one method was not used - i removed it.\nanother one - valueOfTag - switched to Optional", "author": "yfre", "createdAt": "2020-05-01T08:57:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjczNzYyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc0OTU4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r416749586", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return new HoldPositionCharacteristic( (hold) -> item.setState(hold?OnOffType.ON:OnOffType.OFF));\n          \n          \n            \n                    return new HoldPositionCharacteristic(OnOffType::from);", "author": "J-N-K", "createdAt": "2020-04-28T16:22:26Z", "path": "bundles/org.openhab.io.homekit/src/main/java/org/openhab/io/homekit/internal/accessories/HomekitCharacteristicFactory.java", "diffHunk": "@@ -0,0 +1,452 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.io.homekit.internal.accessories;\n+\n+import static org.openhab.io.homekit.internal.HomekitCharacteristicType.*;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.BiFunction;\n+import org.eclipse.smarthome.core.items.GenericItem;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.io.homekit.internal.HomekitAccessoryUpdater;\n+import org.openhab.io.homekit.internal.HomekitCharacteristicType;\n+import org.openhab.io.homekit.internal.HomekitException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import io.github.hapjava.characteristics.Characteristic;\n+import io.github.hapjava.characteristics.CharacteristicEnum;\n+import io.github.hapjava.characteristics.impl.battery.StatusLowBatteryCharacteristic;\n+import io.github.hapjava.characteristics.impl.battery.StatusLowBatteryEnum;\n+import io.github.hapjava.characteristics.impl.carbondioxidesensor.CarbonDioxideLevelCharacteristic;\n+import io.github.hapjava.characteristics.impl.carbondioxidesensor.CarbonDioxidePeakLevelCharacteristic;\n+import io.github.hapjava.characteristics.impl.carbonmonoxidesensor.CarbonMonoxideLevelCharacteristic;\n+import io.github.hapjava.characteristics.impl.carbonmonoxidesensor.CarbonMonoxidePeakLevelCharacteristic;\n+import io.github.hapjava.characteristics.impl.common.NameCharacteristic;\n+import io.github.hapjava.characteristics.impl.common.ObstructionDetectedCharacteristic;\n+import io.github.hapjava.characteristics.impl.common.StatusActiveCharacteristic;\n+import io.github.hapjava.characteristics.impl.common.StatusFaultCharacteristic;\n+import io.github.hapjava.characteristics.impl.common.StatusFaultEnum;\n+import io.github.hapjava.characteristics.impl.common.StatusTamperedCharacteristic;\n+import io.github.hapjava.characteristics.impl.common.StatusTamperedEnum;\n+import io.github.hapjava.characteristics.impl.fan.CurrentFanStateCharacteristic;\n+import io.github.hapjava.characteristics.impl.fan.CurrentFanStateEnum;\n+import io.github.hapjava.characteristics.impl.fan.LockPhysicalControlsCharacteristic;\n+import io.github.hapjava.characteristics.impl.fan.LockPhysicalControlsEnum;\n+import io.github.hapjava.characteristics.impl.fan.RotationDirectionCharacteristic;\n+import io.github.hapjava.characteristics.impl.fan.RotationDirectionEnum;\n+import io.github.hapjava.characteristics.impl.fan.RotationSpeedCharacteristic;\n+import io.github.hapjava.characteristics.impl.fan.SwingModeCharacteristic;\n+import io.github.hapjava.characteristics.impl.fan.SwingModeEnum;\n+import io.github.hapjava.characteristics.impl.fan.TargetFanStateCharacteristic;\n+import io.github.hapjava.characteristics.impl.fan.TargetFanStateEnum;\n+import io.github.hapjava.characteristics.impl.lightbulb.BrightnessCharacteristic;\n+import io.github.hapjava.characteristics.impl.lightbulb.ColorTemperatureCharacteristic;\n+import io.github.hapjava.characteristics.impl.lightbulb.HueCharacteristic;\n+import io.github.hapjava.characteristics.impl.lightbulb.SaturationCharacteristic;\n+import io.github.hapjava.characteristics.impl.valve.RemainingDurationCharacteristic;\n+import io.github.hapjava.characteristics.impl.valve.SetDurationCharacteristic;\n+import io.github.hapjava.characteristics.impl.windowcovering.CurrentHorizontalTiltAngleCharacteristic;\n+import io.github.hapjava.characteristics.impl.windowcovering.CurrentVerticalTiltAngleCharacteristic;\n+import io.github.hapjava.characteristics.impl.windowcovering.HoldPositionCharacteristic;\n+import io.github.hapjava.characteristics.impl.windowcovering.TargetHorizontalTiltAngleCharacteristic;\n+import io.github.hapjava.characteristics.impl.windowcovering.TargetVerticalTiltAngleCharacteristic;\n+\n+/**\n+ * Creates a optional characteristics .\n+ *\n+ * @author Eugen Freiter - Initial contribution\n+ */\n+public class HomekitCharacteristicFactory {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(HomekitCharacteristicFactory.class);\n+\n+    // List of optional characteristics and corresponding method to create them.\n+    private final static Map<HomekitCharacteristicType, BiFunction<GenericItem, HomekitAccessoryUpdater,Characteristic>> optional =\n+        new HashMap<HomekitCharacteristicType, BiFunction<GenericItem, HomekitAccessoryUpdater,Characteristic>> (){{\n+          put(NAME, HomekitCharacteristicFactory::createNameCharacteristic);\n+          put(BATTERY_LOW_STATUS, HomekitCharacteristicFactory::createStatusLowBatteryCharacteristic);\n+          put(FAULT_STATUS, HomekitCharacteristicFactory::createStatusFaultCharacteristic);\n+          put(TAMPERED_STATUS, HomekitCharacteristicFactory::createStatusTamperedCharacteristic);\n+          put(ACTIVE_STATUS, HomekitCharacteristicFactory::createStatusActiveCharacteristic);\n+          put(CARBON_MONOXIDE_LEVEL, HomekitCharacteristicFactory::createCarbonMonoxideLevelCharacteristic);\n+          put(CARBON_MONOXIDE_PEAK_LEVEL, HomekitCharacteristicFactory::createCarbonMonoxidePeakLevelCharacteristic);\n+          put(CARBON_DIOXIDE_LEVEL, HomekitCharacteristicFactory::createCarbonDioxideLevelCharacteristic);\n+          put(CARBON_DIOXIDE_PEAK_LEVEL, HomekitCharacteristicFactory::createCarbonDioxidePeakLevelCharacteristic);\n+          put(HOLD_POSITION, HomekitCharacteristicFactory::createHoldPositionCharacteristic);\n+          put(OBSTRUCTION_STATUS, HomekitCharacteristicFactory::createObstructionDetectedCharacteristic);\n+          put(CURRENT_HORIZONTAL_TILT_ANGLE, HomekitCharacteristicFactory::createCurrentHorizontalTiltAngleCharacteristic);\n+          put(CURRENT_VERTICAL_TILT_ANGLE, HomekitCharacteristicFactory::createCurrentVerticalTiltAngleCharacteristic);\n+          put(TARGET_HORIZONTAL_TILT_ANGLE, HomekitCharacteristicFactory::createTargetHorizontalTiltAngleCharacteristic);\n+          put(TARGET_VERTICAL_TILT_ANGLE, HomekitCharacteristicFactory::createTargetVerticalTiltAngleCharacteristic);\n+          put(HUE, HomekitCharacteristicFactory::createHueCharacteristic);\n+          put(BRIGHTNESS, HomekitCharacteristicFactory::createBrightnessCharacteristic);\n+          put(SATURATION, HomekitCharacteristicFactory::createSaturationCharacteristic);\n+          put(COLOR_TEMPERATURE, HomekitCharacteristicFactory::createColorTemperatureCharacteristic);\n+          put(CURRENT_FAN_STATE, HomekitCharacteristicFactory::createCurrentFanStateCharacteristic);\n+          put(TARGET_FAN_STATE, HomekitCharacteristicFactory::createTargetFanStateCharacteristic);\n+          put(ROTATION_DIRECTION, HomekitCharacteristicFactory::createRotationDirectionCharacteristic);\n+          put(ROTATION_SPEED, HomekitCharacteristicFactory::createRotationSpeedCharacteristic);\n+          put(SWING_MODE, HomekitCharacteristicFactory::createSwingModeCharacteristic);\n+          put(LOCK_CONTROL, HomekitCharacteristicFactory::createLockPhysicalControlsCharacteristic);\n+          put(DURATION, HomekitCharacteristicFactory::createDurationCharacteristic);\n+          put(REMAINING_DURATION, HomekitCharacteristicFactory::createRemainingDurationCharacteristic);\n+          // LEGACY\n+          put(OLD_BATTERY_LOW_STATUS, HomekitCharacteristicFactory::createStatusLowBatteryCharacteristic);\n+        }};\n+\n+  /**\n+   * create optional HomeKit characteristic\n+   * @param type type of characteristic\n+   * @param item corresponding OH item\n+   * @param updater update to keep OH item and HomeKit characteristic in sync\n+   * @return HomeKit characteristic\n+   */\n+    public static Characteristic createCharacteristic(HomekitCharacteristicType type, GenericItem item, HomekitAccessoryUpdater updater)\n+        throws HomekitException {\n+      LOGGER.debug(\"createCharacteristic, type {} item {}\",type, item);\n+        if (type!=null) {\n+            if (optional.containsKey(type)) {\n+                return optional.get(type).apply(item, updater);\n+            }\n+        }\n+        LOGGER.error(\"Unsupported optional characteristic. Item type {}, characteristic type {}\", item.getType(), type);\n+        throw new HomekitException(\"Unsupported optional characteristic. Characteristic type \\\"\" + item.getType());\n+    }\n+\n+    // METHODS TO CREATE SINGLE CHARACTERISTIC FROM OH ITEM\n+\n+\n+    private static <T extends CharacteristicEnum> CompletableFuture<T> getEnumFromOnOffAndNumber(GenericItem item, T  offEnum, T onEnum, T defaultEnum) {\n+        final State state = item.getState();\n+        if (state instanceof OnOffType)\n+            return CompletableFuture.completedFuture(state.equals(OnOffType.OFF) ? offEnum : onEnum);\n+        if (state instanceof OpenClosedType)\n+            return CompletableFuture.completedFuture(state.equals(OpenClosedType.CLOSED) ? offEnum : onEnum);\n+        if (state instanceof DecimalType)\n+            return  CompletableFuture.completedFuture(item.getStateAs(DecimalType.class).intValue()==0?offEnum:onEnum);\n+      if (state instanceof UnDefType)\n+        return CompletableFuture.completedFuture(defaultEnum);\n+      LOGGER.error(\"Item state {} is not supported. Only OnOffType,OpenClosedType and Decimal (0/1) are supported. Ignore item {}\", state.getClass(), item.getName());\n+      return CompletableFuture.completedFuture(defaultEnum);\n+    }\n+\n+    private static void setStateFromEnum(GenericItem item, CharacteristicEnum value, CharacteristicEnum offEnum, CharacteristicEnum onEnum) {\n+        final State state = item.getState();\n+        if (state instanceof OnOffType) {\n+            if (value.equals(offEnum))\n+                item.setState(OnOffType.OFF);\n+            else if (value.equals(onEnum)) {\n+                item.setState(OnOffType.ON);\n+            } else\n+                LOGGER.error(\"Enum value {} is not supported. Only following values are supported: {},{}\", value, offEnum, onEnum);\n+        } else\n+            if (item.getState() instanceof DecimalType) {\n+                item.setState(new DecimalType(value.getCode()));\n+            } else\n+                LOGGER.error(\"Item state {} is not supported. Only OnOffType and DecimalType (0/1) are supported.\", item.getState());\n+    }\n+\n+    private static StatusLowBatteryCharacteristic createStatusLowBatteryCharacteristic(final GenericItem item, HomekitAccessoryUpdater updater) {\n+        return new StatusLowBatteryCharacteristic(\n+            () -> getEnumFromOnOffAndNumber(item, StatusLowBatteryEnum.NORMAL, StatusLowBatteryEnum.LOW, StatusLowBatteryEnum.NORMAL),\n+            (callback) -> updater.subscribe(item, BATTERY_LOW_STATUS.getTag(), callback),\n+            ()->  updater.unsubscribe(item, BATTERY_LOW_STATUS.getTag()));\n+    }\n+\n+    private static StatusFaultCharacteristic createStatusFaultCharacteristic(final GenericItem item, HomekitAccessoryUpdater updater) {\n+        return new StatusFaultCharacteristic(\n+            () -> getEnumFromOnOffAndNumber(item, StatusFaultEnum.NO_FAULT,StatusFaultEnum.GENERAL_FAULT, StatusFaultEnum.NO_FAULT),\n+            (callback) -> updater.subscribe(item, FAULT_STATUS.getTag(), callback),\n+            ()->  updater.unsubscribe(item, FAULT_STATUS.getTag()));\n+    }\n+\n+    private static StatusTamperedCharacteristic createStatusTamperedCharacteristic(final GenericItem item, HomekitAccessoryUpdater updater) {\n+        return new StatusTamperedCharacteristic(\n+            () -> getEnumFromOnOffAndNumber(item,StatusTamperedEnum.NOT_TAMPERED, StatusTamperedEnum.TAMPERED, StatusTamperedEnum.NOT_TAMPERED),\n+            (callback) -> updater.subscribe(item,TAMPERED_STATUS.getTag(), callback),\n+            ()->  updater.unsubscribe(item, TAMPERED_STATUS.getTag()));\n+    }\n+    private static ObstructionDetectedCharacteristic createObstructionDetectedCharacteristic(final GenericItem item, HomekitAccessoryUpdater updater) {\n+        return new ObstructionDetectedCharacteristic(\n+            () -> CompletableFuture.completedFuture(\n+                ((item !=null) &&\n+                 (\n+                     item.getState().equals(OnOffType.ON) ||\n+                     item.getState().equals(OpenClosedType.OPEN)\n+                 )\n+                )),\n+            (callback) -> updater.subscribe(item, OBSTRUCTION_STATUS.getTag(), callback),\n+            ()->  updater.unsubscribe(item, OBSTRUCTION_STATUS.getTag()));\n+    }\n+\n+    private static StatusActiveCharacteristic createStatusActiveCharacteristic(final GenericItem item, HomekitAccessoryUpdater updater) {\n+        return new StatusActiveCharacteristic(\n+            () -> CompletableFuture.completedFuture(\n+                (item !=null) &&\n+                 (\n+                     item.getState().equals(OnOffType.ON) ||\n+                     item.getState().equals(OpenClosedType.OPEN)\n+                 )\n+                                                   ),\n+            (callback) -> updater.subscribe(item, ACTIVE_STATUS.getTag(), callback),\n+            ()->  updater.unsubscribe(item, ACTIVE_STATUS.getTag()));\n+    }\n+\n+    private static NameCharacteristic createNameCharacteristic(final GenericItem item, HomekitAccessoryUpdater updater) {\n+        return new NameCharacteristic(\n+            () -> CompletableFuture.completedFuture(item.getState().toString()));\n+    }\n+    private static HoldPositionCharacteristic createHoldPositionCharacteristic(final GenericItem item, HomekitAccessoryUpdater updater) {\n+        return new HoldPositionCharacteristic( (hold) -> item.setState(hold?OnOffType.ON:OnOffType.OFF));", "originalCommit": "b4c1bba476ec0a464676397686f83d94a3f0fda7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc3NjM4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r416776386", "bodyText": "Since you do that alot, wouldn't it make sense to have a method for that (double in a similar way)?\nprivate static CompletableFuture<int> getCompletedFutureInt(GenericItem item) {\n  return CompletableFuture.completedFuture(item !=null ? item.getStateAs(DecimalType.class).intValue() : 0);\n}\n\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        () -> CompletableFuture.completedFuture((item !=null) ? item.getStateAs(DecimalType.class).intValue() : 0),\n          \n          \n            \n                        HomekitCharacteristicFactory::getCompletedFutureInt,", "author": "J-N-K", "createdAt": "2020-04-28T17:01:20Z", "path": "bundles/org.openhab.io.homekit/src/main/java/org/openhab/io/homekit/internal/accessories/HomekitCharacteristicFactory.java", "diffHunk": "@@ -0,0 +1,452 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.io.homekit.internal.accessories;\n+\n+import static org.openhab.io.homekit.internal.HomekitCharacteristicType.*;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.BiFunction;\n+import org.eclipse.smarthome.core.items.GenericItem;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.io.homekit.internal.HomekitAccessoryUpdater;\n+import org.openhab.io.homekit.internal.HomekitCharacteristicType;\n+import org.openhab.io.homekit.internal.HomekitException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import io.github.hapjava.characteristics.Characteristic;\n+import io.github.hapjava.characteristics.CharacteristicEnum;\n+import io.github.hapjava.characteristics.impl.battery.StatusLowBatteryCharacteristic;\n+import io.github.hapjava.characteristics.impl.battery.StatusLowBatteryEnum;\n+import io.github.hapjava.characteristics.impl.carbondioxidesensor.CarbonDioxideLevelCharacteristic;\n+import io.github.hapjava.characteristics.impl.carbondioxidesensor.CarbonDioxidePeakLevelCharacteristic;\n+import io.github.hapjava.characteristics.impl.carbonmonoxidesensor.CarbonMonoxideLevelCharacteristic;\n+import io.github.hapjava.characteristics.impl.carbonmonoxidesensor.CarbonMonoxidePeakLevelCharacteristic;\n+import io.github.hapjava.characteristics.impl.common.NameCharacteristic;\n+import io.github.hapjava.characteristics.impl.common.ObstructionDetectedCharacteristic;\n+import io.github.hapjava.characteristics.impl.common.StatusActiveCharacteristic;\n+import io.github.hapjava.characteristics.impl.common.StatusFaultCharacteristic;\n+import io.github.hapjava.characteristics.impl.common.StatusFaultEnum;\n+import io.github.hapjava.characteristics.impl.common.StatusTamperedCharacteristic;\n+import io.github.hapjava.characteristics.impl.common.StatusTamperedEnum;\n+import io.github.hapjava.characteristics.impl.fan.CurrentFanStateCharacteristic;\n+import io.github.hapjava.characteristics.impl.fan.CurrentFanStateEnum;\n+import io.github.hapjava.characteristics.impl.fan.LockPhysicalControlsCharacteristic;\n+import io.github.hapjava.characteristics.impl.fan.LockPhysicalControlsEnum;\n+import io.github.hapjava.characteristics.impl.fan.RotationDirectionCharacteristic;\n+import io.github.hapjava.characteristics.impl.fan.RotationDirectionEnum;\n+import io.github.hapjava.characteristics.impl.fan.RotationSpeedCharacteristic;\n+import io.github.hapjava.characteristics.impl.fan.SwingModeCharacteristic;\n+import io.github.hapjava.characteristics.impl.fan.SwingModeEnum;\n+import io.github.hapjava.characteristics.impl.fan.TargetFanStateCharacteristic;\n+import io.github.hapjava.characteristics.impl.fan.TargetFanStateEnum;\n+import io.github.hapjava.characteristics.impl.lightbulb.BrightnessCharacteristic;\n+import io.github.hapjava.characteristics.impl.lightbulb.ColorTemperatureCharacteristic;\n+import io.github.hapjava.characteristics.impl.lightbulb.HueCharacteristic;\n+import io.github.hapjava.characteristics.impl.lightbulb.SaturationCharacteristic;\n+import io.github.hapjava.characteristics.impl.valve.RemainingDurationCharacteristic;\n+import io.github.hapjava.characteristics.impl.valve.SetDurationCharacteristic;\n+import io.github.hapjava.characteristics.impl.windowcovering.CurrentHorizontalTiltAngleCharacteristic;\n+import io.github.hapjava.characteristics.impl.windowcovering.CurrentVerticalTiltAngleCharacteristic;\n+import io.github.hapjava.characteristics.impl.windowcovering.HoldPositionCharacteristic;\n+import io.github.hapjava.characteristics.impl.windowcovering.TargetHorizontalTiltAngleCharacteristic;\n+import io.github.hapjava.characteristics.impl.windowcovering.TargetVerticalTiltAngleCharacteristic;\n+\n+/**\n+ * Creates a optional characteristics .\n+ *\n+ * @author Eugen Freiter - Initial contribution\n+ */\n+public class HomekitCharacteristicFactory {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(HomekitCharacteristicFactory.class);\n+\n+    // List of optional characteristics and corresponding method to create them.\n+    private final static Map<HomekitCharacteristicType, BiFunction<GenericItem, HomekitAccessoryUpdater,Characteristic>> optional =\n+        new HashMap<HomekitCharacteristicType, BiFunction<GenericItem, HomekitAccessoryUpdater,Characteristic>> (){{\n+          put(NAME, HomekitCharacteristicFactory::createNameCharacteristic);\n+          put(BATTERY_LOW_STATUS, HomekitCharacteristicFactory::createStatusLowBatteryCharacteristic);\n+          put(FAULT_STATUS, HomekitCharacteristicFactory::createStatusFaultCharacteristic);\n+          put(TAMPERED_STATUS, HomekitCharacteristicFactory::createStatusTamperedCharacteristic);\n+          put(ACTIVE_STATUS, HomekitCharacteristicFactory::createStatusActiveCharacteristic);\n+          put(CARBON_MONOXIDE_LEVEL, HomekitCharacteristicFactory::createCarbonMonoxideLevelCharacteristic);\n+          put(CARBON_MONOXIDE_PEAK_LEVEL, HomekitCharacteristicFactory::createCarbonMonoxidePeakLevelCharacteristic);\n+          put(CARBON_DIOXIDE_LEVEL, HomekitCharacteristicFactory::createCarbonDioxideLevelCharacteristic);\n+          put(CARBON_DIOXIDE_PEAK_LEVEL, HomekitCharacteristicFactory::createCarbonDioxidePeakLevelCharacteristic);\n+          put(HOLD_POSITION, HomekitCharacteristicFactory::createHoldPositionCharacteristic);\n+          put(OBSTRUCTION_STATUS, HomekitCharacteristicFactory::createObstructionDetectedCharacteristic);\n+          put(CURRENT_HORIZONTAL_TILT_ANGLE, HomekitCharacteristicFactory::createCurrentHorizontalTiltAngleCharacteristic);\n+          put(CURRENT_VERTICAL_TILT_ANGLE, HomekitCharacteristicFactory::createCurrentVerticalTiltAngleCharacteristic);\n+          put(TARGET_HORIZONTAL_TILT_ANGLE, HomekitCharacteristicFactory::createTargetHorizontalTiltAngleCharacteristic);\n+          put(TARGET_VERTICAL_TILT_ANGLE, HomekitCharacteristicFactory::createTargetVerticalTiltAngleCharacteristic);\n+          put(HUE, HomekitCharacteristicFactory::createHueCharacteristic);\n+          put(BRIGHTNESS, HomekitCharacteristicFactory::createBrightnessCharacteristic);\n+          put(SATURATION, HomekitCharacteristicFactory::createSaturationCharacteristic);\n+          put(COLOR_TEMPERATURE, HomekitCharacteristicFactory::createColorTemperatureCharacteristic);\n+          put(CURRENT_FAN_STATE, HomekitCharacteristicFactory::createCurrentFanStateCharacteristic);\n+          put(TARGET_FAN_STATE, HomekitCharacteristicFactory::createTargetFanStateCharacteristic);\n+          put(ROTATION_DIRECTION, HomekitCharacteristicFactory::createRotationDirectionCharacteristic);\n+          put(ROTATION_SPEED, HomekitCharacteristicFactory::createRotationSpeedCharacteristic);\n+          put(SWING_MODE, HomekitCharacteristicFactory::createSwingModeCharacteristic);\n+          put(LOCK_CONTROL, HomekitCharacteristicFactory::createLockPhysicalControlsCharacteristic);\n+          put(DURATION, HomekitCharacteristicFactory::createDurationCharacteristic);\n+          put(REMAINING_DURATION, HomekitCharacteristicFactory::createRemainingDurationCharacteristic);\n+          // LEGACY\n+          put(OLD_BATTERY_LOW_STATUS, HomekitCharacteristicFactory::createStatusLowBatteryCharacteristic);\n+        }};\n+\n+  /**\n+   * create optional HomeKit characteristic\n+   * @param type type of characteristic\n+   * @param item corresponding OH item\n+   * @param updater update to keep OH item and HomeKit characteristic in sync\n+   * @return HomeKit characteristic\n+   */\n+    public static Characteristic createCharacteristic(HomekitCharacteristicType type, GenericItem item, HomekitAccessoryUpdater updater)\n+        throws HomekitException {\n+      LOGGER.debug(\"createCharacteristic, type {} item {}\",type, item);\n+        if (type!=null) {\n+            if (optional.containsKey(type)) {\n+                return optional.get(type).apply(item, updater);\n+            }\n+        }\n+        LOGGER.error(\"Unsupported optional characteristic. Item type {}, characteristic type {}\", item.getType(), type);\n+        throw new HomekitException(\"Unsupported optional characteristic. Characteristic type \\\"\" + item.getType());\n+    }\n+\n+    // METHODS TO CREATE SINGLE CHARACTERISTIC FROM OH ITEM\n+\n+\n+    private static <T extends CharacteristicEnum> CompletableFuture<T> getEnumFromOnOffAndNumber(GenericItem item, T  offEnum, T onEnum, T defaultEnum) {\n+        final State state = item.getState();\n+        if (state instanceof OnOffType)\n+            return CompletableFuture.completedFuture(state.equals(OnOffType.OFF) ? offEnum : onEnum);\n+        if (state instanceof OpenClosedType)\n+            return CompletableFuture.completedFuture(state.equals(OpenClosedType.CLOSED) ? offEnum : onEnum);\n+        if (state instanceof DecimalType)\n+            return  CompletableFuture.completedFuture(item.getStateAs(DecimalType.class).intValue()==0?offEnum:onEnum);\n+      if (state instanceof UnDefType)\n+        return CompletableFuture.completedFuture(defaultEnum);\n+      LOGGER.error(\"Item state {} is not supported. Only OnOffType,OpenClosedType and Decimal (0/1) are supported. Ignore item {}\", state.getClass(), item.getName());\n+      return CompletableFuture.completedFuture(defaultEnum);\n+    }\n+\n+    private static void setStateFromEnum(GenericItem item, CharacteristicEnum value, CharacteristicEnum offEnum, CharacteristicEnum onEnum) {\n+        final State state = item.getState();\n+        if (state instanceof OnOffType) {\n+            if (value.equals(offEnum))\n+                item.setState(OnOffType.OFF);\n+            else if (value.equals(onEnum)) {\n+                item.setState(OnOffType.ON);\n+            } else\n+                LOGGER.error(\"Enum value {} is not supported. Only following values are supported: {},{}\", value, offEnum, onEnum);\n+        } else\n+            if (item.getState() instanceof DecimalType) {\n+                item.setState(new DecimalType(value.getCode()));\n+            } else\n+                LOGGER.error(\"Item state {} is not supported. Only OnOffType and DecimalType (0/1) are supported.\", item.getState());\n+    }\n+\n+    private static StatusLowBatteryCharacteristic createStatusLowBatteryCharacteristic(final GenericItem item, HomekitAccessoryUpdater updater) {\n+        return new StatusLowBatteryCharacteristic(\n+            () -> getEnumFromOnOffAndNumber(item, StatusLowBatteryEnum.NORMAL, StatusLowBatteryEnum.LOW, StatusLowBatteryEnum.NORMAL),\n+            (callback) -> updater.subscribe(item, BATTERY_LOW_STATUS.getTag(), callback),\n+            ()->  updater.unsubscribe(item, BATTERY_LOW_STATUS.getTag()));\n+    }\n+\n+    private static StatusFaultCharacteristic createStatusFaultCharacteristic(final GenericItem item, HomekitAccessoryUpdater updater) {\n+        return new StatusFaultCharacteristic(\n+            () -> getEnumFromOnOffAndNumber(item, StatusFaultEnum.NO_FAULT,StatusFaultEnum.GENERAL_FAULT, StatusFaultEnum.NO_FAULT),\n+            (callback) -> updater.subscribe(item, FAULT_STATUS.getTag(), callback),\n+            ()->  updater.unsubscribe(item, FAULT_STATUS.getTag()));\n+    }\n+\n+    private static StatusTamperedCharacteristic createStatusTamperedCharacteristic(final GenericItem item, HomekitAccessoryUpdater updater) {\n+        return new StatusTamperedCharacteristic(\n+            () -> getEnumFromOnOffAndNumber(item,StatusTamperedEnum.NOT_TAMPERED, StatusTamperedEnum.TAMPERED, StatusTamperedEnum.NOT_TAMPERED),\n+            (callback) -> updater.subscribe(item,TAMPERED_STATUS.getTag(), callback),\n+            ()->  updater.unsubscribe(item, TAMPERED_STATUS.getTag()));\n+    }\n+    private static ObstructionDetectedCharacteristic createObstructionDetectedCharacteristic(final GenericItem item, HomekitAccessoryUpdater updater) {\n+        return new ObstructionDetectedCharacteristic(\n+            () -> CompletableFuture.completedFuture(\n+                ((item !=null) &&\n+                 (\n+                     item.getState().equals(OnOffType.ON) ||\n+                     item.getState().equals(OpenClosedType.OPEN)\n+                 )\n+                )),\n+            (callback) -> updater.subscribe(item, OBSTRUCTION_STATUS.getTag(), callback),\n+            ()->  updater.unsubscribe(item, OBSTRUCTION_STATUS.getTag()));\n+    }\n+\n+    private static StatusActiveCharacteristic createStatusActiveCharacteristic(final GenericItem item, HomekitAccessoryUpdater updater) {\n+        return new StatusActiveCharacteristic(\n+            () -> CompletableFuture.completedFuture(\n+                (item !=null) &&\n+                 (\n+                     item.getState().equals(OnOffType.ON) ||\n+                     item.getState().equals(OpenClosedType.OPEN)\n+                 )\n+                                                   ),\n+            (callback) -> updater.subscribe(item, ACTIVE_STATUS.getTag(), callback),\n+            ()->  updater.unsubscribe(item, ACTIVE_STATUS.getTag()));\n+    }\n+\n+    private static NameCharacteristic createNameCharacteristic(final GenericItem item, HomekitAccessoryUpdater updater) {\n+        return new NameCharacteristic(\n+            () -> CompletableFuture.completedFuture(item.getState().toString()));\n+    }\n+    private static HoldPositionCharacteristic createHoldPositionCharacteristic(final GenericItem item, HomekitAccessoryUpdater updater) {\n+        return new HoldPositionCharacteristic( (hold) -> item.setState(hold?OnOffType.ON:OnOffType.OFF));\n+    }\n+\n+    private static CarbonMonoxideLevelCharacteristic createCarbonMonoxideLevelCharacteristic(final GenericItem item, HomekitAccessoryUpdater updater) {\n+        return new CarbonMonoxideLevelCharacteristic(\n+            () -> CompletableFuture.completedFuture((item !=null) ?\n+                                                    item.getStateAs(DecimalType.class).doubleValue() : 0),\n+            (callback) -> updater.subscribe(item, CARBON_DIOXIDE_LEVEL.getTag(), callback),\n+            ()->  updater.unsubscribe(item, CARBON_DIOXIDE_LEVEL.getTag()));\n+    }\n+    private static CarbonMonoxidePeakLevelCharacteristic createCarbonMonoxidePeakLevelCharacteristic(final GenericItem item, HomekitAccessoryUpdater updater) {\n+        return new CarbonMonoxidePeakLevelCharacteristic(\n+            () -> CompletableFuture.completedFuture((item !=null) ?\n+                                                    item.getStateAs(DecimalType.class).doubleValue() : 0),\n+            (callback) -> updater.subscribe(item, CARBON_DIOXIDE_PEAK_LEVEL.getTag(), callback),\n+            ()->  updater.unsubscribe(item, CARBON_DIOXIDE_PEAK_LEVEL.getTag()));\n+    }\n+\n+    private static CarbonDioxideLevelCharacteristic createCarbonDioxideLevelCharacteristic(final GenericItem item, HomekitAccessoryUpdater updater) {\n+        return new CarbonDioxideLevelCharacteristic(\n+            () -> CompletableFuture.completedFuture((item !=null) ?\n+                                                    item.getStateAs(DecimalType.class).doubleValue() : 0),\n+            (callback) -> updater.subscribe(item, CARBON_MONOXIDE_LEVEL.getTag(), callback),\n+            ()->  updater.unsubscribe(item, CARBON_MONOXIDE_LEVEL.getTag()));\n+    }\n+    private static CarbonDioxidePeakLevelCharacteristic createCarbonDioxidePeakLevelCharacteristic(final GenericItem item, HomekitAccessoryUpdater updater) {\n+        return new CarbonDioxidePeakLevelCharacteristic(\n+            () -> CompletableFuture.completedFuture((item !=null) ?\n+                                                    item.getStateAs(DecimalType.class).doubleValue() : 0),\n+            (callback) -> updater.subscribe(item, CARBON_MONOXIDE_PEAK_LEVEL.getTag(), callback),\n+            ()->  updater.unsubscribe(item, CARBON_MONOXIDE_PEAK_LEVEL.getTag()));\n+    }\n+    private static CurrentHorizontalTiltAngleCharacteristic createCurrentHorizontalTiltAngleCharacteristic(final GenericItem item, HomekitAccessoryUpdater updater) {\n+        return new CurrentHorizontalTiltAngleCharacteristic(\n+            () -> CompletableFuture.completedFuture((item !=null) ?\n+                                                    item.getStateAs(DecimalType.class).intValue() : 0),\n+            (callback) -> updater.subscribe(item, CURRENT_HORIZONTAL_TILT_ANGLE.getTag(), callback),\n+            ()->  updater.unsubscribe(item, CURRENT_HORIZONTAL_TILT_ANGLE.getTag()));\n+    }\n+    private static CurrentVerticalTiltAngleCharacteristic createCurrentVerticalTiltAngleCharacteristic(final GenericItem item, HomekitAccessoryUpdater updater) {\n+        return new CurrentVerticalTiltAngleCharacteristic(\n+            () -> CompletableFuture.completedFuture((item !=null) ?\n+                                                    item.getStateAs(DecimalType.class).intValue() : 0),\n+            (callback) -> updater.subscribe(item, CURRENT_VERTICAL_TILT_ANGLE.getTag(), callback),\n+            ()->  updater.unsubscribe(item,  CURRENT_VERTICAL_TILT_ANGLE.getTag()));\n+    }\n+    private static TargetHorizontalTiltAngleCharacteristic createTargetHorizontalTiltAngleCharacteristic(final GenericItem item, HomekitAccessoryUpdater updater) {\n+        return new TargetHorizontalTiltAngleCharacteristic(\n+            () -> CompletableFuture.completedFuture((item !=null) ?\n+                                                    item.getStateAs(DecimalType.class).intValue() : 0),\n+            (angle) -> item.setState(new DecimalType(angle)),\n+            (callback) -> updater.subscribe(item, TARGET_HORIZONTAL_TILT_ANGLE.getTag(), callback),\n+            ()->  updater.unsubscribe(item, TARGET_HORIZONTAL_TILT_ANGLE.getTag()));\n+    }\n+    private static TargetVerticalTiltAngleCharacteristic createTargetVerticalTiltAngleCharacteristic(final GenericItem item, HomekitAccessoryUpdater updater) {\n+        return new TargetVerticalTiltAngleCharacteristic(\n+            () -> CompletableFuture.completedFuture((item !=null) ? item.getStateAs(DecimalType.class).intValue() : 0),", "originalCommit": "b4c1bba476ec0a464676397686f83d94a3f0fda7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc4MDA4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r416780086", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        item.send(state ? OnOffType.ON : OnOffType.OFF);\n          \n          \n            \n                        item.send(OnOffType.from(state));", "author": "J-N-K", "createdAt": "2020-04-28T17:07:13Z", "path": "bundles/org.openhab.io.homekit/src/main/java/org/openhab/io/homekit/internal/accessories/HomekitFanImpl.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.io.homekit.internal.accessories;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.items.SwitchItem;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.io.homekit.internal.HomekitAccessoryUpdater;\n+import org.openhab.io.homekit.internal.HomekitCharacteristicType;\n+import org.openhab.io.homekit.internal.HomekitSettings;\n+import org.openhab.io.homekit.internal.HomekitTaggedItem;\n+import io.github.hapjava.accessories.FanAccessory;\n+import io.github.hapjava.characteristics.HomekitCharacteristicChangeCallback;\n+import io.github.hapjava.services.impl.FanService;\n+\n+/**\n+ * Implements Fan using an Item that provides an On/Off state\n+ *\n+ * @author Eugen Freiter - Initial contribution\n+ */\n+class HomekitFanImpl extends AbstractHomekitAccessoryImpl implements FanAccessory {\n+    public HomekitFanImpl(HomekitTaggedItem taggedItem, List<HomekitTaggedItem> mandatoryCharacteristics,\n+            HomekitAccessoryUpdater updater, HomekitSettings settings) throws IncompleteAccessoryException {\n+        super(taggedItem, mandatoryCharacteristics, updater, settings);\n+        this.getServices().add(new FanService(this));\n+    }\n+\n+    @Override\n+    public CompletableFuture<Boolean> isActive() {\n+        final @Nullable State state = getStateAs(HomekitCharacteristicType.ACTIVE_STATUS, OnOffType.class);\n+        return CompletableFuture.completedFuture(state != null && state == OnOffType.ON);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> setActive(final boolean state) throws Exception {\n+        final @Nullable SwitchItem item = getItem(HomekitCharacteristicType.ACTIVE_STATUS, SwitchItem.class);\n+        if (item != null)\n+            item.send(state ? OnOffType.ON : OnOffType.OFF);", "originalCommit": "b4c1bba476ec0a464676397686f83d94a3f0fda7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc4MTUyOA==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r416781528", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return CompletableFuture.completedFuture(state != null && state == OnOffType.ON);\n          \n          \n            \n                    return CompletableFuture.completedFuture(state != null && state == OnOffType.ON);\n          \n      \n    \n    \n  \n\nIf it's ON, it cannot be null.", "author": "J-N-K", "createdAt": "2020-04-28T17:09:25Z", "path": "bundles/org.openhab.io.homekit/src/main/java/org/openhab/io/homekit/internal/accessories/HomekitLightbulbImpl.java", "diffHunk": "@@ -12,20 +12,58 @@\n  */\n package org.openhab.io.homekit.internal.accessories;\n \n-import org.eclipse.smarthome.core.items.ItemRegistry;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import org.eclipse.smarthome.core.items.GenericItem;\n+import org.eclipse.smarthome.core.items.GroupItem;\n import org.eclipse.smarthome.core.library.items.SwitchItem;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n import org.openhab.io.homekit.internal.HomekitAccessoryUpdater;\n+import org.openhab.io.homekit.internal.HomekitCharacteristicType;\n+import org.openhab.io.homekit.internal.HomekitSettings;\n import org.openhab.io.homekit.internal.HomekitTaggedItem;\n+import io.github.hapjava.accessories.LightbulbAccessory;\n+import io.github.hapjava.characteristics.HomekitCharacteristicChangeCallback;\n+import io.github.hapjava.services.impl.LightbulbService;\n \n /**\n  * Implements Lightbulb using an Item that provides an On/Off state\n  *\n  * @author Andy Lintner - Initial contribution\n  */\n-class HomekitLightbulbImpl extends AbstractHomekitLightbulbImpl<SwitchItem> {\n+class HomekitLightbulbImpl extends AbstractHomekitAccessoryImpl implements LightbulbAccessory  {\n \n-    public HomekitLightbulbImpl(HomekitTaggedItem taggedItem, ItemRegistry itemRegistry,\n-            HomekitAccessoryUpdater updater) {\n-        super(taggedItem, itemRegistry, updater, SwitchItem.class);\n+    public HomekitLightbulbImpl(HomekitTaggedItem taggedItem, List<HomekitTaggedItem> mandatoryCharacteristics,\n+            HomekitAccessoryUpdater updater, HomekitSettings settings) throws IncompleteAccessoryException {\n+        super(taggedItem, mandatoryCharacteristics, updater, settings);\n+        this.getServices().add(new LightbulbService(this));\n     }\n+\n+    @Override\n+    public CompletableFuture<Boolean> getLightbulbPowerState() {\n+        OnOffType state = getStateAs(HomekitCharacteristicType.ON_STATE, OnOffType.class);\n+        return CompletableFuture.completedFuture(state != null && state == OnOffType.ON);", "originalCommit": "b4c1bba476ec0a464676397686f83d94a3f0fda7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg2NDIzOA==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r416864238", "bodyText": "right.", "author": "yfre", "createdAt": "2020-04-28T19:22:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc4MTUyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc4MTg2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r416781869", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        ((SwitchItem) item).send(value ? OnOffType.ON : OnOffType.OFF);\n          \n          \n            \n                        ((SwitchItem) item).send(OnOffType.from(value));\n          \n      \n    \n    \n  \n\nalso below", "author": "J-N-K", "createdAt": "2020-04-28T17:09:54Z", "path": "bundles/org.openhab.io.homekit/src/main/java/org/openhab/io/homekit/internal/accessories/HomekitLightbulbImpl.java", "diffHunk": "@@ -12,20 +12,58 @@\n  */\n package org.openhab.io.homekit.internal.accessories;\n \n-import org.eclipse.smarthome.core.items.ItemRegistry;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import org.eclipse.smarthome.core.items.GenericItem;\n+import org.eclipse.smarthome.core.items.GroupItem;\n import org.eclipse.smarthome.core.library.items.SwitchItem;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n import org.openhab.io.homekit.internal.HomekitAccessoryUpdater;\n+import org.openhab.io.homekit.internal.HomekitCharacteristicType;\n+import org.openhab.io.homekit.internal.HomekitSettings;\n import org.openhab.io.homekit.internal.HomekitTaggedItem;\n+import io.github.hapjava.accessories.LightbulbAccessory;\n+import io.github.hapjava.characteristics.HomekitCharacteristicChangeCallback;\n+import io.github.hapjava.services.impl.LightbulbService;\n \n /**\n  * Implements Lightbulb using an Item that provides an On/Off state\n  *\n  * @author Andy Lintner - Initial contribution\n  */\n-class HomekitLightbulbImpl extends AbstractHomekitLightbulbImpl<SwitchItem> {\n+class HomekitLightbulbImpl extends AbstractHomekitAccessoryImpl implements LightbulbAccessory  {\n \n-    public HomekitLightbulbImpl(HomekitTaggedItem taggedItem, ItemRegistry itemRegistry,\n-            HomekitAccessoryUpdater updater) {\n-        super(taggedItem, itemRegistry, updater, SwitchItem.class);\n+    public HomekitLightbulbImpl(HomekitTaggedItem taggedItem, List<HomekitTaggedItem> mandatoryCharacteristics,\n+            HomekitAccessoryUpdater updater, HomekitSettings settings) throws IncompleteAccessoryException {\n+        super(taggedItem, mandatoryCharacteristics, updater, settings);\n+        this.getServices().add(new LightbulbService(this));\n     }\n+\n+    @Override\n+    public CompletableFuture<Boolean> getLightbulbPowerState() {\n+        OnOffType state = getStateAs(HomekitCharacteristicType.ON_STATE, OnOffType.class);\n+        return CompletableFuture.completedFuture(state != null && state == OnOffType.ON);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> setLightbulbPowerState(boolean value)  {\n+        GenericItem item = getItem(HomekitCharacteristicType.ON_STATE,GenericItem.class);\n+        if (item instanceof SwitchItem) {\n+            ((SwitchItem) item).send(value ? OnOffType.ON : OnOffType.OFF);", "originalCommit": "b4c1bba476ec0a464676397686f83d94a3f0fda7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc4MzI1OA==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r416783258", "bodyText": "Why is this logger static?", "author": "J-N-K", "createdAt": "2020-04-28T17:11:49Z", "path": "bundles/org.openhab.io.homekit/src/main/java/org/openhab/io/homekit/internal/accessories/HomekitSecuritySystemImpl.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.io.homekit.internal.accessories;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.items.StringItem;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.io.homekit.internal.HomekitAccessoryUpdater;\n+import org.openhab.io.homekit.internal.HomekitCharacteristicType;\n+import org.openhab.io.homekit.internal.HomekitSettings;\n+import org.openhab.io.homekit.internal.HomekitTaggedItem;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import io.github.hapjava.accessories.SecuritySystemAccessory;\n+import io.github.hapjava.characteristics.HomekitCharacteristicChangeCallback;\n+import io.github.hapjava.characteristics.impl.securitysystem.CurrentSecuritySystemStateEnum;\n+import io.github.hapjava.characteristics.impl.securitysystem.TargetSecuritySystemStateEnum;\n+import io.github.hapjava.services.impl.SecuritySystemService;\n+\n+/**\n+ *  Implements SecuritySystem as a GroupedAccessory made up of multiple items:\n+ *  <ul>\n+ *  <li>CurrentSecuritySystemState: String type</li>\n+ *  <li>TargetSecuritySystemState: String type</li>\n+ *  </ul>\n+ * @author Cody Cutrer - Initial contribution\n+ */\n+public class HomekitSecuritySystemImpl extends AbstractHomekitAccessoryImpl implements SecuritySystemAccessory {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(HomekitSecuritySystemImpl.class);", "originalCommit": "b4c1bba476ec0a464676397686f83d94a3f0fda7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc4NDgyOA==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r416784828", "bodyText": "Why is this method throwing Exception?", "author": "J-N-K", "createdAt": "2020-04-28T17:14:17Z", "path": "bundles/org.openhab.io.homekit/src/main/java/org/openhab/io/homekit/internal/accessories/HomekitSecuritySystemImpl.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.io.homekit.internal.accessories;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.items.StringItem;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.io.homekit.internal.HomekitAccessoryUpdater;\n+import org.openhab.io.homekit.internal.HomekitCharacteristicType;\n+import org.openhab.io.homekit.internal.HomekitSettings;\n+import org.openhab.io.homekit.internal.HomekitTaggedItem;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import io.github.hapjava.accessories.SecuritySystemAccessory;\n+import io.github.hapjava.characteristics.HomekitCharacteristicChangeCallback;\n+import io.github.hapjava.characteristics.impl.securitysystem.CurrentSecuritySystemStateEnum;\n+import io.github.hapjava.characteristics.impl.securitysystem.TargetSecuritySystemStateEnum;\n+import io.github.hapjava.services.impl.SecuritySystemService;\n+\n+/**\n+ *  Implements SecuritySystem as a GroupedAccessory made up of multiple items:\n+ *  <ul>\n+ *  <li>CurrentSecuritySystemState: String type</li>\n+ *  <li>TargetSecuritySystemState: String type</li>\n+ *  </ul>\n+ * @author Cody Cutrer - Initial contribution\n+ */\n+public class HomekitSecuritySystemImpl extends AbstractHomekitAccessoryImpl implements SecuritySystemAccessory {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(HomekitSecuritySystemImpl.class);\n+\n+    public HomekitSecuritySystemImpl(HomekitTaggedItem taggedItem, List<HomekitTaggedItem> mandatoryCharacteristics, HomekitAccessoryUpdater updater, HomekitSettings settings) throws IncompleteAccessoryException {\n+        super(taggedItem, mandatoryCharacteristics, updater, settings);\n+        getServices().add(new SecuritySystemService(this));\n+    }\n+\n+    @Override\n+    public CompletableFuture<CurrentSecuritySystemStateEnum> getCurrentSecuritySystemState() {\n+        CurrentSecuritySystemStateEnum state;\n+        final @Nullable State itemState = getStateAs(HomekitCharacteristicType.SECURITY_SYSTEM_CURRENT_STATE, StringType.class);\n+        if (itemState!=null) {\n+            String stringValue = itemState.toString();\n+            if (stringValue.equalsIgnoreCase(\"DISARMED\")) {\n+                state = CurrentSecuritySystemStateEnum.DISARMED;\n+            } else if (stringValue.equalsIgnoreCase(\"AWAY_ARM\")) {\n+                state = CurrentSecuritySystemStateEnum.AWAY_ARM;\n+            } else if (stringValue.equalsIgnoreCase(\"STAY_ARM\")) {\n+                state = CurrentSecuritySystemStateEnum.STAY_ARM;\n+            } else if (stringValue.equalsIgnoreCase(\"NIGHT_ARM\")) {\n+                state = CurrentSecuritySystemStateEnum.NIGHT_ARM;\n+            } else if (stringValue.equalsIgnoreCase(\"TRIGGERED\")) {\n+                state = CurrentSecuritySystemStateEnum.TRIGGERED;\n+            } else if (stringValue.equals(\"UNDEF\") || stringValue.equals(\"NULL\")) {\n+                LOGGER.debug(\"Security system target state not available. Relaying value of DISARM to HomeKit\");\n+                state = CurrentSecuritySystemStateEnum.DISARMED;\n+            } else {\n+                LOGGER.error(\n+                    \"Unrecognized security system target state: {}. Expected DISARM, AWAY_ARM, STAY_ARM, NIGHT_ARM strings in value.\",\n+                    stringValue);\n+                state = CurrentSecuritySystemStateEnum.DISARMED;\n+            }\n+        } else {\n+            LOGGER.debug(\"Security system target state not available. Relaying value of DISARM to HomeKit\");\n+            state = CurrentSecuritySystemStateEnum.DISARMED;\n+        }\n+        return CompletableFuture.completedFuture(state);\n+    }\n+    @Override\n+    public void setTargetSecuritySystemState(final TargetSecuritySystemStateEnum state) throws Exception {", "originalCommit": "b4c1bba476ec0a464676397686f83d94a3f0fda7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg2NDY1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r416864656", "bodyText": "yep. removed", "author": "yfre", "createdAt": "2020-04-28T19:23:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc4NDgyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA3ODk1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r418078952", "bodyText": "reduce to debug", "author": "J-N-K", "createdAt": "2020-04-30T15:03:49Z", "path": "bundles/org.openhab.io.homekit/src/main/java/org/openhab/io/homekit/internal/HomekitChangeListener.java", "diffHunk": "@@ -159,19 +187,40 @@ public void stop() {\n         this.itemRegistry.removeRegistryChangeListener(this);\n     }\n \n+    public Map<String, HomekitAccessory> getAccessories() {\n+        return this.accessoryRegistry.getAllAccessories();\n+    }\n+\n+    /**\n+     * creates one or more HomeKit items for given openhab item.\n+     * one openhab item can linked to several HomeKit accessories or characteristics.\n+     * \n+     * @param item\n+     */\n+    private void createRootAccessories(Item item) {\n+        logger.info(\"create root accessory {}\", item.getLabel());", "originalCommit": "9eb444823de197984d1232e24abf78e940be0472", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUzMDEwMw==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r418530103", "bodyText": "While iterating over the tags you could check if we are in legacyMode and adjust according to the old behaviour if the tag \"Lighting\" is found.", "author": "J-N-K", "createdAt": "2020-05-01T12:58:09Z", "path": "bundles/org.openhab.io.homekit/src/main/java/org/openhab/io/homekit/internal/accessories/HomekitAccessoryFactory.java", "diffHunk": "@@ -12,156 +12,405 @@\n  */\n package org.openhab.io.homekit.internal.accessories;\n \n+import static org.openhab.io.homekit.internal.HomekitAccessoryType.*;\n+import static org.openhab.io.homekit.internal.HomekitCharacteristicType.*;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.AbstractMap.SimpleEntry;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n+import java.util.Map.Entry;\n import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.items.GenericItem;\n import org.eclipse.smarthome.core.items.GroupItem;\n import org.eclipse.smarthome.core.items.Item;\n import org.eclipse.smarthome.core.items.ItemRegistry;\n+import org.eclipse.smarthome.core.items.Metadata;\n+import org.eclipse.smarthome.core.items.MetadataKey;\n+import org.eclipse.smarthome.core.items.MetadataRegistry;\n import org.openhab.io.homekit.internal.HomekitAccessoryType;\n import org.openhab.io.homekit.internal.HomekitAccessoryUpdater;\n import org.openhab.io.homekit.internal.HomekitCharacteristicType;\n import org.openhab.io.homekit.internal.HomekitException;\n import org.openhab.io.homekit.internal.HomekitSettings;\n import org.openhab.io.homekit.internal.HomekitTaggedItem;\n-import org.openhab.io.homekit.internal.battery.BatteryStatus;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import io.github.hapjava.HomekitAccessory;\n+import io.github.hapjava.accessories.HomekitAccessory;\n+import io.github.hapjava.characteristics.Characteristic;\n+import io.github.hapjava.services.Service;\n \n /**\n  * Creates a HomekitAccessory for a given HomekitTaggedItem.\n  *\n  * @author Andy Lintner - Initial contribution\n+ * @author Eugen Freiter - refactoring for optional characteristics\n  */\n+@NonNullByDefault\n public class HomekitAccessoryFactory {\n     private static final Logger LOGGER = LoggerFactory.getLogger(HomekitAccessoryFactory.class);\n+    public final static String METADATA_KEY = \"homekit\"; // prefix for HomeKit meta information in items.xml\n+\n+    /** List of mandatory attributes for each accessory type. **/\n+    private final static Map<HomekitAccessoryType, HomekitCharacteristicType[]> mandatoryCharacteristics = new HashMap<HomekitAccessoryType, HomekitCharacteristicType[]>() {\n+        {\n+            put(LEAK_SENSOR, new HomekitCharacteristicType[] { LEAK_DETECTED_STATE });\n+            put(MOTION_SENSOR, new HomekitCharacteristicType[] { MOTION_DETECTED_STATE });\n+            put(OCCUPANCY_SENSOR, new HomekitCharacteristicType[] { OCCUPANCY_DETECTED_STATE });\n+            put(CONTACT_SENSOR, new HomekitCharacteristicType[] { CONTACT_SENSOR_STATE });\n+            put(SMOKE_SENSOR, new HomekitCharacteristicType[] { SMOKE_DETECTED_STATE });\n+            put(HUMIDITY_SENSOR, new HomekitCharacteristicType[] { RELATIVE_HUMIDITY });\n+            put(SWITCH, new HomekitCharacteristicType[] { ON_STATE });\n+            put(CARBON_DIOXIDE_SENSOR, new HomekitCharacteristicType[] { CARBON_DIOXIDE_DETECTED_STATE });\n+            put(CARBON_MONOXIDE_SENSOR, new HomekitCharacteristicType[] { CARBON_MONOXIDE_DETECTED_STATE });\n+            put(WINDOW_COVERING, new HomekitCharacteristicType[] { TARGET_POSITION, CURRENT_POSITION, POSITION_STATE });\n+            put(LIGHTBULB, new HomekitCharacteristicType[] { ON_STATE });\n+            put(FAN, new HomekitCharacteristicType[] { ACTIVE_STATUS });\n+            put(TEMPERATURE_SENSOR, new HomekitCharacteristicType[] { CURRENT_TEMPERATURE });\n+            put(THERMOSTAT, new HomekitCharacteristicType[] { CURRENT_HEATING_COOLING_STATE,\n+                    TARGET_HEATING_COOLING_STATE, CURRENT_TEMPERATURE, TARGET_TEMPERATURE });\n+            put(LOCK, new HomekitCharacteristicType[] { LOCK_CURRENT_STATE, LOCK_TARGET_STATE });\n+            put(VALVE, new HomekitCharacteristicType[] { ACTIVE_STATUS, INUSE_STATUS });\n+            put(SECURITY_SYSTEM,\n+                    new HomekitCharacteristicType[] { SECURITY_SYSTEM_CURRENT_STATE, SECURITY_SYSTEM_TARGET_STATE });\n+            // LEGACY\n+            put(BLINDS, new HomekitCharacteristicType[] { TARGET_POSITION, CURRENT_POSITION, POSITION_STATE });\n+            put(OLD_HUMIDITY_SENSOR, new HomekitCharacteristicType[] { RELATIVE_HUMIDITY });\n+            put(OLD_DIMMABLE_LIGHTBULB, new HomekitCharacteristicType[] { ON_STATE });\n+            put(OLD_COLORFUL_LIGHTBULB, new HomekitCharacteristicType[] { ON_STATE });\n+        }\n+    };\n+\n+    /** List of service implementation for each accessory type. **/\n+    private final static Map<HomekitAccessoryType, Class<? extends AbstractHomekitAccessoryImpl>> serviceImplMap = new HashMap<HomekitAccessoryType, Class<? extends AbstractHomekitAccessoryImpl>>() {\n+        {\n+            put(LEAK_SENSOR, HomekitLeakSensorImpl.class);\n+            put(MOTION_SENSOR, HomekitMotionSensorImpl.class);\n+            put(OCCUPANCY_SENSOR, HomekitOccupancySensorImpl.class);\n+            put(CONTACT_SENSOR, HomekitContactSensorImpl.class);\n+            put(TEMPERATURE_SENSOR, HomekitTemperatureSensorImpl.class);\n+            put(SMOKE_SENSOR, HomekitSmokeSensorImpl.class);\n+            put(HUMIDITY_SENSOR, HomekitHumiditySensorImpl.class);\n+            put(SWITCH, HomekitSwitchImpl.class);\n+            put(CARBON_DIOXIDE_SENSOR, HomekitCarbonDioxideSensorImpl.class);\n+            put(CARBON_MONOXIDE_SENSOR, HomekitCarbonMonoxideSensorImpl.class);\n+            put(WINDOW_COVERING, HomekitWindowCoveringImpl.class);\n+            put(LIGHTBULB, HomekitLightbulbImpl.class);\n+            put(FAN, HomekitFanImpl.class);\n+            put(TEMPERATURE_SENSOR, HomekitTemperatureSensorImpl.class);\n+            put(THERMOSTAT, HomekitThermostatImpl.class);\n+            put(LOCK, HomekitLockImpl.class);\n+            put(VALVE, HomekitValveImpl.class);\n+            put(SECURITY_SYSTEM, HomekitSecuritySystemImpl.class);\n+            put(BLINDS, HomekitWindowCoveringImpl.class);\n+            put(OLD_HUMIDITY_SENSOR, HomekitHumiditySensorImpl.class);\n+            put(OLD_DIMMABLE_LIGHTBULB, HomekitLightbulbImpl.class);\n+            put(OLD_COLORFUL_LIGHTBULB, HomekitLightbulbImpl.class);\n+\n+        }\n+    };\n+\n+    /** mapping of legacy attributes to new attributes. **/\n+    private final static Map<HomekitCharacteristicType, HomekitCharacteristicType> legacyCharacteristicsMapping = new HashMap<HomekitCharacteristicType, HomekitCharacteristicType>() {\n+        {\n+            put(OLD_CURRENT_HEATING_COOLING_STATE, CURRENT_HEATING_COOLING_STATE);\n+            put(OLD_TARGET_HEATING_COOLING_MODE, TARGET_HEATING_COOLING_STATE);\n+            put(OLD_TARGET_TEMPERATURE, TARGET_TEMPERATURE);\n+            put(OLD_BATTERY_LOW_STATUS, BATTERY_LOW_STATUS);\n+            put(VERY_OLD_TARGET_HEATING_COOLING_MODE, CURRENT_HEATING_COOLING_STATE);\n+        }\n+    };\n+\n+    /** list of optional implicit optional characteristics. mainly used for legacy accessory type */\n+    private final static Map<HomekitAccessoryType, HomekitCharacteristicType[]> implicitOptionalCharacteristics = new HashMap<HomekitAccessoryType, HomekitCharacteristicType[]>() {\n+        {\n+            put(OLD_DIMMABLE_LIGHTBULB, new HomekitCharacteristicType[] { BRIGHTNESS });\n+            put(OLD_COLORFUL_LIGHTBULB, new HomekitCharacteristicType[] { HUE, SATURATION, BRIGHTNESS });\n+\n+        }\n+    };\n+\n+    /**\n+     * creates HomeKit accessory for a openhab item.\n+     * \n+     * @param taggedItem openhab item tagged as HomeKit item\n+     * @param metadataRegistry openhab metadata registry required to get item meta information\n+     * @param updater OH HomeKit update class that ensure the status sync between OH item and corresponding HomeKit\n+     *            characteristic.\n+     * @param settings OH settings\n+     * @return HomeKit accessory\n+     * @throws HomekitException exception in case HomeKit accessory could not be created, e.g. due missing mandatory\n+     *             characteristic\n+     */\n+    public static HomekitAccessory create(HomekitTaggedItem taggedItem, MetadataRegistry metadataRegistry,\n+            HomekitAccessoryUpdater updater, HomekitSettings settings) throws HomekitException {\n \n-    @SuppressWarnings(\"deprecation\")\n-    public static HomekitAccessory create(HomekitTaggedItem taggedItem, ItemRegistry itemRegistry,\n-            HomekitAccessoryUpdater updater, HomekitSettings settings)\n-            throws HomekitException, IncompleteAccessoryException {\n         LOGGER.debug(\"Constructing {} of accessoryType {}\", taggedItem.getName(), taggedItem.getAccessoryType());\n+        final List<HomekitTaggedItem> requiredCharacteristics = getMandatoryCharacteristics(taggedItem,\n+                metadataRegistry);\n+        if ((mandatoryCharacteristics.get(taggedItem.getAccessoryType()) != null) && (requiredCharacteristics\n+                .size() < mandatoryCharacteristics.get(taggedItem.getAccessoryType()).length)) {\n+            LOGGER.error(\"Accessory of type {} must have following characteristics {}. Found only {}\",\n+                    taggedItem.getAccessoryType(), mandatoryCharacteristics.get(taggedItem.getAccessoryType()),\n+                    requiredCharacteristics);\n+            throw new HomekitException(\"Missing mandatory characteristics\");\n+        }\n+        AbstractHomekitAccessoryImpl accessoryImpl = null;\n \n-        Map<HomekitCharacteristicType, Item> characteristicItems = getCharacteristicItems(taggedItem);\n-\n-        switch (taggedItem.getAccessoryType()) {\n-            case LEAK_SENSOR:\n-                HomekitTaggedItem leakSensorAccessory = getPrimaryAccessory(taggedItem,\n-                        HomekitAccessoryType.LEAK_SENSOR, itemRegistry).orElseThrow(\n-                                () -> new HomekitException(\"Leak accessory group should have a leak sensor in it\"));\n-\n-                return new HomekitLeakSensorImpl(leakSensorAccessory, itemRegistry, updater,\n-                        BatteryStatus.getFromCharacteristics(characteristicItems));\n-            case VALVE:\n-                return new HomekitValveImpl(taggedItem, itemRegistry, updater);\n-            case MOTION_SENSOR:\n-                HomekitTaggedItem motionSensorAccessory = getPrimaryAccessory(taggedItem,\n-                        HomekitAccessoryType.MOTION_SENSOR, itemRegistry)\n-                                .orElseThrow(() -> new HomekitException(\n-                                        \"Motion sensor accessory group should have a motion sensor item in it\"));\n-                return new HomekitMotionSensorImpl(motionSensorAccessory, itemRegistry, updater,\n-                        BatteryStatus.getFromCharacteristics(characteristicItems));\n-            case OCCUPANCY_SENSOR:\n-                HomekitTaggedItem occupancySensorAccessory = getPrimaryAccessory(taggedItem,\n-                        HomekitAccessoryType.OCCUPANCY_SENSOR, itemRegistry)\n-                                .orElseThrow(() -> new HomekitException(\n-                                        \"Occupancy sensor accessory group should have a occupancy sensor item in it\"));\n-                return new HomekitOccupancySensorImpl(occupancySensorAccessory, itemRegistry, updater,\n-                        BatteryStatus.getFromCharacteristics(characteristicItems));\n-            case CONTACT_SENSOR:\n-                HomekitTaggedItem contactSensorAccessory = getPrimaryAccessory(taggedItem,\n-                        HomekitAccessoryType.CONTACT_SENSOR, itemRegistry)\n-                                .orElseThrow(() -> new HomekitException(\n-                                        \"Contact sensor accessory group should have a occupancy sensor item in it\"));\n-                return new HomekitContactSensorImpl(contactSensorAccessory, itemRegistry, updater,\n-                        BatteryStatus.getFromCharacteristics(characteristicItems));\n-            case LIGHTBULB:\n-                return new HomekitLightbulbImpl(taggedItem, itemRegistry, updater);\n-            case DIMMABLE_LIGHTBULB:\n-                return new HomekitDimmableLightbulbImpl(taggedItem, itemRegistry, updater);\n-            case COLORFUL_LIGHTBULB:\n-                return new HomekitColorfulLightbulbImpl(taggedItem, itemRegistry, updater);\n-            case THERMOSTAT:\n-                HomekitTaggedItem temperatureAccessory = getPrimaryAccessory(taggedItem,\n-                        HomekitAccessoryType.TEMPERATURE_SENSOR, itemRegistry).orElseThrow(\n-                                () -> new HomekitException(\"Thermostats need a CurrentTemperature accessory\"));\n-                return new HomekitThermostatImpl(taggedItem, itemRegistry, updater, settings,\n-                        temperatureAccessory.getItem(), getCharacteristicItems(taggedItem));\n-            case SWITCH:\n-                return new HomekitSwitchImpl(taggedItem, itemRegistry, updater);\n-            case TEMPERATURE_SENSOR:\n-                return new HomekitTemperatureSensorImpl(taggedItem, itemRegistry, updater, settings);\n-            case HUMIDITY_SENSOR:\n-                return new HomekitHumiditySensorImpl(taggedItem, itemRegistry, updater);\n-            case BLINDS:\n-            case WINDOW_COVERING:\n-                return new HomekitWindowCoveringImpl(taggedItem, itemRegistry, updater);\n-            case SMOKE_SENSOR:\n-                HomekitTaggedItem smokeSensorAccessory = getPrimaryAccessory(taggedItem,\n-                        HomekitAccessoryType.SMOKE_SENSOR, itemRegistry).orElseThrow(\n-                                () -> new HomekitException(\"Smoke accessory group should have a smoke sensor in it\"));\n-                return new HomekitSmokeSensorImpl(smokeSensorAccessory, itemRegistry, updater,\n-                        BatteryStatus.getFromCharacteristics(characteristicItems));\n-            case CARBON_MONOXIDE_SENSOR:\n-                HomekitTaggedItem carbonMonoxideSensorAccessory = getPrimaryAccessory(taggedItem,\n-                        HomekitAccessoryType.CARBON_MONOXIDE_SENSOR, itemRegistry)\n-                                .orElseThrow(() -> new HomekitException(\n-                                        \"Carbon monoxide accessory group should have a carbon monoxide sensor in it\"));\n-                return new HomekitSmokeSensorImpl(carbonMonoxideSensorAccessory, itemRegistry, updater,\n-                        BatteryStatus.getFromCharacteristics(characteristicItems));\n-            case LOCK:\n-                return new HomekitLockImpl(taggedItem, itemRegistry, updater);\n+        try {\n+            final Class<? extends AbstractHomekitAccessoryImpl> accessoryImplClass = serviceImplMap\n+                    .get(taggedItem.getAccessoryType());\n+            if (accessoryImplClass != null) {\n+                accessoryImpl = accessoryImplClass\n+                        .getConstructor(HomekitTaggedItem.class, List.class, HomekitAccessoryUpdater.class,\n+                                HomekitSettings.class)\n+                        .newInstance(taggedItem, requiredCharacteristics, updater, settings);\n+                addOptionalCharacteristics(accessoryImpl, metadataRegistry);\n+                return accessoryImpl;\n+            } else {\n+                LOGGER.error(\"Unsupported HomeKit type: {}\", taggedItem.getAccessoryType());\n+                throw new HomekitException(\"Unsupported HomeKit type: \" + taggedItem.getAccessoryType());\n+            }\n+        } catch (NoSuchMethodException | IllegalAccessException | InstantiationException\n+                | InvocationTargetException e) {\n+            LOGGER.error(\"Cannot instantiate accessory implementation for accessory {}\", taggedItem.getAccessoryType(),\n+                    e);\n+            throw new HomekitException(\n+                    \"Cannot instantiate accessory implementation for accessory \" + taggedItem.getAccessoryType());\n         }\n+    }\n+\n+    /**\n+     * return HomeKit accessory types for a OH item based on meta data\n+     * \n+     * @param item OH item\n+     * @param metadataRegistry meta data registry\n+     * @return list of HomeKit accessory types and characteristics.\n+     */\n+    public static List<Entry<HomekitAccessoryType, HomekitCharacteristicType>> getAccessoryTypes(Item item,\n+            MetadataRegistry metadataRegistry) {\n+        final List<Entry<HomekitAccessoryType, HomekitCharacteristicType>> accessories = new ArrayList<>();\n+        Metadata metadata = metadataRegistry.get(new MetadataKey(METADATA_KEY, item.getUID()));\n+        boolean legacyMode = !(metadata != null);\n+        String[] tags = !legacyMode ? metadata.getValue().split(\",\") : item.getTags().toArray(new String[0]); // fallback\n+                                                                                                              // to tags\n+\n+        LOGGER.debug(\"item {} meta data {}  tags {} \", item.getName(), metadata, tags);\n+        for (String tag : tags) {", "originalCommit": "2824bd2350210a251d748e3e46eccac90e3a2a68", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU0NTM2OA==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r418545368", "bodyText": "ah, ok.. missed that one with overwriting. we could add the same smart logic but personally i would prefer to have full control over the characteristics exposed via homekit.\nbut you are right, for legacy item we should support this smart logic.", "author": "yfre", "createdAt": "2020-05-01T13:41:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUzMDEwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU0NzkyNw==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r418547927", "bodyText": "Yes, only for legacy tags.", "author": "J-N-K", "createdAt": "2020-05-01T13:47:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUzMDEwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU4MjI0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r418582247", "bodyText": "done", "author": "yfre", "createdAt": "2020-05-01T15:06:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUzMDEwMw=="}], "type": "inlineReview"}, {"oid": "580ad0df55c3d1782ed3e5751c52bc756889a322", "url": "https://github.com/openhab/openhab-addons/commit/580ad0df55c3d1782ed3e5751c52bc756889a322", "message": "upgrade to latest HAP library\n\nSigned-off-by: Eugen Freiter <freiter@gmx.de>", "committedDate": "2020-05-01T21:20:34Z", "type": "commit"}, {"oid": "580ad0df55c3d1782ed3e5751c52bc756889a322", "url": "https://github.com/openhab/openhab-addons/commit/580ad0df55c3d1782ed3e5751c52bc756889a322", "message": "upgrade to latest HAP library\n\nSigned-off-by: Eugen Freiter <freiter@gmx.de>", "committedDate": "2020-05-01T21:20:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg0MjUzNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r416842535", "bodyText": "This looks like a good place to use a switch statement\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (stringValue.equalsIgnoreCase(\"DISARMED\")) {\n          \n          \n            \n                        switch(stringValue.toUppercase()){\n          \n          \n            \n                            case \"DISARMED\":", "author": "cpmeister", "createdAt": "2020-04-28T18:45:49Z", "path": "bundles/org.openhab.io.homekit/src/main/java/org/openhab/io/homekit/internal/accessories/HomekitSecuritySystemImpl.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.io.homekit.internal.accessories;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.items.StringItem;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.io.homekit.internal.HomekitAccessoryUpdater;\n+import org.openhab.io.homekit.internal.HomekitCharacteristicType;\n+import org.openhab.io.homekit.internal.HomekitSettings;\n+import org.openhab.io.homekit.internal.HomekitTaggedItem;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import io.github.hapjava.accessories.SecuritySystemAccessory;\n+import io.github.hapjava.characteristics.HomekitCharacteristicChangeCallback;\n+import io.github.hapjava.characteristics.impl.securitysystem.CurrentSecuritySystemStateEnum;\n+import io.github.hapjava.characteristics.impl.securitysystem.TargetSecuritySystemStateEnum;\n+import io.github.hapjava.services.impl.SecuritySystemService;\n+\n+/**\n+ *  Implements SecuritySystem as a GroupedAccessory made up of multiple items:\n+ *  <ul>\n+ *  <li>CurrentSecuritySystemState: String type</li>\n+ *  <li>TargetSecuritySystemState: String type</li>\n+ *  </ul>\n+ * @author Cody Cutrer - Initial contribution\n+ */\n+public class HomekitSecuritySystemImpl extends AbstractHomekitAccessoryImpl implements SecuritySystemAccessory {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(HomekitSecuritySystemImpl.class);\n+\n+    public HomekitSecuritySystemImpl(HomekitTaggedItem taggedItem, List<HomekitTaggedItem> mandatoryCharacteristics, HomekitAccessoryUpdater updater, HomekitSettings settings) throws IncompleteAccessoryException {\n+        super(taggedItem, mandatoryCharacteristics, updater, settings);\n+        getServices().add(new SecuritySystemService(this));\n+    }\n+\n+    @Override\n+    public CompletableFuture<CurrentSecuritySystemStateEnum> getCurrentSecuritySystemState() {\n+        CurrentSecuritySystemStateEnum state;\n+        final @Nullable State itemState = getStateAs(HomekitCharacteristicType.SECURITY_SYSTEM_CURRENT_STATE, StringType.class);\n+        if (itemState!=null) {\n+            String stringValue = itemState.toString();\n+            if (stringValue.equalsIgnoreCase(\"DISARMED\")) {", "originalCommit": "b4c1bba476ec0a464676397686f83d94a3f0fda7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1Mjc3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r418752771", "bodyText": "Arrays.asList uses ... arguments so you don't need to pass in a string array, just the arguments.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return Arrays.asList(new String[] { buildCommandUsage(SUBCMD_LIST_ACCESSORIES, \"list all HomeKit accessories\"),\n          \n          \n            \n                            buildCommandUsage(SUBCMD_PRINT_ACCESSORY + \" <accessory id>\", \"print accessorty details\"),\n          \n          \n            \n                            buildCommandUsage(SUBCMD_CLEAR_PAIRINGS, \"removes all pairings with HomeKit clients\"),\n          \n          \n            \n                            buildCommandUsage(SUBCMD_ALLOW_UNAUTHENTICATED + \" <boolean>\",\n          \n          \n            \n                                    \"enables or disables unauthenticated access to facilitate debugging\") });\n          \n          \n            \n                    return Arrays.asList(buildCommandUsage(SUBCMD_LIST_ACCESSORIES, \"list all HomeKit accessories\"),\n          \n          \n            \n                            buildCommandUsage(SUBCMD_PRINT_ACCESSORY + \" <accessory id>\", \"print accessorty details\"),\n          \n          \n            \n                            buildCommandUsage(SUBCMD_CLEAR_PAIRINGS, \"removes all pairings with HomeKit clients\"),\n          \n          \n            \n                            buildCommandUsage(SUBCMD_ALLOW_UNAUTHENTICATED + \" <boolean>\",\n          \n          \n            \n                                    \"enables or disables unauthenticated access to facilitate debugging\"));", "author": "cpmeister", "createdAt": "2020-05-01T21:49:20Z", "path": "bundles/org.openhab.io.homekit/src/main/java/org/openhab/io/homekit/internal/HomekitCommandExtension.java", "diffHunk": "@@ -71,10 +84,11 @@ public void execute(String[] args, Console console) {\n \n     @Override\n     public List<String> getUsages() {\n-        return Arrays.asList(\n-                new String[] { buildCommandUsage(SUBCMD_CLEAR_PAIRINGS, \"removes all pairings with HomeKit clients\"),\n-                        buildCommandUsage(SUBCMD_ALLOW_UNAUTHENTICATED + \" <boolean>\",\n-                                \"enables or disables unauthenticated access to facilitate debugging\") });\n+        return Arrays.asList(new String[] { buildCommandUsage(SUBCMD_LIST_ACCESSORIES, \"list all HomeKit accessories\"),\n+                buildCommandUsage(SUBCMD_PRINT_ACCESSORY + \" <accessory id>\", \"print accessorty details\"),\n+                buildCommandUsage(SUBCMD_CLEAR_PAIRINGS, \"removes all pairings with HomeKit clients\"),\n+                buildCommandUsage(SUBCMD_ALLOW_UNAUTHENTICATED + \" <boolean>\",\n+                        \"enables or disables unauthenticated access to facilitate debugging\") });", "originalCommit": "580ad0df55c3d1782ed3e5751c52bc756889a322", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1MzA2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r418753069", "bodyText": "The error logging level should be reserved for issues catastrophic enough to threaten the operation of openHab itself. An error in a binding shouldn't qualify for this. Please read the openHab coding guidelines for expected use of logging in bindings.\nMy general rule for logging levels is:\n\ntrace - used for normal expected execution paths\ndebug - used for unexepected execution paths, but well within normal operation\ninfo - used for notable points in an execution path, like a milestone. (in openhab we try reserve this logging level for the core, so bindings should rarely ever call this.)\nwarn - used for notable unexpected execution paths that a regular user (not just a developer) should be notified of. Warnings should be used to indicate that something not-normal occurred and user intervention is required to resolve. Warnings do not indicate a failure to operate merely an abnormal condition of operation that can still be handled by the binding. Failures in binding operation should be indicated by changing the thing status to offline.\nerror - used to indicate catastrophic program failure. This should be used to indicate a catastrophic failure in openhab's ability to operate. A failure in a binding would never cause openhab as a whole to fail so a failure in a bindings should never log an error. Instead that failure should be indicated by changing the thing status.", "author": "cpmeister", "createdAt": "2020-05-01T21:50:15Z", "path": "bundles/org.openhab.io.homekit/src/main/java/org/openhab/io/homekit/internal/HomekitCommandExtension.java", "diffHunk": "@@ -109,4 +123,35 @@ private void allowUnauthenticatedHomekitRequests(boolean allow, Console console)\n         homekit.allowUnauthenticatedRequests(allow);\n         console.println((allow ? \"Enabled \" : \"Disabled \") + \"unauthenticated HomeKit access\");\n     }\n+\n+    private void listAccessories(Console console) {\n+        homekit.getAccessories().stream().forEach(v -> {\n+            try {\n+                console.println(v.getId() + \" \" + v.getName().get());\n+            } catch (InterruptedException | ExecutionException e) {\n+                logger.error(\"Cannot list accessories\", e);", "originalCommit": "580ad0df55c3d1782ed3e5751c52bc756889a322", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzNjMyMg==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r418936322", "bodyText": "thanks for clear guidance. i have reviewed and just all the logging. no error anymore, one info and one debug. all others are either trace or warn", "author": "yfre", "createdAt": "2020-05-02T09:29:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1MzA2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1MzEzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r418753131", "bodyText": "remove blank line", "author": "cpmeister", "createdAt": "2020-05-01T21:50:29Z", "path": "bundles/org.openhab.io.homekit/src/main/java/org/openhab/io/homekit/internal/HomekitCommandExtension.java", "diffHunk": "@@ -109,4 +123,35 @@ private void allowUnauthenticatedHomekitRequests(boolean allow, Console console)\n         homekit.allowUnauthenticatedRequests(allow);\n         console.println((allow ? \"Enabled \" : \"Disabled \") + \"unauthenticated HomeKit access\");\n     }\n+\n+    private void listAccessories(Console console) {\n+        homekit.getAccessories().stream().forEach(v -> {\n+            try {\n+                console.println(v.getId() + \" \" + v.getName().get());\n+            } catch (InterruptedException | ExecutionException e) {\n+                logger.error(\"Cannot list accessories\", e);\n+            }\n+        });\n+    }\n+\n+    private void printAccessory(Integer accessory_id, Console console) {\n+", "originalCommit": "580ad0df55c3d1782ed3e5751c52bc756889a322", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1MzQwOA==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r418753408", "bodyText": "Why all the extra spaces?", "author": "cpmeister", "createdAt": "2020-05-01T21:51:29Z", "path": "bundles/org.openhab.io.homekit/src/main/java/org/openhab/io/homekit/internal/HomekitSettings.java", "diffHunk": "@@ -32,7 +34,7 @@\n     public String thermostatTargetModeAuto = \"Auto\";\n     public String thermostatTargetModeOff = \"Off\";\n     public String thermostatCurrentModeHeating = \"Heating\";\n-    public String thermostatCurrentModeCooling = \"Cooling\";\n+    public String thermostatCurrentModeCooling = \"Cooling   \";", "originalCommit": "580ad0df55c3d1782ed3e5751c52bc756889a322", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1MzczNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r418753735", "bodyText": "please adjust logging level", "author": "cpmeister", "createdAt": "2020-05-01T21:52:34Z", "path": "bundles/org.openhab.io.homekit/src/main/java/org/openhab/io/homekit/internal/HomekitAccessoryRegistry.java", "diffHunk": "@@ -37,9 +38,23 @@\n     private @Nullable HomekitRoot bridge;\n     private final Map<String, HomekitAccessory> createdAccessories = new HashMap<>();\n     private final Set<Integer> createdIds = new HashSet<>();\n-\n+    private int configurationRevision = 1;\n     private final Logger logger = LoggerFactory.getLogger(HomekitAccessoryRegistry.class);\n \n+    public void setConfigurationRevision(int revision) {\n+        configurationRevision = revision;\n+    }\n+\n+    public int makeNewConfigurationRevision() {\n+        configurationRevision = (configurationRevision + 1) % 65535;\n+        try {\n+            bridge.setConfigurationIndex(configurationRevision);\n+        } catch (IOException e) {\n+            logger.error(\"Could not update configuration revision number\", e);", "originalCommit": "580ad0df55c3d1782ed3e5751c52bc756889a322", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1NDU3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r418754571", "bodyText": "Are you sure that reference equality is appropriate here?", "author": "cpmeister", "createdAt": "2020-05-01T21:55:10Z", "path": "bundles/org.openhab.io.homekit/src/main/java/org/openhab/io/homekit/internal/HomekitChangeListener.java", "diffHunk": "@@ -159,18 +187,38 @@ public void stop() {\n         this.itemRegistry.removeRegistryChangeListener(this);\n     }\n \n+    public Map<String, HomekitAccessory> getAccessories() {\n+        return this.accessoryRegistry.getAllAccessories();\n+    }\n+\n+    /**\n+     * creates one or more HomeKit items for given openhab item.\n+     * one openhab item can linked to several HomeKit accessories or characteristics.\n+     * \n+     * @param item\n+     */\n+    private void createRootAccessories(Item item) {\n+        logger.debug(\"create root accessory {}\", item.getLabel());\n+        final List<Entry<HomekitAccessoryType, HomekitCharacteristicType>> accessoryTypes = HomekitAccessoryFactory\n+                .getAccessoryTypes(item, metadataRegistry);\n+        final List<GroupItem> groups = HomekitAccessoryFactory.getAccessoryGroups(item, itemRegistry, metadataRegistry);\n+        logger.debug(\"Item {} has groups {}\", item.getName(), groups);\n+        if (!accessoryTypes.isEmpty() && groups.isEmpty()) { // it has homekit accessory type and is not part of bigger\n+                                                             // homekit group item\n+            logger.debug(\"Item {} is a HomeKit accessory of types {}\", item.getName(), accessoryTypes);\n+            accessoryTypes.stream().filter(accessory -> accessory.getValue() == EMPTY) // no characteristic => root", "originalCommit": "580ad0df55c3d1782ed3e5751c52bc756889a322", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzNDE4OA==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r418934188", "bodyText": "to my knowledge java enum \"equals\" maps directly to \"==\".", "author": "yfre", "createdAt": "2020-05-02T09:05:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1NDU3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA0NTgyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r419045829", "bodyText": "That is correct, I was just checking since it wasn't immediately apparent what class EMPTY was.", "author": "cpmeister", "createdAt": "2020-05-03T04:34:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1NDU3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1NDc2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r418754761", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.info(\"Created {} HomeKit items.\", accessoryRegistry.getAllAccessories().size());\n          \n          \n            \n                    logger.debug(\"Created {} HomeKit items.\", accessoryRegistry.getAllAccessories().size());", "author": "cpmeister", "createdAt": "2020-05-01T21:55:52Z", "path": "bundles/org.openhab.io.homekit/src/main/java/org/openhab/io/homekit/internal/HomekitChangeListener.java", "diffHunk": "@@ -61,17 +73,31 @@\n      */\n     private final Debouncer applyUpdatesDebouncer;\n \n-    HomekitChangeListener(ItemRegistry itemRegistry, HomekitSettings settings) {\n+    HomekitChangeListener(ItemRegistry itemRegistry, HomekitSettings settings, MetadataRegistry metadataRegistry,\n+            final StorageService storageService) {\n         this.itemRegistry = itemRegistry;\n         this.settings = settings;\n+        this.metadataRegistry = metadataRegistry;\n+        storage = storageService.getStorage(\"homekit\");\n+        initialiseRevision();\n+\n         this.applyUpdatesDebouncer = new Debouncer(\"update-homekit-devices\", scheduler, Duration.ofMillis(1000),\n                 Clock.systemUTC(), this::applyUpdates);\n \n         itemRegistry.addRegistryChangeListener(this);\n-        itemRegistry.getAll().stream().map(item -> new HomekitTaggedItem(item, itemRegistry))\n-                .filter(taggedItem -> taggedItem.isAccessory())\n-                .filter(taggedItem -> !taggedItem.isMemberOfAccessoryGroup())\n-                .forEach(rootTaggedItem -> createRootAccessory(rootTaggedItem));\n+        itemRegistry.getItems().stream().forEach(this::createRootAccessories);\n+        logger.info(\"Created {} HomeKit items.\", accessoryRegistry.getAllAccessories().size());", "originalCommit": "580ad0df55c3d1782ed3e5751c52bc756889a322", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkyMzU0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r418923545", "bodyText": "I think it\u2018s ok at INFO. It\u2018s not logged very often (only on startup) and is a useful information, not only in situations where you need to debug something.", "author": "J-N-K", "createdAt": "2020-05-02T07:06:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1NDc2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1NTA5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r418755099", "bodyText": "Please adjust the logging level", "author": "cpmeister", "createdAt": "2020-05-01T21:56:50Z", "path": "bundles/org.openhab.io.homekit/src/main/java/org/openhab/io/homekit/internal/HomekitCommandExtension.java", "diffHunk": "@@ -109,4 +123,35 @@ private void allowUnauthenticatedHomekitRequests(boolean allow, Console console)\n         homekit.allowUnauthenticatedRequests(allow);\n         console.println((allow ? \"Enabled \" : \"Disabled \") + \"unauthenticated HomeKit access\");\n     }\n+\n+    private void listAccessories(Console console) {\n+        homekit.getAccessories().stream().forEach(v -> {\n+            try {\n+                console.println(v.getId() + \" \" + v.getName().get());\n+            } catch (InterruptedException | ExecutionException e) {\n+                logger.error(\"Cannot list accessories\", e);\n+            }\n+        });\n+    }\n+\n+    private void printAccessory(Integer accessory_id, Console console) {\n+\n+        homekit.getAccessories().forEach(v -> {\n+            try {\n+                if (v.getId() == accessory_id) {\n+                    console.println(v.getId() + \" \" + v.getName().get());\n+                    console.println(\"Services:\");\n+                    v.getServices().forEach(s -> {\n+                        console.println(\"    Service Type: \" + s.getType());\n+                        console.println(\"    Characteristics: \");\n+                        s.getCharacteristics().forEach(c -> {\n+                            console.println(\"      : \" + c.getClass());\n+                        });\n+                    });\n+                }\n+            } catch (InterruptedException | ExecutionException e) {\n+                logger.error(\"Cannot print accessory\", e);", "originalCommit": "580ad0df55c3d1782ed3e5751c52bc756889a322", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1NjA0NA==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r418756044", "bodyText": "please make logger final\nAlso change its variable name to lower case.", "author": "cpmeister", "createdAt": "2020-05-01T21:59:49Z", "path": "bundles/org.openhab.io.homekit/src/main/java/org/openhab/io/homekit/internal/accessories/AbstractHomekitAccessoryImpl.java", "diffHunk": "@@ -12,95 +12,160 @@\n  */\n package org.openhab.io.homekit.internal.accessories;\n \n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.Nullable;\n import org.eclipse.smarthome.core.items.GenericItem;\n-import org.eclipse.smarthome.core.items.GroupItem;\n import org.eclipse.smarthome.core.items.Item;\n-import org.eclipse.smarthome.core.items.ItemRegistry;\n+import org.eclipse.smarthome.core.types.State;\n import org.openhab.io.homekit.internal.HomekitAccessoryUpdater;\n+import org.openhab.io.homekit.internal.HomekitCharacteristicType;\n+import org.openhab.io.homekit.internal.HomekitSettings;\n import org.openhab.io.homekit.internal.HomekitTaggedItem;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import io.github.hapjava.HomekitAccessory;\n+import io.github.hapjava.accessories.HomekitAccessory;\n+import io.github.hapjava.characteristics.HomekitCharacteristicChangeCallback;\n+import io.github.hapjava.services.Service;\n \n /**\n- * Abstract class for HomekitAccessory implementations, this provides the\n+ * Abstract class for Homekit Accessory implementations, this provides the\n  * accessory metadata using information from the underlying Item.\n  *\n  * @author Andy Lintner - Initial contribution\n  */\n-abstract class AbstractHomekitAccessoryImpl<T extends GenericItem> implements HomekitAccessory {\n-\n-    private final int accessoryId;\n-    private final String itemName;\n-    private final String itemLabel;\n-    private final ItemRegistry itemRegistry;\n+abstract class AbstractHomekitAccessoryImpl implements HomekitAccessory {\n+    private Logger LOGGER = LoggerFactory.getLogger(AbstractHomekitAccessoryImpl.class);", "originalCommit": "580ad0df55c3d1782ed3e5751c52bc756889a322", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzNDU3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r418934571", "bodyText": "ok. changed LOGGER to lower case in all classes.", "author": "yfre", "createdAt": "2020-05-02T09:09:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1NjA0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1NjQ1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r418756457", "bodyText": "I think it is already implied that T is an object\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected @NonNull <T extends Object> T getAccessoryConfiguration(@NonNull String key, @NonNull T defaultValue) {\n          \n          \n            \n                protected @NonNull <T> T getAccessoryConfiguration(@NonNull String key, @NonNull T defaultValue) {", "author": "cpmeister", "createdAt": "2020-05-01T22:01:15Z", "path": "bundles/org.openhab.io.homekit/src/main/java/org/openhab/io/homekit/internal/accessories/AbstractHomekitAccessoryImpl.java", "diffHunk": "@@ -12,95 +12,160 @@\n  */\n package org.openhab.io.homekit.internal.accessories;\n \n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.Nullable;\n import org.eclipse.smarthome.core.items.GenericItem;\n-import org.eclipse.smarthome.core.items.GroupItem;\n import org.eclipse.smarthome.core.items.Item;\n-import org.eclipse.smarthome.core.items.ItemRegistry;\n+import org.eclipse.smarthome.core.types.State;\n import org.openhab.io.homekit.internal.HomekitAccessoryUpdater;\n+import org.openhab.io.homekit.internal.HomekitCharacteristicType;\n+import org.openhab.io.homekit.internal.HomekitSettings;\n import org.openhab.io.homekit.internal.HomekitTaggedItem;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import io.github.hapjava.HomekitAccessory;\n+import io.github.hapjava.accessories.HomekitAccessory;\n+import io.github.hapjava.characteristics.HomekitCharacteristicChangeCallback;\n+import io.github.hapjava.services.Service;\n \n /**\n- * Abstract class for HomekitAccessory implementations, this provides the\n+ * Abstract class for Homekit Accessory implementations, this provides the\n  * accessory metadata using information from the underlying Item.\n  *\n  * @author Andy Lintner - Initial contribution\n  */\n-abstract class AbstractHomekitAccessoryImpl<T extends GenericItem> implements HomekitAccessory {\n-\n-    private final int accessoryId;\n-    private final String itemName;\n-    private final String itemLabel;\n-    private final ItemRegistry itemRegistry;\n+abstract class AbstractHomekitAccessoryImpl implements HomekitAccessory {\n+    private Logger LOGGER = LoggerFactory.getLogger(AbstractHomekitAccessoryImpl.class);\n+    protected List<HomekitTaggedItem> characteristics;\n+    private final HomekitTaggedItem accessory;\n     private final HomekitAccessoryUpdater updater;\n+    private final HomekitSettings settings;\n+    private final List<Service> services;\n \n-    protected Logger logger = LoggerFactory.getLogger(AbstractHomekitAccessoryImpl.class);\n-\n-    @SuppressWarnings(\"null\")\n-    public AbstractHomekitAccessoryImpl(HomekitTaggedItem taggedItem, ItemRegistry itemRegistry,\n-            HomekitAccessoryUpdater updater, Class<T> expectedItemClass) {\n-        this.accessoryId = taggedItem.getId();\n-        this.itemName = taggedItem.getItem().getName();\n-        this.itemLabel = taggedItem.getItem().getLabel();\n-        this.itemRegistry = itemRegistry;\n+    public AbstractHomekitAccessoryImpl(HomekitTaggedItem accessory, List<HomekitTaggedItem> characteristics,\n+            HomekitAccessoryUpdater updater, HomekitSettings settings) throws IncompleteAccessoryException {\n+        this.characteristics = characteristics;\n+        this.accessory = accessory;\n         this.updater = updater;\n-        Item baseItem = taggedItem.getItem();\n-        if (baseItem instanceof GroupItem && ((GroupItem) baseItem).getBaseItem() != null) {\n-            baseItem = ((GroupItem) baseItem).getBaseItem();\n-        }\n-        if (expectedItemClass != taggedItem.getItem().getClass()\n-                && !expectedItemClass.isAssignableFrom(baseItem.getClass())) {\n-            logger.warn(\"Item {} is of type {} instead of the expected {}\", taggedItem.getItem().getName(),\n-                    baseItem.getClass().getName(), expectedItemClass.getName());\n-        }\n+        this.services = new ArrayList<>();\n+        this.settings = settings;\n+    }\n+\n+    protected Optional<HomekitTaggedItem> getCharacteristic(HomekitCharacteristicType type) {\n+        return characteristics.stream().filter(c -> c.getCharacteristicType().equals(type)).findAny();\n     }\n \n     @Override\n     public int getId() {\n-        return accessoryId;\n+        return accessory.getId();\n+    }\n+\n+    @Override\n+    public CompletableFuture<String> getName() {\n+        return CompletableFuture.completedFuture(accessory.getItem().getLabel());\n     }\n \n     @Override\n-    public String getLabel() {\n-        return itemLabel;\n+    public CompletableFuture<String> getManufacturer() {\n+        return CompletableFuture.completedFuture(\"none\");\n     }\n \n     @Override\n-    public String getManufacturer() {\n-        return \"none\";\n+    public CompletableFuture<String> getModel() {\n+        return CompletableFuture.completedFuture(\"none\");\n     }\n \n     @Override\n-    public String getModel() {\n-        return \"none\";\n+    public CompletableFuture<String> getSerialNumber() {\n+        return CompletableFuture.completedFuture(\"none\");\n     }\n \n     @Override\n-    public String getSerialNumber() {\n-        return \"none\";\n+    public CompletableFuture<String> getFirmwareRevision() {\n+        return CompletableFuture.completedFuture(\"none\");\n     }\n \n     @Override\n     public void identify() {\n         // We're not going to support this for now\n     }\n \n-    protected ItemRegistry getItemRegistry() {\n-        return itemRegistry;\n+    public HomekitTaggedItem getRootAccessory() {\n+        return accessory;\n     }\n \n-    protected String getItemName() {\n-        return itemName;\n+    public Collection<Service> getServices() {\n+        return this.services;\n     }\n \n     protected HomekitAccessoryUpdater getUpdater() {\n         return updater;\n     }\n \n-    protected GenericItem getItem() {\n-        return (GenericItem) getItemRegistry().get(getItemName());\n+    protected HomekitSettings getSettings() {\n+        return settings;\n+    }\n+\n+    protected void subscribe(HomekitCharacteristicType characteristicType,\n+            HomekitCharacteristicChangeCallback callback) {\n+        final Optional<HomekitTaggedItem> characteristic = getCharacteristic(characteristicType);\n+        if (characteristic.isPresent()) {\n+            getUpdater().subscribe((GenericItem) characteristic.get().getItem(), characteristicType.getTag(), callback);\n+        } else {\n+            LOGGER.error(\"Missing mandatory characteristic {}\", characteristicType);\n+        }\n+    }\n+\n+    protected void unsubscribe(HomekitCharacteristicType characteristicType) {\n+        final Optional<HomekitTaggedItem> characteristic = getCharacteristic(characteristicType);\n+        if (characteristic.isPresent()) {\n+            getUpdater().unsubscribe((GenericItem) characteristic.get().getItem(), characteristicType.getTag());\n+        } else {\n+            LOGGER.error(\"Missing mandatory characteristic {}\", characteristicType);\n+        }\n+    }\n+\n+    protected @Nullable <T extends State> T getStateAs(HomekitCharacteristicType characteristic, Class type) {\n+        final Optional<HomekitTaggedItem> taggedItem = getCharacteristic(characteristic);\n+        if (taggedItem.isPresent() && taggedItem.get().getItem().getState() != null) {\n+            return (T) taggedItem.get().getItem().getStateAs(type);\n+        }\n+        LOGGER.error(\"State for characteristic {} at accessory {} cannot be retrieved.\", characteristic,\n+                accessory.getId());\n+\n+        return null;\n+    }\n+\n+    protected @Nullable <T extends Item> T getItem(HomekitCharacteristicType characteristic, Class<T> type) {\n+        final Optional<HomekitTaggedItem> taggedItem = getCharacteristic(characteristic);\n+        if (taggedItem.isPresent()) {\n+            if (type.isInstance(taggedItem.get().getItem()))\n+                return (T) getCharacteristic(characteristic).get().getItem();\n+            else\n+                LOGGER.error(\"Unsupported item type for characteristic {} at accessory {}. Expected {}, got {}\",\n+                        characteristic, accessory.getItem().getLabel(), type, taggedItem.get().getItem().getClass());\n+        } else {\n+            LOGGER.error(\"Mandatory characteristic {} not found at accessory {}. \", characteristic,\n+                    accessory.getItem().getLabel());\n+\n+        }\n+        return null;\n+    }\n+\n+    protected @NonNull <T extends Object> T getAccessoryConfiguration(@NonNull String key, @NonNull T defaultValue) {", "originalCommit": "580ad0df55c3d1782ed3e5751c52bc756889a322", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1NjY1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r418756656", "bodyText": "Please add @NonNullByDefault", "author": "cpmeister", "createdAt": "2020-05-01T22:01:53Z", "path": "bundles/org.openhab.io.homekit/src/main/java/org/openhab/io/homekit/internal/accessories/AbstractHomekitAccessoryImpl.java", "diffHunk": "@@ -12,95 +12,160 @@\n  */\n package org.openhab.io.homekit.internal.accessories;\n \n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.Nullable;\n import org.eclipse.smarthome.core.items.GenericItem;\n-import org.eclipse.smarthome.core.items.GroupItem;\n import org.eclipse.smarthome.core.items.Item;\n-import org.eclipse.smarthome.core.items.ItemRegistry;\n+import org.eclipse.smarthome.core.types.State;\n import org.openhab.io.homekit.internal.HomekitAccessoryUpdater;\n+import org.openhab.io.homekit.internal.HomekitCharacteristicType;\n+import org.openhab.io.homekit.internal.HomekitSettings;\n import org.openhab.io.homekit.internal.HomekitTaggedItem;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import io.github.hapjava.HomekitAccessory;\n+import io.github.hapjava.accessories.HomekitAccessory;\n+import io.github.hapjava.characteristics.HomekitCharacteristicChangeCallback;\n+import io.github.hapjava.services.Service;\n \n /**\n- * Abstract class for HomekitAccessory implementations, this provides the\n+ * Abstract class for Homekit Accessory implementations, this provides the\n  * accessory metadata using information from the underlying Item.\n  *\n  * @author Andy Lintner - Initial contribution\n  */\n-abstract class AbstractHomekitAccessoryImpl<T extends GenericItem> implements HomekitAccessory {\n-\n-    private final int accessoryId;\n-    private final String itemName;\n-    private final String itemLabel;\n-    private final ItemRegistry itemRegistry;\n+abstract class AbstractHomekitAccessoryImpl implements HomekitAccessory {", "originalCommit": "580ad0df55c3d1782ed3e5751c52bc756889a322", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1NzUyOA==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r418757528", "bodyText": "This NonNull  annotation it redundant.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static @NonNull List<HomekitTaggedItem> getMandatoryCharacteristics(HomekitTaggedItem taggedItem,\n          \n          \n            \n                private static List<HomekitTaggedItem> getMandatoryCharacteristics(HomekitTaggedItem taggedItem,", "author": "cpmeister", "createdAt": "2020-05-01T22:04:51Z", "path": "bundles/org.openhab.io.homekit/src/main/java/org/openhab/io/homekit/internal/accessories/HomekitAccessoryFactory.java", "diffHunk": "@@ -12,156 +12,417 @@\n  */\n package org.openhab.io.homekit.internal.accessories;\n \n+import static org.openhab.io.homekit.internal.HomekitAccessoryType.*;\n+import static org.openhab.io.homekit.internal.HomekitCharacteristicType.*;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.AbstractMap.SimpleEntry;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n+import java.util.Map.Entry;\n import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.items.GenericItem;\n import org.eclipse.smarthome.core.items.GroupItem;\n import org.eclipse.smarthome.core.items.Item;\n import org.eclipse.smarthome.core.items.ItemRegistry;\n+import org.eclipse.smarthome.core.items.Metadata;\n+import org.eclipse.smarthome.core.items.MetadataKey;\n+import org.eclipse.smarthome.core.items.MetadataRegistry;\n+import org.eclipse.smarthome.core.library.items.ColorItem;\n+import org.eclipse.smarthome.core.library.items.DimmerItem;\n import org.openhab.io.homekit.internal.HomekitAccessoryType;\n import org.openhab.io.homekit.internal.HomekitAccessoryUpdater;\n import org.openhab.io.homekit.internal.HomekitCharacteristicType;\n import org.openhab.io.homekit.internal.HomekitException;\n import org.openhab.io.homekit.internal.HomekitSettings;\n import org.openhab.io.homekit.internal.HomekitTaggedItem;\n-import org.openhab.io.homekit.internal.battery.BatteryStatus;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import io.github.hapjava.HomekitAccessory;\n+import io.github.hapjava.accessories.HomekitAccessory;\n+import io.github.hapjava.characteristics.Characteristic;\n+import io.github.hapjava.services.Service;\n \n /**\n  * Creates a HomekitAccessory for a given HomekitTaggedItem.\n  *\n  * @author Andy Lintner - Initial contribution\n+ * @author Eugen Freiter - refactoring for optional characteristics\n  */\n+@NonNullByDefault\n public class HomekitAccessoryFactory {\n     private static final Logger LOGGER = LoggerFactory.getLogger(HomekitAccessoryFactory.class);\n+    public final static String METADATA_KEY = \"homekit\"; // prefix for HomeKit meta information in items.xml\n+\n+    /** List of mandatory attributes for each accessory type. **/\n+    private final static Map<HomekitAccessoryType, HomekitCharacteristicType[]> mandatoryCharacteristics = new HashMap<HomekitAccessoryType, HomekitCharacteristicType[]>() {\n+        {\n+            put(LEAK_SENSOR, new HomekitCharacteristicType[] { LEAK_DETECTED_STATE });\n+            put(MOTION_SENSOR, new HomekitCharacteristicType[] { MOTION_DETECTED_STATE });\n+            put(OCCUPANCY_SENSOR, new HomekitCharacteristicType[] { OCCUPANCY_DETECTED_STATE });\n+            put(CONTACT_SENSOR, new HomekitCharacteristicType[] { CONTACT_SENSOR_STATE });\n+            put(SMOKE_SENSOR, new HomekitCharacteristicType[] { SMOKE_DETECTED_STATE });\n+            put(HUMIDITY_SENSOR, new HomekitCharacteristicType[] { RELATIVE_HUMIDITY });\n+            put(SWITCH, new HomekitCharacteristicType[] { ON_STATE });\n+            put(CARBON_DIOXIDE_SENSOR, new HomekitCharacteristicType[] { CARBON_DIOXIDE_DETECTED_STATE });\n+            put(CARBON_MONOXIDE_SENSOR, new HomekitCharacteristicType[] { CARBON_MONOXIDE_DETECTED_STATE });\n+            put(WINDOW_COVERING, new HomekitCharacteristicType[] { TARGET_POSITION, CURRENT_POSITION, POSITION_STATE });\n+            put(LIGHTBULB, new HomekitCharacteristicType[] { ON_STATE });\n+            put(FAN, new HomekitCharacteristicType[] { ACTIVE_STATUS });\n+            put(TEMPERATURE_SENSOR, new HomekitCharacteristicType[] { CURRENT_TEMPERATURE });\n+            put(THERMOSTAT, new HomekitCharacteristicType[] { CURRENT_HEATING_COOLING_STATE,\n+                    TARGET_HEATING_COOLING_STATE, CURRENT_TEMPERATURE, TARGET_TEMPERATURE });\n+            put(LOCK, new HomekitCharacteristicType[] { LOCK_CURRENT_STATE, LOCK_TARGET_STATE });\n+            put(VALVE, new HomekitCharacteristicType[] { ACTIVE_STATUS, INUSE_STATUS });\n+            put(SECURITY_SYSTEM,\n+                    new HomekitCharacteristicType[] { SECURITY_SYSTEM_CURRENT_STATE, SECURITY_SYSTEM_TARGET_STATE });\n+            // LEGACY\n+            put(BLINDS, new HomekitCharacteristicType[] { TARGET_POSITION, CURRENT_POSITION, POSITION_STATE });\n+            put(OLD_HUMIDITY_SENSOR, new HomekitCharacteristicType[] { RELATIVE_HUMIDITY });\n+            put(OLD_DIMMABLE_LIGHTBULB, new HomekitCharacteristicType[] { ON_STATE });\n+            put(OLD_COLORFUL_LIGHTBULB, new HomekitCharacteristicType[] { ON_STATE });\n+        }\n+    };\n+\n+    /** List of service implementation for each accessory type. **/\n+    private final static Map<HomekitAccessoryType, Class<? extends AbstractHomekitAccessoryImpl>> serviceImplMap = new HashMap<HomekitAccessoryType, Class<? extends AbstractHomekitAccessoryImpl>>() {\n+        {\n+            put(LEAK_SENSOR, HomekitLeakSensorImpl.class);\n+            put(MOTION_SENSOR, HomekitMotionSensorImpl.class);\n+            put(OCCUPANCY_SENSOR, HomekitOccupancySensorImpl.class);\n+            put(CONTACT_SENSOR, HomekitContactSensorImpl.class);\n+            put(TEMPERATURE_SENSOR, HomekitTemperatureSensorImpl.class);\n+            put(SMOKE_SENSOR, HomekitSmokeSensorImpl.class);\n+            put(HUMIDITY_SENSOR, HomekitHumiditySensorImpl.class);\n+            put(SWITCH, HomekitSwitchImpl.class);\n+            put(CARBON_DIOXIDE_SENSOR, HomekitCarbonDioxideSensorImpl.class);\n+            put(CARBON_MONOXIDE_SENSOR, HomekitCarbonMonoxideSensorImpl.class);\n+            put(WINDOW_COVERING, HomekitWindowCoveringImpl.class);\n+            put(LIGHTBULB, HomekitLightbulbImpl.class);\n+            put(FAN, HomekitFanImpl.class);\n+            put(TEMPERATURE_SENSOR, HomekitTemperatureSensorImpl.class);\n+            put(THERMOSTAT, HomekitThermostatImpl.class);\n+            put(LOCK, HomekitLockImpl.class);\n+            put(VALVE, HomekitValveImpl.class);\n+            put(SECURITY_SYSTEM, HomekitSecuritySystemImpl.class);\n+            put(BLINDS, HomekitWindowCoveringImpl.class);\n+            put(OLD_HUMIDITY_SENSOR, HomekitHumiditySensorImpl.class);\n+            put(OLD_DIMMABLE_LIGHTBULB, HomekitLightbulbImpl.class);\n+            put(OLD_COLORFUL_LIGHTBULB, HomekitLightbulbImpl.class);\n+\n+        }\n+    };\n+\n+    /** mapping of legacy attributes to new attributes. **/\n+    private final static Map<HomekitCharacteristicType, HomekitCharacteristicType> legacyCharacteristicsMapping = new HashMap<HomekitCharacteristicType, HomekitCharacteristicType>() {\n+        {\n+            put(OLD_CURRENT_HEATING_COOLING_STATE, CURRENT_HEATING_COOLING_STATE);\n+            put(OLD_TARGET_HEATING_COOLING_MODE, TARGET_HEATING_COOLING_STATE);\n+            put(OLD_TARGET_TEMPERATURE, TARGET_TEMPERATURE);\n+            put(OLD_BATTERY_LOW_STATUS, BATTERY_LOW_STATUS);\n+            put(VERY_OLD_TARGET_HEATING_COOLING_MODE, CURRENT_HEATING_COOLING_STATE);\n+        }\n+    };\n+\n+    /** list of optional implicit optional characteristics. mainly used for legacy accessory type */\n+    private final static Map<HomekitAccessoryType, HomekitCharacteristicType[]> implicitOptionalCharacteristics = new HashMap<HomekitAccessoryType, HomekitCharacteristicType[]>() {\n+        {\n+            put(OLD_DIMMABLE_LIGHTBULB, new HomekitCharacteristicType[] { BRIGHTNESS });\n+            put(OLD_COLORFUL_LIGHTBULB, new HomekitCharacteristicType[] { HUE, SATURATION, BRIGHTNESS });\n+\n+        }\n+    };\n+\n+    /**\n+     * creates HomeKit accessory for a openhab item.\n+     * \n+     * @param taggedItem openhab item tagged as HomeKit item\n+     * @param metadataRegistry openhab metadata registry required to get item meta information\n+     * @param updater OH HomeKit update class that ensure the status sync between OH item and corresponding HomeKit\n+     *            characteristic.\n+     * @param settings OH settings\n+     * @return HomeKit accessory\n+     * @throws HomekitException exception in case HomeKit accessory could not be created, e.g. due missing mandatory\n+     *             characteristic\n+     */\n+    public static HomekitAccessory create(HomekitTaggedItem taggedItem, MetadataRegistry metadataRegistry,\n+            HomekitAccessoryUpdater updater, HomekitSettings settings) throws HomekitException {\n \n-    @SuppressWarnings(\"deprecation\")\n-    public static HomekitAccessory create(HomekitTaggedItem taggedItem, ItemRegistry itemRegistry,\n-            HomekitAccessoryUpdater updater, HomekitSettings settings)\n-            throws HomekitException, IncompleteAccessoryException {\n         LOGGER.debug(\"Constructing {} of accessoryType {}\", taggedItem.getName(), taggedItem.getAccessoryType());\n+        final List<HomekitTaggedItem> requiredCharacteristics = getMandatoryCharacteristics(taggedItem,\n+                metadataRegistry);\n+        if ((mandatoryCharacteristics.get(taggedItem.getAccessoryType()) != null) && (requiredCharacteristics\n+                .size() < mandatoryCharacteristics.get(taggedItem.getAccessoryType()).length)) {\n+            LOGGER.error(\"Accessory of type {} must have following characteristics {}. Found only {}\",\n+                    taggedItem.getAccessoryType(), mandatoryCharacteristics.get(taggedItem.getAccessoryType()),\n+                    requiredCharacteristics);\n+            throw new HomekitException(\"Missing mandatory characteristics\");\n+        }\n+        AbstractHomekitAccessoryImpl accessoryImpl = null;\n \n-        Map<HomekitCharacteristicType, Item> characteristicItems = getCharacteristicItems(taggedItem);\n-\n-        switch (taggedItem.getAccessoryType()) {\n-            case LEAK_SENSOR:\n-                HomekitTaggedItem leakSensorAccessory = getPrimaryAccessory(taggedItem,\n-                        HomekitAccessoryType.LEAK_SENSOR, itemRegistry).orElseThrow(\n-                                () -> new HomekitException(\"Leak accessory group should have a leak sensor in it\"));\n-\n-                return new HomekitLeakSensorImpl(leakSensorAccessory, itemRegistry, updater,\n-                        BatteryStatus.getFromCharacteristics(characteristicItems));\n-            case VALVE:\n-                return new HomekitValveImpl(taggedItem, itemRegistry, updater);\n-            case MOTION_SENSOR:\n-                HomekitTaggedItem motionSensorAccessory = getPrimaryAccessory(taggedItem,\n-                        HomekitAccessoryType.MOTION_SENSOR, itemRegistry)\n-                                .orElseThrow(() -> new HomekitException(\n-                                        \"Motion sensor accessory group should have a motion sensor item in it\"));\n-                return new HomekitMotionSensorImpl(motionSensorAccessory, itemRegistry, updater,\n-                        BatteryStatus.getFromCharacteristics(characteristicItems));\n-            case OCCUPANCY_SENSOR:\n-                HomekitTaggedItem occupancySensorAccessory = getPrimaryAccessory(taggedItem,\n-                        HomekitAccessoryType.OCCUPANCY_SENSOR, itemRegistry)\n-                                .orElseThrow(() -> new HomekitException(\n-                                        \"Occupancy sensor accessory group should have a occupancy sensor item in it\"));\n-                return new HomekitOccupancySensorImpl(occupancySensorAccessory, itemRegistry, updater,\n-                        BatteryStatus.getFromCharacteristics(characteristicItems));\n-            case CONTACT_SENSOR:\n-                HomekitTaggedItem contactSensorAccessory = getPrimaryAccessory(taggedItem,\n-                        HomekitAccessoryType.CONTACT_SENSOR, itemRegistry)\n-                                .orElseThrow(() -> new HomekitException(\n-                                        \"Contact sensor accessory group should have a occupancy sensor item in it\"));\n-                return new HomekitContactSensorImpl(contactSensorAccessory, itemRegistry, updater,\n-                        BatteryStatus.getFromCharacteristics(characteristicItems));\n-            case LIGHTBULB:\n-                return new HomekitLightbulbImpl(taggedItem, itemRegistry, updater);\n-            case DIMMABLE_LIGHTBULB:\n-                return new HomekitDimmableLightbulbImpl(taggedItem, itemRegistry, updater);\n-            case COLORFUL_LIGHTBULB:\n-                return new HomekitColorfulLightbulbImpl(taggedItem, itemRegistry, updater);\n-            case THERMOSTAT:\n-                HomekitTaggedItem temperatureAccessory = getPrimaryAccessory(taggedItem,\n-                        HomekitAccessoryType.TEMPERATURE_SENSOR, itemRegistry).orElseThrow(\n-                                () -> new HomekitException(\"Thermostats need a CurrentTemperature accessory\"));\n-                return new HomekitThermostatImpl(taggedItem, itemRegistry, updater, settings,\n-                        temperatureAccessory.getItem(), getCharacteristicItems(taggedItem));\n-            case SWITCH:\n-                return new HomekitSwitchImpl(taggedItem, itemRegistry, updater);\n-            case TEMPERATURE_SENSOR:\n-                return new HomekitTemperatureSensorImpl(taggedItem, itemRegistry, updater, settings);\n-            case HUMIDITY_SENSOR:\n-                return new HomekitHumiditySensorImpl(taggedItem, itemRegistry, updater);\n-            case BLINDS:\n-            case WINDOW_COVERING:\n-                return new HomekitWindowCoveringImpl(taggedItem, itemRegistry, updater);\n-            case SMOKE_SENSOR:\n-                HomekitTaggedItem smokeSensorAccessory = getPrimaryAccessory(taggedItem,\n-                        HomekitAccessoryType.SMOKE_SENSOR, itemRegistry).orElseThrow(\n-                                () -> new HomekitException(\"Smoke accessory group should have a smoke sensor in it\"));\n-                return new HomekitSmokeSensorImpl(smokeSensorAccessory, itemRegistry, updater,\n-                        BatteryStatus.getFromCharacteristics(characteristicItems));\n-            case CARBON_MONOXIDE_SENSOR:\n-                HomekitTaggedItem carbonMonoxideSensorAccessory = getPrimaryAccessory(taggedItem,\n-                        HomekitAccessoryType.CARBON_MONOXIDE_SENSOR, itemRegistry)\n-                                .orElseThrow(() -> new HomekitException(\n-                                        \"Carbon monoxide accessory group should have a carbon monoxide sensor in it\"));\n-                return new HomekitSmokeSensorImpl(carbonMonoxideSensorAccessory, itemRegistry, updater,\n-                        BatteryStatus.getFromCharacteristics(characteristicItems));\n-            case LOCK:\n-                return new HomekitLockImpl(taggedItem, itemRegistry, updater);\n+        try {\n+            final Class<? extends AbstractHomekitAccessoryImpl> accessoryImplClass = serviceImplMap\n+                    .get(taggedItem.getAccessoryType());\n+            if (accessoryImplClass != null) {\n+                accessoryImpl = accessoryImplClass\n+                        .getConstructor(HomekitTaggedItem.class, List.class, HomekitAccessoryUpdater.class,\n+                                HomekitSettings.class)\n+                        .newInstance(taggedItem, requiredCharacteristics, updater, settings);\n+                addOptionalCharacteristics(accessoryImpl, metadataRegistry);\n+                return accessoryImpl;\n+            } else {\n+                LOGGER.error(\"Unsupported HomeKit type: {}\", taggedItem.getAccessoryType());\n+                throw new HomekitException(\"Unsupported HomeKit type: \" + taggedItem.getAccessoryType());\n+            }\n+        } catch (NoSuchMethodException | IllegalAccessException | InstantiationException\n+                | InvocationTargetException e) {\n+            LOGGER.error(\"Cannot instantiate accessory implementation for accessory {}\", taggedItem.getAccessoryType(),\n+                    e);\n+            throw new HomekitException(\n+                    \"Cannot instantiate accessory implementation for accessory \" + taggedItem.getAccessoryType());\n         }\n+    }\n+\n+    /**\n+     * return HomeKit accessory types for a OH item based on meta data\n+     * \n+     * @param item OH item\n+     * @param metadataRegistry meta data registry\n+     * @return list of HomeKit accessory types and characteristics.\n+     */\n+    public static List<Entry<HomekitAccessoryType, HomekitCharacteristicType>> getAccessoryTypes(Item item,\n+            MetadataRegistry metadataRegistry) {\n+        final List<Entry<HomekitAccessoryType, HomekitCharacteristicType>> accessories = new ArrayList<>();\n+        Metadata metadata = metadataRegistry.get(new MetadataKey(METADATA_KEY, item.getUID()));\n+        boolean legacyMode = !(metadata != null);\n+        String[] tags = !legacyMode ? metadata.getValue().split(\",\") : item.getTags().toArray(new String[0]); // fallback\n+                                                                                                              // to tags\n \n-        throw new HomekitException(\"Unknown HomeKit type: \" + taggedItem.getAccessoryType());\n+        LOGGER.debug(\"item {} meta data {}  tags {} \", item.getName(), metadata, tags);\n+        for (String tag : tags) {\n+            final String[] meta = tag.split(\"\\\\.\");\n+            Optional<HomekitAccessoryType> accessoryType = HomekitAccessoryType.valueOfTag(meta[0].trim());\n+            if (accessoryType.isPresent()) { // it accessory, check for characteristic\n+                HomekitAccessoryType type = accessoryType.get();\n+                if ((legacyMode) && (type.equals(LIGHTBULB))) { // support old smart logic to convert Lighting to\n+                                                                // DimmableLighting or ColorfulLighting depending on\n+                                                                // item type\n+                    if (item instanceof ColorItem) {\n+                        type = OLD_COLORFUL_LIGHTBULB;\n+                    } else if (item instanceof DimmerItem) {\n+                        type = OLD_DIMMABLE_LIGHTBULB;\n+                    }\n+                }\n+                if ((meta.length > 1) && (HomekitCharacteristicType.valueOfTag(meta[1].trim()).isPresent())) { // it has\n+                                                                                                               // characteristic\n+                                                                                                               // as\n+                                                                                                               // well\n+                    accessories\n+                            .add(new SimpleEntry<>(type, HomekitCharacteristicType.valueOfTag(meta[1].trim()).get()));\n+                } else {// it has no characteristic\n+                    accessories.add(new SimpleEntry<>(type, EMPTY));\n+                }\n+            } else { // it is no accessory, so, maybe it is a characteristic\n+                HomekitCharacteristicType.valueOfTag(meta[0].trim())\n+                        .ifPresent(c -> accessories.add(new SimpleEntry<>(DUMMY, c)));\n+            }\n+        }\n+        return accessories;\n+    }\n+\n+    public static @Nullable Map<String, Object> getItemConfiguration(Item item, MetadataRegistry metadataRegistry) {\n+        Metadata metadata = metadataRegistry.get(new MetadataKey(METADATA_KEY, item.getUID()));\n+        return metadata != null ? metadata.getConfiguration() : null;\n     }\n \n     /**\n-     * Given an accessory group, return the item in the group tagged as an accessory.\n-     *\n-     * @param taggedItem The group item containing our item, or, the accessory item.\n-     * @param accessoryType The accessory type for which we're looking\n-     * @return\n+     * return list of HomeKit relevant groups linked to an accessory\n+     * \n+     * @param item OH item\n+     * @param itemRegistry item registry\n+     * @param metadataRegistry metadata registry\n+     * @return list of relevant group items\n      */\n-    private static Optional<HomekitTaggedItem> getPrimaryAccessory(HomekitTaggedItem taggedItem,\n-            HomekitAccessoryType accessoryType, ItemRegistry itemRegistry) {\n-        LOGGER.debug(\"{}: isGroup? {}, isMember? {}\", taggedItem.getName(), taggedItem.isGroup(),\n-                taggedItem.isMemberOfAccessoryGroup());\n+    public static List<GroupItem> getAccessoryGroups(Item item, ItemRegistry itemRegistry,\n+            MetadataRegistry metadataRegistry) {\n+        return item.getGroupNames().stream().flatMap(name -> {\n+            Item groupItem = itemRegistry.get(name);\n+            if (groupItem instanceof GroupItem) {\n+                return Stream.of((GroupItem) groupItem);\n+            } else {\n+                return Stream.empty();\n+            }\n+        }).filter(groupItem -> !getAccessoryTypes(groupItem, metadataRegistry).isEmpty()).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * collect all mandatory characteristics for a given tagged item, e.g. collect all mandatory HomeKit items from a\n+     * GroupItem\n+     * \n+     * @param taggedItem HomeKit tagged item\n+     * @param metadataRegistry meta data registry\n+     * @return list of mandatory\n+     */\n+    private static @NonNull List<HomekitTaggedItem> getMandatoryCharacteristics(HomekitTaggedItem taggedItem,", "originalCommit": "580ad0df55c3d1782ed3e5751c52bc756889a322", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1Nzk2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r418757961", "bodyText": "You should cache implicitOptionalCharacteristics.get(taggedItem.getAccessoryType()) in a local variable for reuse.", "author": "cpmeister", "createdAt": "2020-05-01T22:06:17Z", "path": "bundles/org.openhab.io.homekit/src/main/java/org/openhab/io/homekit/internal/accessories/HomekitAccessoryFactory.java", "diffHunk": "@@ -12,156 +12,417 @@\n  */\n package org.openhab.io.homekit.internal.accessories;\n \n+import static org.openhab.io.homekit.internal.HomekitAccessoryType.*;\n+import static org.openhab.io.homekit.internal.HomekitCharacteristicType.*;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.AbstractMap.SimpleEntry;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n+import java.util.Map.Entry;\n import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.items.GenericItem;\n import org.eclipse.smarthome.core.items.GroupItem;\n import org.eclipse.smarthome.core.items.Item;\n import org.eclipse.smarthome.core.items.ItemRegistry;\n+import org.eclipse.smarthome.core.items.Metadata;\n+import org.eclipse.smarthome.core.items.MetadataKey;\n+import org.eclipse.smarthome.core.items.MetadataRegistry;\n+import org.eclipse.smarthome.core.library.items.ColorItem;\n+import org.eclipse.smarthome.core.library.items.DimmerItem;\n import org.openhab.io.homekit.internal.HomekitAccessoryType;\n import org.openhab.io.homekit.internal.HomekitAccessoryUpdater;\n import org.openhab.io.homekit.internal.HomekitCharacteristicType;\n import org.openhab.io.homekit.internal.HomekitException;\n import org.openhab.io.homekit.internal.HomekitSettings;\n import org.openhab.io.homekit.internal.HomekitTaggedItem;\n-import org.openhab.io.homekit.internal.battery.BatteryStatus;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import io.github.hapjava.HomekitAccessory;\n+import io.github.hapjava.accessories.HomekitAccessory;\n+import io.github.hapjava.characteristics.Characteristic;\n+import io.github.hapjava.services.Service;\n \n /**\n  * Creates a HomekitAccessory for a given HomekitTaggedItem.\n  *\n  * @author Andy Lintner - Initial contribution\n+ * @author Eugen Freiter - refactoring for optional characteristics\n  */\n+@NonNullByDefault\n public class HomekitAccessoryFactory {\n     private static final Logger LOGGER = LoggerFactory.getLogger(HomekitAccessoryFactory.class);\n+    public final static String METADATA_KEY = \"homekit\"; // prefix for HomeKit meta information in items.xml\n+\n+    /** List of mandatory attributes for each accessory type. **/\n+    private final static Map<HomekitAccessoryType, HomekitCharacteristicType[]> mandatoryCharacteristics = new HashMap<HomekitAccessoryType, HomekitCharacteristicType[]>() {\n+        {\n+            put(LEAK_SENSOR, new HomekitCharacteristicType[] { LEAK_DETECTED_STATE });\n+            put(MOTION_SENSOR, new HomekitCharacteristicType[] { MOTION_DETECTED_STATE });\n+            put(OCCUPANCY_SENSOR, new HomekitCharacteristicType[] { OCCUPANCY_DETECTED_STATE });\n+            put(CONTACT_SENSOR, new HomekitCharacteristicType[] { CONTACT_SENSOR_STATE });\n+            put(SMOKE_SENSOR, new HomekitCharacteristicType[] { SMOKE_DETECTED_STATE });\n+            put(HUMIDITY_SENSOR, new HomekitCharacteristicType[] { RELATIVE_HUMIDITY });\n+            put(SWITCH, new HomekitCharacteristicType[] { ON_STATE });\n+            put(CARBON_DIOXIDE_SENSOR, new HomekitCharacteristicType[] { CARBON_DIOXIDE_DETECTED_STATE });\n+            put(CARBON_MONOXIDE_SENSOR, new HomekitCharacteristicType[] { CARBON_MONOXIDE_DETECTED_STATE });\n+            put(WINDOW_COVERING, new HomekitCharacteristicType[] { TARGET_POSITION, CURRENT_POSITION, POSITION_STATE });\n+            put(LIGHTBULB, new HomekitCharacteristicType[] { ON_STATE });\n+            put(FAN, new HomekitCharacteristicType[] { ACTIVE_STATUS });\n+            put(TEMPERATURE_SENSOR, new HomekitCharacteristicType[] { CURRENT_TEMPERATURE });\n+            put(THERMOSTAT, new HomekitCharacteristicType[] { CURRENT_HEATING_COOLING_STATE,\n+                    TARGET_HEATING_COOLING_STATE, CURRENT_TEMPERATURE, TARGET_TEMPERATURE });\n+            put(LOCK, new HomekitCharacteristicType[] { LOCK_CURRENT_STATE, LOCK_TARGET_STATE });\n+            put(VALVE, new HomekitCharacteristicType[] { ACTIVE_STATUS, INUSE_STATUS });\n+            put(SECURITY_SYSTEM,\n+                    new HomekitCharacteristicType[] { SECURITY_SYSTEM_CURRENT_STATE, SECURITY_SYSTEM_TARGET_STATE });\n+            // LEGACY\n+            put(BLINDS, new HomekitCharacteristicType[] { TARGET_POSITION, CURRENT_POSITION, POSITION_STATE });\n+            put(OLD_HUMIDITY_SENSOR, new HomekitCharacteristicType[] { RELATIVE_HUMIDITY });\n+            put(OLD_DIMMABLE_LIGHTBULB, new HomekitCharacteristicType[] { ON_STATE });\n+            put(OLD_COLORFUL_LIGHTBULB, new HomekitCharacteristicType[] { ON_STATE });\n+        }\n+    };\n+\n+    /** List of service implementation for each accessory type. **/\n+    private final static Map<HomekitAccessoryType, Class<? extends AbstractHomekitAccessoryImpl>> serviceImplMap = new HashMap<HomekitAccessoryType, Class<? extends AbstractHomekitAccessoryImpl>>() {\n+        {\n+            put(LEAK_SENSOR, HomekitLeakSensorImpl.class);\n+            put(MOTION_SENSOR, HomekitMotionSensorImpl.class);\n+            put(OCCUPANCY_SENSOR, HomekitOccupancySensorImpl.class);\n+            put(CONTACT_SENSOR, HomekitContactSensorImpl.class);\n+            put(TEMPERATURE_SENSOR, HomekitTemperatureSensorImpl.class);\n+            put(SMOKE_SENSOR, HomekitSmokeSensorImpl.class);\n+            put(HUMIDITY_SENSOR, HomekitHumiditySensorImpl.class);\n+            put(SWITCH, HomekitSwitchImpl.class);\n+            put(CARBON_DIOXIDE_SENSOR, HomekitCarbonDioxideSensorImpl.class);\n+            put(CARBON_MONOXIDE_SENSOR, HomekitCarbonMonoxideSensorImpl.class);\n+            put(WINDOW_COVERING, HomekitWindowCoveringImpl.class);\n+            put(LIGHTBULB, HomekitLightbulbImpl.class);\n+            put(FAN, HomekitFanImpl.class);\n+            put(TEMPERATURE_SENSOR, HomekitTemperatureSensorImpl.class);\n+            put(THERMOSTAT, HomekitThermostatImpl.class);\n+            put(LOCK, HomekitLockImpl.class);\n+            put(VALVE, HomekitValveImpl.class);\n+            put(SECURITY_SYSTEM, HomekitSecuritySystemImpl.class);\n+            put(BLINDS, HomekitWindowCoveringImpl.class);\n+            put(OLD_HUMIDITY_SENSOR, HomekitHumiditySensorImpl.class);\n+            put(OLD_DIMMABLE_LIGHTBULB, HomekitLightbulbImpl.class);\n+            put(OLD_COLORFUL_LIGHTBULB, HomekitLightbulbImpl.class);\n+\n+        }\n+    };\n+\n+    /** mapping of legacy attributes to new attributes. **/\n+    private final static Map<HomekitCharacteristicType, HomekitCharacteristicType> legacyCharacteristicsMapping = new HashMap<HomekitCharacteristicType, HomekitCharacteristicType>() {\n+        {\n+            put(OLD_CURRENT_HEATING_COOLING_STATE, CURRENT_HEATING_COOLING_STATE);\n+            put(OLD_TARGET_HEATING_COOLING_MODE, TARGET_HEATING_COOLING_STATE);\n+            put(OLD_TARGET_TEMPERATURE, TARGET_TEMPERATURE);\n+            put(OLD_BATTERY_LOW_STATUS, BATTERY_LOW_STATUS);\n+            put(VERY_OLD_TARGET_HEATING_COOLING_MODE, CURRENT_HEATING_COOLING_STATE);\n+        }\n+    };\n+\n+    /** list of optional implicit optional characteristics. mainly used for legacy accessory type */\n+    private final static Map<HomekitAccessoryType, HomekitCharacteristicType[]> implicitOptionalCharacteristics = new HashMap<HomekitAccessoryType, HomekitCharacteristicType[]>() {\n+        {\n+            put(OLD_DIMMABLE_LIGHTBULB, new HomekitCharacteristicType[] { BRIGHTNESS });\n+            put(OLD_COLORFUL_LIGHTBULB, new HomekitCharacteristicType[] { HUE, SATURATION, BRIGHTNESS });\n+\n+        }\n+    };\n+\n+    /**\n+     * creates HomeKit accessory for a openhab item.\n+     * \n+     * @param taggedItem openhab item tagged as HomeKit item\n+     * @param metadataRegistry openhab metadata registry required to get item meta information\n+     * @param updater OH HomeKit update class that ensure the status sync between OH item and corresponding HomeKit\n+     *            characteristic.\n+     * @param settings OH settings\n+     * @return HomeKit accessory\n+     * @throws HomekitException exception in case HomeKit accessory could not be created, e.g. due missing mandatory\n+     *             characteristic\n+     */\n+    public static HomekitAccessory create(HomekitTaggedItem taggedItem, MetadataRegistry metadataRegistry,\n+            HomekitAccessoryUpdater updater, HomekitSettings settings) throws HomekitException {\n \n-    @SuppressWarnings(\"deprecation\")\n-    public static HomekitAccessory create(HomekitTaggedItem taggedItem, ItemRegistry itemRegistry,\n-            HomekitAccessoryUpdater updater, HomekitSettings settings)\n-            throws HomekitException, IncompleteAccessoryException {\n         LOGGER.debug(\"Constructing {} of accessoryType {}\", taggedItem.getName(), taggedItem.getAccessoryType());\n+        final List<HomekitTaggedItem> requiredCharacteristics = getMandatoryCharacteristics(taggedItem,\n+                metadataRegistry);\n+        if ((mandatoryCharacteristics.get(taggedItem.getAccessoryType()) != null) && (requiredCharacteristics\n+                .size() < mandatoryCharacteristics.get(taggedItem.getAccessoryType()).length)) {\n+            LOGGER.error(\"Accessory of type {} must have following characteristics {}. Found only {}\",\n+                    taggedItem.getAccessoryType(), mandatoryCharacteristics.get(taggedItem.getAccessoryType()),\n+                    requiredCharacteristics);\n+            throw new HomekitException(\"Missing mandatory characteristics\");\n+        }\n+        AbstractHomekitAccessoryImpl accessoryImpl = null;\n \n-        Map<HomekitCharacteristicType, Item> characteristicItems = getCharacteristicItems(taggedItem);\n-\n-        switch (taggedItem.getAccessoryType()) {\n-            case LEAK_SENSOR:\n-                HomekitTaggedItem leakSensorAccessory = getPrimaryAccessory(taggedItem,\n-                        HomekitAccessoryType.LEAK_SENSOR, itemRegistry).orElseThrow(\n-                                () -> new HomekitException(\"Leak accessory group should have a leak sensor in it\"));\n-\n-                return new HomekitLeakSensorImpl(leakSensorAccessory, itemRegistry, updater,\n-                        BatteryStatus.getFromCharacteristics(characteristicItems));\n-            case VALVE:\n-                return new HomekitValveImpl(taggedItem, itemRegistry, updater);\n-            case MOTION_SENSOR:\n-                HomekitTaggedItem motionSensorAccessory = getPrimaryAccessory(taggedItem,\n-                        HomekitAccessoryType.MOTION_SENSOR, itemRegistry)\n-                                .orElseThrow(() -> new HomekitException(\n-                                        \"Motion sensor accessory group should have a motion sensor item in it\"));\n-                return new HomekitMotionSensorImpl(motionSensorAccessory, itemRegistry, updater,\n-                        BatteryStatus.getFromCharacteristics(characteristicItems));\n-            case OCCUPANCY_SENSOR:\n-                HomekitTaggedItem occupancySensorAccessory = getPrimaryAccessory(taggedItem,\n-                        HomekitAccessoryType.OCCUPANCY_SENSOR, itemRegistry)\n-                                .orElseThrow(() -> new HomekitException(\n-                                        \"Occupancy sensor accessory group should have a occupancy sensor item in it\"));\n-                return new HomekitOccupancySensorImpl(occupancySensorAccessory, itemRegistry, updater,\n-                        BatteryStatus.getFromCharacteristics(characteristicItems));\n-            case CONTACT_SENSOR:\n-                HomekitTaggedItem contactSensorAccessory = getPrimaryAccessory(taggedItem,\n-                        HomekitAccessoryType.CONTACT_SENSOR, itemRegistry)\n-                                .orElseThrow(() -> new HomekitException(\n-                                        \"Contact sensor accessory group should have a occupancy sensor item in it\"));\n-                return new HomekitContactSensorImpl(contactSensorAccessory, itemRegistry, updater,\n-                        BatteryStatus.getFromCharacteristics(characteristicItems));\n-            case LIGHTBULB:\n-                return new HomekitLightbulbImpl(taggedItem, itemRegistry, updater);\n-            case DIMMABLE_LIGHTBULB:\n-                return new HomekitDimmableLightbulbImpl(taggedItem, itemRegistry, updater);\n-            case COLORFUL_LIGHTBULB:\n-                return new HomekitColorfulLightbulbImpl(taggedItem, itemRegistry, updater);\n-            case THERMOSTAT:\n-                HomekitTaggedItem temperatureAccessory = getPrimaryAccessory(taggedItem,\n-                        HomekitAccessoryType.TEMPERATURE_SENSOR, itemRegistry).orElseThrow(\n-                                () -> new HomekitException(\"Thermostats need a CurrentTemperature accessory\"));\n-                return new HomekitThermostatImpl(taggedItem, itemRegistry, updater, settings,\n-                        temperatureAccessory.getItem(), getCharacteristicItems(taggedItem));\n-            case SWITCH:\n-                return new HomekitSwitchImpl(taggedItem, itemRegistry, updater);\n-            case TEMPERATURE_SENSOR:\n-                return new HomekitTemperatureSensorImpl(taggedItem, itemRegistry, updater, settings);\n-            case HUMIDITY_SENSOR:\n-                return new HomekitHumiditySensorImpl(taggedItem, itemRegistry, updater);\n-            case BLINDS:\n-            case WINDOW_COVERING:\n-                return new HomekitWindowCoveringImpl(taggedItem, itemRegistry, updater);\n-            case SMOKE_SENSOR:\n-                HomekitTaggedItem smokeSensorAccessory = getPrimaryAccessory(taggedItem,\n-                        HomekitAccessoryType.SMOKE_SENSOR, itemRegistry).orElseThrow(\n-                                () -> new HomekitException(\"Smoke accessory group should have a smoke sensor in it\"));\n-                return new HomekitSmokeSensorImpl(smokeSensorAccessory, itemRegistry, updater,\n-                        BatteryStatus.getFromCharacteristics(characteristicItems));\n-            case CARBON_MONOXIDE_SENSOR:\n-                HomekitTaggedItem carbonMonoxideSensorAccessory = getPrimaryAccessory(taggedItem,\n-                        HomekitAccessoryType.CARBON_MONOXIDE_SENSOR, itemRegistry)\n-                                .orElseThrow(() -> new HomekitException(\n-                                        \"Carbon monoxide accessory group should have a carbon monoxide sensor in it\"));\n-                return new HomekitSmokeSensorImpl(carbonMonoxideSensorAccessory, itemRegistry, updater,\n-                        BatteryStatus.getFromCharacteristics(characteristicItems));\n-            case LOCK:\n-                return new HomekitLockImpl(taggedItem, itemRegistry, updater);\n+        try {\n+            final Class<? extends AbstractHomekitAccessoryImpl> accessoryImplClass = serviceImplMap\n+                    .get(taggedItem.getAccessoryType());\n+            if (accessoryImplClass != null) {\n+                accessoryImpl = accessoryImplClass\n+                        .getConstructor(HomekitTaggedItem.class, List.class, HomekitAccessoryUpdater.class,\n+                                HomekitSettings.class)\n+                        .newInstance(taggedItem, requiredCharacteristics, updater, settings);\n+                addOptionalCharacteristics(accessoryImpl, metadataRegistry);\n+                return accessoryImpl;\n+            } else {\n+                LOGGER.error(\"Unsupported HomeKit type: {}\", taggedItem.getAccessoryType());\n+                throw new HomekitException(\"Unsupported HomeKit type: \" + taggedItem.getAccessoryType());\n+            }\n+        } catch (NoSuchMethodException | IllegalAccessException | InstantiationException\n+                | InvocationTargetException e) {\n+            LOGGER.error(\"Cannot instantiate accessory implementation for accessory {}\", taggedItem.getAccessoryType(),\n+                    e);\n+            throw new HomekitException(\n+                    \"Cannot instantiate accessory implementation for accessory \" + taggedItem.getAccessoryType());\n         }\n+    }\n+\n+    /**\n+     * return HomeKit accessory types for a OH item based on meta data\n+     * \n+     * @param item OH item\n+     * @param metadataRegistry meta data registry\n+     * @return list of HomeKit accessory types and characteristics.\n+     */\n+    public static List<Entry<HomekitAccessoryType, HomekitCharacteristicType>> getAccessoryTypes(Item item,\n+            MetadataRegistry metadataRegistry) {\n+        final List<Entry<HomekitAccessoryType, HomekitCharacteristicType>> accessories = new ArrayList<>();\n+        Metadata metadata = metadataRegistry.get(new MetadataKey(METADATA_KEY, item.getUID()));\n+        boolean legacyMode = !(metadata != null);\n+        String[] tags = !legacyMode ? metadata.getValue().split(\",\") : item.getTags().toArray(new String[0]); // fallback\n+                                                                                                              // to tags\n \n-        throw new HomekitException(\"Unknown HomeKit type: \" + taggedItem.getAccessoryType());\n+        LOGGER.debug(\"item {} meta data {}  tags {} \", item.getName(), metadata, tags);\n+        for (String tag : tags) {\n+            final String[] meta = tag.split(\"\\\\.\");\n+            Optional<HomekitAccessoryType> accessoryType = HomekitAccessoryType.valueOfTag(meta[0].trim());\n+            if (accessoryType.isPresent()) { // it accessory, check for characteristic\n+                HomekitAccessoryType type = accessoryType.get();\n+                if ((legacyMode) && (type.equals(LIGHTBULB))) { // support old smart logic to convert Lighting to\n+                                                                // DimmableLighting or ColorfulLighting depending on\n+                                                                // item type\n+                    if (item instanceof ColorItem) {\n+                        type = OLD_COLORFUL_LIGHTBULB;\n+                    } else if (item instanceof DimmerItem) {\n+                        type = OLD_DIMMABLE_LIGHTBULB;\n+                    }\n+                }\n+                if ((meta.length > 1) && (HomekitCharacteristicType.valueOfTag(meta[1].trim()).isPresent())) { // it has\n+                                                                                                               // characteristic\n+                                                                                                               // as\n+                                                                                                               // well\n+                    accessories\n+                            .add(new SimpleEntry<>(type, HomekitCharacteristicType.valueOfTag(meta[1].trim()).get()));\n+                } else {// it has no characteristic\n+                    accessories.add(new SimpleEntry<>(type, EMPTY));\n+                }\n+            } else { // it is no accessory, so, maybe it is a characteristic\n+                HomekitCharacteristicType.valueOfTag(meta[0].trim())\n+                        .ifPresent(c -> accessories.add(new SimpleEntry<>(DUMMY, c)));\n+            }\n+        }\n+        return accessories;\n+    }\n+\n+    public static @Nullable Map<String, Object> getItemConfiguration(Item item, MetadataRegistry metadataRegistry) {\n+        Metadata metadata = metadataRegistry.get(new MetadataKey(METADATA_KEY, item.getUID()));\n+        return metadata != null ? metadata.getConfiguration() : null;\n     }\n \n     /**\n-     * Given an accessory group, return the item in the group tagged as an accessory.\n-     *\n-     * @param taggedItem The group item containing our item, or, the accessory item.\n-     * @param accessoryType The accessory type for which we're looking\n-     * @return\n+     * return list of HomeKit relevant groups linked to an accessory\n+     * \n+     * @param item OH item\n+     * @param itemRegistry item registry\n+     * @param metadataRegistry metadata registry\n+     * @return list of relevant group items\n      */\n-    private static Optional<HomekitTaggedItem> getPrimaryAccessory(HomekitTaggedItem taggedItem,\n-            HomekitAccessoryType accessoryType, ItemRegistry itemRegistry) {\n-        LOGGER.debug(\"{}: isGroup? {}, isMember? {}\", taggedItem.getName(), taggedItem.isGroup(),\n-                taggedItem.isMemberOfAccessoryGroup());\n+    public static List<GroupItem> getAccessoryGroups(Item item, ItemRegistry itemRegistry,\n+            MetadataRegistry metadataRegistry) {\n+        return item.getGroupNames().stream().flatMap(name -> {\n+            Item groupItem = itemRegistry.get(name);\n+            if (groupItem instanceof GroupItem) {\n+                return Stream.of((GroupItem) groupItem);\n+            } else {\n+                return Stream.empty();\n+            }\n+        }).filter(groupItem -> !getAccessoryTypes(groupItem, metadataRegistry).isEmpty()).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * collect all mandatory characteristics for a given tagged item, e.g. collect all mandatory HomeKit items from a\n+     * GroupItem\n+     * \n+     * @param taggedItem HomeKit tagged item\n+     * @param metadataRegistry meta data registry\n+     * @return list of mandatory\n+     */\n+    private static @NonNull List<HomekitTaggedItem> getMandatoryCharacteristics(HomekitTaggedItem taggedItem,\n+            MetadataRegistry metadataRegistry) {\n+        LOGGER.debug(\"get mandatory characteristics for item {}: isGroup? {}, isMember? {}\", taggedItem.getName(),\n+                taggedItem.isGroup(), taggedItem.isMemberOfAccessoryGroup());\n+        List<HomekitTaggedItem> collectedCharacteristics = new ArrayList<>();\n         if (taggedItem.isGroup()) {\n-            GroupItem groupItem = (GroupItem) taggedItem.getItem();\n-            return groupItem.getMembers().stream().filter(item -> item.hasTag(accessoryType.getTag())).findFirst()\n-                    .map(item -> new HomekitTaggedItem(item, itemRegistry));\n-        } else if (taggedItem.getAccessoryType() == accessoryType) {\n-            return Optional.of(taggedItem);\n+            for (Item item : ((GroupItem) taggedItem.getItem()).getAllMembers()) {\n+                addMandatoryCharacteristics(taggedItem, collectedCharacteristics, item, metadataRegistry);\n+            }\n         } else {\n-            return Optional.empty();\n+            addMandatoryCharacteristics(taggedItem, collectedCharacteristics, taggedItem.getItem(), metadataRegistry);\n         }\n+        return collectedCharacteristics;\n     }\n \n-    private static Map<HomekitCharacteristicType, Item> getCharacteristicItems(HomekitTaggedItem taggedItem) {\n+    /**\n+     * add mandatory HomeKit items for a given main item to a list of characteristics\n+     * \n+     * @param mainItem main item\n+     * @param characteristics list of characteristics\n+     * @param item current item\n+     * @param metadataRegistry meta date registry\n+     */\n+    private static void addMandatoryCharacteristics(HomekitTaggedItem mainItem, List<HomekitTaggedItem> characteristics,\n+            Item item, MetadataRegistry metadataRegistry) {\n+        HomekitCharacteristicType[] requiredChar = mandatoryCharacteristics.get(mainItem.getAccessoryType());\n+        for (Entry<HomekitAccessoryType, HomekitCharacteristicType> accessory : getAccessoryTypes(item,\n+                metadataRegistry)) {\n+            if (isRootAccessory(accessory) && (requiredChar != null)) {\n+                Arrays.stream(requiredChar)\n+                        .forEach(c -> characteristics.add(new HomekitTaggedItem(item, accessory.getKey(), c,\n+                                mainItem.isGroup() ? (GroupItem) mainItem.getItem() : null,\n+                                HomekitAccessoryFactory.getItemConfiguration(item, metadataRegistry))));\n+            } else {\n+                if (isMandatoryCharacteristic(mainItem.getAccessoryType(), legacyCheck(accessory.getValue())))\n+                    characteristics\n+                            .add(new HomekitTaggedItem(item, accessory.getKey(), legacyCheck(accessory.getValue()),\n+                                    mainItem.isGroup() ? (GroupItem) mainItem.getItem() : null,\n+                                    HomekitAccessoryFactory.getItemConfiguration(item, metadataRegistry)));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * add optional characteristic for given accessory.\n+     * \n+     * @param accessory accessory\n+     * @param metadataRegistry metadata registry\n+     */\n+    private static void addOptionalCharacteristics(AbstractHomekitAccessoryImpl accessory,\n+            MetadataRegistry metadataRegistry) {\n+        Map<HomekitCharacteristicType, GenericItem> characteristics = getOptionalCharacteristics(\n+                accessory.getRootAccessory(), metadataRegistry);\n+        Service service = accessory.getPrimaryService();\n+\n+        characteristics.forEach((type, item) -> {\n+            try {\n+                LOGGER.debug(\"adding optional characteristic: {} for item {}\", type, item.getName());\n+\n+                final Characteristic characteristic = HomekitCharacteristicFactory.createCharacteristic(type, item,\n+                        accessory.getUpdater());\n+\n+                service.getClass().getMethod(\"addOptionalCharacteristic\", characteristic.getClass()). // find the\n+                                                                                                      // corresponding\n+                                                                                                      // add method at\n+                                                                                                      // service and\n+                                                                                                      // call it.\n+                invoke(service, characteristic);\n+\n+                accessory.addCharacteristic(new HomekitTaggedItem(item, accessory.getRootAccessory().getAccessoryType(),\n+                        type, accessory.getRootAccessory().getRootDeviceGroupItem(),\n+                        getItemConfiguration(item, metadataRegistry)));\n+            } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException | HomekitException e) {\n+                LOGGER.error(\"Not supported optional HomeKit characteristic. Service type {}, characteristic type {}\",\n+                        service.getType(), type, e);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * collect optional HomeKit characteristics for a OH item.\n+     * \n+     * @param taggedItem main OH item\n+     * @param metadataRegistry OH metadata registry\n+     * @return a map with characteristics and corresponding OH items\n+     */\n+    private static Map<HomekitCharacteristicType, GenericItem> getOptionalCharacteristics(HomekitTaggedItem taggedItem,\n+            MetadataRegistry metadataRegistry) {\n+        LOGGER.debug(\"get optional characteristics for item {}: isGroup? {}, isMember? {}\", taggedItem.getName(),\n+                taggedItem.isGroup(), taggedItem.isMemberOfAccessoryGroup());\n+        Map<HomekitCharacteristicType, GenericItem> characteristicItems = new HashMap<>();\n         if (taggedItem.isGroup()) {\n             GroupItem groupItem = (GroupItem) taggedItem.getItem();\n-            Map<HomekitCharacteristicType, Item> characteristicItems = new HashMap<>();\n             groupItem.getMembers().forEach(item -> {\n-                HomekitCharacteristicType type = HomekitCharacteristicType.fromItem(item);\n-                if (type != null) {\n-                    if (characteristicItems.containsKey(type)) {\n-                        LOGGER.warn(\"incorrect configuration for {} detected: {} and {} are tagged as {}, skipping {}\",\n-                                taggedItem.getItem().getUID(), characteristicItems.get(type).getUID(), item.getUID(),\n-                                type, item.getUID());\n-                    } else {\n-                        characteristicItems.put(type, item);\n-                    }\n-                }\n+                getAccessoryTypes(item, metadataRegistry).stream().filter(c -> !isRootAccessory(c)).filter(\n+                        c -> !isMandatoryCharacteristic(taggedItem.getAccessoryType(), legacyCheck(c.getValue())))\n+                        .forEach(characteristic -> characteristicItems.put(legacyCheck(characteristic.getValue()),\n+                                (GenericItem) item));\n             });\n-            return Collections.unmodifiableMap(characteristicItems);\n         } else {\n-            // do nothing; only accessory groups have characteristic items\n-            return Collections.emptyMap();\n+            getAccessoryTypes(taggedItem.getItem(), metadataRegistry).stream().filter(c -> !isRootAccessory(c))\n+                    .filter(c -> !isMandatoryCharacteristic(taggedItem.getAccessoryType(), legacyCheck(c.getValue())))\n+                    .forEach(characteristic -> characteristicItems.put(legacyCheck(characteristic.getValue()),\n+                            (GenericItem) taggedItem.getItem()));\n+\n+            if (implicitOptionalCharacteristics.get(taggedItem.getAccessoryType()) != null) {", "originalCommit": "580ad0df55c3d1782ed3e5751c52bc756889a322", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1OTI2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r418759262", "bodyText": "Please add bracket around the if statement", "author": "cpmeister", "createdAt": "2020-05-01T22:11:00Z", "path": "bundles/org.openhab.io.homekit/src/main/java/org/openhab/io/homekit/internal/accessories/HomekitFanImpl.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.io.homekit.internal.accessories;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.items.SwitchItem;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.io.homekit.internal.HomekitAccessoryUpdater;\n+import org.openhab.io.homekit.internal.HomekitCharacteristicType;\n+import org.openhab.io.homekit.internal.HomekitSettings;\n+import org.openhab.io.homekit.internal.HomekitTaggedItem;\n+\n+import io.github.hapjava.accessories.FanAccessory;\n+import io.github.hapjava.characteristics.HomekitCharacteristicChangeCallback;\n+import io.github.hapjava.services.impl.FanService;\n+\n+/**\n+ * Implements Fan using an Item that provides an On/Off state\n+ *\n+ * @author Eugen Freiter - Initial contribution\n+ */\n+class HomekitFanImpl extends AbstractHomekitAccessoryImpl implements FanAccessory {\n+    public HomekitFanImpl(HomekitTaggedItem taggedItem, List<HomekitTaggedItem> mandatoryCharacteristics,\n+            HomekitAccessoryUpdater updater, HomekitSettings settings) throws IncompleteAccessoryException {\n+        super(taggedItem, mandatoryCharacteristics, updater, settings);\n+        this.getServices().add(new FanService(this));\n+    }\n+\n+    @Override\n+    public CompletableFuture<Boolean> isActive() {\n+        final @Nullable State state = getStateAs(HomekitCharacteristicType.ACTIVE_STATUS, OnOffType.class);\n+        return CompletableFuture.completedFuture(state == OnOffType.ON);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> setActive(final boolean state) throws Exception {\n+        final @Nullable SwitchItem item = getItem(HomekitCharacteristicType.ACTIVE_STATUS, SwitchItem.class);\n+        if (item != null)", "originalCommit": "580ad0df55c3d1782ed3e5751c52bc756889a322", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc2MjQ1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r418762453", "bodyText": "please add brackets to if statement", "author": "cpmeister", "createdAt": "2020-05-01T22:22:58Z", "path": "bundles/org.openhab.io.homekit/src/main/java/org/openhab/io/homekit/internal/accessories/HomekitWindowCoveringImpl.java", "diffHunk": "@@ -57,13 +58,16 @@ public HomekitWindowCoveringImpl(HomekitTaggedItem taggedItem, ItemRegistry item\n \n     @Override\n     public CompletableFuture<Void> setTargetPosition(int value) throws Exception {\n-        ((RollershutterItem) getItem()).send(new PercentType(100 - value));\n+        final @Nullable RollershutterItem item = getItem(HomekitCharacteristicType.TARGET_POSITION,\n+                RollershutterItem.class);\n+        if (item != null)", "originalCommit": "580ad0df55c3d1782ed3e5751c52bc756889a322", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc2MzE4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r418763183", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .completedFuture(((contactDetected != null) && (contactDetected)) ? ContactStateEnum.DETECTED\n          \n          \n            \n                            .completedFuture((contactDetected == Boolean.TRUE) ? ContactStateEnum.DETECTED", "author": "cpmeister", "createdAt": "2020-05-01T22:25:45Z", "path": "bundles/org.openhab.io.homekit/src/main/java/org/openhab/io/homekit/internal/accessories/HomekitContactSensorImpl.java", "diffHunk": "@@ -12,72 +12,53 @@\n  */\n package org.openhab.io.homekit.internal.accessories;\n \n+import java.util.List;\n import java.util.concurrent.CompletableFuture;\n \n import org.eclipse.smarthome.core.items.GenericItem;\n-import org.eclipse.smarthome.core.items.ItemRegistry;\n import org.eclipse.smarthome.core.library.types.OnOffType;\n import org.eclipse.smarthome.core.library.types.OpenClosedType;\n import org.openhab.io.homekit.internal.HomekitAccessoryUpdater;\n+import org.openhab.io.homekit.internal.HomekitCharacteristicType;\n+import org.openhab.io.homekit.internal.HomekitSettings;\n import org.openhab.io.homekit.internal.HomekitTaggedItem;\n-import org.openhab.io.homekit.internal.battery.BatteryStatus;\n \n-import io.github.hapjava.HomekitCharacteristicChangeCallback;\n-import io.github.hapjava.accessories.BatteryStatusAccessory;\n-import io.github.hapjava.accessories.ContactSensor;\n-import io.github.hapjava.accessories.properties.ContactState;\n+import io.github.hapjava.accessories.ContactSensorAccessory;\n+import io.github.hapjava.characteristics.HomekitCharacteristicChangeCallback;\n+import io.github.hapjava.characteristics.impl.contactsensor.ContactStateEnum;\n+import io.github.hapjava.services.impl.ContactSensorService;\n \n /**\n  *\n- * @author Philipp Arndt - Initial contribution; Tim Harper - support for battery status\n+ * @author Philipp Arndt - Initial contribution\n  */\n-public class HomekitContactSensorImpl extends AbstractHomekitAccessoryImpl<GenericItem>\n-        implements ContactSensor, BatteryStatusAccessory {\n-    private BatteryStatus batteryStatus;\n-    private BooleanItemReader contactSensedReader;\n+public class HomekitContactSensorImpl extends AbstractHomekitAccessoryImpl implements ContactSensorAccessory {\n+    private final BooleanItemReader contactSensedReader;\n \n-    public HomekitContactSensorImpl(HomekitTaggedItem taggedItem, ItemRegistry itemRegistry,\n-            HomekitAccessoryUpdater updater, BatteryStatus batteryStatus) {\n-        super(taggedItem, itemRegistry, updater, GenericItem.class);\n-        this.contactSensedReader = new BooleanItemReader(taggedItem.getItem(), OnOffType.OFF, OpenClosedType.CLOSED);\n-        this.batteryStatus = batteryStatus;\n+    public HomekitContactSensorImpl(HomekitTaggedItem taggedItem, List<HomekitTaggedItem> mandatoryCharacteristics,\n+            HomekitAccessoryUpdater updater, HomekitSettings settings) throws IncompleteAccessoryException {\n+        super(taggedItem, mandatoryCharacteristics, updater, settings);\n+        this.contactSensedReader = new BooleanItemReader(\n+                getItem(HomekitCharacteristicType.CONTACT_SENSOR_STATE, GenericItem.class), OnOffType.OFF,\n+                OpenClosedType.CLOSED);\n+        getServices().add(new ContactSensorService(this));\n     }\n \n     @Override\n-    public CompletableFuture<ContactState> getCurrentState() {\n+    public CompletableFuture<ContactStateEnum> getCurrentState() {\n         Boolean contactDetected = contactSensedReader.getValue();\n-        if (contactDetected == null) {\n-            // BUG - HAP-java does not currently handle null well here, so we'll default to not detected.\n-            return CompletableFuture.completedFuture(ContactState.NOT_DETECTED);\n-        } else if (contactDetected) {\n-            return CompletableFuture.completedFuture(ContactState.DETECTED);\n-        } else {\n-            return CompletableFuture.completedFuture(ContactState.NOT_DETECTED);\n-        }\n+        return CompletableFuture\n+                .completedFuture(((contactDetected != null) && (contactDetected)) ? ContactStateEnum.DETECTED", "originalCommit": "580ad0df55c3d1782ed3e5751c52bc756889a322", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc2MzM4MA==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r418763380", "bodyText": "Please add @NonNullByDefault", "author": "cpmeister", "createdAt": "2020-05-01T22:26:26Z", "path": "bundles/org.openhab.io.homekit/src/main/java/org/openhab/io/homekit/internal/accessories/HomekitCharacteristicFactory.java", "diffHunk": "@@ -0,0 +1,466 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.io.homekit.internal.accessories;\n+\n+import static org.openhab.io.homekit.internal.HomekitCharacteristicType.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.BiFunction;\n+import java.util.function.Supplier;\n+\n+import org.eclipse.smarthome.core.items.GenericItem;\n+import org.eclipse.smarthome.core.items.Item;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.io.homekit.internal.HomekitAccessoryUpdater;\n+import org.openhab.io.homekit.internal.HomekitCharacteristicType;\n+import org.openhab.io.homekit.internal.HomekitException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.github.hapjava.characteristics.Characteristic;\n+import io.github.hapjava.characteristics.CharacteristicEnum;\n+import io.github.hapjava.characteristics.impl.battery.StatusLowBatteryCharacteristic;\n+import io.github.hapjava.characteristics.impl.battery.StatusLowBatteryEnum;\n+import io.github.hapjava.characteristics.impl.carbondioxidesensor.CarbonDioxideLevelCharacteristic;\n+import io.github.hapjava.characteristics.impl.carbondioxidesensor.CarbonDioxidePeakLevelCharacteristic;\n+import io.github.hapjava.characteristics.impl.carbonmonoxidesensor.CarbonMonoxideLevelCharacteristic;\n+import io.github.hapjava.characteristics.impl.carbonmonoxidesensor.CarbonMonoxidePeakLevelCharacteristic;\n+import io.github.hapjava.characteristics.impl.common.NameCharacteristic;\n+import io.github.hapjava.characteristics.impl.common.ObstructionDetectedCharacteristic;\n+import io.github.hapjava.characteristics.impl.common.StatusActiveCharacteristic;\n+import io.github.hapjava.characteristics.impl.common.StatusFaultCharacteristic;\n+import io.github.hapjava.characteristics.impl.common.StatusFaultEnum;\n+import io.github.hapjava.characteristics.impl.common.StatusTamperedCharacteristic;\n+import io.github.hapjava.characteristics.impl.common.StatusTamperedEnum;\n+import io.github.hapjava.characteristics.impl.fan.CurrentFanStateCharacteristic;\n+import io.github.hapjava.characteristics.impl.fan.CurrentFanStateEnum;\n+import io.github.hapjava.characteristics.impl.fan.LockPhysicalControlsCharacteristic;\n+import io.github.hapjava.characteristics.impl.fan.LockPhysicalControlsEnum;\n+import io.github.hapjava.characteristics.impl.fan.RotationDirectionCharacteristic;\n+import io.github.hapjava.characteristics.impl.fan.RotationDirectionEnum;\n+import io.github.hapjava.characteristics.impl.fan.RotationSpeedCharacteristic;\n+import io.github.hapjava.characteristics.impl.fan.SwingModeCharacteristic;\n+import io.github.hapjava.characteristics.impl.fan.SwingModeEnum;\n+import io.github.hapjava.characteristics.impl.fan.TargetFanStateCharacteristic;\n+import io.github.hapjava.characteristics.impl.fan.TargetFanStateEnum;\n+import io.github.hapjava.characteristics.impl.lightbulb.BrightnessCharacteristic;\n+import io.github.hapjava.characteristics.impl.lightbulb.ColorTemperatureCharacteristic;\n+import io.github.hapjava.characteristics.impl.lightbulb.HueCharacteristic;\n+import io.github.hapjava.characteristics.impl.lightbulb.SaturationCharacteristic;\n+import io.github.hapjava.characteristics.impl.valve.RemainingDurationCharacteristic;\n+import io.github.hapjava.characteristics.impl.valve.SetDurationCharacteristic;\n+import io.github.hapjava.characteristics.impl.windowcovering.CurrentHorizontalTiltAngleCharacteristic;\n+import io.github.hapjava.characteristics.impl.windowcovering.CurrentVerticalTiltAngleCharacteristic;\n+import io.github.hapjava.characteristics.impl.windowcovering.HoldPositionCharacteristic;\n+import io.github.hapjava.characteristics.impl.windowcovering.TargetHorizontalTiltAngleCharacteristic;\n+import io.github.hapjava.characteristics.impl.windowcovering.TargetVerticalTiltAngleCharacteristic;\n+\n+/**\n+ * Creates a optional characteristics .\n+ *\n+ * @author Eugen Freiter - Initial contribution\n+ */\n+public class HomekitCharacteristicFactory {", "originalCommit": "580ad0df55c3d1782ed3e5751c52bc756889a322", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc2Mzk1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r418763952", "bodyText": "Please adjust logging level", "author": "cpmeister", "createdAt": "2020-05-01T22:28:29Z", "path": "bundles/org.openhab.io.homekit/src/main/java/org/openhab/io/homekit/internal/accessories/HomekitCharacteristicFactory.java", "diffHunk": "@@ -0,0 +1,466 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.io.homekit.internal.accessories;\n+\n+import static org.openhab.io.homekit.internal.HomekitCharacteristicType.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.BiFunction;\n+import java.util.function.Supplier;\n+\n+import org.eclipse.smarthome.core.items.GenericItem;\n+import org.eclipse.smarthome.core.items.Item;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.io.homekit.internal.HomekitAccessoryUpdater;\n+import org.openhab.io.homekit.internal.HomekitCharacteristicType;\n+import org.openhab.io.homekit.internal.HomekitException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.github.hapjava.characteristics.Characteristic;\n+import io.github.hapjava.characteristics.CharacteristicEnum;\n+import io.github.hapjava.characteristics.impl.battery.StatusLowBatteryCharacteristic;\n+import io.github.hapjava.characteristics.impl.battery.StatusLowBatteryEnum;\n+import io.github.hapjava.characteristics.impl.carbondioxidesensor.CarbonDioxideLevelCharacteristic;\n+import io.github.hapjava.characteristics.impl.carbondioxidesensor.CarbonDioxidePeakLevelCharacteristic;\n+import io.github.hapjava.characteristics.impl.carbonmonoxidesensor.CarbonMonoxideLevelCharacteristic;\n+import io.github.hapjava.characteristics.impl.carbonmonoxidesensor.CarbonMonoxidePeakLevelCharacteristic;\n+import io.github.hapjava.characteristics.impl.common.NameCharacteristic;\n+import io.github.hapjava.characteristics.impl.common.ObstructionDetectedCharacteristic;\n+import io.github.hapjava.characteristics.impl.common.StatusActiveCharacteristic;\n+import io.github.hapjava.characteristics.impl.common.StatusFaultCharacteristic;\n+import io.github.hapjava.characteristics.impl.common.StatusFaultEnum;\n+import io.github.hapjava.characteristics.impl.common.StatusTamperedCharacteristic;\n+import io.github.hapjava.characteristics.impl.common.StatusTamperedEnum;\n+import io.github.hapjava.characteristics.impl.fan.CurrentFanStateCharacteristic;\n+import io.github.hapjava.characteristics.impl.fan.CurrentFanStateEnum;\n+import io.github.hapjava.characteristics.impl.fan.LockPhysicalControlsCharacteristic;\n+import io.github.hapjava.characteristics.impl.fan.LockPhysicalControlsEnum;\n+import io.github.hapjava.characteristics.impl.fan.RotationDirectionCharacteristic;\n+import io.github.hapjava.characteristics.impl.fan.RotationDirectionEnum;\n+import io.github.hapjava.characteristics.impl.fan.RotationSpeedCharacteristic;\n+import io.github.hapjava.characteristics.impl.fan.SwingModeCharacteristic;\n+import io.github.hapjava.characteristics.impl.fan.SwingModeEnum;\n+import io.github.hapjava.characteristics.impl.fan.TargetFanStateCharacteristic;\n+import io.github.hapjava.characteristics.impl.fan.TargetFanStateEnum;\n+import io.github.hapjava.characteristics.impl.lightbulb.BrightnessCharacteristic;\n+import io.github.hapjava.characteristics.impl.lightbulb.ColorTemperatureCharacteristic;\n+import io.github.hapjava.characteristics.impl.lightbulb.HueCharacteristic;\n+import io.github.hapjava.characteristics.impl.lightbulb.SaturationCharacteristic;\n+import io.github.hapjava.characteristics.impl.valve.RemainingDurationCharacteristic;\n+import io.github.hapjava.characteristics.impl.valve.SetDurationCharacteristic;\n+import io.github.hapjava.characteristics.impl.windowcovering.CurrentHorizontalTiltAngleCharacteristic;\n+import io.github.hapjava.characteristics.impl.windowcovering.CurrentVerticalTiltAngleCharacteristic;\n+import io.github.hapjava.characteristics.impl.windowcovering.HoldPositionCharacteristic;\n+import io.github.hapjava.characteristics.impl.windowcovering.TargetHorizontalTiltAngleCharacteristic;\n+import io.github.hapjava.characteristics.impl.windowcovering.TargetVerticalTiltAngleCharacteristic;\n+\n+/**\n+ * Creates a optional characteristics .\n+ *\n+ * @author Eugen Freiter - Initial contribution\n+ */\n+public class HomekitCharacteristicFactory {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(HomekitCharacteristicFactory.class);\n+\n+    // List of optional characteristics and corresponding method to create them.\n+    private final static Map<HomekitCharacteristicType, BiFunction<GenericItem, HomekitAccessoryUpdater, Characteristic>> optional = new HashMap<HomekitCharacteristicType, BiFunction<GenericItem, HomekitAccessoryUpdater, Characteristic>>() {\n+        {\n+            put(NAME, HomekitCharacteristicFactory::createNameCharacteristic);\n+            put(BATTERY_LOW_STATUS, HomekitCharacteristicFactory::createStatusLowBatteryCharacteristic);\n+            put(FAULT_STATUS, HomekitCharacteristicFactory::createStatusFaultCharacteristic);\n+            put(TAMPERED_STATUS, HomekitCharacteristicFactory::createStatusTamperedCharacteristic);\n+            put(ACTIVE_STATUS, HomekitCharacteristicFactory::createStatusActiveCharacteristic);\n+            put(CARBON_MONOXIDE_LEVEL, HomekitCharacteristicFactory::createCarbonMonoxideLevelCharacteristic);\n+            put(CARBON_MONOXIDE_PEAK_LEVEL, HomekitCharacteristicFactory::createCarbonMonoxidePeakLevelCharacteristic);\n+            put(CARBON_DIOXIDE_LEVEL, HomekitCharacteristicFactory::createCarbonDioxideLevelCharacteristic);\n+            put(CARBON_DIOXIDE_PEAK_LEVEL, HomekitCharacteristicFactory::createCarbonDioxidePeakLevelCharacteristic);\n+            put(HOLD_POSITION, HomekitCharacteristicFactory::createHoldPositionCharacteristic);\n+            put(OBSTRUCTION_STATUS, HomekitCharacteristicFactory::createObstructionDetectedCharacteristic);\n+            put(CURRENT_HORIZONTAL_TILT_ANGLE,\n+                    HomekitCharacteristicFactory::createCurrentHorizontalTiltAngleCharacteristic);\n+            put(CURRENT_VERTICAL_TILT_ANGLE,\n+                    HomekitCharacteristicFactory::createCurrentVerticalTiltAngleCharacteristic);\n+            put(TARGET_HORIZONTAL_TILT_ANGLE,\n+                    HomekitCharacteristicFactory::createTargetHorizontalTiltAngleCharacteristic);\n+            put(TARGET_VERTICAL_TILT_ANGLE, HomekitCharacteristicFactory::createTargetVerticalTiltAngleCharacteristic);\n+            put(HUE, HomekitCharacteristicFactory::createHueCharacteristic);\n+            put(BRIGHTNESS, HomekitCharacteristicFactory::createBrightnessCharacteristic);\n+            put(SATURATION, HomekitCharacteristicFactory::createSaturationCharacteristic);\n+            put(COLOR_TEMPERATURE, HomekitCharacteristicFactory::createColorTemperatureCharacteristic);\n+            put(CURRENT_FAN_STATE, HomekitCharacteristicFactory::createCurrentFanStateCharacteristic);\n+            put(TARGET_FAN_STATE, HomekitCharacteristicFactory::createTargetFanStateCharacteristic);\n+            put(ROTATION_DIRECTION, HomekitCharacteristicFactory::createRotationDirectionCharacteristic);\n+            put(ROTATION_SPEED, HomekitCharacteristicFactory::createRotationSpeedCharacteristic);\n+            put(SWING_MODE, HomekitCharacteristicFactory::createSwingModeCharacteristic);\n+            put(LOCK_CONTROL, HomekitCharacteristicFactory::createLockPhysicalControlsCharacteristic);\n+            put(DURATION, HomekitCharacteristicFactory::createDurationCharacteristic);\n+            put(REMAINING_DURATION, HomekitCharacteristicFactory::createRemainingDurationCharacteristic);\n+            // LEGACY\n+            put(OLD_BATTERY_LOW_STATUS, HomekitCharacteristicFactory::createStatusLowBatteryCharacteristic);\n+        }\n+    };\n+\n+    /**\n+     * create optional HomeKit characteristic\n+     * \n+     * @param type type of characteristic\n+     * @param item corresponding OH item\n+     * @param updater update to keep OH item and HomeKit characteristic in sync\n+     * @return HomeKit characteristic\n+     */\n+    public static Characteristic createCharacteristic(HomekitCharacteristicType type, GenericItem item,\n+            HomekitAccessoryUpdater updater) throws HomekitException {\n+        LOGGER.debug(\"createCharacteristic, type {} item {}\", type, item);\n+        if (type != null) {\n+            if (optional.containsKey(type)) {\n+                return optional.get(type).apply(item, updater);\n+            }\n+        }\n+        LOGGER.error(\"Unsupported optional characteristic. Item type {}, characteristic type {}\", item.getType(), type);", "originalCommit": "580ad0df55c3d1782ed3e5751c52bc756889a322", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc2NDEzNA==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r418764134", "bodyText": "Please add brackets to if statements", "author": "cpmeister", "createdAt": "2020-05-01T22:29:03Z", "path": "bundles/org.openhab.io.homekit/src/main/java/org/openhab/io/homekit/internal/accessories/HomekitCharacteristicFactory.java", "diffHunk": "@@ -0,0 +1,466 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.io.homekit.internal.accessories;\n+\n+import static org.openhab.io.homekit.internal.HomekitCharacteristicType.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.BiFunction;\n+import java.util.function.Supplier;\n+\n+import org.eclipse.smarthome.core.items.GenericItem;\n+import org.eclipse.smarthome.core.items.Item;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.io.homekit.internal.HomekitAccessoryUpdater;\n+import org.openhab.io.homekit.internal.HomekitCharacteristicType;\n+import org.openhab.io.homekit.internal.HomekitException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.github.hapjava.characteristics.Characteristic;\n+import io.github.hapjava.characteristics.CharacteristicEnum;\n+import io.github.hapjava.characteristics.impl.battery.StatusLowBatteryCharacteristic;\n+import io.github.hapjava.characteristics.impl.battery.StatusLowBatteryEnum;\n+import io.github.hapjava.characteristics.impl.carbondioxidesensor.CarbonDioxideLevelCharacteristic;\n+import io.github.hapjava.characteristics.impl.carbondioxidesensor.CarbonDioxidePeakLevelCharacteristic;\n+import io.github.hapjava.characteristics.impl.carbonmonoxidesensor.CarbonMonoxideLevelCharacteristic;\n+import io.github.hapjava.characteristics.impl.carbonmonoxidesensor.CarbonMonoxidePeakLevelCharacteristic;\n+import io.github.hapjava.characteristics.impl.common.NameCharacteristic;\n+import io.github.hapjava.characteristics.impl.common.ObstructionDetectedCharacteristic;\n+import io.github.hapjava.characteristics.impl.common.StatusActiveCharacteristic;\n+import io.github.hapjava.characteristics.impl.common.StatusFaultCharacteristic;\n+import io.github.hapjava.characteristics.impl.common.StatusFaultEnum;\n+import io.github.hapjava.characteristics.impl.common.StatusTamperedCharacteristic;\n+import io.github.hapjava.characteristics.impl.common.StatusTamperedEnum;\n+import io.github.hapjava.characteristics.impl.fan.CurrentFanStateCharacteristic;\n+import io.github.hapjava.characteristics.impl.fan.CurrentFanStateEnum;\n+import io.github.hapjava.characteristics.impl.fan.LockPhysicalControlsCharacteristic;\n+import io.github.hapjava.characteristics.impl.fan.LockPhysicalControlsEnum;\n+import io.github.hapjava.characteristics.impl.fan.RotationDirectionCharacteristic;\n+import io.github.hapjava.characteristics.impl.fan.RotationDirectionEnum;\n+import io.github.hapjava.characteristics.impl.fan.RotationSpeedCharacteristic;\n+import io.github.hapjava.characteristics.impl.fan.SwingModeCharacteristic;\n+import io.github.hapjava.characteristics.impl.fan.SwingModeEnum;\n+import io.github.hapjava.characteristics.impl.fan.TargetFanStateCharacteristic;\n+import io.github.hapjava.characteristics.impl.fan.TargetFanStateEnum;\n+import io.github.hapjava.characteristics.impl.lightbulb.BrightnessCharacteristic;\n+import io.github.hapjava.characteristics.impl.lightbulb.ColorTemperatureCharacteristic;\n+import io.github.hapjava.characteristics.impl.lightbulb.HueCharacteristic;\n+import io.github.hapjava.characteristics.impl.lightbulb.SaturationCharacteristic;\n+import io.github.hapjava.characteristics.impl.valve.RemainingDurationCharacteristic;\n+import io.github.hapjava.characteristics.impl.valve.SetDurationCharacteristic;\n+import io.github.hapjava.characteristics.impl.windowcovering.CurrentHorizontalTiltAngleCharacteristic;\n+import io.github.hapjava.characteristics.impl.windowcovering.CurrentVerticalTiltAngleCharacteristic;\n+import io.github.hapjava.characteristics.impl.windowcovering.HoldPositionCharacteristic;\n+import io.github.hapjava.characteristics.impl.windowcovering.TargetHorizontalTiltAngleCharacteristic;\n+import io.github.hapjava.characteristics.impl.windowcovering.TargetVerticalTiltAngleCharacteristic;\n+\n+/**\n+ * Creates a optional characteristics .\n+ *\n+ * @author Eugen Freiter - Initial contribution\n+ */\n+public class HomekitCharacteristicFactory {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(HomekitCharacteristicFactory.class);\n+\n+    // List of optional characteristics and corresponding method to create them.\n+    private final static Map<HomekitCharacteristicType, BiFunction<GenericItem, HomekitAccessoryUpdater, Characteristic>> optional = new HashMap<HomekitCharacteristicType, BiFunction<GenericItem, HomekitAccessoryUpdater, Characteristic>>() {\n+        {\n+            put(NAME, HomekitCharacteristicFactory::createNameCharacteristic);\n+            put(BATTERY_LOW_STATUS, HomekitCharacteristicFactory::createStatusLowBatteryCharacteristic);\n+            put(FAULT_STATUS, HomekitCharacteristicFactory::createStatusFaultCharacteristic);\n+            put(TAMPERED_STATUS, HomekitCharacteristicFactory::createStatusTamperedCharacteristic);\n+            put(ACTIVE_STATUS, HomekitCharacteristicFactory::createStatusActiveCharacteristic);\n+            put(CARBON_MONOXIDE_LEVEL, HomekitCharacteristicFactory::createCarbonMonoxideLevelCharacteristic);\n+            put(CARBON_MONOXIDE_PEAK_LEVEL, HomekitCharacteristicFactory::createCarbonMonoxidePeakLevelCharacteristic);\n+            put(CARBON_DIOXIDE_LEVEL, HomekitCharacteristicFactory::createCarbonDioxideLevelCharacteristic);\n+            put(CARBON_DIOXIDE_PEAK_LEVEL, HomekitCharacteristicFactory::createCarbonDioxidePeakLevelCharacteristic);\n+            put(HOLD_POSITION, HomekitCharacteristicFactory::createHoldPositionCharacteristic);\n+            put(OBSTRUCTION_STATUS, HomekitCharacteristicFactory::createObstructionDetectedCharacteristic);\n+            put(CURRENT_HORIZONTAL_TILT_ANGLE,\n+                    HomekitCharacteristicFactory::createCurrentHorizontalTiltAngleCharacteristic);\n+            put(CURRENT_VERTICAL_TILT_ANGLE,\n+                    HomekitCharacteristicFactory::createCurrentVerticalTiltAngleCharacteristic);\n+            put(TARGET_HORIZONTAL_TILT_ANGLE,\n+                    HomekitCharacteristicFactory::createTargetHorizontalTiltAngleCharacteristic);\n+            put(TARGET_VERTICAL_TILT_ANGLE, HomekitCharacteristicFactory::createTargetVerticalTiltAngleCharacteristic);\n+            put(HUE, HomekitCharacteristicFactory::createHueCharacteristic);\n+            put(BRIGHTNESS, HomekitCharacteristicFactory::createBrightnessCharacteristic);\n+            put(SATURATION, HomekitCharacteristicFactory::createSaturationCharacteristic);\n+            put(COLOR_TEMPERATURE, HomekitCharacteristicFactory::createColorTemperatureCharacteristic);\n+            put(CURRENT_FAN_STATE, HomekitCharacteristicFactory::createCurrentFanStateCharacteristic);\n+            put(TARGET_FAN_STATE, HomekitCharacteristicFactory::createTargetFanStateCharacteristic);\n+            put(ROTATION_DIRECTION, HomekitCharacteristicFactory::createRotationDirectionCharacteristic);\n+            put(ROTATION_SPEED, HomekitCharacteristicFactory::createRotationSpeedCharacteristic);\n+            put(SWING_MODE, HomekitCharacteristicFactory::createSwingModeCharacteristic);\n+            put(LOCK_CONTROL, HomekitCharacteristicFactory::createLockPhysicalControlsCharacteristic);\n+            put(DURATION, HomekitCharacteristicFactory::createDurationCharacteristic);\n+            put(REMAINING_DURATION, HomekitCharacteristicFactory::createRemainingDurationCharacteristic);\n+            // LEGACY\n+            put(OLD_BATTERY_LOW_STATUS, HomekitCharacteristicFactory::createStatusLowBatteryCharacteristic);\n+        }\n+    };\n+\n+    /**\n+     * create optional HomeKit characteristic\n+     * \n+     * @param type type of characteristic\n+     * @param item corresponding OH item\n+     * @param updater update to keep OH item and HomeKit characteristic in sync\n+     * @return HomeKit characteristic\n+     */\n+    public static Characteristic createCharacteristic(HomekitCharacteristicType type, GenericItem item,\n+            HomekitAccessoryUpdater updater) throws HomekitException {\n+        LOGGER.debug(\"createCharacteristic, type {} item {}\", type, item);\n+        if (type != null) {\n+            if (optional.containsKey(type)) {\n+                return optional.get(type).apply(item, updater);\n+            }\n+        }\n+        LOGGER.error(\"Unsupported optional characteristic. Item type {}, characteristic type {}\", item.getType(), type);\n+        throw new HomekitException(\"Unsupported optional characteristic. Characteristic type \\\"\" + item.getType());\n+    }\n+\n+    // METHODS TO CREATE SINGLE CHARACTERISTIC FROM OH ITEM\n+\n+    // supporting methods\n+    private static <T extends CharacteristicEnum> CompletableFuture<T> getEnumFromItem(GenericItem item, T offEnum,\n+            T onEnum, T defaultEnum) {\n+        final State state = item.getState();\n+        if (state instanceof OnOffType)", "originalCommit": "580ad0df55c3d1782ed3e5751c52bc756889a322", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b621e7f72123037228334dea5aad3511eea60e25", "url": "https://github.com/openhab/openhab-addons/commit/b621e7f72123037228334dea5aad3511eea60e25", "message": "Incorporated changes from review\n\nSigned-off-by: Eugen Freiter <freiter@gmx.de>", "committedDate": "2020-05-02T10:43:30Z", "type": "commit"}, {"oid": "d5f1e15b388561676aa8747515dd681411ca769d", "url": "https://github.com/openhab/openhab-addons/commit/d5f1e15b388561676aa8747515dd681411ca769d", "message": "fix number cast, fix value mapping for contact sensor (OPEN = contact NOT_DETECTED)\n\nSigned-off-by: Eugen Freiter <freiter@gmx.de>", "committedDate": "2020-05-02T12:46:47Z", "type": "commit"}, {"oid": "d5f1e15b388561676aa8747515dd681411ca769d", "url": "https://github.com/openhab/openhab-addons/commit/d5f1e15b388561676aa8747515dd681411ca769d", "message": "fix number cast, fix value mapping for contact sensor (OPEN = contact NOT_DETECTED)\n\nSigned-off-by: Eugen Freiter <freiter@gmx.de>", "committedDate": "2020-05-02T12:46:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA0NTY0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r419045647", "bodyText": "Can this be made final?", "author": "cpmeister", "createdAt": "2020-05-03T04:32:28Z", "path": "bundles/org.openhab.io.homekit/src/main/java/org/openhab/io/homekit/internal/accessories/AbstractHomekitAccessoryImpl.java", "diffHunk": "@@ -12,95 +12,159 @@\n  */\n package org.openhab.io.homekit.internal.accessories;\n \n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n import org.eclipse.smarthome.core.items.GenericItem;\n-import org.eclipse.smarthome.core.items.GroupItem;\n import org.eclipse.smarthome.core.items.Item;\n-import org.eclipse.smarthome.core.items.ItemRegistry;\n+import org.eclipse.smarthome.core.types.State;\n import org.openhab.io.homekit.internal.HomekitAccessoryUpdater;\n+import org.openhab.io.homekit.internal.HomekitCharacteristicType;\n+import org.openhab.io.homekit.internal.HomekitSettings;\n import org.openhab.io.homekit.internal.HomekitTaggedItem;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import io.github.hapjava.HomekitAccessory;\n+import io.github.hapjava.accessories.HomekitAccessory;\n+import io.github.hapjava.characteristics.HomekitCharacteristicChangeCallback;\n+import io.github.hapjava.services.Service;\n \n /**\n- * Abstract class for HomekitAccessory implementations, this provides the\n+ * Abstract class for Homekit Accessory implementations, this provides the\n  * accessory metadata using information from the underlying Item.\n  *\n  * @author Andy Lintner - Initial contribution\n  */\n-abstract class AbstractHomekitAccessoryImpl<T extends GenericItem> implements HomekitAccessory {\n-\n-    private final int accessoryId;\n-    private final String itemName;\n-    private final String itemLabel;\n-    private final ItemRegistry itemRegistry;\n+abstract class AbstractHomekitAccessoryImpl implements HomekitAccessory {\n+    private final Logger logger = LoggerFactory.getLogger(AbstractHomekitAccessoryImpl.class);\n+    protected List<HomekitTaggedItem> characteristics;", "originalCommit": "d5f1e15b388561676aa8747515dd681411ca769d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA3NDU2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r419074565", "bodyText": "good point. it can be final and private.", "author": "yfre", "createdAt": "2020-05-03T09:20:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA0NTY0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA0NjI2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r419046266", "bodyText": "Please cache mandatoryCharacteristics.get(taggedItem.getAccessoryType()) into a local variable for reuse", "author": "cpmeister", "createdAt": "2020-05-03T04:40:57Z", "path": "bundles/org.openhab.io.homekit/src/main/java/org/openhab/io/homekit/internal/accessories/HomekitAccessoryFactory.java", "diffHunk": "@@ -12,156 +12,417 @@\n  */\n package org.openhab.io.homekit.internal.accessories;\n \n+import static org.openhab.io.homekit.internal.HomekitAccessoryType.*;\n+import static org.openhab.io.homekit.internal.HomekitCharacteristicType.*;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.AbstractMap.SimpleEntry;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n+import java.util.Map.Entry;\n import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.items.GenericItem;\n import org.eclipse.smarthome.core.items.GroupItem;\n import org.eclipse.smarthome.core.items.Item;\n import org.eclipse.smarthome.core.items.ItemRegistry;\n+import org.eclipse.smarthome.core.items.Metadata;\n+import org.eclipse.smarthome.core.items.MetadataKey;\n+import org.eclipse.smarthome.core.items.MetadataRegistry;\n+import org.eclipse.smarthome.core.library.items.ColorItem;\n+import org.eclipse.smarthome.core.library.items.DimmerItem;\n import org.openhab.io.homekit.internal.HomekitAccessoryType;\n import org.openhab.io.homekit.internal.HomekitAccessoryUpdater;\n import org.openhab.io.homekit.internal.HomekitCharacteristicType;\n import org.openhab.io.homekit.internal.HomekitException;\n import org.openhab.io.homekit.internal.HomekitSettings;\n import org.openhab.io.homekit.internal.HomekitTaggedItem;\n-import org.openhab.io.homekit.internal.battery.BatteryStatus;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import io.github.hapjava.HomekitAccessory;\n+import io.github.hapjava.accessories.HomekitAccessory;\n+import io.github.hapjava.characteristics.Characteristic;\n+import io.github.hapjava.services.Service;\n \n /**\n  * Creates a HomekitAccessory for a given HomekitTaggedItem.\n  *\n  * @author Andy Lintner - Initial contribution\n+ * @author Eugen Freiter - refactoring for optional characteristics\n  */\n+@NonNullByDefault\n public class HomekitAccessoryFactory {\n-    private static final Logger LOGGER = LoggerFactory.getLogger(HomekitAccessoryFactory.class);\n-\n-    @SuppressWarnings(\"deprecation\")\n-    public static HomekitAccessory create(HomekitTaggedItem taggedItem, ItemRegistry itemRegistry,\n-            HomekitAccessoryUpdater updater, HomekitSettings settings)\n-            throws HomekitException, IncompleteAccessoryException {\n-        LOGGER.debug(\"Constructing {} of accessoryType {}\", taggedItem.getName(), taggedItem.getAccessoryType());\n-\n-        Map<HomekitCharacteristicType, Item> characteristicItems = getCharacteristicItems(taggedItem);\n-\n-        switch (taggedItem.getAccessoryType()) {\n-            case LEAK_SENSOR:\n-                HomekitTaggedItem leakSensorAccessory = getPrimaryAccessory(taggedItem,\n-                        HomekitAccessoryType.LEAK_SENSOR, itemRegistry).orElseThrow(\n-                                () -> new HomekitException(\"Leak accessory group should have a leak sensor in it\"));\n-\n-                return new HomekitLeakSensorImpl(leakSensorAccessory, itemRegistry, updater,\n-                        BatteryStatus.getFromCharacteristics(characteristicItems));\n-            case VALVE:\n-                return new HomekitValveImpl(taggedItem, itemRegistry, updater);\n-            case MOTION_SENSOR:\n-                HomekitTaggedItem motionSensorAccessory = getPrimaryAccessory(taggedItem,\n-                        HomekitAccessoryType.MOTION_SENSOR, itemRegistry)\n-                                .orElseThrow(() -> new HomekitException(\n-                                        \"Motion sensor accessory group should have a motion sensor item in it\"));\n-                return new HomekitMotionSensorImpl(motionSensorAccessory, itemRegistry, updater,\n-                        BatteryStatus.getFromCharacteristics(characteristicItems));\n-            case OCCUPANCY_SENSOR:\n-                HomekitTaggedItem occupancySensorAccessory = getPrimaryAccessory(taggedItem,\n-                        HomekitAccessoryType.OCCUPANCY_SENSOR, itemRegistry)\n-                                .orElseThrow(() -> new HomekitException(\n-                                        \"Occupancy sensor accessory group should have a occupancy sensor item in it\"));\n-                return new HomekitOccupancySensorImpl(occupancySensorAccessory, itemRegistry, updater,\n-                        BatteryStatus.getFromCharacteristics(characteristicItems));\n-            case CONTACT_SENSOR:\n-                HomekitTaggedItem contactSensorAccessory = getPrimaryAccessory(taggedItem,\n-                        HomekitAccessoryType.CONTACT_SENSOR, itemRegistry)\n-                                .orElseThrow(() -> new HomekitException(\n-                                        \"Contact sensor accessory group should have a occupancy sensor item in it\"));\n-                return new HomekitContactSensorImpl(contactSensorAccessory, itemRegistry, updater,\n-                        BatteryStatus.getFromCharacteristics(characteristicItems));\n-            case LIGHTBULB:\n-                return new HomekitLightbulbImpl(taggedItem, itemRegistry, updater);\n-            case DIMMABLE_LIGHTBULB:\n-                return new HomekitDimmableLightbulbImpl(taggedItem, itemRegistry, updater);\n-            case COLORFUL_LIGHTBULB:\n-                return new HomekitColorfulLightbulbImpl(taggedItem, itemRegistry, updater);\n-            case THERMOSTAT:\n-                HomekitTaggedItem temperatureAccessory = getPrimaryAccessory(taggedItem,\n-                        HomekitAccessoryType.TEMPERATURE_SENSOR, itemRegistry).orElseThrow(\n-                                () -> new HomekitException(\"Thermostats need a CurrentTemperature accessory\"));\n-                return new HomekitThermostatImpl(taggedItem, itemRegistry, updater, settings,\n-                        temperatureAccessory.getItem(), getCharacteristicItems(taggedItem));\n-            case SWITCH:\n-                return new HomekitSwitchImpl(taggedItem, itemRegistry, updater);\n-            case TEMPERATURE_SENSOR:\n-                return new HomekitTemperatureSensorImpl(taggedItem, itemRegistry, updater, settings);\n-            case HUMIDITY_SENSOR:\n-                return new HomekitHumiditySensorImpl(taggedItem, itemRegistry, updater);\n-            case BLINDS:\n-            case WINDOW_COVERING:\n-                return new HomekitWindowCoveringImpl(taggedItem, itemRegistry, updater);\n-            case SMOKE_SENSOR:\n-                HomekitTaggedItem smokeSensorAccessory = getPrimaryAccessory(taggedItem,\n-                        HomekitAccessoryType.SMOKE_SENSOR, itemRegistry).orElseThrow(\n-                                () -> new HomekitException(\"Smoke accessory group should have a smoke sensor in it\"));\n-                return new HomekitSmokeSensorImpl(smokeSensorAccessory, itemRegistry, updater,\n-                        BatteryStatus.getFromCharacteristics(characteristicItems));\n-            case CARBON_MONOXIDE_SENSOR:\n-                HomekitTaggedItem carbonMonoxideSensorAccessory = getPrimaryAccessory(taggedItem,\n-                        HomekitAccessoryType.CARBON_MONOXIDE_SENSOR, itemRegistry)\n-                                .orElseThrow(() -> new HomekitException(\n-                                        \"Carbon monoxide accessory group should have a carbon monoxide sensor in it\"));\n-                return new HomekitSmokeSensorImpl(carbonMonoxideSensorAccessory, itemRegistry, updater,\n-                        BatteryStatus.getFromCharacteristics(characteristicItems));\n-            case LOCK:\n-                return new HomekitLockImpl(taggedItem, itemRegistry, updater);\n+    private static final Logger logger = LoggerFactory.getLogger(HomekitAccessoryFactory.class);\n+    public final static String METADATA_KEY = \"homekit\"; // prefix for HomeKit meta information in items.xml\n+\n+    /** List of mandatory attributes for each accessory type. **/\n+    private final static Map<HomekitAccessoryType, HomekitCharacteristicType[]> mandatoryCharacteristics = new HashMap<HomekitAccessoryType, HomekitCharacteristicType[]>() {\n+        {\n+            put(LEAK_SENSOR, new HomekitCharacteristicType[] { LEAK_DETECTED_STATE });\n+            put(MOTION_SENSOR, new HomekitCharacteristicType[] { MOTION_DETECTED_STATE });\n+            put(OCCUPANCY_SENSOR, new HomekitCharacteristicType[] { OCCUPANCY_DETECTED_STATE });\n+            put(CONTACT_SENSOR, new HomekitCharacteristicType[] { CONTACT_SENSOR_STATE });\n+            put(SMOKE_SENSOR, new HomekitCharacteristicType[] { SMOKE_DETECTED_STATE });\n+            put(HUMIDITY_SENSOR, new HomekitCharacteristicType[] { RELATIVE_HUMIDITY });\n+            put(SWITCH, new HomekitCharacteristicType[] { ON_STATE });\n+            put(CARBON_DIOXIDE_SENSOR, new HomekitCharacteristicType[] { CARBON_DIOXIDE_DETECTED_STATE });\n+            put(CARBON_MONOXIDE_SENSOR, new HomekitCharacteristicType[] { CARBON_MONOXIDE_DETECTED_STATE });\n+            put(WINDOW_COVERING, new HomekitCharacteristicType[] { TARGET_POSITION, CURRENT_POSITION, POSITION_STATE });\n+            put(LIGHTBULB, new HomekitCharacteristicType[] { ON_STATE });\n+            put(FAN, new HomekitCharacteristicType[] { ACTIVE_STATUS });\n+            put(TEMPERATURE_SENSOR, new HomekitCharacteristicType[] { CURRENT_TEMPERATURE });\n+            put(THERMOSTAT, new HomekitCharacteristicType[] { CURRENT_HEATING_COOLING_STATE,\n+                    TARGET_HEATING_COOLING_STATE, CURRENT_TEMPERATURE, TARGET_TEMPERATURE });\n+            put(LOCK, new HomekitCharacteristicType[] { LOCK_CURRENT_STATE, LOCK_TARGET_STATE });\n+            put(VALVE, new HomekitCharacteristicType[] { ACTIVE_STATUS, INUSE_STATUS });\n+            put(SECURITY_SYSTEM,\n+                    new HomekitCharacteristicType[] { SECURITY_SYSTEM_CURRENT_STATE, SECURITY_SYSTEM_TARGET_STATE });\n+            // LEGACY\n+            put(BLINDS, new HomekitCharacteristicType[] { TARGET_POSITION, CURRENT_POSITION, POSITION_STATE });\n+            put(OLD_HUMIDITY_SENSOR, new HomekitCharacteristicType[] { RELATIVE_HUMIDITY });\n+            put(OLD_DIMMABLE_LIGHTBULB, new HomekitCharacteristicType[] { ON_STATE });\n+            put(OLD_COLORFUL_LIGHTBULB, new HomekitCharacteristicType[] { ON_STATE });\n+        }\n+    };\n+\n+    /** List of service implementation for each accessory type. **/\n+    private final static Map<HomekitAccessoryType, Class<? extends AbstractHomekitAccessoryImpl>> serviceImplMap = new HashMap<HomekitAccessoryType, Class<? extends AbstractHomekitAccessoryImpl>>() {\n+        {\n+            put(LEAK_SENSOR, HomekitLeakSensorImpl.class);\n+            put(MOTION_SENSOR, HomekitMotionSensorImpl.class);\n+            put(OCCUPANCY_SENSOR, HomekitOccupancySensorImpl.class);\n+            put(CONTACT_SENSOR, HomekitContactSensorImpl.class);\n+            put(TEMPERATURE_SENSOR, HomekitTemperatureSensorImpl.class);\n+            put(SMOKE_SENSOR, HomekitSmokeSensorImpl.class);\n+            put(HUMIDITY_SENSOR, HomekitHumiditySensorImpl.class);\n+            put(SWITCH, HomekitSwitchImpl.class);\n+            put(CARBON_DIOXIDE_SENSOR, HomekitCarbonDioxideSensorImpl.class);\n+            put(CARBON_MONOXIDE_SENSOR, HomekitCarbonMonoxideSensorImpl.class);\n+            put(WINDOW_COVERING, HomekitWindowCoveringImpl.class);\n+            put(LIGHTBULB, HomekitLightbulbImpl.class);\n+            put(FAN, HomekitFanImpl.class);\n+            put(TEMPERATURE_SENSOR, HomekitTemperatureSensorImpl.class);\n+            put(THERMOSTAT, HomekitThermostatImpl.class);\n+            put(LOCK, HomekitLockImpl.class);\n+            put(VALVE, HomekitValveImpl.class);\n+            put(SECURITY_SYSTEM, HomekitSecuritySystemImpl.class);\n+            put(BLINDS, HomekitWindowCoveringImpl.class);\n+            put(OLD_HUMIDITY_SENSOR, HomekitHumiditySensorImpl.class);\n+            put(OLD_DIMMABLE_LIGHTBULB, HomekitLightbulbImpl.class);\n+            put(OLD_COLORFUL_LIGHTBULB, HomekitLightbulbImpl.class);\n+\n+        }\n+    };\n+\n+    /** mapping of legacy attributes to new attributes. **/\n+    private final static Map<HomekitCharacteristicType, HomekitCharacteristicType> legacyCharacteristicsMapping = new HashMap<HomekitCharacteristicType, HomekitCharacteristicType>() {\n+        {\n+            put(OLD_CURRENT_HEATING_COOLING_STATE, CURRENT_HEATING_COOLING_STATE);\n+            put(OLD_TARGET_HEATING_COOLING_MODE, TARGET_HEATING_COOLING_STATE);\n+            put(OLD_TARGET_TEMPERATURE, TARGET_TEMPERATURE);\n+            put(OLD_BATTERY_LOW_STATUS, BATTERY_LOW_STATUS);\n+            put(VERY_OLD_TARGET_HEATING_COOLING_MODE, CURRENT_HEATING_COOLING_STATE);\n+        }\n+    };\n+\n+    /** list of optional implicit optional characteristics. mainly used for legacy accessory type */\n+    private final static Map<HomekitAccessoryType, HomekitCharacteristicType[]> implicitOptionalCharacteristics = new HashMap<HomekitAccessoryType, HomekitCharacteristicType[]>() {\n+        {\n+            put(OLD_DIMMABLE_LIGHTBULB, new HomekitCharacteristicType[] { BRIGHTNESS });\n+            put(OLD_COLORFUL_LIGHTBULB, new HomekitCharacteristicType[] { HUE, SATURATION, BRIGHTNESS });\n+\n+        }\n+    };\n+\n+    /**\n+     * creates HomeKit accessory for a openhab item.\n+     * \n+     * @param taggedItem openhab item tagged as HomeKit item\n+     * @param metadataRegistry openhab metadata registry required to get item meta information\n+     * @param updater OH HomeKit update class that ensure the status sync between OH item and corresponding HomeKit\n+     *            characteristic.\n+     * @param settings OH settings\n+     * @return HomeKit accessory\n+     * @throws HomekitException exception in case HomeKit accessory could not be created, e.g. due missing mandatory\n+     *             characteristic\n+     */\n+    public static HomekitAccessory create(HomekitTaggedItem taggedItem, MetadataRegistry metadataRegistry,\n+            HomekitAccessoryUpdater updater, HomekitSettings settings) throws HomekitException {\n+\n+        logger.trace(\"Constructing {} of accessoryType {}\", taggedItem.getName(), taggedItem.getAccessoryType());\n+        final List<HomekitTaggedItem> requiredCharacteristics = getMandatoryCharacteristics(taggedItem,\n+                metadataRegistry);\n+        if ((mandatoryCharacteristics.get(taggedItem.getAccessoryType()) != null) && (requiredCharacteristics", "originalCommit": "d5f1e15b388561676aa8747515dd681411ca769d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA3NDk4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r419074982", "bodyText": "yeah. that one was used in every second line. fixed, replaced with local variable.", "author": "yfre", "createdAt": "2020-05-03T09:24:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA0NjI2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA0Njc4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r419046787", "bodyText": "Is this kind of reflection really necessary?", "author": "cpmeister", "createdAt": "2020-05-03T04:47:47Z", "path": "bundles/org.openhab.io.homekit/src/main/java/org/openhab/io/homekit/internal/accessories/HomekitAccessoryFactory.java", "diffHunk": "@@ -12,156 +12,417 @@\n  */\n package org.openhab.io.homekit.internal.accessories;\n \n+import static org.openhab.io.homekit.internal.HomekitAccessoryType.*;\n+import static org.openhab.io.homekit.internal.HomekitCharacteristicType.*;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.AbstractMap.SimpleEntry;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n+import java.util.Map.Entry;\n import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.items.GenericItem;\n import org.eclipse.smarthome.core.items.GroupItem;\n import org.eclipse.smarthome.core.items.Item;\n import org.eclipse.smarthome.core.items.ItemRegistry;\n+import org.eclipse.smarthome.core.items.Metadata;\n+import org.eclipse.smarthome.core.items.MetadataKey;\n+import org.eclipse.smarthome.core.items.MetadataRegistry;\n+import org.eclipse.smarthome.core.library.items.ColorItem;\n+import org.eclipse.smarthome.core.library.items.DimmerItem;\n import org.openhab.io.homekit.internal.HomekitAccessoryType;\n import org.openhab.io.homekit.internal.HomekitAccessoryUpdater;\n import org.openhab.io.homekit.internal.HomekitCharacteristicType;\n import org.openhab.io.homekit.internal.HomekitException;\n import org.openhab.io.homekit.internal.HomekitSettings;\n import org.openhab.io.homekit.internal.HomekitTaggedItem;\n-import org.openhab.io.homekit.internal.battery.BatteryStatus;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import io.github.hapjava.HomekitAccessory;\n+import io.github.hapjava.accessories.HomekitAccessory;\n+import io.github.hapjava.characteristics.Characteristic;\n+import io.github.hapjava.services.Service;\n \n /**\n  * Creates a HomekitAccessory for a given HomekitTaggedItem.\n  *\n  * @author Andy Lintner - Initial contribution\n+ * @author Eugen Freiter - refactoring for optional characteristics\n  */\n+@NonNullByDefault\n public class HomekitAccessoryFactory {\n-    private static final Logger LOGGER = LoggerFactory.getLogger(HomekitAccessoryFactory.class);\n-\n-    @SuppressWarnings(\"deprecation\")\n-    public static HomekitAccessory create(HomekitTaggedItem taggedItem, ItemRegistry itemRegistry,\n-            HomekitAccessoryUpdater updater, HomekitSettings settings)\n-            throws HomekitException, IncompleteAccessoryException {\n-        LOGGER.debug(\"Constructing {} of accessoryType {}\", taggedItem.getName(), taggedItem.getAccessoryType());\n-\n-        Map<HomekitCharacteristicType, Item> characteristicItems = getCharacteristicItems(taggedItem);\n-\n-        switch (taggedItem.getAccessoryType()) {\n-            case LEAK_SENSOR:\n-                HomekitTaggedItem leakSensorAccessory = getPrimaryAccessory(taggedItem,\n-                        HomekitAccessoryType.LEAK_SENSOR, itemRegistry).orElseThrow(\n-                                () -> new HomekitException(\"Leak accessory group should have a leak sensor in it\"));\n-\n-                return new HomekitLeakSensorImpl(leakSensorAccessory, itemRegistry, updater,\n-                        BatteryStatus.getFromCharacteristics(characteristicItems));\n-            case VALVE:\n-                return new HomekitValveImpl(taggedItem, itemRegistry, updater);\n-            case MOTION_SENSOR:\n-                HomekitTaggedItem motionSensorAccessory = getPrimaryAccessory(taggedItem,\n-                        HomekitAccessoryType.MOTION_SENSOR, itemRegistry)\n-                                .orElseThrow(() -> new HomekitException(\n-                                        \"Motion sensor accessory group should have a motion sensor item in it\"));\n-                return new HomekitMotionSensorImpl(motionSensorAccessory, itemRegistry, updater,\n-                        BatteryStatus.getFromCharacteristics(characteristicItems));\n-            case OCCUPANCY_SENSOR:\n-                HomekitTaggedItem occupancySensorAccessory = getPrimaryAccessory(taggedItem,\n-                        HomekitAccessoryType.OCCUPANCY_SENSOR, itemRegistry)\n-                                .orElseThrow(() -> new HomekitException(\n-                                        \"Occupancy sensor accessory group should have a occupancy sensor item in it\"));\n-                return new HomekitOccupancySensorImpl(occupancySensorAccessory, itemRegistry, updater,\n-                        BatteryStatus.getFromCharacteristics(characteristicItems));\n-            case CONTACT_SENSOR:\n-                HomekitTaggedItem contactSensorAccessory = getPrimaryAccessory(taggedItem,\n-                        HomekitAccessoryType.CONTACT_SENSOR, itemRegistry)\n-                                .orElseThrow(() -> new HomekitException(\n-                                        \"Contact sensor accessory group should have a occupancy sensor item in it\"));\n-                return new HomekitContactSensorImpl(contactSensorAccessory, itemRegistry, updater,\n-                        BatteryStatus.getFromCharacteristics(characteristicItems));\n-            case LIGHTBULB:\n-                return new HomekitLightbulbImpl(taggedItem, itemRegistry, updater);\n-            case DIMMABLE_LIGHTBULB:\n-                return new HomekitDimmableLightbulbImpl(taggedItem, itemRegistry, updater);\n-            case COLORFUL_LIGHTBULB:\n-                return new HomekitColorfulLightbulbImpl(taggedItem, itemRegistry, updater);\n-            case THERMOSTAT:\n-                HomekitTaggedItem temperatureAccessory = getPrimaryAccessory(taggedItem,\n-                        HomekitAccessoryType.TEMPERATURE_SENSOR, itemRegistry).orElseThrow(\n-                                () -> new HomekitException(\"Thermostats need a CurrentTemperature accessory\"));\n-                return new HomekitThermostatImpl(taggedItem, itemRegistry, updater, settings,\n-                        temperatureAccessory.getItem(), getCharacteristicItems(taggedItem));\n-            case SWITCH:\n-                return new HomekitSwitchImpl(taggedItem, itemRegistry, updater);\n-            case TEMPERATURE_SENSOR:\n-                return new HomekitTemperatureSensorImpl(taggedItem, itemRegistry, updater, settings);\n-            case HUMIDITY_SENSOR:\n-                return new HomekitHumiditySensorImpl(taggedItem, itemRegistry, updater);\n-            case BLINDS:\n-            case WINDOW_COVERING:\n-                return new HomekitWindowCoveringImpl(taggedItem, itemRegistry, updater);\n-            case SMOKE_SENSOR:\n-                HomekitTaggedItem smokeSensorAccessory = getPrimaryAccessory(taggedItem,\n-                        HomekitAccessoryType.SMOKE_SENSOR, itemRegistry).orElseThrow(\n-                                () -> new HomekitException(\"Smoke accessory group should have a smoke sensor in it\"));\n-                return new HomekitSmokeSensorImpl(smokeSensorAccessory, itemRegistry, updater,\n-                        BatteryStatus.getFromCharacteristics(characteristicItems));\n-            case CARBON_MONOXIDE_SENSOR:\n-                HomekitTaggedItem carbonMonoxideSensorAccessory = getPrimaryAccessory(taggedItem,\n-                        HomekitAccessoryType.CARBON_MONOXIDE_SENSOR, itemRegistry)\n-                                .orElseThrow(() -> new HomekitException(\n-                                        \"Carbon monoxide accessory group should have a carbon monoxide sensor in it\"));\n-                return new HomekitSmokeSensorImpl(carbonMonoxideSensorAccessory, itemRegistry, updater,\n-                        BatteryStatus.getFromCharacteristics(characteristicItems));\n-            case LOCK:\n-                return new HomekitLockImpl(taggedItem, itemRegistry, updater);\n+    private static final Logger logger = LoggerFactory.getLogger(HomekitAccessoryFactory.class);\n+    public final static String METADATA_KEY = \"homekit\"; // prefix for HomeKit meta information in items.xml\n+\n+    /** List of mandatory attributes for each accessory type. **/\n+    private final static Map<HomekitAccessoryType, HomekitCharacteristicType[]> mandatoryCharacteristics = new HashMap<HomekitAccessoryType, HomekitCharacteristicType[]>() {\n+        {\n+            put(LEAK_SENSOR, new HomekitCharacteristicType[] { LEAK_DETECTED_STATE });\n+            put(MOTION_SENSOR, new HomekitCharacteristicType[] { MOTION_DETECTED_STATE });\n+            put(OCCUPANCY_SENSOR, new HomekitCharacteristicType[] { OCCUPANCY_DETECTED_STATE });\n+            put(CONTACT_SENSOR, new HomekitCharacteristicType[] { CONTACT_SENSOR_STATE });\n+            put(SMOKE_SENSOR, new HomekitCharacteristicType[] { SMOKE_DETECTED_STATE });\n+            put(HUMIDITY_SENSOR, new HomekitCharacteristicType[] { RELATIVE_HUMIDITY });\n+            put(SWITCH, new HomekitCharacteristicType[] { ON_STATE });\n+            put(CARBON_DIOXIDE_SENSOR, new HomekitCharacteristicType[] { CARBON_DIOXIDE_DETECTED_STATE });\n+            put(CARBON_MONOXIDE_SENSOR, new HomekitCharacteristicType[] { CARBON_MONOXIDE_DETECTED_STATE });\n+            put(WINDOW_COVERING, new HomekitCharacteristicType[] { TARGET_POSITION, CURRENT_POSITION, POSITION_STATE });\n+            put(LIGHTBULB, new HomekitCharacteristicType[] { ON_STATE });\n+            put(FAN, new HomekitCharacteristicType[] { ACTIVE_STATUS });\n+            put(TEMPERATURE_SENSOR, new HomekitCharacteristicType[] { CURRENT_TEMPERATURE });\n+            put(THERMOSTAT, new HomekitCharacteristicType[] { CURRENT_HEATING_COOLING_STATE,\n+                    TARGET_HEATING_COOLING_STATE, CURRENT_TEMPERATURE, TARGET_TEMPERATURE });\n+            put(LOCK, new HomekitCharacteristicType[] { LOCK_CURRENT_STATE, LOCK_TARGET_STATE });\n+            put(VALVE, new HomekitCharacteristicType[] { ACTIVE_STATUS, INUSE_STATUS });\n+            put(SECURITY_SYSTEM,\n+                    new HomekitCharacteristicType[] { SECURITY_SYSTEM_CURRENT_STATE, SECURITY_SYSTEM_TARGET_STATE });\n+            // LEGACY\n+            put(BLINDS, new HomekitCharacteristicType[] { TARGET_POSITION, CURRENT_POSITION, POSITION_STATE });\n+            put(OLD_HUMIDITY_SENSOR, new HomekitCharacteristicType[] { RELATIVE_HUMIDITY });\n+            put(OLD_DIMMABLE_LIGHTBULB, new HomekitCharacteristicType[] { ON_STATE });\n+            put(OLD_COLORFUL_LIGHTBULB, new HomekitCharacteristicType[] { ON_STATE });\n+        }\n+    };\n+\n+    /** List of service implementation for each accessory type. **/\n+    private final static Map<HomekitAccessoryType, Class<? extends AbstractHomekitAccessoryImpl>> serviceImplMap = new HashMap<HomekitAccessoryType, Class<? extends AbstractHomekitAccessoryImpl>>() {\n+        {\n+            put(LEAK_SENSOR, HomekitLeakSensorImpl.class);\n+            put(MOTION_SENSOR, HomekitMotionSensorImpl.class);\n+            put(OCCUPANCY_SENSOR, HomekitOccupancySensorImpl.class);\n+            put(CONTACT_SENSOR, HomekitContactSensorImpl.class);\n+            put(TEMPERATURE_SENSOR, HomekitTemperatureSensorImpl.class);\n+            put(SMOKE_SENSOR, HomekitSmokeSensorImpl.class);\n+            put(HUMIDITY_SENSOR, HomekitHumiditySensorImpl.class);\n+            put(SWITCH, HomekitSwitchImpl.class);\n+            put(CARBON_DIOXIDE_SENSOR, HomekitCarbonDioxideSensorImpl.class);\n+            put(CARBON_MONOXIDE_SENSOR, HomekitCarbonMonoxideSensorImpl.class);\n+            put(WINDOW_COVERING, HomekitWindowCoveringImpl.class);\n+            put(LIGHTBULB, HomekitLightbulbImpl.class);\n+            put(FAN, HomekitFanImpl.class);\n+            put(TEMPERATURE_SENSOR, HomekitTemperatureSensorImpl.class);\n+            put(THERMOSTAT, HomekitThermostatImpl.class);\n+            put(LOCK, HomekitLockImpl.class);\n+            put(VALVE, HomekitValveImpl.class);\n+            put(SECURITY_SYSTEM, HomekitSecuritySystemImpl.class);\n+            put(BLINDS, HomekitWindowCoveringImpl.class);\n+            put(OLD_HUMIDITY_SENSOR, HomekitHumiditySensorImpl.class);\n+            put(OLD_DIMMABLE_LIGHTBULB, HomekitLightbulbImpl.class);\n+            put(OLD_COLORFUL_LIGHTBULB, HomekitLightbulbImpl.class);\n+\n+        }\n+    };\n+\n+    /** mapping of legacy attributes to new attributes. **/\n+    private final static Map<HomekitCharacteristicType, HomekitCharacteristicType> legacyCharacteristicsMapping = new HashMap<HomekitCharacteristicType, HomekitCharacteristicType>() {\n+        {\n+            put(OLD_CURRENT_HEATING_COOLING_STATE, CURRENT_HEATING_COOLING_STATE);\n+            put(OLD_TARGET_HEATING_COOLING_MODE, TARGET_HEATING_COOLING_STATE);\n+            put(OLD_TARGET_TEMPERATURE, TARGET_TEMPERATURE);\n+            put(OLD_BATTERY_LOW_STATUS, BATTERY_LOW_STATUS);\n+            put(VERY_OLD_TARGET_HEATING_COOLING_MODE, CURRENT_HEATING_COOLING_STATE);\n+        }\n+    };\n+\n+    /** list of optional implicit optional characteristics. mainly used for legacy accessory type */\n+    private final static Map<HomekitAccessoryType, HomekitCharacteristicType[]> implicitOptionalCharacteristics = new HashMap<HomekitAccessoryType, HomekitCharacteristicType[]>() {\n+        {\n+            put(OLD_DIMMABLE_LIGHTBULB, new HomekitCharacteristicType[] { BRIGHTNESS });\n+            put(OLD_COLORFUL_LIGHTBULB, new HomekitCharacteristicType[] { HUE, SATURATION, BRIGHTNESS });\n+\n+        }\n+    };\n+\n+    /**\n+     * creates HomeKit accessory for a openhab item.\n+     * \n+     * @param taggedItem openhab item tagged as HomeKit item\n+     * @param metadataRegistry openhab metadata registry required to get item meta information\n+     * @param updater OH HomeKit update class that ensure the status sync between OH item and corresponding HomeKit\n+     *            characteristic.\n+     * @param settings OH settings\n+     * @return HomeKit accessory\n+     * @throws HomekitException exception in case HomeKit accessory could not be created, e.g. due missing mandatory\n+     *             characteristic\n+     */\n+    public static HomekitAccessory create(HomekitTaggedItem taggedItem, MetadataRegistry metadataRegistry,\n+            HomekitAccessoryUpdater updater, HomekitSettings settings) throws HomekitException {\n+\n+        logger.trace(\"Constructing {} of accessoryType {}\", taggedItem.getName(), taggedItem.getAccessoryType());\n+        final List<HomekitTaggedItem> requiredCharacteristics = getMandatoryCharacteristics(taggedItem,\n+                metadataRegistry);\n+        if ((mandatoryCharacteristics.get(taggedItem.getAccessoryType()) != null) && (requiredCharacteristics\n+                .size() < mandatoryCharacteristics.get(taggedItem.getAccessoryType()).length)) {\n+            logger.warn(\"Accessory of type {} must have following characteristics {}. Found only {}\",\n+                    taggedItem.getAccessoryType(), mandatoryCharacteristics.get(taggedItem.getAccessoryType()),\n+                    requiredCharacteristics);\n+            throw new HomekitException(\"Missing mandatory characteristics\");\n         }\n+        AbstractHomekitAccessoryImpl accessoryImpl = null;\n \n-        throw new HomekitException(\"Unknown HomeKit type: \" + taggedItem.getAccessoryType());\n+        try {\n+            final Class<? extends AbstractHomekitAccessoryImpl> accessoryImplClass = serviceImplMap\n+                    .get(taggedItem.getAccessoryType());\n+            if (accessoryImplClass != null) {\n+                accessoryImpl = accessoryImplClass\n+                        .getConstructor(HomekitTaggedItem.class, List.class, HomekitAccessoryUpdater.class,\n+                                HomekitSettings.class)\n+                        .newInstance(taggedItem, requiredCharacteristics, updater, settings);\n+                addOptionalCharacteristics(accessoryImpl, metadataRegistry);\n+                return accessoryImpl;\n+            } else {\n+                logger.warn(\"Unsupported HomeKit type: {}\", taggedItem.getAccessoryType());\n+                throw new HomekitException(\"Unsupported HomeKit type: \" + taggedItem.getAccessoryType());\n+            }\n+        } catch (NoSuchMethodException | IllegalAccessException | InstantiationException\n+                | InvocationTargetException e) {\n+            logger.warn(\"Cannot instantiate accessory implementation for accessory {}\", taggedItem.getAccessoryType(),\n+                    e);\n+            throw new HomekitException(\n+                    \"Cannot instantiate accessory implementation for accessory \" + taggedItem.getAccessoryType());\n+        }\n+    }\n+\n+    /**\n+     * return HomeKit accessory types for a OH item based on meta data\n+     * \n+     * @param item OH item\n+     * @param metadataRegistry meta data registry\n+     * @return list of HomeKit accessory types and characteristics.\n+     */\n+    public static List<Entry<HomekitAccessoryType, HomekitCharacteristicType>> getAccessoryTypes(Item item,\n+            MetadataRegistry metadataRegistry) {\n+        final List<Entry<HomekitAccessoryType, HomekitCharacteristicType>> accessories = new ArrayList<>();\n+        Metadata metadata = metadataRegistry.get(new MetadataKey(METADATA_KEY, item.getUID()));\n+        boolean legacyMode = !(metadata != null);\n+        String[] tags = !legacyMode ? metadata.getValue().split(\",\") : item.getTags().toArray(new String[0]); // fallback\n+                                                                                                              // to tags\n+\n+        logger.trace(\"item {} meta data {}  tags {} \", item.getName(), metadata, tags);\n+        for (String tag : tags) {\n+            final String[] meta = tag.split(\"\\\\.\");\n+            Optional<HomekitAccessoryType> accessoryType = HomekitAccessoryType.valueOfTag(meta[0].trim());\n+            if (accessoryType.isPresent()) { // it accessory, check for characteristic\n+                HomekitAccessoryType type = accessoryType.get();\n+                if ((legacyMode) && (type.equals(LIGHTBULB))) { // support old smart logic to convert Lighting to\n+                                                                // DimmableLighting or ColorfulLighting depending on\n+                                                                // item type\n+                    if (item instanceof ColorItem) {\n+                        type = OLD_COLORFUL_LIGHTBULB;\n+                    } else if (item instanceof DimmerItem) {\n+                        type = OLD_DIMMABLE_LIGHTBULB;\n+                    }\n+                }\n+                if ((meta.length > 1) && (HomekitCharacteristicType.valueOfTag(meta[1].trim()).isPresent())) { // it has\n+                                                                                                               // characteristic\n+                                                                                                               // as\n+                                                                                                               // well\n+                    accessories\n+                            .add(new SimpleEntry<>(type, HomekitCharacteristicType.valueOfTag(meta[1].trim()).get()));\n+                } else {// it has no characteristic\n+                    accessories.add(new SimpleEntry<>(type, EMPTY));\n+                }\n+            } else { // it is no accessory, so, maybe it is a characteristic\n+                HomekitCharacteristicType.valueOfTag(meta[0].trim())\n+                        .ifPresent(c -> accessories.add(new SimpleEntry<>(DUMMY, c)));\n+            }\n+        }\n+        return accessories;\n+    }\n+\n+    public static @Nullable Map<String, Object> getItemConfiguration(Item item, MetadataRegistry metadataRegistry) {\n+        Metadata metadata = metadataRegistry.get(new MetadataKey(METADATA_KEY, item.getUID()));\n+        return metadata != null ? metadata.getConfiguration() : null;\n+    }\n+\n+    /**\n+     * return list of HomeKit relevant groups linked to an accessory\n+     * \n+     * @param item OH item\n+     * @param itemRegistry item registry\n+     * @param metadataRegistry metadata registry\n+     * @return list of relevant group items\n+     */\n+    public static List<GroupItem> getAccessoryGroups(Item item, ItemRegistry itemRegistry,\n+            MetadataRegistry metadataRegistry) {\n+        return item.getGroupNames().stream().flatMap(name -> {\n+            Item groupItem = itemRegistry.get(name);\n+            if (groupItem instanceof GroupItem) {\n+                return Stream.of((GroupItem) groupItem);\n+            } else {\n+                return Stream.empty();\n+            }\n+        }).filter(groupItem -> !getAccessoryTypes(groupItem, metadataRegistry).isEmpty()).collect(Collectors.toList());\n     }\n \n     /**\n-     * Given an accessory group, return the item in the group tagged as an accessory.\n-     *\n-     * @param taggedItem The group item containing our item, or, the accessory item.\n-     * @param accessoryType The accessory type for which we're looking\n-     * @return\n+     * collect all mandatory characteristics for a given tagged item, e.g. collect all mandatory HomeKit items from a\n+     * GroupItem\n+     * \n+     * @param taggedItem HomeKit tagged item\n+     * @param metadataRegistry meta data registry\n+     * @return list of mandatory\n      */\n-    private static Optional<HomekitTaggedItem> getPrimaryAccessory(HomekitTaggedItem taggedItem,\n-            HomekitAccessoryType accessoryType, ItemRegistry itemRegistry) {\n-        LOGGER.debug(\"{}: isGroup? {}, isMember? {}\", taggedItem.getName(), taggedItem.isGroup(),\n-                taggedItem.isMemberOfAccessoryGroup());\n+    private static List<HomekitTaggedItem> getMandatoryCharacteristics(HomekitTaggedItem taggedItem,\n+            MetadataRegistry metadataRegistry) {\n+        logger.trace(\"get mandatory characteristics for item {}: isGroup? {}, isMember? {}\", taggedItem.getName(),\n+                taggedItem.isGroup(), taggedItem.isMemberOfAccessoryGroup());\n+        List<HomekitTaggedItem> collectedCharacteristics = new ArrayList<>();\n         if (taggedItem.isGroup()) {\n-            GroupItem groupItem = (GroupItem) taggedItem.getItem();\n-            return groupItem.getMembers().stream().filter(item -> item.hasTag(accessoryType.getTag())).findFirst()\n-                    .map(item -> new HomekitTaggedItem(item, itemRegistry));\n-        } else if (taggedItem.getAccessoryType() == accessoryType) {\n-            return Optional.of(taggedItem);\n+            for (Item item : ((GroupItem) taggedItem.getItem()).getAllMembers()) {\n+                addMandatoryCharacteristics(taggedItem, collectedCharacteristics, item, metadataRegistry);\n+            }\n         } else {\n-            return Optional.empty();\n+            addMandatoryCharacteristics(taggedItem, collectedCharacteristics, taggedItem.getItem(), metadataRegistry);\n+        }\n+        return collectedCharacteristics;\n+    }\n+\n+    /**\n+     * add mandatory HomeKit items for a given main item to a list of characteristics\n+     * \n+     * @param mainItem main item\n+     * @param characteristics list of characteristics\n+     * @param item current item\n+     * @param metadataRegistry meta date registry\n+     */\n+    private static void addMandatoryCharacteristics(HomekitTaggedItem mainItem, List<HomekitTaggedItem> characteristics,\n+            Item item, MetadataRegistry metadataRegistry) {\n+        HomekitCharacteristicType[] requiredChar = mandatoryCharacteristics.get(mainItem.getAccessoryType());\n+        for (Entry<HomekitAccessoryType, HomekitCharacteristicType> accessory : getAccessoryTypes(item,\n+                metadataRegistry)) {\n+            if (isRootAccessory(accessory) && (requiredChar != null)) {\n+                Arrays.stream(requiredChar)\n+                        .forEach(c -> characteristics.add(new HomekitTaggedItem(item, accessory.getKey(), c,\n+                                mainItem.isGroup() ? (GroupItem) mainItem.getItem() : null,\n+                                HomekitAccessoryFactory.getItemConfiguration(item, metadataRegistry))));\n+            } else {\n+                if (isMandatoryCharacteristic(mainItem.getAccessoryType(), legacyCheck(accessory.getValue())))\n+                    characteristics\n+                            .add(new HomekitTaggedItem(item, accessory.getKey(), legacyCheck(accessory.getValue()),\n+                                    mainItem.isGroup() ? (GroupItem) mainItem.getItem() : null,\n+                                    HomekitAccessoryFactory.getItemConfiguration(item, metadataRegistry)));\n+            }\n         }\n     }\n \n-    private static Map<HomekitCharacteristicType, Item> getCharacteristicItems(HomekitTaggedItem taggedItem) {\n+    /**\n+     * add optional characteristic for given accessory.\n+     * \n+     * @param accessory accessory\n+     * @param metadataRegistry metadata registry\n+     */\n+    private static void addOptionalCharacteristics(AbstractHomekitAccessoryImpl accessory,\n+            MetadataRegistry metadataRegistry) {\n+        Map<HomekitCharacteristicType, GenericItem> characteristics = getOptionalCharacteristics(\n+                accessory.getRootAccessory(), metadataRegistry);\n+        Service service = accessory.getPrimaryService();\n+\n+        characteristics.forEach((type, item) -> {\n+            try {\n+                logger.trace(\"adding optional characteristic: {} for item {}\", type, item.getName());\n+\n+                final Characteristic characteristic = HomekitCharacteristicFactory.createCharacteristic(type, item,\n+                        accessory.getUpdater());\n+\n+                service.getClass().getMethod(\"addOptionalCharacteristic\", characteristic.getClass()). // find the\n+                                                                                                      // corresponding\n+                                                                                                      // add method at\n+                                                                                                      // service and\n+                                                                                                      // call it.", "originalCommit": "d5f1e15b388561676aa8747515dd681411ca769d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA3Mjc4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r419072787", "bodyText": "to me it is a pretty elegant and future proof solution.\nalternative would a pretty big and ugly switch with 20 complex cases and growing. further, with reflection we will be able to add support for additional optional characteristics just by upgrading the underlaying lib without touching the addon code.\nimportant: this code is executed only at start of the binding and on changes in items configuration, so that it has no impact on runtime performance later.", "author": "yfre", "createdAt": "2020-05-03T09:05:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA0Njc4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA0ODE5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7495#discussion_r419048196", "bodyText": "I would prefer if you cached getSettings() in a local variable to prevent calling it excessively.", "author": "cpmeister", "createdAt": "2020-05-03T05:04:10Z", "path": "bundles/org.openhab.io.homekit/src/main/java/org/openhab/io/homekit/internal/accessories/HomekitThermostatImpl.java", "diffHunk": "@@ -50,219 +46,207 @@\n  *\n  * @author Andy Lintner - Initial contribution\n  */\n-class HomekitThermostatImpl extends AbstractTemperatureHomekitAccessoryImpl<GroupItem> implements BasicThermostat {\n-    private final HomekitSettings settings;\n-\n-    private @NonNull NumberItem currentTemperatureItem;\n-    private @NonNull StringItem targetHeatingCoolingModeItem;\n-    private @Nullable StringItem currentHeatingCoolingModeItem;\n-    private @NonNull NumberItem targetTemperatureItem;\n-\n+class HomekitThermostatImpl extends AbstractHomekitAccessoryImpl implements ThermostatAccessory {\n     private Logger logger = LoggerFactory.getLogger(HomekitThermostatImpl.class);\n \n-    @SuppressWarnings(\"deprecation\")\n-    public HomekitThermostatImpl(HomekitTaggedItem taggedItem, ItemRegistry itemRegistry,\n-            HomekitAccessoryUpdater updater, HomekitSettings settings, Item currentTemperatureItem,\n-            Map<HomekitCharacteristicType, Item> origCharacteristicItems) throws IncompleteAccessoryException {\n-        super(taggedItem, itemRegistry, updater, settings, GroupItem.class);\n-\n-        HashMap<HomekitCharacteristicType, Item> characteristicItems = new HashMap<>(origCharacteristicItems);\n-        this.settings = settings;\n-\n-        if (currentTemperatureItem instanceof NumberItem) {\n-            this.currentTemperatureItem = (NumberItem) currentTemperatureItem;\n-        } else {\n-            throw new IncompleteAccessoryException(currentTemperatureItem.getUID()\n-                    + \"tagged as thermostat currentTemperatureItem has wrong item type (NumberItem needed)\");\n-        }\n+    public HomekitThermostatImpl(HomekitTaggedItem taggedItem, List<HomekitTaggedItem> mandatoryCharacteristics,\n+            HomekitAccessoryUpdater updater, HomekitSettings settings) throws IncompleteAccessoryException {\n+        super(taggedItem, mandatoryCharacteristics, updater, settings);\n+        this.getServices().add(new ThermostatService(this));\n+    }\n \n-        Item targetHeatingCoolingModeItem = getItemWithDeprecation(characteristicItems,\n-                HomekitCharacteristicType.TARGET_HEATING_COOLING_MODE,\n-                HomekitCharacteristicType.OLD_TARGET_HEATING_COOLING_MODE).orElseThrow(\n-                        () -> new IncompleteAccessoryException(HomekitCharacteristicType.TARGET_HEATING_COOLING_MODE));\n-        if (targetHeatingCoolingModeItem instanceof StringItem) {\n-            this.targetHeatingCoolingModeItem = (StringItem) targetHeatingCoolingModeItem;\n+    @Override\n+    public CompletableFuture<CurrentHeatingCoolingStateEnum> getCurrentState() {\n+        String stringValue = getSettings().thermostatCurrentModeOff;\n+        final Optional<HomekitTaggedItem> characteristic = getCharacteristic(\n+                HomekitCharacteristicType.CURRENT_HEATING_COOLING_STATE);\n+        if (characteristic.isPresent()) {\n+            stringValue = characteristic.get().getItem().getState().toString();\n         } else {\n-            throw new IncompleteAccessoryException(targetHeatingCoolingModeItem.getUID()\n-                    + \" tagged as thermostat targetHeatingCoolingMode has wrong item type (String needed)\");\n+            logger.warn(\"Missing mandatory characteristic {}\", HomekitCharacteristicType.CURRENT_HEATING_COOLING_STATE);\n         }\n \n-        Item targetTemperatureItem = getItemWithDeprecation(characteristicItems,\n-                HomekitCharacteristicType.TARGET_TEMPERATURE, HomekitCharacteristicType.OLD_TARGET_TEMPERATURE)\n-                        .orElseThrow(\n-                                () -> new IncompleteAccessoryException(HomekitCharacteristicType.TARGET_TEMPERATURE));\n-        if (targetTemperatureItem instanceof NumberItem) {\n-            this.targetTemperatureItem = (NumberItem) targetTemperatureItem;\n-        } else {\n-            throw new IncompleteAccessoryException(targetTemperatureItem.getUID()\n-                    + \" tagged as thermostat targetTemperature has wrong item type (Number needed)\");\n-        }\n+        CurrentHeatingCoolingStateEnum mode;\n \n-        Item currentHeatingCoolingModeItem = characteristicItems\n-                .remove(HomekitCharacteristicType.CURRENT_HEATING_COOLING_STATE);\n-        if (currentHeatingCoolingModeItem instanceof StringItem || currentHeatingCoolingModeItem == null) {\n-            this.currentHeatingCoolingModeItem = (StringItem) currentHeatingCoolingModeItem;\n+        if (stringValue.equalsIgnoreCase(getSettings().thermostatCurrentModeCooling)) {\n+            mode = CurrentHeatingCoolingStateEnum.COOL;\n+        } else if (stringValue.equalsIgnoreCase(getSettings().thermostatCurrentModeHeating)) {\n+            mode = CurrentHeatingCoolingStateEnum.HEAT;\n+        } else if (stringValue.equalsIgnoreCase(getSettings().thermostatCurrentModeOff)) {\n+            mode = CurrentHeatingCoolingStateEnum.OFF;\n+        } else if (stringValue.equals(\"UNDEF\") || stringValue.equals(\"NULL\")) {\n+            logger.warn(\"Heating cooling target mode not available. Relaying value of OFF to Homekit\");\n+            mode = CurrentHeatingCoolingStateEnum.OFF;\n         } else {\n-            throw new IncompleteAccessoryException(currentHeatingCoolingModeItem.getUID()\n-                    + \" tagged as thermostat currentHeatingCoolingMode has wrong item type (String needed)\");\n+            logger.warn(\"Unrecognized heatingCoolingCurrentMode: {}. Expected {}, {}, or {} strings in value.\",\n+                    stringValue, getSettings().thermostatCurrentModeCooling, getSettings().thermostatCurrentModeHeating,\n+                    getSettings().thermostatCurrentModeOff);\n+            mode = CurrentHeatingCoolingStateEnum.OFF;\n         }\n-\n-        characteristicItems.entrySet().stream().forEach(entry -> {\n-            logger.warn(\"Item {} has unrecognized thermostat characteristic: {}\", entry.getValue().getUID(),\n-                    entry.getKey().getTag());\n-        });\n+        return CompletableFuture.completedFuture(mode);\n     }\n \n-    private Optional<Item> getItemWithDeprecation(HashMap<HomekitCharacteristicType, Item> characteristicItems,\n-            HomekitCharacteristicType currentTag, HomekitCharacteristicType deprecatedTag) {\n-        Optional<Item> targetTempItem = Optional.ofNullable(characteristicItems.remove(currentTag));\n-        if (!targetTempItem.isPresent()) {\n-            targetTempItem = Optional.ofNullable(characteristicItems.remove(deprecatedTag));\n-            targetTempItem.ifPresent(item -> {\n-                logger.warn(\"The tag {} has been renamed to {}; please update your things, accordingly\",\n-                        deprecatedTag.getTag(), currentTag.getTag());\n-            });\n-        }\n-        return targetTempItem;\n+    @Override\n+    public CompletableFuture<Double> getCurrentTemperature() {\n+        DecimalType state = getStateAs(HomekitCharacteristicType.CURRENT_TEMPERATURE, DecimalType.class);\n+        return CompletableFuture.completedFuture(state != null ? convertToCelsius(state.doubleValue()) : 0.0);\n     }\n \n     @Override\n-    public CompletableFuture<ThermostatMode> getCurrentMode() {\n-        String stringValue = settings.thermostatCurrentModeOff;\n-        if (currentHeatingCoolingModeItem != null) {\n-            stringValue = currentHeatingCoolingModeItem.getState().toString();\n+    public CompletableFuture<TargetHeatingCoolingStateEnum> getTargetState() {\n+        String stringValue = getSettings().thermostatTargetModeOff;\n+\n+        final Optional<HomekitTaggedItem> characteristic = getCharacteristic(\n+                HomekitCharacteristicType.TARGET_HEATING_COOLING_STATE);\n+        if (characteristic.isPresent()) {\n+            stringValue = characteristic.get().getItem().getState().toString();\n+        } else {\n+            logger.warn(\"Missing mandatory characteristic {}\", HomekitCharacteristicType.TARGET_HEATING_COOLING_STATE);\n         }\n-        ThermostatMode mode;\n-\n-        if (stringValue.equalsIgnoreCase(settings.thermostatCurrentModeCooling)) {\n-            mode = ThermostatMode.COOL;\n-        } else if (stringValue.equalsIgnoreCase(settings.thermostatCurrentModeHeating)) {\n-            mode = ThermostatMode.HEAT;\n-        } else if (stringValue.equalsIgnoreCase(settings.thermostatCurrentModeOff)) {\n-            mode = ThermostatMode.OFF;\n+        TargetHeatingCoolingStateEnum mode;\n+\n+        if (stringValue.equalsIgnoreCase(getSettings().thermostatTargetModeCool)) {", "originalCommit": "d5f1e15b388561676aa8747515dd681411ca769d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "946b8964029ddff080057bc36364b5fdcf0558ac", "url": "https://github.com/openhab/openhab-addons/commit/946b8964029ddff080057bc36364b5fdcf0558ac", "message": "Incorporated changes from review\n\nSigned-off-by: Eugen Freiter <freiter@gmx.de>", "committedDate": "2020-05-03T09:26:49Z", "type": "commit"}, {"oid": "31e9593fa2dec881d1218053ce5e3b0b4556145f", "url": "https://github.com/openhab/openhab-addons/commit/31e9593fa2dec881d1218053ce5e3b0b4556145f", "message": "fix some potential NPE\n\nSigned-off-by: Eugen Freiter <freiter@gmx.de>", "committedDate": "2020-05-03T12:58:14Z", "type": "commit"}]}