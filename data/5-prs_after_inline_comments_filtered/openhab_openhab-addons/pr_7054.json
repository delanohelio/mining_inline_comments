{"pr_number": 7054, "pr_title": "[venstarthermostat] Initial contribution: Venstar thermostats with Local API support", "pr_createdAt": "2020-02-22T19:54:34Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/7054", "timeline": [{"oid": "4ab364716a1d9855cdb6f3e8fa065a9c5e7ca075", "url": "https://github.com/openhab/openhab-addons/commit/4ab364716a1d9855cdb6f3e8fa065a9c5e7ca075", "message": "This bundle provides support for Venstar thermostats with Local API support (such as ColorTouch, Voyager and Explorer). This binding includes device autodiscovery and full read/write support using the Venstar local API.\n\nIncludes feedback and contributions (as noted in the source) from @digitaldan.\n\nThis contribution is ready for review.\n\nSigned-off-by: William Welliver <william@welliver.org>\nSigned-off-by: H William Welliver <william@welliver.org>", "committedDate": "2020-02-22T19:55:17Z", "type": "forcePushed"}, {"oid": "0b95c3cd59ae3ee64a5beb5d69545a72806d83e8", "url": "https://github.com/openhab/openhab-addons/commit/0b95c3cd59ae3ee64a5beb5d69545a72806d83e8", "message": "copyright notice\n\nSigned-off-by: H William Welliver <william@welliver.org>", "committedDate": "2020-02-22T20:12:38Z", "type": "forcePushed"}, {"oid": "e6a3c50ab3e1f2327b5faeba90f75b9070ecd51d", "url": "https://github.com/openhab/openhab-addons/commit/e6a3c50ab3e1f2327b5faeba90f75b9070ecd51d", "message": "Correct nullable annotations\n\nSigned-off-by: H William Welliver <william@welliver.org>", "committedDate": "2020-02-29T16:26:33Z", "type": "forcePushed"}, {"oid": "cd0edce648fe08318f732f960af3c86ce690538d", "url": "https://github.com/openhab/openhab-addons/commit/cd0edce648fe08318f732f960af3c86ce690538d", "message": "Initial contribution: Venstar thermostats with Local API support\n\nThis bundle provides support for Venstar thermostats with Local API support (such as ColorTouch, Voyager and Explorer). This binding includes device autodiscovery and full read/write support using the Venstar local API.\n\nIncludes feedback and contributions (as noted in the source) from @digitaldan.\n\nThis contribution is ready for review.\n\nSigned-off-by: William Welliver <william@welliver.org>\nSigned-off-by: H William Welliver <william@welliver.org>", "committedDate": "2020-06-23T01:09:58Z", "type": "commit"}, {"oid": "cd0edce648fe08318f732f960af3c86ce690538d", "url": "https://github.com/openhab/openhab-addons/commit/cd0edce648fe08318f732f960af3c86ce690538d", "message": "Initial contribution: Venstar thermostats with Local API support\n\nThis bundle provides support for Venstar thermostats with Local API support (such as ColorTouch, Voyager and Explorer). This binding includes device autodiscovery and full read/write support using the Venstar local API.\n\nIncludes feedback and contributions (as noted in the source) from @digitaldan.\n\nThis contribution is ready for review.\n\nSigned-off-by: William Welliver <william@welliver.org>\nSigned-off-by: H William Welliver <william@welliver.org>", "committedDate": "2020-06-23T01:09:58Z", "type": "forcePushed"}, {"oid": "9928aeb04b270c342d73a0d676265e2c138529d1", "url": "https://github.com/openhab/openhab-addons/commit/9928aeb04b270c342d73a0d676265e2c138529d1", "message": "Fix pom version\n\nSigned-off-by: William Welliver william@welliver.org\nSigned-off-by: H William Welliver <william@welliver.org>", "committedDate": "2020-06-23T01:18:32Z", "type": "commit"}, {"oid": "9928aeb04b270c342d73a0d676265e2c138529d1", "url": "https://github.com/openhab/openhab-addons/commit/9928aeb04b270c342d73a0d676265e2c138529d1", "message": "Fix pom version\n\nSigned-off-by: William Welliver william@welliver.org\nSigned-off-by: H William Welliver <william@welliver.org>", "committedDate": "2020-06-23T01:18:32Z", "type": "forcePushed"}, {"oid": "e203e85557a13e40df197e8489ecc4c43e594244", "url": "https://github.com/openhab/openhab-addons/commit/e203e85557a13e40df197e8489ecc4c43e594244", "message": "Correct travis build errors\n\nSigned-off-by: William Welliver <william@welliver.org>\nSigned-off-by: H William Welliver <william@welliver.org>", "committedDate": "2020-08-05T15:05:59Z", "type": "commit"}, {"oid": "e203e85557a13e40df197e8489ecc4c43e594244", "url": "https://github.com/openhab/openhab-addons/commit/e203e85557a13e40df197e8489ecc4c43e594244", "message": "Correct travis build errors\n\nSigned-off-by: William Welliver <william@welliver.org>\nSigned-off-by: H William Welliver <william@welliver.org>", "committedDate": "2020-08-05T15:05:59Z", "type": "forcePushed"}, {"oid": "91c910a2d029c1aae40b9730487b45ef59c86721", "url": "https://github.com/openhab/openhab-addons/commit/91c910a2d029c1aae40b9730487b45ef59c86721", "message": "Correct conflict\n\nSigned-off-by: William Welliver <william@welliver.org>\nSigned-off-by: H William Welliver <william@welliver.org>", "committedDate": "2020-08-05T15:14:40Z", "type": "commit"}, {"oid": "ef4ba68bd47139e407c69dbbe539ca2cdbf53ac3", "url": "https://github.com/openhab/openhab-addons/commit/ef4ba68bd47139e407c69dbbe539ca2cdbf53ac3", "message": "Merge branch '2.5.x' into hww3/venstar", "committedDate": "2020-08-05T15:17:55Z", "type": "commit"}, {"oid": "092b26cb990ca2997a309ca2aa995992b759ff9b", "url": "https://github.com/openhab/openhab-addons/commit/092b26cb990ca2997a309ca2aa995992b759ff9b", "message": "Correct version\n\nSigned-off-by: William Welliver <william@welliver.org>\nSigned-off-by: H William Welliver <william@welliver.org>", "committedDate": "2020-08-05T15:25:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQyNDQ4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7054#discussion_r487424489", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    result = DiscoveryResultBuilder.create(thingUid).withLabel(label).withRepresentationProperty(uuid)\n          \n          \n            \n                    result = DiscoveryResultBuilder.create(thingUid).withLabel(label).withRepresentationProperty(VenstarThermostatBindingConstants.PROPERTY_UUID)\n          \n      \n    \n    \n  \n\nI did notice this one recently as my 3.x system is complaining about it this property if its missing/wrong.", "author": "digitaldan", "createdAt": "2020-09-12T16:16:11Z", "path": "bundles/org.openhab.binding.venstarthermostat/src/main/java/org/openhab/binding/venstarthermostat/internal/discovery/VenstarThermostatDiscoveryService.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.venstarthermostat.internal.discovery;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.DatagramPacket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.Scanner;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.venstarthermostat.internal.VenstarThermostatBindingConstants;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VenstarThermostatDiscoveryService} is responsible for discovery of\n+ * Venstar thermostats on the local network\n+ *\n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ */\n+\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.venstarthermostat\")\n+public class    VenstarThermostatDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(VenstarThermostatDiscoveryService.class);\n+    private static final String COLOR_TOUCH_DISCOVERY_MESSAGE = \"M-SEARCH * HTTP/1.1\\r\\n\"\n+            + \"Host: 239.255.255.250:1900\\r\\n\" + \"Man: ssdp:discover\\r\\n\" + \"ST: colortouch:ecp\\r\\n\" + \"\\r\\n\";\n+    private static final Pattern USN_PATTERN = Pattern\n+            .compile(\"^(colortouch:)?ecp((?::[0-9a-fA-F]{2}){6}):name:(.+)(?::type:(\\\\w+))\");\n+    private static final String SSDP_MATCH = \"colortouch:ecp\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    private ScheduledFuture<?> scheduledFuture = null;\n+\n+    public VenstarThermostatDiscoveryService() {\n+        super(VenstarThermostatBindingConstants.SUPPORTED_THING_TYPES, 30, true);\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.debug(\"Starting Background Scan\");\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleAtFixedRate(this::doRunRun, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        if (scheduledFuture != null && !scheduledFuture.isCancelled()) {\n+            scheduledFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Starting Interactive Scan\");\n+        doRunRun();\n+    }\n+\n+    protected synchronized void doRunRun() {\n+        logger.trace(\"Sending SSDP discover.\");\n+        for (int i = 0; i < 5; i++) {\n+            try {\n+                Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+                while (nets.hasMoreElements()) {\n+                    NetworkInterface ni = nets.nextElement();\n+                    MulticastSocket socket = sendDiscoveryBroacast(ni);\n+                    if (socket != null) {\n+                        scanResposesForKeywords(socket);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Error discoverying devices\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided\n+     * services.\n+     *\n+     * @return The Socket the answers will arrive at.\n+     * @throws UnknownHostException\n+     * @throws IOException\n+     * @throws SocketException\n+     * @throws UnsupportedEncodingException\n+     */\n+    private MulticastSocket sendDiscoveryBroacast(NetworkInterface ni)\n+            throws UnknownHostException, SocketException, UnsupportedEncodingException {\n+        InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+        final int port = 1900;\n+\n+        logger.trace(\"Considering {}\", ni.getName());\n+        try {\n+            if (!ni.isUp() || !ni.supportsMulticast()) {\n+                logger.trace(\"skipping interface {}\", ni.getName());\n+                return null;\n+            }\n+\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.trace(\"no ipv4 address on {}\", ni.getName());\n+                return null;\n+            }\n+\n+            // for whatever reason, the venstar thermostat responses will not be seen\n+            // if we bind this socket to a particular address.\n+            // this seems to be okay on linux systems, but osx apparently prefers ipv6, so this\n+            // prevents responses from being received unless the ipv4 stack is given preference.\n+            MulticastSocket socket = new MulticastSocket(new InetSocketAddress(port));\n+            socket.setSoTimeout(2000);\n+            socket.setReuseAddress(true);\n+            socket.setNetworkInterface(ni);\n+            socket.joinGroup(m);\n+\n+            logger.trace(\"Joined UPnP Multicast group on Interface: {}\", ni.getName());\n+            byte[] requestMessage = COLOR_TOUCH_DISCOVERY_MESSAGE.getBytes(\"UTF-8\");\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+            socket.send(datagramPacket);\n+            return socket;\n+        } catch (IOException e) {\n+            logger.trace(\"got ioexception: {}\", e.getMessage());\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Scans all messages that arrive on the socket and scans them for the\n+     * search keywords. The search is not case sensitive.\n+     *\n+     * @param socket\n+     *            The socket where the answers arrive.\n+     * @param keywords\n+     *            The keywords to be searched for.\n+     * @return\n+     * @throws IOException\n+     */\n+    private void scanResposesForKeywords(MulticastSocket socket, String... keywords) throws IOException {\n+        // In the worst case a SocketTimeoutException raises\n+        do {\n+            byte[] rxbuf = new byte[8192];\n+            DatagramPacket packet = new DatagramPacket(rxbuf, rxbuf.length);\n+            try {\n+                socket.receive(packet);\n+            } catch (IOException e) {\n+                logger.trace(\"Got exception while trying to receive UPnP packets: {}\", e.getMessage());\n+                return;\n+            }\n+            String response = new String(packet.getData());\n+            if (response.contains(SSDP_MATCH)) {\n+                logger.trace(\"Match: {} \", response);\n+                parseResponse(response);\n+            }\n+        } while (true);\n+    }\n+\n+    protected void parseResponse(String response) {\n+        DiscoveryResult result;\n+\n+        String name = null;\n+        String url = null;\n+        String uuid = null;\n+\n+        Scanner scanner = new Scanner(response);\n+        while (scanner.hasNextLine()) {\n+            String line = scanner.nextLine();\n+            String[] pair = line.split(\":\", 2);\n+            if (pair.length != 2) {\n+                continue;\n+            }\n+            String key = pair[0].toLowerCase();\n+            String value = pair[1].trim();\n+            logger.trace(\"key: {} value: {}.\", key, value);\n+            switch (key) {\n+                case \"location\":\n+                    url = value;\n+                    break;\n+                case \"usn\":\n+                    Matcher m = USN_PATTERN.matcher(value);\n+                    if (m.find()) {\n+                        uuid = m.group(2);\n+                        name = m.group(3);\n+                    }\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+        scanner.close();\n+\n+        logger.trace(\"Found thermostat, name: {} uuid: {} url: {}\", name, uuid, url);\n+\n+        if (name == null || uuid == null || url == null) {\n+            logger.trace(\"Bad Format from thermostat\");\n+            return;\n+        }\n+\n+        uuid = uuid.replace(\":\", \"\").toLowerCase();\n+\n+        ThingUID thingUid = new ThingUID(VenstarThermostatBindingConstants.THING_TYPE_COLOR_TOUCH, uuid);\n+\n+        logger.trace(\"Got discovered device.\");\n+\n+        String label = String.format(\"Venstar Thermostat (%s)\", name);\n+        result = DiscoveryResultBuilder.create(thingUid).withLabel(label).withRepresentationProperty(uuid)", "originalCommit": "092b26cb990ca2997a309ca2aa995992b759ff9b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAxNDYxMA==", "url": "https://github.com/openhab/openhab-addons/pull/7054#discussion_r491014610", "bodyText": "nit - remove empty line", "author": "digitaldan", "createdAt": "2020-09-18T15:08:47Z", "path": "bundles/org.openhab.binding.venstarthermostat/src/main/java/org/openhab/binding/venstarthermostat/internal/handler/VenstarThermostatHandler.java", "diffHunk": "@@ -0,0 +1,497 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.venstarthermostat.internal.handler;\n+\n+import static org.eclipse.smarthome.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.binding.venstarthermostat.internal.VenstarThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.MalformedURLException;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.Quantity;\n+import javax.measure.Unit;\n+import javax.measure.quantity.Dimensionless;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.util.ssl.SslContextFactory;\n+import org.eclipse.smarthome.config.core.status.ConfigStatusMessage;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.ConfigStatusThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.venstarthermostat.internal.VenstarThermostatConfiguration;\n+import org.openhab.binding.venstarthermostat.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VenstarThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Migration to Jetty, annotations and various improvements\n+ */\n+@NonNullByDefault\n+public class VenstarThermostatHandler extends ConfigStatusThingHandler {\n+\n+    private static final int TIMEOUT_SECONDS = 30;\n+    private static final int UPDATE_AFTER_COMMAND_SECONDS = 2;\n+\n+    private Logger log = LoggerFactory.getLogger(VenstarThermostatHandler.class);\n+    private List<VenstarSensor> sensorData = new ArrayList<>();\n+    private VenstarInfoData infoData = new VenstarInfoData();\n+    private Map<String, State> stateMap = Collections.synchronizedMap(new HashMap<>());\n+    private @Nullable Future<?> updatesTask;\n+    private @Nullable URL baseURL;\n+    private int refresh;\n+    private final HttpClient httpClient;\n+    private final Gson gson;\n+\n+    // Venstar Thermostats are most commonly installed in the US, so start with a reasonable default.\n+    private Unit<Temperature> unitSystem = ImperialUnits.FAHRENHEIT;\n+\n+    public VenstarThermostatHandler(Thing thing) {\n+        super(thing);\n+        httpClient = new HttpClient(new SslContextFactory(true));\n+        gson = new GsonBuilder().registerTypeAdapter(VenstarSystemState.class, new VenstarSystemStateSerializer())\n+                .registerTypeAdapter(VenstarSystemMode.class, new VenstarSystemModeSerializer()).create();\n+\n+        log.trace(\"VenstarThermostatHandler for thing {}\", getThing().getUID());\n+    }\n+\n+    @SuppressWarnings(\"null\") // compiler does not see conf.refresh == null check\n+    @Override\n+    public Collection<ConfigStatusMessage> getConfigStatus() {\n+        Collection<ConfigStatusMessage> status = new ArrayList<>();\n+        VenstarThermostatConfiguration config = getConfigAs(VenstarThermostatConfiguration.class);\n+        if (StringUtils.isBlank(config.username)) {\n+            log.warn(\"username is empty\");\n+            status.add(ConfigStatusMessage.Builder.error(CONFIG_USERNAME).withMessageKeySuffix(EMPTY_INVALID)\n+                    .withArguments(CONFIG_USERNAME).build());\n+        }\n+\n+        if (StringUtils.isBlank(config.password)) {\n+            log.warn(\"password is empty\");\n+            status.add(ConfigStatusMessage.Builder.error(CONFIG_PASSWORD).withMessageKeySuffix(EMPTY_INVALID)\n+                    .withArguments(CONFIG_PASSWORD).build());\n+        }\n+\n+        if (config.refresh == null || config.refresh < 10) {\n+            log.warn(\"refresh is too small: {}\", config.refresh);\n+\n+            status.add(ConfigStatusMessage.Builder.error(CONFIG_REFRESH).withMessageKeySuffix(REFRESH_INVALID)\n+                    .withArguments(CONFIG_REFRESH).build());\n+        }\n+        return status;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            log.debug(\"Controller is NOT ONLINE and is not responding to commands\");\n+            return;\n+        }\n+\n+        stopUpdateTasks();\n+        if (command instanceof RefreshType) {\n+            log.debug(\"Refresh command requested for {}\", channelUID);\n+            stateMap.clear();\n+            startUpdatesTask(0);\n+        } else {\n+            stateMap.remove(channelUID.getAsString());\n+            if (channelUID.getId().equals(CHANNEL_HEATING_SETPOINT)) {\n+                QuantityType<Temperature> quantity = commandToQuantityType(command, unitSystem);\n+                int value = quantityToRoundedTemperature(quantity, unitSystem).intValue();\n+\n+                log.debug(\"Setting heating setpoint to {}\", value);\n+                setHeatingSetpoint(value);\n+            } else if (channelUID.getId().equals(CHANNEL_COOLING_SETPOINT)) {\n+                QuantityType<Temperature> quantity = commandToQuantityType(command, unitSystem);\n+                int value = quantityToRoundedTemperature(quantity, unitSystem).intValue();\n+\n+                log.debug(\"Setting cooling setpoint to {}\", value);\n+                setCoolingSetpoint(value);\n+            } else if (channelUID.getId().equals(CHANNEL_SYSTEM_MODE)) {\n+                VenstarSystemMode value;\n+                if (command instanceof StringType) {\n+                    value = VenstarSystemMode.valueOf(((StringType) command).toString().toUpperCase());\n+", "originalCommit": "092b26cb990ca2997a309ca2aa995992b759ff9b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAxNDczOA==", "url": "https://github.com/openhab/openhab-addons/pull/7054#discussion_r491014738", "bodyText": "nit - remove empty line", "author": "digitaldan", "createdAt": "2020-09-18T15:08:57Z", "path": "bundles/org.openhab.binding.venstarthermostat/src/main/java/org/openhab/binding/venstarthermostat/internal/handler/VenstarThermostatHandler.java", "diffHunk": "@@ -0,0 +1,497 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.venstarthermostat.internal.handler;\n+\n+import static org.eclipse.smarthome.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.binding.venstarthermostat.internal.VenstarThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.MalformedURLException;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.Quantity;\n+import javax.measure.Unit;\n+import javax.measure.quantity.Dimensionless;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.util.ssl.SslContextFactory;\n+import org.eclipse.smarthome.config.core.status.ConfigStatusMessage;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.ConfigStatusThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.venstarthermostat.internal.VenstarThermostatConfiguration;\n+import org.openhab.binding.venstarthermostat.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VenstarThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Migration to Jetty, annotations and various improvements\n+ */\n+@NonNullByDefault\n+public class VenstarThermostatHandler extends ConfigStatusThingHandler {\n+\n+    private static final int TIMEOUT_SECONDS = 30;\n+    private static final int UPDATE_AFTER_COMMAND_SECONDS = 2;\n+\n+    private Logger log = LoggerFactory.getLogger(VenstarThermostatHandler.class);\n+    private List<VenstarSensor> sensorData = new ArrayList<>();\n+    private VenstarInfoData infoData = new VenstarInfoData();\n+    private Map<String, State> stateMap = Collections.synchronizedMap(new HashMap<>());\n+    private @Nullable Future<?> updatesTask;\n+    private @Nullable URL baseURL;\n+    private int refresh;\n+    private final HttpClient httpClient;\n+    private final Gson gson;\n+\n+    // Venstar Thermostats are most commonly installed in the US, so start with a reasonable default.\n+    private Unit<Temperature> unitSystem = ImperialUnits.FAHRENHEIT;\n+\n+    public VenstarThermostatHandler(Thing thing) {\n+        super(thing);\n+        httpClient = new HttpClient(new SslContextFactory(true));\n+        gson = new GsonBuilder().registerTypeAdapter(VenstarSystemState.class, new VenstarSystemStateSerializer())\n+                .registerTypeAdapter(VenstarSystemMode.class, new VenstarSystemModeSerializer()).create();\n+\n+        log.trace(\"VenstarThermostatHandler for thing {}\", getThing().getUID());\n+    }\n+\n+    @SuppressWarnings(\"null\") // compiler does not see conf.refresh == null check\n+    @Override\n+    public Collection<ConfigStatusMessage> getConfigStatus() {\n+        Collection<ConfigStatusMessage> status = new ArrayList<>();\n+        VenstarThermostatConfiguration config = getConfigAs(VenstarThermostatConfiguration.class);\n+        if (StringUtils.isBlank(config.username)) {\n+            log.warn(\"username is empty\");\n+            status.add(ConfigStatusMessage.Builder.error(CONFIG_USERNAME).withMessageKeySuffix(EMPTY_INVALID)\n+                    .withArguments(CONFIG_USERNAME).build());\n+        }\n+\n+        if (StringUtils.isBlank(config.password)) {\n+            log.warn(\"password is empty\");\n+            status.add(ConfigStatusMessage.Builder.error(CONFIG_PASSWORD).withMessageKeySuffix(EMPTY_INVALID)\n+                    .withArguments(CONFIG_PASSWORD).build());\n+        }\n+\n+        if (config.refresh == null || config.refresh < 10) {\n+            log.warn(\"refresh is too small: {}\", config.refresh);\n+\n+            status.add(ConfigStatusMessage.Builder.error(CONFIG_REFRESH).withMessageKeySuffix(REFRESH_INVALID)\n+                    .withArguments(CONFIG_REFRESH).build());\n+        }\n+        return status;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            log.debug(\"Controller is NOT ONLINE and is not responding to commands\");\n+            return;\n+        }\n+\n+        stopUpdateTasks();\n+        if (command instanceof RefreshType) {\n+            log.debug(\"Refresh command requested for {}\", channelUID);\n+            stateMap.clear();\n+            startUpdatesTask(0);\n+        } else {\n+            stateMap.remove(channelUID.getAsString());\n+            if (channelUID.getId().equals(CHANNEL_HEATING_SETPOINT)) {\n+                QuantityType<Temperature> quantity = commandToQuantityType(command, unitSystem);\n+                int value = quantityToRoundedTemperature(quantity, unitSystem).intValue();\n+\n+                log.debug(\"Setting heating setpoint to {}\", value);\n+                setHeatingSetpoint(value);\n+            } else if (channelUID.getId().equals(CHANNEL_COOLING_SETPOINT)) {\n+                QuantityType<Temperature> quantity = commandToQuantityType(command, unitSystem);\n+                int value = quantityToRoundedTemperature(quantity, unitSystem).intValue();\n+\n+                log.debug(\"Setting cooling setpoint to {}\", value);\n+                setCoolingSetpoint(value);\n+            } else if (channelUID.getId().equals(CHANNEL_SYSTEM_MODE)) {\n+                VenstarSystemMode value;\n+                if (command instanceof StringType) {\n+                    value = VenstarSystemMode.valueOf(((StringType) command).toString().toUpperCase());\n+\n+                } else {\n+                    value = VenstarSystemMode.fromInt(((DecimalType) command).intValue());\n+                }\n+                log.debug(\"Setting system mode to  {}\", value);\n+                setSystemMode(value);\n+                updateIfChanged(CHANNEL_SYSTEM_MODE_RAW, new StringType(\"\" + value));\n+", "originalCommit": "092b26cb990ca2997a309ca2aa995992b759ff9b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAxNDkyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7054#discussion_r491014921", "bodyText": "nit - remove empty line", "author": "digitaldan", "createdAt": "2020-09-18T15:09:14Z", "path": "bundles/org.openhab.binding.venstarthermostat/src/main/java/org/openhab/binding/venstarthermostat/internal/handler/VenstarThermostatHandler.java", "diffHunk": "@@ -0,0 +1,497 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.venstarthermostat.internal.handler;\n+\n+import static org.eclipse.smarthome.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.binding.venstarthermostat.internal.VenstarThermostatBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.net.MalformedURLException;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.measure.Quantity;\n+import javax.measure.Unit;\n+import javax.measure.quantity.Dimensionless;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.util.ssl.SslContextFactory;\n+import org.eclipse.smarthome.config.core.status.ConfigStatusMessage;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.ConfigStatusThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.venstarthermostat.internal.VenstarThermostatConfiguration;\n+import org.openhab.binding.venstarthermostat.internal.model.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link VenstarThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Migration to Jetty, annotations and various improvements\n+ */\n+@NonNullByDefault\n+public class VenstarThermostatHandler extends ConfigStatusThingHandler {\n+\n+    private static final int TIMEOUT_SECONDS = 30;\n+    private static final int UPDATE_AFTER_COMMAND_SECONDS = 2;\n+\n+    private Logger log = LoggerFactory.getLogger(VenstarThermostatHandler.class);\n+    private List<VenstarSensor> sensorData = new ArrayList<>();\n+    private VenstarInfoData infoData = new VenstarInfoData();\n+    private Map<String, State> stateMap = Collections.synchronizedMap(new HashMap<>());\n+    private @Nullable Future<?> updatesTask;\n+    private @Nullable URL baseURL;\n+    private int refresh;\n+    private final HttpClient httpClient;\n+    private final Gson gson;\n+\n+    // Venstar Thermostats are most commonly installed in the US, so start with a reasonable default.\n+    private Unit<Temperature> unitSystem = ImperialUnits.FAHRENHEIT;\n+\n+    public VenstarThermostatHandler(Thing thing) {\n+        super(thing);\n+        httpClient = new HttpClient(new SslContextFactory(true));\n+        gson = new GsonBuilder().registerTypeAdapter(VenstarSystemState.class, new VenstarSystemStateSerializer())\n+                .registerTypeAdapter(VenstarSystemMode.class, new VenstarSystemModeSerializer()).create();\n+\n+        log.trace(\"VenstarThermostatHandler for thing {}\", getThing().getUID());\n+    }\n+\n+    @SuppressWarnings(\"null\") // compiler does not see conf.refresh == null check\n+    @Override\n+    public Collection<ConfigStatusMessage> getConfigStatus() {\n+        Collection<ConfigStatusMessage> status = new ArrayList<>();\n+        VenstarThermostatConfiguration config = getConfigAs(VenstarThermostatConfiguration.class);\n+        if (StringUtils.isBlank(config.username)) {\n+            log.warn(\"username is empty\");\n+            status.add(ConfigStatusMessage.Builder.error(CONFIG_USERNAME).withMessageKeySuffix(EMPTY_INVALID)\n+                    .withArguments(CONFIG_USERNAME).build());\n+        }\n+\n+        if (StringUtils.isBlank(config.password)) {\n+            log.warn(\"password is empty\");\n+            status.add(ConfigStatusMessage.Builder.error(CONFIG_PASSWORD).withMessageKeySuffix(EMPTY_INVALID)\n+                    .withArguments(CONFIG_PASSWORD).build());\n+        }\n+\n+        if (config.refresh == null || config.refresh < 10) {\n+            log.warn(\"refresh is too small: {}\", config.refresh);\n+\n+            status.add(ConfigStatusMessage.Builder.error(CONFIG_REFRESH).withMessageKeySuffix(REFRESH_INVALID)\n+                    .withArguments(CONFIG_REFRESH).build());\n+        }\n+        return status;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            log.debug(\"Controller is NOT ONLINE and is not responding to commands\");\n+            return;\n+        }\n+\n+        stopUpdateTasks();\n+        if (command instanceof RefreshType) {\n+            log.debug(\"Refresh command requested for {}\", channelUID);\n+            stateMap.clear();\n+            startUpdatesTask(0);\n+        } else {\n+            stateMap.remove(channelUID.getAsString());\n+            if (channelUID.getId().equals(CHANNEL_HEATING_SETPOINT)) {\n+                QuantityType<Temperature> quantity = commandToQuantityType(command, unitSystem);\n+                int value = quantityToRoundedTemperature(quantity, unitSystem).intValue();\n+\n+                log.debug(\"Setting heating setpoint to {}\", value);\n+                setHeatingSetpoint(value);\n+            } else if (channelUID.getId().equals(CHANNEL_COOLING_SETPOINT)) {\n+                QuantityType<Temperature> quantity = commandToQuantityType(command, unitSystem);\n+                int value = quantityToRoundedTemperature(quantity, unitSystem).intValue();\n+\n+                log.debug(\"Setting cooling setpoint to {}\", value);\n+                setCoolingSetpoint(value);\n+            } else if (channelUID.getId().equals(CHANNEL_SYSTEM_MODE)) {\n+                VenstarSystemMode value;\n+                if (command instanceof StringType) {\n+                    value = VenstarSystemMode.valueOf(((StringType) command).toString().toUpperCase());\n+\n+                } else {\n+                    value = VenstarSystemMode.fromInt(((DecimalType) command).intValue());\n+                }\n+                log.debug(\"Setting system mode to  {}\", value);\n+                setSystemMode(value);\n+                updateIfChanged(CHANNEL_SYSTEM_MODE_RAW, new StringType(\"\" + value));\n+\n+            }\n+            startUpdatesTask(UPDATE_AFTER_COMMAND_SECONDS);\n+        }\n+", "originalCommit": "092b26cb990ca2997a309ca2aa995992b759ff9b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bee2d0846768c82719046505cdc599512e154e4d", "url": "https://github.com/openhab/openhab-addons/commit/bee2d0846768c82719046505cdc599512e154e4d", "message": "Update bundles/org.openhab.binding.venstarthermostat/README.md\n\nCo-authored-by: Hilbrand Bouwkamp <hilbrand@h72.nl>", "committedDate": "2020-09-19T21:21:16Z", "type": "commit"}, {"oid": "fcaff082d090a0188b4dffd506b572542dccdd00", "url": "https://github.com/openhab/openhab-addons/commit/fcaff082d090a0188b4dffd506b572542dccdd00", "message": "Update bundles/org.openhab.binding.venstarthermostat/pom.xml\n\nCo-authored-by: Hilbrand Bouwkamp <hilbrand@h72.nl>", "committedDate": "2020-09-19T21:21:32Z", "type": "commit"}]}