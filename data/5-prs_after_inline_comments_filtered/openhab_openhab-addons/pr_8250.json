{"pr_number": 8250, "pr_title": "[helioseasycontrols] Modbus: HeliosEasyControls - Initial Contribution", "pr_createdAt": "2020-08-03T18:35:06Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/8250", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg3NzA1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r464877051", "bodyText": "Not sure if it matters but let eclipse generate a proper random number", "author": "ssalonen", "createdAt": "2020-08-04T08:11:30Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosException.java", "diffHunk": "@@ -0,0 +1,10 @@\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\n+\n+public class HeliosException extends Exception {\n+\n+    private static final long serialVersionUID = 1L;", "originalCommit": "73d8f576a176edc1b7c8f90549169819e7d5e410", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg4MTY1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r464881651", "bodyText": "You can also use logger.error with this type of critical error", "author": "ssalonen", "createdAt": "2020-08-04T08:20:02Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,577 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    /**\r\n+     * Logger instance\r\n+     */\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    /**\r\n+     * Configuration instance\r\n+     */\r\n+    private HeliosEasyControlsConfiguration config;\r\n+\r\n+    /**\r\n+     * Used to poll the variables' status based on the configured refresh interval\r\n+     */\r\n+    private ScheduledFuture<?> pollingJob;\r\n+\r\n+    /**\r\n+     * The map holding the variable meta info by variable name\r\n+     */\r\n+    private Map<String, HeliosVariable> vMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private static ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore>();\r\n+\r\n+    /**\r\n+     * Communication interface to the endpoint\r\n+     */\r\n+    private ModbusCommunicationInterface comms;\r\n+\r\n+    /**\r\n+     * The date format used by the device\r\n+     */\r\n+    private int dateFormat = -1;\r\n+\r\n+    /**\r\n+     * Constructor\r\n+     *\r\n+     * @param thing\r\n+     * @param managerRef\r\n+     */\r\n+    public HeliosEasyControlsHandler(Thing thing) {\r\n+        super(thing);\r\n+    }\r\n+\r\n+    /**\r\n+     * Reads variable definitions from JSON file and store them in vMap\r\n+     */\r\n+    private void readVariableDefinition() {\r\n+        try {\r\n+            Gson gson = new Gson();\r\n+            Type vMapType = new TypeToken<Map<String, HeliosVariable>>() {\r\n+            }.getType();\r\n+            this.vMap = gson.fromJson(\r\n+                    new BufferedReader(new InputStreamReader(getClass()\r\n+                            .getResourceAsStream(HeliosEasyControlsBindingConstants.VARIABLES_DEFINITION_FILE))),\r\n+                    vMapType);\r\n+            // add the name to the variable itself\r\n+            for (Map.Entry<String, HeliosVariable> entry : this.vMap.entrySet()) {\r\n+                entry.getValue().setName(entry.getKey()); // workaround to set the variable name inside the\r\n+                                                          // HeliosVariable object\r\n+                if (!entry.getValue().isOk()) {\r\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\r", "originalCommit": "73d8f576a176edc1b7c8f90549169819e7d5e410", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAxMTQxMA==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r465011410", "bodyText": "Check dev guidelines on logging levels https://www.openhab.org/docs/developer/guidelines.html#f-logging\nThis one should be perhaps logged with debug level or dropped all together (as thing status is updated). Also, it might be good give some context - now only exception message is logged.", "author": "ssalonen", "createdAt": "2020-08-04T12:25:29Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,577 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    /**\r\n+     * Logger instance\r\n+     */\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    /**\r\n+     * Configuration instance\r\n+     */\r\n+    private HeliosEasyControlsConfiguration config;\r\n+\r\n+    /**\r\n+     * Used to poll the variables' status based on the configured refresh interval\r\n+     */\r\n+    private ScheduledFuture<?> pollingJob;\r\n+\r\n+    /**\r\n+     * The map holding the variable meta info by variable name\r\n+     */\r\n+    private Map<String, HeliosVariable> vMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private static ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore>();\r\n+\r\n+    /**\r\n+     * Communication interface to the endpoint\r\n+     */\r\n+    private ModbusCommunicationInterface comms;\r\n+\r\n+    /**\r\n+     * The date format used by the device\r\n+     */\r\n+    private int dateFormat = -1;\r\n+\r\n+    /**\r\n+     * Constructor\r\n+     *\r\n+     * @param thing\r\n+     * @param managerRef\r\n+     */\r\n+    public HeliosEasyControlsHandler(Thing thing) {\r\n+        super(thing);\r\n+    }\r\n+\r\n+    /**\r\n+     * Reads variable definitions from JSON file and store them in vMap\r\n+     */\r\n+    private void readVariableDefinition() {\r\n+        try {\r\n+            Gson gson = new Gson();\r\n+            Type vMapType = new TypeToken<Map<String, HeliosVariable>>() {\r\n+            }.getType();\r\n+            this.vMap = gson.fromJson(\r\n+                    new BufferedReader(new InputStreamReader(getClass()\r\n+                            .getResourceAsStream(HeliosEasyControlsBindingConstants.VARIABLES_DEFINITION_FILE))),\r\n+                    vMapType);\r\n+            // add the name to the variable itself\r\n+            for (Map.Entry<String, HeliosVariable> entry : this.vMap.entrySet()) {\r\n+                entry.getValue().setName(entry.getKey()); // workaround to set the variable name inside the\r\n+                                                          // HeliosVariable object\r\n+                if (!entry.getValue().isOk()) {\r\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\r\n+                            \"Variables definition file contains inconsistent data.\");\r\n+\r\n+                }\r\n+            }\r\n+        } catch (Exception e) {\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\r\n+                    \"Variables definition file not found or of illegal format.\");\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the endpoint handler from the bridge this handler is connected to\r\n+     * Checks that we're connected to the right type of bridge\r\n+     *\r\n+     * @return the endpoint handler or null if the bridge does not exist\r\n+     */\r\n+    private ModbusEndpointThingHandler getEndpointThingHandler() {\r\n+        Bridge bridge = getBridge();\r\n+        if (bridge == null) {\r\n+            logger.debug(\"Bridge is null\");\r\n+            return null;\r\n+        }\r\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\r\n+            logger.debug(\"Bridge is not online\");\r\n+            return null;\r\n+        }\r\n+\r\n+        ThingHandler handler = bridge.getHandler();\r\n+        if (handler == null) {\r\n+            logger.debug(\"Bridge handler is null\");\r\n+            return null;\r\n+        }\r\n+\r\n+        if (handler instanceof ModbusEndpointThingHandler) {\r\n+            return (ModbusEndpointThingHandler) handler;\r\n+        } else {\r\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\r\n+            return null;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get a reference to the modbus endpoint\r\n+     */\r\n+    private void connectEndpoint() {\r\n+        if (this.comms != null) {\r\n+            return;\r\n+        }\r\n+\r\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\r\n+        if (slaveEndpointThingHandler == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' is offline\", label));\r\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\r\n+            return;\r\n+        }\r\n+\r\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\r\n+\r\n+        if (comms == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\r\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\r\n+            return;\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void initialize() {\r\n+        this.config = getConfigAs(HeliosEasyControlsConfiguration.class);\r\n+        this.readVariableDefinition();\r\n+        this.connectEndpoint();\r\n+        if (this.comms != null) {\r\n+            HeliosEasyControlsHandler.transactionLocks.putIfAbsent(this.comms.getEndpoint(), new Semaphore(1, true));\r\n+            updateStatus(ThingStatus.UNKNOWN);\r\n+\r\n+            // background initialization\r\n+            scheduler.execute(() -> {\r\n+                try {\r\n+                    readValue(HeliosEasyControlsBindingConstants.DATE_FORMAT);\r\n+                    // status will be updated to ONLINE by the read callback function\r\n+                } catch (HeliosException e) {\r\n+                    logger.error(e.getMessage());\r", "originalCommit": "73d8f576a176edc1b7c8f90549169819e7d5e410", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAxMjM3NA==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r465012374", "bodyText": "See comment on logging levels above", "author": "ssalonen", "createdAt": "2020-08-04T12:27:10Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,577 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    /**\r\n+     * Logger instance\r\n+     */\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    /**\r\n+     * Configuration instance\r\n+     */\r\n+    private HeliosEasyControlsConfiguration config;\r\n+\r\n+    /**\r\n+     * Used to poll the variables' status based on the configured refresh interval\r\n+     */\r\n+    private ScheduledFuture<?> pollingJob;\r\n+\r\n+    /**\r\n+     * The map holding the variable meta info by variable name\r\n+     */\r\n+    private Map<String, HeliosVariable> vMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private static ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore>();\r\n+\r\n+    /**\r\n+     * Communication interface to the endpoint\r\n+     */\r\n+    private ModbusCommunicationInterface comms;\r\n+\r\n+    /**\r\n+     * The date format used by the device\r\n+     */\r\n+    private int dateFormat = -1;\r\n+\r\n+    /**\r\n+     * Constructor\r\n+     *\r\n+     * @param thing\r\n+     * @param managerRef\r\n+     */\r\n+    public HeliosEasyControlsHandler(Thing thing) {\r\n+        super(thing);\r\n+    }\r\n+\r\n+    /**\r\n+     * Reads variable definitions from JSON file and store them in vMap\r\n+     */\r\n+    private void readVariableDefinition() {\r\n+        try {\r\n+            Gson gson = new Gson();\r\n+            Type vMapType = new TypeToken<Map<String, HeliosVariable>>() {\r\n+            }.getType();\r\n+            this.vMap = gson.fromJson(\r\n+                    new BufferedReader(new InputStreamReader(getClass()\r\n+                            .getResourceAsStream(HeliosEasyControlsBindingConstants.VARIABLES_DEFINITION_FILE))),\r\n+                    vMapType);\r\n+            // add the name to the variable itself\r\n+            for (Map.Entry<String, HeliosVariable> entry : this.vMap.entrySet()) {\r\n+                entry.getValue().setName(entry.getKey()); // workaround to set the variable name inside the\r\n+                                                          // HeliosVariable object\r\n+                if (!entry.getValue().isOk()) {\r\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\r\n+                            \"Variables definition file contains inconsistent data.\");\r\n+\r\n+                }\r\n+            }\r\n+        } catch (Exception e) {\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\r\n+                    \"Variables definition file not found or of illegal format.\");\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the endpoint handler from the bridge this handler is connected to\r\n+     * Checks that we're connected to the right type of bridge\r\n+     *\r\n+     * @return the endpoint handler or null if the bridge does not exist\r\n+     */\r\n+    private ModbusEndpointThingHandler getEndpointThingHandler() {\r\n+        Bridge bridge = getBridge();\r\n+        if (bridge == null) {\r\n+            logger.debug(\"Bridge is null\");\r\n+            return null;\r\n+        }\r\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\r\n+            logger.debug(\"Bridge is not online\");\r\n+            return null;\r\n+        }\r\n+\r\n+        ThingHandler handler = bridge.getHandler();\r\n+        if (handler == null) {\r\n+            logger.debug(\"Bridge handler is null\");\r\n+            return null;\r\n+        }\r\n+\r\n+        if (handler instanceof ModbusEndpointThingHandler) {\r\n+            return (ModbusEndpointThingHandler) handler;\r\n+        } else {\r\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\r\n+            return null;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get a reference to the modbus endpoint\r\n+     */\r\n+    private void connectEndpoint() {\r\n+        if (this.comms != null) {\r\n+            return;\r\n+        }\r\n+\r\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\r\n+        if (slaveEndpointThingHandler == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' is offline\", label));\r\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\r\n+            return;\r\n+        }\r\n+\r\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\r\n+\r\n+        if (comms == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\r\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\r\n+            return;\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void initialize() {\r\n+        this.config = getConfigAs(HeliosEasyControlsConfiguration.class);\r\n+        this.readVariableDefinition();\r\n+        this.connectEndpoint();\r\n+        if (this.comms != null) {\r\n+            HeliosEasyControlsHandler.transactionLocks.putIfAbsent(this.comms.getEndpoint(), new Semaphore(1, true));\r\n+            updateStatus(ThingStatus.UNKNOWN);\r\n+\r\n+            // background initialization\r\n+            scheduler.execute(() -> {\r\n+                try {\r\n+                    readValue(HeliosEasyControlsBindingConstants.DATE_FORMAT);\r\n+                    // status will be updated to ONLINE by the read callback function\r\n+                } catch (HeliosException e) {\r\n+                    logger.error(e.getMessage());\r\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\r\n+                }\r\n+            });\r\n+\r\n+            // poll for status updates regularly\r\n+            Runnable runnable = new Runnable() {\r\n+\r\n+                @Override\r\n+                public void run() {\r\n+                    for (Map.Entry<String, HeliosVariable> entry : vMap.entrySet()) {\r\n+                        if (isLinked(entry.getKey())\r\n+                                || (entry.getKey().equals(HeliosEasyControlsBindingConstants.DATE_FORMAT))) {\r\n+                            try {\r\n+                                readValue(entry.getKey());\r\n+                            } catch (HeliosException e) {\r\n+                                logger.error(e.getMessage());\r", "originalCommit": "73d8f576a176edc1b7c8f90549169819e7d5e410", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAxMjUxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r465012515", "bodyText": "Logging levels", "author": "ssalonen", "createdAt": "2020-08-04T12:27:26Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,577 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    /**\r\n+     * Logger instance\r\n+     */\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    /**\r\n+     * Configuration instance\r\n+     */\r\n+    private HeliosEasyControlsConfiguration config;\r\n+\r\n+    /**\r\n+     * Used to poll the variables' status based on the configured refresh interval\r\n+     */\r\n+    private ScheduledFuture<?> pollingJob;\r\n+\r\n+    /**\r\n+     * The map holding the variable meta info by variable name\r\n+     */\r\n+    private Map<String, HeliosVariable> vMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private static ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore>();\r\n+\r\n+    /**\r\n+     * Communication interface to the endpoint\r\n+     */\r\n+    private ModbusCommunicationInterface comms;\r\n+\r\n+    /**\r\n+     * The date format used by the device\r\n+     */\r\n+    private int dateFormat = -1;\r\n+\r\n+    /**\r\n+     * Constructor\r\n+     *\r\n+     * @param thing\r\n+     * @param managerRef\r\n+     */\r\n+    public HeliosEasyControlsHandler(Thing thing) {\r\n+        super(thing);\r\n+    }\r\n+\r\n+    /**\r\n+     * Reads variable definitions from JSON file and store them in vMap\r\n+     */\r\n+    private void readVariableDefinition() {\r\n+        try {\r\n+            Gson gson = new Gson();\r\n+            Type vMapType = new TypeToken<Map<String, HeliosVariable>>() {\r\n+            }.getType();\r\n+            this.vMap = gson.fromJson(\r\n+                    new BufferedReader(new InputStreamReader(getClass()\r\n+                            .getResourceAsStream(HeliosEasyControlsBindingConstants.VARIABLES_DEFINITION_FILE))),\r\n+                    vMapType);\r\n+            // add the name to the variable itself\r\n+            for (Map.Entry<String, HeliosVariable> entry : this.vMap.entrySet()) {\r\n+                entry.getValue().setName(entry.getKey()); // workaround to set the variable name inside the\r\n+                                                          // HeliosVariable object\r\n+                if (!entry.getValue().isOk()) {\r\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\r\n+                            \"Variables definition file contains inconsistent data.\");\r\n+\r\n+                }\r\n+            }\r\n+        } catch (Exception e) {\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\r\n+                    \"Variables definition file not found or of illegal format.\");\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the endpoint handler from the bridge this handler is connected to\r\n+     * Checks that we're connected to the right type of bridge\r\n+     *\r\n+     * @return the endpoint handler or null if the bridge does not exist\r\n+     */\r\n+    private ModbusEndpointThingHandler getEndpointThingHandler() {\r\n+        Bridge bridge = getBridge();\r\n+        if (bridge == null) {\r\n+            logger.debug(\"Bridge is null\");\r\n+            return null;\r\n+        }\r\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\r\n+            logger.debug(\"Bridge is not online\");\r\n+            return null;\r\n+        }\r\n+\r\n+        ThingHandler handler = bridge.getHandler();\r\n+        if (handler == null) {\r\n+            logger.debug(\"Bridge handler is null\");\r\n+            return null;\r\n+        }\r\n+\r\n+        if (handler instanceof ModbusEndpointThingHandler) {\r\n+            return (ModbusEndpointThingHandler) handler;\r\n+        } else {\r\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\r\n+            return null;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get a reference to the modbus endpoint\r\n+     */\r\n+    private void connectEndpoint() {\r\n+        if (this.comms != null) {\r\n+            return;\r\n+        }\r\n+\r\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\r\n+        if (slaveEndpointThingHandler == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' is offline\", label));\r\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\r\n+            return;\r\n+        }\r\n+\r\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\r\n+\r\n+        if (comms == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\r\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\r\n+            return;\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void initialize() {\r\n+        this.config = getConfigAs(HeliosEasyControlsConfiguration.class);\r\n+        this.readVariableDefinition();\r\n+        this.connectEndpoint();\r\n+        if (this.comms != null) {\r\n+            HeliosEasyControlsHandler.transactionLocks.putIfAbsent(this.comms.getEndpoint(), new Semaphore(1, true));\r\n+            updateStatus(ThingStatus.UNKNOWN);\r\n+\r\n+            // background initialization\r\n+            scheduler.execute(() -> {\r\n+                try {\r\n+                    readValue(HeliosEasyControlsBindingConstants.DATE_FORMAT);\r\n+                    // status will be updated to ONLINE by the read callback function\r\n+                } catch (HeliosException e) {\r\n+                    logger.error(e.getMessage());\r\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\r\n+                }\r\n+            });\r\n+\r\n+            // poll for status updates regularly\r\n+            Runnable runnable = new Runnable() {\r\n+\r\n+                @Override\r\n+                public void run() {\r\n+                    for (Map.Entry<String, HeliosVariable> entry : vMap.entrySet()) {\r\n+                        if (isLinked(entry.getKey())\r\n+                                || (entry.getKey().equals(HeliosEasyControlsBindingConstants.DATE_FORMAT))) {\r\n+                            try {\r\n+                                readValue(entry.getKey());\r\n+                            } catch (HeliosException e) {\r\n+                                logger.error(e.getMessage());\r\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\r\n+                                        e.getMessage());\r\n+                            }\r\n+                        }\r\n+                    }\r\n+                }\r\n+            };\r\n+            this.pollingJob = scheduler.scheduleAtFixedRate(runnable, config.getRefreshInterval(),\r\n+                    config.getRefreshInterval(), TimeUnit.MILLISECONDS);\r\n+\r\n+        } else {\r\n+            logger.error(\"Modbus endpoint is null.\");\r", "originalCommit": "73d8f576a176edc1b7c8f90549169819e7d5e410", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAxMzk0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r465013945", "bodyText": "Check logging level. Consider updating thing status on failed writes", "author": "ssalonen", "createdAt": "2020-08-04T12:30:07Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,577 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    /**\r\n+     * Logger instance\r\n+     */\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    /**\r\n+     * Configuration instance\r\n+     */\r\n+    private HeliosEasyControlsConfiguration config;\r\n+\r\n+    /**\r\n+     * Used to poll the variables' status based on the configured refresh interval\r\n+     */\r\n+    private ScheduledFuture<?> pollingJob;\r\n+\r\n+    /**\r\n+     * The map holding the variable meta info by variable name\r\n+     */\r\n+    private Map<String, HeliosVariable> vMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private static ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore>();\r\n+\r\n+    /**\r\n+     * Communication interface to the endpoint\r\n+     */\r\n+    private ModbusCommunicationInterface comms;\r\n+\r\n+    /**\r\n+     * The date format used by the device\r\n+     */\r\n+    private int dateFormat = -1;\r\n+\r\n+    /**\r\n+     * Constructor\r\n+     *\r\n+     * @param thing\r\n+     * @param managerRef\r\n+     */\r\n+    public HeliosEasyControlsHandler(Thing thing) {\r\n+        super(thing);\r\n+    }\r\n+\r\n+    /**\r\n+     * Reads variable definitions from JSON file and store them in vMap\r\n+     */\r\n+    private void readVariableDefinition() {\r\n+        try {\r\n+            Gson gson = new Gson();\r\n+            Type vMapType = new TypeToken<Map<String, HeliosVariable>>() {\r\n+            }.getType();\r\n+            this.vMap = gson.fromJson(\r\n+                    new BufferedReader(new InputStreamReader(getClass()\r\n+                            .getResourceAsStream(HeliosEasyControlsBindingConstants.VARIABLES_DEFINITION_FILE))),\r\n+                    vMapType);\r\n+            // add the name to the variable itself\r\n+            for (Map.Entry<String, HeliosVariable> entry : this.vMap.entrySet()) {\r\n+                entry.getValue().setName(entry.getKey()); // workaround to set the variable name inside the\r\n+                                                          // HeliosVariable object\r\n+                if (!entry.getValue().isOk()) {\r\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\r\n+                            \"Variables definition file contains inconsistent data.\");\r\n+\r\n+                }\r\n+            }\r\n+        } catch (Exception e) {\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\r\n+                    \"Variables definition file not found or of illegal format.\");\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the endpoint handler from the bridge this handler is connected to\r\n+     * Checks that we're connected to the right type of bridge\r\n+     *\r\n+     * @return the endpoint handler or null if the bridge does not exist\r\n+     */\r\n+    private ModbusEndpointThingHandler getEndpointThingHandler() {\r\n+        Bridge bridge = getBridge();\r\n+        if (bridge == null) {\r\n+            logger.debug(\"Bridge is null\");\r\n+            return null;\r\n+        }\r\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\r\n+            logger.debug(\"Bridge is not online\");\r\n+            return null;\r\n+        }\r\n+\r\n+        ThingHandler handler = bridge.getHandler();\r\n+        if (handler == null) {\r\n+            logger.debug(\"Bridge handler is null\");\r\n+            return null;\r\n+        }\r\n+\r\n+        if (handler instanceof ModbusEndpointThingHandler) {\r\n+            return (ModbusEndpointThingHandler) handler;\r\n+        } else {\r\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\r\n+            return null;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get a reference to the modbus endpoint\r\n+     */\r\n+    private void connectEndpoint() {\r\n+        if (this.comms != null) {\r\n+            return;\r\n+        }\r\n+\r\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\r\n+        if (slaveEndpointThingHandler == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' is offline\", label));\r\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\r\n+            return;\r\n+        }\r\n+\r\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\r\n+\r\n+        if (comms == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\r\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\r\n+            return;\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void initialize() {\r\n+        this.config = getConfigAs(HeliosEasyControlsConfiguration.class);\r\n+        this.readVariableDefinition();\r\n+        this.connectEndpoint();\r\n+        if (this.comms != null) {\r\n+            HeliosEasyControlsHandler.transactionLocks.putIfAbsent(this.comms.getEndpoint(), new Semaphore(1, true));\r\n+            updateStatus(ThingStatus.UNKNOWN);\r\n+\r\n+            // background initialization\r\n+            scheduler.execute(() -> {\r\n+                try {\r\n+                    readValue(HeliosEasyControlsBindingConstants.DATE_FORMAT);\r\n+                    // status will be updated to ONLINE by the read callback function\r\n+                } catch (HeliosException e) {\r\n+                    logger.error(e.getMessage());\r\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\r\n+                }\r\n+            });\r\n+\r\n+            // poll for status updates regularly\r\n+            Runnable runnable = new Runnable() {\r\n+\r\n+                @Override\r\n+                public void run() {\r\n+                    for (Map.Entry<String, HeliosVariable> entry : vMap.entrySet()) {\r\n+                        if (isLinked(entry.getKey())\r\n+                                || (entry.getKey().equals(HeliosEasyControlsBindingConstants.DATE_FORMAT))) {\r\n+                            try {\r\n+                                readValue(entry.getKey());\r\n+                            } catch (HeliosException e) {\r\n+                                logger.error(e.getMessage());\r\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\r\n+                                        e.getMessage());\r\n+                            }\r\n+                        }\r\n+                    }\r\n+                }\r\n+            };\r\n+            this.pollingJob = scheduler.scheduleAtFixedRate(runnable, config.getRefreshInterval(),\r\n+                    config.getRefreshInterval(), TimeUnit.MILLISECONDS);\r\n+\r\n+        } else {\r\n+            logger.error(\"Modbus endpoint is null.\");\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void dispose() {\r\n+        if (this.pollingJob != null) {\r\n+            this.pollingJob.cancel(true);\r\n+        }\r\n+        this.comms = null;\r\n+    }\r\n+\r\n+    @Override\r\n+    public void handleCommand(ChannelUID channelUID, Command command) {\r\n+        String channelId = channelUID.getId();\r\n+        if (command instanceof RefreshType) {\r\n+            scheduler.schedule(new Runnable() {\r\n+                @Override\r\n+                public void run() {\r\n+                    try {\r\n+                        readValue(channelId);\r\n+                    } catch (HeliosException e) {\r\n+                        logger.error(e.getMessage());\r\n+                    }\r\n+                }\r\n+            }, 0, TimeUnit.SECONDS);\r\n+        } else { // write command\r\n+            String value;\r\n+            if (command instanceof OnOffType) {\r\n+                value = command == OnOffType.ON ? \"1\" : \"0\";\r\n+            } else if (command instanceof DateTimeType) {\r\n+                value = formatDate(channelId, ((DateTimeType) command).getZonedDateTime());\r\n+            } else { // Number or String\r\n+                value = command.toString();\r\n+            }\r\n+            scheduler.schedule(new Runnable() {\r\n+                @Override\r\n+                public void run() {\r\n+                    try {\r\n+                        writeValue(channelId, value);\r\n+                    } catch (HeliosException e) {\r\n+                        logger.error(e.getMessage());\r", "originalCommit": "73d8f576a176edc1b7c8f90549169819e7d5e410", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAxNDAxNA==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r465014014", "bodyText": "Check logging level. Consider updating thing status on failed writes", "author": "ssalonen", "createdAt": "2020-08-04T12:30:15Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,577 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    /**\r\n+     * Logger instance\r\n+     */\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    /**\r\n+     * Configuration instance\r\n+     */\r\n+    private HeliosEasyControlsConfiguration config;\r\n+\r\n+    /**\r\n+     * Used to poll the variables' status based on the configured refresh interval\r\n+     */\r\n+    private ScheduledFuture<?> pollingJob;\r\n+\r\n+    /**\r\n+     * The map holding the variable meta info by variable name\r\n+     */\r\n+    private Map<String, HeliosVariable> vMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private static ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore>();\r\n+\r\n+    /**\r\n+     * Communication interface to the endpoint\r\n+     */\r\n+    private ModbusCommunicationInterface comms;\r\n+\r\n+    /**\r\n+     * The date format used by the device\r\n+     */\r\n+    private int dateFormat = -1;\r\n+\r\n+    /**\r\n+     * Constructor\r\n+     *\r\n+     * @param thing\r\n+     * @param managerRef\r\n+     */\r\n+    public HeliosEasyControlsHandler(Thing thing) {\r\n+        super(thing);\r\n+    }\r\n+\r\n+    /**\r\n+     * Reads variable definitions from JSON file and store them in vMap\r\n+     */\r\n+    private void readVariableDefinition() {\r\n+        try {\r\n+            Gson gson = new Gson();\r\n+            Type vMapType = new TypeToken<Map<String, HeliosVariable>>() {\r\n+            }.getType();\r\n+            this.vMap = gson.fromJson(\r\n+                    new BufferedReader(new InputStreamReader(getClass()\r\n+                            .getResourceAsStream(HeliosEasyControlsBindingConstants.VARIABLES_DEFINITION_FILE))),\r\n+                    vMapType);\r\n+            // add the name to the variable itself\r\n+            for (Map.Entry<String, HeliosVariable> entry : this.vMap.entrySet()) {\r\n+                entry.getValue().setName(entry.getKey()); // workaround to set the variable name inside the\r\n+                                                          // HeliosVariable object\r\n+                if (!entry.getValue().isOk()) {\r\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\r\n+                            \"Variables definition file contains inconsistent data.\");\r\n+\r\n+                }\r\n+            }\r\n+        } catch (Exception e) {\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\r\n+                    \"Variables definition file not found or of illegal format.\");\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the endpoint handler from the bridge this handler is connected to\r\n+     * Checks that we're connected to the right type of bridge\r\n+     *\r\n+     * @return the endpoint handler or null if the bridge does not exist\r\n+     */\r\n+    private ModbusEndpointThingHandler getEndpointThingHandler() {\r\n+        Bridge bridge = getBridge();\r\n+        if (bridge == null) {\r\n+            logger.debug(\"Bridge is null\");\r\n+            return null;\r\n+        }\r\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\r\n+            logger.debug(\"Bridge is not online\");\r\n+            return null;\r\n+        }\r\n+\r\n+        ThingHandler handler = bridge.getHandler();\r\n+        if (handler == null) {\r\n+            logger.debug(\"Bridge handler is null\");\r\n+            return null;\r\n+        }\r\n+\r\n+        if (handler instanceof ModbusEndpointThingHandler) {\r\n+            return (ModbusEndpointThingHandler) handler;\r\n+        } else {\r\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\r\n+            return null;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get a reference to the modbus endpoint\r\n+     */\r\n+    private void connectEndpoint() {\r\n+        if (this.comms != null) {\r\n+            return;\r\n+        }\r\n+\r\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\r\n+        if (slaveEndpointThingHandler == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' is offline\", label));\r\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\r\n+            return;\r\n+        }\r\n+\r\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\r\n+\r\n+        if (comms == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\r\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\r\n+            return;\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void initialize() {\r\n+        this.config = getConfigAs(HeliosEasyControlsConfiguration.class);\r\n+        this.readVariableDefinition();\r\n+        this.connectEndpoint();\r\n+        if (this.comms != null) {\r\n+            HeliosEasyControlsHandler.transactionLocks.putIfAbsent(this.comms.getEndpoint(), new Semaphore(1, true));\r\n+            updateStatus(ThingStatus.UNKNOWN);\r\n+\r\n+            // background initialization\r\n+            scheduler.execute(() -> {\r\n+                try {\r\n+                    readValue(HeliosEasyControlsBindingConstants.DATE_FORMAT);\r\n+                    // status will be updated to ONLINE by the read callback function\r\n+                } catch (HeliosException e) {\r\n+                    logger.error(e.getMessage());\r\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\r\n+                }\r\n+            });\r\n+\r\n+            // poll for status updates regularly\r\n+            Runnable runnable = new Runnable() {\r\n+\r\n+                @Override\r\n+                public void run() {\r\n+                    for (Map.Entry<String, HeliosVariable> entry : vMap.entrySet()) {\r\n+                        if (isLinked(entry.getKey())\r\n+                                || (entry.getKey().equals(HeliosEasyControlsBindingConstants.DATE_FORMAT))) {\r\n+                            try {\r\n+                                readValue(entry.getKey());\r\n+                            } catch (HeliosException e) {\r\n+                                logger.error(e.getMessage());\r\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\r\n+                                        e.getMessage());\r\n+                            }\r\n+                        }\r\n+                    }\r\n+                }\r\n+            };\r\n+            this.pollingJob = scheduler.scheduleAtFixedRate(runnable, config.getRefreshInterval(),\r\n+                    config.getRefreshInterval(), TimeUnit.MILLISECONDS);\r\n+\r\n+        } else {\r\n+            logger.error(\"Modbus endpoint is null.\");\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void dispose() {\r\n+        if (this.pollingJob != null) {\r\n+            this.pollingJob.cancel(true);\r\n+        }\r\n+        this.comms = null;\r\n+    }\r\n+\r\n+    @Override\r\n+    public void handleCommand(ChannelUID channelUID, Command command) {\r\n+        String channelId = channelUID.getId();\r\n+        if (command instanceof RefreshType) {\r\n+            scheduler.schedule(new Runnable() {\r\n+                @Override\r\n+                public void run() {\r\n+                    try {\r\n+                        readValue(channelId);\r\n+                    } catch (HeliosException e) {\r\n+                        logger.error(e.getMessage());\r", "originalCommit": "73d8f576a176edc1b7c8f90549169819e7d5e410", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAxNDUwOA==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r465014508", "bodyText": "Document cases when the exception is raised", "author": "ssalonen", "createdAt": "2020-08-04T12:31:11Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,577 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    /**\r\n+     * Logger instance\r\n+     */\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    /**\r\n+     * Configuration instance\r\n+     */\r\n+    private HeliosEasyControlsConfiguration config;\r\n+\r\n+    /**\r\n+     * Used to poll the variables' status based on the configured refresh interval\r\n+     */\r\n+    private ScheduledFuture<?> pollingJob;\r\n+\r\n+    /**\r\n+     * The map holding the variable meta info by variable name\r\n+     */\r\n+    private Map<String, HeliosVariable> vMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private static ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore>();\r\n+\r\n+    /**\r\n+     * Communication interface to the endpoint\r\n+     */\r\n+    private ModbusCommunicationInterface comms;\r\n+\r\n+    /**\r\n+     * The date format used by the device\r\n+     */\r\n+    private int dateFormat = -1;\r\n+\r\n+    /**\r\n+     * Constructor\r\n+     *\r\n+     * @param thing\r\n+     * @param managerRef\r\n+     */\r\n+    public HeliosEasyControlsHandler(Thing thing) {\r\n+        super(thing);\r\n+    }\r\n+\r\n+    /**\r\n+     * Reads variable definitions from JSON file and store them in vMap\r\n+     */\r\n+    private void readVariableDefinition() {\r\n+        try {\r\n+            Gson gson = new Gson();\r\n+            Type vMapType = new TypeToken<Map<String, HeliosVariable>>() {\r\n+            }.getType();\r\n+            this.vMap = gson.fromJson(\r\n+                    new BufferedReader(new InputStreamReader(getClass()\r\n+                            .getResourceAsStream(HeliosEasyControlsBindingConstants.VARIABLES_DEFINITION_FILE))),\r\n+                    vMapType);\r\n+            // add the name to the variable itself\r\n+            for (Map.Entry<String, HeliosVariable> entry : this.vMap.entrySet()) {\r\n+                entry.getValue().setName(entry.getKey()); // workaround to set the variable name inside the\r\n+                                                          // HeliosVariable object\r\n+                if (!entry.getValue().isOk()) {\r\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\r\n+                            \"Variables definition file contains inconsistent data.\");\r\n+\r\n+                }\r\n+            }\r\n+        } catch (Exception e) {\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\r\n+                    \"Variables definition file not found or of illegal format.\");\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the endpoint handler from the bridge this handler is connected to\r\n+     * Checks that we're connected to the right type of bridge\r\n+     *\r\n+     * @return the endpoint handler or null if the bridge does not exist\r\n+     */\r\n+    private ModbusEndpointThingHandler getEndpointThingHandler() {\r\n+        Bridge bridge = getBridge();\r\n+        if (bridge == null) {\r\n+            logger.debug(\"Bridge is null\");\r\n+            return null;\r\n+        }\r\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\r\n+            logger.debug(\"Bridge is not online\");\r\n+            return null;\r\n+        }\r\n+\r\n+        ThingHandler handler = bridge.getHandler();\r\n+        if (handler == null) {\r\n+            logger.debug(\"Bridge handler is null\");\r\n+            return null;\r\n+        }\r\n+\r\n+        if (handler instanceof ModbusEndpointThingHandler) {\r\n+            return (ModbusEndpointThingHandler) handler;\r\n+        } else {\r\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\r\n+            return null;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get a reference to the modbus endpoint\r\n+     */\r\n+    private void connectEndpoint() {\r\n+        if (this.comms != null) {\r\n+            return;\r\n+        }\r\n+\r\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\r\n+        if (slaveEndpointThingHandler == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' is offline\", label));\r\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\r\n+            return;\r\n+        }\r\n+\r\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\r\n+\r\n+        if (comms == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\r\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\r\n+            return;\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void initialize() {\r\n+        this.config = getConfigAs(HeliosEasyControlsConfiguration.class);\r\n+        this.readVariableDefinition();\r\n+        this.connectEndpoint();\r\n+        if (this.comms != null) {\r\n+            HeliosEasyControlsHandler.transactionLocks.putIfAbsent(this.comms.getEndpoint(), new Semaphore(1, true));\r\n+            updateStatus(ThingStatus.UNKNOWN);\r\n+\r\n+            // background initialization\r\n+            scheduler.execute(() -> {\r\n+                try {\r\n+                    readValue(HeliosEasyControlsBindingConstants.DATE_FORMAT);\r\n+                    // status will be updated to ONLINE by the read callback function\r\n+                } catch (HeliosException e) {\r\n+                    logger.error(e.getMessage());\r\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\r\n+                }\r\n+            });\r\n+\r\n+            // poll for status updates regularly\r\n+            Runnable runnable = new Runnable() {\r\n+\r\n+                @Override\r\n+                public void run() {\r\n+                    for (Map.Entry<String, HeliosVariable> entry : vMap.entrySet()) {\r\n+                        if (isLinked(entry.getKey())\r\n+                                || (entry.getKey().equals(HeliosEasyControlsBindingConstants.DATE_FORMAT))) {\r\n+                            try {\r\n+                                readValue(entry.getKey());\r\n+                            } catch (HeliosException e) {\r\n+                                logger.error(e.getMessage());\r\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\r\n+                                        e.getMessage());\r\n+                            }\r\n+                        }\r\n+                    }\r\n+                }\r\n+            };\r\n+            this.pollingJob = scheduler.scheduleAtFixedRate(runnable, config.getRefreshInterval(),\r\n+                    config.getRefreshInterval(), TimeUnit.MILLISECONDS);\r\n+\r\n+        } else {\r\n+            logger.error(\"Modbus endpoint is null.\");\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void dispose() {\r\n+        if (this.pollingJob != null) {\r\n+            this.pollingJob.cancel(true);\r\n+        }\r\n+        this.comms = null;\r\n+    }\r\n+\r\n+    @Override\r\n+    public void handleCommand(ChannelUID channelUID, Command command) {\r\n+        String channelId = channelUID.getId();\r\n+        if (command instanceof RefreshType) {\r\n+            scheduler.schedule(new Runnable() {\r\n+                @Override\r\n+                public void run() {\r\n+                    try {\r\n+                        readValue(channelId);\r\n+                    } catch (HeliosException e) {\r\n+                        logger.error(e.getMessage());\r\n+                    }\r\n+                }\r\n+            }, 0, TimeUnit.SECONDS);\r\n+        } else { // write command\r\n+            String value;\r\n+            if (command instanceof OnOffType) {\r\n+                value = command == OnOffType.ON ? \"1\" : \"0\";\r\n+            } else if (command instanceof DateTimeType) {\r\n+                value = formatDate(channelId, ((DateTimeType) command).getZonedDateTime());\r\n+            } else { // Number or String\r\n+                value = command.toString();\r\n+            }\r\n+            scheduler.schedule(new Runnable() {\r\n+                @Override\r\n+                public void run() {\r\n+                    try {\r\n+                        writeValue(channelId, value);\r\n+                    } catch (HeliosException e) {\r\n+                        logger.error(e.getMessage());\r\n+                    }\r\n+                }\r\n+            }, 0, TimeUnit.SECONDS);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Writes a variable value to the Helios device\r\n+     *\r\n+     * @param variableName The variable name\r\n+     * @param value The new value\r\n+     * @return The value if the transaction succeeded, <tt>null</tt> otherwise\r\n+     * @throws HeliosException\r", "originalCommit": "73d8f576a176edc1b7c8f90549169819e7d5e410", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAxNTIzNA==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r465015234", "bodyText": "Document when exception is raised", "author": "ssalonen", "createdAt": "2020-08-04T12:32:30Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,577 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    /**\r\n+     * Logger instance\r\n+     */\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    /**\r\n+     * Configuration instance\r\n+     */\r\n+    private HeliosEasyControlsConfiguration config;\r\n+\r\n+    /**\r\n+     * Used to poll the variables' status based on the configured refresh interval\r\n+     */\r\n+    private ScheduledFuture<?> pollingJob;\r\n+\r\n+    /**\r\n+     * The map holding the variable meta info by variable name\r\n+     */\r\n+    private Map<String, HeliosVariable> vMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private static ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore>();\r\n+\r\n+    /**\r\n+     * Communication interface to the endpoint\r\n+     */\r\n+    private ModbusCommunicationInterface comms;\r\n+\r\n+    /**\r\n+     * The date format used by the device\r\n+     */\r\n+    private int dateFormat = -1;\r\n+\r\n+    /**\r\n+     * Constructor\r\n+     *\r\n+     * @param thing\r\n+     * @param managerRef\r\n+     */\r\n+    public HeliosEasyControlsHandler(Thing thing) {\r\n+        super(thing);\r\n+    }\r\n+\r\n+    /**\r\n+     * Reads variable definitions from JSON file and store them in vMap\r\n+     */\r\n+    private void readVariableDefinition() {\r\n+        try {\r\n+            Gson gson = new Gson();\r\n+            Type vMapType = new TypeToken<Map<String, HeliosVariable>>() {\r\n+            }.getType();\r\n+            this.vMap = gson.fromJson(\r\n+                    new BufferedReader(new InputStreamReader(getClass()\r\n+                            .getResourceAsStream(HeliosEasyControlsBindingConstants.VARIABLES_DEFINITION_FILE))),\r\n+                    vMapType);\r\n+            // add the name to the variable itself\r\n+            for (Map.Entry<String, HeliosVariable> entry : this.vMap.entrySet()) {\r\n+                entry.getValue().setName(entry.getKey()); // workaround to set the variable name inside the\r\n+                                                          // HeliosVariable object\r\n+                if (!entry.getValue().isOk()) {\r\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\r\n+                            \"Variables definition file contains inconsistent data.\");\r\n+\r\n+                }\r\n+            }\r\n+        } catch (Exception e) {\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\r\n+                    \"Variables definition file not found or of illegal format.\");\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the endpoint handler from the bridge this handler is connected to\r\n+     * Checks that we're connected to the right type of bridge\r\n+     *\r\n+     * @return the endpoint handler or null if the bridge does not exist\r\n+     */\r\n+    private ModbusEndpointThingHandler getEndpointThingHandler() {\r\n+        Bridge bridge = getBridge();\r\n+        if (bridge == null) {\r\n+            logger.debug(\"Bridge is null\");\r\n+            return null;\r\n+        }\r\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\r\n+            logger.debug(\"Bridge is not online\");\r\n+            return null;\r\n+        }\r\n+\r\n+        ThingHandler handler = bridge.getHandler();\r\n+        if (handler == null) {\r\n+            logger.debug(\"Bridge handler is null\");\r\n+            return null;\r\n+        }\r\n+\r\n+        if (handler instanceof ModbusEndpointThingHandler) {\r\n+            return (ModbusEndpointThingHandler) handler;\r\n+        } else {\r\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\r\n+            return null;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get a reference to the modbus endpoint\r\n+     */\r\n+    private void connectEndpoint() {\r\n+        if (this.comms != null) {\r\n+            return;\r\n+        }\r\n+\r\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\r\n+        if (slaveEndpointThingHandler == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' is offline\", label));\r\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\r\n+            return;\r\n+        }\r\n+\r\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\r\n+\r\n+        if (comms == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\r\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\r\n+            return;\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void initialize() {\r\n+        this.config = getConfigAs(HeliosEasyControlsConfiguration.class);\r\n+        this.readVariableDefinition();\r\n+        this.connectEndpoint();\r\n+        if (this.comms != null) {\r\n+            HeliosEasyControlsHandler.transactionLocks.putIfAbsent(this.comms.getEndpoint(), new Semaphore(1, true));\r\n+            updateStatus(ThingStatus.UNKNOWN);\r\n+\r\n+            // background initialization\r\n+            scheduler.execute(() -> {\r\n+                try {\r\n+                    readValue(HeliosEasyControlsBindingConstants.DATE_FORMAT);\r\n+                    // status will be updated to ONLINE by the read callback function\r\n+                } catch (HeliosException e) {\r\n+                    logger.error(e.getMessage());\r\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\r\n+                }\r\n+            });\r\n+\r\n+            // poll for status updates regularly\r\n+            Runnable runnable = new Runnable() {\r\n+\r\n+                @Override\r\n+                public void run() {\r\n+                    for (Map.Entry<String, HeliosVariable> entry : vMap.entrySet()) {\r\n+                        if (isLinked(entry.getKey())\r\n+                                || (entry.getKey().equals(HeliosEasyControlsBindingConstants.DATE_FORMAT))) {\r\n+                            try {\r\n+                                readValue(entry.getKey());\r\n+                            } catch (HeliosException e) {\r\n+                                logger.error(e.getMessage());\r\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\r\n+                                        e.getMessage());\r\n+                            }\r\n+                        }\r\n+                    }\r\n+                }\r\n+            };\r\n+            this.pollingJob = scheduler.scheduleAtFixedRate(runnable, config.getRefreshInterval(),\r\n+                    config.getRefreshInterval(), TimeUnit.MILLISECONDS);\r\n+\r\n+        } else {\r\n+            logger.error(\"Modbus endpoint is null.\");\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void dispose() {\r\n+        if (this.pollingJob != null) {\r\n+            this.pollingJob.cancel(true);\r\n+        }\r\n+        this.comms = null;\r\n+    }\r\n+\r\n+    @Override\r\n+    public void handleCommand(ChannelUID channelUID, Command command) {\r\n+        String channelId = channelUID.getId();\r\n+        if (command instanceof RefreshType) {\r\n+            scheduler.schedule(new Runnable() {\r\n+                @Override\r\n+                public void run() {\r\n+                    try {\r\n+                        readValue(channelId);\r\n+                    } catch (HeliosException e) {\r\n+                        logger.error(e.getMessage());\r\n+                    }\r\n+                }\r\n+            }, 0, TimeUnit.SECONDS);\r\n+        } else { // write command\r\n+            String value;\r\n+            if (command instanceof OnOffType) {\r\n+                value = command == OnOffType.ON ? \"1\" : \"0\";\r\n+            } else if (command instanceof DateTimeType) {\r\n+                value = formatDate(channelId, ((DateTimeType) command).getZonedDateTime());\r\n+            } else { // Number or String\r\n+                value = command.toString();\r\n+            }\r\n+            scheduler.schedule(new Runnable() {\r\n+                @Override\r\n+                public void run() {\r\n+                    try {\r\n+                        writeValue(channelId, value);\r\n+                    } catch (HeliosException e) {\r\n+                        logger.error(e.getMessage());\r\n+                    }\r\n+                }\r\n+            }, 0, TimeUnit.SECONDS);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Writes a variable value to the Helios device\r\n+     *\r\n+     * @param variableName The variable name\r\n+     * @param value The new value\r\n+     * @return The value if the transaction succeeded, <tt>null</tt> otherwise\r\n+     * @throws HeliosException\r\n+     */\r\n+    public void writeValue(String variableName, String value) throws HeliosException {\r\n+        HeliosVariable v = this.vMap.get(variableName);\r\n+        if (!v.hasWriteAccess()) {\r\n+            throw new HeliosException(\"Variable \" + variableName + \" is read-only\");\r\n+        } else if (!v.isInAllowedRange(value)) {\r\n+            throw new HeliosException(\"Value \" + value + \" is outside of allowed range of variable \" + variableName);\r\n+        } else {\r\n+            // write to device\r\n+            String payload = v.getVariableString() + \"=\" + value;\r\n+            final Semaphore lock = transactionLocks.get(comms.getEndpoint());\r\n+            try {\r\n+                lock.acquire();\r\n+                this.comms.submitOneTimeWrite(new ModbusWriteRegisterRequestBlueprint(\r\n+                        HeliosEasyControlsBindingConstants.UNIT_ID, HeliosEasyControlsBindingConstants.START_ADDRESS,\r\n+                        new ModbusRegisterArray(preparePayload(payload)), true,\r\n+                        HeliosEasyControlsBindingConstants.MAX_TRIES), result -> {\r\n+                            lock.release();\r\n+                        }, failureCallback -> {\r\n+                            handleError(\"{} encountered error writing to device: {}\",\r\n+                                    failureCallback.getCause().getMessage(), lock);\r\n+                        });\r\n+                // ensure the openHAB item is updated with the device's actual value\r\n+                scheduler.schedule(new Runnable() {\r\n+                    @Override\r\n+                    public void run() {\r\n+                        try {\r\n+                            readValue(variableName);\r\n+                        } catch (HeliosException e) {\r\n+                            logger.error(\r\n+                                    \"{} encountered HeliosException when trying to read variable {} from the device after updating it: {}\",\r\n+                                    HeliosEasyControlsHandler.class.getSimpleName(), variableName, e.getMessage());\r\n+                        }\r\n+                    }\r\n+                }, 1, TimeUnit.SECONDS);\r\n+            } catch (Exception e) {\r\n+                logger.error(\r\n+                        \"{} encountered Exception when trying to lock Semaphore for writing variable {} to the device: {}\",\r\n+                        HeliosEasyControlsHandler.class.getSimpleName(), variableName, e.getMessage());\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Read a variable from the Helios device\r\n+     *\r\n+     * @param variableName The variable name\r\n+     * @return The value\r\n+     * @throws HeliosException\r", "originalCommit": "73d8f576a176edc1b7c8f90549169819e7d5e410", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAxNzA2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r465017067", "bodyText": "Please consider renaming the parameter... The lambda you are implementing is the callback, not the argument itself. Call it e.g. failureInfo", "author": "ssalonen", "createdAt": "2020-08-04T12:35:52Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,577 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    /**\r\n+     * Logger instance\r\n+     */\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    /**\r\n+     * Configuration instance\r\n+     */\r\n+    private HeliosEasyControlsConfiguration config;\r\n+\r\n+    /**\r\n+     * Used to poll the variables' status based on the configured refresh interval\r\n+     */\r\n+    private ScheduledFuture<?> pollingJob;\r\n+\r\n+    /**\r\n+     * The map holding the variable meta info by variable name\r\n+     */\r\n+    private Map<String, HeliosVariable> vMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private static ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore>();\r\n+\r\n+    /**\r\n+     * Communication interface to the endpoint\r\n+     */\r\n+    private ModbusCommunicationInterface comms;\r\n+\r\n+    /**\r\n+     * The date format used by the device\r\n+     */\r\n+    private int dateFormat = -1;\r\n+\r\n+    /**\r\n+     * Constructor\r\n+     *\r\n+     * @param thing\r\n+     * @param managerRef\r\n+     */\r\n+    public HeliosEasyControlsHandler(Thing thing) {\r\n+        super(thing);\r\n+    }\r\n+\r\n+    /**\r\n+     * Reads variable definitions from JSON file and store them in vMap\r\n+     */\r\n+    private void readVariableDefinition() {\r\n+        try {\r\n+            Gson gson = new Gson();\r\n+            Type vMapType = new TypeToken<Map<String, HeliosVariable>>() {\r\n+            }.getType();\r\n+            this.vMap = gson.fromJson(\r\n+                    new BufferedReader(new InputStreamReader(getClass()\r\n+                            .getResourceAsStream(HeliosEasyControlsBindingConstants.VARIABLES_DEFINITION_FILE))),\r\n+                    vMapType);\r\n+            // add the name to the variable itself\r\n+            for (Map.Entry<String, HeliosVariable> entry : this.vMap.entrySet()) {\r\n+                entry.getValue().setName(entry.getKey()); // workaround to set the variable name inside the\r\n+                                                          // HeliosVariable object\r\n+                if (!entry.getValue().isOk()) {\r\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\r\n+                            \"Variables definition file contains inconsistent data.\");\r\n+\r\n+                }\r\n+            }\r\n+        } catch (Exception e) {\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\r\n+                    \"Variables definition file not found or of illegal format.\");\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the endpoint handler from the bridge this handler is connected to\r\n+     * Checks that we're connected to the right type of bridge\r\n+     *\r\n+     * @return the endpoint handler or null if the bridge does not exist\r\n+     */\r\n+    private ModbusEndpointThingHandler getEndpointThingHandler() {\r\n+        Bridge bridge = getBridge();\r\n+        if (bridge == null) {\r\n+            logger.debug(\"Bridge is null\");\r\n+            return null;\r\n+        }\r\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\r\n+            logger.debug(\"Bridge is not online\");\r\n+            return null;\r\n+        }\r\n+\r\n+        ThingHandler handler = bridge.getHandler();\r\n+        if (handler == null) {\r\n+            logger.debug(\"Bridge handler is null\");\r\n+            return null;\r\n+        }\r\n+\r\n+        if (handler instanceof ModbusEndpointThingHandler) {\r\n+            return (ModbusEndpointThingHandler) handler;\r\n+        } else {\r\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\r\n+            return null;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get a reference to the modbus endpoint\r\n+     */\r\n+    private void connectEndpoint() {\r\n+        if (this.comms != null) {\r\n+            return;\r\n+        }\r\n+\r\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\r\n+        if (slaveEndpointThingHandler == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' is offline\", label));\r\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\r\n+            return;\r\n+        }\r\n+\r\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\r\n+\r\n+        if (comms == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\r\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\r\n+            return;\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void initialize() {\r\n+        this.config = getConfigAs(HeliosEasyControlsConfiguration.class);\r\n+        this.readVariableDefinition();\r\n+        this.connectEndpoint();\r\n+        if (this.comms != null) {\r\n+            HeliosEasyControlsHandler.transactionLocks.putIfAbsent(this.comms.getEndpoint(), new Semaphore(1, true));\r\n+            updateStatus(ThingStatus.UNKNOWN);\r\n+\r\n+            // background initialization\r\n+            scheduler.execute(() -> {\r\n+                try {\r\n+                    readValue(HeliosEasyControlsBindingConstants.DATE_FORMAT);\r\n+                    // status will be updated to ONLINE by the read callback function\r\n+                } catch (HeliosException e) {\r\n+                    logger.error(e.getMessage());\r\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\r\n+                }\r\n+            });\r\n+\r\n+            // poll for status updates regularly\r\n+            Runnable runnable = new Runnable() {\r\n+\r\n+                @Override\r\n+                public void run() {\r\n+                    for (Map.Entry<String, HeliosVariable> entry : vMap.entrySet()) {\r\n+                        if (isLinked(entry.getKey())\r\n+                                || (entry.getKey().equals(HeliosEasyControlsBindingConstants.DATE_FORMAT))) {\r\n+                            try {\r\n+                                readValue(entry.getKey());\r\n+                            } catch (HeliosException e) {\r\n+                                logger.error(e.getMessage());\r\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\r\n+                                        e.getMessage());\r\n+                            }\r\n+                        }\r\n+                    }\r\n+                }\r\n+            };\r\n+            this.pollingJob = scheduler.scheduleAtFixedRate(runnable, config.getRefreshInterval(),\r\n+                    config.getRefreshInterval(), TimeUnit.MILLISECONDS);\r\n+\r\n+        } else {\r\n+            logger.error(\"Modbus endpoint is null.\");\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void dispose() {\r\n+        if (this.pollingJob != null) {\r\n+            this.pollingJob.cancel(true);\r\n+        }\r\n+        this.comms = null;\r\n+    }\r\n+\r\n+    @Override\r\n+    public void handleCommand(ChannelUID channelUID, Command command) {\r\n+        String channelId = channelUID.getId();\r\n+        if (command instanceof RefreshType) {\r\n+            scheduler.schedule(new Runnable() {\r\n+                @Override\r\n+                public void run() {\r\n+                    try {\r\n+                        readValue(channelId);\r\n+                    } catch (HeliosException e) {\r\n+                        logger.error(e.getMessage());\r\n+                    }\r\n+                }\r\n+            }, 0, TimeUnit.SECONDS);\r\n+        } else { // write command\r\n+            String value;\r\n+            if (command instanceof OnOffType) {\r\n+                value = command == OnOffType.ON ? \"1\" : \"0\";\r\n+            } else if (command instanceof DateTimeType) {\r\n+                value = formatDate(channelId, ((DateTimeType) command).getZonedDateTime());\r\n+            } else { // Number or String\r\n+                value = command.toString();\r\n+            }\r\n+            scheduler.schedule(new Runnable() {\r\n+                @Override\r\n+                public void run() {\r\n+                    try {\r\n+                        writeValue(channelId, value);\r\n+                    } catch (HeliosException e) {\r\n+                        logger.error(e.getMessage());\r\n+                    }\r\n+                }\r\n+            }, 0, TimeUnit.SECONDS);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Writes a variable value to the Helios device\r\n+     *\r\n+     * @param variableName The variable name\r\n+     * @param value The new value\r\n+     * @return The value if the transaction succeeded, <tt>null</tt> otherwise\r\n+     * @throws HeliosException\r\n+     */\r\n+    public void writeValue(String variableName, String value) throws HeliosException {\r\n+        HeliosVariable v = this.vMap.get(variableName);\r\n+        if (!v.hasWriteAccess()) {\r\n+            throw new HeliosException(\"Variable \" + variableName + \" is read-only\");\r\n+        } else if (!v.isInAllowedRange(value)) {\r\n+            throw new HeliosException(\"Value \" + value + \" is outside of allowed range of variable \" + variableName);\r\n+        } else {\r\n+            // write to device\r\n+            String payload = v.getVariableString() + \"=\" + value;\r\n+            final Semaphore lock = transactionLocks.get(comms.getEndpoint());\r\n+            try {\r\n+                lock.acquire();\r\n+                this.comms.submitOneTimeWrite(new ModbusWriteRegisterRequestBlueprint(\r\n+                        HeliosEasyControlsBindingConstants.UNIT_ID, HeliosEasyControlsBindingConstants.START_ADDRESS,\r\n+                        new ModbusRegisterArray(preparePayload(payload)), true,\r\n+                        HeliosEasyControlsBindingConstants.MAX_TRIES), result -> {\r\n+                            lock.release();\r\n+                        }, failureCallback -> {\r\n+                            handleError(\"{} encountered error writing to device: {}\",\r\n+                                    failureCallback.getCause().getMessage(), lock);\r\n+                        });\r\n+                // ensure the openHAB item is updated with the device's actual value\r\n+                scheduler.schedule(new Runnable() {\r\n+                    @Override\r\n+                    public void run() {\r\n+                        try {\r\n+                            readValue(variableName);\r\n+                        } catch (HeliosException e) {\r\n+                            logger.error(\r\n+                                    \"{} encountered HeliosException when trying to read variable {} from the device after updating it: {}\",\r\n+                                    HeliosEasyControlsHandler.class.getSimpleName(), variableName, e.getMessage());\r\n+                        }\r\n+                    }\r\n+                }, 1, TimeUnit.SECONDS);\r\n+            } catch (Exception e) {\r\n+                logger.error(\r\n+                        \"{} encountered Exception when trying to lock Semaphore for writing variable {} to the device: {}\",\r\n+                        HeliosEasyControlsHandler.class.getSimpleName(), variableName, e.getMessage());\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Read a variable from the Helios device\r\n+     *\r\n+     * @param variableName The variable name\r\n+     * @return The value\r\n+     * @throws HeliosException\r\n+     */\r\n+    public void readValue(String variableName) throws HeliosException {\r\n+        final Semaphore lock = transactionLocks.get(comms.getEndpoint());\r\n+        HeliosVariable v = this.vMap.get(variableName);\r\n+        if (v.hasReadAccess()) {\r\n+            try {\r\n+                lock.acquire(); // will block until lock is available\r\n+            } catch (InterruptedException e) {\r\n+                logger.error(\"{} encountered Exception when trying to read variable {} from the device: {}\",\r\n+                        HeliosEasyControlsHandler.class.getSimpleName(), variableName, e.getMessage());\r\n+                return;\r\n+            }\r\n+            // write variable name to register\r\n+            String payload = v.getVariableString();\r\n+            this.comms.submitOneTimeWrite(new ModbusWriteRegisterRequestBlueprint(\r\n+                    HeliosEasyControlsBindingConstants.UNIT_ID, HeliosEasyControlsBindingConstants.START_ADDRESS,\r\n+                    new ModbusRegisterArray(preparePayload(payload)), true,\r\n+                    HeliosEasyControlsBindingConstants.MAX_TRIES), result -> {\r\n+                        this.comms.submitOneTimePoll(\r\n+                                new ModbusReadRequestBlueprint(HeliosEasyControlsBindingConstants.UNIT_ID,\r\n+                                        ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS,\r\n+                                        HeliosEasyControlsBindingConstants.START_ADDRESS, v.getCount(),\r\n+                                        HeliosEasyControlsBindingConstants.MAX_TRIES),\r\n+                                pollResult -> {\r\n+                                    lock.release();\r\n+                                    Optional<ModbusRegisterArray> registers = (Optional<ModbusRegisterArray>) pollResult\r\n+                                            .getRegisters();\r\n+                                    if (registers.isPresent()) {\r\n+                                        processResponse(v, registers.get());\r\n+                                    }\r\n+                                }, failureCallback -> {\r\n+                                    handleError(\"{} encountered error reading from device: {}\",\r\n+                                            failureCallback.getCause().getMessage(), lock);\r\n+                                });\r\n+                    }, failureCallback -> {\r", "originalCommit": "73d8f576a176edc1b7c8f90549169819e7d5e410", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAxODQ0OA==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r465018448", "bodyText": "How do you want to handle the timezones? For example, should the binding write dates as UTC to the device?\nIf I understood correctly, the current implementation ignores the time zone all together", "author": "ssalonen", "createdAt": "2020-08-04T12:38:24Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,577 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    /**\r\n+     * Logger instance\r\n+     */\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    /**\r\n+     * Configuration instance\r\n+     */\r\n+    private HeliosEasyControlsConfiguration config;\r\n+\r\n+    /**\r\n+     * Used to poll the variables' status based on the configured refresh interval\r\n+     */\r\n+    private ScheduledFuture<?> pollingJob;\r\n+\r\n+    /**\r\n+     * The map holding the variable meta info by variable name\r\n+     */\r\n+    private Map<String, HeliosVariable> vMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private static ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore>();\r\n+\r\n+    /**\r\n+     * Communication interface to the endpoint\r\n+     */\r\n+    private ModbusCommunicationInterface comms;\r\n+\r\n+    /**\r\n+     * The date format used by the device\r\n+     */\r\n+    private int dateFormat = -1;\r\n+\r\n+    /**\r\n+     * Constructor\r\n+     *\r\n+     * @param thing\r\n+     * @param managerRef\r\n+     */\r\n+    public HeliosEasyControlsHandler(Thing thing) {\r\n+        super(thing);\r\n+    }\r\n+\r\n+    /**\r\n+     * Reads variable definitions from JSON file and store them in vMap\r\n+     */\r\n+    private void readVariableDefinition() {\r\n+        try {\r\n+            Gson gson = new Gson();\r\n+            Type vMapType = new TypeToken<Map<String, HeliosVariable>>() {\r\n+            }.getType();\r\n+            this.vMap = gson.fromJson(\r\n+                    new BufferedReader(new InputStreamReader(getClass()\r\n+                            .getResourceAsStream(HeliosEasyControlsBindingConstants.VARIABLES_DEFINITION_FILE))),\r\n+                    vMapType);\r\n+            // add the name to the variable itself\r\n+            for (Map.Entry<String, HeliosVariable> entry : this.vMap.entrySet()) {\r\n+                entry.getValue().setName(entry.getKey()); // workaround to set the variable name inside the\r\n+                                                          // HeliosVariable object\r\n+                if (!entry.getValue().isOk()) {\r\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\r\n+                            \"Variables definition file contains inconsistent data.\");\r\n+\r\n+                }\r\n+            }\r\n+        } catch (Exception e) {\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\r\n+                    \"Variables definition file not found or of illegal format.\");\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the endpoint handler from the bridge this handler is connected to\r\n+     * Checks that we're connected to the right type of bridge\r\n+     *\r\n+     * @return the endpoint handler or null if the bridge does not exist\r\n+     */\r\n+    private ModbusEndpointThingHandler getEndpointThingHandler() {\r\n+        Bridge bridge = getBridge();\r\n+        if (bridge == null) {\r\n+            logger.debug(\"Bridge is null\");\r\n+            return null;\r\n+        }\r\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\r\n+            logger.debug(\"Bridge is not online\");\r\n+            return null;\r\n+        }\r\n+\r\n+        ThingHandler handler = bridge.getHandler();\r\n+        if (handler == null) {\r\n+            logger.debug(\"Bridge handler is null\");\r\n+            return null;\r\n+        }\r\n+\r\n+        if (handler instanceof ModbusEndpointThingHandler) {\r\n+            return (ModbusEndpointThingHandler) handler;\r\n+        } else {\r\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\r\n+            return null;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get a reference to the modbus endpoint\r\n+     */\r\n+    private void connectEndpoint() {\r\n+        if (this.comms != null) {\r\n+            return;\r\n+        }\r\n+\r\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\r\n+        if (slaveEndpointThingHandler == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' is offline\", label));\r\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\r\n+            return;\r\n+        }\r\n+\r\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\r\n+\r\n+        if (comms == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\r\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\r\n+            return;\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void initialize() {\r\n+        this.config = getConfigAs(HeliosEasyControlsConfiguration.class);\r\n+        this.readVariableDefinition();\r\n+        this.connectEndpoint();\r\n+        if (this.comms != null) {\r\n+            HeliosEasyControlsHandler.transactionLocks.putIfAbsent(this.comms.getEndpoint(), new Semaphore(1, true));\r\n+            updateStatus(ThingStatus.UNKNOWN);\r\n+\r\n+            // background initialization\r\n+            scheduler.execute(() -> {\r\n+                try {\r\n+                    readValue(HeliosEasyControlsBindingConstants.DATE_FORMAT);\r\n+                    // status will be updated to ONLINE by the read callback function\r\n+                } catch (HeliosException e) {\r\n+                    logger.error(e.getMessage());\r\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\r\n+                }\r\n+            });\r\n+\r\n+            // poll for status updates regularly\r\n+            Runnable runnable = new Runnable() {\r\n+\r\n+                @Override\r\n+                public void run() {\r\n+                    for (Map.Entry<String, HeliosVariable> entry : vMap.entrySet()) {\r\n+                        if (isLinked(entry.getKey())\r\n+                                || (entry.getKey().equals(HeliosEasyControlsBindingConstants.DATE_FORMAT))) {\r\n+                            try {\r\n+                                readValue(entry.getKey());\r\n+                            } catch (HeliosException e) {\r\n+                                logger.error(e.getMessage());\r\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\r\n+                                        e.getMessage());\r\n+                            }\r\n+                        }\r\n+                    }\r\n+                }\r\n+            };\r\n+            this.pollingJob = scheduler.scheduleAtFixedRate(runnable, config.getRefreshInterval(),\r\n+                    config.getRefreshInterval(), TimeUnit.MILLISECONDS);\r\n+\r\n+        } else {\r\n+            logger.error(\"Modbus endpoint is null.\");\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void dispose() {\r\n+        if (this.pollingJob != null) {\r\n+            this.pollingJob.cancel(true);\r\n+        }\r\n+        this.comms = null;\r\n+    }\r\n+\r\n+    @Override\r\n+    public void handleCommand(ChannelUID channelUID, Command command) {\r\n+        String channelId = channelUID.getId();\r\n+        if (command instanceof RefreshType) {\r\n+            scheduler.schedule(new Runnable() {\r\n+                @Override\r\n+                public void run() {\r\n+                    try {\r\n+                        readValue(channelId);\r\n+                    } catch (HeliosException e) {\r\n+                        logger.error(e.getMessage());\r\n+                    }\r\n+                }\r\n+            }, 0, TimeUnit.SECONDS);\r\n+        } else { // write command\r\n+            String value;\r\n+            if (command instanceof OnOffType) {\r\n+                value = command == OnOffType.ON ? \"1\" : \"0\";\r\n+            } else if (command instanceof DateTimeType) {\r\n+                value = formatDate(channelId, ((DateTimeType) command).getZonedDateTime());\r\n+            } else { // Number or String\r\n+                value = command.toString();\r\n+            }\r\n+            scheduler.schedule(new Runnable() {\r\n+                @Override\r\n+                public void run() {\r\n+                    try {\r\n+                        writeValue(channelId, value);\r\n+                    } catch (HeliosException e) {\r\n+                        logger.error(e.getMessage());\r\n+                    }\r\n+                }\r\n+            }, 0, TimeUnit.SECONDS);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Writes a variable value to the Helios device\r\n+     *\r\n+     * @param variableName The variable name\r\n+     * @param value The new value\r\n+     * @return The value if the transaction succeeded, <tt>null</tt> otherwise\r\n+     * @throws HeliosException\r\n+     */\r\n+    public void writeValue(String variableName, String value) throws HeliosException {\r\n+        HeliosVariable v = this.vMap.get(variableName);\r\n+        if (!v.hasWriteAccess()) {\r\n+            throw new HeliosException(\"Variable \" + variableName + \" is read-only\");\r\n+        } else if (!v.isInAllowedRange(value)) {\r\n+            throw new HeliosException(\"Value \" + value + \" is outside of allowed range of variable \" + variableName);\r\n+        } else {\r\n+            // write to device\r\n+            String payload = v.getVariableString() + \"=\" + value;\r\n+            final Semaphore lock = transactionLocks.get(comms.getEndpoint());\r\n+            try {\r\n+                lock.acquire();\r\n+                this.comms.submitOneTimeWrite(new ModbusWriteRegisterRequestBlueprint(\r\n+                        HeliosEasyControlsBindingConstants.UNIT_ID, HeliosEasyControlsBindingConstants.START_ADDRESS,\r\n+                        new ModbusRegisterArray(preparePayload(payload)), true,\r\n+                        HeliosEasyControlsBindingConstants.MAX_TRIES), result -> {\r\n+                            lock.release();\r\n+                        }, failureCallback -> {\r\n+                            handleError(\"{} encountered error writing to device: {}\",\r\n+                                    failureCallback.getCause().getMessage(), lock);\r\n+                        });\r\n+                // ensure the openHAB item is updated with the device's actual value\r\n+                scheduler.schedule(new Runnable() {\r\n+                    @Override\r\n+                    public void run() {\r\n+                        try {\r\n+                            readValue(variableName);\r\n+                        } catch (HeliosException e) {\r\n+                            logger.error(\r\n+                                    \"{} encountered HeliosException when trying to read variable {} from the device after updating it: {}\",\r\n+                                    HeliosEasyControlsHandler.class.getSimpleName(), variableName, e.getMessage());\r\n+                        }\r\n+                    }\r\n+                }, 1, TimeUnit.SECONDS);\r\n+            } catch (Exception e) {\r\n+                logger.error(\r\n+                        \"{} encountered Exception when trying to lock Semaphore for writing variable {} to the device: {}\",\r\n+                        HeliosEasyControlsHandler.class.getSimpleName(), variableName, e.getMessage());\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Read a variable from the Helios device\r\n+     *\r\n+     * @param variableName The variable name\r\n+     * @return The value\r\n+     * @throws HeliosException\r\n+     */\r\n+    public void readValue(String variableName) throws HeliosException {\r\n+        final Semaphore lock = transactionLocks.get(comms.getEndpoint());\r\n+        HeliosVariable v = this.vMap.get(variableName);\r\n+        if (v.hasReadAccess()) {\r\n+            try {\r\n+                lock.acquire(); // will block until lock is available\r\n+            } catch (InterruptedException e) {\r\n+                logger.error(\"{} encountered Exception when trying to read variable {} from the device: {}\",\r\n+                        HeliosEasyControlsHandler.class.getSimpleName(), variableName, e.getMessage());\r\n+                return;\r\n+            }\r\n+            // write variable name to register\r\n+            String payload = v.getVariableString();\r\n+            this.comms.submitOneTimeWrite(new ModbusWriteRegisterRequestBlueprint(\r\n+                    HeliosEasyControlsBindingConstants.UNIT_ID, HeliosEasyControlsBindingConstants.START_ADDRESS,\r\n+                    new ModbusRegisterArray(preparePayload(payload)), true,\r\n+                    HeliosEasyControlsBindingConstants.MAX_TRIES), result -> {\r\n+                        this.comms.submitOneTimePoll(\r\n+                                new ModbusReadRequestBlueprint(HeliosEasyControlsBindingConstants.UNIT_ID,\r\n+                                        ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS,\r\n+                                        HeliosEasyControlsBindingConstants.START_ADDRESS, v.getCount(),\r\n+                                        HeliosEasyControlsBindingConstants.MAX_TRIES),\r\n+                                pollResult -> {\r\n+                                    lock.release();\r\n+                                    Optional<ModbusRegisterArray> registers = (Optional<ModbusRegisterArray>) pollResult\r\n+                                            .getRegisters();\r\n+                                    if (registers.isPresent()) {\r\n+                                        processResponse(v, registers.get());\r\n+                                    }\r\n+                                }, failureCallback -> {\r\n+                                    handleError(\"{} encountered error reading from device: {}\",\r\n+                                            failureCallback.getCause().getMessage(), lock);\r\n+                                });\r\n+                    }, failureCallback -> {\r\n+                        handleError(\"{} encountered error writing to device: {}\",\r\n+                                failureCallback.getCause().getMessage(), lock);\r\n+                    });\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Formats the provided date to a string in the device's configured date format\r\n+     *\r\n+     * @param date the date to be formatted\r\n+     * @return a string in the device's configured date format\r\n+     */\r\n+    private String formatDate(String variableName, ZonedDateTime date) {\r", "originalCommit": "73d8f576a176edc1b7c8f90549169819e7d5e410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI5NzcyMA==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r465297720", "bodyText": "The device has separate variables for date and time as well as for the difference to GMT / UTC.\nThis method only takes care of the date part.\nI'm not sure it's actually necessary to consider the time zone here - do you think there is a use case for this?", "author": "bern77", "createdAt": "2020-08-04T20:01:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAxODQ0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU0MDA4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r465540085", "bodyText": "Yes, when writing ZonedDateTime it can be in whatever timezone really. E.g. If it comes from persistence, the time zone might be UTC or might be local, dependending on implementation details.\nWhat should matter is the instant represented by the object.\nIt would be a different story if we would be dealing with \"naive\" datetime objects which does not have a concept of timezone.\nTwo approaches come to mind:\n\nwrite both the timezone and time part. One could convert ZonedDateTime to local time zone first to avoid any funny time zones ending up to the device\nconvert ZonedDateTime to local time zone (system default), ignore the timezone and write only the time part\n\nWhat do you think?", "author": "ssalonen", "createdAt": "2020-08-05T07:51:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAxODQ0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU0NTE3OA==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r465545178", "bodyText": "I guess you could also read the timezone of the device and convert ZonedDateTime to that", "author": "ssalonen", "createdAt": "2020-08-05T08:00:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAxODQ0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI4MTIyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r491281229", "bodyText": "@bern77 did you find some goo way to resolve this?", "author": "ssalonen", "createdAt": "2020-09-19T05:58:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAxODQ0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI4ODYwMA==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r491288600", "bodyText": "I think so, I'm now using a single DateTime item and set all 3 paramets (date, time and GMT offset) in one go.\nAlso, I've added an Action to set the device's system time to the server system time.", "author": "bern77", "createdAt": "2020-09-19T06:21:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAxODQ0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAyMjU1NA==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r465022554", "bodyText": "This is now assuming system default timezone... Is that what you want?", "author": "ssalonen", "createdAt": "2020-08-04T12:45:22Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,577 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    /**\r\n+     * Logger instance\r\n+     */\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    /**\r\n+     * Configuration instance\r\n+     */\r\n+    private HeliosEasyControlsConfiguration config;\r\n+\r\n+    /**\r\n+     * Used to poll the variables' status based on the configured refresh interval\r\n+     */\r\n+    private ScheduledFuture<?> pollingJob;\r\n+\r\n+    /**\r\n+     * The map holding the variable meta info by variable name\r\n+     */\r\n+    private Map<String, HeliosVariable> vMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private static ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore>();\r\n+\r\n+    /**\r\n+     * Communication interface to the endpoint\r\n+     */\r\n+    private ModbusCommunicationInterface comms;\r\n+\r\n+    /**\r\n+     * The date format used by the device\r\n+     */\r\n+    private int dateFormat = -1;\r\n+\r\n+    /**\r\n+     * Constructor\r\n+     *\r\n+     * @param thing\r\n+     * @param managerRef\r\n+     */\r\n+    public HeliosEasyControlsHandler(Thing thing) {\r\n+        super(thing);\r\n+    }\r\n+\r\n+    /**\r\n+     * Reads variable definitions from JSON file and store them in vMap\r\n+     */\r\n+    private void readVariableDefinition() {\r\n+        try {\r\n+            Gson gson = new Gson();\r\n+            Type vMapType = new TypeToken<Map<String, HeliosVariable>>() {\r\n+            }.getType();\r\n+            this.vMap = gson.fromJson(\r\n+                    new BufferedReader(new InputStreamReader(getClass()\r\n+                            .getResourceAsStream(HeliosEasyControlsBindingConstants.VARIABLES_DEFINITION_FILE))),\r\n+                    vMapType);\r\n+            // add the name to the variable itself\r\n+            for (Map.Entry<String, HeliosVariable> entry : this.vMap.entrySet()) {\r\n+                entry.getValue().setName(entry.getKey()); // workaround to set the variable name inside the\r\n+                                                          // HeliosVariable object\r\n+                if (!entry.getValue().isOk()) {\r\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\r\n+                            \"Variables definition file contains inconsistent data.\");\r\n+\r\n+                }\r\n+            }\r\n+        } catch (Exception e) {\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\r\n+                    \"Variables definition file not found or of illegal format.\");\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the endpoint handler from the bridge this handler is connected to\r\n+     * Checks that we're connected to the right type of bridge\r\n+     *\r\n+     * @return the endpoint handler or null if the bridge does not exist\r\n+     */\r\n+    private ModbusEndpointThingHandler getEndpointThingHandler() {\r\n+        Bridge bridge = getBridge();\r\n+        if (bridge == null) {\r\n+            logger.debug(\"Bridge is null\");\r\n+            return null;\r\n+        }\r\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\r\n+            logger.debug(\"Bridge is not online\");\r\n+            return null;\r\n+        }\r\n+\r\n+        ThingHandler handler = bridge.getHandler();\r\n+        if (handler == null) {\r\n+            logger.debug(\"Bridge handler is null\");\r\n+            return null;\r\n+        }\r\n+\r\n+        if (handler instanceof ModbusEndpointThingHandler) {\r\n+            return (ModbusEndpointThingHandler) handler;\r\n+        } else {\r\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\r\n+            return null;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get a reference to the modbus endpoint\r\n+     */\r\n+    private void connectEndpoint() {\r\n+        if (this.comms != null) {\r\n+            return;\r\n+        }\r\n+\r\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\r\n+        if (slaveEndpointThingHandler == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' is offline\", label));\r\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\r\n+            return;\r\n+        }\r\n+\r\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\r\n+\r\n+        if (comms == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\r\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\r\n+            return;\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void initialize() {\r\n+        this.config = getConfigAs(HeliosEasyControlsConfiguration.class);\r\n+        this.readVariableDefinition();\r\n+        this.connectEndpoint();\r\n+        if (this.comms != null) {\r\n+            HeliosEasyControlsHandler.transactionLocks.putIfAbsent(this.comms.getEndpoint(), new Semaphore(1, true));\r\n+            updateStatus(ThingStatus.UNKNOWN);\r\n+\r\n+            // background initialization\r\n+            scheduler.execute(() -> {\r\n+                try {\r\n+                    readValue(HeliosEasyControlsBindingConstants.DATE_FORMAT);\r\n+                    // status will be updated to ONLINE by the read callback function\r\n+                } catch (HeliosException e) {\r\n+                    logger.error(e.getMessage());\r\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\r\n+                }\r\n+            });\r\n+\r\n+            // poll for status updates regularly\r\n+            Runnable runnable = new Runnable() {\r\n+\r\n+                @Override\r\n+                public void run() {\r\n+                    for (Map.Entry<String, HeliosVariable> entry : vMap.entrySet()) {\r\n+                        if (isLinked(entry.getKey())\r\n+                                || (entry.getKey().equals(HeliosEasyControlsBindingConstants.DATE_FORMAT))) {\r\n+                            try {\r\n+                                readValue(entry.getKey());\r\n+                            } catch (HeliosException e) {\r\n+                                logger.error(e.getMessage());\r\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\r\n+                                        e.getMessage());\r\n+                            }\r\n+                        }\r\n+                    }\r\n+                }\r\n+            };\r\n+            this.pollingJob = scheduler.scheduleAtFixedRate(runnable, config.getRefreshInterval(),\r\n+                    config.getRefreshInterval(), TimeUnit.MILLISECONDS);\r\n+\r\n+        } else {\r\n+            logger.error(\"Modbus endpoint is null.\");\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void dispose() {\r\n+        if (this.pollingJob != null) {\r\n+            this.pollingJob.cancel(true);\r\n+        }\r\n+        this.comms = null;\r\n+    }\r\n+\r\n+    @Override\r\n+    public void handleCommand(ChannelUID channelUID, Command command) {\r\n+        String channelId = channelUID.getId();\r\n+        if (command instanceof RefreshType) {\r\n+            scheduler.schedule(new Runnable() {\r\n+                @Override\r\n+                public void run() {\r\n+                    try {\r\n+                        readValue(channelId);\r\n+                    } catch (HeliosException e) {\r\n+                        logger.error(e.getMessage());\r\n+                    }\r\n+                }\r\n+            }, 0, TimeUnit.SECONDS);\r\n+        } else { // write command\r\n+            String value;\r\n+            if (command instanceof OnOffType) {\r\n+                value = command == OnOffType.ON ? \"1\" : \"0\";\r\n+            } else if (command instanceof DateTimeType) {\r\n+                value = formatDate(channelId, ((DateTimeType) command).getZonedDateTime());\r\n+            } else { // Number or String\r\n+                value = command.toString();\r\n+            }\r\n+            scheduler.schedule(new Runnable() {\r\n+                @Override\r\n+                public void run() {\r\n+                    try {\r\n+                        writeValue(channelId, value);\r\n+                    } catch (HeliosException e) {\r\n+                        logger.error(e.getMessage());\r\n+                    }\r\n+                }\r\n+            }, 0, TimeUnit.SECONDS);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Writes a variable value to the Helios device\r\n+     *\r\n+     * @param variableName The variable name\r\n+     * @param value The new value\r\n+     * @return The value if the transaction succeeded, <tt>null</tt> otherwise\r\n+     * @throws HeliosException\r\n+     */\r\n+    public void writeValue(String variableName, String value) throws HeliosException {\r\n+        HeliosVariable v = this.vMap.get(variableName);\r\n+        if (!v.hasWriteAccess()) {\r\n+            throw new HeliosException(\"Variable \" + variableName + \" is read-only\");\r\n+        } else if (!v.isInAllowedRange(value)) {\r\n+            throw new HeliosException(\"Value \" + value + \" is outside of allowed range of variable \" + variableName);\r\n+        } else {\r\n+            // write to device\r\n+            String payload = v.getVariableString() + \"=\" + value;\r\n+            final Semaphore lock = transactionLocks.get(comms.getEndpoint());\r\n+            try {\r\n+                lock.acquire();\r\n+                this.comms.submitOneTimeWrite(new ModbusWriteRegisterRequestBlueprint(\r\n+                        HeliosEasyControlsBindingConstants.UNIT_ID, HeliosEasyControlsBindingConstants.START_ADDRESS,\r\n+                        new ModbusRegisterArray(preparePayload(payload)), true,\r\n+                        HeliosEasyControlsBindingConstants.MAX_TRIES), result -> {\r\n+                            lock.release();\r\n+                        }, failureCallback -> {\r\n+                            handleError(\"{} encountered error writing to device: {}\",\r\n+                                    failureCallback.getCause().getMessage(), lock);\r\n+                        });\r\n+                // ensure the openHAB item is updated with the device's actual value\r\n+                scheduler.schedule(new Runnable() {\r\n+                    @Override\r\n+                    public void run() {\r\n+                        try {\r\n+                            readValue(variableName);\r\n+                        } catch (HeliosException e) {\r\n+                            logger.error(\r\n+                                    \"{} encountered HeliosException when trying to read variable {} from the device after updating it: {}\",\r\n+                                    HeliosEasyControlsHandler.class.getSimpleName(), variableName, e.getMessage());\r\n+                        }\r\n+                    }\r\n+                }, 1, TimeUnit.SECONDS);\r\n+            } catch (Exception e) {\r\n+                logger.error(\r\n+                        \"{} encountered Exception when trying to lock Semaphore for writing variable {} to the device: {}\",\r\n+                        HeliosEasyControlsHandler.class.getSimpleName(), variableName, e.getMessage());\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Read a variable from the Helios device\r\n+     *\r\n+     * @param variableName The variable name\r\n+     * @return The value\r\n+     * @throws HeliosException\r\n+     */\r\n+    public void readValue(String variableName) throws HeliosException {\r\n+        final Semaphore lock = transactionLocks.get(comms.getEndpoint());\r\n+        HeliosVariable v = this.vMap.get(variableName);\r\n+        if (v.hasReadAccess()) {\r\n+            try {\r\n+                lock.acquire(); // will block until lock is available\r\n+            } catch (InterruptedException e) {\r\n+                logger.error(\"{} encountered Exception when trying to read variable {} from the device: {}\",\r\n+                        HeliosEasyControlsHandler.class.getSimpleName(), variableName, e.getMessage());\r\n+                return;\r\n+            }\r\n+            // write variable name to register\r\n+            String payload = v.getVariableString();\r\n+            this.comms.submitOneTimeWrite(new ModbusWriteRegisterRequestBlueprint(\r\n+                    HeliosEasyControlsBindingConstants.UNIT_ID, HeliosEasyControlsBindingConstants.START_ADDRESS,\r\n+                    new ModbusRegisterArray(preparePayload(payload)), true,\r\n+                    HeliosEasyControlsBindingConstants.MAX_TRIES), result -> {\r\n+                        this.comms.submitOneTimePoll(\r\n+                                new ModbusReadRequestBlueprint(HeliosEasyControlsBindingConstants.UNIT_ID,\r\n+                                        ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS,\r\n+                                        HeliosEasyControlsBindingConstants.START_ADDRESS, v.getCount(),\r\n+                                        HeliosEasyControlsBindingConstants.MAX_TRIES),\r\n+                                pollResult -> {\r\n+                                    lock.release();\r\n+                                    Optional<ModbusRegisterArray> registers = (Optional<ModbusRegisterArray>) pollResult\r\n+                                            .getRegisters();\r\n+                                    if (registers.isPresent()) {\r\n+                                        processResponse(v, registers.get());\r\n+                                    }\r\n+                                }, failureCallback -> {\r\n+                                    handleError(\"{} encountered error reading from device: {}\",\r\n+                                            failureCallback.getCause().getMessage(), lock);\r\n+                                });\r\n+                    }, failureCallback -> {\r\n+                        handleError(\"{} encountered error writing to device: {}\",\r\n+                                failureCallback.getCause().getMessage(), lock);\r\n+                    });\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Formats the provided date to a string in the device's configured date format\r\n+     *\r\n+     * @param date the date to be formatted\r\n+     * @return a string in the device's configured date format\r\n+     */\r\n+    private String formatDate(String variableName, ZonedDateTime date) {\r\n+        String y = Integer.toString(date.getYear());\r\n+        String m = Integer.toString(date.getMonthValue());\r\n+        if (m.length() == 1) {\r\n+            m = \"0\" + m;\r\n+        }\r\n+        String d = Integer.toString(date.getDayOfMonth());\r\n+        if (d.length() == 1) {\r\n+            d = \"0\" + d;\r\n+        }\r\n+        if (variableName.equals(HeliosEasyControlsBindingConstants.DATE)) { // fixed format for writing the system date\r\n+            return d + \".\" + m + \".\" + y;\r\n+        } else {\r\n+            switch (this.dateFormat) {\r\n+                case 0: // dd.mm.yyyy\r\n+                    return d + \".\" + m + \".\" + y;\r\n+                case 1: // mm.dd.yyyy\r\n+                    return m + \".\" + d + \".\" + y;\r\n+                case 2: // yyyy.mm.dd\r\n+                    return y + \".\" + m + \".\" + d;\r\n+                default:\r\n+                    return d + \".\" + m + \".\" + y;\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns a DateTimeType object based on the provided String and the device's configured date format\r\n+     *\r\n+     * @param date The date string read from the device\r\n+     * @return A DateTimeType object representing the date or time specified\r\n+     */\r\n+    private DateTimeType toDateTime(String date) {\r\n+        String[] dateTimeParts = null;\r\n+        String dateTime = date;\r\n+        try { // date\r\n+            dateTimeParts = date.split(\"\\\\.\"); // try to split date components\r\n+            if (dateTimeParts.length == 1) { // time\r\n+                return DateTimeType.valueOf(date);\r\n+            } else { // date - we'll try the device's date format\r\n+                switch (this.dateFormat) {\r\n+                    case 0: // dd.mm.yyyy\r\n+                        dateTime = dateTimeParts[2] + \"-\" + dateTimeParts[1] + \"-\" + dateTimeParts[0];\r\n+                        break;\r\n+                    case 1: // mm.dd.yyyy\r\n+                        dateTime = dateTimeParts[2] + \"-\" + dateTimeParts[0] + \"-\" + dateTimeParts[1];\r\n+                        break;\r\n+                    case 2: // yyyy.mm.dd\r\n+                        dateTime = dateTimeParts[0] + \"-\" + dateTimeParts[1] + \"-\" + dateTimeParts[2];\r\n+                        break;\r\n+                    default:\r\n+                        dateTime = dateTimeParts[2] + \"-\" + dateTimeParts[1] + \"-\" + dateTimeParts[0];\r\n+                        break;\r\n+                }\r\n+                return DateTimeType.valueOf(dateTime);\r", "originalCommit": "73d8f576a176edc1b7c8f90549169819e7d5e410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMwMDA5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r465300092", "bodyText": "Here dateTime would only contain a date, no time information. So I think it should be fine.\nSee above - the protocol spec splits up date and time into different variables... so I believe the current implementation should be fine.\nIt would be more elegant though if I created a method to set date, time and difference to UTC at the same time...", "author": "bern77", "createdAt": "2020-08-04T20:06:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAyMjU1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI4MTU0NA==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r491281544", "bodyText": "Did you find some good resolution here @bern77 ?\nEven the date part depends on timezone as we know..", "author": "ssalonen", "createdAt": "2020-09-19T05:58:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAyMjU1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI4OTA1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r491289053", "bodyText": "see above, should be OK now :)", "author": "bern77", "createdAt": "2020-09-19T06:22:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAyMjU1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAyNDU1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r465024559", "bodyText": "Provide appropriate charset explicitly, e.g. StandardCharsets.US_ASCII or StandardCharsets.UTF8", "author": "ssalonen", "createdAt": "2020-08-04T12:48:49Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,577 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    /**\r\n+     * Logger instance\r\n+     */\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    /**\r\n+     * Configuration instance\r\n+     */\r\n+    private HeliosEasyControlsConfiguration config;\r\n+\r\n+    /**\r\n+     * Used to poll the variables' status based on the configured refresh interval\r\n+     */\r\n+    private ScheduledFuture<?> pollingJob;\r\n+\r\n+    /**\r\n+     * The map holding the variable meta info by variable name\r\n+     */\r\n+    private Map<String, HeliosVariable> vMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private static ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore>();\r\n+\r\n+    /**\r\n+     * Communication interface to the endpoint\r\n+     */\r\n+    private ModbusCommunicationInterface comms;\r\n+\r\n+    /**\r\n+     * The date format used by the device\r\n+     */\r\n+    private int dateFormat = -1;\r\n+\r\n+    /**\r\n+     * Constructor\r\n+     *\r\n+     * @param thing\r\n+     * @param managerRef\r\n+     */\r\n+    public HeliosEasyControlsHandler(Thing thing) {\r\n+        super(thing);\r\n+    }\r\n+\r\n+    /**\r\n+     * Reads variable definitions from JSON file and store them in vMap\r\n+     */\r\n+    private void readVariableDefinition() {\r\n+        try {\r\n+            Gson gson = new Gson();\r\n+            Type vMapType = new TypeToken<Map<String, HeliosVariable>>() {\r\n+            }.getType();\r\n+            this.vMap = gson.fromJson(\r\n+                    new BufferedReader(new InputStreamReader(getClass()\r\n+                            .getResourceAsStream(HeliosEasyControlsBindingConstants.VARIABLES_DEFINITION_FILE))),\r\n+                    vMapType);\r\n+            // add the name to the variable itself\r\n+            for (Map.Entry<String, HeliosVariable> entry : this.vMap.entrySet()) {\r\n+                entry.getValue().setName(entry.getKey()); // workaround to set the variable name inside the\r\n+                                                          // HeliosVariable object\r\n+                if (!entry.getValue().isOk()) {\r\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\r\n+                            \"Variables definition file contains inconsistent data.\");\r\n+\r\n+                }\r\n+            }\r\n+        } catch (Exception e) {\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\r\n+                    \"Variables definition file not found or of illegal format.\");\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the endpoint handler from the bridge this handler is connected to\r\n+     * Checks that we're connected to the right type of bridge\r\n+     *\r\n+     * @return the endpoint handler or null if the bridge does not exist\r\n+     */\r\n+    private ModbusEndpointThingHandler getEndpointThingHandler() {\r\n+        Bridge bridge = getBridge();\r\n+        if (bridge == null) {\r\n+            logger.debug(\"Bridge is null\");\r\n+            return null;\r\n+        }\r\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\r\n+            logger.debug(\"Bridge is not online\");\r\n+            return null;\r\n+        }\r\n+\r\n+        ThingHandler handler = bridge.getHandler();\r\n+        if (handler == null) {\r\n+            logger.debug(\"Bridge handler is null\");\r\n+            return null;\r\n+        }\r\n+\r\n+        if (handler instanceof ModbusEndpointThingHandler) {\r\n+            return (ModbusEndpointThingHandler) handler;\r\n+        } else {\r\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\r\n+            return null;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get a reference to the modbus endpoint\r\n+     */\r\n+    private void connectEndpoint() {\r\n+        if (this.comms != null) {\r\n+            return;\r\n+        }\r\n+\r\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\r\n+        if (slaveEndpointThingHandler == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' is offline\", label));\r\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\r\n+            return;\r\n+        }\r\n+\r\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\r\n+\r\n+        if (comms == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\r\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\r\n+            return;\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void initialize() {\r\n+        this.config = getConfigAs(HeliosEasyControlsConfiguration.class);\r\n+        this.readVariableDefinition();\r\n+        this.connectEndpoint();\r\n+        if (this.comms != null) {\r\n+            HeliosEasyControlsHandler.transactionLocks.putIfAbsent(this.comms.getEndpoint(), new Semaphore(1, true));\r\n+            updateStatus(ThingStatus.UNKNOWN);\r\n+\r\n+            // background initialization\r\n+            scheduler.execute(() -> {\r\n+                try {\r\n+                    readValue(HeliosEasyControlsBindingConstants.DATE_FORMAT);\r\n+                    // status will be updated to ONLINE by the read callback function\r\n+                } catch (HeliosException e) {\r\n+                    logger.error(e.getMessage());\r\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\r\n+                }\r\n+            });\r\n+\r\n+            // poll for status updates regularly\r\n+            Runnable runnable = new Runnable() {\r\n+\r\n+                @Override\r\n+                public void run() {\r\n+                    for (Map.Entry<String, HeliosVariable> entry : vMap.entrySet()) {\r\n+                        if (isLinked(entry.getKey())\r\n+                                || (entry.getKey().equals(HeliosEasyControlsBindingConstants.DATE_FORMAT))) {\r\n+                            try {\r\n+                                readValue(entry.getKey());\r\n+                            } catch (HeliosException e) {\r\n+                                logger.error(e.getMessage());\r\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\r\n+                                        e.getMessage());\r\n+                            }\r\n+                        }\r\n+                    }\r\n+                }\r\n+            };\r\n+            this.pollingJob = scheduler.scheduleAtFixedRate(runnable, config.getRefreshInterval(),\r\n+                    config.getRefreshInterval(), TimeUnit.MILLISECONDS);\r\n+\r\n+        } else {\r\n+            logger.error(\"Modbus endpoint is null.\");\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void dispose() {\r\n+        if (this.pollingJob != null) {\r\n+            this.pollingJob.cancel(true);\r\n+        }\r\n+        this.comms = null;\r\n+    }\r\n+\r\n+    @Override\r\n+    public void handleCommand(ChannelUID channelUID, Command command) {\r\n+        String channelId = channelUID.getId();\r\n+        if (command instanceof RefreshType) {\r\n+            scheduler.schedule(new Runnable() {\r\n+                @Override\r\n+                public void run() {\r\n+                    try {\r\n+                        readValue(channelId);\r\n+                    } catch (HeliosException e) {\r\n+                        logger.error(e.getMessage());\r\n+                    }\r\n+                }\r\n+            }, 0, TimeUnit.SECONDS);\r\n+        } else { // write command\r\n+            String value;\r\n+            if (command instanceof OnOffType) {\r\n+                value = command == OnOffType.ON ? \"1\" : \"0\";\r\n+            } else if (command instanceof DateTimeType) {\r\n+                value = formatDate(channelId, ((DateTimeType) command).getZonedDateTime());\r\n+            } else { // Number or String\r\n+                value = command.toString();\r\n+            }\r\n+            scheduler.schedule(new Runnable() {\r\n+                @Override\r\n+                public void run() {\r\n+                    try {\r\n+                        writeValue(channelId, value);\r\n+                    } catch (HeliosException e) {\r\n+                        logger.error(e.getMessage());\r\n+                    }\r\n+                }\r\n+            }, 0, TimeUnit.SECONDS);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Writes a variable value to the Helios device\r\n+     *\r\n+     * @param variableName The variable name\r\n+     * @param value The new value\r\n+     * @return The value if the transaction succeeded, <tt>null</tt> otherwise\r\n+     * @throws HeliosException\r\n+     */\r\n+    public void writeValue(String variableName, String value) throws HeliosException {\r\n+        HeliosVariable v = this.vMap.get(variableName);\r\n+        if (!v.hasWriteAccess()) {\r\n+            throw new HeliosException(\"Variable \" + variableName + \" is read-only\");\r\n+        } else if (!v.isInAllowedRange(value)) {\r\n+            throw new HeliosException(\"Value \" + value + \" is outside of allowed range of variable \" + variableName);\r\n+        } else {\r\n+            // write to device\r\n+            String payload = v.getVariableString() + \"=\" + value;\r\n+            final Semaphore lock = transactionLocks.get(comms.getEndpoint());\r\n+            try {\r\n+                lock.acquire();\r\n+                this.comms.submitOneTimeWrite(new ModbusWriteRegisterRequestBlueprint(\r\n+                        HeliosEasyControlsBindingConstants.UNIT_ID, HeliosEasyControlsBindingConstants.START_ADDRESS,\r\n+                        new ModbusRegisterArray(preparePayload(payload)), true,\r\n+                        HeliosEasyControlsBindingConstants.MAX_TRIES), result -> {\r\n+                            lock.release();\r\n+                        }, failureCallback -> {\r\n+                            handleError(\"{} encountered error writing to device: {}\",\r\n+                                    failureCallback.getCause().getMessage(), lock);\r\n+                        });\r\n+                // ensure the openHAB item is updated with the device's actual value\r\n+                scheduler.schedule(new Runnable() {\r\n+                    @Override\r\n+                    public void run() {\r\n+                        try {\r\n+                            readValue(variableName);\r\n+                        } catch (HeliosException e) {\r\n+                            logger.error(\r\n+                                    \"{} encountered HeliosException when trying to read variable {} from the device after updating it: {}\",\r\n+                                    HeliosEasyControlsHandler.class.getSimpleName(), variableName, e.getMessage());\r\n+                        }\r\n+                    }\r\n+                }, 1, TimeUnit.SECONDS);\r\n+            } catch (Exception e) {\r\n+                logger.error(\r\n+                        \"{} encountered Exception when trying to lock Semaphore for writing variable {} to the device: {}\",\r\n+                        HeliosEasyControlsHandler.class.getSimpleName(), variableName, e.getMessage());\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Read a variable from the Helios device\r\n+     *\r\n+     * @param variableName The variable name\r\n+     * @return The value\r\n+     * @throws HeliosException\r\n+     */\r\n+    public void readValue(String variableName) throws HeliosException {\r\n+        final Semaphore lock = transactionLocks.get(comms.getEndpoint());\r\n+        HeliosVariable v = this.vMap.get(variableName);\r\n+        if (v.hasReadAccess()) {\r\n+            try {\r\n+                lock.acquire(); // will block until lock is available\r\n+            } catch (InterruptedException e) {\r\n+                logger.error(\"{} encountered Exception when trying to read variable {} from the device: {}\",\r\n+                        HeliosEasyControlsHandler.class.getSimpleName(), variableName, e.getMessage());\r\n+                return;\r\n+            }\r\n+            // write variable name to register\r\n+            String payload = v.getVariableString();\r\n+            this.comms.submitOneTimeWrite(new ModbusWriteRegisterRequestBlueprint(\r\n+                    HeliosEasyControlsBindingConstants.UNIT_ID, HeliosEasyControlsBindingConstants.START_ADDRESS,\r\n+                    new ModbusRegisterArray(preparePayload(payload)), true,\r\n+                    HeliosEasyControlsBindingConstants.MAX_TRIES), result -> {\r\n+                        this.comms.submitOneTimePoll(\r\n+                                new ModbusReadRequestBlueprint(HeliosEasyControlsBindingConstants.UNIT_ID,\r\n+                                        ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS,\r\n+                                        HeliosEasyControlsBindingConstants.START_ADDRESS, v.getCount(),\r\n+                                        HeliosEasyControlsBindingConstants.MAX_TRIES),\r\n+                                pollResult -> {\r\n+                                    lock.release();\r\n+                                    Optional<ModbusRegisterArray> registers = (Optional<ModbusRegisterArray>) pollResult\r\n+                                            .getRegisters();\r\n+                                    if (registers.isPresent()) {\r\n+                                        processResponse(v, registers.get());\r\n+                                    }\r\n+                                }, failureCallback -> {\r\n+                                    handleError(\"{} encountered error reading from device: {}\",\r\n+                                            failureCallback.getCause().getMessage(), lock);\r\n+                                });\r\n+                    }, failureCallback -> {\r\n+                        handleError(\"{} encountered error writing to device: {}\",\r\n+                                failureCallback.getCause().getMessage(), lock);\r\n+                    });\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Formats the provided date to a string in the device's configured date format\r\n+     *\r\n+     * @param date the date to be formatted\r\n+     * @return a string in the device's configured date format\r\n+     */\r\n+    private String formatDate(String variableName, ZonedDateTime date) {\r\n+        String y = Integer.toString(date.getYear());\r\n+        String m = Integer.toString(date.getMonthValue());\r\n+        if (m.length() == 1) {\r\n+            m = \"0\" + m;\r\n+        }\r\n+        String d = Integer.toString(date.getDayOfMonth());\r\n+        if (d.length() == 1) {\r\n+            d = \"0\" + d;\r\n+        }\r\n+        if (variableName.equals(HeliosEasyControlsBindingConstants.DATE)) { // fixed format for writing the system date\r\n+            return d + \".\" + m + \".\" + y;\r\n+        } else {\r\n+            switch (this.dateFormat) {\r\n+                case 0: // dd.mm.yyyy\r\n+                    return d + \".\" + m + \".\" + y;\r\n+                case 1: // mm.dd.yyyy\r\n+                    return m + \".\" + d + \".\" + y;\r\n+                case 2: // yyyy.mm.dd\r\n+                    return y + \".\" + m + \".\" + d;\r\n+                default:\r\n+                    return d + \".\" + m + \".\" + y;\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns a DateTimeType object based on the provided String and the device's configured date format\r\n+     *\r\n+     * @param date The date string read from the device\r\n+     * @return A DateTimeType object representing the date or time specified\r\n+     */\r\n+    private DateTimeType toDateTime(String date) {\r\n+        String[] dateTimeParts = null;\r\n+        String dateTime = date;\r\n+        try { // date\r\n+            dateTimeParts = date.split(\"\\\\.\"); // try to split date components\r\n+            if (dateTimeParts.length == 1) { // time\r\n+                return DateTimeType.valueOf(date);\r\n+            } else { // date - we'll try the device's date format\r\n+                switch (this.dateFormat) {\r\n+                    case 0: // dd.mm.yyyy\r\n+                        dateTime = dateTimeParts[2] + \"-\" + dateTimeParts[1] + \"-\" + dateTimeParts[0];\r\n+                        break;\r\n+                    case 1: // mm.dd.yyyy\r\n+                        dateTime = dateTimeParts[2] + \"-\" + dateTimeParts[0] + \"-\" + dateTimeParts[1];\r\n+                        break;\r\n+                    case 2: // yyyy.mm.dd\r\n+                        dateTime = dateTimeParts[0] + \"-\" + dateTimeParts[1] + \"-\" + dateTimeParts[2];\r\n+                        break;\r\n+                    default:\r\n+                        dateTime = dateTimeParts[2] + \"-\" + dateTimeParts[1] + \"-\" + dateTimeParts[0];\r\n+                        break;\r\n+                }\r\n+                return DateTimeType.valueOf(dateTime);\r\n+            }\r\n+        } catch (Exception e) {\r\n+            // falling back to default date format (apparently using the configured format has failed)\r\n+            if (dateTimeParts != null) {\r\n+                dateTime = dateTimeParts[2] + \"-\" + dateTimeParts[1] + \"-\" + dateTimeParts[0];\r\n+                return DateTimeType.valueOf(dateTime);\r\n+            } else {\r\n+                logger.error(\"{} couldn't parse the provided date string: {}\",\r\n+                        HeliosEasyControlsHandler.class.getSimpleName(), date);\r\n+                return new DateTimeType();\r\n+            }\r\n+\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Prepares the payload for the request\r\n+     *\r\n+     * @param payload The String representation of the payload\r\n+     * @return The Register representation of the payload\r\n+     */\r\n+    private ModbusRegister[] preparePayload(String payload) {\r\n+\r\n+        // determine number of registers\r\n+        int l = (payload.length() + 1) / 2; // +1 because we need to include at least one termination symbol 0x00\r\n+        if ((payload.length() + 1) % 2 != 0) {\r\n+            l++;\r\n+        }\r\n+\r\n+        ModbusRegister reg[] = new ModbusRegister[l];\r\n+        byte[] b = payload.getBytes();\r\n+        int ch = 0;\r\n+        for (int i = 0; i < reg.length; i++) {\r\n+            byte b1 = ch < b.length ? b[ch] : (byte) 0x00; // terminate with 0x00 if at the end of the payload\r\n+            ch++;\r\n+            byte b2 = ch < b.length ? b[ch] : (byte) 0x00;\r\n+            ch++;\r\n+            reg[i] = new ModbusRegister(b1, b2);\r\n+        }\r\n+        return reg;\r\n+    }\r\n+\r\n+    /**\r\n+     * Decodes the Helios device' response and returns the actual value of the variable\r\n+     *\r\n+     * @param response The registers received from the Helios device\r\n+     * @return The value or <tt>null</tt> if an error occurred\r\n+     */\r\n+    private void processResponse(HeliosVariable v, ModbusRegisterArray registers) {\r\n+        // decode response\r\n+        byte[] b = new byte[registers.size() * 2];\r\n+        int actSize = 0; // track the actual size of the useable array (excluding any 0x00\r\n+                         // characters)\r\n+        for (int i = 0; i < registers.size(); i++) {\r\n+            byte[] reg = registers.getRegister(i).getBytes();\r\n+            if (reg.length == 2) { // only add to the array if it's a useable character\r\n+                if (reg[0] != 0x00) {\r\n+                    b[actSize++] = reg[0];\r\n+                }\r\n+                if (reg[1] != 0x00) {\r\n+                    b[actSize++] = reg[1];\r\n+                }\r\n+            }\r\n+        }\r\n+        b = Arrays.copyOf(b, actSize); // before creating a string of it the array needs to be\r\n+                                       // truncated\r\n+        String r = new String(b);\r", "originalCommit": "73d8f576a176edc1b7c8f90549169819e7d5e410", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAyNjA3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r465026079", "bodyText": "Can you have many = in the string? If so, you can defend yourself with the limit parameter of String.split", "author": "ssalonen", "createdAt": "2020-08-04T12:51:23Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,577 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    /**\r\n+     * Logger instance\r\n+     */\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    /**\r\n+     * Configuration instance\r\n+     */\r\n+    private HeliosEasyControlsConfiguration config;\r\n+\r\n+    /**\r\n+     * Used to poll the variables' status based on the configured refresh interval\r\n+     */\r\n+    private ScheduledFuture<?> pollingJob;\r\n+\r\n+    /**\r\n+     * The map holding the variable meta info by variable name\r\n+     */\r\n+    private Map<String, HeliosVariable> vMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private static ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore>();\r\n+\r\n+    /**\r\n+     * Communication interface to the endpoint\r\n+     */\r\n+    private ModbusCommunicationInterface comms;\r\n+\r\n+    /**\r\n+     * The date format used by the device\r\n+     */\r\n+    private int dateFormat = -1;\r\n+\r\n+    /**\r\n+     * Constructor\r\n+     *\r\n+     * @param thing\r\n+     * @param managerRef\r\n+     */\r\n+    public HeliosEasyControlsHandler(Thing thing) {\r\n+        super(thing);\r\n+    }\r\n+\r\n+    /**\r\n+     * Reads variable definitions from JSON file and store them in vMap\r\n+     */\r\n+    private void readVariableDefinition() {\r\n+        try {\r\n+            Gson gson = new Gson();\r\n+            Type vMapType = new TypeToken<Map<String, HeliosVariable>>() {\r\n+            }.getType();\r\n+            this.vMap = gson.fromJson(\r\n+                    new BufferedReader(new InputStreamReader(getClass()\r\n+                            .getResourceAsStream(HeliosEasyControlsBindingConstants.VARIABLES_DEFINITION_FILE))),\r\n+                    vMapType);\r\n+            // add the name to the variable itself\r\n+            for (Map.Entry<String, HeliosVariable> entry : this.vMap.entrySet()) {\r\n+                entry.getValue().setName(entry.getKey()); // workaround to set the variable name inside the\r\n+                                                          // HeliosVariable object\r\n+                if (!entry.getValue().isOk()) {\r\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\r\n+                            \"Variables definition file contains inconsistent data.\");\r\n+\r\n+                }\r\n+            }\r\n+        } catch (Exception e) {\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\r\n+                    \"Variables definition file not found or of illegal format.\");\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the endpoint handler from the bridge this handler is connected to\r\n+     * Checks that we're connected to the right type of bridge\r\n+     *\r\n+     * @return the endpoint handler or null if the bridge does not exist\r\n+     */\r\n+    private ModbusEndpointThingHandler getEndpointThingHandler() {\r\n+        Bridge bridge = getBridge();\r\n+        if (bridge == null) {\r\n+            logger.debug(\"Bridge is null\");\r\n+            return null;\r\n+        }\r\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\r\n+            logger.debug(\"Bridge is not online\");\r\n+            return null;\r\n+        }\r\n+\r\n+        ThingHandler handler = bridge.getHandler();\r\n+        if (handler == null) {\r\n+            logger.debug(\"Bridge handler is null\");\r\n+            return null;\r\n+        }\r\n+\r\n+        if (handler instanceof ModbusEndpointThingHandler) {\r\n+            return (ModbusEndpointThingHandler) handler;\r\n+        } else {\r\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\r\n+            return null;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get a reference to the modbus endpoint\r\n+     */\r\n+    private void connectEndpoint() {\r\n+        if (this.comms != null) {\r\n+            return;\r\n+        }\r\n+\r\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\r\n+        if (slaveEndpointThingHandler == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' is offline\", label));\r\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\r\n+            return;\r\n+        }\r\n+\r\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\r\n+\r\n+        if (comms == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\r\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\r\n+            return;\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void initialize() {\r\n+        this.config = getConfigAs(HeliosEasyControlsConfiguration.class);\r\n+        this.readVariableDefinition();\r\n+        this.connectEndpoint();\r\n+        if (this.comms != null) {\r\n+            HeliosEasyControlsHandler.transactionLocks.putIfAbsent(this.comms.getEndpoint(), new Semaphore(1, true));\r\n+            updateStatus(ThingStatus.UNKNOWN);\r\n+\r\n+            // background initialization\r\n+            scheduler.execute(() -> {\r\n+                try {\r\n+                    readValue(HeliosEasyControlsBindingConstants.DATE_FORMAT);\r\n+                    // status will be updated to ONLINE by the read callback function\r\n+                } catch (HeliosException e) {\r\n+                    logger.error(e.getMessage());\r\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\r\n+                }\r\n+            });\r\n+\r\n+            // poll for status updates regularly\r\n+            Runnable runnable = new Runnable() {\r\n+\r\n+                @Override\r\n+                public void run() {\r\n+                    for (Map.Entry<String, HeliosVariable> entry : vMap.entrySet()) {\r\n+                        if (isLinked(entry.getKey())\r\n+                                || (entry.getKey().equals(HeliosEasyControlsBindingConstants.DATE_FORMAT))) {\r\n+                            try {\r\n+                                readValue(entry.getKey());\r\n+                            } catch (HeliosException e) {\r\n+                                logger.error(e.getMessage());\r\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\r\n+                                        e.getMessage());\r\n+                            }\r\n+                        }\r\n+                    }\r\n+                }\r\n+            };\r\n+            this.pollingJob = scheduler.scheduleAtFixedRate(runnable, config.getRefreshInterval(),\r\n+                    config.getRefreshInterval(), TimeUnit.MILLISECONDS);\r\n+\r\n+        } else {\r\n+            logger.error(\"Modbus endpoint is null.\");\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void dispose() {\r\n+        if (this.pollingJob != null) {\r\n+            this.pollingJob.cancel(true);\r\n+        }\r\n+        this.comms = null;\r\n+    }\r\n+\r\n+    @Override\r\n+    public void handleCommand(ChannelUID channelUID, Command command) {\r\n+        String channelId = channelUID.getId();\r\n+        if (command instanceof RefreshType) {\r\n+            scheduler.schedule(new Runnable() {\r\n+                @Override\r\n+                public void run() {\r\n+                    try {\r\n+                        readValue(channelId);\r\n+                    } catch (HeliosException e) {\r\n+                        logger.error(e.getMessage());\r\n+                    }\r\n+                }\r\n+            }, 0, TimeUnit.SECONDS);\r\n+        } else { // write command\r\n+            String value;\r\n+            if (command instanceof OnOffType) {\r\n+                value = command == OnOffType.ON ? \"1\" : \"0\";\r\n+            } else if (command instanceof DateTimeType) {\r\n+                value = formatDate(channelId, ((DateTimeType) command).getZonedDateTime());\r\n+            } else { // Number or String\r\n+                value = command.toString();\r\n+            }\r\n+            scheduler.schedule(new Runnable() {\r\n+                @Override\r\n+                public void run() {\r\n+                    try {\r\n+                        writeValue(channelId, value);\r\n+                    } catch (HeliosException e) {\r\n+                        logger.error(e.getMessage());\r\n+                    }\r\n+                }\r\n+            }, 0, TimeUnit.SECONDS);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Writes a variable value to the Helios device\r\n+     *\r\n+     * @param variableName The variable name\r\n+     * @param value The new value\r\n+     * @return The value if the transaction succeeded, <tt>null</tt> otherwise\r\n+     * @throws HeliosException\r\n+     */\r\n+    public void writeValue(String variableName, String value) throws HeliosException {\r\n+        HeliosVariable v = this.vMap.get(variableName);\r\n+        if (!v.hasWriteAccess()) {\r\n+            throw new HeliosException(\"Variable \" + variableName + \" is read-only\");\r\n+        } else if (!v.isInAllowedRange(value)) {\r\n+            throw new HeliosException(\"Value \" + value + \" is outside of allowed range of variable \" + variableName);\r\n+        } else {\r\n+            // write to device\r\n+            String payload = v.getVariableString() + \"=\" + value;\r\n+            final Semaphore lock = transactionLocks.get(comms.getEndpoint());\r\n+            try {\r\n+                lock.acquire();\r\n+                this.comms.submitOneTimeWrite(new ModbusWriteRegisterRequestBlueprint(\r\n+                        HeliosEasyControlsBindingConstants.UNIT_ID, HeliosEasyControlsBindingConstants.START_ADDRESS,\r\n+                        new ModbusRegisterArray(preparePayload(payload)), true,\r\n+                        HeliosEasyControlsBindingConstants.MAX_TRIES), result -> {\r\n+                            lock.release();\r\n+                        }, failureCallback -> {\r\n+                            handleError(\"{} encountered error writing to device: {}\",\r\n+                                    failureCallback.getCause().getMessage(), lock);\r\n+                        });\r\n+                // ensure the openHAB item is updated with the device's actual value\r\n+                scheduler.schedule(new Runnable() {\r\n+                    @Override\r\n+                    public void run() {\r\n+                        try {\r\n+                            readValue(variableName);\r\n+                        } catch (HeliosException e) {\r\n+                            logger.error(\r\n+                                    \"{} encountered HeliosException when trying to read variable {} from the device after updating it: {}\",\r\n+                                    HeliosEasyControlsHandler.class.getSimpleName(), variableName, e.getMessage());\r\n+                        }\r\n+                    }\r\n+                }, 1, TimeUnit.SECONDS);\r\n+            } catch (Exception e) {\r\n+                logger.error(\r\n+                        \"{} encountered Exception when trying to lock Semaphore for writing variable {} to the device: {}\",\r\n+                        HeliosEasyControlsHandler.class.getSimpleName(), variableName, e.getMessage());\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Read a variable from the Helios device\r\n+     *\r\n+     * @param variableName The variable name\r\n+     * @return The value\r\n+     * @throws HeliosException\r\n+     */\r\n+    public void readValue(String variableName) throws HeliosException {\r\n+        final Semaphore lock = transactionLocks.get(comms.getEndpoint());\r\n+        HeliosVariable v = this.vMap.get(variableName);\r\n+        if (v.hasReadAccess()) {\r\n+            try {\r\n+                lock.acquire(); // will block until lock is available\r\n+            } catch (InterruptedException e) {\r\n+                logger.error(\"{} encountered Exception when trying to read variable {} from the device: {}\",\r\n+                        HeliosEasyControlsHandler.class.getSimpleName(), variableName, e.getMessage());\r\n+                return;\r\n+            }\r\n+            // write variable name to register\r\n+            String payload = v.getVariableString();\r\n+            this.comms.submitOneTimeWrite(new ModbusWriteRegisterRequestBlueprint(\r\n+                    HeliosEasyControlsBindingConstants.UNIT_ID, HeliosEasyControlsBindingConstants.START_ADDRESS,\r\n+                    new ModbusRegisterArray(preparePayload(payload)), true,\r\n+                    HeliosEasyControlsBindingConstants.MAX_TRIES), result -> {\r\n+                        this.comms.submitOneTimePoll(\r\n+                                new ModbusReadRequestBlueprint(HeliosEasyControlsBindingConstants.UNIT_ID,\r\n+                                        ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS,\r\n+                                        HeliosEasyControlsBindingConstants.START_ADDRESS, v.getCount(),\r\n+                                        HeliosEasyControlsBindingConstants.MAX_TRIES),\r\n+                                pollResult -> {\r\n+                                    lock.release();\r\n+                                    Optional<ModbusRegisterArray> registers = (Optional<ModbusRegisterArray>) pollResult\r\n+                                            .getRegisters();\r\n+                                    if (registers.isPresent()) {\r\n+                                        processResponse(v, registers.get());\r\n+                                    }\r\n+                                }, failureCallback -> {\r\n+                                    handleError(\"{} encountered error reading from device: {}\",\r\n+                                            failureCallback.getCause().getMessage(), lock);\r\n+                                });\r\n+                    }, failureCallback -> {\r\n+                        handleError(\"{} encountered error writing to device: {}\",\r\n+                                failureCallback.getCause().getMessage(), lock);\r\n+                    });\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Formats the provided date to a string in the device's configured date format\r\n+     *\r\n+     * @param date the date to be formatted\r\n+     * @return a string in the device's configured date format\r\n+     */\r\n+    private String formatDate(String variableName, ZonedDateTime date) {\r\n+        String y = Integer.toString(date.getYear());\r\n+        String m = Integer.toString(date.getMonthValue());\r\n+        if (m.length() == 1) {\r\n+            m = \"0\" + m;\r\n+        }\r\n+        String d = Integer.toString(date.getDayOfMonth());\r\n+        if (d.length() == 1) {\r\n+            d = \"0\" + d;\r\n+        }\r\n+        if (variableName.equals(HeliosEasyControlsBindingConstants.DATE)) { // fixed format for writing the system date\r\n+            return d + \".\" + m + \".\" + y;\r\n+        } else {\r\n+            switch (this.dateFormat) {\r\n+                case 0: // dd.mm.yyyy\r\n+                    return d + \".\" + m + \".\" + y;\r\n+                case 1: // mm.dd.yyyy\r\n+                    return m + \".\" + d + \".\" + y;\r\n+                case 2: // yyyy.mm.dd\r\n+                    return y + \".\" + m + \".\" + d;\r\n+                default:\r\n+                    return d + \".\" + m + \".\" + y;\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns a DateTimeType object based on the provided String and the device's configured date format\r\n+     *\r\n+     * @param date The date string read from the device\r\n+     * @return A DateTimeType object representing the date or time specified\r\n+     */\r\n+    private DateTimeType toDateTime(String date) {\r\n+        String[] dateTimeParts = null;\r\n+        String dateTime = date;\r\n+        try { // date\r\n+            dateTimeParts = date.split(\"\\\\.\"); // try to split date components\r\n+            if (dateTimeParts.length == 1) { // time\r\n+                return DateTimeType.valueOf(date);\r\n+            } else { // date - we'll try the device's date format\r\n+                switch (this.dateFormat) {\r\n+                    case 0: // dd.mm.yyyy\r\n+                        dateTime = dateTimeParts[2] + \"-\" + dateTimeParts[1] + \"-\" + dateTimeParts[0];\r\n+                        break;\r\n+                    case 1: // mm.dd.yyyy\r\n+                        dateTime = dateTimeParts[2] + \"-\" + dateTimeParts[0] + \"-\" + dateTimeParts[1];\r\n+                        break;\r\n+                    case 2: // yyyy.mm.dd\r\n+                        dateTime = dateTimeParts[0] + \"-\" + dateTimeParts[1] + \"-\" + dateTimeParts[2];\r\n+                        break;\r\n+                    default:\r\n+                        dateTime = dateTimeParts[2] + \"-\" + dateTimeParts[1] + \"-\" + dateTimeParts[0];\r\n+                        break;\r\n+                }\r\n+                return DateTimeType.valueOf(dateTime);\r\n+            }\r\n+        } catch (Exception e) {\r\n+            // falling back to default date format (apparently using the configured format has failed)\r\n+            if (dateTimeParts != null) {\r\n+                dateTime = dateTimeParts[2] + \"-\" + dateTimeParts[1] + \"-\" + dateTimeParts[0];\r\n+                return DateTimeType.valueOf(dateTime);\r\n+            } else {\r\n+                logger.error(\"{} couldn't parse the provided date string: {}\",\r\n+                        HeliosEasyControlsHandler.class.getSimpleName(), date);\r\n+                return new DateTimeType();\r\n+            }\r\n+\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Prepares the payload for the request\r\n+     *\r\n+     * @param payload The String representation of the payload\r\n+     * @return The Register representation of the payload\r\n+     */\r\n+    private ModbusRegister[] preparePayload(String payload) {\r\n+\r\n+        // determine number of registers\r\n+        int l = (payload.length() + 1) / 2; // +1 because we need to include at least one termination symbol 0x00\r\n+        if ((payload.length() + 1) % 2 != 0) {\r\n+            l++;\r\n+        }\r\n+\r\n+        ModbusRegister reg[] = new ModbusRegister[l];\r\n+        byte[] b = payload.getBytes();\r\n+        int ch = 0;\r\n+        for (int i = 0; i < reg.length; i++) {\r\n+            byte b1 = ch < b.length ? b[ch] : (byte) 0x00; // terminate with 0x00 if at the end of the payload\r\n+            ch++;\r\n+            byte b2 = ch < b.length ? b[ch] : (byte) 0x00;\r\n+            ch++;\r\n+            reg[i] = new ModbusRegister(b1, b2);\r\n+        }\r\n+        return reg;\r\n+    }\r\n+\r\n+    /**\r\n+     * Decodes the Helios device' response and returns the actual value of the variable\r\n+     *\r\n+     * @param response The registers received from the Helios device\r\n+     * @return The value or <tt>null</tt> if an error occurred\r\n+     */\r\n+    private void processResponse(HeliosVariable v, ModbusRegisterArray registers) {\r\n+        // decode response\r\n+        byte[] b = new byte[registers.size() * 2];\r\n+        int actSize = 0; // track the actual size of the useable array (excluding any 0x00\r\n+                         // characters)\r\n+        for (int i = 0; i < registers.size(); i++) {\r\n+            byte[] reg = registers.getRegister(i).getBytes();\r\n+            if (reg.length == 2) { // only add to the array if it's a useable character\r\n+                if (reg[0] != 0x00) {\r\n+                    b[actSize++] = reg[0];\r\n+                }\r\n+                if (reg[1] != 0x00) {\r\n+                    b[actSize++] = reg[1];\r\n+                }\r\n+            }\r\n+        }\r\n+        b = Arrays.copyOf(b, actSize); // before creating a string of it the array needs to be\r\n+                                       // truncated\r\n+        String r = new String(b);\r\n+        String[] parts = r.split(\"=\"); // remove the part \"vXXXX=\" from the string\r", "originalCommit": "73d8f576a176edc1b7c8f90549169819e7d5e410", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAyODU1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r465028559", "bodyText": "Check logging level. Should thing status change?", "author": "ssalonen", "createdAt": "2020-08-04T12:55:17Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,577 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    /**\r\n+     * Logger instance\r\n+     */\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    /**\r\n+     * Configuration instance\r\n+     */\r\n+    private HeliosEasyControlsConfiguration config;\r\n+\r\n+    /**\r\n+     * Used to poll the variables' status based on the configured refresh interval\r\n+     */\r\n+    private ScheduledFuture<?> pollingJob;\r\n+\r\n+    /**\r\n+     * The map holding the variable meta info by variable name\r\n+     */\r\n+    private Map<String, HeliosVariable> vMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private static ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore>();\r\n+\r\n+    /**\r\n+     * Communication interface to the endpoint\r\n+     */\r\n+    private ModbusCommunicationInterface comms;\r\n+\r\n+    /**\r\n+     * The date format used by the device\r\n+     */\r\n+    private int dateFormat = -1;\r\n+\r\n+    /**\r\n+     * Constructor\r\n+     *\r\n+     * @param thing\r\n+     * @param managerRef\r\n+     */\r\n+    public HeliosEasyControlsHandler(Thing thing) {\r\n+        super(thing);\r\n+    }\r\n+\r\n+    /**\r\n+     * Reads variable definitions from JSON file and store them in vMap\r\n+     */\r\n+    private void readVariableDefinition() {\r\n+        try {\r\n+            Gson gson = new Gson();\r\n+            Type vMapType = new TypeToken<Map<String, HeliosVariable>>() {\r\n+            }.getType();\r\n+            this.vMap = gson.fromJson(\r\n+                    new BufferedReader(new InputStreamReader(getClass()\r\n+                            .getResourceAsStream(HeliosEasyControlsBindingConstants.VARIABLES_DEFINITION_FILE))),\r\n+                    vMapType);\r\n+            // add the name to the variable itself\r\n+            for (Map.Entry<String, HeliosVariable> entry : this.vMap.entrySet()) {\r\n+                entry.getValue().setName(entry.getKey()); // workaround to set the variable name inside the\r\n+                                                          // HeliosVariable object\r\n+                if (!entry.getValue().isOk()) {\r\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\r\n+                            \"Variables definition file contains inconsistent data.\");\r\n+\r\n+                }\r\n+            }\r\n+        } catch (Exception e) {\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\r\n+                    \"Variables definition file not found or of illegal format.\");\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the endpoint handler from the bridge this handler is connected to\r\n+     * Checks that we're connected to the right type of bridge\r\n+     *\r\n+     * @return the endpoint handler or null if the bridge does not exist\r\n+     */\r\n+    private ModbusEndpointThingHandler getEndpointThingHandler() {\r\n+        Bridge bridge = getBridge();\r\n+        if (bridge == null) {\r\n+            logger.debug(\"Bridge is null\");\r\n+            return null;\r\n+        }\r\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\r\n+            logger.debug(\"Bridge is not online\");\r\n+            return null;\r\n+        }\r\n+\r\n+        ThingHandler handler = bridge.getHandler();\r\n+        if (handler == null) {\r\n+            logger.debug(\"Bridge handler is null\");\r\n+            return null;\r\n+        }\r\n+\r\n+        if (handler instanceof ModbusEndpointThingHandler) {\r\n+            return (ModbusEndpointThingHandler) handler;\r\n+        } else {\r\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\r\n+            return null;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get a reference to the modbus endpoint\r\n+     */\r\n+    private void connectEndpoint() {\r\n+        if (this.comms != null) {\r\n+            return;\r\n+        }\r\n+\r\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\r\n+        if (slaveEndpointThingHandler == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' is offline\", label));\r\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\r\n+            return;\r\n+        }\r\n+\r\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\r\n+\r\n+        if (comms == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\r\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\r\n+            return;\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void initialize() {\r\n+        this.config = getConfigAs(HeliosEasyControlsConfiguration.class);\r\n+        this.readVariableDefinition();\r\n+        this.connectEndpoint();\r\n+        if (this.comms != null) {\r\n+            HeliosEasyControlsHandler.transactionLocks.putIfAbsent(this.comms.getEndpoint(), new Semaphore(1, true));\r\n+            updateStatus(ThingStatus.UNKNOWN);\r\n+\r\n+            // background initialization\r\n+            scheduler.execute(() -> {\r\n+                try {\r\n+                    readValue(HeliosEasyControlsBindingConstants.DATE_FORMAT);\r\n+                    // status will be updated to ONLINE by the read callback function\r\n+                } catch (HeliosException e) {\r\n+                    logger.error(e.getMessage());\r\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\r\n+                }\r\n+            });\r\n+\r\n+            // poll for status updates regularly\r\n+            Runnable runnable = new Runnable() {\r\n+\r\n+                @Override\r\n+                public void run() {\r\n+                    for (Map.Entry<String, HeliosVariable> entry : vMap.entrySet()) {\r\n+                        if (isLinked(entry.getKey())\r\n+                                || (entry.getKey().equals(HeliosEasyControlsBindingConstants.DATE_FORMAT))) {\r\n+                            try {\r\n+                                readValue(entry.getKey());\r\n+                            } catch (HeliosException e) {\r\n+                                logger.error(e.getMessage());\r\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\r\n+                                        e.getMessage());\r\n+                            }\r\n+                        }\r\n+                    }\r\n+                }\r\n+            };\r\n+            this.pollingJob = scheduler.scheduleAtFixedRate(runnable, config.getRefreshInterval(),\r\n+                    config.getRefreshInterval(), TimeUnit.MILLISECONDS);\r\n+\r\n+        } else {\r\n+            logger.error(\"Modbus endpoint is null.\");\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void dispose() {\r\n+        if (this.pollingJob != null) {\r\n+            this.pollingJob.cancel(true);\r\n+        }\r\n+        this.comms = null;\r\n+    }\r\n+\r\n+    @Override\r\n+    public void handleCommand(ChannelUID channelUID, Command command) {\r\n+        String channelId = channelUID.getId();\r\n+        if (command instanceof RefreshType) {\r\n+            scheduler.schedule(new Runnable() {\r\n+                @Override\r\n+                public void run() {\r\n+                    try {\r\n+                        readValue(channelId);\r\n+                    } catch (HeliosException e) {\r\n+                        logger.error(e.getMessage());\r\n+                    }\r\n+                }\r\n+            }, 0, TimeUnit.SECONDS);\r\n+        } else { // write command\r\n+            String value;\r\n+            if (command instanceof OnOffType) {\r\n+                value = command == OnOffType.ON ? \"1\" : \"0\";\r\n+            } else if (command instanceof DateTimeType) {\r\n+                value = formatDate(channelId, ((DateTimeType) command).getZonedDateTime());\r\n+            } else { // Number or String\r\n+                value = command.toString();\r\n+            }\r\n+            scheduler.schedule(new Runnable() {\r\n+                @Override\r\n+                public void run() {\r\n+                    try {\r\n+                        writeValue(channelId, value);\r\n+                    } catch (HeliosException e) {\r\n+                        logger.error(e.getMessage());\r\n+                    }\r\n+                }\r\n+            }, 0, TimeUnit.SECONDS);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Writes a variable value to the Helios device\r\n+     *\r\n+     * @param variableName The variable name\r\n+     * @param value The new value\r\n+     * @return The value if the transaction succeeded, <tt>null</tt> otherwise\r\n+     * @throws HeliosException\r\n+     */\r\n+    public void writeValue(String variableName, String value) throws HeliosException {\r\n+        HeliosVariable v = this.vMap.get(variableName);\r\n+        if (!v.hasWriteAccess()) {\r\n+            throw new HeliosException(\"Variable \" + variableName + \" is read-only\");\r\n+        } else if (!v.isInAllowedRange(value)) {\r\n+            throw new HeliosException(\"Value \" + value + \" is outside of allowed range of variable \" + variableName);\r\n+        } else {\r\n+            // write to device\r\n+            String payload = v.getVariableString() + \"=\" + value;\r\n+            final Semaphore lock = transactionLocks.get(comms.getEndpoint());\r\n+            try {\r\n+                lock.acquire();\r\n+                this.comms.submitOneTimeWrite(new ModbusWriteRegisterRequestBlueprint(\r\n+                        HeliosEasyControlsBindingConstants.UNIT_ID, HeliosEasyControlsBindingConstants.START_ADDRESS,\r\n+                        new ModbusRegisterArray(preparePayload(payload)), true,\r\n+                        HeliosEasyControlsBindingConstants.MAX_TRIES), result -> {\r\n+                            lock.release();\r\n+                        }, failureCallback -> {\r\n+                            handleError(\"{} encountered error writing to device: {}\",\r\n+                                    failureCallback.getCause().getMessage(), lock);\r\n+                        });\r\n+                // ensure the openHAB item is updated with the device's actual value\r\n+                scheduler.schedule(new Runnable() {\r\n+                    @Override\r\n+                    public void run() {\r\n+                        try {\r\n+                            readValue(variableName);\r\n+                        } catch (HeliosException e) {\r\n+                            logger.error(\r", "originalCommit": "73d8f576a176edc1b7c8f90549169819e7d5e410", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAyOTA0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r465029045", "bodyText": "What type of exceptions are catched by this?", "author": "ssalonen", "createdAt": "2020-08-04T12:56:04Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,577 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    /**\r\n+     * Logger instance\r\n+     */\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    /**\r\n+     * Configuration instance\r\n+     */\r\n+    private HeliosEasyControlsConfiguration config;\r\n+\r\n+    /**\r\n+     * Used to poll the variables' status based on the configured refresh interval\r\n+     */\r\n+    private ScheduledFuture<?> pollingJob;\r\n+\r\n+    /**\r\n+     * The map holding the variable meta info by variable name\r\n+     */\r\n+    private Map<String, HeliosVariable> vMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private static ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore>();\r\n+\r\n+    /**\r\n+     * Communication interface to the endpoint\r\n+     */\r\n+    private ModbusCommunicationInterface comms;\r\n+\r\n+    /**\r\n+     * The date format used by the device\r\n+     */\r\n+    private int dateFormat = -1;\r\n+\r\n+    /**\r\n+     * Constructor\r\n+     *\r\n+     * @param thing\r\n+     * @param managerRef\r\n+     */\r\n+    public HeliosEasyControlsHandler(Thing thing) {\r\n+        super(thing);\r\n+    }\r\n+\r\n+    /**\r\n+     * Reads variable definitions from JSON file and store them in vMap\r\n+     */\r\n+    private void readVariableDefinition() {\r\n+        try {\r\n+            Gson gson = new Gson();\r\n+            Type vMapType = new TypeToken<Map<String, HeliosVariable>>() {\r\n+            }.getType();\r\n+            this.vMap = gson.fromJson(\r\n+                    new BufferedReader(new InputStreamReader(getClass()\r\n+                            .getResourceAsStream(HeliosEasyControlsBindingConstants.VARIABLES_DEFINITION_FILE))),\r\n+                    vMapType);\r\n+            // add the name to the variable itself\r\n+            for (Map.Entry<String, HeliosVariable> entry : this.vMap.entrySet()) {\r\n+                entry.getValue().setName(entry.getKey()); // workaround to set the variable name inside the\r\n+                                                          // HeliosVariable object\r\n+                if (!entry.getValue().isOk()) {\r\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\r\n+                            \"Variables definition file contains inconsistent data.\");\r\n+\r\n+                }\r\n+            }\r\n+        } catch (Exception e) {\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\r\n+                    \"Variables definition file not found or of illegal format.\");\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the endpoint handler from the bridge this handler is connected to\r\n+     * Checks that we're connected to the right type of bridge\r\n+     *\r\n+     * @return the endpoint handler or null if the bridge does not exist\r\n+     */\r\n+    private ModbusEndpointThingHandler getEndpointThingHandler() {\r\n+        Bridge bridge = getBridge();\r\n+        if (bridge == null) {\r\n+            logger.debug(\"Bridge is null\");\r\n+            return null;\r\n+        }\r\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\r\n+            logger.debug(\"Bridge is not online\");\r\n+            return null;\r\n+        }\r\n+\r\n+        ThingHandler handler = bridge.getHandler();\r\n+        if (handler == null) {\r\n+            logger.debug(\"Bridge handler is null\");\r\n+            return null;\r\n+        }\r\n+\r\n+        if (handler instanceof ModbusEndpointThingHandler) {\r\n+            return (ModbusEndpointThingHandler) handler;\r\n+        } else {\r\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\r\n+            return null;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get a reference to the modbus endpoint\r\n+     */\r\n+    private void connectEndpoint() {\r\n+        if (this.comms != null) {\r\n+            return;\r\n+        }\r\n+\r\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\r\n+        if (slaveEndpointThingHandler == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' is offline\", label));\r\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\r\n+            return;\r\n+        }\r\n+\r\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\r\n+\r\n+        if (comms == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\r\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\r\n+            return;\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void initialize() {\r\n+        this.config = getConfigAs(HeliosEasyControlsConfiguration.class);\r\n+        this.readVariableDefinition();\r\n+        this.connectEndpoint();\r\n+        if (this.comms != null) {\r\n+            HeliosEasyControlsHandler.transactionLocks.putIfAbsent(this.comms.getEndpoint(), new Semaphore(1, true));\r\n+            updateStatus(ThingStatus.UNKNOWN);\r\n+\r\n+            // background initialization\r\n+            scheduler.execute(() -> {\r\n+                try {\r\n+                    readValue(HeliosEasyControlsBindingConstants.DATE_FORMAT);\r\n+                    // status will be updated to ONLINE by the read callback function\r\n+                } catch (HeliosException e) {\r\n+                    logger.error(e.getMessage());\r\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\r\n+                }\r\n+            });\r\n+\r\n+            // poll for status updates regularly\r\n+            Runnable runnable = new Runnable() {\r\n+\r\n+                @Override\r\n+                public void run() {\r\n+                    for (Map.Entry<String, HeliosVariable> entry : vMap.entrySet()) {\r\n+                        if (isLinked(entry.getKey())\r\n+                                || (entry.getKey().equals(HeliosEasyControlsBindingConstants.DATE_FORMAT))) {\r\n+                            try {\r\n+                                readValue(entry.getKey());\r\n+                            } catch (HeliosException e) {\r\n+                                logger.error(e.getMessage());\r\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\r\n+                                        e.getMessage());\r\n+                            }\r\n+                        }\r\n+                    }\r\n+                }\r\n+            };\r\n+            this.pollingJob = scheduler.scheduleAtFixedRate(runnable, config.getRefreshInterval(),\r\n+                    config.getRefreshInterval(), TimeUnit.MILLISECONDS);\r\n+\r\n+        } else {\r\n+            logger.error(\"Modbus endpoint is null.\");\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void dispose() {\r\n+        if (this.pollingJob != null) {\r\n+            this.pollingJob.cancel(true);\r\n+        }\r\n+        this.comms = null;\r\n+    }\r\n+\r\n+    @Override\r\n+    public void handleCommand(ChannelUID channelUID, Command command) {\r\n+        String channelId = channelUID.getId();\r\n+        if (command instanceof RefreshType) {\r\n+            scheduler.schedule(new Runnable() {\r\n+                @Override\r\n+                public void run() {\r\n+                    try {\r\n+                        readValue(channelId);\r\n+                    } catch (HeliosException e) {\r\n+                        logger.error(e.getMessage());\r\n+                    }\r\n+                }\r\n+            }, 0, TimeUnit.SECONDS);\r\n+        } else { // write command\r\n+            String value;\r\n+            if (command instanceof OnOffType) {\r\n+                value = command == OnOffType.ON ? \"1\" : \"0\";\r\n+            } else if (command instanceof DateTimeType) {\r\n+                value = formatDate(channelId, ((DateTimeType) command).getZonedDateTime());\r\n+            } else { // Number or String\r\n+                value = command.toString();\r\n+            }\r\n+            scheduler.schedule(new Runnable() {\r\n+                @Override\r\n+                public void run() {\r\n+                    try {\r\n+                        writeValue(channelId, value);\r\n+                    } catch (HeliosException e) {\r\n+                        logger.error(e.getMessage());\r\n+                    }\r\n+                }\r\n+            }, 0, TimeUnit.SECONDS);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Writes a variable value to the Helios device\r\n+     *\r\n+     * @param variableName The variable name\r\n+     * @param value The new value\r\n+     * @return The value if the transaction succeeded, <tt>null</tt> otherwise\r\n+     * @throws HeliosException\r\n+     */\r\n+    public void writeValue(String variableName, String value) throws HeliosException {\r\n+        HeliosVariable v = this.vMap.get(variableName);\r\n+        if (!v.hasWriteAccess()) {\r\n+            throw new HeliosException(\"Variable \" + variableName + \" is read-only\");\r\n+        } else if (!v.isInAllowedRange(value)) {\r\n+            throw new HeliosException(\"Value \" + value + \" is outside of allowed range of variable \" + variableName);\r\n+        } else {\r\n+            // write to device\r\n+            String payload = v.getVariableString() + \"=\" + value;\r\n+            final Semaphore lock = transactionLocks.get(comms.getEndpoint());\r\n+            try {\r\n+                lock.acquire();\r\n+                this.comms.submitOneTimeWrite(new ModbusWriteRegisterRequestBlueprint(\r\n+                        HeliosEasyControlsBindingConstants.UNIT_ID, HeliosEasyControlsBindingConstants.START_ADDRESS,\r\n+                        new ModbusRegisterArray(preparePayload(payload)), true,\r\n+                        HeliosEasyControlsBindingConstants.MAX_TRIES), result -> {\r\n+                            lock.release();\r\n+                        }, failureCallback -> {\r\n+                            handleError(\"{} encountered error writing to device: {}\",\r\n+                                    failureCallback.getCause().getMessage(), lock);\r\n+                        });\r\n+                // ensure the openHAB item is updated with the device's actual value\r\n+                scheduler.schedule(new Runnable() {\r\n+                    @Override\r\n+                    public void run() {\r\n+                        try {\r\n+                            readValue(variableName);\r\n+                        } catch (HeliosException e) {\r\n+                            logger.error(\r\n+                                    \"{} encountered HeliosException when trying to read variable {} from the device after updating it: {}\",\r\n+                                    HeliosEasyControlsHandler.class.getSimpleName(), variableName, e.getMessage());\r\n+                        }\r\n+                    }\r\n+                }, 1, TimeUnit.SECONDS);\r\n+            } catch (Exception e) {\r", "originalCommit": "73d8f576a176edc1b7c8f90549169819e7d5e410", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAzMzE2MA==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r465033160", "bodyText": "It's great that user can refresh the data on demand. Unfortunately, I think openHAB commands all channels REFRESH on startup, generating a lot of traffic since there are so many channels.\nOne way to handle this is to throttle refreshes. See FMI weather binding as one example https://github.com/openhab/openhab-addons/blob/2.5.x/bundles/org.openhab.binding.fmiweather/src/main/java/org/openhab/binding/fmiweather/internal/AbstractWeatherHandler.java", "author": "ssalonen", "createdAt": "2020-08-04T13:02:50Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,577 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    /**\r\n+     * Logger instance\r\n+     */\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    /**\r\n+     * Configuration instance\r\n+     */\r\n+    private HeliosEasyControlsConfiguration config;\r\n+\r\n+    /**\r\n+     * Used to poll the variables' status based on the configured refresh interval\r\n+     */\r\n+    private ScheduledFuture<?> pollingJob;\r\n+\r\n+    /**\r\n+     * The map holding the variable meta info by variable name\r\n+     */\r\n+    private Map<String, HeliosVariable> vMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private static ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore>();\r\n+\r\n+    /**\r\n+     * Communication interface to the endpoint\r\n+     */\r\n+    private ModbusCommunicationInterface comms;\r\n+\r\n+    /**\r\n+     * The date format used by the device\r\n+     */\r\n+    private int dateFormat = -1;\r\n+\r\n+    /**\r\n+     * Constructor\r\n+     *\r\n+     * @param thing\r\n+     * @param managerRef\r\n+     */\r\n+    public HeliosEasyControlsHandler(Thing thing) {\r\n+        super(thing);\r\n+    }\r\n+\r\n+    /**\r\n+     * Reads variable definitions from JSON file and store them in vMap\r\n+     */\r\n+    private void readVariableDefinition() {\r\n+        try {\r\n+            Gson gson = new Gson();\r\n+            Type vMapType = new TypeToken<Map<String, HeliosVariable>>() {\r\n+            }.getType();\r\n+            this.vMap = gson.fromJson(\r\n+                    new BufferedReader(new InputStreamReader(getClass()\r\n+                            .getResourceAsStream(HeliosEasyControlsBindingConstants.VARIABLES_DEFINITION_FILE))),\r\n+                    vMapType);\r\n+            // add the name to the variable itself\r\n+            for (Map.Entry<String, HeliosVariable> entry : this.vMap.entrySet()) {\r\n+                entry.getValue().setName(entry.getKey()); // workaround to set the variable name inside the\r\n+                                                          // HeliosVariable object\r\n+                if (!entry.getValue().isOk()) {\r\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\r\n+                            \"Variables definition file contains inconsistent data.\");\r\n+\r\n+                }\r\n+            }\r\n+        } catch (Exception e) {\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\r\n+                    \"Variables definition file not found or of illegal format.\");\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the endpoint handler from the bridge this handler is connected to\r\n+     * Checks that we're connected to the right type of bridge\r\n+     *\r\n+     * @return the endpoint handler or null if the bridge does not exist\r\n+     */\r\n+    private ModbusEndpointThingHandler getEndpointThingHandler() {\r\n+        Bridge bridge = getBridge();\r\n+        if (bridge == null) {\r\n+            logger.debug(\"Bridge is null\");\r\n+            return null;\r\n+        }\r\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\r\n+            logger.debug(\"Bridge is not online\");\r\n+            return null;\r\n+        }\r\n+\r\n+        ThingHandler handler = bridge.getHandler();\r\n+        if (handler == null) {\r\n+            logger.debug(\"Bridge handler is null\");\r\n+            return null;\r\n+        }\r\n+\r\n+        if (handler instanceof ModbusEndpointThingHandler) {\r\n+            return (ModbusEndpointThingHandler) handler;\r\n+        } else {\r\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\r\n+            return null;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get a reference to the modbus endpoint\r\n+     */\r\n+    private void connectEndpoint() {\r\n+        if (this.comms != null) {\r\n+            return;\r\n+        }\r\n+\r\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\r\n+        if (slaveEndpointThingHandler == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' is offline\", label));\r\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\r\n+            return;\r\n+        }\r\n+\r\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\r\n+\r\n+        if (comms == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\r\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\r\n+            return;\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void initialize() {\r\n+        this.config = getConfigAs(HeliosEasyControlsConfiguration.class);\r\n+        this.readVariableDefinition();\r\n+        this.connectEndpoint();\r\n+        if (this.comms != null) {\r\n+            HeliosEasyControlsHandler.transactionLocks.putIfAbsent(this.comms.getEndpoint(), new Semaphore(1, true));\r\n+            updateStatus(ThingStatus.UNKNOWN);\r\n+\r\n+            // background initialization\r\n+            scheduler.execute(() -> {\r\n+                try {\r\n+                    readValue(HeliosEasyControlsBindingConstants.DATE_FORMAT);\r\n+                    // status will be updated to ONLINE by the read callback function\r\n+                } catch (HeliosException e) {\r\n+                    logger.error(e.getMessage());\r\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\r\n+                }\r\n+            });\r\n+\r\n+            // poll for status updates regularly\r\n+            Runnable runnable = new Runnable() {\r\n+\r\n+                @Override\r\n+                public void run() {\r\n+                    for (Map.Entry<String, HeliosVariable> entry : vMap.entrySet()) {\r\n+                        if (isLinked(entry.getKey())\r\n+                                || (entry.getKey().equals(HeliosEasyControlsBindingConstants.DATE_FORMAT))) {\r\n+                            try {\r\n+                                readValue(entry.getKey());\r\n+                            } catch (HeliosException e) {\r\n+                                logger.error(e.getMessage());\r\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\r\n+                                        e.getMessage());\r\n+                            }\r\n+                        }\r\n+                    }\r\n+                }\r\n+            };\r\n+            this.pollingJob = scheduler.scheduleAtFixedRate(runnable, config.getRefreshInterval(),\r\n+                    config.getRefreshInterval(), TimeUnit.MILLISECONDS);\r\n+\r\n+        } else {\r\n+            logger.error(\"Modbus endpoint is null.\");\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void dispose() {\r\n+        if (this.pollingJob != null) {\r\n+            this.pollingJob.cancel(true);\r\n+        }\r\n+        this.comms = null;\r\n+    }\r\n+\r\n+    @Override\r\n+    public void handleCommand(ChannelUID channelUID, Command command) {\r\n+        String channelId = channelUID.getId();\r\n+        if (command instanceof RefreshType) {\r", "originalCommit": "73d8f576a176edc1b7c8f90549169819e7d5e410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMwMjk3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r465302976", "bodyText": "readValue uses the locking mechanism, so the traffic communicating with the device is handled in a controlled way. Or do you mean traffic in general?", "author": "bern77", "createdAt": "2020-08-04T20:12:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAzMzE2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTU1NDA5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r465554095", "bodyText": "I think it would mean all these commands would pile up in queue of sort (=waiting for the lock), executed in very rapid fashion.\nIn my experience with other bindings it makes the openHAB itself slow (raspberry pi) since so many state updates are fired... Naturally after this initialization things are running smoothly again. So it's not a dealbreaker, just inconvenience\nYou are correct that locking ensures that at most one transaction is running at the same time. But still the rate of the requests is quite high. The rate is limited by the parameters set in the tcp thing.\nWriting this I realized that data is read by one variable at a time, not as one chunk. So actually my advice of throttling (I.e. Refreshing only if last refresh for the thing is old enough) does not make sense -- only way to refresh all the N channels is to fire N requests?\nHere are instructions how to test it if you like:\n\ncreate things\nlink all channels\nstart openHAB, observe if there are requests flying to the device (e.g. via logs). Check long it takes to update all channels\n\nI believe channels might get REFRESH when the things or items are recreated. This happens when the thigns/items files are modified.", "author": "ssalonen", "createdAt": "2020-08-05T08:16:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAzMzE2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAxMDM0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r466010347", "bodyText": "Exactly, the process is to write the variable number to a register and retrieve data from the register in return. Variable by variable.\nAt the moment the implementation will fetch all variables each refresh interval; one improvement could be to only fetch variables that are actually tied to an item. But so far when testing I didn't experience any particular delays (at least on my PC as well as on the Linux server running my PROD instance). Sure, some variable will take a little while to show a value in the sitemap, but I personally didn't mind so far...", "author": "bern77", "createdAt": "2020-08-05T21:19:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAzMzE2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIyOTc1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r466229757", "bodyText": "Yeah I would keep it simple if it performs \"well enough\".", "author": "ssalonen", "createdAt": "2020-08-06T08:19:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAzMzE2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3NDg4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r466574885", "bodyText": "Actually, ignore my last statement \ud83d\ude02\nI'm already just fetching the variables linked to an item...\nThinking about it, I'm wondering if simply introducing an additional delay before unlocking after a read transaction would have the same result as the throttling mechanism...\nBtw. your choice of variable name for the throttling is quite amusing for an Austrian \ud83d\ude09 (cf. https://www.dict.cc/german-english/Fut.html)", "author": "bern77", "createdAt": "2020-08-06T17:32:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAzMzE2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYwMjg4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r466602886", "bodyText": "I don't think it is a good idea to introduce any delays in Helios binding, after all delays are ensured by the transport bundle. Specifically, timeBetweenTransactionsMillis parameter of tcp thing is already ensuring delays between transactions.\nWhat I meant with throttling (as implemented in FMI weather) is slightly different. Instead of processing all refresh commands, we would wait for a while, e.g. 3 seconds, and combine all incoming refresh commands in this interval together and just make one operation to refresh the data.\nThe main use case with FMI is to make it more efficient to update the data when many/all channels receive the refresh command. Generic modbus binding has similar technique although implementation is quite different\nThe end result is quite different from a simple delay since we limit the amount of transactions.\nHowever, with Helios each channel corresponds to one write/read transaction, and similar optimization is not possible. I guess the best thing you can do is handle only the linked channels \ud83d\ude42", "author": "ssalonen", "createdAt": "2020-08-06T18:22:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAzMzE2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYwMzM2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r466603362", "bodyText": "Good to know about the fut \ud83d\ude05", "author": "ssalonen", "createdAt": "2020-08-06T18:23:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAzMzE2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI4OTgzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r491289831", "bodyText": "Thanks, then I'll leave the implementation as it is. If some users do experience issues I can still revisit this. But I wouldn't expect it to be honest.\nGlad I could help with my little 'lesson in Austrian' \ud83d\ude01", "author": "bern77", "createdAt": "2020-09-19T06:24:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAzMzE2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAzNDgyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r465034829", "bodyText": "scheduler.submit is a cleaner way to schedule a runnable to be executed immediately on the background, you can drop the other arguments", "author": "ssalonen", "createdAt": "2020-08-04T13:05:29Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,577 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    /**\r\n+     * Logger instance\r\n+     */\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    /**\r\n+     * Configuration instance\r\n+     */\r\n+    private HeliosEasyControlsConfiguration config;\r\n+\r\n+    /**\r\n+     * Used to poll the variables' status based on the configured refresh interval\r\n+     */\r\n+    private ScheduledFuture<?> pollingJob;\r\n+\r\n+    /**\r\n+     * The map holding the variable meta info by variable name\r\n+     */\r\n+    private Map<String, HeliosVariable> vMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private static ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore>();\r\n+\r\n+    /**\r\n+     * Communication interface to the endpoint\r\n+     */\r\n+    private ModbusCommunicationInterface comms;\r\n+\r\n+    /**\r\n+     * The date format used by the device\r\n+     */\r\n+    private int dateFormat = -1;\r\n+\r\n+    /**\r\n+     * Constructor\r\n+     *\r\n+     * @param thing\r\n+     * @param managerRef\r\n+     */\r\n+    public HeliosEasyControlsHandler(Thing thing) {\r\n+        super(thing);\r\n+    }\r\n+\r\n+    /**\r\n+     * Reads variable definitions from JSON file and store them in vMap\r\n+     */\r\n+    private void readVariableDefinition() {\r\n+        try {\r\n+            Gson gson = new Gson();\r\n+            Type vMapType = new TypeToken<Map<String, HeliosVariable>>() {\r\n+            }.getType();\r\n+            this.vMap = gson.fromJson(\r\n+                    new BufferedReader(new InputStreamReader(getClass()\r\n+                            .getResourceAsStream(HeliosEasyControlsBindingConstants.VARIABLES_DEFINITION_FILE))),\r\n+                    vMapType);\r\n+            // add the name to the variable itself\r\n+            for (Map.Entry<String, HeliosVariable> entry : this.vMap.entrySet()) {\r\n+                entry.getValue().setName(entry.getKey()); // workaround to set the variable name inside the\r\n+                                                          // HeliosVariable object\r\n+                if (!entry.getValue().isOk()) {\r\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\r\n+                            \"Variables definition file contains inconsistent data.\");\r\n+\r\n+                }\r\n+            }\r\n+        } catch (Exception e) {\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\r\n+                    \"Variables definition file not found or of illegal format.\");\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the endpoint handler from the bridge this handler is connected to\r\n+     * Checks that we're connected to the right type of bridge\r\n+     *\r\n+     * @return the endpoint handler or null if the bridge does not exist\r\n+     */\r\n+    private ModbusEndpointThingHandler getEndpointThingHandler() {\r\n+        Bridge bridge = getBridge();\r\n+        if (bridge == null) {\r\n+            logger.debug(\"Bridge is null\");\r\n+            return null;\r\n+        }\r\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\r\n+            logger.debug(\"Bridge is not online\");\r\n+            return null;\r\n+        }\r\n+\r\n+        ThingHandler handler = bridge.getHandler();\r\n+        if (handler == null) {\r\n+            logger.debug(\"Bridge handler is null\");\r\n+            return null;\r\n+        }\r\n+\r\n+        if (handler instanceof ModbusEndpointThingHandler) {\r\n+            return (ModbusEndpointThingHandler) handler;\r\n+        } else {\r\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\r\n+            return null;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get a reference to the modbus endpoint\r\n+     */\r\n+    private void connectEndpoint() {\r\n+        if (this.comms != null) {\r\n+            return;\r\n+        }\r\n+\r\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\r\n+        if (slaveEndpointThingHandler == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' is offline\", label));\r\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\r\n+            return;\r\n+        }\r\n+\r\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\r\n+\r\n+        if (comms == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\r\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\r\n+            return;\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void initialize() {\r\n+        this.config = getConfigAs(HeliosEasyControlsConfiguration.class);\r\n+        this.readVariableDefinition();\r\n+        this.connectEndpoint();\r\n+        if (this.comms != null) {\r\n+            HeliosEasyControlsHandler.transactionLocks.putIfAbsent(this.comms.getEndpoint(), new Semaphore(1, true));\r\n+            updateStatus(ThingStatus.UNKNOWN);\r\n+\r\n+            // background initialization\r\n+            scheduler.execute(() -> {\r\n+                try {\r\n+                    readValue(HeliosEasyControlsBindingConstants.DATE_FORMAT);\r\n+                    // status will be updated to ONLINE by the read callback function\r\n+                } catch (HeliosException e) {\r\n+                    logger.error(e.getMessage());\r\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\r\n+                }\r\n+            });\r\n+\r\n+            // poll for status updates regularly\r\n+            Runnable runnable = new Runnable() {\r\n+\r\n+                @Override\r\n+                public void run() {\r\n+                    for (Map.Entry<String, HeliosVariable> entry : vMap.entrySet()) {\r\n+                        if (isLinked(entry.getKey())\r\n+                                || (entry.getKey().equals(HeliosEasyControlsBindingConstants.DATE_FORMAT))) {\r\n+                            try {\r\n+                                readValue(entry.getKey());\r\n+                            } catch (HeliosException e) {\r\n+                                logger.error(e.getMessage());\r\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\r\n+                                        e.getMessage());\r\n+                            }\r\n+                        }\r\n+                    }\r\n+                }\r\n+            };\r\n+            this.pollingJob = scheduler.scheduleAtFixedRate(runnable, config.getRefreshInterval(),\r\n+                    config.getRefreshInterval(), TimeUnit.MILLISECONDS);\r\n+\r\n+        } else {\r\n+            logger.error(\"Modbus endpoint is null.\");\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void dispose() {\r\n+        if (this.pollingJob != null) {\r\n+            this.pollingJob.cancel(true);\r\n+        }\r\n+        this.comms = null;\r\n+    }\r\n+\r\n+    @Override\r\n+    public void handleCommand(ChannelUID channelUID, Command command) {\r\n+        String channelId = channelUID.getId();\r\n+        if (command instanceof RefreshType) {\r\n+            scheduler.schedule(new Runnable() {\r", "originalCommit": "73d8f576a176edc1b7c8f90549169819e7d5e410", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAzNTg1NA==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r465035854", "bodyText": "You might want to check the type? Just to avoid handling nonsense command types", "author": "ssalonen", "createdAt": "2020-08-04T13:07:06Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,577 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    /**\r\n+     * Logger instance\r\n+     */\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    /**\r\n+     * Configuration instance\r\n+     */\r\n+    private HeliosEasyControlsConfiguration config;\r\n+\r\n+    /**\r\n+     * Used to poll the variables' status based on the configured refresh interval\r\n+     */\r\n+    private ScheduledFuture<?> pollingJob;\r\n+\r\n+    /**\r\n+     * The map holding the variable meta info by variable name\r\n+     */\r\n+    private Map<String, HeliosVariable> vMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private static ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore>();\r\n+\r\n+    /**\r\n+     * Communication interface to the endpoint\r\n+     */\r\n+    private ModbusCommunicationInterface comms;\r\n+\r\n+    /**\r\n+     * The date format used by the device\r\n+     */\r\n+    private int dateFormat = -1;\r\n+\r\n+    /**\r\n+     * Constructor\r\n+     *\r\n+     * @param thing\r\n+     * @param managerRef\r\n+     */\r\n+    public HeliosEasyControlsHandler(Thing thing) {\r\n+        super(thing);\r\n+    }\r\n+\r\n+    /**\r\n+     * Reads variable definitions from JSON file and store them in vMap\r\n+     */\r\n+    private void readVariableDefinition() {\r\n+        try {\r\n+            Gson gson = new Gson();\r\n+            Type vMapType = new TypeToken<Map<String, HeliosVariable>>() {\r\n+            }.getType();\r\n+            this.vMap = gson.fromJson(\r\n+                    new BufferedReader(new InputStreamReader(getClass()\r\n+                            .getResourceAsStream(HeliosEasyControlsBindingConstants.VARIABLES_DEFINITION_FILE))),\r\n+                    vMapType);\r\n+            // add the name to the variable itself\r\n+            for (Map.Entry<String, HeliosVariable> entry : this.vMap.entrySet()) {\r\n+                entry.getValue().setName(entry.getKey()); // workaround to set the variable name inside the\r\n+                                                          // HeliosVariable object\r\n+                if (!entry.getValue().isOk()) {\r\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\r\n+                            \"Variables definition file contains inconsistent data.\");\r\n+\r\n+                }\r\n+            }\r\n+        } catch (Exception e) {\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\r\n+                    \"Variables definition file not found or of illegal format.\");\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the endpoint handler from the bridge this handler is connected to\r\n+     * Checks that we're connected to the right type of bridge\r\n+     *\r\n+     * @return the endpoint handler or null if the bridge does not exist\r\n+     */\r\n+    private ModbusEndpointThingHandler getEndpointThingHandler() {\r\n+        Bridge bridge = getBridge();\r\n+        if (bridge == null) {\r\n+            logger.debug(\"Bridge is null\");\r\n+            return null;\r\n+        }\r\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\r\n+            logger.debug(\"Bridge is not online\");\r\n+            return null;\r\n+        }\r\n+\r\n+        ThingHandler handler = bridge.getHandler();\r\n+        if (handler == null) {\r\n+            logger.debug(\"Bridge handler is null\");\r\n+            return null;\r\n+        }\r\n+\r\n+        if (handler instanceof ModbusEndpointThingHandler) {\r\n+            return (ModbusEndpointThingHandler) handler;\r\n+        } else {\r\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\r\n+            return null;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get a reference to the modbus endpoint\r\n+     */\r\n+    private void connectEndpoint() {\r\n+        if (this.comms != null) {\r\n+            return;\r\n+        }\r\n+\r\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\r\n+        if (slaveEndpointThingHandler == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' is offline\", label));\r\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\r\n+            return;\r\n+        }\r\n+\r\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\r\n+\r\n+        if (comms == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\r\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\r\n+            return;\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void initialize() {\r\n+        this.config = getConfigAs(HeliosEasyControlsConfiguration.class);\r\n+        this.readVariableDefinition();\r\n+        this.connectEndpoint();\r\n+        if (this.comms != null) {\r\n+            HeliosEasyControlsHandler.transactionLocks.putIfAbsent(this.comms.getEndpoint(), new Semaphore(1, true));\r\n+            updateStatus(ThingStatus.UNKNOWN);\r\n+\r\n+            // background initialization\r\n+            scheduler.execute(() -> {\r\n+                try {\r\n+                    readValue(HeliosEasyControlsBindingConstants.DATE_FORMAT);\r\n+                    // status will be updated to ONLINE by the read callback function\r\n+                } catch (HeliosException e) {\r\n+                    logger.error(e.getMessage());\r\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\r\n+                }\r\n+            });\r\n+\r\n+            // poll for status updates regularly\r\n+            Runnable runnable = new Runnable() {\r\n+\r\n+                @Override\r\n+                public void run() {\r\n+                    for (Map.Entry<String, HeliosVariable> entry : vMap.entrySet()) {\r\n+                        if (isLinked(entry.getKey())\r\n+                                || (entry.getKey().equals(HeliosEasyControlsBindingConstants.DATE_FORMAT))) {\r\n+                            try {\r\n+                                readValue(entry.getKey());\r\n+                            } catch (HeliosException e) {\r\n+                                logger.error(e.getMessage());\r\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\r\n+                                        e.getMessage());\r\n+                            }\r\n+                        }\r\n+                    }\r\n+                }\r\n+            };\r\n+            this.pollingJob = scheduler.scheduleAtFixedRate(runnable, config.getRefreshInterval(),\r\n+                    config.getRefreshInterval(), TimeUnit.MILLISECONDS);\r\n+\r\n+        } else {\r\n+            logger.error(\"Modbus endpoint is null.\");\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void dispose() {\r\n+        if (this.pollingJob != null) {\r\n+            this.pollingJob.cancel(true);\r\n+        }\r\n+        this.comms = null;\r\n+    }\r\n+\r\n+    @Override\r\n+    public void handleCommand(ChannelUID channelUID, Command command) {\r\n+        String channelId = channelUID.getId();\r\n+        if (command instanceof RefreshType) {\r\n+            scheduler.schedule(new Runnable() {\r\n+                @Override\r\n+                public void run() {\r\n+                    try {\r\n+                        readValue(channelId);\r\n+                    } catch (HeliosException e) {\r\n+                        logger.error(e.getMessage());\r\n+                    }\r\n+                }\r\n+            }, 0, TimeUnit.SECONDS);\r\n+        } else { // write command\r\n+            String value;\r\n+            if (command instanceof OnOffType) {\r\n+                value = command == OnOffType.ON ? \"1\" : \"0\";\r\n+            } else if (command instanceof DateTimeType) {\r\n+                value = formatDate(channelId, ((DateTimeType) command).getZonedDateTime());\r\n+            } else { // Number or String\r", "originalCommit": "73d8f576a176edc1b7c8f90549169819e7d5e410", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzMzk4OA==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r465133988", "bodyText": "Add NonnullByDefault per coding conventions", "author": "ssalonen", "createdAt": "2020-08-04T15:24:18Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsConfiguration.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsConfiguration} class contains fields mapping thing configuration parameters.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+public class HeliosEasyControlsConfiguration {\r", "originalCommit": "73d8f576a176edc1b7c8f90549169819e7d5e410", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzNDI4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r465134289", "bodyText": "NonNullByDefault", "author": "ssalonen", "createdAt": "2020-08-04T15:24:44Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandlerFactory.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import static org.openhab.binding.modbus.helioseasycontrols.internal.HeliosEasyControlsBindingConstants.THING_TYPE_HELIOS_VENTILATION_EASY_CONTROLS;\r\n+\r\n+import java.util.Collections;\r\n+import java.util.Set;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNull;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\r\n+import org.osgi.service.component.annotations.Component;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandlerFactory} is responsible for creating things and thing\r\n+ * handlers.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+@Component(configurationPid = \"binding.helioseasycontrols\", service = ThingHandlerFactory.class)\r\n+public class HeliosEasyControlsHandlerFactory extends BaseThingHandlerFactory {\r", "originalCommit": "73d8f576a176edc1b7c8f90549169819e7d5e410", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzNDUxMg==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r465134512", "bodyText": "NonnullByDefault", "author": "ssalonen", "createdAt": "2020-08-04T15:25:00Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosException.java", "diffHunk": "@@ -0,0 +1,10 @@\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\n+\n+public class HeliosException extends Exception {", "originalCommit": "73d8f576a176edc1b7c8f90549169819e7d5e410", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzNDU5OA==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r465134598", "bodyText": "NonnullByDefault", "author": "ssalonen", "createdAt": "2020-08-04T15:25:09Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosVariable.java", "diffHunk": "@@ -0,0 +1,298 @@\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\n+\n+/**\n+ * This class represents a variable of the Helios modbus.\n+ *\n+ * @author Bernhard Bauer - Initial contribution\n+ * @version 2.0\n+ */\n+public class HeliosVariable implements Comparable<HeliosVariable> {", "originalCommit": "73d8f576a176edc1b7c8f90549169819e7d5e410", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "86f42d3a5d2de1b69427d610051fe77fbbe46396", "url": "https://github.com/openhab/openhab-addons/commit/86f42d3a5d2de1b69427d610051fe77fbbe46396", "message": "Use UoM when writing to device\n\nSigned-off-by: Bernhard <bern77@gmail.com>", "committedDate": "2020-08-06T18:33:12Z", "type": "forcePushed"}, {"oid": "0df2ab2d0d560fed3667345ad86d566acb870512", "url": "https://github.com/openhab/openhab-addons/commit/0df2ab2d0d560fed3667345ad86d566acb870512", "message": "Discarded unwanted changes to other bindings\n\nSigned-off-by: Bernhard <bern77@gmail.com>", "committedDate": "2020-08-30T10:29:42Z", "type": "forcePushed"}, {"oid": "5e8ad2f12137c73d3a54209fbe1db00ab92971d4", "url": "https://github.com/openhab/openhab-addons/commit/5e8ad2f12137c73d3a54209fbe1db00ab92971d4", "message": "Discarded unwanted changes to other bindings\n\nSigned-off-by: Bernhard <bern77@gmail.com>", "committedDate": "2020-08-30T10:41:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxMjM1MA==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r479812350", "bodyText": "Are you aware that private fields don't need to be commented?", "author": "fwolter", "createdAt": "2020-08-30T20:30:17Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,684 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.nio.charset.StandardCharsets;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.QuantityType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\r\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.eclipse.smarthome.core.types.State;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+@NonNullByDefault\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    /**\r\n+     * Logger instance\r\n+     */\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r", "originalCommit": "a29484f182958feae2d73f3ac06490316afc5798", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxMjQ4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r479812486", "bodyText": "Better write the field name out.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @Nullable Map<String, HeliosVariable> vMap;\n          \n          \n            \n                private @Nullable Map<String, HeliosVariable> variableMap;", "author": "fwolter", "createdAt": "2020-08-30T20:31:27Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,684 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.nio.charset.StandardCharsets;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.QuantityType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\r\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.eclipse.smarthome.core.types.State;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+@NonNullByDefault\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    /**\r\n+     * Logger instance\r\n+     */\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    /**\r\n+     * Configuration instance\r\n+     */\r\n+    private @Nullable HeliosEasyControlsConfiguration config;\r\n+\r\n+    /**\r\n+     * Used to poll the variables' status based on the configured refresh interval\r\n+     */\r\n+    private @Nullable ScheduledFuture<?> pollingJob;\r\n+\r\n+    /**\r\n+     * The map holding the variable meta info by variable name\r\n+     */\r\n+    private @Nullable Map<String, HeliosVariable> vMap;\r", "originalCommit": "a29484f182958feae2d73f3ac06490316afc5798", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxMjUyMw==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r479812523", "bodyText": "Syntactical sugar\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore>();\n          \n          \n            \n                private static ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<>();", "author": "fwolter", "createdAt": "2020-08-30T20:31:54Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,684 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.nio.charset.StandardCharsets;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.QuantityType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\r\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.eclipse.smarthome.core.types.State;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+@NonNullByDefault\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    /**\r\n+     * Logger instance\r\n+     */\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    /**\r\n+     * Configuration instance\r\n+     */\r\n+    private @Nullable HeliosEasyControlsConfiguration config;\r\n+\r\n+    /**\r\n+     * Used to poll the variables' status based on the configured refresh interval\r\n+     */\r\n+    private @Nullable ScheduledFuture<?> pollingJob;\r\n+\r\n+    /**\r\n+     * The map holding the variable meta info by variable name\r\n+     */\r\n+    private @Nullable Map<String, HeliosVariable> vMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private static ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore>();\r", "originalCommit": "a29484f182958feae2d73f3ac06490316afc5798", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxMjY0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r479812649", "bodyText": "It's good practice to use base type.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore>();\n          \n          \n            \n                private static Map<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore>();", "author": "fwolter", "createdAt": "2020-08-30T20:33:50Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,684 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.nio.charset.StandardCharsets;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.QuantityType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\r\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.eclipse.smarthome.core.types.State;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+@NonNullByDefault\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    /**\r\n+     * Logger instance\r\n+     */\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    /**\r\n+     * Configuration instance\r\n+     */\r\n+    private @Nullable HeliosEasyControlsConfiguration config;\r\n+\r\n+    /**\r\n+     * Used to poll the variables' status based on the configured refresh interval\r\n+     */\r\n+    private @Nullable ScheduledFuture<?> pollingJob;\r\n+\r\n+    /**\r\n+     * The map holding the variable meta info by variable name\r\n+     */\r\n+    private @Nullable Map<String, HeliosVariable> vMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private static ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore>();\r", "originalCommit": "a29484f182958feae2d73f3ac06490316afc5798", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxMjczNA==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r479812734", "bodyText": "Is this static by intention? What happens if the user creates more than one Thing of this type?", "author": "fwolter", "createdAt": "2020-08-30T20:34:39Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,684 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.nio.charset.StandardCharsets;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.QuantityType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\r\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.eclipse.smarthome.core.types.State;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+@NonNullByDefault\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    /**\r\n+     * Logger instance\r\n+     */\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    /**\r\n+     * Configuration instance\r\n+     */\r\n+    private @Nullable HeliosEasyControlsConfiguration config;\r\n+\r\n+    /**\r\n+     * Used to poll the variables' status based on the configured refresh interval\r\n+     */\r\n+    private @Nullable ScheduledFuture<?> pollingJob;\r\n+\r\n+    /**\r\n+     * The map holding the variable meta info by variable name\r\n+     */\r\n+    private @Nullable Map<String, HeliosVariable> vMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private static ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore>();\r", "originalCommit": "a29484f182958feae2d73f3ac06490316afc5798", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxMjc1NA==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r479812754", "bodyText": "This field is never used", "author": "fwolter", "createdAt": "2020-08-30T20:34:59Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,684 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.nio.charset.StandardCharsets;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.QuantityType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\r\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.eclipse.smarthome.core.types.State;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+@NonNullByDefault\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    /**\r\n+     * Logger instance\r\n+     */\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    /**\r\n+     * Configuration instance\r\n+     */\r\n+    private @Nullable HeliosEasyControlsConfiguration config;\r\n+\r\n+    /**\r\n+     * Used to poll the variables' status based on the configured refresh interval\r\n+     */\r\n+    private @Nullable ScheduledFuture<?> pollingJob;\r\n+\r\n+    /**\r\n+     * The map holding the variable meta info by variable name\r\n+     */\r\n+    private @Nullable Map<String, HeliosVariable> vMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private static ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore>();\r\n+\r\n+    /**\r\n+     * Communication interface to the endpoint\r\n+     */\r\n+    private @Nullable ModbusCommunicationInterface comms;\r\n+\r\n+    /**\r\n+     * The date format used by the device\r\n+     */\r\n+    private int dateFormat = -1;\r\n+\r\n+    /**\r\n+     * The UTC offset of the device\r\n+     */\r\n+    private int utcOffset = 0;\r", "originalCommit": "a29484f182958feae2d73f3ac06490316afc5798", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA4OTk0OA==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r484089948", "bodyText": "I planned to make setting the date and time somewhat more comfortable but didn't get further than that so far ;)", "author": "bern77", "createdAt": "2020-09-06T16:34:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxMjc1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxMjg2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r479812861", "bodyText": "Constructors don't need to be commented either.", "author": "fwolter", "createdAt": "2020-08-30T20:35:50Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,684 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.nio.charset.StandardCharsets;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.QuantityType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\r\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.eclipse.smarthome.core.types.State;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+@NonNullByDefault\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    /**\r\n+     * Logger instance\r\n+     */\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    /**\r\n+     * Configuration instance\r\n+     */\r\n+    private @Nullable HeliosEasyControlsConfiguration config;\r\n+\r\n+    /**\r\n+     * Used to poll the variables' status based on the configured refresh interval\r\n+     */\r\n+    private @Nullable ScheduledFuture<?> pollingJob;\r\n+\r\n+    /**\r\n+     * The map holding the variable meta info by variable name\r\n+     */\r\n+    private @Nullable Map<String, HeliosVariable> vMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private static ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore>();\r\n+\r\n+    /**\r\n+     * Communication interface to the endpoint\r\n+     */\r\n+    private @Nullable ModbusCommunicationInterface comms;\r\n+\r\n+    /**\r\n+     * The date format used by the device\r\n+     */\r\n+    private int dateFormat = -1;\r\n+\r\n+    /**\r\n+     * The UTC offset of the device\r\n+     */\r\n+    private int utcOffset = 0;\r\n+\r\n+    /**\r\n+     * Constructor\r\n+     *\r\n+     * @param thing\r\n+     * @param managerRef\r\n+     */\r\n+    public HeliosEasyControlsHandler(Thing thing) {\r", "originalCommit": "a29484f182958feae2d73f3ac06490316afc5798", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxMjg5MA==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r479812890", "bodyText": "Can you make this a field to save resources?", "author": "fwolter", "createdAt": "2020-08-30T20:36:12Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,684 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.nio.charset.StandardCharsets;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.QuantityType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\r\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.eclipse.smarthome.core.types.State;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+@NonNullByDefault\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    /**\r\n+     * Logger instance\r\n+     */\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    /**\r\n+     * Configuration instance\r\n+     */\r\n+    private @Nullable HeliosEasyControlsConfiguration config;\r\n+\r\n+    /**\r\n+     * Used to poll the variables' status based on the configured refresh interval\r\n+     */\r\n+    private @Nullable ScheduledFuture<?> pollingJob;\r\n+\r\n+    /**\r\n+     * The map holding the variable meta info by variable name\r\n+     */\r\n+    private @Nullable Map<String, HeliosVariable> vMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private static ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore>();\r\n+\r\n+    /**\r\n+     * Communication interface to the endpoint\r\n+     */\r\n+    private @Nullable ModbusCommunicationInterface comms;\r\n+\r\n+    /**\r\n+     * The date format used by the device\r\n+     */\r\n+    private int dateFormat = -1;\r\n+\r\n+    /**\r\n+     * The UTC offset of the device\r\n+     */\r\n+    private int utcOffset = 0;\r\n+\r\n+    /**\r\n+     * Constructor\r\n+     *\r\n+     * @param thing\r\n+     * @param managerRef\r\n+     */\r\n+    public HeliosEasyControlsHandler(Thing thing) {\r\n+        super(thing);\r\n+    }\r\n+\r\n+    /**\r\n+     * Reads variable definitions from JSON file and store them in vMap\r\n+     */\r\n+    private void readVariableDefinition() {\r\n+        Gson gson = new Gson();\r", "originalCommit": "a29484f182958feae2d73f3ac06490316afc5798", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5MDI0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r484090243", "bodyText": "Sorry, I'm afraid I don't know what you mean exactly. I need to parse a JSON file for the variable settings and thought Gson is the preferred library for that in the OH framework?", "author": "bern77", "createdAt": "2020-09-06T16:38:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxMjg5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5MDU0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r484090549", "bodyText": "The Gson object is created everytime the method is invoked. To save resources, you can instantiate the object once in a class field (private member).", "author": "fwolter", "createdAt": "2020-09-06T16:41:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxMjg5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5MDc2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r484090761", "bodyText": "Ah, thanks - sure, makes sense \ud83d\ude0a", "author": "bern77", "createdAt": "2020-09-06T16:44:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxMjg5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxMjk2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r479812963", "bodyText": "You need to close these readers when you are finished. You could use Java's auto closable feature.", "author": "fwolter", "createdAt": "2020-08-30T20:37:20Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,684 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.nio.charset.StandardCharsets;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.QuantityType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\r\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.eclipse.smarthome.core.types.State;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+@NonNullByDefault\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    /**\r\n+     * Logger instance\r\n+     */\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    /**\r\n+     * Configuration instance\r\n+     */\r\n+    private @Nullable HeliosEasyControlsConfiguration config;\r\n+\r\n+    /**\r\n+     * Used to poll the variables' status based on the configured refresh interval\r\n+     */\r\n+    private @Nullable ScheduledFuture<?> pollingJob;\r\n+\r\n+    /**\r\n+     * The map holding the variable meta info by variable name\r\n+     */\r\n+    private @Nullable Map<String, HeliosVariable> vMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private static ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore>();\r\n+\r\n+    /**\r\n+     * Communication interface to the endpoint\r\n+     */\r\n+    private @Nullable ModbusCommunicationInterface comms;\r\n+\r\n+    /**\r\n+     * The date format used by the device\r\n+     */\r\n+    private int dateFormat = -1;\r\n+\r\n+    /**\r\n+     * The UTC offset of the device\r\n+     */\r\n+    private int utcOffset = 0;\r\n+\r\n+    /**\r\n+     * Constructor\r\n+     *\r\n+     * @param thing\r\n+     * @param managerRef\r\n+     */\r\n+    public HeliosEasyControlsHandler(Thing thing) {\r\n+        super(thing);\r\n+    }\r\n+\r\n+    /**\r\n+     * Reads variable definitions from JSON file and store them in vMap\r\n+     */\r\n+    private void readVariableDefinition() {\r\n+        Gson gson = new Gson();\r\n+        Type vMapType = new TypeToken<Map<String, HeliosVariable>>() {\r\n+        }.getType();\r\n+        this.vMap = gson.fromJson(\r\n+                new BufferedReader(new InputStreamReader(\r\n+                        getClass().getResourceAsStream(HeliosEasyControlsBindingConstants.VARIABLES_DEFINITION_FILE))),\r", "originalCommit": "a29484f182958feae2d73f3ac06490316afc5798", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxMzk2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r479813966", "bodyText": "Better use scheduleWithFixedDelay(). See https://www.openhab.org/docs/developer/guidelines.html#e-runtime-behavior point 2", "author": "fwolter", "createdAt": "2020-08-30T20:48:29Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,684 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.nio.charset.StandardCharsets;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.QuantityType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\r\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.eclipse.smarthome.core.types.State;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+@NonNullByDefault\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    /**\r\n+     * Logger instance\r\n+     */\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    /**\r\n+     * Configuration instance\r\n+     */\r\n+    private @Nullable HeliosEasyControlsConfiguration config;\r\n+\r\n+    /**\r\n+     * Used to poll the variables' status based on the configured refresh interval\r\n+     */\r\n+    private @Nullable ScheduledFuture<?> pollingJob;\r\n+\r\n+    /**\r\n+     * The map holding the variable meta info by variable name\r\n+     */\r\n+    private @Nullable Map<String, HeliosVariable> vMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private static ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore>();\r\n+\r\n+    /**\r\n+     * Communication interface to the endpoint\r\n+     */\r\n+    private @Nullable ModbusCommunicationInterface comms;\r\n+\r\n+    /**\r\n+     * The date format used by the device\r\n+     */\r\n+    private int dateFormat = -1;\r\n+\r\n+    /**\r\n+     * The UTC offset of the device\r\n+     */\r\n+    private int utcOffset = 0;\r\n+\r\n+    /**\r\n+     * Constructor\r\n+     *\r\n+     * @param thing\r\n+     * @param managerRef\r\n+     */\r\n+    public HeliosEasyControlsHandler(Thing thing) {\r\n+        super(thing);\r\n+    }\r\n+\r\n+    /**\r\n+     * Reads variable definitions from JSON file and store them in vMap\r\n+     */\r\n+    private void readVariableDefinition() {\r\n+        Gson gson = new Gson();\r\n+        Type vMapType = new TypeToken<Map<String, HeliosVariable>>() {\r\n+        }.getType();\r\n+        this.vMap = gson.fromJson(\r\n+                new BufferedReader(new InputStreamReader(\r\n+                        getClass().getResourceAsStream(HeliosEasyControlsBindingConstants.VARIABLES_DEFINITION_FILE))),\r\n+                vMapType);\r\n+        if (vMap != null) {\r\n+            // add the name to the variable itself\r\n+            for (Map.Entry<String, HeliosVariable> entry : this.vMap.entrySet()) {\r\n+                entry.getValue().setName(entry.getKey()); // workaround to set the variable name inside the\r\n+                                                          // HeliosVariable object\r\n+                if (!entry.getValue().isOk()) {\r\n+                    this.handleError(\"Variables definition file contains inconsistent data.\",\r\n+                            ThingStatusDetail.CONFIGURATION_ERROR);\r\n+                }\r\n+            }\r\n+        } else {\r\n+            this.handleError(\"Variables definition file not found or of illegal format.\",\r\n+                    ThingStatusDetail.CONFIGURATION_ERROR);\r\n+        }\r\n+\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the endpoint handler from the bridge this handler is connected to\r\n+     * Checks that we're connected to the right type of bridge\r\n+     *\r\n+     * @return the endpoint handler or null if the bridge does not exist\r\n+     */\r\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\r\n+        Bridge bridge = getBridge();\r\n+        if (bridge == null) {\r\n+            logger.debug(\"Bridge is null\");\r\n+            return null;\r\n+        }\r\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\r\n+            logger.debug(\"Bridge is not online\");\r\n+            return null;\r\n+        }\r\n+\r\n+        ThingHandler handler = bridge.getHandler();\r\n+        if (handler == null) {\r\n+            logger.debug(\"Bridge handler is null\");\r\n+            return null;\r\n+        }\r\n+\r\n+        if (handler instanceof ModbusEndpointThingHandler) {\r\n+            return (ModbusEndpointThingHandler) handler;\r\n+        } else {\r\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\r\n+            return null;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get a reference to the modbus endpoint\r\n+     */\r\n+    private void connectEndpoint() {\r\n+        if (this.comms != null) {\r\n+            return;\r\n+        }\r\n+\r\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\r\n+        if (slaveEndpointThingHandler == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' is offline\", label));\r\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\r\n+            return;\r\n+        }\r\n+\r\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\r\n+\r\n+        if (comms == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\r\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\r\n+            return;\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void initialize() {\r\n+        this.config = getConfigAs(HeliosEasyControlsConfiguration.class);\r\n+        this.readVariableDefinition();\r\n+        this.connectEndpoint();\r\n+        if ((this.comms != null) && (this.vMap != null) && (this.config != null)) {\r\n+            HeliosEasyControlsHandler.transactionLocks.putIfAbsent(this.comms.getEndpoint(), new Semaphore(1, true));\r\n+            updateStatus(ThingStatus.UNKNOWN);\r\n+\r\n+            // background initialization\r\n+            scheduler.execute(() -> {\r\n+                readValue(HeliosEasyControlsBindingConstants.DATE_FORMAT);\r\n+                // status will be updated to ONLINE by the read callback function (via processResponse)\r\n+            });\r\n+\r\n+            // poll for status updates regularly\r\n+            Runnable runnable = new Runnable() {\r\n+\r\n+                @Override\r\n+                public void run() {\r\n+                    if (vMap != null) {\r\n+                        for (Map.Entry<String, HeliosVariable> entry : vMap.entrySet()) {\r\n+                            if (isLinked(entry.getKey())\r\n+                                    || (entry.getKey().equals(HeliosEasyControlsBindingConstants.DATE_FORMAT))\r\n+                                    || (entry.getKey()\r\n+                                            .equals(HeliosEasyControlsBindingConstants.TIME_ZONE_DIFFERENCE_TO_GMT))) {\r\n+                                readValue(entry.getKey());\r\n+                            }\r\n+                        }\r\n+\r\n+                    } else {\r\n+                        handleError(\"Variable definition is null\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+                    }\r\n+                }\r\n+            };\r\n+            this.pollingJob = scheduler.scheduleAtFixedRate(runnable, this.config.getRefreshInterval(),\r", "originalCommit": "a29484f182958feae2d73f3ac06490316afc5798", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxNDA0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r479814045", "bodyText": "You can eliminate the compiler warning by storing the config to a local variable and do a null check on that. Same for the vMap occurrences.", "author": "fwolter", "createdAt": "2020-08-30T20:49:20Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,684 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.nio.charset.StandardCharsets;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.QuantityType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\r\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.eclipse.smarthome.core.types.State;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+@NonNullByDefault\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    /**\r\n+     * Logger instance\r\n+     */\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    /**\r\n+     * Configuration instance\r\n+     */\r\n+    private @Nullable HeliosEasyControlsConfiguration config;\r\n+\r\n+    /**\r\n+     * Used to poll the variables' status based on the configured refresh interval\r\n+     */\r\n+    private @Nullable ScheduledFuture<?> pollingJob;\r\n+\r\n+    /**\r\n+     * The map holding the variable meta info by variable name\r\n+     */\r\n+    private @Nullable Map<String, HeliosVariable> vMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private static ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore>();\r\n+\r\n+    /**\r\n+     * Communication interface to the endpoint\r\n+     */\r\n+    private @Nullable ModbusCommunicationInterface comms;\r\n+\r\n+    /**\r\n+     * The date format used by the device\r\n+     */\r\n+    private int dateFormat = -1;\r\n+\r\n+    /**\r\n+     * The UTC offset of the device\r\n+     */\r\n+    private int utcOffset = 0;\r\n+\r\n+    /**\r\n+     * Constructor\r\n+     *\r\n+     * @param thing\r\n+     * @param managerRef\r\n+     */\r\n+    public HeliosEasyControlsHandler(Thing thing) {\r\n+        super(thing);\r\n+    }\r\n+\r\n+    /**\r\n+     * Reads variable definitions from JSON file and store them in vMap\r\n+     */\r\n+    private void readVariableDefinition() {\r\n+        Gson gson = new Gson();\r\n+        Type vMapType = new TypeToken<Map<String, HeliosVariable>>() {\r\n+        }.getType();\r\n+        this.vMap = gson.fromJson(\r\n+                new BufferedReader(new InputStreamReader(\r\n+                        getClass().getResourceAsStream(HeliosEasyControlsBindingConstants.VARIABLES_DEFINITION_FILE))),\r\n+                vMapType);\r\n+        if (vMap != null) {\r\n+            // add the name to the variable itself\r\n+            for (Map.Entry<String, HeliosVariable> entry : this.vMap.entrySet()) {\r\n+                entry.getValue().setName(entry.getKey()); // workaround to set the variable name inside the\r\n+                                                          // HeliosVariable object\r\n+                if (!entry.getValue().isOk()) {\r\n+                    this.handleError(\"Variables definition file contains inconsistent data.\",\r\n+                            ThingStatusDetail.CONFIGURATION_ERROR);\r\n+                }\r\n+            }\r\n+        } else {\r\n+            this.handleError(\"Variables definition file not found or of illegal format.\",\r\n+                    ThingStatusDetail.CONFIGURATION_ERROR);\r\n+        }\r\n+\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the endpoint handler from the bridge this handler is connected to\r\n+     * Checks that we're connected to the right type of bridge\r\n+     *\r\n+     * @return the endpoint handler or null if the bridge does not exist\r\n+     */\r\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\r\n+        Bridge bridge = getBridge();\r\n+        if (bridge == null) {\r\n+            logger.debug(\"Bridge is null\");\r\n+            return null;\r\n+        }\r\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\r\n+            logger.debug(\"Bridge is not online\");\r\n+            return null;\r\n+        }\r\n+\r\n+        ThingHandler handler = bridge.getHandler();\r\n+        if (handler == null) {\r\n+            logger.debug(\"Bridge handler is null\");\r\n+            return null;\r\n+        }\r\n+\r\n+        if (handler instanceof ModbusEndpointThingHandler) {\r\n+            return (ModbusEndpointThingHandler) handler;\r\n+        } else {\r\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\r\n+            return null;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get a reference to the modbus endpoint\r\n+     */\r\n+    private void connectEndpoint() {\r\n+        if (this.comms != null) {\r\n+            return;\r\n+        }\r\n+\r\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\r\n+        if (slaveEndpointThingHandler == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' is offline\", label));\r\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\r\n+            return;\r\n+        }\r\n+\r\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\r\n+\r\n+        if (comms == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\r\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\r\n+            return;\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void initialize() {\r\n+        this.config = getConfigAs(HeliosEasyControlsConfiguration.class);\r\n+        this.readVariableDefinition();\r\n+        this.connectEndpoint();\r\n+        if ((this.comms != null) && (this.vMap != null) && (this.config != null)) {\r\n+            HeliosEasyControlsHandler.transactionLocks.putIfAbsent(this.comms.getEndpoint(), new Semaphore(1, true));\r\n+            updateStatus(ThingStatus.UNKNOWN);\r\n+\r\n+            // background initialization\r\n+            scheduler.execute(() -> {\r\n+                readValue(HeliosEasyControlsBindingConstants.DATE_FORMAT);\r\n+                // status will be updated to ONLINE by the read callback function (via processResponse)\r\n+            });\r\n+\r\n+            // poll for status updates regularly\r\n+            Runnable runnable = new Runnable() {\r\n+\r\n+                @Override\r\n+                public void run() {\r\n+                    if (vMap != null) {\r\n+                        for (Map.Entry<String, HeliosVariable> entry : vMap.entrySet()) {\r\n+                            if (isLinked(entry.getKey())\r\n+                                    || (entry.getKey().equals(HeliosEasyControlsBindingConstants.DATE_FORMAT))\r\n+                                    || (entry.getKey()\r\n+                                            .equals(HeliosEasyControlsBindingConstants.TIME_ZONE_DIFFERENCE_TO_GMT))) {\r\n+                                readValue(entry.getKey());\r\n+                            }\r\n+                        }\r\n+\r\n+                    } else {\r\n+                        handleError(\"Variable definition is null\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+                    }\r\n+                }\r\n+            };\r\n+            this.pollingJob = scheduler.scheduleAtFixedRate(runnable, this.config.getRefreshInterval(),\r\n+                    this.config.getRefreshInterval(), TimeUnit.MILLISECONDS);\r", "originalCommit": "a29484f182958feae2d73f3ac06490316afc5798", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxNDE3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r479814179", "bodyText": "It's uncommon to end the error message with a period.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            this.handleError(\"Modbus communication interface is unavailable.\",\n          \n          \n            \n                            this.handleError(\"Modbus communication interface is unavailable\",", "author": "fwolter", "createdAt": "2020-08-30T20:50:36Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,684 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.nio.charset.StandardCharsets;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.QuantityType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\r\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.eclipse.smarthome.core.types.State;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+@NonNullByDefault\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    /**\r\n+     * Logger instance\r\n+     */\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    /**\r\n+     * Configuration instance\r\n+     */\r\n+    private @Nullable HeliosEasyControlsConfiguration config;\r\n+\r\n+    /**\r\n+     * Used to poll the variables' status based on the configured refresh interval\r\n+     */\r\n+    private @Nullable ScheduledFuture<?> pollingJob;\r\n+\r\n+    /**\r\n+     * The map holding the variable meta info by variable name\r\n+     */\r\n+    private @Nullable Map<String, HeliosVariable> vMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private static ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore>();\r\n+\r\n+    /**\r\n+     * Communication interface to the endpoint\r\n+     */\r\n+    private @Nullable ModbusCommunicationInterface comms;\r\n+\r\n+    /**\r\n+     * The date format used by the device\r\n+     */\r\n+    private int dateFormat = -1;\r\n+\r\n+    /**\r\n+     * The UTC offset of the device\r\n+     */\r\n+    private int utcOffset = 0;\r\n+\r\n+    /**\r\n+     * Constructor\r\n+     *\r\n+     * @param thing\r\n+     * @param managerRef\r\n+     */\r\n+    public HeliosEasyControlsHandler(Thing thing) {\r\n+        super(thing);\r\n+    }\r\n+\r\n+    /**\r\n+     * Reads variable definitions from JSON file and store them in vMap\r\n+     */\r\n+    private void readVariableDefinition() {\r\n+        Gson gson = new Gson();\r\n+        Type vMapType = new TypeToken<Map<String, HeliosVariable>>() {\r\n+        }.getType();\r\n+        this.vMap = gson.fromJson(\r\n+                new BufferedReader(new InputStreamReader(\r\n+                        getClass().getResourceAsStream(HeliosEasyControlsBindingConstants.VARIABLES_DEFINITION_FILE))),\r\n+                vMapType);\r\n+        if (vMap != null) {\r\n+            // add the name to the variable itself\r\n+            for (Map.Entry<String, HeliosVariable> entry : this.vMap.entrySet()) {\r\n+                entry.getValue().setName(entry.getKey()); // workaround to set the variable name inside the\r\n+                                                          // HeliosVariable object\r\n+                if (!entry.getValue().isOk()) {\r\n+                    this.handleError(\"Variables definition file contains inconsistent data.\",\r\n+                            ThingStatusDetail.CONFIGURATION_ERROR);\r\n+                }\r\n+            }\r\n+        } else {\r\n+            this.handleError(\"Variables definition file not found or of illegal format.\",\r\n+                    ThingStatusDetail.CONFIGURATION_ERROR);\r\n+        }\r\n+\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the endpoint handler from the bridge this handler is connected to\r\n+     * Checks that we're connected to the right type of bridge\r\n+     *\r\n+     * @return the endpoint handler or null if the bridge does not exist\r\n+     */\r\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\r\n+        Bridge bridge = getBridge();\r\n+        if (bridge == null) {\r\n+            logger.debug(\"Bridge is null\");\r\n+            return null;\r\n+        }\r\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\r\n+            logger.debug(\"Bridge is not online\");\r\n+            return null;\r\n+        }\r\n+\r\n+        ThingHandler handler = bridge.getHandler();\r\n+        if (handler == null) {\r\n+            logger.debug(\"Bridge handler is null\");\r\n+            return null;\r\n+        }\r\n+\r\n+        if (handler instanceof ModbusEndpointThingHandler) {\r\n+            return (ModbusEndpointThingHandler) handler;\r\n+        } else {\r\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\r\n+            return null;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get a reference to the modbus endpoint\r\n+     */\r\n+    private void connectEndpoint() {\r\n+        if (this.comms != null) {\r\n+            return;\r\n+        }\r\n+\r\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\r\n+        if (slaveEndpointThingHandler == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' is offline\", label));\r\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\r\n+            return;\r\n+        }\r\n+\r\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\r\n+\r\n+        if (comms == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\r\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\r\n+            return;\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void initialize() {\r\n+        this.config = getConfigAs(HeliosEasyControlsConfiguration.class);\r\n+        this.readVariableDefinition();\r\n+        this.connectEndpoint();\r\n+        if ((this.comms != null) && (this.vMap != null) && (this.config != null)) {\r\n+            HeliosEasyControlsHandler.transactionLocks.putIfAbsent(this.comms.getEndpoint(), new Semaphore(1, true));\r\n+            updateStatus(ThingStatus.UNKNOWN);\r\n+\r\n+            // background initialization\r\n+            scheduler.execute(() -> {\r\n+                readValue(HeliosEasyControlsBindingConstants.DATE_FORMAT);\r\n+                // status will be updated to ONLINE by the read callback function (via processResponse)\r\n+            });\r\n+\r\n+            // poll for status updates regularly\r\n+            Runnable runnable = new Runnable() {\r\n+\r\n+                @Override\r\n+                public void run() {\r\n+                    if (vMap != null) {\r\n+                        for (Map.Entry<String, HeliosVariable> entry : vMap.entrySet()) {\r\n+                            if (isLinked(entry.getKey())\r\n+                                    || (entry.getKey().equals(HeliosEasyControlsBindingConstants.DATE_FORMAT))\r\n+                                    || (entry.getKey()\r\n+                                            .equals(HeliosEasyControlsBindingConstants.TIME_ZONE_DIFFERENCE_TO_GMT))) {\r\n+                                readValue(entry.getKey());\r\n+                            }\r\n+                        }\r\n+\r\n+                    } else {\r\n+                        handleError(\"Variable definition is null\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+                    }\r\n+                }\r\n+            };\r\n+            this.pollingJob = scheduler.scheduleAtFixedRate(runnable, this.config.getRefreshInterval(),\r\n+                    this.config.getRefreshInterval(), TimeUnit.MILLISECONDS);\r\n+\r\n+        } else { // at least one null assertion has failed, let's log the problem and update the thing status\r\n+            if (this.comms == null) {\r\n+                this.handleError(\"Modbus communication interface is unavailable.\",\r", "originalCommit": "a29484f182958feae2d73f3ac06490316afc5798", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxNDMwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r479814305", "bodyText": "Syntactical sugar. Same for below.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        scheduler.submit(new Runnable() {\n          \n          \n            \n                            @Override\n          \n          \n            \n                            public void run() {\n          \n          \n            \n                                readValue(channelId);\n          \n          \n            \n                            }\n          \n          \n            \n                        });\n          \n          \n            \n                        scheduler.submit(() -> readValue(channelId));", "author": "fwolter", "createdAt": "2020-08-30T20:51:39Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,684 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.nio.charset.StandardCharsets;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.QuantityType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\r\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.eclipse.smarthome.core.types.State;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+@NonNullByDefault\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    /**\r\n+     * Logger instance\r\n+     */\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    /**\r\n+     * Configuration instance\r\n+     */\r\n+    private @Nullable HeliosEasyControlsConfiguration config;\r\n+\r\n+    /**\r\n+     * Used to poll the variables' status based on the configured refresh interval\r\n+     */\r\n+    private @Nullable ScheduledFuture<?> pollingJob;\r\n+\r\n+    /**\r\n+     * The map holding the variable meta info by variable name\r\n+     */\r\n+    private @Nullable Map<String, HeliosVariable> vMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private static ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore>();\r\n+\r\n+    /**\r\n+     * Communication interface to the endpoint\r\n+     */\r\n+    private @Nullable ModbusCommunicationInterface comms;\r\n+\r\n+    /**\r\n+     * The date format used by the device\r\n+     */\r\n+    private int dateFormat = -1;\r\n+\r\n+    /**\r\n+     * The UTC offset of the device\r\n+     */\r\n+    private int utcOffset = 0;\r\n+\r\n+    /**\r\n+     * Constructor\r\n+     *\r\n+     * @param thing\r\n+     * @param managerRef\r\n+     */\r\n+    public HeliosEasyControlsHandler(Thing thing) {\r\n+        super(thing);\r\n+    }\r\n+\r\n+    /**\r\n+     * Reads variable definitions from JSON file and store them in vMap\r\n+     */\r\n+    private void readVariableDefinition() {\r\n+        Gson gson = new Gson();\r\n+        Type vMapType = new TypeToken<Map<String, HeliosVariable>>() {\r\n+        }.getType();\r\n+        this.vMap = gson.fromJson(\r\n+                new BufferedReader(new InputStreamReader(\r\n+                        getClass().getResourceAsStream(HeliosEasyControlsBindingConstants.VARIABLES_DEFINITION_FILE))),\r\n+                vMapType);\r\n+        if (vMap != null) {\r\n+            // add the name to the variable itself\r\n+            for (Map.Entry<String, HeliosVariable> entry : this.vMap.entrySet()) {\r\n+                entry.getValue().setName(entry.getKey()); // workaround to set the variable name inside the\r\n+                                                          // HeliosVariable object\r\n+                if (!entry.getValue().isOk()) {\r\n+                    this.handleError(\"Variables definition file contains inconsistent data.\",\r\n+                            ThingStatusDetail.CONFIGURATION_ERROR);\r\n+                }\r\n+            }\r\n+        } else {\r\n+            this.handleError(\"Variables definition file not found or of illegal format.\",\r\n+                    ThingStatusDetail.CONFIGURATION_ERROR);\r\n+        }\r\n+\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the endpoint handler from the bridge this handler is connected to\r\n+     * Checks that we're connected to the right type of bridge\r\n+     *\r\n+     * @return the endpoint handler or null if the bridge does not exist\r\n+     */\r\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\r\n+        Bridge bridge = getBridge();\r\n+        if (bridge == null) {\r\n+            logger.debug(\"Bridge is null\");\r\n+            return null;\r\n+        }\r\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\r\n+            logger.debug(\"Bridge is not online\");\r\n+            return null;\r\n+        }\r\n+\r\n+        ThingHandler handler = bridge.getHandler();\r\n+        if (handler == null) {\r\n+            logger.debug(\"Bridge handler is null\");\r\n+            return null;\r\n+        }\r\n+\r\n+        if (handler instanceof ModbusEndpointThingHandler) {\r\n+            return (ModbusEndpointThingHandler) handler;\r\n+        } else {\r\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\r\n+            return null;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get a reference to the modbus endpoint\r\n+     */\r\n+    private void connectEndpoint() {\r\n+        if (this.comms != null) {\r\n+            return;\r\n+        }\r\n+\r\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\r\n+        if (slaveEndpointThingHandler == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' is offline\", label));\r\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\r\n+            return;\r\n+        }\r\n+\r\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\r\n+\r\n+        if (comms == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\r\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\r\n+            return;\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void initialize() {\r\n+        this.config = getConfigAs(HeliosEasyControlsConfiguration.class);\r\n+        this.readVariableDefinition();\r\n+        this.connectEndpoint();\r\n+        if ((this.comms != null) && (this.vMap != null) && (this.config != null)) {\r\n+            HeliosEasyControlsHandler.transactionLocks.putIfAbsent(this.comms.getEndpoint(), new Semaphore(1, true));\r\n+            updateStatus(ThingStatus.UNKNOWN);\r\n+\r\n+            // background initialization\r\n+            scheduler.execute(() -> {\r\n+                readValue(HeliosEasyControlsBindingConstants.DATE_FORMAT);\r\n+                // status will be updated to ONLINE by the read callback function (via processResponse)\r\n+            });\r\n+\r\n+            // poll for status updates regularly\r\n+            Runnable runnable = new Runnable() {\r\n+\r\n+                @Override\r\n+                public void run() {\r\n+                    if (vMap != null) {\r\n+                        for (Map.Entry<String, HeliosVariable> entry : vMap.entrySet()) {\r\n+                            if (isLinked(entry.getKey())\r\n+                                    || (entry.getKey().equals(HeliosEasyControlsBindingConstants.DATE_FORMAT))\r\n+                                    || (entry.getKey()\r\n+                                            .equals(HeliosEasyControlsBindingConstants.TIME_ZONE_DIFFERENCE_TO_GMT))) {\r\n+                                readValue(entry.getKey());\r\n+                            }\r\n+                        }\r\n+\r\n+                    } else {\r\n+                        handleError(\"Variable definition is null\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+                    }\r\n+                }\r\n+            };\r\n+            this.pollingJob = scheduler.scheduleAtFixedRate(runnable, this.config.getRefreshInterval(),\r\n+                    this.config.getRefreshInterval(), TimeUnit.MILLISECONDS);\r\n+\r\n+        } else { // at least one null assertion has failed, let's log the problem and update the thing status\r\n+            if (this.comms == null) {\r\n+                this.handleError(\"Modbus communication interface is unavailable.\",\r\n+                        ThingStatusDetail.COMMUNICATION_ERROR);\r\n+            }\r\n+            if (this.vMap == null) {\r\n+                this.handleError(\"Variable definition is unavailable.\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            }\r\n+            if (this.config == null) {\r\n+                this.handleError(\"Binding configuration is unavailable.\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void dispose() {\r\n+        if (this.pollingJob != null) {\r\n+            this.pollingJob.cancel(true);\r\n+        }\r\n+        this.comms = null;\r\n+    }\r\n+\r\n+    @Override\r\n+    public void handleCommand(ChannelUID channelUID, Command command) {\r\n+        String channelId = channelUID.getIdWithoutGroup();\r\n+        if (command instanceof RefreshType) {\r\n+            scheduler.submit(new Runnable() {\r\n+                @Override\r\n+                public void run() {\r\n+                    readValue(channelId);\r\n+                }\r\n+            });\r", "originalCommit": "a29484f182958feae2d73f3ac06490316afc5798", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxNDU2NA==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r479814564", "bodyText": "The status update is logged, too. You could remove the log message and include the message in the status update. Same for below.", "author": "fwolter", "createdAt": "2020-08-30T20:54:39Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,684 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.nio.charset.StandardCharsets;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.QuantityType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\r\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.eclipse.smarthome.core.types.State;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+@NonNullByDefault\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    /**\r\n+     * Logger instance\r\n+     */\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    /**\r\n+     * Configuration instance\r\n+     */\r\n+    private @Nullable HeliosEasyControlsConfiguration config;\r\n+\r\n+    /**\r\n+     * Used to poll the variables' status based on the configured refresh interval\r\n+     */\r\n+    private @Nullable ScheduledFuture<?> pollingJob;\r\n+\r\n+    /**\r\n+     * The map holding the variable meta info by variable name\r\n+     */\r\n+    private @Nullable Map<String, HeliosVariable> vMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private static ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore>();\r\n+\r\n+    /**\r\n+     * Communication interface to the endpoint\r\n+     */\r\n+    private @Nullable ModbusCommunicationInterface comms;\r\n+\r\n+    /**\r\n+     * The date format used by the device\r\n+     */\r\n+    private int dateFormat = -1;\r\n+\r\n+    /**\r\n+     * The UTC offset of the device\r\n+     */\r\n+    private int utcOffset = 0;\r\n+\r\n+    /**\r\n+     * Constructor\r\n+     *\r\n+     * @param thing\r\n+     * @param managerRef\r\n+     */\r\n+    public HeliosEasyControlsHandler(Thing thing) {\r\n+        super(thing);\r\n+    }\r\n+\r\n+    /**\r\n+     * Reads variable definitions from JSON file and store them in vMap\r\n+     */\r\n+    private void readVariableDefinition() {\r\n+        Gson gson = new Gson();\r\n+        Type vMapType = new TypeToken<Map<String, HeliosVariable>>() {\r\n+        }.getType();\r\n+        this.vMap = gson.fromJson(\r\n+                new BufferedReader(new InputStreamReader(\r\n+                        getClass().getResourceAsStream(HeliosEasyControlsBindingConstants.VARIABLES_DEFINITION_FILE))),\r\n+                vMapType);\r\n+        if (vMap != null) {\r\n+            // add the name to the variable itself\r\n+            for (Map.Entry<String, HeliosVariable> entry : this.vMap.entrySet()) {\r\n+                entry.getValue().setName(entry.getKey()); // workaround to set the variable name inside the\r\n+                                                          // HeliosVariable object\r\n+                if (!entry.getValue().isOk()) {\r\n+                    this.handleError(\"Variables definition file contains inconsistent data.\",\r\n+                            ThingStatusDetail.CONFIGURATION_ERROR);\r\n+                }\r\n+            }\r\n+        } else {\r\n+            this.handleError(\"Variables definition file not found or of illegal format.\",\r\n+                    ThingStatusDetail.CONFIGURATION_ERROR);\r\n+        }\r\n+\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the endpoint handler from the bridge this handler is connected to\r\n+     * Checks that we're connected to the right type of bridge\r\n+     *\r\n+     * @return the endpoint handler or null if the bridge does not exist\r\n+     */\r\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\r\n+        Bridge bridge = getBridge();\r\n+        if (bridge == null) {\r\n+            logger.debug(\"Bridge is null\");\r\n+            return null;\r\n+        }\r\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\r\n+            logger.debug(\"Bridge is not online\");\r\n+            return null;\r\n+        }\r\n+\r\n+        ThingHandler handler = bridge.getHandler();\r\n+        if (handler == null) {\r\n+            logger.debug(\"Bridge handler is null\");\r\n+            return null;\r\n+        }\r\n+\r\n+        if (handler instanceof ModbusEndpointThingHandler) {\r\n+            return (ModbusEndpointThingHandler) handler;\r\n+        } else {\r\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\r\n+            return null;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get a reference to the modbus endpoint\r\n+     */\r\n+    private void connectEndpoint() {\r\n+        if (this.comms != null) {\r\n+            return;\r\n+        }\r\n+\r\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\r\n+        if (slaveEndpointThingHandler == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' is offline\", label));\r\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\r\n+            return;\r\n+        }\r\n+\r\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\r\n+\r\n+        if (comms == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\r\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\r\n+            return;\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void initialize() {\r\n+        this.config = getConfigAs(HeliosEasyControlsConfiguration.class);\r\n+        this.readVariableDefinition();\r\n+        this.connectEndpoint();\r\n+        if ((this.comms != null) && (this.vMap != null) && (this.config != null)) {\r\n+            HeliosEasyControlsHandler.transactionLocks.putIfAbsent(this.comms.getEndpoint(), new Semaphore(1, true));\r\n+            updateStatus(ThingStatus.UNKNOWN);\r\n+\r\n+            // background initialization\r\n+            scheduler.execute(() -> {\r\n+                readValue(HeliosEasyControlsBindingConstants.DATE_FORMAT);\r\n+                // status will be updated to ONLINE by the read callback function (via processResponse)\r\n+            });\r\n+\r\n+            // poll for status updates regularly\r\n+            Runnable runnable = new Runnable() {\r\n+\r\n+                @Override\r\n+                public void run() {\r\n+                    if (vMap != null) {\r\n+                        for (Map.Entry<String, HeliosVariable> entry : vMap.entrySet()) {\r\n+                            if (isLinked(entry.getKey())\r\n+                                    || (entry.getKey().equals(HeliosEasyControlsBindingConstants.DATE_FORMAT))\r\n+                                    || (entry.getKey()\r\n+                                            .equals(HeliosEasyControlsBindingConstants.TIME_ZONE_DIFFERENCE_TO_GMT))) {\r\n+                                readValue(entry.getKey());\r\n+                            }\r\n+                        }\r\n+\r\n+                    } else {\r\n+                        handleError(\"Variable definition is null\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+                    }\r\n+                }\r\n+            };\r\n+            this.pollingJob = scheduler.scheduleAtFixedRate(runnable, this.config.getRefreshInterval(),\r\n+                    this.config.getRefreshInterval(), TimeUnit.MILLISECONDS);\r\n+\r\n+        } else { // at least one null assertion has failed, let's log the problem and update the thing status\r\n+            if (this.comms == null) {\r\n+                this.handleError(\"Modbus communication interface is unavailable.\",\r\n+                        ThingStatusDetail.COMMUNICATION_ERROR);\r\n+            }\r\n+            if (this.vMap == null) {\r\n+                this.handleError(\"Variable definition is unavailable.\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            }\r\n+            if (this.config == null) {\r\n+                this.handleError(\"Binding configuration is unavailable.\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void dispose() {\r\n+        if (this.pollingJob != null) {\r\n+            this.pollingJob.cancel(true);\r\n+        }\r\n+        this.comms = null;\r\n+    }\r\n+\r\n+    @Override\r\n+    public void handleCommand(ChannelUID channelUID, Command command) {\r\n+        String channelId = channelUID.getIdWithoutGroup();\r\n+        if (command instanceof RefreshType) {\r\n+            scheduler.submit(new Runnable() {\r\n+                @Override\r\n+                public void run() {\r\n+                    readValue(channelId);\r\n+                }\r\n+            });\r\n+        } else { // write command\r\n+            String value = null;\r\n+            if (command instanceof OnOffType) {\r\n+                value = command == OnOffType.ON ? \"1\" : \"0\";\r\n+            } else if (command instanceof DateTimeType) {\r\n+                value = formatDate(channelId, ((DateTimeType) command).getZonedDateTime());\r\n+            } else if ((command instanceof DecimalType) || (command instanceof StringType)) {\r\n+                value = command.toString();\r\n+            } else if (command instanceof QuantityType<?>) {\r\n+                // convert item's unit to the Helios device's unit\r\n+                String unit = this.vMap.get(channelId).getUnit();\r\n+                QuantityType<?> val = (QuantityType<?>) command;\r\n+                if (unit != null) {\r\n+                    if (unit.equals(HeliosVariable.UNIT_DAY)) {\r\n+                        val = val.toUnit(SmartHomeUnits.DAY);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_HOUR)) {\r\n+                        val = val.toUnit(SmartHomeUnits.HOUR);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_MIN)) {\r\n+                        val = val.toUnit(SmartHomeUnits.MINUTE);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_SEC)) {\r\n+                        val = val.toUnit(SmartHomeUnits.SECOND);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_VOLT)) {\r\n+                        val = val.toUnit(SmartHomeUnits.VOLT);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_PERCENT)) {\r\n+                        val = val.toUnit(SmartHomeUnits.PERCENT);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_PPM)) {\r\n+                        val = val.toUnit(SmartHomeUnits.PARTS_PER_MILLION);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_TEMP)) {\r\n+                        val = val.toUnit(SIUnits.CELSIUS);\r\n+                    }\r\n+                    value = val != null ? String.valueOf(val.doubleValue()) : null; // ignore the UoM\r\n+                }\r\n+            }\r\n+            if (value != null) {\r\n+                final String v = value;\r\n+                scheduler.submit(new Runnable() {\r\n+                    @Override\r\n+                    public void run() {\r\n+                        try {\r\n+                            writeValue(channelId, v);\r\n+                            updateStatus(ThingStatus.ONLINE);\r\n+                        } catch (HeliosException e) {\r\n+                            logger.warn(\"Writing value {} to channel {} failed: {}\", v, channelId, e.getMessage());\r\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\r\n+                                    \"Writing to device failed.\");\r", "originalCommit": "a29484f182958feae2d73f3ac06490316afc5798", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxNDg5NA==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r479814894", "bodyText": "OH should update the Channel for you. The delay could lead to unintened updates if the user clicks to fast.", "author": "fwolter", "createdAt": "2020-08-30T20:57:57Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,684 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.nio.charset.StandardCharsets;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.QuantityType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\r\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.eclipse.smarthome.core.types.State;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+@NonNullByDefault\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    /**\r\n+     * Logger instance\r\n+     */\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    /**\r\n+     * Configuration instance\r\n+     */\r\n+    private @Nullable HeliosEasyControlsConfiguration config;\r\n+\r\n+    /**\r\n+     * Used to poll the variables' status based on the configured refresh interval\r\n+     */\r\n+    private @Nullable ScheduledFuture<?> pollingJob;\r\n+\r\n+    /**\r\n+     * The map holding the variable meta info by variable name\r\n+     */\r\n+    private @Nullable Map<String, HeliosVariable> vMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private static ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore>();\r\n+\r\n+    /**\r\n+     * Communication interface to the endpoint\r\n+     */\r\n+    private @Nullable ModbusCommunicationInterface comms;\r\n+\r\n+    /**\r\n+     * The date format used by the device\r\n+     */\r\n+    private int dateFormat = -1;\r\n+\r\n+    /**\r\n+     * The UTC offset of the device\r\n+     */\r\n+    private int utcOffset = 0;\r\n+\r\n+    /**\r\n+     * Constructor\r\n+     *\r\n+     * @param thing\r\n+     * @param managerRef\r\n+     */\r\n+    public HeliosEasyControlsHandler(Thing thing) {\r\n+        super(thing);\r\n+    }\r\n+\r\n+    /**\r\n+     * Reads variable definitions from JSON file and store them in vMap\r\n+     */\r\n+    private void readVariableDefinition() {\r\n+        Gson gson = new Gson();\r\n+        Type vMapType = new TypeToken<Map<String, HeliosVariable>>() {\r\n+        }.getType();\r\n+        this.vMap = gson.fromJson(\r\n+                new BufferedReader(new InputStreamReader(\r\n+                        getClass().getResourceAsStream(HeliosEasyControlsBindingConstants.VARIABLES_DEFINITION_FILE))),\r\n+                vMapType);\r\n+        if (vMap != null) {\r\n+            // add the name to the variable itself\r\n+            for (Map.Entry<String, HeliosVariable> entry : this.vMap.entrySet()) {\r\n+                entry.getValue().setName(entry.getKey()); // workaround to set the variable name inside the\r\n+                                                          // HeliosVariable object\r\n+                if (!entry.getValue().isOk()) {\r\n+                    this.handleError(\"Variables definition file contains inconsistent data.\",\r\n+                            ThingStatusDetail.CONFIGURATION_ERROR);\r\n+                }\r\n+            }\r\n+        } else {\r\n+            this.handleError(\"Variables definition file not found or of illegal format.\",\r\n+                    ThingStatusDetail.CONFIGURATION_ERROR);\r\n+        }\r\n+\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the endpoint handler from the bridge this handler is connected to\r\n+     * Checks that we're connected to the right type of bridge\r\n+     *\r\n+     * @return the endpoint handler or null if the bridge does not exist\r\n+     */\r\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\r\n+        Bridge bridge = getBridge();\r\n+        if (bridge == null) {\r\n+            logger.debug(\"Bridge is null\");\r\n+            return null;\r\n+        }\r\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\r\n+            logger.debug(\"Bridge is not online\");\r\n+            return null;\r\n+        }\r\n+\r\n+        ThingHandler handler = bridge.getHandler();\r\n+        if (handler == null) {\r\n+            logger.debug(\"Bridge handler is null\");\r\n+            return null;\r\n+        }\r\n+\r\n+        if (handler instanceof ModbusEndpointThingHandler) {\r\n+            return (ModbusEndpointThingHandler) handler;\r\n+        } else {\r\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\r\n+            return null;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get a reference to the modbus endpoint\r\n+     */\r\n+    private void connectEndpoint() {\r\n+        if (this.comms != null) {\r\n+            return;\r\n+        }\r\n+\r\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\r\n+        if (slaveEndpointThingHandler == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' is offline\", label));\r\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\r\n+            return;\r\n+        }\r\n+\r\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\r\n+\r\n+        if (comms == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\r\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\r\n+            return;\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void initialize() {\r\n+        this.config = getConfigAs(HeliosEasyControlsConfiguration.class);\r\n+        this.readVariableDefinition();\r\n+        this.connectEndpoint();\r\n+        if ((this.comms != null) && (this.vMap != null) && (this.config != null)) {\r\n+            HeliosEasyControlsHandler.transactionLocks.putIfAbsent(this.comms.getEndpoint(), new Semaphore(1, true));\r\n+            updateStatus(ThingStatus.UNKNOWN);\r\n+\r\n+            // background initialization\r\n+            scheduler.execute(() -> {\r\n+                readValue(HeliosEasyControlsBindingConstants.DATE_FORMAT);\r\n+                // status will be updated to ONLINE by the read callback function (via processResponse)\r\n+            });\r\n+\r\n+            // poll for status updates regularly\r\n+            Runnable runnable = new Runnable() {\r\n+\r\n+                @Override\r\n+                public void run() {\r\n+                    if (vMap != null) {\r\n+                        for (Map.Entry<String, HeliosVariable> entry : vMap.entrySet()) {\r\n+                            if (isLinked(entry.getKey())\r\n+                                    || (entry.getKey().equals(HeliosEasyControlsBindingConstants.DATE_FORMAT))\r\n+                                    || (entry.getKey()\r\n+                                            .equals(HeliosEasyControlsBindingConstants.TIME_ZONE_DIFFERENCE_TO_GMT))) {\r\n+                                readValue(entry.getKey());\r\n+                            }\r\n+                        }\r\n+\r\n+                    } else {\r\n+                        handleError(\"Variable definition is null\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+                    }\r\n+                }\r\n+            };\r\n+            this.pollingJob = scheduler.scheduleAtFixedRate(runnable, this.config.getRefreshInterval(),\r\n+                    this.config.getRefreshInterval(), TimeUnit.MILLISECONDS);\r\n+\r\n+        } else { // at least one null assertion has failed, let's log the problem and update the thing status\r\n+            if (this.comms == null) {\r\n+                this.handleError(\"Modbus communication interface is unavailable.\",\r\n+                        ThingStatusDetail.COMMUNICATION_ERROR);\r\n+            }\r\n+            if (this.vMap == null) {\r\n+                this.handleError(\"Variable definition is unavailable.\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            }\r\n+            if (this.config == null) {\r\n+                this.handleError(\"Binding configuration is unavailable.\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void dispose() {\r\n+        if (this.pollingJob != null) {\r\n+            this.pollingJob.cancel(true);\r\n+        }\r\n+        this.comms = null;\r\n+    }\r\n+\r\n+    @Override\r\n+    public void handleCommand(ChannelUID channelUID, Command command) {\r\n+        String channelId = channelUID.getIdWithoutGroup();\r\n+        if (command instanceof RefreshType) {\r\n+            scheduler.submit(new Runnable() {\r\n+                @Override\r\n+                public void run() {\r\n+                    readValue(channelId);\r\n+                }\r\n+            });\r\n+        } else { // write command\r\n+            String value = null;\r\n+            if (command instanceof OnOffType) {\r\n+                value = command == OnOffType.ON ? \"1\" : \"0\";\r\n+            } else if (command instanceof DateTimeType) {\r\n+                value = formatDate(channelId, ((DateTimeType) command).getZonedDateTime());\r\n+            } else if ((command instanceof DecimalType) || (command instanceof StringType)) {\r\n+                value = command.toString();\r\n+            } else if (command instanceof QuantityType<?>) {\r\n+                // convert item's unit to the Helios device's unit\r\n+                String unit = this.vMap.get(channelId).getUnit();\r\n+                QuantityType<?> val = (QuantityType<?>) command;\r\n+                if (unit != null) {\r\n+                    if (unit.equals(HeliosVariable.UNIT_DAY)) {\r\n+                        val = val.toUnit(SmartHomeUnits.DAY);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_HOUR)) {\r\n+                        val = val.toUnit(SmartHomeUnits.HOUR);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_MIN)) {\r\n+                        val = val.toUnit(SmartHomeUnits.MINUTE);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_SEC)) {\r\n+                        val = val.toUnit(SmartHomeUnits.SECOND);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_VOLT)) {\r\n+                        val = val.toUnit(SmartHomeUnits.VOLT);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_PERCENT)) {\r\n+                        val = val.toUnit(SmartHomeUnits.PERCENT);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_PPM)) {\r\n+                        val = val.toUnit(SmartHomeUnits.PARTS_PER_MILLION);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_TEMP)) {\r\n+                        val = val.toUnit(SIUnits.CELSIUS);\r\n+                    }\r\n+                    value = val != null ? String.valueOf(val.doubleValue()) : null; // ignore the UoM\r\n+                }\r\n+            }\r\n+            if (value != null) {\r\n+                final String v = value;\r\n+                scheduler.submit(new Runnable() {\r\n+                    @Override\r\n+                    public void run() {\r\n+                        try {\r\n+                            writeValue(channelId, v);\r\n+                            updateStatus(ThingStatus.ONLINE);\r\n+                        } catch (HeliosException e) {\r\n+                            logger.warn(\"Writing value {} to channel {} failed: {}\", v, channelId, e.getMessage());\r\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\r\n+                                    \"Writing to device failed.\");\r\n+                        }\r\n+                    }\r\n+                });\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Writes a variable value to the Helios device\r\n+     *\r\n+     * @param variableName The variable name\r\n+     * @param value The new value\r\n+     * @return The value if the transaction succeeded, <tt>null</tt> otherwise\r\n+     * @throws HeliosException Thrown if the variable is read-only or the provided value is out of range\r\n+     */\r\n+    public void writeValue(String variableName, String value) throws HeliosException {\r\n+        if (this.vMap == null) {\r\n+            this.handleError(\"Variable definition is unavailable.\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            return;\r\n+        } else {\r\n+            HeliosVariable v = this.vMap.get(variableName);\r\n+            if (!v.hasWriteAccess()) {\r\n+                throw new HeliosException(\"Variable \" + variableName + \" is read-only\");\r\n+            } else if (!v.isInAllowedRange(value)) {\r\n+                throw new HeliosException(\r\n+                        \"Value \" + value + \" is outside of allowed range of variable \" + variableName);\r\n+            } else if (this.comms != null) {\r\n+                // write to device\r\n+                String payload = v.getVariableString() + \"=\" + value;\r\n+                final Semaphore lock = transactionLocks.get(this.comms.getEndpoint());\r\n+                try {\r\n+                    lock.acquire();\r\n+                    this.comms.submitOneTimeWrite(\r\n+                            new ModbusWriteRegisterRequestBlueprint(HeliosEasyControlsBindingConstants.UNIT_ID,\r\n+                                    HeliosEasyControlsBindingConstants.START_ADDRESS,\r\n+                                    new ModbusRegisterArray(preparePayload(payload)), true,\r\n+                                    HeliosEasyControlsBindingConstants.MAX_TRIES),\r\n+                            result -> {\r\n+                                lock.release();\r\n+                                updateStatus(ThingStatus.ONLINE);\r\n+                            }, failureInfo -> {\r\n+                                String errorMsg = failureInfo.getCause().getMessage();\r\n+                                logger.warn(\"{} encountered error writing to device: {}\",\r\n+                                        HeliosEasyControlsHandler.class.getSimpleName(), errorMsg);\r\n+                                lock.release();\r\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorMsg);\r\n+                            });\r\n+                    // ensure the openHAB item is updated with the device's actual value\r\n+                    scheduler.schedule(new Runnable() {\r\n+                        @Override\r\n+                        public void run() {\r\n+                            readValue(variableName);\r\n+                        }\r\n+                    }, 1, TimeUnit.SECONDS);\r", "originalCommit": "a29484f182958feae2d73f3ac06490316afc5798", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk1MTEzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r486951139", "bodyText": "To avoid unnecessary updates I've attached this to the actual write command now.\nBecause without this the state update would take quite a while.", "author": "bern77", "createdAt": "2020-09-11T10:17:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxNDg5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzExNjU1NA==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r487116554", "bodyText": "Actually the Channel is instantly updated when the user sent a command to it. This is done by the framework. An update is only necessary if changing a Channel would affect another Channel's value.", "author": "fwolter", "createdAt": "2020-09-11T15:19:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxNDg5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIwMDQ5NA==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r487200494", "bodyText": "Then, fascinatingly, I've managed to implement a binding that counters this mechanism beautifully...\nChaning a value via a write request works fine and I see the effect on the device, but in OH the change will only become visibly when the next scheduled refresh is executed.\nDo you have any idea what might be a possible cause?", "author": "bern77", "createdAt": "2020-09-11T17:54:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxNDg5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIxOTg3OA==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r487219878", "bodyText": "I observed this behavior, too, sometimes. It seems Basic UI misses to update the sitemap. Do you see the update in the console? Here is the explaining documentation: https://www.openhab.org/docs/developer/bindings/thing-xml.html#auto-update-policies", "author": "fwolter", "createdAt": "2020-09-11T18:33:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxNDg5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM3Nzg4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r487377889", "bodyText": "I've just seen that I didn't actively update the channel state after writing to the device, just when reading from the device. I've now changed this to also update the channel state upon writing. I hope this is now more in line with the standard behaviour.", "author": "bern77", "createdAt": "2020-09-12T06:55:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxNDg5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5NDc1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r487394757", "bodyText": "Actually you only need to update the Channel when the change is not originated by the user. I just tested to change a Channel, which is not updated by the corresponding binding and I see its status changed on the console (ItemStateChangedEvent) when I send a command to it.", "author": "fwolter", "createdAt": "2020-09-12T10:22:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxNDg5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzUwMzU5NA==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r487503594", "bodyText": "Strange - if I don't update the channel the change is not done. I've tested this with a simple rule:\nlogInfo(\"TEST\", triggeringItem + \" - \" + receivedCommand)\nThread::sleep(2000)\nlogInfo(\"TEST\", triggeringItem.state.toString)\n\nWhen it fires I see the correct command which triggered the rule but the item's state doesn't change. The second output is still the old state. However the command does physically change the device's state...", "author": "bern77", "createdAt": "2020-09-13T09:10:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxNDg5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc2MzU2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r487763561", "bodyText": "When looking to the schedule, it might be a good idea to choose the approach which works for you at the moment to get this merged before 2.5.9. And then, file another PR when the above is clarified.", "author": "fwolter", "createdAt": "2020-09-14T09:08:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxNDg5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc3Njk2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r487776963", "bodyText": "The latest commit works fine for me and I'm happy to leave this as it is. If we find a more elegant approach later I'm happy to make the necessary changes.", "author": "bern77", "createdAt": "2020-09-14T09:31:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxNDg5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxNTI1NA==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r479815254", "bodyText": "Can this be removed?", "author": "fwolter", "createdAt": "2020-08-30T21:01:56Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,684 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.nio.charset.StandardCharsets;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.QuantityType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\r\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.eclipse.smarthome.core.types.State;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+@NonNullByDefault\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    /**\r\n+     * Logger instance\r\n+     */\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    /**\r\n+     * Configuration instance\r\n+     */\r\n+    private @Nullable HeliosEasyControlsConfiguration config;\r\n+\r\n+    /**\r\n+     * Used to poll the variables' status based on the configured refresh interval\r\n+     */\r\n+    private @Nullable ScheduledFuture<?> pollingJob;\r\n+\r\n+    /**\r\n+     * The map holding the variable meta info by variable name\r\n+     */\r\n+    private @Nullable Map<String, HeliosVariable> vMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private static ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore>();\r\n+\r\n+    /**\r\n+     * Communication interface to the endpoint\r\n+     */\r\n+    private @Nullable ModbusCommunicationInterface comms;\r\n+\r\n+    /**\r\n+     * The date format used by the device\r\n+     */\r\n+    private int dateFormat = -1;\r\n+\r\n+    /**\r\n+     * The UTC offset of the device\r\n+     */\r\n+    private int utcOffset = 0;\r\n+\r\n+    /**\r\n+     * Constructor\r\n+     *\r\n+     * @param thing\r\n+     * @param managerRef\r\n+     */\r\n+    public HeliosEasyControlsHandler(Thing thing) {\r\n+        super(thing);\r\n+    }\r\n+\r\n+    /**\r\n+     * Reads variable definitions from JSON file and store them in vMap\r\n+     */\r\n+    private void readVariableDefinition() {\r\n+        Gson gson = new Gson();\r\n+        Type vMapType = new TypeToken<Map<String, HeliosVariable>>() {\r\n+        }.getType();\r\n+        this.vMap = gson.fromJson(\r\n+                new BufferedReader(new InputStreamReader(\r\n+                        getClass().getResourceAsStream(HeliosEasyControlsBindingConstants.VARIABLES_DEFINITION_FILE))),\r\n+                vMapType);\r\n+        if (vMap != null) {\r\n+            // add the name to the variable itself\r\n+            for (Map.Entry<String, HeliosVariable> entry : this.vMap.entrySet()) {\r\n+                entry.getValue().setName(entry.getKey()); // workaround to set the variable name inside the\r\n+                                                          // HeliosVariable object\r\n+                if (!entry.getValue().isOk()) {\r\n+                    this.handleError(\"Variables definition file contains inconsistent data.\",\r\n+                            ThingStatusDetail.CONFIGURATION_ERROR);\r\n+                }\r\n+            }\r\n+        } else {\r\n+            this.handleError(\"Variables definition file not found or of illegal format.\",\r\n+                    ThingStatusDetail.CONFIGURATION_ERROR);\r\n+        }\r\n+\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the endpoint handler from the bridge this handler is connected to\r\n+     * Checks that we're connected to the right type of bridge\r\n+     *\r\n+     * @return the endpoint handler or null if the bridge does not exist\r\n+     */\r\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\r\n+        Bridge bridge = getBridge();\r\n+        if (bridge == null) {\r\n+            logger.debug(\"Bridge is null\");\r\n+            return null;\r\n+        }\r\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\r\n+            logger.debug(\"Bridge is not online\");\r\n+            return null;\r\n+        }\r\n+\r\n+        ThingHandler handler = bridge.getHandler();\r\n+        if (handler == null) {\r\n+            logger.debug(\"Bridge handler is null\");\r\n+            return null;\r\n+        }\r\n+\r\n+        if (handler instanceof ModbusEndpointThingHandler) {\r\n+            return (ModbusEndpointThingHandler) handler;\r\n+        } else {\r\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\r\n+            return null;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get a reference to the modbus endpoint\r\n+     */\r\n+    private void connectEndpoint() {\r\n+        if (this.comms != null) {\r\n+            return;\r\n+        }\r\n+\r\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\r\n+        if (slaveEndpointThingHandler == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' is offline\", label));\r\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\r\n+            return;\r\n+        }\r\n+\r\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\r\n+\r\n+        if (comms == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\r\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\r\n+            return;\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void initialize() {\r\n+        this.config = getConfigAs(HeliosEasyControlsConfiguration.class);\r\n+        this.readVariableDefinition();\r\n+        this.connectEndpoint();\r\n+        if ((this.comms != null) && (this.vMap != null) && (this.config != null)) {\r\n+            HeliosEasyControlsHandler.transactionLocks.putIfAbsent(this.comms.getEndpoint(), new Semaphore(1, true));\r\n+            updateStatus(ThingStatus.UNKNOWN);\r\n+\r\n+            // background initialization\r\n+            scheduler.execute(() -> {\r\n+                readValue(HeliosEasyControlsBindingConstants.DATE_FORMAT);\r\n+                // status will be updated to ONLINE by the read callback function (via processResponse)\r\n+            });\r\n+\r\n+            // poll for status updates regularly\r\n+            Runnable runnable = new Runnable() {\r\n+\r\n+                @Override\r\n+                public void run() {\r\n+                    if (vMap != null) {\r\n+                        for (Map.Entry<String, HeliosVariable> entry : vMap.entrySet()) {\r\n+                            if (isLinked(entry.getKey())\r\n+                                    || (entry.getKey().equals(HeliosEasyControlsBindingConstants.DATE_FORMAT))\r\n+                                    || (entry.getKey()\r\n+                                            .equals(HeliosEasyControlsBindingConstants.TIME_ZONE_DIFFERENCE_TO_GMT))) {\r\n+                                readValue(entry.getKey());\r\n+                            }\r\n+                        }\r\n+\r\n+                    } else {\r\n+                        handleError(\"Variable definition is null\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+                    }\r\n+                }\r\n+            };\r\n+            this.pollingJob = scheduler.scheduleAtFixedRate(runnable, this.config.getRefreshInterval(),\r\n+                    this.config.getRefreshInterval(), TimeUnit.MILLISECONDS);\r\n+\r\n+        } else { // at least one null assertion has failed, let's log the problem and update the thing status\r\n+            if (this.comms == null) {\r\n+                this.handleError(\"Modbus communication interface is unavailable.\",\r\n+                        ThingStatusDetail.COMMUNICATION_ERROR);\r\n+            }\r\n+            if (this.vMap == null) {\r\n+                this.handleError(\"Variable definition is unavailable.\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            }\r\n+            if (this.config == null) {\r\n+                this.handleError(\"Binding configuration is unavailable.\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void dispose() {\r\n+        if (this.pollingJob != null) {\r\n+            this.pollingJob.cancel(true);\r\n+        }\r\n+        this.comms = null;\r\n+    }\r\n+\r\n+    @Override\r\n+    public void handleCommand(ChannelUID channelUID, Command command) {\r\n+        String channelId = channelUID.getIdWithoutGroup();\r\n+        if (command instanceof RefreshType) {\r\n+            scheduler.submit(new Runnable() {\r\n+                @Override\r\n+                public void run() {\r\n+                    readValue(channelId);\r\n+                }\r\n+            });\r\n+        } else { // write command\r\n+            String value = null;\r\n+            if (command instanceof OnOffType) {\r\n+                value = command == OnOffType.ON ? \"1\" : \"0\";\r\n+            } else if (command instanceof DateTimeType) {\r\n+                value = formatDate(channelId, ((DateTimeType) command).getZonedDateTime());\r\n+            } else if ((command instanceof DecimalType) || (command instanceof StringType)) {\r\n+                value = command.toString();\r\n+            } else if (command instanceof QuantityType<?>) {\r\n+                // convert item's unit to the Helios device's unit\r\n+                String unit = this.vMap.get(channelId).getUnit();\r\n+                QuantityType<?> val = (QuantityType<?>) command;\r\n+                if (unit != null) {\r\n+                    if (unit.equals(HeliosVariable.UNIT_DAY)) {\r\n+                        val = val.toUnit(SmartHomeUnits.DAY);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_HOUR)) {\r\n+                        val = val.toUnit(SmartHomeUnits.HOUR);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_MIN)) {\r\n+                        val = val.toUnit(SmartHomeUnits.MINUTE);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_SEC)) {\r\n+                        val = val.toUnit(SmartHomeUnits.SECOND);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_VOLT)) {\r\n+                        val = val.toUnit(SmartHomeUnits.VOLT);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_PERCENT)) {\r\n+                        val = val.toUnit(SmartHomeUnits.PERCENT);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_PPM)) {\r\n+                        val = val.toUnit(SmartHomeUnits.PARTS_PER_MILLION);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_TEMP)) {\r\n+                        val = val.toUnit(SIUnits.CELSIUS);\r\n+                    }\r\n+                    value = val != null ? String.valueOf(val.doubleValue()) : null; // ignore the UoM\r\n+                }\r\n+            }\r\n+            if (value != null) {\r\n+                final String v = value;\r\n+                scheduler.submit(new Runnable() {\r\n+                    @Override\r\n+                    public void run() {\r\n+                        try {\r\n+                            writeValue(channelId, v);\r\n+                            updateStatus(ThingStatus.ONLINE);\r\n+                        } catch (HeliosException e) {\r\n+                            logger.warn(\"Writing value {} to channel {} failed: {}\", v, channelId, e.getMessage());\r\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\r\n+                                    \"Writing to device failed.\");\r\n+                        }\r\n+                    }\r\n+                });\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Writes a variable value to the Helios device\r\n+     *\r\n+     * @param variableName The variable name\r\n+     * @param value The new value\r\n+     * @return The value if the transaction succeeded, <tt>null</tt> otherwise\r\n+     * @throws HeliosException Thrown if the variable is read-only or the provided value is out of range\r\n+     */\r\n+    public void writeValue(String variableName, String value) throws HeliosException {\r\n+        if (this.vMap == null) {\r\n+            this.handleError(\"Variable definition is unavailable.\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            return;\r\n+        } else {\r\n+            HeliosVariable v = this.vMap.get(variableName);\r\n+            if (!v.hasWriteAccess()) {\r\n+                throw new HeliosException(\"Variable \" + variableName + \" is read-only\");\r\n+            } else if (!v.isInAllowedRange(value)) {\r\n+                throw new HeliosException(\r\n+                        \"Value \" + value + \" is outside of allowed range of variable \" + variableName);\r\n+            } else if (this.comms != null) {\r\n+                // write to device\r\n+                String payload = v.getVariableString() + \"=\" + value;\r\n+                final Semaphore lock = transactionLocks.get(this.comms.getEndpoint());\r\n+                try {\r\n+                    lock.acquire();\r\n+                    this.comms.submitOneTimeWrite(\r\n+                            new ModbusWriteRegisterRequestBlueprint(HeliosEasyControlsBindingConstants.UNIT_ID,\r\n+                                    HeliosEasyControlsBindingConstants.START_ADDRESS,\r\n+                                    new ModbusRegisterArray(preparePayload(payload)), true,\r\n+                                    HeliosEasyControlsBindingConstants.MAX_TRIES),\r\n+                            result -> {\r\n+                                lock.release();\r\n+                                updateStatus(ThingStatus.ONLINE);\r\n+                            }, failureInfo -> {\r\n+                                String errorMsg = failureInfo.getCause().getMessage();\r\n+                                logger.warn(\"{} encountered error writing to device: {}\",\r\n+                                        HeliosEasyControlsHandler.class.getSimpleName(), errorMsg);\r\n+                                lock.release();\r\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorMsg);\r\n+                            });\r\n+                    // ensure the openHAB item is updated with the device's actual value\r\n+                    scheduler.schedule(new Runnable() {\r\n+                        @Override\r\n+                        public void run() {\r\n+                            readValue(variableName);\r\n+                        }\r\n+                    }, 1, TimeUnit.SECONDS);\r\n+                } catch (InterruptedException e) {\r\n+                    logger.warn(\r\n+                            \"{} encountered Exception when trying to lock Semaphore for writing variable {} to the device: {}\",\r\n+                            HeliosEasyControlsHandler.class.getSimpleName(), variableName, e.getMessage());\r\n+                }\r\n+            } else { // comms is null\r\n+                this.handleError(\"Modbus communication interface is null.\", ThingStatusDetail.COMMUNICATION_ERROR);\r\n+            }\r\n+        }\r\n+\r\n+    }\r\n+\r\n+    /**\r\n+     * Read a variable from the Helios device\r\n+     *\r\n+     * @param variableName The variable name\r\n+     * @return The value\r\n+     */\r\n+    public void readValue(String variableName) {\r\n+        if ((this.comms != null) && (this.vMap != null)) {\r\n+            final Semaphore lock = transactionLocks.get(this.comms.getEndpoint());\r\n+            HeliosVariable v = this.vMap.get(variableName);\r\n+            if (v.hasReadAccess()) {\r\n+                try {\r\n+                    lock.acquire(); // will block until lock is available\r\n+                } catch (InterruptedException e) {\r\n+                    logger.warn(\"{} encountered Exception when trying to read variable {} from the device: {}\",\r\n+                            HeliosEasyControlsHandler.class.getSimpleName(), variableName, e.getMessage());\r\n+                    return;\r\n+                }\r\n+                // write variable name to register\r\n+                String payload = v.getVariableString();\r\n+                this.comms.submitOneTimeWrite(new ModbusWriteRegisterRequestBlueprint(\r\n+                        HeliosEasyControlsBindingConstants.UNIT_ID, HeliosEasyControlsBindingConstants.START_ADDRESS,\r\n+                        new ModbusRegisterArray(preparePayload(payload)), true,\r\n+                        HeliosEasyControlsBindingConstants.MAX_TRIES), result -> {\r\n+                            this.comms.submitOneTimePoll(\r\n+                                    new ModbusReadRequestBlueprint(HeliosEasyControlsBindingConstants.UNIT_ID,\r\n+                                            ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS,\r\n+                                            HeliosEasyControlsBindingConstants.START_ADDRESS, v.getCount(),\r\n+                                            HeliosEasyControlsBindingConstants.MAX_TRIES),\r\n+                                    pollResult -> {\r\n+                                        lock.release();\r\n+                                        Optional<ModbusRegisterArray> registers = pollResult.getRegisters();\r\n+                                        if (registers.isPresent()) {\r\n+                                            processResponse(v, registers.get());\r\n+                                        }\r\n+                                    }, failureInfo -> {\r\n+                                        String errorMsg = failureInfo.getCause().getMessage();\r\n+                                        logger.warn(\"{} encountered error reading from device: {}\",\r\n+                                                HeliosEasyControlsHandler.class.getSimpleName(), errorMsg);\r\n+                                        lock.release();\r\n+                                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\r\n+                                                errorMsg);\r\n+                                    });\r\n+                        }, failureInfo -> {\r\n+                            String errorMsg = failureInfo.getCause().getMessage();\r\n+                            logger.warn(\"{} encountered error writing to device: {}\",\r\n+                                    HeliosEasyControlsHandler.class.getSimpleName(), errorMsg);\r\n+                            lock.release();\r\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorMsg);\r\n+\r\n+                        });\r\n+            }\r\n+        } else {\r\n+            if (this.comms == null) {\r\n+                this.handleError(\"Modbus communication interface is unavailable.\",\r\n+                        ThingStatusDetail.COMMUNICATION_ERROR);\r\n+            }\r\n+            if (this.vMap == null) {\r\n+                this.handleError(\"Variable definition is unavailable.\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    // TODO: set time incl. timezone, update time channels based on timezone read from device\r", "originalCommit": "a29484f182958feae2d73f3ac06490316afc5798", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5NDgxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r484094819", "bodyText": "Still something I intend to implement...", "author": "bern77", "createdAt": "2020-09-06T17:27:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxNTI1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDEwODU3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r484108572", "bodyText": "In general code to be commited to the official repo shouldn't contain any TODOs. You could open an issue, if you don't want to implement it in this round (which would be best according the 2.5.9 merge window I think).", "author": "fwolter", "createdAt": "2020-09-06T20:04:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxNTI1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxNTQwNw==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r479815407", "bodyText": "See my comment in the readme.", "author": "fwolter", "createdAt": "2020-08-30T21:04:13Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,684 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.nio.charset.StandardCharsets;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.QuantityType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\r\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.eclipse.smarthome.core.types.State;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+@NonNullByDefault\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    /**\r\n+     * Logger instance\r\n+     */\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    /**\r\n+     * Configuration instance\r\n+     */\r\n+    private @Nullable HeliosEasyControlsConfiguration config;\r\n+\r\n+    /**\r\n+     * Used to poll the variables' status based on the configured refresh interval\r\n+     */\r\n+    private @Nullable ScheduledFuture<?> pollingJob;\r\n+\r\n+    /**\r\n+     * The map holding the variable meta info by variable name\r\n+     */\r\n+    private @Nullable Map<String, HeliosVariable> vMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private static ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore>();\r\n+\r\n+    /**\r\n+     * Communication interface to the endpoint\r\n+     */\r\n+    private @Nullable ModbusCommunicationInterface comms;\r\n+\r\n+    /**\r\n+     * The date format used by the device\r\n+     */\r\n+    private int dateFormat = -1;\r\n+\r\n+    /**\r\n+     * The UTC offset of the device\r\n+     */\r\n+    private int utcOffset = 0;\r\n+\r\n+    /**\r\n+     * Constructor\r\n+     *\r\n+     * @param thing\r\n+     * @param managerRef\r\n+     */\r\n+    public HeliosEasyControlsHandler(Thing thing) {\r\n+        super(thing);\r\n+    }\r\n+\r\n+    /**\r\n+     * Reads variable definitions from JSON file and store them in vMap\r\n+     */\r\n+    private void readVariableDefinition() {\r\n+        Gson gson = new Gson();\r\n+        Type vMapType = new TypeToken<Map<String, HeliosVariable>>() {\r\n+        }.getType();\r\n+        this.vMap = gson.fromJson(\r\n+                new BufferedReader(new InputStreamReader(\r\n+                        getClass().getResourceAsStream(HeliosEasyControlsBindingConstants.VARIABLES_DEFINITION_FILE))),\r\n+                vMapType);\r\n+        if (vMap != null) {\r\n+            // add the name to the variable itself\r\n+            for (Map.Entry<String, HeliosVariable> entry : this.vMap.entrySet()) {\r\n+                entry.getValue().setName(entry.getKey()); // workaround to set the variable name inside the\r\n+                                                          // HeliosVariable object\r\n+                if (!entry.getValue().isOk()) {\r\n+                    this.handleError(\"Variables definition file contains inconsistent data.\",\r\n+                            ThingStatusDetail.CONFIGURATION_ERROR);\r\n+                }\r\n+            }\r\n+        } else {\r\n+            this.handleError(\"Variables definition file not found or of illegal format.\",\r\n+                    ThingStatusDetail.CONFIGURATION_ERROR);\r\n+        }\r\n+\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the endpoint handler from the bridge this handler is connected to\r\n+     * Checks that we're connected to the right type of bridge\r\n+     *\r\n+     * @return the endpoint handler or null if the bridge does not exist\r\n+     */\r\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\r\n+        Bridge bridge = getBridge();\r\n+        if (bridge == null) {\r\n+            logger.debug(\"Bridge is null\");\r\n+            return null;\r\n+        }\r\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\r\n+            logger.debug(\"Bridge is not online\");\r\n+            return null;\r\n+        }\r\n+\r\n+        ThingHandler handler = bridge.getHandler();\r\n+        if (handler == null) {\r\n+            logger.debug(\"Bridge handler is null\");\r\n+            return null;\r\n+        }\r\n+\r\n+        if (handler instanceof ModbusEndpointThingHandler) {\r\n+            return (ModbusEndpointThingHandler) handler;\r\n+        } else {\r\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\r\n+            return null;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get a reference to the modbus endpoint\r\n+     */\r\n+    private void connectEndpoint() {\r\n+        if (this.comms != null) {\r\n+            return;\r\n+        }\r\n+\r\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\r\n+        if (slaveEndpointThingHandler == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' is offline\", label));\r\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\r\n+            return;\r\n+        }\r\n+\r\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\r\n+\r\n+        if (comms == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\r\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\r\n+            return;\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void initialize() {\r\n+        this.config = getConfigAs(HeliosEasyControlsConfiguration.class);\r\n+        this.readVariableDefinition();\r\n+        this.connectEndpoint();\r\n+        if ((this.comms != null) && (this.vMap != null) && (this.config != null)) {\r\n+            HeliosEasyControlsHandler.transactionLocks.putIfAbsent(this.comms.getEndpoint(), new Semaphore(1, true));\r\n+            updateStatus(ThingStatus.UNKNOWN);\r\n+\r\n+            // background initialization\r\n+            scheduler.execute(() -> {\r\n+                readValue(HeliosEasyControlsBindingConstants.DATE_FORMAT);\r\n+                // status will be updated to ONLINE by the read callback function (via processResponse)\r\n+            });\r\n+\r\n+            // poll for status updates regularly\r\n+            Runnable runnable = new Runnable() {\r\n+\r\n+                @Override\r\n+                public void run() {\r\n+                    if (vMap != null) {\r\n+                        for (Map.Entry<String, HeliosVariable> entry : vMap.entrySet()) {\r\n+                            if (isLinked(entry.getKey())\r\n+                                    || (entry.getKey().equals(HeliosEasyControlsBindingConstants.DATE_FORMAT))\r\n+                                    || (entry.getKey()\r\n+                                            .equals(HeliosEasyControlsBindingConstants.TIME_ZONE_DIFFERENCE_TO_GMT))) {\r\n+                                readValue(entry.getKey());\r\n+                            }\r\n+                        }\r\n+\r\n+                    } else {\r\n+                        handleError(\"Variable definition is null\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+                    }\r\n+                }\r\n+            };\r\n+            this.pollingJob = scheduler.scheduleAtFixedRate(runnable, this.config.getRefreshInterval(),\r\n+                    this.config.getRefreshInterval(), TimeUnit.MILLISECONDS);\r\n+\r\n+        } else { // at least one null assertion has failed, let's log the problem and update the thing status\r\n+            if (this.comms == null) {\r\n+                this.handleError(\"Modbus communication interface is unavailable.\",\r\n+                        ThingStatusDetail.COMMUNICATION_ERROR);\r\n+            }\r\n+            if (this.vMap == null) {\r\n+                this.handleError(\"Variable definition is unavailable.\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            }\r\n+            if (this.config == null) {\r\n+                this.handleError(\"Binding configuration is unavailable.\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void dispose() {\r\n+        if (this.pollingJob != null) {\r\n+            this.pollingJob.cancel(true);\r\n+        }\r\n+        this.comms = null;\r\n+    }\r\n+\r\n+    @Override\r\n+    public void handleCommand(ChannelUID channelUID, Command command) {\r\n+        String channelId = channelUID.getIdWithoutGroup();\r\n+        if (command instanceof RefreshType) {\r\n+            scheduler.submit(new Runnable() {\r\n+                @Override\r\n+                public void run() {\r\n+                    readValue(channelId);\r\n+                }\r\n+            });\r\n+        } else { // write command\r\n+            String value = null;\r\n+            if (command instanceof OnOffType) {\r\n+                value = command == OnOffType.ON ? \"1\" : \"0\";\r\n+            } else if (command instanceof DateTimeType) {\r\n+                value = formatDate(channelId, ((DateTimeType) command).getZonedDateTime());\r\n+            } else if ((command instanceof DecimalType) || (command instanceof StringType)) {\r\n+                value = command.toString();\r\n+            } else if (command instanceof QuantityType<?>) {\r\n+                // convert item's unit to the Helios device's unit\r\n+                String unit = this.vMap.get(channelId).getUnit();\r\n+                QuantityType<?> val = (QuantityType<?>) command;\r\n+                if (unit != null) {\r\n+                    if (unit.equals(HeliosVariable.UNIT_DAY)) {\r\n+                        val = val.toUnit(SmartHomeUnits.DAY);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_HOUR)) {\r\n+                        val = val.toUnit(SmartHomeUnits.HOUR);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_MIN)) {\r\n+                        val = val.toUnit(SmartHomeUnits.MINUTE);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_SEC)) {\r\n+                        val = val.toUnit(SmartHomeUnits.SECOND);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_VOLT)) {\r\n+                        val = val.toUnit(SmartHomeUnits.VOLT);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_PERCENT)) {\r\n+                        val = val.toUnit(SmartHomeUnits.PERCENT);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_PPM)) {\r\n+                        val = val.toUnit(SmartHomeUnits.PARTS_PER_MILLION);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_TEMP)) {\r\n+                        val = val.toUnit(SIUnits.CELSIUS);\r\n+                    }\r\n+                    value = val != null ? String.valueOf(val.doubleValue()) : null; // ignore the UoM\r\n+                }\r\n+            }\r\n+            if (value != null) {\r\n+                final String v = value;\r\n+                scheduler.submit(new Runnable() {\r\n+                    @Override\r\n+                    public void run() {\r\n+                        try {\r\n+                            writeValue(channelId, v);\r\n+                            updateStatus(ThingStatus.ONLINE);\r\n+                        } catch (HeliosException e) {\r\n+                            logger.warn(\"Writing value {} to channel {} failed: {}\", v, channelId, e.getMessage());\r\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\r\n+                                    \"Writing to device failed.\");\r\n+                        }\r\n+                    }\r\n+                });\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Writes a variable value to the Helios device\r\n+     *\r\n+     * @param variableName The variable name\r\n+     * @param value The new value\r\n+     * @return The value if the transaction succeeded, <tt>null</tt> otherwise\r\n+     * @throws HeliosException Thrown if the variable is read-only or the provided value is out of range\r\n+     */\r\n+    public void writeValue(String variableName, String value) throws HeliosException {\r\n+        if (this.vMap == null) {\r\n+            this.handleError(\"Variable definition is unavailable.\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            return;\r\n+        } else {\r\n+            HeliosVariable v = this.vMap.get(variableName);\r\n+            if (!v.hasWriteAccess()) {\r\n+                throw new HeliosException(\"Variable \" + variableName + \" is read-only\");\r\n+            } else if (!v.isInAllowedRange(value)) {\r\n+                throw new HeliosException(\r\n+                        \"Value \" + value + \" is outside of allowed range of variable \" + variableName);\r\n+            } else if (this.comms != null) {\r\n+                // write to device\r\n+                String payload = v.getVariableString() + \"=\" + value;\r\n+                final Semaphore lock = transactionLocks.get(this.comms.getEndpoint());\r\n+                try {\r\n+                    lock.acquire();\r\n+                    this.comms.submitOneTimeWrite(\r\n+                            new ModbusWriteRegisterRequestBlueprint(HeliosEasyControlsBindingConstants.UNIT_ID,\r\n+                                    HeliosEasyControlsBindingConstants.START_ADDRESS,\r\n+                                    new ModbusRegisterArray(preparePayload(payload)), true,\r\n+                                    HeliosEasyControlsBindingConstants.MAX_TRIES),\r\n+                            result -> {\r\n+                                lock.release();\r\n+                                updateStatus(ThingStatus.ONLINE);\r\n+                            }, failureInfo -> {\r\n+                                String errorMsg = failureInfo.getCause().getMessage();\r\n+                                logger.warn(\"{} encountered error writing to device: {}\",\r\n+                                        HeliosEasyControlsHandler.class.getSimpleName(), errorMsg);\r\n+                                lock.release();\r\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorMsg);\r\n+                            });\r\n+                    // ensure the openHAB item is updated with the device's actual value\r\n+                    scheduler.schedule(new Runnable() {\r\n+                        @Override\r\n+                        public void run() {\r\n+                            readValue(variableName);\r\n+                        }\r\n+                    }, 1, TimeUnit.SECONDS);\r\n+                } catch (InterruptedException e) {\r\n+                    logger.warn(\r\n+                            \"{} encountered Exception when trying to lock Semaphore for writing variable {} to the device: {}\",\r\n+                            HeliosEasyControlsHandler.class.getSimpleName(), variableName, e.getMessage());\r\n+                }\r\n+            } else { // comms is null\r\n+                this.handleError(\"Modbus communication interface is null.\", ThingStatusDetail.COMMUNICATION_ERROR);\r\n+            }\r\n+        }\r\n+\r\n+    }\r\n+\r\n+    /**\r\n+     * Read a variable from the Helios device\r\n+     *\r\n+     * @param variableName The variable name\r\n+     * @return The value\r\n+     */\r\n+    public void readValue(String variableName) {\r\n+        if ((this.comms != null) && (this.vMap != null)) {\r\n+            final Semaphore lock = transactionLocks.get(this.comms.getEndpoint());\r\n+            HeliosVariable v = this.vMap.get(variableName);\r\n+            if (v.hasReadAccess()) {\r\n+                try {\r\n+                    lock.acquire(); // will block until lock is available\r\n+                } catch (InterruptedException e) {\r\n+                    logger.warn(\"{} encountered Exception when trying to read variable {} from the device: {}\",\r\n+                            HeliosEasyControlsHandler.class.getSimpleName(), variableName, e.getMessage());\r\n+                    return;\r\n+                }\r\n+                // write variable name to register\r\n+                String payload = v.getVariableString();\r\n+                this.comms.submitOneTimeWrite(new ModbusWriteRegisterRequestBlueprint(\r\n+                        HeliosEasyControlsBindingConstants.UNIT_ID, HeliosEasyControlsBindingConstants.START_ADDRESS,\r\n+                        new ModbusRegisterArray(preparePayload(payload)), true,\r\n+                        HeliosEasyControlsBindingConstants.MAX_TRIES), result -> {\r\n+                            this.comms.submitOneTimePoll(\r\n+                                    new ModbusReadRequestBlueprint(HeliosEasyControlsBindingConstants.UNIT_ID,\r\n+                                            ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS,\r\n+                                            HeliosEasyControlsBindingConstants.START_ADDRESS, v.getCount(),\r\n+                                            HeliosEasyControlsBindingConstants.MAX_TRIES),\r\n+                                    pollResult -> {\r\n+                                        lock.release();\r\n+                                        Optional<ModbusRegisterArray> registers = pollResult.getRegisters();\r\n+                                        if (registers.isPresent()) {\r\n+                                            processResponse(v, registers.get());\r\n+                                        }\r\n+                                    }, failureInfo -> {\r\n+                                        String errorMsg = failureInfo.getCause().getMessage();\r\n+                                        logger.warn(\"{} encountered error reading from device: {}\",\r\n+                                                HeliosEasyControlsHandler.class.getSimpleName(), errorMsg);\r\n+                                        lock.release();\r\n+                                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\r\n+                                                errorMsg);\r\n+                                    });\r\n+                        }, failureInfo -> {\r\n+                            String errorMsg = failureInfo.getCause().getMessage();\r\n+                            logger.warn(\"{} encountered error writing to device: {}\",\r\n+                                    HeliosEasyControlsHandler.class.getSimpleName(), errorMsg);\r\n+                            lock.release();\r\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorMsg);\r\n+\r\n+                        });\r\n+            }\r\n+        } else {\r\n+            if (this.comms == null) {\r\n+                this.handleError(\"Modbus communication interface is unavailable.\",\r\n+                        ThingStatusDetail.COMMUNICATION_ERROR);\r\n+            }\r\n+            if (this.vMap == null) {\r\n+                this.handleError(\"Variable definition is unavailable.\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    // TODO: set time incl. timezone, update time channels based on timezone read from device\r\n+\r\n+    /**\r\n+     * Formats the provided date to a string in the device's configured date format\r\n+     *\r\n+     * @param variableName the variable name\r\n+     * @param date the date to be formatted\r\n+     * @return a string in the device's configured date format\r\n+     */\r\n+    private String formatDate(String variableName, ZonedDateTime date) {\r", "originalCommit": "a29484f182958feae2d73f3ac06490316afc5798", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxNTU4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r479815582", "bodyText": "Better check the length in the else branch, too.", "author": "fwolter", "createdAt": "2020-08-30T21:05:42Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,684 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.nio.charset.StandardCharsets;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.QuantityType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\r\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.eclipse.smarthome.core.types.State;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+@NonNullByDefault\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    /**\r\n+     * Logger instance\r\n+     */\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    /**\r\n+     * Configuration instance\r\n+     */\r\n+    private @Nullable HeliosEasyControlsConfiguration config;\r\n+\r\n+    /**\r\n+     * Used to poll the variables' status based on the configured refresh interval\r\n+     */\r\n+    private @Nullable ScheduledFuture<?> pollingJob;\r\n+\r\n+    /**\r\n+     * The map holding the variable meta info by variable name\r\n+     */\r\n+    private @Nullable Map<String, HeliosVariable> vMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private static ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore>();\r\n+\r\n+    /**\r\n+     * Communication interface to the endpoint\r\n+     */\r\n+    private @Nullable ModbusCommunicationInterface comms;\r\n+\r\n+    /**\r\n+     * The date format used by the device\r\n+     */\r\n+    private int dateFormat = -1;\r\n+\r\n+    /**\r\n+     * The UTC offset of the device\r\n+     */\r\n+    private int utcOffset = 0;\r\n+\r\n+    /**\r\n+     * Constructor\r\n+     *\r\n+     * @param thing\r\n+     * @param managerRef\r\n+     */\r\n+    public HeliosEasyControlsHandler(Thing thing) {\r\n+        super(thing);\r\n+    }\r\n+\r\n+    /**\r\n+     * Reads variable definitions from JSON file and store them in vMap\r\n+     */\r\n+    private void readVariableDefinition() {\r\n+        Gson gson = new Gson();\r\n+        Type vMapType = new TypeToken<Map<String, HeliosVariable>>() {\r\n+        }.getType();\r\n+        this.vMap = gson.fromJson(\r\n+                new BufferedReader(new InputStreamReader(\r\n+                        getClass().getResourceAsStream(HeliosEasyControlsBindingConstants.VARIABLES_DEFINITION_FILE))),\r\n+                vMapType);\r\n+        if (vMap != null) {\r\n+            // add the name to the variable itself\r\n+            for (Map.Entry<String, HeliosVariable> entry : this.vMap.entrySet()) {\r\n+                entry.getValue().setName(entry.getKey()); // workaround to set the variable name inside the\r\n+                                                          // HeliosVariable object\r\n+                if (!entry.getValue().isOk()) {\r\n+                    this.handleError(\"Variables definition file contains inconsistent data.\",\r\n+                            ThingStatusDetail.CONFIGURATION_ERROR);\r\n+                }\r\n+            }\r\n+        } else {\r\n+            this.handleError(\"Variables definition file not found or of illegal format.\",\r\n+                    ThingStatusDetail.CONFIGURATION_ERROR);\r\n+        }\r\n+\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the endpoint handler from the bridge this handler is connected to\r\n+     * Checks that we're connected to the right type of bridge\r\n+     *\r\n+     * @return the endpoint handler or null if the bridge does not exist\r\n+     */\r\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\r\n+        Bridge bridge = getBridge();\r\n+        if (bridge == null) {\r\n+            logger.debug(\"Bridge is null\");\r\n+            return null;\r\n+        }\r\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\r\n+            logger.debug(\"Bridge is not online\");\r\n+            return null;\r\n+        }\r\n+\r\n+        ThingHandler handler = bridge.getHandler();\r\n+        if (handler == null) {\r\n+            logger.debug(\"Bridge handler is null\");\r\n+            return null;\r\n+        }\r\n+\r\n+        if (handler instanceof ModbusEndpointThingHandler) {\r\n+            return (ModbusEndpointThingHandler) handler;\r\n+        } else {\r\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\r\n+            return null;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get a reference to the modbus endpoint\r\n+     */\r\n+    private void connectEndpoint() {\r\n+        if (this.comms != null) {\r\n+            return;\r\n+        }\r\n+\r\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\r\n+        if (slaveEndpointThingHandler == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' is offline\", label));\r\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\r\n+            return;\r\n+        }\r\n+\r\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\r\n+\r\n+        if (comms == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\r\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\r\n+            return;\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void initialize() {\r\n+        this.config = getConfigAs(HeliosEasyControlsConfiguration.class);\r\n+        this.readVariableDefinition();\r\n+        this.connectEndpoint();\r\n+        if ((this.comms != null) && (this.vMap != null) && (this.config != null)) {\r\n+            HeliosEasyControlsHandler.transactionLocks.putIfAbsent(this.comms.getEndpoint(), new Semaphore(1, true));\r\n+            updateStatus(ThingStatus.UNKNOWN);\r\n+\r\n+            // background initialization\r\n+            scheduler.execute(() -> {\r\n+                readValue(HeliosEasyControlsBindingConstants.DATE_FORMAT);\r\n+                // status will be updated to ONLINE by the read callback function (via processResponse)\r\n+            });\r\n+\r\n+            // poll for status updates regularly\r\n+            Runnable runnable = new Runnable() {\r\n+\r\n+                @Override\r\n+                public void run() {\r\n+                    if (vMap != null) {\r\n+                        for (Map.Entry<String, HeliosVariable> entry : vMap.entrySet()) {\r\n+                            if (isLinked(entry.getKey())\r\n+                                    || (entry.getKey().equals(HeliosEasyControlsBindingConstants.DATE_FORMAT))\r\n+                                    || (entry.getKey()\r\n+                                            .equals(HeliosEasyControlsBindingConstants.TIME_ZONE_DIFFERENCE_TO_GMT))) {\r\n+                                readValue(entry.getKey());\r\n+                            }\r\n+                        }\r\n+\r\n+                    } else {\r\n+                        handleError(\"Variable definition is null\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+                    }\r\n+                }\r\n+            };\r\n+            this.pollingJob = scheduler.scheduleAtFixedRate(runnable, this.config.getRefreshInterval(),\r\n+                    this.config.getRefreshInterval(), TimeUnit.MILLISECONDS);\r\n+\r\n+        } else { // at least one null assertion has failed, let's log the problem and update the thing status\r\n+            if (this.comms == null) {\r\n+                this.handleError(\"Modbus communication interface is unavailable.\",\r\n+                        ThingStatusDetail.COMMUNICATION_ERROR);\r\n+            }\r\n+            if (this.vMap == null) {\r\n+                this.handleError(\"Variable definition is unavailable.\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            }\r\n+            if (this.config == null) {\r\n+                this.handleError(\"Binding configuration is unavailable.\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void dispose() {\r\n+        if (this.pollingJob != null) {\r\n+            this.pollingJob.cancel(true);\r\n+        }\r\n+        this.comms = null;\r\n+    }\r\n+\r\n+    @Override\r\n+    public void handleCommand(ChannelUID channelUID, Command command) {\r\n+        String channelId = channelUID.getIdWithoutGroup();\r\n+        if (command instanceof RefreshType) {\r\n+            scheduler.submit(new Runnable() {\r\n+                @Override\r\n+                public void run() {\r\n+                    readValue(channelId);\r\n+                }\r\n+            });\r\n+        } else { // write command\r\n+            String value = null;\r\n+            if (command instanceof OnOffType) {\r\n+                value = command == OnOffType.ON ? \"1\" : \"0\";\r\n+            } else if (command instanceof DateTimeType) {\r\n+                value = formatDate(channelId, ((DateTimeType) command).getZonedDateTime());\r\n+            } else if ((command instanceof DecimalType) || (command instanceof StringType)) {\r\n+                value = command.toString();\r\n+            } else if (command instanceof QuantityType<?>) {\r\n+                // convert item's unit to the Helios device's unit\r\n+                String unit = this.vMap.get(channelId).getUnit();\r\n+                QuantityType<?> val = (QuantityType<?>) command;\r\n+                if (unit != null) {\r\n+                    if (unit.equals(HeliosVariable.UNIT_DAY)) {\r\n+                        val = val.toUnit(SmartHomeUnits.DAY);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_HOUR)) {\r\n+                        val = val.toUnit(SmartHomeUnits.HOUR);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_MIN)) {\r\n+                        val = val.toUnit(SmartHomeUnits.MINUTE);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_SEC)) {\r\n+                        val = val.toUnit(SmartHomeUnits.SECOND);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_VOLT)) {\r\n+                        val = val.toUnit(SmartHomeUnits.VOLT);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_PERCENT)) {\r\n+                        val = val.toUnit(SmartHomeUnits.PERCENT);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_PPM)) {\r\n+                        val = val.toUnit(SmartHomeUnits.PARTS_PER_MILLION);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_TEMP)) {\r\n+                        val = val.toUnit(SIUnits.CELSIUS);\r\n+                    }\r\n+                    value = val != null ? String.valueOf(val.doubleValue()) : null; // ignore the UoM\r\n+                }\r\n+            }\r\n+            if (value != null) {\r\n+                final String v = value;\r\n+                scheduler.submit(new Runnable() {\r\n+                    @Override\r\n+                    public void run() {\r\n+                        try {\r\n+                            writeValue(channelId, v);\r\n+                            updateStatus(ThingStatus.ONLINE);\r\n+                        } catch (HeliosException e) {\r\n+                            logger.warn(\"Writing value {} to channel {} failed: {}\", v, channelId, e.getMessage());\r\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\r\n+                                    \"Writing to device failed.\");\r\n+                        }\r\n+                    }\r\n+                });\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Writes a variable value to the Helios device\r\n+     *\r\n+     * @param variableName The variable name\r\n+     * @param value The new value\r\n+     * @return The value if the transaction succeeded, <tt>null</tt> otherwise\r\n+     * @throws HeliosException Thrown if the variable is read-only or the provided value is out of range\r\n+     */\r\n+    public void writeValue(String variableName, String value) throws HeliosException {\r\n+        if (this.vMap == null) {\r\n+            this.handleError(\"Variable definition is unavailable.\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            return;\r\n+        } else {\r\n+            HeliosVariable v = this.vMap.get(variableName);\r\n+            if (!v.hasWriteAccess()) {\r\n+                throw new HeliosException(\"Variable \" + variableName + \" is read-only\");\r\n+            } else if (!v.isInAllowedRange(value)) {\r\n+                throw new HeliosException(\r\n+                        \"Value \" + value + \" is outside of allowed range of variable \" + variableName);\r\n+            } else if (this.comms != null) {\r\n+                // write to device\r\n+                String payload = v.getVariableString() + \"=\" + value;\r\n+                final Semaphore lock = transactionLocks.get(this.comms.getEndpoint());\r\n+                try {\r\n+                    lock.acquire();\r\n+                    this.comms.submitOneTimeWrite(\r\n+                            new ModbusWriteRegisterRequestBlueprint(HeliosEasyControlsBindingConstants.UNIT_ID,\r\n+                                    HeliosEasyControlsBindingConstants.START_ADDRESS,\r\n+                                    new ModbusRegisterArray(preparePayload(payload)), true,\r\n+                                    HeliosEasyControlsBindingConstants.MAX_TRIES),\r\n+                            result -> {\r\n+                                lock.release();\r\n+                                updateStatus(ThingStatus.ONLINE);\r\n+                            }, failureInfo -> {\r\n+                                String errorMsg = failureInfo.getCause().getMessage();\r\n+                                logger.warn(\"{} encountered error writing to device: {}\",\r\n+                                        HeliosEasyControlsHandler.class.getSimpleName(), errorMsg);\r\n+                                lock.release();\r\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorMsg);\r\n+                            });\r\n+                    // ensure the openHAB item is updated with the device's actual value\r\n+                    scheduler.schedule(new Runnable() {\r\n+                        @Override\r\n+                        public void run() {\r\n+                            readValue(variableName);\r\n+                        }\r\n+                    }, 1, TimeUnit.SECONDS);\r\n+                } catch (InterruptedException e) {\r\n+                    logger.warn(\r\n+                            \"{} encountered Exception when trying to lock Semaphore for writing variable {} to the device: {}\",\r\n+                            HeliosEasyControlsHandler.class.getSimpleName(), variableName, e.getMessage());\r\n+                }\r\n+            } else { // comms is null\r\n+                this.handleError(\"Modbus communication interface is null.\", ThingStatusDetail.COMMUNICATION_ERROR);\r\n+            }\r\n+        }\r\n+\r\n+    }\r\n+\r\n+    /**\r\n+     * Read a variable from the Helios device\r\n+     *\r\n+     * @param variableName The variable name\r\n+     * @return The value\r\n+     */\r\n+    public void readValue(String variableName) {\r\n+        if ((this.comms != null) && (this.vMap != null)) {\r\n+            final Semaphore lock = transactionLocks.get(this.comms.getEndpoint());\r\n+            HeliosVariable v = this.vMap.get(variableName);\r\n+            if (v.hasReadAccess()) {\r\n+                try {\r\n+                    lock.acquire(); // will block until lock is available\r\n+                } catch (InterruptedException e) {\r\n+                    logger.warn(\"{} encountered Exception when trying to read variable {} from the device: {}\",\r\n+                            HeliosEasyControlsHandler.class.getSimpleName(), variableName, e.getMessage());\r\n+                    return;\r\n+                }\r\n+                // write variable name to register\r\n+                String payload = v.getVariableString();\r\n+                this.comms.submitOneTimeWrite(new ModbusWriteRegisterRequestBlueprint(\r\n+                        HeliosEasyControlsBindingConstants.UNIT_ID, HeliosEasyControlsBindingConstants.START_ADDRESS,\r\n+                        new ModbusRegisterArray(preparePayload(payload)), true,\r\n+                        HeliosEasyControlsBindingConstants.MAX_TRIES), result -> {\r\n+                            this.comms.submitOneTimePoll(\r\n+                                    new ModbusReadRequestBlueprint(HeliosEasyControlsBindingConstants.UNIT_ID,\r\n+                                            ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS,\r\n+                                            HeliosEasyControlsBindingConstants.START_ADDRESS, v.getCount(),\r\n+                                            HeliosEasyControlsBindingConstants.MAX_TRIES),\r\n+                                    pollResult -> {\r\n+                                        lock.release();\r\n+                                        Optional<ModbusRegisterArray> registers = pollResult.getRegisters();\r\n+                                        if (registers.isPresent()) {\r\n+                                            processResponse(v, registers.get());\r\n+                                        }\r\n+                                    }, failureInfo -> {\r\n+                                        String errorMsg = failureInfo.getCause().getMessage();\r\n+                                        logger.warn(\"{} encountered error reading from device: {}\",\r\n+                                                HeliosEasyControlsHandler.class.getSimpleName(), errorMsg);\r\n+                                        lock.release();\r\n+                                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\r\n+                                                errorMsg);\r\n+                                    });\r\n+                        }, failureInfo -> {\r\n+                            String errorMsg = failureInfo.getCause().getMessage();\r\n+                            logger.warn(\"{} encountered error writing to device: {}\",\r\n+                                    HeliosEasyControlsHandler.class.getSimpleName(), errorMsg);\r\n+                            lock.release();\r\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorMsg);\r\n+\r\n+                        });\r\n+            }\r\n+        } else {\r\n+            if (this.comms == null) {\r\n+                this.handleError(\"Modbus communication interface is unavailable.\",\r\n+                        ThingStatusDetail.COMMUNICATION_ERROR);\r\n+            }\r\n+            if (this.vMap == null) {\r\n+                this.handleError(\"Variable definition is unavailable.\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    // TODO: set time incl. timezone, update time channels based on timezone read from device\r\n+\r\n+    /**\r\n+     * Formats the provided date to a string in the device's configured date format\r\n+     *\r\n+     * @param variableName the variable name\r\n+     * @param date the date to be formatted\r\n+     * @return a string in the device's configured date format\r\n+     */\r\n+    private String formatDate(String variableName, ZonedDateTime date) {\r\n+        String y = Integer.toString(date.getYear());\r\n+        String m = Integer.toString(date.getMonthValue());\r\n+        if (m.length() == 1) {\r\n+            m = \"0\" + m;\r\n+        }\r\n+        String d = Integer.toString(date.getDayOfMonth());\r\n+        if (d.length() == 1) {\r\n+            d = \"0\" + d;\r\n+        }\r\n+        if (variableName.equals(HeliosEasyControlsBindingConstants.DATE)) { // fixed format for writing the system date\r\n+            return d + \".\" + m + \".\" + y;\r\n+        } else {\r\n+            switch (this.dateFormat) {\r\n+                case 0: // dd.mm.yyyy\r\n+                    return d + \".\" + m + \".\" + y;\r\n+                case 1: // mm.dd.yyyy\r\n+                    return m + \".\" + d + \".\" + y;\r\n+                case 2: // yyyy.mm.dd\r\n+                    return y + \".\" + m + \".\" + d;\r\n+                default:\r\n+                    return d + \".\" + m + \".\" + y;\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns a DateTimeType object based on the provided String and the device's configured date format\r\n+     *\r\n+     * @param date The date string read from the device\r\n+     * @return A DateTimeType object representing the date or time specified\r\n+     */\r\n+    private DateTimeType toDateTime(String date) {\r\n+        String[] dateTimeParts = null;\r\n+        String dateTime = date;\r\n+        try { // date\r\n+            dateTimeParts = date.split(\"\\\\.\"); // try to split date components\r\n+            if (dateTimeParts.length == 1) { // time\r\n+                return DateTimeType.valueOf(date);\r\n+            } else { // date - we'll try the device's date format\r\n+                switch (this.dateFormat) {\r", "originalCommit": "a29484f182958feae2d73f3ac06490316afc5798", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxNTYyNw==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r479815627", "bodyText": "What type of exception do you expect here? Can you specify the concrete type?", "author": "fwolter", "createdAt": "2020-08-30T21:06:15Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,684 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.nio.charset.StandardCharsets;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.QuantityType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\r\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.eclipse.smarthome.core.types.State;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+@NonNullByDefault\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    /**\r\n+     * Logger instance\r\n+     */\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    /**\r\n+     * Configuration instance\r\n+     */\r\n+    private @Nullable HeliosEasyControlsConfiguration config;\r\n+\r\n+    /**\r\n+     * Used to poll the variables' status based on the configured refresh interval\r\n+     */\r\n+    private @Nullable ScheduledFuture<?> pollingJob;\r\n+\r\n+    /**\r\n+     * The map holding the variable meta info by variable name\r\n+     */\r\n+    private @Nullable Map<String, HeliosVariable> vMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private static ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore>();\r\n+\r\n+    /**\r\n+     * Communication interface to the endpoint\r\n+     */\r\n+    private @Nullable ModbusCommunicationInterface comms;\r\n+\r\n+    /**\r\n+     * The date format used by the device\r\n+     */\r\n+    private int dateFormat = -1;\r\n+\r\n+    /**\r\n+     * The UTC offset of the device\r\n+     */\r\n+    private int utcOffset = 0;\r\n+\r\n+    /**\r\n+     * Constructor\r\n+     *\r\n+     * @param thing\r\n+     * @param managerRef\r\n+     */\r\n+    public HeliosEasyControlsHandler(Thing thing) {\r\n+        super(thing);\r\n+    }\r\n+\r\n+    /**\r\n+     * Reads variable definitions from JSON file and store them in vMap\r\n+     */\r\n+    private void readVariableDefinition() {\r\n+        Gson gson = new Gson();\r\n+        Type vMapType = new TypeToken<Map<String, HeliosVariable>>() {\r\n+        }.getType();\r\n+        this.vMap = gson.fromJson(\r\n+                new BufferedReader(new InputStreamReader(\r\n+                        getClass().getResourceAsStream(HeliosEasyControlsBindingConstants.VARIABLES_DEFINITION_FILE))),\r\n+                vMapType);\r\n+        if (vMap != null) {\r\n+            // add the name to the variable itself\r\n+            for (Map.Entry<String, HeliosVariable> entry : this.vMap.entrySet()) {\r\n+                entry.getValue().setName(entry.getKey()); // workaround to set the variable name inside the\r\n+                                                          // HeliosVariable object\r\n+                if (!entry.getValue().isOk()) {\r\n+                    this.handleError(\"Variables definition file contains inconsistent data.\",\r\n+                            ThingStatusDetail.CONFIGURATION_ERROR);\r\n+                }\r\n+            }\r\n+        } else {\r\n+            this.handleError(\"Variables definition file not found or of illegal format.\",\r\n+                    ThingStatusDetail.CONFIGURATION_ERROR);\r\n+        }\r\n+\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the endpoint handler from the bridge this handler is connected to\r\n+     * Checks that we're connected to the right type of bridge\r\n+     *\r\n+     * @return the endpoint handler or null if the bridge does not exist\r\n+     */\r\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\r\n+        Bridge bridge = getBridge();\r\n+        if (bridge == null) {\r\n+            logger.debug(\"Bridge is null\");\r\n+            return null;\r\n+        }\r\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\r\n+            logger.debug(\"Bridge is not online\");\r\n+            return null;\r\n+        }\r\n+\r\n+        ThingHandler handler = bridge.getHandler();\r\n+        if (handler == null) {\r\n+            logger.debug(\"Bridge handler is null\");\r\n+            return null;\r\n+        }\r\n+\r\n+        if (handler instanceof ModbusEndpointThingHandler) {\r\n+            return (ModbusEndpointThingHandler) handler;\r\n+        } else {\r\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\r\n+            return null;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get a reference to the modbus endpoint\r\n+     */\r\n+    private void connectEndpoint() {\r\n+        if (this.comms != null) {\r\n+            return;\r\n+        }\r\n+\r\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\r\n+        if (slaveEndpointThingHandler == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' is offline\", label));\r\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\r\n+            return;\r\n+        }\r\n+\r\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\r\n+\r\n+        if (comms == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\r\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\r\n+            return;\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void initialize() {\r\n+        this.config = getConfigAs(HeliosEasyControlsConfiguration.class);\r\n+        this.readVariableDefinition();\r\n+        this.connectEndpoint();\r\n+        if ((this.comms != null) && (this.vMap != null) && (this.config != null)) {\r\n+            HeliosEasyControlsHandler.transactionLocks.putIfAbsent(this.comms.getEndpoint(), new Semaphore(1, true));\r\n+            updateStatus(ThingStatus.UNKNOWN);\r\n+\r\n+            // background initialization\r\n+            scheduler.execute(() -> {\r\n+                readValue(HeliosEasyControlsBindingConstants.DATE_FORMAT);\r\n+                // status will be updated to ONLINE by the read callback function (via processResponse)\r\n+            });\r\n+\r\n+            // poll for status updates regularly\r\n+            Runnable runnable = new Runnable() {\r\n+\r\n+                @Override\r\n+                public void run() {\r\n+                    if (vMap != null) {\r\n+                        for (Map.Entry<String, HeliosVariable> entry : vMap.entrySet()) {\r\n+                            if (isLinked(entry.getKey())\r\n+                                    || (entry.getKey().equals(HeliosEasyControlsBindingConstants.DATE_FORMAT))\r\n+                                    || (entry.getKey()\r\n+                                            .equals(HeliosEasyControlsBindingConstants.TIME_ZONE_DIFFERENCE_TO_GMT))) {\r\n+                                readValue(entry.getKey());\r\n+                            }\r\n+                        }\r\n+\r\n+                    } else {\r\n+                        handleError(\"Variable definition is null\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+                    }\r\n+                }\r\n+            };\r\n+            this.pollingJob = scheduler.scheduleAtFixedRate(runnable, this.config.getRefreshInterval(),\r\n+                    this.config.getRefreshInterval(), TimeUnit.MILLISECONDS);\r\n+\r\n+        } else { // at least one null assertion has failed, let's log the problem and update the thing status\r\n+            if (this.comms == null) {\r\n+                this.handleError(\"Modbus communication interface is unavailable.\",\r\n+                        ThingStatusDetail.COMMUNICATION_ERROR);\r\n+            }\r\n+            if (this.vMap == null) {\r\n+                this.handleError(\"Variable definition is unavailable.\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            }\r\n+            if (this.config == null) {\r\n+                this.handleError(\"Binding configuration is unavailable.\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void dispose() {\r\n+        if (this.pollingJob != null) {\r\n+            this.pollingJob.cancel(true);\r\n+        }\r\n+        this.comms = null;\r\n+    }\r\n+\r\n+    @Override\r\n+    public void handleCommand(ChannelUID channelUID, Command command) {\r\n+        String channelId = channelUID.getIdWithoutGroup();\r\n+        if (command instanceof RefreshType) {\r\n+            scheduler.submit(new Runnable() {\r\n+                @Override\r\n+                public void run() {\r\n+                    readValue(channelId);\r\n+                }\r\n+            });\r\n+        } else { // write command\r\n+            String value = null;\r\n+            if (command instanceof OnOffType) {\r\n+                value = command == OnOffType.ON ? \"1\" : \"0\";\r\n+            } else if (command instanceof DateTimeType) {\r\n+                value = formatDate(channelId, ((DateTimeType) command).getZonedDateTime());\r\n+            } else if ((command instanceof DecimalType) || (command instanceof StringType)) {\r\n+                value = command.toString();\r\n+            } else if (command instanceof QuantityType<?>) {\r\n+                // convert item's unit to the Helios device's unit\r\n+                String unit = this.vMap.get(channelId).getUnit();\r\n+                QuantityType<?> val = (QuantityType<?>) command;\r\n+                if (unit != null) {\r\n+                    if (unit.equals(HeliosVariable.UNIT_DAY)) {\r\n+                        val = val.toUnit(SmartHomeUnits.DAY);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_HOUR)) {\r\n+                        val = val.toUnit(SmartHomeUnits.HOUR);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_MIN)) {\r\n+                        val = val.toUnit(SmartHomeUnits.MINUTE);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_SEC)) {\r\n+                        val = val.toUnit(SmartHomeUnits.SECOND);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_VOLT)) {\r\n+                        val = val.toUnit(SmartHomeUnits.VOLT);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_PERCENT)) {\r\n+                        val = val.toUnit(SmartHomeUnits.PERCENT);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_PPM)) {\r\n+                        val = val.toUnit(SmartHomeUnits.PARTS_PER_MILLION);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_TEMP)) {\r\n+                        val = val.toUnit(SIUnits.CELSIUS);\r\n+                    }\r\n+                    value = val != null ? String.valueOf(val.doubleValue()) : null; // ignore the UoM\r\n+                }\r\n+            }\r\n+            if (value != null) {\r\n+                final String v = value;\r\n+                scheduler.submit(new Runnable() {\r\n+                    @Override\r\n+                    public void run() {\r\n+                        try {\r\n+                            writeValue(channelId, v);\r\n+                            updateStatus(ThingStatus.ONLINE);\r\n+                        } catch (HeliosException e) {\r\n+                            logger.warn(\"Writing value {} to channel {} failed: {}\", v, channelId, e.getMessage());\r\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\r\n+                                    \"Writing to device failed.\");\r\n+                        }\r\n+                    }\r\n+                });\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Writes a variable value to the Helios device\r\n+     *\r\n+     * @param variableName The variable name\r\n+     * @param value The new value\r\n+     * @return The value if the transaction succeeded, <tt>null</tt> otherwise\r\n+     * @throws HeliosException Thrown if the variable is read-only or the provided value is out of range\r\n+     */\r\n+    public void writeValue(String variableName, String value) throws HeliosException {\r\n+        if (this.vMap == null) {\r\n+            this.handleError(\"Variable definition is unavailable.\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            return;\r\n+        } else {\r\n+            HeliosVariable v = this.vMap.get(variableName);\r\n+            if (!v.hasWriteAccess()) {\r\n+                throw new HeliosException(\"Variable \" + variableName + \" is read-only\");\r\n+            } else if (!v.isInAllowedRange(value)) {\r\n+                throw new HeliosException(\r\n+                        \"Value \" + value + \" is outside of allowed range of variable \" + variableName);\r\n+            } else if (this.comms != null) {\r\n+                // write to device\r\n+                String payload = v.getVariableString() + \"=\" + value;\r\n+                final Semaphore lock = transactionLocks.get(this.comms.getEndpoint());\r\n+                try {\r\n+                    lock.acquire();\r\n+                    this.comms.submitOneTimeWrite(\r\n+                            new ModbusWriteRegisterRequestBlueprint(HeliosEasyControlsBindingConstants.UNIT_ID,\r\n+                                    HeliosEasyControlsBindingConstants.START_ADDRESS,\r\n+                                    new ModbusRegisterArray(preparePayload(payload)), true,\r\n+                                    HeliosEasyControlsBindingConstants.MAX_TRIES),\r\n+                            result -> {\r\n+                                lock.release();\r\n+                                updateStatus(ThingStatus.ONLINE);\r\n+                            }, failureInfo -> {\r\n+                                String errorMsg = failureInfo.getCause().getMessage();\r\n+                                logger.warn(\"{} encountered error writing to device: {}\",\r\n+                                        HeliosEasyControlsHandler.class.getSimpleName(), errorMsg);\r\n+                                lock.release();\r\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorMsg);\r\n+                            });\r\n+                    // ensure the openHAB item is updated with the device's actual value\r\n+                    scheduler.schedule(new Runnable() {\r\n+                        @Override\r\n+                        public void run() {\r\n+                            readValue(variableName);\r\n+                        }\r\n+                    }, 1, TimeUnit.SECONDS);\r\n+                } catch (InterruptedException e) {\r\n+                    logger.warn(\r\n+                            \"{} encountered Exception when trying to lock Semaphore for writing variable {} to the device: {}\",\r\n+                            HeliosEasyControlsHandler.class.getSimpleName(), variableName, e.getMessage());\r\n+                }\r\n+            } else { // comms is null\r\n+                this.handleError(\"Modbus communication interface is null.\", ThingStatusDetail.COMMUNICATION_ERROR);\r\n+            }\r\n+        }\r\n+\r\n+    }\r\n+\r\n+    /**\r\n+     * Read a variable from the Helios device\r\n+     *\r\n+     * @param variableName The variable name\r\n+     * @return The value\r\n+     */\r\n+    public void readValue(String variableName) {\r\n+        if ((this.comms != null) && (this.vMap != null)) {\r\n+            final Semaphore lock = transactionLocks.get(this.comms.getEndpoint());\r\n+            HeliosVariable v = this.vMap.get(variableName);\r\n+            if (v.hasReadAccess()) {\r\n+                try {\r\n+                    lock.acquire(); // will block until lock is available\r\n+                } catch (InterruptedException e) {\r\n+                    logger.warn(\"{} encountered Exception when trying to read variable {} from the device: {}\",\r\n+                            HeliosEasyControlsHandler.class.getSimpleName(), variableName, e.getMessage());\r\n+                    return;\r\n+                }\r\n+                // write variable name to register\r\n+                String payload = v.getVariableString();\r\n+                this.comms.submitOneTimeWrite(new ModbusWriteRegisterRequestBlueprint(\r\n+                        HeliosEasyControlsBindingConstants.UNIT_ID, HeliosEasyControlsBindingConstants.START_ADDRESS,\r\n+                        new ModbusRegisterArray(preparePayload(payload)), true,\r\n+                        HeliosEasyControlsBindingConstants.MAX_TRIES), result -> {\r\n+                            this.comms.submitOneTimePoll(\r\n+                                    new ModbusReadRequestBlueprint(HeliosEasyControlsBindingConstants.UNIT_ID,\r\n+                                            ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS,\r\n+                                            HeliosEasyControlsBindingConstants.START_ADDRESS, v.getCount(),\r\n+                                            HeliosEasyControlsBindingConstants.MAX_TRIES),\r\n+                                    pollResult -> {\r\n+                                        lock.release();\r\n+                                        Optional<ModbusRegisterArray> registers = pollResult.getRegisters();\r\n+                                        if (registers.isPresent()) {\r\n+                                            processResponse(v, registers.get());\r\n+                                        }\r\n+                                    }, failureInfo -> {\r\n+                                        String errorMsg = failureInfo.getCause().getMessage();\r\n+                                        logger.warn(\"{} encountered error reading from device: {}\",\r\n+                                                HeliosEasyControlsHandler.class.getSimpleName(), errorMsg);\r\n+                                        lock.release();\r\n+                                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\r\n+                                                errorMsg);\r\n+                                    });\r\n+                        }, failureInfo -> {\r\n+                            String errorMsg = failureInfo.getCause().getMessage();\r\n+                            logger.warn(\"{} encountered error writing to device: {}\",\r\n+                                    HeliosEasyControlsHandler.class.getSimpleName(), errorMsg);\r\n+                            lock.release();\r\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorMsg);\r\n+\r\n+                        });\r\n+            }\r\n+        } else {\r\n+            if (this.comms == null) {\r\n+                this.handleError(\"Modbus communication interface is unavailable.\",\r\n+                        ThingStatusDetail.COMMUNICATION_ERROR);\r\n+            }\r\n+            if (this.vMap == null) {\r\n+                this.handleError(\"Variable definition is unavailable.\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    // TODO: set time incl. timezone, update time channels based on timezone read from device\r\n+\r\n+    /**\r\n+     * Formats the provided date to a string in the device's configured date format\r\n+     *\r\n+     * @param variableName the variable name\r\n+     * @param date the date to be formatted\r\n+     * @return a string in the device's configured date format\r\n+     */\r\n+    private String formatDate(String variableName, ZonedDateTime date) {\r\n+        String y = Integer.toString(date.getYear());\r\n+        String m = Integer.toString(date.getMonthValue());\r\n+        if (m.length() == 1) {\r\n+            m = \"0\" + m;\r\n+        }\r\n+        String d = Integer.toString(date.getDayOfMonth());\r\n+        if (d.length() == 1) {\r\n+            d = \"0\" + d;\r\n+        }\r\n+        if (variableName.equals(HeliosEasyControlsBindingConstants.DATE)) { // fixed format for writing the system date\r\n+            return d + \".\" + m + \".\" + y;\r\n+        } else {\r\n+            switch (this.dateFormat) {\r\n+                case 0: // dd.mm.yyyy\r\n+                    return d + \".\" + m + \".\" + y;\r\n+                case 1: // mm.dd.yyyy\r\n+                    return m + \".\" + d + \".\" + y;\r\n+                case 2: // yyyy.mm.dd\r\n+                    return y + \".\" + m + \".\" + d;\r\n+                default:\r\n+                    return d + \".\" + m + \".\" + y;\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns a DateTimeType object based on the provided String and the device's configured date format\r\n+     *\r\n+     * @param date The date string read from the device\r\n+     * @return A DateTimeType object representing the date or time specified\r\n+     */\r\n+    private DateTimeType toDateTime(String date) {\r\n+        String[] dateTimeParts = null;\r\n+        String dateTime = date;\r\n+        try { // date\r\n+            dateTimeParts = date.split(\"\\\\.\"); // try to split date components\r\n+            if (dateTimeParts.length == 1) { // time\r\n+                return DateTimeType.valueOf(date);\r\n+            } else { // date - we'll try the device's date format\r\n+                switch (this.dateFormat) {\r\n+                    case 0: // dd.mm.yyyy\r\n+                        dateTime = dateTimeParts[2] + \"-\" + dateTimeParts[1] + \"-\" + dateTimeParts[0];\r\n+                        break;\r\n+                    case 1: // mm.dd.yyyy\r\n+                        dateTime = dateTimeParts[2] + \"-\" + dateTimeParts[0] + \"-\" + dateTimeParts[1];\r\n+                        break;\r\n+                    case 2: // yyyy.mm.dd\r\n+                        dateTime = dateTimeParts[0] + \"-\" + dateTimeParts[1] + \"-\" + dateTimeParts[2];\r\n+                        break;\r\n+                    default:\r\n+                        dateTime = dateTimeParts[2] + \"-\" + dateTimeParts[1] + \"-\" + dateTimeParts[0];\r\n+                        break;\r\n+                }\r\n+                return DateTimeType.valueOf(dateTime);\r\n+            }\r\n+        } catch (Exception e) {\r", "originalCommit": "a29484f182958feae2d73f3ac06490316afc5798", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxNTc3MA==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r479815770", "bodyText": "Isn't the date format fixed in the protocol?", "author": "fwolter", "createdAt": "2020-08-30T21:07:39Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,684 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.nio.charset.StandardCharsets;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.QuantityType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\r\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.eclipse.smarthome.core.types.State;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+@NonNullByDefault\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    /**\r\n+     * Logger instance\r\n+     */\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    /**\r\n+     * Configuration instance\r\n+     */\r\n+    private @Nullable HeliosEasyControlsConfiguration config;\r\n+\r\n+    /**\r\n+     * Used to poll the variables' status based on the configured refresh interval\r\n+     */\r\n+    private @Nullable ScheduledFuture<?> pollingJob;\r\n+\r\n+    /**\r\n+     * The map holding the variable meta info by variable name\r\n+     */\r\n+    private @Nullable Map<String, HeliosVariable> vMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private static ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore>();\r\n+\r\n+    /**\r\n+     * Communication interface to the endpoint\r\n+     */\r\n+    private @Nullable ModbusCommunicationInterface comms;\r\n+\r\n+    /**\r\n+     * The date format used by the device\r\n+     */\r\n+    private int dateFormat = -1;\r\n+\r\n+    /**\r\n+     * The UTC offset of the device\r\n+     */\r\n+    private int utcOffset = 0;\r\n+\r\n+    /**\r\n+     * Constructor\r\n+     *\r\n+     * @param thing\r\n+     * @param managerRef\r\n+     */\r\n+    public HeliosEasyControlsHandler(Thing thing) {\r\n+        super(thing);\r\n+    }\r\n+\r\n+    /**\r\n+     * Reads variable definitions from JSON file and store them in vMap\r\n+     */\r\n+    private void readVariableDefinition() {\r\n+        Gson gson = new Gson();\r\n+        Type vMapType = new TypeToken<Map<String, HeliosVariable>>() {\r\n+        }.getType();\r\n+        this.vMap = gson.fromJson(\r\n+                new BufferedReader(new InputStreamReader(\r\n+                        getClass().getResourceAsStream(HeliosEasyControlsBindingConstants.VARIABLES_DEFINITION_FILE))),\r\n+                vMapType);\r\n+        if (vMap != null) {\r\n+            // add the name to the variable itself\r\n+            for (Map.Entry<String, HeliosVariable> entry : this.vMap.entrySet()) {\r\n+                entry.getValue().setName(entry.getKey()); // workaround to set the variable name inside the\r\n+                                                          // HeliosVariable object\r\n+                if (!entry.getValue().isOk()) {\r\n+                    this.handleError(\"Variables definition file contains inconsistent data.\",\r\n+                            ThingStatusDetail.CONFIGURATION_ERROR);\r\n+                }\r\n+            }\r\n+        } else {\r\n+            this.handleError(\"Variables definition file not found or of illegal format.\",\r\n+                    ThingStatusDetail.CONFIGURATION_ERROR);\r\n+        }\r\n+\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the endpoint handler from the bridge this handler is connected to\r\n+     * Checks that we're connected to the right type of bridge\r\n+     *\r\n+     * @return the endpoint handler or null if the bridge does not exist\r\n+     */\r\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\r\n+        Bridge bridge = getBridge();\r\n+        if (bridge == null) {\r\n+            logger.debug(\"Bridge is null\");\r\n+            return null;\r\n+        }\r\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\r\n+            logger.debug(\"Bridge is not online\");\r\n+            return null;\r\n+        }\r\n+\r\n+        ThingHandler handler = bridge.getHandler();\r\n+        if (handler == null) {\r\n+            logger.debug(\"Bridge handler is null\");\r\n+            return null;\r\n+        }\r\n+\r\n+        if (handler instanceof ModbusEndpointThingHandler) {\r\n+            return (ModbusEndpointThingHandler) handler;\r\n+        } else {\r\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\r\n+            return null;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get a reference to the modbus endpoint\r\n+     */\r\n+    private void connectEndpoint() {\r\n+        if (this.comms != null) {\r\n+            return;\r\n+        }\r\n+\r\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\r\n+        if (slaveEndpointThingHandler == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' is offline\", label));\r\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\r\n+            return;\r\n+        }\r\n+\r\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\r\n+\r\n+        if (comms == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\r\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\r\n+            return;\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void initialize() {\r\n+        this.config = getConfigAs(HeliosEasyControlsConfiguration.class);\r\n+        this.readVariableDefinition();\r\n+        this.connectEndpoint();\r\n+        if ((this.comms != null) && (this.vMap != null) && (this.config != null)) {\r\n+            HeliosEasyControlsHandler.transactionLocks.putIfAbsent(this.comms.getEndpoint(), new Semaphore(1, true));\r\n+            updateStatus(ThingStatus.UNKNOWN);\r\n+\r\n+            // background initialization\r\n+            scheduler.execute(() -> {\r\n+                readValue(HeliosEasyControlsBindingConstants.DATE_FORMAT);\r\n+                // status will be updated to ONLINE by the read callback function (via processResponse)\r\n+            });\r\n+\r\n+            // poll for status updates regularly\r\n+            Runnable runnable = new Runnable() {\r\n+\r\n+                @Override\r\n+                public void run() {\r\n+                    if (vMap != null) {\r\n+                        for (Map.Entry<String, HeliosVariable> entry : vMap.entrySet()) {\r\n+                            if (isLinked(entry.getKey())\r\n+                                    || (entry.getKey().equals(HeliosEasyControlsBindingConstants.DATE_FORMAT))\r\n+                                    || (entry.getKey()\r\n+                                            .equals(HeliosEasyControlsBindingConstants.TIME_ZONE_DIFFERENCE_TO_GMT))) {\r\n+                                readValue(entry.getKey());\r\n+                            }\r\n+                        }\r\n+\r\n+                    } else {\r\n+                        handleError(\"Variable definition is null\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+                    }\r\n+                }\r\n+            };\r\n+            this.pollingJob = scheduler.scheduleAtFixedRate(runnable, this.config.getRefreshInterval(),\r\n+                    this.config.getRefreshInterval(), TimeUnit.MILLISECONDS);\r\n+\r\n+        } else { // at least one null assertion has failed, let's log the problem and update the thing status\r\n+            if (this.comms == null) {\r\n+                this.handleError(\"Modbus communication interface is unavailable.\",\r\n+                        ThingStatusDetail.COMMUNICATION_ERROR);\r\n+            }\r\n+            if (this.vMap == null) {\r\n+                this.handleError(\"Variable definition is unavailable.\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            }\r\n+            if (this.config == null) {\r\n+                this.handleError(\"Binding configuration is unavailable.\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void dispose() {\r\n+        if (this.pollingJob != null) {\r\n+            this.pollingJob.cancel(true);\r\n+        }\r\n+        this.comms = null;\r\n+    }\r\n+\r\n+    @Override\r\n+    public void handleCommand(ChannelUID channelUID, Command command) {\r\n+        String channelId = channelUID.getIdWithoutGroup();\r\n+        if (command instanceof RefreshType) {\r\n+            scheduler.submit(new Runnable() {\r\n+                @Override\r\n+                public void run() {\r\n+                    readValue(channelId);\r\n+                }\r\n+            });\r\n+        } else { // write command\r\n+            String value = null;\r\n+            if (command instanceof OnOffType) {\r\n+                value = command == OnOffType.ON ? \"1\" : \"0\";\r\n+            } else if (command instanceof DateTimeType) {\r\n+                value = formatDate(channelId, ((DateTimeType) command).getZonedDateTime());\r\n+            } else if ((command instanceof DecimalType) || (command instanceof StringType)) {\r\n+                value = command.toString();\r\n+            } else if (command instanceof QuantityType<?>) {\r\n+                // convert item's unit to the Helios device's unit\r\n+                String unit = this.vMap.get(channelId).getUnit();\r\n+                QuantityType<?> val = (QuantityType<?>) command;\r\n+                if (unit != null) {\r\n+                    if (unit.equals(HeliosVariable.UNIT_DAY)) {\r\n+                        val = val.toUnit(SmartHomeUnits.DAY);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_HOUR)) {\r\n+                        val = val.toUnit(SmartHomeUnits.HOUR);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_MIN)) {\r\n+                        val = val.toUnit(SmartHomeUnits.MINUTE);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_SEC)) {\r\n+                        val = val.toUnit(SmartHomeUnits.SECOND);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_VOLT)) {\r\n+                        val = val.toUnit(SmartHomeUnits.VOLT);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_PERCENT)) {\r\n+                        val = val.toUnit(SmartHomeUnits.PERCENT);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_PPM)) {\r\n+                        val = val.toUnit(SmartHomeUnits.PARTS_PER_MILLION);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_TEMP)) {\r\n+                        val = val.toUnit(SIUnits.CELSIUS);\r\n+                    }\r\n+                    value = val != null ? String.valueOf(val.doubleValue()) : null; // ignore the UoM\r\n+                }\r\n+            }\r\n+            if (value != null) {\r\n+                final String v = value;\r\n+                scheduler.submit(new Runnable() {\r\n+                    @Override\r\n+                    public void run() {\r\n+                        try {\r\n+                            writeValue(channelId, v);\r\n+                            updateStatus(ThingStatus.ONLINE);\r\n+                        } catch (HeliosException e) {\r\n+                            logger.warn(\"Writing value {} to channel {} failed: {}\", v, channelId, e.getMessage());\r\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\r\n+                                    \"Writing to device failed.\");\r\n+                        }\r\n+                    }\r\n+                });\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Writes a variable value to the Helios device\r\n+     *\r\n+     * @param variableName The variable name\r\n+     * @param value The new value\r\n+     * @return The value if the transaction succeeded, <tt>null</tt> otherwise\r\n+     * @throws HeliosException Thrown if the variable is read-only or the provided value is out of range\r\n+     */\r\n+    public void writeValue(String variableName, String value) throws HeliosException {\r\n+        if (this.vMap == null) {\r\n+            this.handleError(\"Variable definition is unavailable.\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            return;\r\n+        } else {\r\n+            HeliosVariable v = this.vMap.get(variableName);\r\n+            if (!v.hasWriteAccess()) {\r\n+                throw new HeliosException(\"Variable \" + variableName + \" is read-only\");\r\n+            } else if (!v.isInAllowedRange(value)) {\r\n+                throw new HeliosException(\r\n+                        \"Value \" + value + \" is outside of allowed range of variable \" + variableName);\r\n+            } else if (this.comms != null) {\r\n+                // write to device\r\n+                String payload = v.getVariableString() + \"=\" + value;\r\n+                final Semaphore lock = transactionLocks.get(this.comms.getEndpoint());\r\n+                try {\r\n+                    lock.acquire();\r\n+                    this.comms.submitOneTimeWrite(\r\n+                            new ModbusWriteRegisterRequestBlueprint(HeliosEasyControlsBindingConstants.UNIT_ID,\r\n+                                    HeliosEasyControlsBindingConstants.START_ADDRESS,\r\n+                                    new ModbusRegisterArray(preparePayload(payload)), true,\r\n+                                    HeliosEasyControlsBindingConstants.MAX_TRIES),\r\n+                            result -> {\r\n+                                lock.release();\r\n+                                updateStatus(ThingStatus.ONLINE);\r\n+                            }, failureInfo -> {\r\n+                                String errorMsg = failureInfo.getCause().getMessage();\r\n+                                logger.warn(\"{} encountered error writing to device: {}\",\r\n+                                        HeliosEasyControlsHandler.class.getSimpleName(), errorMsg);\r\n+                                lock.release();\r\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorMsg);\r\n+                            });\r\n+                    // ensure the openHAB item is updated with the device's actual value\r\n+                    scheduler.schedule(new Runnable() {\r\n+                        @Override\r\n+                        public void run() {\r\n+                            readValue(variableName);\r\n+                        }\r\n+                    }, 1, TimeUnit.SECONDS);\r\n+                } catch (InterruptedException e) {\r\n+                    logger.warn(\r\n+                            \"{} encountered Exception when trying to lock Semaphore for writing variable {} to the device: {}\",\r\n+                            HeliosEasyControlsHandler.class.getSimpleName(), variableName, e.getMessage());\r\n+                }\r\n+            } else { // comms is null\r\n+                this.handleError(\"Modbus communication interface is null.\", ThingStatusDetail.COMMUNICATION_ERROR);\r\n+            }\r\n+        }\r\n+\r\n+    }\r\n+\r\n+    /**\r\n+     * Read a variable from the Helios device\r\n+     *\r\n+     * @param variableName The variable name\r\n+     * @return The value\r\n+     */\r\n+    public void readValue(String variableName) {\r\n+        if ((this.comms != null) && (this.vMap != null)) {\r\n+            final Semaphore lock = transactionLocks.get(this.comms.getEndpoint());\r\n+            HeliosVariable v = this.vMap.get(variableName);\r\n+            if (v.hasReadAccess()) {\r\n+                try {\r\n+                    lock.acquire(); // will block until lock is available\r\n+                } catch (InterruptedException e) {\r\n+                    logger.warn(\"{} encountered Exception when trying to read variable {} from the device: {}\",\r\n+                            HeliosEasyControlsHandler.class.getSimpleName(), variableName, e.getMessage());\r\n+                    return;\r\n+                }\r\n+                // write variable name to register\r\n+                String payload = v.getVariableString();\r\n+                this.comms.submitOneTimeWrite(new ModbusWriteRegisterRequestBlueprint(\r\n+                        HeliosEasyControlsBindingConstants.UNIT_ID, HeliosEasyControlsBindingConstants.START_ADDRESS,\r\n+                        new ModbusRegisterArray(preparePayload(payload)), true,\r\n+                        HeliosEasyControlsBindingConstants.MAX_TRIES), result -> {\r\n+                            this.comms.submitOneTimePoll(\r\n+                                    new ModbusReadRequestBlueprint(HeliosEasyControlsBindingConstants.UNIT_ID,\r\n+                                            ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS,\r\n+                                            HeliosEasyControlsBindingConstants.START_ADDRESS, v.getCount(),\r\n+                                            HeliosEasyControlsBindingConstants.MAX_TRIES),\r\n+                                    pollResult -> {\r\n+                                        lock.release();\r\n+                                        Optional<ModbusRegisterArray> registers = pollResult.getRegisters();\r\n+                                        if (registers.isPresent()) {\r\n+                                            processResponse(v, registers.get());\r\n+                                        }\r\n+                                    }, failureInfo -> {\r\n+                                        String errorMsg = failureInfo.getCause().getMessage();\r\n+                                        logger.warn(\"{} encountered error reading from device: {}\",\r\n+                                                HeliosEasyControlsHandler.class.getSimpleName(), errorMsg);\r\n+                                        lock.release();\r\n+                                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\r\n+                                                errorMsg);\r\n+                                    });\r\n+                        }, failureInfo -> {\r\n+                            String errorMsg = failureInfo.getCause().getMessage();\r\n+                            logger.warn(\"{} encountered error writing to device: {}\",\r\n+                                    HeliosEasyControlsHandler.class.getSimpleName(), errorMsg);\r\n+                            lock.release();\r\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorMsg);\r\n+\r\n+                        });\r\n+            }\r\n+        } else {\r\n+            if (this.comms == null) {\r\n+                this.handleError(\"Modbus communication interface is unavailable.\",\r\n+                        ThingStatusDetail.COMMUNICATION_ERROR);\r\n+            }\r\n+            if (this.vMap == null) {\r\n+                this.handleError(\"Variable definition is unavailable.\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    // TODO: set time incl. timezone, update time channels based on timezone read from device\r\n+\r\n+    /**\r\n+     * Formats the provided date to a string in the device's configured date format\r\n+     *\r\n+     * @param variableName the variable name\r\n+     * @param date the date to be formatted\r\n+     * @return a string in the device's configured date format\r\n+     */\r\n+    private String formatDate(String variableName, ZonedDateTime date) {\r\n+        String y = Integer.toString(date.getYear());\r\n+        String m = Integer.toString(date.getMonthValue());\r\n+        if (m.length() == 1) {\r\n+            m = \"0\" + m;\r\n+        }\r\n+        String d = Integer.toString(date.getDayOfMonth());\r\n+        if (d.length() == 1) {\r\n+            d = \"0\" + d;\r\n+        }\r\n+        if (variableName.equals(HeliosEasyControlsBindingConstants.DATE)) { // fixed format for writing the system date\r\n+            return d + \".\" + m + \".\" + y;\r\n+        } else {\r\n+            switch (this.dateFormat) {\r\n+                case 0: // dd.mm.yyyy\r\n+                    return d + \".\" + m + \".\" + y;\r\n+                case 1: // mm.dd.yyyy\r\n+                    return m + \".\" + d + \".\" + y;\r\n+                case 2: // yyyy.mm.dd\r\n+                    return y + \".\" + m + \".\" + d;\r\n+                default:\r\n+                    return d + \".\" + m + \".\" + y;\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns a DateTimeType object based on the provided String and the device's configured date format\r\n+     *\r\n+     * @param date The date string read from the device\r\n+     * @return A DateTimeType object representing the date or time specified\r\n+     */\r\n+    private DateTimeType toDateTime(String date) {\r", "originalCommit": "a29484f182958feae2d73f3ac06490316afc5798", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5NTYxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r484095611", "bodyText": "The date format can be configured to 3 different formats. I use this method to create a DateTimeType I can actually work with. As mentioned above, I do intend to make the handling of system date and time a bit more convenient...", "author": "bern77", "createdAt": "2020-09-06T17:35:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxNTc3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxNTgyMw==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r479815823", "bodyText": "You could throw an exception here, instead of returning a dummy value.", "author": "fwolter", "createdAt": "2020-08-30T21:08:26Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,684 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.nio.charset.StandardCharsets;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.QuantityType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\r\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.eclipse.smarthome.core.types.State;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+@NonNullByDefault\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    /**\r\n+     * Logger instance\r\n+     */\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    /**\r\n+     * Configuration instance\r\n+     */\r\n+    private @Nullable HeliosEasyControlsConfiguration config;\r\n+\r\n+    /**\r\n+     * Used to poll the variables' status based on the configured refresh interval\r\n+     */\r\n+    private @Nullable ScheduledFuture<?> pollingJob;\r\n+\r\n+    /**\r\n+     * The map holding the variable meta info by variable name\r\n+     */\r\n+    private @Nullable Map<String, HeliosVariable> vMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private static ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore>();\r\n+\r\n+    /**\r\n+     * Communication interface to the endpoint\r\n+     */\r\n+    private @Nullable ModbusCommunicationInterface comms;\r\n+\r\n+    /**\r\n+     * The date format used by the device\r\n+     */\r\n+    private int dateFormat = -1;\r\n+\r\n+    /**\r\n+     * The UTC offset of the device\r\n+     */\r\n+    private int utcOffset = 0;\r\n+\r\n+    /**\r\n+     * Constructor\r\n+     *\r\n+     * @param thing\r\n+     * @param managerRef\r\n+     */\r\n+    public HeliosEasyControlsHandler(Thing thing) {\r\n+        super(thing);\r\n+    }\r\n+\r\n+    /**\r\n+     * Reads variable definitions from JSON file and store them in vMap\r\n+     */\r\n+    private void readVariableDefinition() {\r\n+        Gson gson = new Gson();\r\n+        Type vMapType = new TypeToken<Map<String, HeliosVariable>>() {\r\n+        }.getType();\r\n+        this.vMap = gson.fromJson(\r\n+                new BufferedReader(new InputStreamReader(\r\n+                        getClass().getResourceAsStream(HeliosEasyControlsBindingConstants.VARIABLES_DEFINITION_FILE))),\r\n+                vMapType);\r\n+        if (vMap != null) {\r\n+            // add the name to the variable itself\r\n+            for (Map.Entry<String, HeliosVariable> entry : this.vMap.entrySet()) {\r\n+                entry.getValue().setName(entry.getKey()); // workaround to set the variable name inside the\r\n+                                                          // HeliosVariable object\r\n+                if (!entry.getValue().isOk()) {\r\n+                    this.handleError(\"Variables definition file contains inconsistent data.\",\r\n+                            ThingStatusDetail.CONFIGURATION_ERROR);\r\n+                }\r\n+            }\r\n+        } else {\r\n+            this.handleError(\"Variables definition file not found or of illegal format.\",\r\n+                    ThingStatusDetail.CONFIGURATION_ERROR);\r\n+        }\r\n+\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the endpoint handler from the bridge this handler is connected to\r\n+     * Checks that we're connected to the right type of bridge\r\n+     *\r\n+     * @return the endpoint handler or null if the bridge does not exist\r\n+     */\r\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\r\n+        Bridge bridge = getBridge();\r\n+        if (bridge == null) {\r\n+            logger.debug(\"Bridge is null\");\r\n+            return null;\r\n+        }\r\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\r\n+            logger.debug(\"Bridge is not online\");\r\n+            return null;\r\n+        }\r\n+\r\n+        ThingHandler handler = bridge.getHandler();\r\n+        if (handler == null) {\r\n+            logger.debug(\"Bridge handler is null\");\r\n+            return null;\r\n+        }\r\n+\r\n+        if (handler instanceof ModbusEndpointThingHandler) {\r\n+            return (ModbusEndpointThingHandler) handler;\r\n+        } else {\r\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\r\n+            return null;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get a reference to the modbus endpoint\r\n+     */\r\n+    private void connectEndpoint() {\r\n+        if (this.comms != null) {\r\n+            return;\r\n+        }\r\n+\r\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\r\n+        if (slaveEndpointThingHandler == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' is offline\", label));\r\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\r\n+            return;\r\n+        }\r\n+\r\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\r\n+\r\n+        if (comms == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\r\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\r\n+            return;\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void initialize() {\r\n+        this.config = getConfigAs(HeliosEasyControlsConfiguration.class);\r\n+        this.readVariableDefinition();\r\n+        this.connectEndpoint();\r\n+        if ((this.comms != null) && (this.vMap != null) && (this.config != null)) {\r\n+            HeliosEasyControlsHandler.transactionLocks.putIfAbsent(this.comms.getEndpoint(), new Semaphore(1, true));\r\n+            updateStatus(ThingStatus.UNKNOWN);\r\n+\r\n+            // background initialization\r\n+            scheduler.execute(() -> {\r\n+                readValue(HeliosEasyControlsBindingConstants.DATE_FORMAT);\r\n+                // status will be updated to ONLINE by the read callback function (via processResponse)\r\n+            });\r\n+\r\n+            // poll for status updates regularly\r\n+            Runnable runnable = new Runnable() {\r\n+\r\n+                @Override\r\n+                public void run() {\r\n+                    if (vMap != null) {\r\n+                        for (Map.Entry<String, HeliosVariable> entry : vMap.entrySet()) {\r\n+                            if (isLinked(entry.getKey())\r\n+                                    || (entry.getKey().equals(HeliosEasyControlsBindingConstants.DATE_FORMAT))\r\n+                                    || (entry.getKey()\r\n+                                            .equals(HeliosEasyControlsBindingConstants.TIME_ZONE_DIFFERENCE_TO_GMT))) {\r\n+                                readValue(entry.getKey());\r\n+                            }\r\n+                        }\r\n+\r\n+                    } else {\r\n+                        handleError(\"Variable definition is null\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+                    }\r\n+                }\r\n+            };\r\n+            this.pollingJob = scheduler.scheduleAtFixedRate(runnable, this.config.getRefreshInterval(),\r\n+                    this.config.getRefreshInterval(), TimeUnit.MILLISECONDS);\r\n+\r\n+        } else { // at least one null assertion has failed, let's log the problem and update the thing status\r\n+            if (this.comms == null) {\r\n+                this.handleError(\"Modbus communication interface is unavailable.\",\r\n+                        ThingStatusDetail.COMMUNICATION_ERROR);\r\n+            }\r\n+            if (this.vMap == null) {\r\n+                this.handleError(\"Variable definition is unavailable.\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            }\r\n+            if (this.config == null) {\r\n+                this.handleError(\"Binding configuration is unavailable.\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void dispose() {\r\n+        if (this.pollingJob != null) {\r\n+            this.pollingJob.cancel(true);\r\n+        }\r\n+        this.comms = null;\r\n+    }\r\n+\r\n+    @Override\r\n+    public void handleCommand(ChannelUID channelUID, Command command) {\r\n+        String channelId = channelUID.getIdWithoutGroup();\r\n+        if (command instanceof RefreshType) {\r\n+            scheduler.submit(new Runnable() {\r\n+                @Override\r\n+                public void run() {\r\n+                    readValue(channelId);\r\n+                }\r\n+            });\r\n+        } else { // write command\r\n+            String value = null;\r\n+            if (command instanceof OnOffType) {\r\n+                value = command == OnOffType.ON ? \"1\" : \"0\";\r\n+            } else if (command instanceof DateTimeType) {\r\n+                value = formatDate(channelId, ((DateTimeType) command).getZonedDateTime());\r\n+            } else if ((command instanceof DecimalType) || (command instanceof StringType)) {\r\n+                value = command.toString();\r\n+            } else if (command instanceof QuantityType<?>) {\r\n+                // convert item's unit to the Helios device's unit\r\n+                String unit = this.vMap.get(channelId).getUnit();\r\n+                QuantityType<?> val = (QuantityType<?>) command;\r\n+                if (unit != null) {\r\n+                    if (unit.equals(HeliosVariable.UNIT_DAY)) {\r\n+                        val = val.toUnit(SmartHomeUnits.DAY);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_HOUR)) {\r\n+                        val = val.toUnit(SmartHomeUnits.HOUR);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_MIN)) {\r\n+                        val = val.toUnit(SmartHomeUnits.MINUTE);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_SEC)) {\r\n+                        val = val.toUnit(SmartHomeUnits.SECOND);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_VOLT)) {\r\n+                        val = val.toUnit(SmartHomeUnits.VOLT);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_PERCENT)) {\r\n+                        val = val.toUnit(SmartHomeUnits.PERCENT);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_PPM)) {\r\n+                        val = val.toUnit(SmartHomeUnits.PARTS_PER_MILLION);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_TEMP)) {\r\n+                        val = val.toUnit(SIUnits.CELSIUS);\r\n+                    }\r\n+                    value = val != null ? String.valueOf(val.doubleValue()) : null; // ignore the UoM\r\n+                }\r\n+            }\r\n+            if (value != null) {\r\n+                final String v = value;\r\n+                scheduler.submit(new Runnable() {\r\n+                    @Override\r\n+                    public void run() {\r\n+                        try {\r\n+                            writeValue(channelId, v);\r\n+                            updateStatus(ThingStatus.ONLINE);\r\n+                        } catch (HeliosException e) {\r\n+                            logger.warn(\"Writing value {} to channel {} failed: {}\", v, channelId, e.getMessage());\r\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\r\n+                                    \"Writing to device failed.\");\r\n+                        }\r\n+                    }\r\n+                });\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Writes a variable value to the Helios device\r\n+     *\r\n+     * @param variableName The variable name\r\n+     * @param value The new value\r\n+     * @return The value if the transaction succeeded, <tt>null</tt> otherwise\r\n+     * @throws HeliosException Thrown if the variable is read-only or the provided value is out of range\r\n+     */\r\n+    public void writeValue(String variableName, String value) throws HeliosException {\r\n+        if (this.vMap == null) {\r\n+            this.handleError(\"Variable definition is unavailable.\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            return;\r\n+        } else {\r\n+            HeliosVariable v = this.vMap.get(variableName);\r\n+            if (!v.hasWriteAccess()) {\r\n+                throw new HeliosException(\"Variable \" + variableName + \" is read-only\");\r\n+            } else if (!v.isInAllowedRange(value)) {\r\n+                throw new HeliosException(\r\n+                        \"Value \" + value + \" is outside of allowed range of variable \" + variableName);\r\n+            } else if (this.comms != null) {\r\n+                // write to device\r\n+                String payload = v.getVariableString() + \"=\" + value;\r\n+                final Semaphore lock = transactionLocks.get(this.comms.getEndpoint());\r\n+                try {\r\n+                    lock.acquire();\r\n+                    this.comms.submitOneTimeWrite(\r\n+                            new ModbusWriteRegisterRequestBlueprint(HeliosEasyControlsBindingConstants.UNIT_ID,\r\n+                                    HeliosEasyControlsBindingConstants.START_ADDRESS,\r\n+                                    new ModbusRegisterArray(preparePayload(payload)), true,\r\n+                                    HeliosEasyControlsBindingConstants.MAX_TRIES),\r\n+                            result -> {\r\n+                                lock.release();\r\n+                                updateStatus(ThingStatus.ONLINE);\r\n+                            }, failureInfo -> {\r\n+                                String errorMsg = failureInfo.getCause().getMessage();\r\n+                                logger.warn(\"{} encountered error writing to device: {}\",\r\n+                                        HeliosEasyControlsHandler.class.getSimpleName(), errorMsg);\r\n+                                lock.release();\r\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorMsg);\r\n+                            });\r\n+                    // ensure the openHAB item is updated with the device's actual value\r\n+                    scheduler.schedule(new Runnable() {\r\n+                        @Override\r\n+                        public void run() {\r\n+                            readValue(variableName);\r\n+                        }\r\n+                    }, 1, TimeUnit.SECONDS);\r\n+                } catch (InterruptedException e) {\r\n+                    logger.warn(\r\n+                            \"{} encountered Exception when trying to lock Semaphore for writing variable {} to the device: {}\",\r\n+                            HeliosEasyControlsHandler.class.getSimpleName(), variableName, e.getMessage());\r\n+                }\r\n+            } else { // comms is null\r\n+                this.handleError(\"Modbus communication interface is null.\", ThingStatusDetail.COMMUNICATION_ERROR);\r\n+            }\r\n+        }\r\n+\r\n+    }\r\n+\r\n+    /**\r\n+     * Read a variable from the Helios device\r\n+     *\r\n+     * @param variableName The variable name\r\n+     * @return The value\r\n+     */\r\n+    public void readValue(String variableName) {\r\n+        if ((this.comms != null) && (this.vMap != null)) {\r\n+            final Semaphore lock = transactionLocks.get(this.comms.getEndpoint());\r\n+            HeliosVariable v = this.vMap.get(variableName);\r\n+            if (v.hasReadAccess()) {\r\n+                try {\r\n+                    lock.acquire(); // will block until lock is available\r\n+                } catch (InterruptedException e) {\r\n+                    logger.warn(\"{} encountered Exception when trying to read variable {} from the device: {}\",\r\n+                            HeliosEasyControlsHandler.class.getSimpleName(), variableName, e.getMessage());\r\n+                    return;\r\n+                }\r\n+                // write variable name to register\r\n+                String payload = v.getVariableString();\r\n+                this.comms.submitOneTimeWrite(new ModbusWriteRegisterRequestBlueprint(\r\n+                        HeliosEasyControlsBindingConstants.UNIT_ID, HeliosEasyControlsBindingConstants.START_ADDRESS,\r\n+                        new ModbusRegisterArray(preparePayload(payload)), true,\r\n+                        HeliosEasyControlsBindingConstants.MAX_TRIES), result -> {\r\n+                            this.comms.submitOneTimePoll(\r\n+                                    new ModbusReadRequestBlueprint(HeliosEasyControlsBindingConstants.UNIT_ID,\r\n+                                            ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS,\r\n+                                            HeliosEasyControlsBindingConstants.START_ADDRESS, v.getCount(),\r\n+                                            HeliosEasyControlsBindingConstants.MAX_TRIES),\r\n+                                    pollResult -> {\r\n+                                        lock.release();\r\n+                                        Optional<ModbusRegisterArray> registers = pollResult.getRegisters();\r\n+                                        if (registers.isPresent()) {\r\n+                                            processResponse(v, registers.get());\r\n+                                        }\r\n+                                    }, failureInfo -> {\r\n+                                        String errorMsg = failureInfo.getCause().getMessage();\r\n+                                        logger.warn(\"{} encountered error reading from device: {}\",\r\n+                                                HeliosEasyControlsHandler.class.getSimpleName(), errorMsg);\r\n+                                        lock.release();\r\n+                                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\r\n+                                                errorMsg);\r\n+                                    });\r\n+                        }, failureInfo -> {\r\n+                            String errorMsg = failureInfo.getCause().getMessage();\r\n+                            logger.warn(\"{} encountered error writing to device: {}\",\r\n+                                    HeliosEasyControlsHandler.class.getSimpleName(), errorMsg);\r\n+                            lock.release();\r\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorMsg);\r\n+\r\n+                        });\r\n+            }\r\n+        } else {\r\n+            if (this.comms == null) {\r\n+                this.handleError(\"Modbus communication interface is unavailable.\",\r\n+                        ThingStatusDetail.COMMUNICATION_ERROR);\r\n+            }\r\n+            if (this.vMap == null) {\r\n+                this.handleError(\"Variable definition is unavailable.\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    // TODO: set time incl. timezone, update time channels based on timezone read from device\r\n+\r\n+    /**\r\n+     * Formats the provided date to a string in the device's configured date format\r\n+     *\r\n+     * @param variableName the variable name\r\n+     * @param date the date to be formatted\r\n+     * @return a string in the device's configured date format\r\n+     */\r\n+    private String formatDate(String variableName, ZonedDateTime date) {\r\n+        String y = Integer.toString(date.getYear());\r\n+        String m = Integer.toString(date.getMonthValue());\r\n+        if (m.length() == 1) {\r\n+            m = \"0\" + m;\r\n+        }\r\n+        String d = Integer.toString(date.getDayOfMonth());\r\n+        if (d.length() == 1) {\r\n+            d = \"0\" + d;\r\n+        }\r\n+        if (variableName.equals(HeliosEasyControlsBindingConstants.DATE)) { // fixed format for writing the system date\r\n+            return d + \".\" + m + \".\" + y;\r\n+        } else {\r\n+            switch (this.dateFormat) {\r\n+                case 0: // dd.mm.yyyy\r\n+                    return d + \".\" + m + \".\" + y;\r\n+                case 1: // mm.dd.yyyy\r\n+                    return m + \".\" + d + \".\" + y;\r\n+                case 2: // yyyy.mm.dd\r\n+                    return y + \".\" + m + \".\" + d;\r\n+                default:\r\n+                    return d + \".\" + m + \".\" + y;\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns a DateTimeType object based on the provided String and the device's configured date format\r\n+     *\r\n+     * @param date The date string read from the device\r\n+     * @return A DateTimeType object representing the date or time specified\r\n+     */\r\n+    private DateTimeType toDateTime(String date) {\r\n+        String[] dateTimeParts = null;\r\n+        String dateTime = date;\r\n+        try { // date\r\n+            dateTimeParts = date.split(\"\\\\.\"); // try to split date components\r\n+            if (dateTimeParts.length == 1) { // time\r\n+                return DateTimeType.valueOf(date);\r\n+            } else { // date - we'll try the device's date format\r\n+                switch (this.dateFormat) {\r\n+                    case 0: // dd.mm.yyyy\r\n+                        dateTime = dateTimeParts[2] + \"-\" + dateTimeParts[1] + \"-\" + dateTimeParts[0];\r\n+                        break;\r\n+                    case 1: // mm.dd.yyyy\r\n+                        dateTime = dateTimeParts[2] + \"-\" + dateTimeParts[0] + \"-\" + dateTimeParts[1];\r\n+                        break;\r\n+                    case 2: // yyyy.mm.dd\r\n+                        dateTime = dateTimeParts[0] + \"-\" + dateTimeParts[1] + \"-\" + dateTimeParts[2];\r\n+                        break;\r\n+                    default:\r\n+                        dateTime = dateTimeParts[2] + \"-\" + dateTimeParts[1] + \"-\" + dateTimeParts[0];\r\n+                        break;\r\n+                }\r\n+                return DateTimeType.valueOf(dateTime);\r\n+            }\r\n+        } catch (Exception e) {\r\n+            // falling back to default date format (apparently using the configured format has failed)\r\n+            if (dateTimeParts != null) {\r\n+                dateTime = dateTimeParts[2] + \"-\" + dateTimeParts[1] + \"-\" + dateTimeParts[0];\r\n+                return DateTimeType.valueOf(dateTime);\r\n+            } else {\r\n+                logger.warn(\"{} couldn't parse the provided date string: {}\",\r\n+                        HeliosEasyControlsHandler.class.getSimpleName(), date);\r\n+                return new DateTimeType(); // return at least a valid DateTimeType object\r", "originalCommit": "a29484f182958feae2d73f3ac06490316afc5798", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxNTg5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r479815895", "bodyText": "Can this be removed?", "author": "fwolter", "createdAt": "2020-08-30T21:09:09Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,684 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.nio.charset.StandardCharsets;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.QuantityType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\r\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.eclipse.smarthome.core.types.State;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+@NonNullByDefault\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    /**\r\n+     * Logger instance\r\n+     */\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    /**\r\n+     * Configuration instance\r\n+     */\r\n+    private @Nullable HeliosEasyControlsConfiguration config;\r\n+\r\n+    /**\r\n+     * Used to poll the variables' status based on the configured refresh interval\r\n+     */\r\n+    private @Nullable ScheduledFuture<?> pollingJob;\r\n+\r\n+    /**\r\n+     * The map holding the variable meta info by variable name\r\n+     */\r\n+    private @Nullable Map<String, HeliosVariable> vMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private static ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore>();\r\n+\r\n+    /**\r\n+     * Communication interface to the endpoint\r\n+     */\r\n+    private @Nullable ModbusCommunicationInterface comms;\r\n+\r\n+    /**\r\n+     * The date format used by the device\r\n+     */\r\n+    private int dateFormat = -1;\r\n+\r\n+    /**\r\n+     * The UTC offset of the device\r\n+     */\r\n+    private int utcOffset = 0;\r\n+\r\n+    /**\r\n+     * Constructor\r\n+     *\r\n+     * @param thing\r\n+     * @param managerRef\r\n+     */\r\n+    public HeliosEasyControlsHandler(Thing thing) {\r\n+        super(thing);\r\n+    }\r\n+\r\n+    /**\r\n+     * Reads variable definitions from JSON file and store them in vMap\r\n+     */\r\n+    private void readVariableDefinition() {\r\n+        Gson gson = new Gson();\r\n+        Type vMapType = new TypeToken<Map<String, HeliosVariable>>() {\r\n+        }.getType();\r\n+        this.vMap = gson.fromJson(\r\n+                new BufferedReader(new InputStreamReader(\r\n+                        getClass().getResourceAsStream(HeliosEasyControlsBindingConstants.VARIABLES_DEFINITION_FILE))),\r\n+                vMapType);\r\n+        if (vMap != null) {\r\n+            // add the name to the variable itself\r\n+            for (Map.Entry<String, HeliosVariable> entry : this.vMap.entrySet()) {\r\n+                entry.getValue().setName(entry.getKey()); // workaround to set the variable name inside the\r\n+                                                          // HeliosVariable object\r\n+                if (!entry.getValue().isOk()) {\r\n+                    this.handleError(\"Variables definition file contains inconsistent data.\",\r\n+                            ThingStatusDetail.CONFIGURATION_ERROR);\r\n+                }\r\n+            }\r\n+        } else {\r\n+            this.handleError(\"Variables definition file not found or of illegal format.\",\r\n+                    ThingStatusDetail.CONFIGURATION_ERROR);\r\n+        }\r\n+\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the endpoint handler from the bridge this handler is connected to\r\n+     * Checks that we're connected to the right type of bridge\r\n+     *\r\n+     * @return the endpoint handler or null if the bridge does not exist\r\n+     */\r\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\r\n+        Bridge bridge = getBridge();\r\n+        if (bridge == null) {\r\n+            logger.debug(\"Bridge is null\");\r\n+            return null;\r\n+        }\r\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\r\n+            logger.debug(\"Bridge is not online\");\r\n+            return null;\r\n+        }\r\n+\r\n+        ThingHandler handler = bridge.getHandler();\r\n+        if (handler == null) {\r\n+            logger.debug(\"Bridge handler is null\");\r\n+            return null;\r\n+        }\r\n+\r\n+        if (handler instanceof ModbusEndpointThingHandler) {\r\n+            return (ModbusEndpointThingHandler) handler;\r\n+        } else {\r\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\r\n+            return null;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get a reference to the modbus endpoint\r\n+     */\r\n+    private void connectEndpoint() {\r\n+        if (this.comms != null) {\r\n+            return;\r\n+        }\r\n+\r\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\r\n+        if (slaveEndpointThingHandler == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' is offline\", label));\r\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\r\n+            return;\r\n+        }\r\n+\r\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\r\n+\r\n+        if (comms == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\r\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\r\n+            return;\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void initialize() {\r\n+        this.config = getConfigAs(HeliosEasyControlsConfiguration.class);\r\n+        this.readVariableDefinition();\r\n+        this.connectEndpoint();\r\n+        if ((this.comms != null) && (this.vMap != null) && (this.config != null)) {\r\n+            HeliosEasyControlsHandler.transactionLocks.putIfAbsent(this.comms.getEndpoint(), new Semaphore(1, true));\r\n+            updateStatus(ThingStatus.UNKNOWN);\r\n+\r\n+            // background initialization\r\n+            scheduler.execute(() -> {\r\n+                readValue(HeliosEasyControlsBindingConstants.DATE_FORMAT);\r\n+                // status will be updated to ONLINE by the read callback function (via processResponse)\r\n+            });\r\n+\r\n+            // poll for status updates regularly\r\n+            Runnable runnable = new Runnable() {\r\n+\r\n+                @Override\r\n+                public void run() {\r\n+                    if (vMap != null) {\r\n+                        for (Map.Entry<String, HeliosVariable> entry : vMap.entrySet()) {\r\n+                            if (isLinked(entry.getKey())\r\n+                                    || (entry.getKey().equals(HeliosEasyControlsBindingConstants.DATE_FORMAT))\r\n+                                    || (entry.getKey()\r\n+                                            .equals(HeliosEasyControlsBindingConstants.TIME_ZONE_DIFFERENCE_TO_GMT))) {\r\n+                                readValue(entry.getKey());\r\n+                            }\r\n+                        }\r\n+\r\n+                    } else {\r\n+                        handleError(\"Variable definition is null\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+                    }\r\n+                }\r\n+            };\r\n+            this.pollingJob = scheduler.scheduleAtFixedRate(runnable, this.config.getRefreshInterval(),\r\n+                    this.config.getRefreshInterval(), TimeUnit.MILLISECONDS);\r\n+\r\n+        } else { // at least one null assertion has failed, let's log the problem and update the thing status\r\n+            if (this.comms == null) {\r\n+                this.handleError(\"Modbus communication interface is unavailable.\",\r\n+                        ThingStatusDetail.COMMUNICATION_ERROR);\r\n+            }\r\n+            if (this.vMap == null) {\r\n+                this.handleError(\"Variable definition is unavailable.\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            }\r\n+            if (this.config == null) {\r\n+                this.handleError(\"Binding configuration is unavailable.\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void dispose() {\r\n+        if (this.pollingJob != null) {\r\n+            this.pollingJob.cancel(true);\r\n+        }\r\n+        this.comms = null;\r\n+    }\r\n+\r\n+    @Override\r\n+    public void handleCommand(ChannelUID channelUID, Command command) {\r\n+        String channelId = channelUID.getIdWithoutGroup();\r\n+        if (command instanceof RefreshType) {\r\n+            scheduler.submit(new Runnable() {\r\n+                @Override\r\n+                public void run() {\r\n+                    readValue(channelId);\r\n+                }\r\n+            });\r\n+        } else { // write command\r\n+            String value = null;\r\n+            if (command instanceof OnOffType) {\r\n+                value = command == OnOffType.ON ? \"1\" : \"0\";\r\n+            } else if (command instanceof DateTimeType) {\r\n+                value = formatDate(channelId, ((DateTimeType) command).getZonedDateTime());\r\n+            } else if ((command instanceof DecimalType) || (command instanceof StringType)) {\r\n+                value = command.toString();\r\n+            } else if (command instanceof QuantityType<?>) {\r\n+                // convert item's unit to the Helios device's unit\r\n+                String unit = this.vMap.get(channelId).getUnit();\r\n+                QuantityType<?> val = (QuantityType<?>) command;\r\n+                if (unit != null) {\r\n+                    if (unit.equals(HeliosVariable.UNIT_DAY)) {\r\n+                        val = val.toUnit(SmartHomeUnits.DAY);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_HOUR)) {\r\n+                        val = val.toUnit(SmartHomeUnits.HOUR);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_MIN)) {\r\n+                        val = val.toUnit(SmartHomeUnits.MINUTE);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_SEC)) {\r\n+                        val = val.toUnit(SmartHomeUnits.SECOND);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_VOLT)) {\r\n+                        val = val.toUnit(SmartHomeUnits.VOLT);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_PERCENT)) {\r\n+                        val = val.toUnit(SmartHomeUnits.PERCENT);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_PPM)) {\r\n+                        val = val.toUnit(SmartHomeUnits.PARTS_PER_MILLION);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_TEMP)) {\r\n+                        val = val.toUnit(SIUnits.CELSIUS);\r\n+                    }\r\n+                    value = val != null ? String.valueOf(val.doubleValue()) : null; // ignore the UoM\r\n+                }\r\n+            }\r\n+            if (value != null) {\r\n+                final String v = value;\r\n+                scheduler.submit(new Runnable() {\r\n+                    @Override\r\n+                    public void run() {\r\n+                        try {\r\n+                            writeValue(channelId, v);\r\n+                            updateStatus(ThingStatus.ONLINE);\r\n+                        } catch (HeliosException e) {\r\n+                            logger.warn(\"Writing value {} to channel {} failed: {}\", v, channelId, e.getMessage());\r\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\r\n+                                    \"Writing to device failed.\");\r\n+                        }\r\n+                    }\r\n+                });\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Writes a variable value to the Helios device\r\n+     *\r\n+     * @param variableName The variable name\r\n+     * @param value The new value\r\n+     * @return The value if the transaction succeeded, <tt>null</tt> otherwise\r\n+     * @throws HeliosException Thrown if the variable is read-only or the provided value is out of range\r\n+     */\r\n+    public void writeValue(String variableName, String value) throws HeliosException {\r\n+        if (this.vMap == null) {\r\n+            this.handleError(\"Variable definition is unavailable.\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            return;\r\n+        } else {\r\n+            HeliosVariable v = this.vMap.get(variableName);\r\n+            if (!v.hasWriteAccess()) {\r\n+                throw new HeliosException(\"Variable \" + variableName + \" is read-only\");\r\n+            } else if (!v.isInAllowedRange(value)) {\r\n+                throw new HeliosException(\r\n+                        \"Value \" + value + \" is outside of allowed range of variable \" + variableName);\r\n+            } else if (this.comms != null) {\r\n+                // write to device\r\n+                String payload = v.getVariableString() + \"=\" + value;\r\n+                final Semaphore lock = transactionLocks.get(this.comms.getEndpoint());\r\n+                try {\r\n+                    lock.acquire();\r\n+                    this.comms.submitOneTimeWrite(\r\n+                            new ModbusWriteRegisterRequestBlueprint(HeliosEasyControlsBindingConstants.UNIT_ID,\r\n+                                    HeliosEasyControlsBindingConstants.START_ADDRESS,\r\n+                                    new ModbusRegisterArray(preparePayload(payload)), true,\r\n+                                    HeliosEasyControlsBindingConstants.MAX_TRIES),\r\n+                            result -> {\r\n+                                lock.release();\r\n+                                updateStatus(ThingStatus.ONLINE);\r\n+                            }, failureInfo -> {\r\n+                                String errorMsg = failureInfo.getCause().getMessage();\r\n+                                logger.warn(\"{} encountered error writing to device: {}\",\r\n+                                        HeliosEasyControlsHandler.class.getSimpleName(), errorMsg);\r\n+                                lock.release();\r\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorMsg);\r\n+                            });\r\n+                    // ensure the openHAB item is updated with the device's actual value\r\n+                    scheduler.schedule(new Runnable() {\r\n+                        @Override\r\n+                        public void run() {\r\n+                            readValue(variableName);\r\n+                        }\r\n+                    }, 1, TimeUnit.SECONDS);\r\n+                } catch (InterruptedException e) {\r\n+                    logger.warn(\r\n+                            \"{} encountered Exception when trying to lock Semaphore for writing variable {} to the device: {}\",\r\n+                            HeliosEasyControlsHandler.class.getSimpleName(), variableName, e.getMessage());\r\n+                }\r\n+            } else { // comms is null\r\n+                this.handleError(\"Modbus communication interface is null.\", ThingStatusDetail.COMMUNICATION_ERROR);\r\n+            }\r\n+        }\r\n+\r\n+    }\r\n+\r\n+    /**\r\n+     * Read a variable from the Helios device\r\n+     *\r\n+     * @param variableName The variable name\r\n+     * @return The value\r\n+     */\r\n+    public void readValue(String variableName) {\r\n+        if ((this.comms != null) && (this.vMap != null)) {\r\n+            final Semaphore lock = transactionLocks.get(this.comms.getEndpoint());\r\n+            HeliosVariable v = this.vMap.get(variableName);\r\n+            if (v.hasReadAccess()) {\r\n+                try {\r\n+                    lock.acquire(); // will block until lock is available\r\n+                } catch (InterruptedException e) {\r\n+                    logger.warn(\"{} encountered Exception when trying to read variable {} from the device: {}\",\r\n+                            HeliosEasyControlsHandler.class.getSimpleName(), variableName, e.getMessage());\r\n+                    return;\r\n+                }\r\n+                // write variable name to register\r\n+                String payload = v.getVariableString();\r\n+                this.comms.submitOneTimeWrite(new ModbusWriteRegisterRequestBlueprint(\r\n+                        HeliosEasyControlsBindingConstants.UNIT_ID, HeliosEasyControlsBindingConstants.START_ADDRESS,\r\n+                        new ModbusRegisterArray(preparePayload(payload)), true,\r\n+                        HeliosEasyControlsBindingConstants.MAX_TRIES), result -> {\r\n+                            this.comms.submitOneTimePoll(\r\n+                                    new ModbusReadRequestBlueprint(HeliosEasyControlsBindingConstants.UNIT_ID,\r\n+                                            ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS,\r\n+                                            HeliosEasyControlsBindingConstants.START_ADDRESS, v.getCount(),\r\n+                                            HeliosEasyControlsBindingConstants.MAX_TRIES),\r\n+                                    pollResult -> {\r\n+                                        lock.release();\r\n+                                        Optional<ModbusRegisterArray> registers = pollResult.getRegisters();\r\n+                                        if (registers.isPresent()) {\r\n+                                            processResponse(v, registers.get());\r\n+                                        }\r\n+                                    }, failureInfo -> {\r\n+                                        String errorMsg = failureInfo.getCause().getMessage();\r\n+                                        logger.warn(\"{} encountered error reading from device: {}\",\r\n+                                                HeliosEasyControlsHandler.class.getSimpleName(), errorMsg);\r\n+                                        lock.release();\r\n+                                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\r\n+                                                errorMsg);\r\n+                                    });\r\n+                        }, failureInfo -> {\r\n+                            String errorMsg = failureInfo.getCause().getMessage();\r\n+                            logger.warn(\"{} encountered error writing to device: {}\",\r\n+                                    HeliosEasyControlsHandler.class.getSimpleName(), errorMsg);\r\n+                            lock.release();\r\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorMsg);\r\n+\r\n+                        });\r\n+            }\r\n+        } else {\r\n+            if (this.comms == null) {\r\n+                this.handleError(\"Modbus communication interface is unavailable.\",\r\n+                        ThingStatusDetail.COMMUNICATION_ERROR);\r\n+            }\r\n+            if (this.vMap == null) {\r\n+                this.handleError(\"Variable definition is unavailable.\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    // TODO: set time incl. timezone, update time channels based on timezone read from device\r\n+\r\n+    /**\r\n+     * Formats the provided date to a string in the device's configured date format\r\n+     *\r\n+     * @param variableName the variable name\r\n+     * @param date the date to be formatted\r\n+     * @return a string in the device's configured date format\r\n+     */\r\n+    private String formatDate(String variableName, ZonedDateTime date) {\r\n+        String y = Integer.toString(date.getYear());\r\n+        String m = Integer.toString(date.getMonthValue());\r\n+        if (m.length() == 1) {\r\n+            m = \"0\" + m;\r\n+        }\r\n+        String d = Integer.toString(date.getDayOfMonth());\r\n+        if (d.length() == 1) {\r\n+            d = \"0\" + d;\r\n+        }\r\n+        if (variableName.equals(HeliosEasyControlsBindingConstants.DATE)) { // fixed format for writing the system date\r\n+            return d + \".\" + m + \".\" + y;\r\n+        } else {\r\n+            switch (this.dateFormat) {\r\n+                case 0: // dd.mm.yyyy\r\n+                    return d + \".\" + m + \".\" + y;\r\n+                case 1: // mm.dd.yyyy\r\n+                    return m + \".\" + d + \".\" + y;\r\n+                case 2: // yyyy.mm.dd\r\n+                    return y + \".\" + m + \".\" + d;\r\n+                default:\r\n+                    return d + \".\" + m + \".\" + y;\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns a DateTimeType object based on the provided String and the device's configured date format\r\n+     *\r\n+     * @param date The date string read from the device\r\n+     * @return A DateTimeType object representing the date or time specified\r\n+     */\r\n+    private DateTimeType toDateTime(String date) {\r\n+        String[] dateTimeParts = null;\r\n+        String dateTime = date;\r\n+        try { // date\r\n+            dateTimeParts = date.split(\"\\\\.\"); // try to split date components\r\n+            if (dateTimeParts.length == 1) { // time\r\n+                return DateTimeType.valueOf(date);\r\n+            } else { // date - we'll try the device's date format\r\n+                switch (this.dateFormat) {\r\n+                    case 0: // dd.mm.yyyy\r\n+                        dateTime = dateTimeParts[2] + \"-\" + dateTimeParts[1] + \"-\" + dateTimeParts[0];\r\n+                        break;\r\n+                    case 1: // mm.dd.yyyy\r\n+                        dateTime = dateTimeParts[2] + \"-\" + dateTimeParts[0] + \"-\" + dateTimeParts[1];\r\n+                        break;\r\n+                    case 2: // yyyy.mm.dd\r\n+                        dateTime = dateTimeParts[0] + \"-\" + dateTimeParts[1] + \"-\" + dateTimeParts[2];\r\n+                        break;\r\n+                    default:\r\n+                        dateTime = dateTimeParts[2] + \"-\" + dateTimeParts[1] + \"-\" + dateTimeParts[0];\r\n+                        break;\r\n+                }\r\n+                return DateTimeType.valueOf(dateTime);\r\n+            }\r\n+        } catch (Exception e) {\r\n+            // falling back to default date format (apparently using the configured format has failed)\r\n+            if (dateTimeParts != null) {\r\n+                dateTime = dateTimeParts[2] + \"-\" + dateTimeParts[1] + \"-\" + dateTimeParts[0];\r\n+                return DateTimeType.valueOf(dateTime);\r\n+            } else {\r\n+                logger.warn(\"{} couldn't parse the provided date string: {}\",\r\n+                        HeliosEasyControlsHandler.class.getSimpleName(), date);\r\n+                return new DateTimeType(); // return at least a valid DateTimeType object\r\n+            }\r\n+\r\n+        }\r\n+    }\r\n+\r\n+    private @Nullable QuantityType<?> toQuantityType(String value, @Nullable String unit) {\r\n+        if (unit == null) {\r\n+            return null;\r\n+        } else if (unit.equals(HeliosVariable.UNIT_DAY)) {\r\n+            return new QuantityType<>(Integer.parseInt(value), SmartHomeUnits.DAY);\r\n+        } else if (unit.equals(HeliosVariable.UNIT_HOUR)) {\r\n+            return new QuantityType<>(Integer.parseInt(value), SmartHomeUnits.HOUR);\r\n+        } else if (unit.equals(HeliosVariable.UNIT_MIN)) {\r\n+            return new QuantityType<>(Integer.parseInt(value), SmartHomeUnits.MINUTE);\r\n+        } else if (unit.equals(HeliosVariable.UNIT_SEC)) {\r\n+            return new QuantityType<>(Integer.parseInt(value), SmartHomeUnits.SECOND);\r\n+        } else if (unit.equals(HeliosVariable.UNIT_VOLT)) {\r\n+            return new QuantityType<>(Float.parseFloat(value), SmartHomeUnits.VOLT);\r\n+        } else if (unit.equals(HeliosVariable.UNIT_PERCENT)) {\r\n+            return new QuantityType<>(Float.parseFloat(value), SmartHomeUnits.PERCENT);\r\n+        } else if (unit.equals(HeliosVariable.UNIT_PPM)) {\r\n+            return new QuantityType<>(Float.parseFloat(value), SmartHomeUnits.PARTS_PER_MILLION);\r\n+        } else if (unit.equals(HeliosVariable.UNIT_TEMP)) {\r\n+            return new QuantityType<>(Float.parseFloat(value), SIUnits.CELSIUS);\r\n+        } else {\r\n+            return null;\r\n+        }\r\n+    }\r\n+\r\n+    // TODO: Set date, time and UTC delta together => also additional channel required\r", "originalCommit": "a29484f182958feae2d73f3ac06490316afc5798", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5NTcxOA==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r484095718", "bodyText": "See above... still some work to be done", "author": "bern77", "createdAt": "2020-09-06T17:36:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxNTg5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc3OTE2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r487779167", "bodyText": "If I see correctly, this is done now?", "author": "fwolter", "createdAt": "2020-09-14T09:35:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxNTg5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxNjI1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r479816255", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-08-30T21:12:54Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,684 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.nio.charset.StandardCharsets;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.QuantityType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\r\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.eclipse.smarthome.core.types.State;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+@NonNullByDefault\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    /**\r\n+     * Logger instance\r\n+     */\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    /**\r\n+     * Configuration instance\r\n+     */\r\n+    private @Nullable HeliosEasyControlsConfiguration config;\r\n+\r\n+    /**\r\n+     * Used to poll the variables' status based on the configured refresh interval\r\n+     */\r\n+    private @Nullable ScheduledFuture<?> pollingJob;\r\n+\r\n+    /**\r\n+     * The map holding the variable meta info by variable name\r\n+     */\r\n+    private @Nullable Map<String, HeliosVariable> vMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private static ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<ModbusSlaveEndpoint, Semaphore>();\r\n+\r\n+    /**\r\n+     * Communication interface to the endpoint\r\n+     */\r\n+    private @Nullable ModbusCommunicationInterface comms;\r\n+\r\n+    /**\r\n+     * The date format used by the device\r\n+     */\r\n+    private int dateFormat = -1;\r\n+\r\n+    /**\r\n+     * The UTC offset of the device\r\n+     */\r\n+    private int utcOffset = 0;\r\n+\r\n+    /**\r\n+     * Constructor\r\n+     *\r\n+     * @param thing\r\n+     * @param managerRef\r\n+     */\r\n+    public HeliosEasyControlsHandler(Thing thing) {\r\n+        super(thing);\r\n+    }\r\n+\r\n+    /**\r\n+     * Reads variable definitions from JSON file and store them in vMap\r\n+     */\r\n+    private void readVariableDefinition() {\r\n+        Gson gson = new Gson();\r\n+        Type vMapType = new TypeToken<Map<String, HeliosVariable>>() {\r\n+        }.getType();\r\n+        this.vMap = gson.fromJson(\r\n+                new BufferedReader(new InputStreamReader(\r\n+                        getClass().getResourceAsStream(HeliosEasyControlsBindingConstants.VARIABLES_DEFINITION_FILE))),\r\n+                vMapType);\r\n+        if (vMap != null) {\r\n+            // add the name to the variable itself\r\n+            for (Map.Entry<String, HeliosVariable> entry : this.vMap.entrySet()) {\r\n+                entry.getValue().setName(entry.getKey()); // workaround to set the variable name inside the\r\n+                                                          // HeliosVariable object\r\n+                if (!entry.getValue().isOk()) {\r\n+                    this.handleError(\"Variables definition file contains inconsistent data.\",\r\n+                            ThingStatusDetail.CONFIGURATION_ERROR);\r\n+                }\r\n+            }\r\n+        } else {\r\n+            this.handleError(\"Variables definition file not found or of illegal format.\",\r\n+                    ThingStatusDetail.CONFIGURATION_ERROR);\r\n+        }\r\n+\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the endpoint handler from the bridge this handler is connected to\r\n+     * Checks that we're connected to the right type of bridge\r\n+     *\r\n+     * @return the endpoint handler or null if the bridge does not exist\r\n+     */\r\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\r\n+        Bridge bridge = getBridge();\r\n+        if (bridge == null) {\r\n+            logger.debug(\"Bridge is null\");\r\n+            return null;\r\n+        }\r\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\r\n+            logger.debug(\"Bridge is not online\");\r\n+            return null;\r\n+        }\r\n+\r\n+        ThingHandler handler = bridge.getHandler();\r\n+        if (handler == null) {\r\n+            logger.debug(\"Bridge handler is null\");\r\n+            return null;\r\n+        }\r\n+\r\n+        if (handler instanceof ModbusEndpointThingHandler) {\r\n+            return (ModbusEndpointThingHandler) handler;\r\n+        } else {\r\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\r\n+            return null;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get a reference to the modbus endpoint\r\n+     */\r\n+    private void connectEndpoint() {\r\n+        if (this.comms != null) {\r\n+            return;\r\n+        }\r\n+\r\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\r\n+        if (slaveEndpointThingHandler == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' is offline\", label));\r\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\r\n+            return;\r\n+        }\r\n+\r\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\r\n+\r\n+        if (comms == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\r\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\r\n+            return;\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void initialize() {\r\n+        this.config = getConfigAs(HeliosEasyControlsConfiguration.class);\r\n+        this.readVariableDefinition();\r\n+        this.connectEndpoint();\r\n+        if ((this.comms != null) && (this.vMap != null) && (this.config != null)) {\r\n+            HeliosEasyControlsHandler.transactionLocks.putIfAbsent(this.comms.getEndpoint(), new Semaphore(1, true));\r\n+            updateStatus(ThingStatus.UNKNOWN);\r\n+\r\n+            // background initialization\r\n+            scheduler.execute(() -> {\r\n+                readValue(HeliosEasyControlsBindingConstants.DATE_FORMAT);\r\n+                // status will be updated to ONLINE by the read callback function (via processResponse)\r\n+            });\r\n+\r\n+            // poll for status updates regularly\r\n+            Runnable runnable = new Runnable() {\r\n+\r\n+                @Override\r\n+                public void run() {\r\n+                    if (vMap != null) {\r\n+                        for (Map.Entry<String, HeliosVariable> entry : vMap.entrySet()) {\r\n+                            if (isLinked(entry.getKey())\r\n+                                    || (entry.getKey().equals(HeliosEasyControlsBindingConstants.DATE_FORMAT))\r\n+                                    || (entry.getKey()\r\n+                                            .equals(HeliosEasyControlsBindingConstants.TIME_ZONE_DIFFERENCE_TO_GMT))) {\r\n+                                readValue(entry.getKey());\r\n+                            }\r\n+                        }\r\n+\r\n+                    } else {\r\n+                        handleError(\"Variable definition is null\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+                    }\r\n+                }\r\n+            };\r\n+            this.pollingJob = scheduler.scheduleAtFixedRate(runnable, this.config.getRefreshInterval(),\r\n+                    this.config.getRefreshInterval(), TimeUnit.MILLISECONDS);\r\n+\r\n+        } else { // at least one null assertion has failed, let's log the problem and update the thing status\r\n+            if (this.comms == null) {\r\n+                this.handleError(\"Modbus communication interface is unavailable.\",\r\n+                        ThingStatusDetail.COMMUNICATION_ERROR);\r\n+            }\r\n+            if (this.vMap == null) {\r\n+                this.handleError(\"Variable definition is unavailable.\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            }\r\n+            if (this.config == null) {\r\n+                this.handleError(\"Binding configuration is unavailable.\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void dispose() {\r\n+        if (this.pollingJob != null) {\r\n+            this.pollingJob.cancel(true);\r\n+        }\r\n+        this.comms = null;\r\n+    }\r\n+\r\n+    @Override\r\n+    public void handleCommand(ChannelUID channelUID, Command command) {\r\n+        String channelId = channelUID.getIdWithoutGroup();\r\n+        if (command instanceof RefreshType) {\r\n+            scheduler.submit(new Runnable() {\r\n+                @Override\r\n+                public void run() {\r\n+                    readValue(channelId);\r\n+                }\r\n+            });\r\n+        } else { // write command\r\n+            String value = null;\r\n+            if (command instanceof OnOffType) {\r\n+                value = command == OnOffType.ON ? \"1\" : \"0\";\r\n+            } else if (command instanceof DateTimeType) {\r\n+                value = formatDate(channelId, ((DateTimeType) command).getZonedDateTime());\r\n+            } else if ((command instanceof DecimalType) || (command instanceof StringType)) {\r\n+                value = command.toString();\r\n+            } else if (command instanceof QuantityType<?>) {\r\n+                // convert item's unit to the Helios device's unit\r\n+                String unit = this.vMap.get(channelId).getUnit();\r\n+                QuantityType<?> val = (QuantityType<?>) command;\r\n+                if (unit != null) {\r\n+                    if (unit.equals(HeliosVariable.UNIT_DAY)) {\r\n+                        val = val.toUnit(SmartHomeUnits.DAY);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_HOUR)) {\r\n+                        val = val.toUnit(SmartHomeUnits.HOUR);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_MIN)) {\r\n+                        val = val.toUnit(SmartHomeUnits.MINUTE);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_SEC)) {\r\n+                        val = val.toUnit(SmartHomeUnits.SECOND);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_VOLT)) {\r\n+                        val = val.toUnit(SmartHomeUnits.VOLT);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_PERCENT)) {\r\n+                        val = val.toUnit(SmartHomeUnits.PERCENT);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_PPM)) {\r\n+                        val = val.toUnit(SmartHomeUnits.PARTS_PER_MILLION);\r\n+                    } else if (unit.equals(HeliosVariable.UNIT_TEMP)) {\r\n+                        val = val.toUnit(SIUnits.CELSIUS);\r\n+                    }\r\n+                    value = val != null ? String.valueOf(val.doubleValue()) : null; // ignore the UoM\r\n+                }\r\n+            }\r\n+            if (value != null) {\r\n+                final String v = value;\r\n+                scheduler.submit(new Runnable() {\r\n+                    @Override\r\n+                    public void run() {\r\n+                        try {\r\n+                            writeValue(channelId, v);\r\n+                            updateStatus(ThingStatus.ONLINE);\r\n+                        } catch (HeliosException e) {\r\n+                            logger.warn(\"Writing value {} to channel {} failed: {}\", v, channelId, e.getMessage());\r\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\r\n+                                    \"Writing to device failed.\");\r\n+                        }\r\n+                    }\r\n+                });\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Writes a variable value to the Helios device\r\n+     *\r\n+     * @param variableName The variable name\r\n+     * @param value The new value\r\n+     * @return The value if the transaction succeeded, <tt>null</tt> otherwise\r\n+     * @throws HeliosException Thrown if the variable is read-only or the provided value is out of range\r\n+     */\r\n+    public void writeValue(String variableName, String value) throws HeliosException {\r\n+        if (this.vMap == null) {\r\n+            this.handleError(\"Variable definition is unavailable.\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            return;\r\n+        } else {\r\n+            HeliosVariable v = this.vMap.get(variableName);\r\n+            if (!v.hasWriteAccess()) {\r\n+                throw new HeliosException(\"Variable \" + variableName + \" is read-only\");\r\n+            } else if (!v.isInAllowedRange(value)) {\r\n+                throw new HeliosException(\r\n+                        \"Value \" + value + \" is outside of allowed range of variable \" + variableName);\r\n+            } else if (this.comms != null) {\r\n+                // write to device\r\n+                String payload = v.getVariableString() + \"=\" + value;\r\n+                final Semaphore lock = transactionLocks.get(this.comms.getEndpoint());\r\n+                try {\r\n+                    lock.acquire();\r\n+                    this.comms.submitOneTimeWrite(\r\n+                            new ModbusWriteRegisterRequestBlueprint(HeliosEasyControlsBindingConstants.UNIT_ID,\r\n+                                    HeliosEasyControlsBindingConstants.START_ADDRESS,\r\n+                                    new ModbusRegisterArray(preparePayload(payload)), true,\r\n+                                    HeliosEasyControlsBindingConstants.MAX_TRIES),\r\n+                            result -> {\r\n+                                lock.release();\r\n+                                updateStatus(ThingStatus.ONLINE);\r\n+                            }, failureInfo -> {\r\n+                                String errorMsg = failureInfo.getCause().getMessage();\r\n+                                logger.warn(\"{} encountered error writing to device: {}\",\r\n+                                        HeliosEasyControlsHandler.class.getSimpleName(), errorMsg);\r\n+                                lock.release();\r\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorMsg);\r\n+                            });\r\n+                    // ensure the openHAB item is updated with the device's actual value\r\n+                    scheduler.schedule(new Runnable() {\r\n+                        @Override\r\n+                        public void run() {\r\n+                            readValue(variableName);\r\n+                        }\r\n+                    }, 1, TimeUnit.SECONDS);\r\n+                } catch (InterruptedException e) {\r\n+                    logger.warn(\r\n+                            \"{} encountered Exception when trying to lock Semaphore for writing variable {} to the device: {}\",\r\n+                            HeliosEasyControlsHandler.class.getSimpleName(), variableName, e.getMessage());\r\n+                }\r\n+            } else { // comms is null\r\n+                this.handleError(\"Modbus communication interface is null.\", ThingStatusDetail.COMMUNICATION_ERROR);\r\n+            }\r\n+        }\r\n+\r\n+    }\r\n+\r\n+    /**\r\n+     * Read a variable from the Helios device\r\n+     *\r\n+     * @param variableName The variable name\r\n+     * @return The value\r\n+     */\r\n+    public void readValue(String variableName) {\r\n+        if ((this.comms != null) && (this.vMap != null)) {\r\n+            final Semaphore lock = transactionLocks.get(this.comms.getEndpoint());\r\n+            HeliosVariable v = this.vMap.get(variableName);\r\n+            if (v.hasReadAccess()) {\r\n+                try {\r\n+                    lock.acquire(); // will block until lock is available\r\n+                } catch (InterruptedException e) {\r\n+                    logger.warn(\"{} encountered Exception when trying to read variable {} from the device: {}\",\r\n+                            HeliosEasyControlsHandler.class.getSimpleName(), variableName, e.getMessage());\r\n+                    return;\r\n+                }\r\n+                // write variable name to register\r\n+                String payload = v.getVariableString();\r\n+                this.comms.submitOneTimeWrite(new ModbusWriteRegisterRequestBlueprint(\r\n+                        HeliosEasyControlsBindingConstants.UNIT_ID, HeliosEasyControlsBindingConstants.START_ADDRESS,\r\n+                        new ModbusRegisterArray(preparePayload(payload)), true,\r\n+                        HeliosEasyControlsBindingConstants.MAX_TRIES), result -> {\r\n+                            this.comms.submitOneTimePoll(\r\n+                                    new ModbusReadRequestBlueprint(HeliosEasyControlsBindingConstants.UNIT_ID,\r\n+                                            ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS,\r\n+                                            HeliosEasyControlsBindingConstants.START_ADDRESS, v.getCount(),\r\n+                                            HeliosEasyControlsBindingConstants.MAX_TRIES),\r\n+                                    pollResult -> {\r\n+                                        lock.release();\r\n+                                        Optional<ModbusRegisterArray> registers = pollResult.getRegisters();\r\n+                                        if (registers.isPresent()) {\r\n+                                            processResponse(v, registers.get());\r\n+                                        }\r\n+                                    }, failureInfo -> {\r\n+                                        String errorMsg = failureInfo.getCause().getMessage();\r\n+                                        logger.warn(\"{} encountered error reading from device: {}\",\r\n+                                                HeliosEasyControlsHandler.class.getSimpleName(), errorMsg);\r\n+                                        lock.release();\r\n+                                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\r\n+                                                errorMsg);\r\n+                                    });\r\n+                        }, failureInfo -> {\r\n+                            String errorMsg = failureInfo.getCause().getMessage();\r\n+                            logger.warn(\"{} encountered error writing to device: {}\",\r\n+                                    HeliosEasyControlsHandler.class.getSimpleName(), errorMsg);\r\n+                            lock.release();\r\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, errorMsg);\r\n+\r\n+                        });\r\n+            }\r\n+        } else {\r\n+            if (this.comms == null) {\r\n+                this.handleError(\"Modbus communication interface is unavailable.\",\r\n+                        ThingStatusDetail.COMMUNICATION_ERROR);\r\n+            }\r\n+            if (this.vMap == null) {\r\n+                this.handleError(\"Variable definition is unavailable.\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    // TODO: set time incl. timezone, update time channels based on timezone read from device\r\n+\r\n+    /**\r\n+     * Formats the provided date to a string in the device's configured date format\r\n+     *\r\n+     * @param variableName the variable name\r\n+     * @param date the date to be formatted\r\n+     * @return a string in the device's configured date format\r\n+     */\r\n+    private String formatDate(String variableName, ZonedDateTime date) {\r\n+        String y = Integer.toString(date.getYear());\r\n+        String m = Integer.toString(date.getMonthValue());\r\n+        if (m.length() == 1) {\r\n+            m = \"0\" + m;\r\n+        }\r\n+        String d = Integer.toString(date.getDayOfMonth());\r\n+        if (d.length() == 1) {\r\n+            d = \"0\" + d;\r\n+        }\r\n+        if (variableName.equals(HeliosEasyControlsBindingConstants.DATE)) { // fixed format for writing the system date\r\n+            return d + \".\" + m + \".\" + y;\r\n+        } else {\r\n+            switch (this.dateFormat) {\r\n+                case 0: // dd.mm.yyyy\r\n+                    return d + \".\" + m + \".\" + y;\r\n+                case 1: // mm.dd.yyyy\r\n+                    return m + \".\" + d + \".\" + y;\r\n+                case 2: // yyyy.mm.dd\r\n+                    return y + \".\" + m + \".\" + d;\r\n+                default:\r\n+                    return d + \".\" + m + \".\" + y;\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns a DateTimeType object based on the provided String and the device's configured date format\r\n+     *\r\n+     * @param date The date string read from the device\r\n+     * @return A DateTimeType object representing the date or time specified\r\n+     */\r\n+    private DateTimeType toDateTime(String date) {\r\n+        String[] dateTimeParts = null;\r\n+        String dateTime = date;\r\n+        try { // date\r\n+            dateTimeParts = date.split(\"\\\\.\"); // try to split date components\r\n+            if (dateTimeParts.length == 1) { // time\r\n+                return DateTimeType.valueOf(date);\r\n+            } else { // date - we'll try the device's date format\r\n+                switch (this.dateFormat) {\r\n+                    case 0: // dd.mm.yyyy\r\n+                        dateTime = dateTimeParts[2] + \"-\" + dateTimeParts[1] + \"-\" + dateTimeParts[0];\r\n+                        break;\r\n+                    case 1: // mm.dd.yyyy\r\n+                        dateTime = dateTimeParts[2] + \"-\" + dateTimeParts[0] + \"-\" + dateTimeParts[1];\r\n+                        break;\r\n+                    case 2: // yyyy.mm.dd\r\n+                        dateTime = dateTimeParts[0] + \"-\" + dateTimeParts[1] + \"-\" + dateTimeParts[2];\r\n+                        break;\r\n+                    default:\r\n+                        dateTime = dateTimeParts[2] + \"-\" + dateTimeParts[1] + \"-\" + dateTimeParts[0];\r\n+                        break;\r\n+                }\r\n+                return DateTimeType.valueOf(dateTime);\r\n+            }\r\n+        } catch (Exception e) {\r\n+            // falling back to default date format (apparently using the configured format has failed)\r\n+            if (dateTimeParts != null) {\r\n+                dateTime = dateTimeParts[2] + \"-\" + dateTimeParts[1] + \"-\" + dateTimeParts[0];\r\n+                return DateTimeType.valueOf(dateTime);\r\n+            } else {\r\n+                logger.warn(\"{} couldn't parse the provided date string: {}\",\r\n+                        HeliosEasyControlsHandler.class.getSimpleName(), date);\r\n+                return new DateTimeType(); // return at least a valid DateTimeType object\r\n+            }\r\n+\r\n+        }\r\n+    }\r\n+\r\n+    private @Nullable QuantityType<?> toQuantityType(String value, @Nullable String unit) {\r\n+        if (unit == null) {\r\n+            return null;\r\n+        } else if (unit.equals(HeliosVariable.UNIT_DAY)) {\r\n+            return new QuantityType<>(Integer.parseInt(value), SmartHomeUnits.DAY);\r\n+        } else if (unit.equals(HeliosVariable.UNIT_HOUR)) {\r\n+            return new QuantityType<>(Integer.parseInt(value), SmartHomeUnits.HOUR);\r\n+        } else if (unit.equals(HeliosVariable.UNIT_MIN)) {\r\n+            return new QuantityType<>(Integer.parseInt(value), SmartHomeUnits.MINUTE);\r\n+        } else if (unit.equals(HeliosVariable.UNIT_SEC)) {\r\n+            return new QuantityType<>(Integer.parseInt(value), SmartHomeUnits.SECOND);\r\n+        } else if (unit.equals(HeliosVariable.UNIT_VOLT)) {\r\n+            return new QuantityType<>(Float.parseFloat(value), SmartHomeUnits.VOLT);\r\n+        } else if (unit.equals(HeliosVariable.UNIT_PERCENT)) {\r\n+            return new QuantityType<>(Float.parseFloat(value), SmartHomeUnits.PERCENT);\r\n+        } else if (unit.equals(HeliosVariable.UNIT_PPM)) {\r\n+            return new QuantityType<>(Float.parseFloat(value), SmartHomeUnits.PARTS_PER_MILLION);\r\n+        } else if (unit.equals(HeliosVariable.UNIT_TEMP)) {\r\n+            return new QuantityType<>(Float.parseFloat(value), SIUnits.CELSIUS);\r\n+        } else {\r\n+            return null;\r\n+        }\r\n+    }\r\n+\r\n+    // TODO: Set date, time and UTC delta together => also additional channel required\r\n+\r\n+    /**\r\n+     * Prepares the payload for the request\r\n+     *\r\n+     * @param payload The String representation of the payload\r\n+     * @return The Register representation of the payload\r\n+     */\r\n+    private ModbusRegister[] preparePayload(String payload) {\r\n+\r\n+        // determine number of registers\r\n+        int l = (payload.length() + 1) / 2; // +1 because we need to include at least one termination symbol 0x00\r\n+        if ((payload.length() + 1) % 2 != 0) {\r\n+            l++;\r\n+        }\r\n+\r\n+        ModbusRegister reg[] = new ModbusRegister[l];\r\n+        byte[] b = payload.getBytes();\r\n+        int ch = 0;\r\n+        for (int i = 0; i < reg.length; i++) {\r\n+            byte b1 = ch < b.length ? b[ch] : (byte) 0x00; // terminate with 0x00 if at the end of the payload\r\n+            ch++;\r\n+            byte b2 = ch < b.length ? b[ch] : (byte) 0x00;\r\n+            ch++;\r\n+            reg[i] = new ModbusRegister(b1, b2);\r\n+        }\r\n+        return reg;\r\n+    }\r\n+\r\n+    /**\r\n+     * Decodes the Helios device' response and updates the channel with the actual value of the variable\r\n+     *\r\n+     * @param response The registers received from the Helios device\r\n+     * @return The value or <tt>null</tt> if an error occurred\r\n+     */\r\n+    private void processResponse(HeliosVariable v, ModbusRegisterArray registers) {\r\n+        // decode response\r\n+        byte[] b = new byte[registers.size() * 2];\r\n+        int actSize = 0; // track the actual size of the usable array (excluding any 0x00\r\n+                         // characters)\r\n+        for (int i = 0; i < registers.size(); i++) {\r\n+            byte[] reg = registers.getRegister(i).getBytes();\r\n+            if (reg.length == 2) { // only add to the array if it's a usable character\r\n+                if (reg[0] != 0x00) {\r\n+                    b[actSize++] = reg[0];\r\n+                }\r\n+                if (reg[1] != 0x00) {\r\n+                    b[actSize++] = reg[1];\r\n+                }\r\n+            }\r\n+        }\r\n+        b = Arrays.copyOf(b, actSize); // before creating a string of it the array needs to be\r\n+                                       // truncated\r\n+        String r = new String(b, StandardCharsets.US_ASCII);\r\n+        String[] parts = r.split(\"=\", 2); // remove the part \"vXXXX=\" from the string\r\n+        // making sure we have a proper response and the response matches the requested variable\r\n+        if ((parts.length == 2) && (v.getVariableString().equals(parts[0]))) {\r\n+            String variableType = v.getType();\r\n+            Channel channel = getThing().getChannel(v.getGroupAndName());\r\n+            String itemType;\r\n+            if (channel != null) {\r\n+                itemType = channel.getAcceptedItemType();\r\n+                if (itemType != null) {\r\n+                    switch (itemType) {\r\n+                        case \"Number\":\r\n+                            if (((variableType.equals(HeliosVariable.TYPE_INTEGER))\r\n+                                    || (variableType == HeliosVariable.TYPE_FLOAT)) && (!parts[1].equals(\"-\"))) {\r\n+                                State state = null;\r\n+                                if (v.getUnit() == null) {\r\n+                                    state = DecimalType.valueOf(parts[1]);\r\n+                                } else { // QuantityType\r\n+                                    state = this.toQuantityType(parts[1], v.getUnit());\r\n+                                }\r\n+                                if (state != null) {\r\n+                                    updateState(v.getGroupAndName(), state);\r\n+                                    updateStatus(ThingStatus.ONLINE);\r\n+                                    // update date format and UTC offset upon read\r\n+                                    if (v.getName().equals(HeliosEasyControlsBindingConstants.DATE_FORMAT)) {\r\n+                                        this.dateFormat = Integer.parseInt(parts[1]);\r\n+                                    } else if (v.getName()\r\n+                                            .equals(HeliosEasyControlsBindingConstants.TIME_ZONE_DIFFERENCE_TO_GMT)) {\r\n+                                        this.utcOffset = Integer.parseInt(parts[1]);\r\n+                                    }\r\n+                                }\r\n+                            }\r\n+                            break;\r\n+                        case \"Switch\":\r\n+                            if (variableType.equals(HeliosVariable.TYPE_INTEGER)) {\r\n+                                updateState(v.getGroupAndName(), parts[1].equals(\"1\") ? OnOffType.ON : OnOffType.OFF);\r\n+                            }\r\n+                            break;\r\n+                        case \"String\":\r\n+                            if (variableType.equals(HeliosVariable.TYPE_STRING)) {\r\n+                                updateState(v.getGroupAndName(), StringType.valueOf(parts[1]));\r\n+                            }\r\n+                            break;\r\n+                        case \"DateTime\":\r\n+                            if (variableType.equals(HeliosVariable.TYPE_STRING)) {\r\n+                                updateState(v.getGroupAndName(), toDateTime(parts[1]));\r\n+                            }\r\n+                            break;\r\n+                    }\r\n+                } else { // itemType was null\r\n+                    logger.warn(\"{} couldn't determine item type of variable {}\",\r\n+                            HeliosEasyControlsHandler.class.getSimpleName(), v.getName());\r\n+                }\r\n+            } else { // channel was null\r\n+                logger.warn(\"{} couldn't find channel for variable {}\", HeliosEasyControlsHandler.class.getSimpleName(),\r\n+                        v.getName());\r\n+            }\r\n+        } else { // another variable was read\r\n+            logger.warn(\"{} tried to read value from variable {} and the result provided by the device was {}\",\r\n+                    HeliosEasyControlsHandler.class.getSimpleName(), v.getName(), r);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Logs an error (as a warning entry) and updates the thing status\r\n+     *\r\n+     * @param errorMsg The error message to be logged and provided with the Thing's status update\r\n+     * @param status The Thing's new status\r\n+     */\r\n+    private void handleError(String errorMsg, ThingStatusDetail status) {\r\n+        logger.warn(\"{}\", errorMsg);\r\n+        updateStatus(ThingStatus.OFFLINE, status, errorMsg);\r", "originalCommit": "a29484f182958feae2d73f3ac06490316afc5798", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxNjI5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r479816297", "bodyText": "The logger is never used.", "author": "fwolter", "createdAt": "2020-08-30T21:13:29Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandlerFactory.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import static org.openhab.binding.modbus.helioseasycontrols.internal.HeliosEasyControlsBindingConstants.THING_TYPE_HELIOS_VENTILATION_EASY_CONTROLS;\r\n+\r\n+import java.util.Collections;\r\n+import java.util.Set;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\r\n+import org.osgi.service.component.annotations.Component;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandlerFactory} is responsible for creating things and thing\r\n+ * handlers.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+@NonNullByDefault\r\n+@Component(configurationPid = \"binding.helioseasycontrols\", service = ThingHandlerFactory.class)\r\n+public class HeliosEasyControlsHandlerFactory extends BaseThingHandlerFactory {\r\n+\r\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections\r\n+            .singleton(THING_TYPE_HELIOS_VENTILATION_EASY_CONTROLS);\r\n+\r\n+    /**\r\n+     * Logger instance\r\n+     */\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandlerFactory.class);\r", "originalCommit": "a29484f182958feae2d73f3ac06490316afc5798", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxNjU3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r479816575", "bodyText": "Syntactical sugar\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    String v = Integer.toString(this.variable);\n          \n          \n            \n                    while (v.length() < 5) {\n          \n          \n            \n                        v = '0' + v;\n          \n          \n            \n                    }\n          \n          \n            \n                    v = 'v' + v;\n          \n          \n            \n                    return v;\n          \n          \n            \n                    return String.format(\"v%05d\", variable);", "author": "fwolter", "createdAt": "2020-08-30T21:16:10Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosVariable.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+\r\n+/**\r\n+ * This class represents a variable of the Helios modbus.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ * @version 2.0\r\n+ */\r\n+@NonNullByDefault\r\n+public class HeliosVariable implements Comparable<HeliosVariable> {\r\n+\r\n+    /**\r\n+     * Read access\r\n+     */\r\n+    public static final String ACCESS_R = \"R\";\r\n+\r\n+    /**\r\n+     * Write access\r\n+     */\r\n+    public static final String ACCESS_W = \"W\";\r\n+\r\n+    /**\r\n+     * Read and write access\r\n+     */\r\n+    public static final String ACCESS_RW = \"RW\";\r\n+\r\n+    /**\r\n+     * Integer type\r\n+     */\r\n+    public static final String TYPE_INTEGER = \"int\";\r\n+\r\n+    /**\r\n+     * Float type\r\n+     */\r\n+    public static final String TYPE_FLOAT = \"float\";\r\n+\r\n+    /**\r\n+     * String type\r\n+     */\r\n+    public static final String TYPE_STRING = \"string\";\r\n+\r\n+    /**\r\n+     * Unit Volt\r\n+     */\r\n+    public static final String UNIT_VOLT = \"V\";\r\n+\r\n+    /**\r\n+     * Unit %\r\n+     */\r\n+    public static final String UNIT_PERCENT = \"%\";\r\n+\r\n+    /**\r\n+     * Unit ppm\r\n+     */\r\n+    public static final String UNIT_PPM = \"ppm\";\r\n+\r\n+    /**\r\n+     * Unit degrees Celsius\r\n+     */\r\n+    public static final String UNIT_TEMP = \"\u00b0C\";\r\n+\r\n+    /**\r\n+     * Unit day\r\n+     */\r\n+    public static final String UNIT_DAY = \"d\";\r\n+\r\n+    /**\r\n+     * Unit hour\r\n+     */\r\n+    public static final String UNIT_HOUR = \"h\";\r\n+\r\n+    /**\r\n+     * Unit minute\r\n+     */\r\n+    public static final String UNIT_MIN = \"min\";\r\n+\r\n+    /**\r\n+     * Unit second\r\n+     */\r\n+    public static final String UNIT_SEC = \"s\";\r\n+\r\n+    /**\r\n+     * The variable number\r\n+     */\r\n+    private int variable;\r\n+\r\n+    /**\r\n+     * The variable name\r\n+     */\r\n+    private String name;\r\n+\r\n+    /**\r\n+     * The variable group\r\n+     */\r\n+    private @Nullable String group;\r\n+\r\n+    /**\r\n+     * The access to the variable\r\n+     */\r\n+    private String access;\r\n+\r\n+    /**\r\n+     * The length of the variable (number of chars)\r\n+     */\r\n+    private int length;\r\n+\r\n+    /**\r\n+     * The register count for this variable\r\n+     */\r\n+    private int count;\r\n+\r\n+    /**\r\n+     * The variable type\r\n+     */\r\n+    private String type;\r\n+\r\n+    /**\r\n+     * The variable's unit\r\n+     */\r\n+    private @Nullable String unit;\r\n+\r\n+    /**\r\n+     * The minimal value (or null if not applicable)\r\n+     */\r\n+    private @Nullable Double minVal;\r\n+\r\n+    /**\r\n+     * The maximum value (or null if not applicable)\r\n+     */\r\n+    private @Nullable Double maxVal;\r\n+\r\n+    /**\r\n+     * Constructor to set the member variables\r\n+     *\r\n+     * @param variable The variable's number\r\n+     * @param name The variable's name\r\n+     * @param group The variable's group\r\n+     * @param access Access possibilities\r\n+     * @param length Number of expected characters when writing to / reading from Modbus\r\n+     * @param count Exact number of characters to write to Modbus\r\n+     * @param type Variable type (string, integer or float)\r\n+     * @param unit Variable's unit\r\n+     * @param minVal Minimum value (only applicable for numeric values)\r\n+     * @param maxVal Maximum value (only applicable for numeric values)\r\n+     */\r\n+    public HeliosVariable(int variable, String name, @Nullable String group, String access, int length, int count,\r\n+            String type, @Nullable String unit, @Nullable Double minVal, @Nullable Double maxVal) {\r\n+        this.variable = variable;\r\n+        this.name = name;\r\n+        this.group = group;\r\n+        this.access = access;\r\n+        this.length = length;\r\n+        this.count = count;\r\n+        this.type = type;\r\n+        this.unit = unit;\r\n+        this.minVal = minVal;\r\n+        this.maxVal = maxVal;\r\n+    }\r\n+\r\n+    /**\r\n+     * Constructor to set the member variables\r\n+     *\r\n+     * @param variable The variable's number\r\n+     * @param name The variable's name\r\n+     * @param group The variable's group\r\n+     * @param access Access possibilities\r\n+     * @param length Number of expected characters when writing to / reading from Modbus\r\n+     * @param count Exact number of characters to write to Modbus\r\n+     * @param type Variable type (string, integer or float)\r\n+     * @param unit Variable's unit\r\n+     */\r\n+    public HeliosVariable(int variable, String name, @Nullable String group, String access, int length, int count,\r\n+            String type, String unit) {\r\n+        this(variable, name, group, access, length, count, type, unit, null, null);\r\n+    }\r\n+\r\n+    /**\r\n+     * Constructor to set the member variables\r\n+     *\r\n+     * @param variable The variable's number\r\n+     * @param name The variable's name\r\n+     * @param group The variable's group\r\n+     * @param access Access possibilities\r\n+     * @param length Number of expected characters when writing to / reading from Modbus\r\n+     * @param count Exact number of characters to write to Modbus\r\n+     * @param type Variable type (string, integer or float)\r\n+     */\r\n+    public HeliosVariable(int variable, String name, @Nullable String group, String access, int length, int count,\r\n+            String type) {\r\n+        this(variable, name, group, access, length, count, type, null, null, null);\r\n+    }\r\n+\r\n+    /**\r\n+     * Getter for variable\r\n+     *\r\n+     * @return variable\r\n+     */\r\n+    public int getVariable() {\r\n+        return this.variable;\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns a formatted string representation for the variable\r\n+     *\r\n+     * @return String The string representation for the variable (e.g. 'v00020' for variable number 20)\r\n+     */\r\n+    public String getVariableString() {\r\n+        String v = Integer.toString(this.variable);\r\n+        while (v.length() < 5) {\r\n+            v = '0' + v;\r\n+        }\r\n+        v = 'v' + v;\r\n+        return v;\r", "originalCommit": "a29484f182958feae2d73f3ac06490316afc5798", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxNjcxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r479816711", "bodyText": "Primitive types should be used where possible. Same for below.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                Long l = new Double(value).longValue();\n          \n          \n            \n                                long l = new Double(value).longValue();", "author": "fwolter", "createdAt": "2020-08-30T21:17:40Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosVariable.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+\r\n+/**\r\n+ * This class represents a variable of the Helios modbus.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ * @version 2.0\r\n+ */\r\n+@NonNullByDefault\r\n+public class HeliosVariable implements Comparable<HeliosVariable> {\r\n+\r\n+    /**\r\n+     * Read access\r\n+     */\r\n+    public static final String ACCESS_R = \"R\";\r\n+\r\n+    /**\r\n+     * Write access\r\n+     */\r\n+    public static final String ACCESS_W = \"W\";\r\n+\r\n+    /**\r\n+     * Read and write access\r\n+     */\r\n+    public static final String ACCESS_RW = \"RW\";\r\n+\r\n+    /**\r\n+     * Integer type\r\n+     */\r\n+    public static final String TYPE_INTEGER = \"int\";\r\n+\r\n+    /**\r\n+     * Float type\r\n+     */\r\n+    public static final String TYPE_FLOAT = \"float\";\r\n+\r\n+    /**\r\n+     * String type\r\n+     */\r\n+    public static final String TYPE_STRING = \"string\";\r\n+\r\n+    /**\r\n+     * Unit Volt\r\n+     */\r\n+    public static final String UNIT_VOLT = \"V\";\r\n+\r\n+    /**\r\n+     * Unit %\r\n+     */\r\n+    public static final String UNIT_PERCENT = \"%\";\r\n+\r\n+    /**\r\n+     * Unit ppm\r\n+     */\r\n+    public static final String UNIT_PPM = \"ppm\";\r\n+\r\n+    /**\r\n+     * Unit degrees Celsius\r\n+     */\r\n+    public static final String UNIT_TEMP = \"\u00b0C\";\r\n+\r\n+    /**\r\n+     * Unit day\r\n+     */\r\n+    public static final String UNIT_DAY = \"d\";\r\n+\r\n+    /**\r\n+     * Unit hour\r\n+     */\r\n+    public static final String UNIT_HOUR = \"h\";\r\n+\r\n+    /**\r\n+     * Unit minute\r\n+     */\r\n+    public static final String UNIT_MIN = \"min\";\r\n+\r\n+    /**\r\n+     * Unit second\r\n+     */\r\n+    public static final String UNIT_SEC = \"s\";\r\n+\r\n+    /**\r\n+     * The variable number\r\n+     */\r\n+    private int variable;\r\n+\r\n+    /**\r\n+     * The variable name\r\n+     */\r\n+    private String name;\r\n+\r\n+    /**\r\n+     * The variable group\r\n+     */\r\n+    private @Nullable String group;\r\n+\r\n+    /**\r\n+     * The access to the variable\r\n+     */\r\n+    private String access;\r\n+\r\n+    /**\r\n+     * The length of the variable (number of chars)\r\n+     */\r\n+    private int length;\r\n+\r\n+    /**\r\n+     * The register count for this variable\r\n+     */\r\n+    private int count;\r\n+\r\n+    /**\r\n+     * The variable type\r\n+     */\r\n+    private String type;\r\n+\r\n+    /**\r\n+     * The variable's unit\r\n+     */\r\n+    private @Nullable String unit;\r\n+\r\n+    /**\r\n+     * The minimal value (or null if not applicable)\r\n+     */\r\n+    private @Nullable Double minVal;\r\n+\r\n+    /**\r\n+     * The maximum value (or null if not applicable)\r\n+     */\r\n+    private @Nullable Double maxVal;\r\n+\r\n+    /**\r\n+     * Constructor to set the member variables\r\n+     *\r\n+     * @param variable The variable's number\r\n+     * @param name The variable's name\r\n+     * @param group The variable's group\r\n+     * @param access Access possibilities\r\n+     * @param length Number of expected characters when writing to / reading from Modbus\r\n+     * @param count Exact number of characters to write to Modbus\r\n+     * @param type Variable type (string, integer or float)\r\n+     * @param unit Variable's unit\r\n+     * @param minVal Minimum value (only applicable for numeric values)\r\n+     * @param maxVal Maximum value (only applicable for numeric values)\r\n+     */\r\n+    public HeliosVariable(int variable, String name, @Nullable String group, String access, int length, int count,\r\n+            String type, @Nullable String unit, @Nullable Double minVal, @Nullable Double maxVal) {\r\n+        this.variable = variable;\r\n+        this.name = name;\r\n+        this.group = group;\r\n+        this.access = access;\r\n+        this.length = length;\r\n+        this.count = count;\r\n+        this.type = type;\r\n+        this.unit = unit;\r\n+        this.minVal = minVal;\r\n+        this.maxVal = maxVal;\r\n+    }\r\n+\r\n+    /**\r\n+     * Constructor to set the member variables\r\n+     *\r\n+     * @param variable The variable's number\r\n+     * @param name The variable's name\r\n+     * @param group The variable's group\r\n+     * @param access Access possibilities\r\n+     * @param length Number of expected characters when writing to / reading from Modbus\r\n+     * @param count Exact number of characters to write to Modbus\r\n+     * @param type Variable type (string, integer or float)\r\n+     * @param unit Variable's unit\r\n+     */\r\n+    public HeliosVariable(int variable, String name, @Nullable String group, String access, int length, int count,\r\n+            String type, String unit) {\r\n+        this(variable, name, group, access, length, count, type, unit, null, null);\r\n+    }\r\n+\r\n+    /**\r\n+     * Constructor to set the member variables\r\n+     *\r\n+     * @param variable The variable's number\r\n+     * @param name The variable's name\r\n+     * @param group The variable's group\r\n+     * @param access Access possibilities\r\n+     * @param length Number of expected characters when writing to / reading from Modbus\r\n+     * @param count Exact number of characters to write to Modbus\r\n+     * @param type Variable type (string, integer or float)\r\n+     */\r\n+    public HeliosVariable(int variable, String name, @Nullable String group, String access, int length, int count,\r\n+            String type) {\r\n+        this(variable, name, group, access, length, count, type, null, null, null);\r\n+    }\r\n+\r\n+    /**\r\n+     * Getter for variable\r\n+     *\r\n+     * @return variable\r\n+     */\r\n+    public int getVariable() {\r\n+        return this.variable;\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns a formatted string representation for the variable\r\n+     *\r\n+     * @return String The string representation for the variable (e.g. 'v00020' for variable number 20)\r\n+     */\r\n+    public String getVariableString() {\r\n+        String v = Integer.toString(this.variable);\r\n+        while (v.length() < 5) {\r\n+            v = '0' + v;\r\n+        }\r\n+        v = 'v' + v;\r\n+        return v;\r\n+    }\r\n+\r\n+    /**\r\n+     * Setter for name\r\n+     *\r\n+     */\r\n+    public void setName(String name) {\r\n+        this.name = name;\r\n+    }\r\n+\r\n+    /**\r\n+     * Getter for name\r\n+     *\r\n+     * @return name\r\n+     */\r\n+    public String getName() {\r\n+        return this.name;\r\n+    }\r\n+\r\n+    /**\r\n+     * Getter for group\r\n+     *\r\n+     * @return group\r\n+     */\r\n+    public @Nullable String getGroup() {\r\n+        return this.group;\r\n+    }\r\n+\r\n+    /**\r\n+     * Getter for access\r\n+     *\r\n+     * @return access\r\n+     */\r\n+    public String getAccess() {\r\n+        return this.access;\r\n+    }\r\n+\r\n+    /**\r\n+     * Getter for length\r\n+     *\r\n+     * @return length\r\n+     */\r\n+    public int getLength() {\r\n+        return this.length;\r\n+    }\r\n+\r\n+    /**\r\n+     * Getter for count\r\n+     *\r\n+     * @return count\r\n+     */\r\n+    public int getCount() {\r\n+        return this.count;\r\n+    }\r\n+\r\n+    /**\r\n+     * Getter for the type\r\n+     */\r\n+    public String getType() {\r\n+        return this.type;\r\n+    }\r\n+\r\n+    /**\r\n+     * Getter for the unit\r\n+     */\r\n+    public @Nullable String getUnit() {\r\n+        return this.unit;\r\n+    }\r\n+\r\n+    /**\r\n+     * Getter for minimum value\r\n+     *\r\n+     * @return minimum value\r\n+     */\r\n+    public @Nullable Double getMinVal() {\r\n+        return this.minVal;\r\n+    }\r\n+\r\n+    /**\r\n+     * Getter for maximum value\r\n+     *\r\n+     * @return maximum value\r\n+     */\r\n+    public @Nullable Double getMaxVal() {\r\n+        return this.maxVal;\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns the variable's name and prefixes the group, separated by a # if available\r\n+     *\r\n+     * @return the variable's name and prefixes the group, separated by a # if available\r\n+     */\r\n+    public String getGroupAndName() {\r\n+        return this.group != null ? this.group + \"#\" + this.name : this.name;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks if the variable's data are consistent\r\n+     *\r\n+     * @return true if the variable contains consistent data\r\n+     */\r\n+    public boolean isOk() {\r\n+        boolean check;\r\n+\r\n+        // this.access has one of the allowed values\r\n+        check = (this.access.equals(HeliosVariable.ACCESS_R)) || (this.access.equals(HeliosVariable.ACCESS_W))\r\n+                || (this.access.equals(HeliosVariable.ACCESS_RW));\r\n+\r\n+        // this.type has one of the allowed values\r\n+        check = check && ((this.type.equals(HeliosVariable.TYPE_STRING))\r\n+                || (this.type.equals(HeliosVariable.TYPE_INTEGER)) || (this.type.equals(HeliosVariable.TYPE_FLOAT)));\r\n+\r\n+        // this.minValue and this.maxValue are either not set or minValue is less than maxValue\r\n+        check = check && (((this.minVal == null) && (this.maxVal == null)) || (this.minVal <= this.maxVal));\r\n+\r\n+        // length is set\r\n+        check = check && (this.length > 0);\r\n+\r\n+        // count is set\r\n+        check = check && (this.count > 0);\r\n+\r\n+        return check;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks if the variable has write access\r\n+     *\r\n+     * @return true if the variable has write access\r\n+     */\r\n+    public boolean hasWriteAccess() {\r\n+        return (this.access.equals(HeliosVariable.ACCESS_W)) || (this.access.equals(HeliosVariable.ACCESS_RW));\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks if the variable has read access\r\n+     *\r\n+     * @return true if the variable has read access\r\n+     */\r\n+    public boolean hasReadAccess() {\r\n+        return (this.access.equals(HeliosVariable.ACCESS_R)) || (this.access.equals(HeliosVariable.ACCESS_RW));\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks if the provided value is within the accepted range\r\n+     *\r\n+     * @param value The value as a string\r\n+     * @return true if the value is within the accepted range\r\n+     */\r\n+    public boolean isInAllowedRange(String value) {\r\n+        if ((this.getMinVal() != null) && (this.getMaxVal() != null)) { // min and max value are set\r\n+            try {\r\n+                if (this.type.equals(HeliosVariable.TYPE_INTEGER)) {\r\n+                    // using long becuase some variable are specified with a max of 2^32-1\r\n+                    // parsing double to allow floating point values to be processed as well\r\n+                    Long l = new Double(value).longValue();\r", "originalCommit": "a29484f182958feae2d73f3ac06490316afc5798", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxNjc2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r479816762", "bodyText": "What type of exception do you expect here? Can you specify the concrete type?", "author": "fwolter", "createdAt": "2020-08-30T21:18:10Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosVariable.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+\r\n+/**\r\n+ * This class represents a variable of the Helios modbus.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ * @version 2.0\r\n+ */\r\n+@NonNullByDefault\r\n+public class HeliosVariable implements Comparable<HeliosVariable> {\r\n+\r\n+    /**\r\n+     * Read access\r\n+     */\r\n+    public static final String ACCESS_R = \"R\";\r\n+\r\n+    /**\r\n+     * Write access\r\n+     */\r\n+    public static final String ACCESS_W = \"W\";\r\n+\r\n+    /**\r\n+     * Read and write access\r\n+     */\r\n+    public static final String ACCESS_RW = \"RW\";\r\n+\r\n+    /**\r\n+     * Integer type\r\n+     */\r\n+    public static final String TYPE_INTEGER = \"int\";\r\n+\r\n+    /**\r\n+     * Float type\r\n+     */\r\n+    public static final String TYPE_FLOAT = \"float\";\r\n+\r\n+    /**\r\n+     * String type\r\n+     */\r\n+    public static final String TYPE_STRING = \"string\";\r\n+\r\n+    /**\r\n+     * Unit Volt\r\n+     */\r\n+    public static final String UNIT_VOLT = \"V\";\r\n+\r\n+    /**\r\n+     * Unit %\r\n+     */\r\n+    public static final String UNIT_PERCENT = \"%\";\r\n+\r\n+    /**\r\n+     * Unit ppm\r\n+     */\r\n+    public static final String UNIT_PPM = \"ppm\";\r\n+\r\n+    /**\r\n+     * Unit degrees Celsius\r\n+     */\r\n+    public static final String UNIT_TEMP = \"\u00b0C\";\r\n+\r\n+    /**\r\n+     * Unit day\r\n+     */\r\n+    public static final String UNIT_DAY = \"d\";\r\n+\r\n+    /**\r\n+     * Unit hour\r\n+     */\r\n+    public static final String UNIT_HOUR = \"h\";\r\n+\r\n+    /**\r\n+     * Unit minute\r\n+     */\r\n+    public static final String UNIT_MIN = \"min\";\r\n+\r\n+    /**\r\n+     * Unit second\r\n+     */\r\n+    public static final String UNIT_SEC = \"s\";\r\n+\r\n+    /**\r\n+     * The variable number\r\n+     */\r\n+    private int variable;\r\n+\r\n+    /**\r\n+     * The variable name\r\n+     */\r\n+    private String name;\r\n+\r\n+    /**\r\n+     * The variable group\r\n+     */\r\n+    private @Nullable String group;\r\n+\r\n+    /**\r\n+     * The access to the variable\r\n+     */\r\n+    private String access;\r\n+\r\n+    /**\r\n+     * The length of the variable (number of chars)\r\n+     */\r\n+    private int length;\r\n+\r\n+    /**\r\n+     * The register count for this variable\r\n+     */\r\n+    private int count;\r\n+\r\n+    /**\r\n+     * The variable type\r\n+     */\r\n+    private String type;\r\n+\r\n+    /**\r\n+     * The variable's unit\r\n+     */\r\n+    private @Nullable String unit;\r\n+\r\n+    /**\r\n+     * The minimal value (or null if not applicable)\r\n+     */\r\n+    private @Nullable Double minVal;\r\n+\r\n+    /**\r\n+     * The maximum value (or null if not applicable)\r\n+     */\r\n+    private @Nullable Double maxVal;\r\n+\r\n+    /**\r\n+     * Constructor to set the member variables\r\n+     *\r\n+     * @param variable The variable's number\r\n+     * @param name The variable's name\r\n+     * @param group The variable's group\r\n+     * @param access Access possibilities\r\n+     * @param length Number of expected characters when writing to / reading from Modbus\r\n+     * @param count Exact number of characters to write to Modbus\r\n+     * @param type Variable type (string, integer or float)\r\n+     * @param unit Variable's unit\r\n+     * @param minVal Minimum value (only applicable for numeric values)\r\n+     * @param maxVal Maximum value (only applicable for numeric values)\r\n+     */\r\n+    public HeliosVariable(int variable, String name, @Nullable String group, String access, int length, int count,\r\n+            String type, @Nullable String unit, @Nullable Double minVal, @Nullable Double maxVal) {\r\n+        this.variable = variable;\r\n+        this.name = name;\r\n+        this.group = group;\r\n+        this.access = access;\r\n+        this.length = length;\r\n+        this.count = count;\r\n+        this.type = type;\r\n+        this.unit = unit;\r\n+        this.minVal = minVal;\r\n+        this.maxVal = maxVal;\r\n+    }\r\n+\r\n+    /**\r\n+     * Constructor to set the member variables\r\n+     *\r\n+     * @param variable The variable's number\r\n+     * @param name The variable's name\r\n+     * @param group The variable's group\r\n+     * @param access Access possibilities\r\n+     * @param length Number of expected characters when writing to / reading from Modbus\r\n+     * @param count Exact number of characters to write to Modbus\r\n+     * @param type Variable type (string, integer or float)\r\n+     * @param unit Variable's unit\r\n+     */\r\n+    public HeliosVariable(int variable, String name, @Nullable String group, String access, int length, int count,\r\n+            String type, String unit) {\r\n+        this(variable, name, group, access, length, count, type, unit, null, null);\r\n+    }\r\n+\r\n+    /**\r\n+     * Constructor to set the member variables\r\n+     *\r\n+     * @param variable The variable's number\r\n+     * @param name The variable's name\r\n+     * @param group The variable's group\r\n+     * @param access Access possibilities\r\n+     * @param length Number of expected characters when writing to / reading from Modbus\r\n+     * @param count Exact number of characters to write to Modbus\r\n+     * @param type Variable type (string, integer or float)\r\n+     */\r\n+    public HeliosVariable(int variable, String name, @Nullable String group, String access, int length, int count,\r\n+            String type) {\r\n+        this(variable, name, group, access, length, count, type, null, null, null);\r\n+    }\r\n+\r\n+    /**\r\n+     * Getter for variable\r\n+     *\r\n+     * @return variable\r\n+     */\r\n+    public int getVariable() {\r\n+        return this.variable;\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns a formatted string representation for the variable\r\n+     *\r\n+     * @return String The string representation for the variable (e.g. 'v00020' for variable number 20)\r\n+     */\r\n+    public String getVariableString() {\r\n+        String v = Integer.toString(this.variable);\r\n+        while (v.length() < 5) {\r\n+            v = '0' + v;\r\n+        }\r\n+        v = 'v' + v;\r\n+        return v;\r\n+    }\r\n+\r\n+    /**\r\n+     * Setter for name\r\n+     *\r\n+     */\r\n+    public void setName(String name) {\r\n+        this.name = name;\r\n+    }\r\n+\r\n+    /**\r\n+     * Getter for name\r\n+     *\r\n+     * @return name\r\n+     */\r\n+    public String getName() {\r\n+        return this.name;\r\n+    }\r\n+\r\n+    /**\r\n+     * Getter for group\r\n+     *\r\n+     * @return group\r\n+     */\r\n+    public @Nullable String getGroup() {\r\n+        return this.group;\r\n+    }\r\n+\r\n+    /**\r\n+     * Getter for access\r\n+     *\r\n+     * @return access\r\n+     */\r\n+    public String getAccess() {\r\n+        return this.access;\r\n+    }\r\n+\r\n+    /**\r\n+     * Getter for length\r\n+     *\r\n+     * @return length\r\n+     */\r\n+    public int getLength() {\r\n+        return this.length;\r\n+    }\r\n+\r\n+    /**\r\n+     * Getter for count\r\n+     *\r\n+     * @return count\r\n+     */\r\n+    public int getCount() {\r\n+        return this.count;\r\n+    }\r\n+\r\n+    /**\r\n+     * Getter for the type\r\n+     */\r\n+    public String getType() {\r\n+        return this.type;\r\n+    }\r\n+\r\n+    /**\r\n+     * Getter for the unit\r\n+     */\r\n+    public @Nullable String getUnit() {\r\n+        return this.unit;\r\n+    }\r\n+\r\n+    /**\r\n+     * Getter for minimum value\r\n+     *\r\n+     * @return minimum value\r\n+     */\r\n+    public @Nullable Double getMinVal() {\r\n+        return this.minVal;\r\n+    }\r\n+\r\n+    /**\r\n+     * Getter for maximum value\r\n+     *\r\n+     * @return maximum value\r\n+     */\r\n+    public @Nullable Double getMaxVal() {\r\n+        return this.maxVal;\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns the variable's name and prefixes the group, separated by a # if available\r\n+     *\r\n+     * @return the variable's name and prefixes the group, separated by a # if available\r\n+     */\r\n+    public String getGroupAndName() {\r\n+        return this.group != null ? this.group + \"#\" + this.name : this.name;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks if the variable's data are consistent\r\n+     *\r\n+     * @return true if the variable contains consistent data\r\n+     */\r\n+    public boolean isOk() {\r\n+        boolean check;\r\n+\r\n+        // this.access has one of the allowed values\r\n+        check = (this.access.equals(HeliosVariable.ACCESS_R)) || (this.access.equals(HeliosVariable.ACCESS_W))\r\n+                || (this.access.equals(HeliosVariable.ACCESS_RW));\r\n+\r\n+        // this.type has one of the allowed values\r\n+        check = check && ((this.type.equals(HeliosVariable.TYPE_STRING))\r\n+                || (this.type.equals(HeliosVariable.TYPE_INTEGER)) || (this.type.equals(HeliosVariable.TYPE_FLOAT)));\r\n+\r\n+        // this.minValue and this.maxValue are either not set or minValue is less than maxValue\r\n+        check = check && (((this.minVal == null) && (this.maxVal == null)) || (this.minVal <= this.maxVal));\r\n+\r\n+        // length is set\r\n+        check = check && (this.length > 0);\r\n+\r\n+        // count is set\r\n+        check = check && (this.count > 0);\r\n+\r\n+        return check;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks if the variable has write access\r\n+     *\r\n+     * @return true if the variable has write access\r\n+     */\r\n+    public boolean hasWriteAccess() {\r\n+        return (this.access.equals(HeliosVariable.ACCESS_W)) || (this.access.equals(HeliosVariable.ACCESS_RW));\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks if the variable has read access\r\n+     *\r\n+     * @return true if the variable has read access\r\n+     */\r\n+    public boolean hasReadAccess() {\r\n+        return (this.access.equals(HeliosVariable.ACCESS_R)) || (this.access.equals(HeliosVariable.ACCESS_RW));\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks if the provided value is within the accepted range\r\n+     *\r\n+     * @param value The value as a string\r\n+     * @return true if the value is within the accepted range\r\n+     */\r\n+    public boolean isInAllowedRange(String value) {\r\n+        if ((this.getMinVal() != null) && (this.getMaxVal() != null)) { // min and max value are set\r\n+            try {\r\n+                if (this.type.equals(HeliosVariable.TYPE_INTEGER)) {\r\n+                    // using long becuase some variable are specified with a max of 2^32-1\r\n+                    // parsing double to allow floating point values to be processed as well\r\n+                    Long l = new Double(value).longValue();\r\n+                    return (this.getMinVal().longValue() <= l) && (this.getMaxVal().longValue() >= l);\r\n+                } else if (this.type.equals(HeliosVariable.TYPE_FLOAT)) {\r\n+                    Double d = Double.parseDouble(value);\r\n+                    return (this.getMinVal() <= d) && (this.getMaxVal() >= d);\r\n+                }\r\n+            } catch (Exception e) {\r", "originalCommit": "a29484f182958feae2d73f3ac06490316afc5798", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxNjk4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r479816986", "bodyText": "What about this?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (this.getVariable() < v.getVariable()) {\n          \n          \n            \n                        return -1;\n          \n          \n            \n                    } else if (this.getVariable() == v.getVariable()) {\n          \n          \n            \n                        return 0;\n          \n          \n            \n                    } else {\n          \n          \n            \n                        return 1;\n          \n          \n            \n                    }\n          \n          \n            \n                    return getVariable() - v.getVariable();", "author": "fwolter", "createdAt": "2020-08-30T21:20:31Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosVariable.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+\r\n+/**\r\n+ * This class represents a variable of the Helios modbus.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ * @version 2.0\r\n+ */\r\n+@NonNullByDefault\r\n+public class HeliosVariable implements Comparable<HeliosVariable> {\r\n+\r\n+    /**\r\n+     * Read access\r\n+     */\r\n+    public static final String ACCESS_R = \"R\";\r\n+\r\n+    /**\r\n+     * Write access\r\n+     */\r\n+    public static final String ACCESS_W = \"W\";\r\n+\r\n+    /**\r\n+     * Read and write access\r\n+     */\r\n+    public static final String ACCESS_RW = \"RW\";\r\n+\r\n+    /**\r\n+     * Integer type\r\n+     */\r\n+    public static final String TYPE_INTEGER = \"int\";\r\n+\r\n+    /**\r\n+     * Float type\r\n+     */\r\n+    public static final String TYPE_FLOAT = \"float\";\r\n+\r\n+    /**\r\n+     * String type\r\n+     */\r\n+    public static final String TYPE_STRING = \"string\";\r\n+\r\n+    /**\r\n+     * Unit Volt\r\n+     */\r\n+    public static final String UNIT_VOLT = \"V\";\r\n+\r\n+    /**\r\n+     * Unit %\r\n+     */\r\n+    public static final String UNIT_PERCENT = \"%\";\r\n+\r\n+    /**\r\n+     * Unit ppm\r\n+     */\r\n+    public static final String UNIT_PPM = \"ppm\";\r\n+\r\n+    /**\r\n+     * Unit degrees Celsius\r\n+     */\r\n+    public static final String UNIT_TEMP = \"\u00b0C\";\r\n+\r\n+    /**\r\n+     * Unit day\r\n+     */\r\n+    public static final String UNIT_DAY = \"d\";\r\n+\r\n+    /**\r\n+     * Unit hour\r\n+     */\r\n+    public static final String UNIT_HOUR = \"h\";\r\n+\r\n+    /**\r\n+     * Unit minute\r\n+     */\r\n+    public static final String UNIT_MIN = \"min\";\r\n+\r\n+    /**\r\n+     * Unit second\r\n+     */\r\n+    public static final String UNIT_SEC = \"s\";\r\n+\r\n+    /**\r\n+     * The variable number\r\n+     */\r\n+    private int variable;\r\n+\r\n+    /**\r\n+     * The variable name\r\n+     */\r\n+    private String name;\r\n+\r\n+    /**\r\n+     * The variable group\r\n+     */\r\n+    private @Nullable String group;\r\n+\r\n+    /**\r\n+     * The access to the variable\r\n+     */\r\n+    private String access;\r\n+\r\n+    /**\r\n+     * The length of the variable (number of chars)\r\n+     */\r\n+    private int length;\r\n+\r\n+    /**\r\n+     * The register count for this variable\r\n+     */\r\n+    private int count;\r\n+\r\n+    /**\r\n+     * The variable type\r\n+     */\r\n+    private String type;\r\n+\r\n+    /**\r\n+     * The variable's unit\r\n+     */\r\n+    private @Nullable String unit;\r\n+\r\n+    /**\r\n+     * The minimal value (or null if not applicable)\r\n+     */\r\n+    private @Nullable Double minVal;\r\n+\r\n+    /**\r\n+     * The maximum value (or null if not applicable)\r\n+     */\r\n+    private @Nullable Double maxVal;\r\n+\r\n+    /**\r\n+     * Constructor to set the member variables\r\n+     *\r\n+     * @param variable The variable's number\r\n+     * @param name The variable's name\r\n+     * @param group The variable's group\r\n+     * @param access Access possibilities\r\n+     * @param length Number of expected characters when writing to / reading from Modbus\r\n+     * @param count Exact number of characters to write to Modbus\r\n+     * @param type Variable type (string, integer or float)\r\n+     * @param unit Variable's unit\r\n+     * @param minVal Minimum value (only applicable for numeric values)\r\n+     * @param maxVal Maximum value (only applicable for numeric values)\r\n+     */\r\n+    public HeliosVariable(int variable, String name, @Nullable String group, String access, int length, int count,\r\n+            String type, @Nullable String unit, @Nullable Double minVal, @Nullable Double maxVal) {\r\n+        this.variable = variable;\r\n+        this.name = name;\r\n+        this.group = group;\r\n+        this.access = access;\r\n+        this.length = length;\r\n+        this.count = count;\r\n+        this.type = type;\r\n+        this.unit = unit;\r\n+        this.minVal = minVal;\r\n+        this.maxVal = maxVal;\r\n+    }\r\n+\r\n+    /**\r\n+     * Constructor to set the member variables\r\n+     *\r\n+     * @param variable The variable's number\r\n+     * @param name The variable's name\r\n+     * @param group The variable's group\r\n+     * @param access Access possibilities\r\n+     * @param length Number of expected characters when writing to / reading from Modbus\r\n+     * @param count Exact number of characters to write to Modbus\r\n+     * @param type Variable type (string, integer or float)\r\n+     * @param unit Variable's unit\r\n+     */\r\n+    public HeliosVariable(int variable, String name, @Nullable String group, String access, int length, int count,\r\n+            String type, String unit) {\r\n+        this(variable, name, group, access, length, count, type, unit, null, null);\r\n+    }\r\n+\r\n+    /**\r\n+     * Constructor to set the member variables\r\n+     *\r\n+     * @param variable The variable's number\r\n+     * @param name The variable's name\r\n+     * @param group The variable's group\r\n+     * @param access Access possibilities\r\n+     * @param length Number of expected characters when writing to / reading from Modbus\r\n+     * @param count Exact number of characters to write to Modbus\r\n+     * @param type Variable type (string, integer or float)\r\n+     */\r\n+    public HeliosVariable(int variable, String name, @Nullable String group, String access, int length, int count,\r\n+            String type) {\r\n+        this(variable, name, group, access, length, count, type, null, null, null);\r\n+    }\r\n+\r\n+    /**\r\n+     * Getter for variable\r\n+     *\r\n+     * @return variable\r\n+     */\r\n+    public int getVariable() {\r\n+        return this.variable;\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns a formatted string representation for the variable\r\n+     *\r\n+     * @return String The string representation for the variable (e.g. 'v00020' for variable number 20)\r\n+     */\r\n+    public String getVariableString() {\r\n+        String v = Integer.toString(this.variable);\r\n+        while (v.length() < 5) {\r\n+            v = '0' + v;\r\n+        }\r\n+        v = 'v' + v;\r\n+        return v;\r\n+    }\r\n+\r\n+    /**\r\n+     * Setter for name\r\n+     *\r\n+     */\r\n+    public void setName(String name) {\r\n+        this.name = name;\r\n+    }\r\n+\r\n+    /**\r\n+     * Getter for name\r\n+     *\r\n+     * @return name\r\n+     */\r\n+    public String getName() {\r\n+        return this.name;\r\n+    }\r\n+\r\n+    /**\r\n+     * Getter for group\r\n+     *\r\n+     * @return group\r\n+     */\r\n+    public @Nullable String getGroup() {\r\n+        return this.group;\r\n+    }\r\n+\r\n+    /**\r\n+     * Getter for access\r\n+     *\r\n+     * @return access\r\n+     */\r\n+    public String getAccess() {\r\n+        return this.access;\r\n+    }\r\n+\r\n+    /**\r\n+     * Getter for length\r\n+     *\r\n+     * @return length\r\n+     */\r\n+    public int getLength() {\r\n+        return this.length;\r\n+    }\r\n+\r\n+    /**\r\n+     * Getter for count\r\n+     *\r\n+     * @return count\r\n+     */\r\n+    public int getCount() {\r\n+        return this.count;\r\n+    }\r\n+\r\n+    /**\r\n+     * Getter for the type\r\n+     */\r\n+    public String getType() {\r\n+        return this.type;\r\n+    }\r\n+\r\n+    /**\r\n+     * Getter for the unit\r\n+     */\r\n+    public @Nullable String getUnit() {\r\n+        return this.unit;\r\n+    }\r\n+\r\n+    /**\r\n+     * Getter for minimum value\r\n+     *\r\n+     * @return minimum value\r\n+     */\r\n+    public @Nullable Double getMinVal() {\r\n+        return this.minVal;\r\n+    }\r\n+\r\n+    /**\r\n+     * Getter for maximum value\r\n+     *\r\n+     * @return maximum value\r\n+     */\r\n+    public @Nullable Double getMaxVal() {\r\n+        return this.maxVal;\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns the variable's name and prefixes the group, separated by a # if available\r\n+     *\r\n+     * @return the variable's name and prefixes the group, separated by a # if available\r\n+     */\r\n+    public String getGroupAndName() {\r\n+        return this.group != null ? this.group + \"#\" + this.name : this.name;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks if the variable's data are consistent\r\n+     *\r\n+     * @return true if the variable contains consistent data\r\n+     */\r\n+    public boolean isOk() {\r\n+        boolean check;\r\n+\r\n+        // this.access has one of the allowed values\r\n+        check = (this.access.equals(HeliosVariable.ACCESS_R)) || (this.access.equals(HeliosVariable.ACCESS_W))\r\n+                || (this.access.equals(HeliosVariable.ACCESS_RW));\r\n+\r\n+        // this.type has one of the allowed values\r\n+        check = check && ((this.type.equals(HeliosVariable.TYPE_STRING))\r\n+                || (this.type.equals(HeliosVariable.TYPE_INTEGER)) || (this.type.equals(HeliosVariable.TYPE_FLOAT)));\r\n+\r\n+        // this.minValue and this.maxValue are either not set or minValue is less than maxValue\r\n+        check = check && (((this.minVal == null) && (this.maxVal == null)) || (this.minVal <= this.maxVal));\r\n+\r\n+        // length is set\r\n+        check = check && (this.length > 0);\r\n+\r\n+        // count is set\r\n+        check = check && (this.count > 0);\r\n+\r\n+        return check;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks if the variable has write access\r\n+     *\r\n+     * @return true if the variable has write access\r\n+     */\r\n+    public boolean hasWriteAccess() {\r\n+        return (this.access.equals(HeliosVariable.ACCESS_W)) || (this.access.equals(HeliosVariable.ACCESS_RW));\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks if the variable has read access\r\n+     *\r\n+     * @return true if the variable has read access\r\n+     */\r\n+    public boolean hasReadAccess() {\r\n+        return (this.access.equals(HeliosVariable.ACCESS_R)) || (this.access.equals(HeliosVariable.ACCESS_RW));\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks if the provided value is within the accepted range\r\n+     *\r\n+     * @param value The value as a string\r\n+     * @return true if the value is within the accepted range\r\n+     */\r\n+    public boolean isInAllowedRange(String value) {\r\n+        if ((this.getMinVal() != null) && (this.getMaxVal() != null)) { // min and max value are set\r\n+            try {\r\n+                if (this.type.equals(HeliosVariable.TYPE_INTEGER)) {\r\n+                    // using long becuase some variable are specified with a max of 2^32-1\r\n+                    // parsing double to allow floating point values to be processed as well\r\n+                    Long l = new Double(value).longValue();\r\n+                    return (this.getMinVal().longValue() <= l) && (this.getMaxVal().longValue() >= l);\r\n+                } else if (this.type.equals(HeliosVariable.TYPE_FLOAT)) {\r\n+                    Double d = Double.parseDouble(value);\r\n+                    return (this.getMinVal() <= d) && (this.getMaxVal() >= d);\r\n+                }\r\n+            } catch (Exception e) {\r\n+                return false;\r\n+            }\r\n+        } else {\r\n+            return true; // no range to check\r\n+        }\r\n+        return false;\r\n+    }\r\n+\r\n+    @Override\r\n+    public int compareTo(HeliosVariable v) {\r\n+        if (this.getVariable() < v.getVariable()) {\r\n+            return -1;\r\n+        } else if (this.getVariable() == v.getVariable()) {\r\n+            return 0;\r\n+        } else {\r\n+            return 1;\r\n+        }\r", "originalCommit": "a29484f182958feae2d73f3ac06490316afc5798", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5Njk0OA==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r484096948", "bodyText": "Well, that would be really elegant then... that's not quite my style ;)", "author": "bern77", "createdAt": "2020-09-06T17:50:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTgxNjk4Ng=="}], "type": "inlineReview"}, {"oid": "e9c1c1e632124fd9fc1fc05fd59e1f870c1f5919", "url": "https://github.com/openhab/openhab-addons/commit/e9c1c1e632124fd9fc1fc05fd59e1f870c1f5919", "message": "Changes based on @fwolter's review:\n\n- Introduction of Actions\n- Introduction of Properties\n- Combined item for system date+time\n- Combined items to set bypass period\n- Simplified structure of thing-types.xml\n- General code improvements\n\nSigned-off-by: Bernhard Bauer <bern77@gmail.com>", "committedDate": "2020-09-11T11:50:13Z", "type": "forcePushed"}, {"oid": "03a46c3665218ac3ea448a5cb225e50038dc9a6b", "url": "https://github.com/openhab/openhab-addons/commit/03a46c3665218ac3ea448a5cb225e50038dc9a6b", "message": "Changes based on @fwolter's review:\n\n- Introduction of Actions\n- Introduction of Properties\n- Combined item for system date+time\n- Combined items to set bypass period\n- Simplified structure of thing-types.xml\n- General code improvements\n\nSigned-off-by: Bernhard Bauer <bern77@gmail.com>\nSigned-off-by: Bernhard <bern77@gmail.com>", "committedDate": "2020-09-11T11:56:23Z", "type": "forcePushed"}, {"oid": "e60b053c866295e60197069999da93563850c182", "url": "https://github.com/openhab/openhab-addons/commit/e60b053c866295e60197069999da93563850c182", "message": "Small bugfix\n\nSigned-off-by: Bernhard Bauer <bern77@gmail.com>\nSigned-off-by: Bernhard <bern77@gmail.com>", "committedDate": "2020-09-11T18:24:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc3MTEwNA==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r487771104", "bodyText": "The scope should be the binding name.", "author": "fwolter", "createdAt": "2020-09-14T09:21:22Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsActions.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class provides the actions available for the Helios device\n+ *\n+ * @author Bernhard Bauer - Initial contribution\n+ */\n+@ThingActionsScope(name = \"helios-ventilation-easycontrols\")", "originalCommit": "265816de988695fb46c5a470145b22452d6038eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgwMjYwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r487802605", "bodyText": "Just to make sure I get it right - should I use modbus.helioseasycontrols or just helioseasycontrols?", "author": "bern77", "createdAt": "2020-09-14T10:14:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc3MTEwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgwNDM5OA==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r487804398", "bodyText": "I think it's better to add the modbus.", "author": "fwolter", "createdAt": "2020-09-14T10:17:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc3MTEwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc3NDQ4OA==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r487774488", "bodyText": "Closing the streams must be done in the finally clause to ensure they are closed also if an exception is raised. Or you could use Java's auto-closeable feature:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    try {\n          \n          \n            \n                        InputStreamReader jsonFile = new InputStreamReader(\n          \n          \n            \n                                getClass().getResourceAsStream(HeliosEasyControlsBindingConstants.VARIABLES_DEFINITION_FILE));\n          \n          \n            \n                        BufferedReader reader = new BufferedReader(jsonFile);\n          \n          \n            \n                        this.variableMap = gson.fromJson(reader, vMapType);\n          \n          \n            \n                        reader.close();\n          \n          \n            \n                        jsonFile.close();\n          \n          \n            \n                    try (InputStreamReader jsonFile = new InputStreamReader(\n          \n          \n            \n                            getClass().getResourceAsStream(HeliosEasyControlsBindingConstants.VARIABLES_DEFINITION_FILE));\n          \n          \n            \n                            BufferedReader reader = new BufferedReader(jsonFile)) {\n          \n          \n            \n                        this.variableMap = gson.fromJson(reader, vMapType);", "author": "fwolter", "createdAt": "2020-09-14T09:27:02Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,805 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.IOException;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.nio.charset.StandardCharsets;\r\n+import java.time.ZoneId;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Collection;\r\n+import java.util.Collections;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.QuantityType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\r\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.eclipse.smarthome.core.types.State;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+@NonNullByDefault\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    private @Nullable HeliosEasyControlsConfiguration config;\r\n+\r\n+    private @Nullable ScheduledFuture<?> pollingJob;\r\n+\r\n+    private @Nullable Map<String, HeliosVariable> variableMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private Map<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<>();\r\n+\r\n+    private Gson gson = new Gson();\r\n+\r\n+    private @Nullable ModbusCommunicationInterface comms;\r\n+\r\n+    private int dateFormat = -1;\r\n+    private ZonedDateTime sysDate = ZonedDateTime.now(); // initialize with local system time as a best guess\r\n+                                                         // before reading from device\r\n+\r\n+    private class BypassDate {\r\n+        // initialization to avoid issues when updating before all variables were read\r\n+        private int month = 1;\r\n+        private int day = 1;\r\n+\r\n+        public void setMonth(int month) {\r\n+            this.month = month;\r\n+        }\r\n+\r\n+        public void setDay(int day) {\r\n+            this.day = day;\r\n+        }\r\n+\r\n+        public DateTimeType toDateTimeType() {\r\n+            return new DateTimeType(ZonedDateTime.of(1900, this.month, this.day, 0, 0, 0, 0, ZoneId.of(\"UTC+00:00\")));\r\n+        }\r\n+    }\r\n+\r\n+    private @Nullable BypassDate bypassFrom, bypassTo;\r\n+\r\n+    public HeliosEasyControlsHandler(Thing thing) {\r\n+        super(thing);\r\n+    }\r\n+\r\n+    /**\r\n+     * Reads variable definitions from JSON file and store them in variableMap\r\n+     */\r\n+    private void readVariableDefinition() {\r\n+        Type vMapType = new TypeToken<Map<String, HeliosVariable>>() {\r\n+        }.getType();\r\n+        try {\r\n+            InputStreamReader jsonFile = new InputStreamReader(\r\n+                    getClass().getResourceAsStream(HeliosEasyControlsBindingConstants.VARIABLES_DEFINITION_FILE));\r\n+            BufferedReader reader = new BufferedReader(jsonFile);\r\n+            this.variableMap = gson.fromJson(reader, vMapType);\r\n+            reader.close();\r\n+            jsonFile.close();\r", "originalCommit": "265816de988695fb46c5a470145b22452d6038eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc3OTU2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r487779561", "bodyText": "Can this be removed?", "author": "fwolter", "createdAt": "2020-09-14T09:35:53Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,805 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.IOException;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.nio.charset.StandardCharsets;\r\n+import java.time.ZoneId;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Collection;\r\n+import java.util.Collections;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.QuantityType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\r\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.eclipse.smarthome.core.types.State;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+@NonNullByDefault\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    private @Nullable HeliosEasyControlsConfiguration config;\r\n+\r\n+    private @Nullable ScheduledFuture<?> pollingJob;\r\n+\r\n+    private @Nullable Map<String, HeliosVariable> variableMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private Map<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<>();\r\n+\r\n+    private Gson gson = new Gson();\r\n+\r\n+    private @Nullable ModbusCommunicationInterface comms;\r\n+\r\n+    private int dateFormat = -1;\r\n+    private ZonedDateTime sysDate = ZonedDateTime.now(); // initialize with local system time as a best guess\r\n+                                                         // before reading from device\r\n+\r\n+    private class BypassDate {\r\n+        // initialization to avoid issues when updating before all variables were read\r\n+        private int month = 1;\r\n+        private int day = 1;\r\n+\r\n+        public void setMonth(int month) {\r\n+            this.month = month;\r\n+        }\r\n+\r\n+        public void setDay(int day) {\r\n+            this.day = day;\r\n+        }\r\n+\r\n+        public DateTimeType toDateTimeType() {\r\n+            return new DateTimeType(ZonedDateTime.of(1900, this.month, this.day, 0, 0, 0, 0, ZoneId.of(\"UTC+00:00\")));\r\n+        }\r\n+    }\r\n+\r\n+    private @Nullable BypassDate bypassFrom, bypassTo;\r\n+\r\n+    public HeliosEasyControlsHandler(Thing thing) {\r\n+        super(thing);\r\n+    }\r\n+\r\n+    /**\r\n+     * Reads variable definitions from JSON file and store them in variableMap\r\n+     */\r\n+    private void readVariableDefinition() {\r\n+        Type vMapType = new TypeToken<Map<String, HeliosVariable>>() {\r\n+        }.getType();\r\n+        try {\r\n+            InputStreamReader jsonFile = new InputStreamReader(\r\n+                    getClass().getResourceAsStream(HeliosEasyControlsBindingConstants.VARIABLES_DEFINITION_FILE));\r\n+            BufferedReader reader = new BufferedReader(jsonFile);\r\n+            this.variableMap = gson.fromJson(reader, vMapType);\r\n+            reader.close();\r\n+            jsonFile.close();\r\n+        } catch (IOException e) {\r\n+            this.handleError(\"Error reading variable definition file\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+        }\r\n+        if (variableMap != null) {\r\n+            // add the name to the variable itself\r\n+            for (Map.Entry<String, HeliosVariable> entry : this.variableMap.entrySet()) {\r\n+                entry.getValue().setName(entry.getKey()); // workaround to set the variable name inside the\r\n+                                                          // HeliosVariable object\r\n+                if (!entry.getValue().isOk()) {\r\n+                    this.handleError(\"Variables definition file contains inconsistent data\",\r\n+                            ThingStatusDetail.CONFIGURATION_ERROR);\r\n+                }\r\n+            }\r\n+        } else {\r\n+            this.handleError(\"Variables definition file not found or of illegal format\",\r\n+                    ThingStatusDetail.CONFIGURATION_ERROR);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the endpoint handler from the bridge this handler is connected to\r\n+     * Checks that we're connected to the right type of bridge\r\n+     *\r\n+     * @return the endpoint handler or null if the bridge does not exist\r\n+     */\r\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\r\n+        Bridge bridge = getBridge();\r\n+        if (bridge == null) {\r\n+            logger.debug(\"Bridge is null\");\r\n+            return null;\r\n+        }\r\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\r\n+            logger.debug(\"Bridge is not online\");\r\n+            return null;\r\n+        }\r\n+\r\n+        ThingHandler handler = bridge.getHandler();\r\n+        if (handler == null) {\r\n+            logger.debug(\"Bridge handler is null\");\r\n+            return null;\r\n+        }\r\n+\r\n+        if (handler instanceof ModbusEndpointThingHandler) {\r\n+            return (ModbusEndpointThingHandler) handler;\r\n+        } else {\r\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\r\n+            return null;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get a reference to the modbus endpoint\r\n+     */\r\n+    private void connectEndpoint() {\r\n+        if (this.comms != null) {\r\n+            return;\r\n+        }\r\n+\r\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\r\n+        if (slaveEndpointThingHandler == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' is offline\", label));\r\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\r\n+            return;\r\n+        }\r\n+\r\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\r\n+\r\n+        if (comms == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\r\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\r\n+            return;\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void initialize() {\r\n+        this.config = getConfigAs(HeliosEasyControlsConfiguration.class);\r\n+        this.readVariableDefinition();\r\n+        this.connectEndpoint();\r\n+        if ((this.comms != null) && (this.variableMap != null) && (this.config != null)) {\r\n+            this.transactionLocks.putIfAbsent(this.comms.getEndpoint(), new Semaphore(1, true));\r\n+            updateStatus(ThingStatus.UNKNOWN);\r\n+\r\n+            // background initialization\r\n+            scheduler.execute(() -> {\r\n+                readValue(HeliosEasyControlsBindingConstants.DATE_FORMAT);\r\n+                // status will be updated to ONLINE by the read callback function (via processResponse)\r\n+            });\r\n+\r\n+            // poll for status updates regularly\r\n+            HeliosEasyControlsConfiguration config = this.config;\r\n+            if (config != null) {\r\n+                this.pollingJob = scheduler.scheduleWithFixedDelay(() -> {\r\n+                    if (variableMap != null) {\r\n+                        for (Map.Entry<String, HeliosVariable> entry : variableMap.entrySet()) {\r\n+                            if (this.isProperty(entry.getKey()) || isLinked(entry.getValue().getGroupAndName())\r\n+                                    || HeliosEasyControlsBindingConstants.ALWAYS_UPDATE_VARIABLES\r\n+                                            .contains(entry.getKey())) {\r\n+                                readValue(entry.getKey());\r\n+                            }\r\n+                        }\r\n+                    } else {\r\n+                        handleError(\"Variable definition is null\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+                    }\r\n+                }, config.getRefreshInterval(), config.getRefreshInterval(), TimeUnit.MILLISECONDS);\r\n+            }\r\n+        } else { // at least one null assertion has failed, let's log the problem and update the thing status\r\n+            if (this.comms == null) {\r\n+                this.handleError(\"Modbus communication interface is unavailable\",\r\n+                        ThingStatusDetail.COMMUNICATION_ERROR);\r\n+            }\r\n+            if (this.variableMap == null) {\r\n+                this.handleError(\"Variable definition is unavailable\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            }\r\n+            if (this.config == null) {\r\n+                this.handleError(\"Binding configuration is unavailable\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void dispose() {\r\n+        if (this.pollingJob != null) {\r\n+            this.pollingJob.cancel(true);\r\n+        }\r\n+        this.comms = null;\r\n+    }\r\n+\r\n+    @Override\r\n+    public void handleCommand(ChannelUID channelUID, Command command) {\r\n+        String channelId = channelUID.getIdWithoutGroup();\r\n+        if (command instanceof RefreshType) {\r\n+            if (channelId.equals(HeliosEasyControlsBindingConstants.SYS_DATE)) {\r\n+                scheduler.submit(() -> readValue(HeliosEasyControlsBindingConstants.DATE));\r\n+                scheduler.submit(() -> readValue(HeliosEasyControlsBindingConstants.TIME));\r\n+            } else if (channelId.equals(HeliosEasyControlsBindingConstants.BYPASS_FROM)) {\r\n+                scheduler.submit(() -> readValue(HeliosEasyControlsBindingConstants.BYPASS_FROM_DAY));\r\n+                scheduler.submit(() -> readValue(HeliosEasyControlsBindingConstants.BYPASS_FROM_MONTH));\r\n+            } else if (channelId.equals(HeliosEasyControlsBindingConstants.BYPASS_TO)) {\r\n+                scheduler.submit(() -> readValue(HeliosEasyControlsBindingConstants.BYPASS_TO_DAY));\r\n+                scheduler.submit(() -> readValue(HeliosEasyControlsBindingConstants.BYPASS_TO_MONTH));\r\n+            } else {\r\n+                scheduler.submit(() -> readValue(channelId));\r\n+            }\r\n+        } else { // write command\r\n+            String value = null;\r\n+            if (command instanceof OnOffType) {\r\n+                value = command == OnOffType.ON ? \"1\" : \"0\";\r\n+            } else if (command instanceof DateTimeType) {\r\n+                ZonedDateTime d = ((DateTimeType) command).getZonedDateTime();\r\n+                if (channelId.equals(HeliosEasyControlsBindingConstants.SYS_DATE)) {\r\n+                    setSysDateTime(d);\r\n+                } else if (channelId.equals(HeliosEasyControlsBindingConstants.BYPASS_FROM)) {\r\n+                    this.setBypass(true, d.getDayOfMonth(), d.getMonthValue());\r\n+                } else if (channelId.equals(HeliosEasyControlsBindingConstants.BYPASS_TO)) {\r\n+                    this.setBypass(false, d.getDayOfMonth(), d.getMonthValue());\r\n+                } else {\r\n+                    value = formatDate(channelId, ((DateTimeType) command).getZonedDateTime());\r\n+                }\r\n+            } else if ((command instanceof DecimalType) || (command instanceof StringType)) {\r\n+                value = command.toString();\r\n+            } else if (command instanceof QuantityType<?>) {\r\n+                // convert item's unit to the Helios device's unit\r\n+                Map<String, HeliosVariable> variableMap = this.variableMap;\r\n+                if (variableMap != null) {\r\n+                    String unit = variableMap.get(channelId).getUnit();\r\n+                    QuantityType<?> val = (QuantityType<?>) command;\r\n+                    if (unit != null) {\r\n+                        if (unit.equals(HeliosVariable.UNIT_DAY)) {\r\n+                            val = val.toUnit(SmartHomeUnits.DAY);\r\n+                        } else if (unit.equals(HeliosVariable.UNIT_HOUR)) {\r\n+                            val = val.toUnit(SmartHomeUnits.HOUR);\r\n+                        } else if (unit.equals(HeliosVariable.UNIT_MIN)) {\r\n+                            val = val.toUnit(SmartHomeUnits.MINUTE);\r\n+                        } else if (unit.equals(HeliosVariable.UNIT_SEC)) {\r\n+                            val = val.toUnit(SmartHomeUnits.SECOND);\r\n+                        } else if (unit.equals(HeliosVariable.UNIT_VOLT)) {\r\n+                            val = val.toUnit(SmartHomeUnits.VOLT);\r\n+                        } else if (unit.equals(HeliosVariable.UNIT_PERCENT)) {\r\n+                            val = val.toUnit(SmartHomeUnits.PERCENT);\r\n+                        } else if (unit.equals(HeliosVariable.UNIT_PPM)) {\r\n+                            val = val.toUnit(SmartHomeUnits.PARTS_PER_MILLION);\r\n+                        } else if (unit.equals(HeliosVariable.UNIT_TEMP)) {\r\n+                            val = val.toUnit(SIUnits.CELSIUS);\r\n+                        }\r\n+                        value = val != null ? String.valueOf(val.doubleValue()) : null; // ignore the UoM\r\n+                    }\r\n+                }\r\n+            }\r\n+            if (value != null) {\r\n+                final String v = value;\r\n+                scheduler.submit(() -> {\r\n+                    try {\r\n+                        writeValue(channelId, v);\r\n+                        if (variableMap != null) {\r\n+                            updateState(variableMap.get(channelId), v);\r\n+                            updateStatus(ThingStatus.ONLINE);\r\n+                        }\r\n+                    } catch (HeliosException e) {\r\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\r\n+                                \"Writing value \" + v + \"to channel \" + channelId + \" failed: \" + e.getMessage());\r\n+                    }\r\n+                });\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\r\n+        return Collections.singleton(HeliosEasyControlsActions.class);\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks if the provided variable name is a property\r\n+     *\r\n+     * @param variableName The variable's name\r\n+     * @return true if the variable is a property\r\n+     */\r\n+    private boolean isProperty(String variableName) {\r\n+        return HeliosEasyControlsBindingConstants.PROPERTY_NAMES.contains(variableName);\r\n+    }\r\n+\r\n+    /**\r\n+     * Writes a variable value to the Helios device\r\n+     *\r\n+     * @param variableName The variable name\r\n+     * @param value The new value\r\n+     * @return The value if the transaction succeeded, <tt>null</tt> otherwise\r\n+     * @throws HeliosException Thrown if the variable is read-only or the provided value is out of range\r\n+     */\r\n+    public void writeValue(String variableName, String value) throws HeliosException {\r\n+        if (this.variableMap == null) {\r\n+            this.handleError(\"Variable definition is unavailable.\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            return;\r\n+        } else {\r\n+            Map<String, HeliosVariable> variableMap = this.variableMap;\r\n+            if (variableMap != null) {\r\n+                HeliosVariable v = variableMap.get(variableName);\r\n+\r\n+                if (!v.hasWriteAccess()) {\r\n+                    throw new HeliosException(\"Variable \" + variableName + \" is read-only\");\r\n+                } else if (!v.isInAllowedRange(value)) {\r\n+                    throw new HeliosException(\r\n+                            \"Value \" + value + \" is outside of allowed range of variable \" + variableName);\r\n+                } else if (this.comms != null) {\r\n+                    // write to device\r\n+                    String payload = v.getVariableString() + \"=\" + value;\r\n+                    ModbusCommunicationInterface comms = this.comms;\r\n+                    if (comms != null) {\r\n+                        final Semaphore lock = transactionLocks.get(comms.getEndpoint());\r\n+                        try {\r\n+                            lock.acquire();\r\n+                            comms.submitOneTimeWrite(\r\n+                                    new ModbusWriteRegisterRequestBlueprint(HeliosEasyControlsBindingConstants.UNIT_ID,\r\n+                                            HeliosEasyControlsBindingConstants.START_ADDRESS,\r\n+                                            new ModbusRegisterArray(preparePayload(payload)), true,\r\n+                                            HeliosEasyControlsBindingConstants.MAX_TRIES),\r\n+                                    result -> {\r\n+                                        lock.release();\r\n+                                        updateStatus(ThingStatus.ONLINE);\r\n+                                    }, failureInfo -> {\r\n+                                        lock.release();\r\n+                                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\r\n+                                                \"Error writing to device: \" + failureInfo.getCause().getMessage());\r\n+                                    });\r\n+                        } catch (InterruptedException e) {\r\n+                            logger.warn(\r\n+                                    \"{} encountered Exception when trying to lock Semaphore for writing variable {} to the device: {}\",\r\n+                                    HeliosEasyControlsHandler.class.getSimpleName(), variableName, e.getMessage());\r\n+                        }\r\n+                    }\r\n+                } else { // comms is null\r\n+                    this.handleError(\"Modbus communication interface is null\", ThingStatusDetail.COMMUNICATION_ERROR);\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Read a variable from the Helios device\r\n+     *\r\n+     * @param variableName The variable name\r\n+     * @return The value\r\n+     */\r\n+    public void readValue(String variableName) {\r\n+        Map<String, HeliosVariable> variableMap = this.variableMap;\r\n+        ModbusCommunicationInterface comms = this.comms;\r\n+        if ((comms != null) && (variableMap != null)) {\r\n+            final Semaphore lock = transactionLocks.get(comms.getEndpoint());\r\n+            HeliosVariable v = variableMap.get(variableName);\r\n+            if (v.hasReadAccess()) {\r\n+                try {\r\n+                    lock.acquire(); // will block until lock is available\r\n+                } catch (InterruptedException e) {\r\n+                    logger.warn(\"{} encountered Exception when trying to read variable {} from the device: {}\",\r\n+                            HeliosEasyControlsHandler.class.getSimpleName(), variableName, e.getMessage());\r\n+                    return;\r\n+                }\r\n+                // write variable name to register\r\n+                String payload = v.getVariableString();\r\n+                comms.submitOneTimeWrite(new ModbusWriteRegisterRequestBlueprint(\r\n+                        HeliosEasyControlsBindingConstants.UNIT_ID, HeliosEasyControlsBindingConstants.START_ADDRESS,\r\n+                        new ModbusRegisterArray(preparePayload(payload)), true,\r\n+                        HeliosEasyControlsBindingConstants.MAX_TRIES), result -> {\r\n+                            comms.submitOneTimePoll(\r\n+                                    new ModbusReadRequestBlueprint(HeliosEasyControlsBindingConstants.UNIT_ID,\r\n+                                            ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS,\r\n+                                            HeliosEasyControlsBindingConstants.START_ADDRESS, v.getCount(),\r\n+                                            HeliosEasyControlsBindingConstants.MAX_TRIES),\r\n+                                    pollResult -> {\r\n+                                        lock.release();\r\n+                                        Optional<ModbusRegisterArray> registers = pollResult.getRegisters();\r\n+                                        if (registers.isPresent()) {\r\n+                                            processResponse(v, registers.get());\r\n+                                        }\r\n+                                    }, failureInfo -> {\r\n+                                        lock.release();\r\n+                                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\r\n+                                                \"Error reading from device: \" + failureInfo.getCause().getMessage());\r\n+                                    });\r\n+                        }, failureInfo -> {\r\n+                            lock.release();\r\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\r\n+                                    \"Error writing to device: \" + failureInfo.getCause().getMessage());\r\n+\r\n+                        });\r\n+            }\r\n+\r\n+        } else {\r\n+            if (this.comms == null) {\r\n+                this.handleError(\"Modbus communication interface is unavailable\",\r\n+                        ThingStatusDetail.COMMUNICATION_ERROR);\r\n+            }\r\n+            if (variableMap == null) {\r\n+                this.handleError(\"Variable definition is unavailable\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private void updateSysDate(DateTimeType dateTime) {\r\n+        this.updateSysDateTime(dateTime.getZonedDateTime(), true, sysDate.getOffset().getTotalSeconds() / 60 / 60);\r\n+    }\r\n+\r\n+    private void updateSysTime(DateTimeType dateTime) {\r\n+        this.updateSysDateTime(dateTime.getZonedDateTime(), false, sysDate.getOffset().getTotalSeconds() / 60 / 60);\r\n+    }\r\n+\r\n+    private void updateUtcOffset(int utcOffset) {\r\n+        this.updateSysDateTime(this.sysDate, true, sysDate.getOffset().getTotalSeconds() / 60 / 60);\r\n+    }\r\n+\r\n+    private void updateSysDateTime(ZonedDateTime dateTime, boolean updateDate, int utcOffset) {\r\n+        ZonedDateTime sysDate = this.sysDate;\r\n+        sysDate = ZonedDateTime.of(updateDate ? dateTime.getYear() : sysDate.getYear(),\r\n+                updateDate ? dateTime.getMonthValue() : sysDate.getMonthValue(),\r\n+                updateDate ? dateTime.getDayOfMonth() : sysDate.getDayOfMonth(),\r\n+                updateDate ? sysDate.getHour() : dateTime.getHour(),\r\n+                updateDate ? sysDate.getMinute() : dateTime.getMinute(),\r\n+                updateDate ? sysDate.getSecond() : dateTime.getSecond(), 0,\r\n+                ZoneId.of(\"UTC\" + (utcOffset >= 0 ? \"+\" : \"\") + String.format(\"%02d\", utcOffset) + \":00\"));\r\n+        updateState(\"general#\" + HeliosEasyControlsBindingConstants.SYS_DATE, new DateTimeType(sysDate));\r\n+        this.sysDate = sysDate;\r\n+    }\r\n+\r\n+    private void setSysDateTime(ZonedDateTime date) {\r\n+        try {\r\n+            this.writeValue(HeliosEasyControlsBindingConstants.DATE,\r\n+                    this.formatDate(HeliosEasyControlsBindingConstants.DATE, date));\r\n+            this.writeValue(HeliosEasyControlsBindingConstants.TIME,\r\n+                    date.getHour() + \":\" + date.getMinute() + \":\" + date.getSecond());\r\n+            this.writeValue(HeliosEasyControlsBindingConstants.TIME_ZONE_DIFFERENCE_TO_GMT,\r\n+                    Integer.toString(date.getOffset().getTotalSeconds() / 60 / 60));\r\n+        } catch (HeliosException e) {\r\n+            logger.warn(\"{} encountered Exception when trying to set system date: {}\",\r\n+                    HeliosEasyControlsHandler.class.getSimpleName(), e.getMessage());\r\n+        }\r\n+\r\n+    }\r\n+\r\n+    protected void setSysDateTime() {\r\n+        this.setSysDateTime(ZonedDateTime.now());\r\n+    }\r\n+\r\n+    private void updateBypass(boolean from, boolean month, int val) {\r\n+        BypassDate bypassDate = from ? this.bypassFrom : this.bypassTo;\r\n+        if (bypassDate == null) {\r\n+            bypassDate = new BypassDate();\r\n+        }\r\n+        if (month) {\r\n+            bypassDate.setMonth(val);\r\n+\r\n+        } else {\r\n+            bypassDate.setDay(val);\r\n+        }\r\n+        updateState(\"unitConfig#\" + (from ? HeliosEasyControlsBindingConstants.BYPASS_FROM\r\n+                : HeliosEasyControlsBindingConstants.BYPASS_TO), bypassDate.toDateTimeType());\r\n+        if (from) {\r\n+            this.bypassFrom = bypassDate;\r\n+\r\n+        } else {\r\n+            this.bypassTo = bypassDate;\r\n+        }\r\n+    }\r\n+\r\n+    protected void setBypass(boolean from, int day, int month) {\r\n+        try {\r\n+            this.writeValue(from ? HeliosEasyControlsBindingConstants.BYPASS_FROM_DAY\r\n+                    : HeliosEasyControlsBindingConstants.BYPASS_TO_DAY, Integer.toString(day));\r\n+            this.writeValue(from ? HeliosEasyControlsBindingConstants.BYPASS_FROM_MONTH\r\n+                    : HeliosEasyControlsBindingConstants.BYPASS_TO_MONTH, Integer.toString(month));\r\n+        } catch (HeliosException e) {\r\n+            logger.warn(\"{} encountered Exception when trying to set bypass period: {}\",\r\n+                    HeliosEasyControlsHandler.class.getSimpleName(), e.getMessage());\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Formats the provided date to a string in the device's configured date format\r\n+     *\r\n+     * @param variableName the variable name\r\n+     * @param date the date to be formatted\r\n+     * @return a string in the device's configured date format\r\n+     */\r\n+    public String formatDate(String variableName, ZonedDateTime date) {\r\n+        String y = Integer.toString(date.getYear());\r\n+        String m = Integer.toString(date.getMonthValue());\r\n+        if (m.length() == 1) {\r\n+            m = \"0\" + m;\r\n+        }\r\n+        String d = Integer.toString(date.getDayOfMonth());\r\n+        if (d.length() == 1) {\r\n+            d = \"0\" + d;\r\n+        }\r\n+        if (variableName.equals(HeliosEasyControlsBindingConstants.DATE)) { // fixed format for writing the system date\r\n+            return d + \".\" + m + \".\" + y;\r\n+        } else {\r\n+            switch (this.dateFormat) {\r\n+                case 0: // dd.mm.yyyy\r\n+                    return d + \".\" + m + \".\" + y;\r\n+                case 1: // mm.dd.yyyy\r\n+                    return m + \".\" + d + \".\" + y;\r\n+                case 2: // yyyy.mm.dd\r\n+                    return y + \".\" + m + \".\" + d;\r\n+                default:\r\n+                    return d + \".\" + m + \".\" + y;\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns a DateTimeType object based on the provided String and the device's configured date format\r\n+     *\r\n+     * @param date The date string read from the device\r\n+     * @return A DateTimeType object representing the date or time specified\r\n+     */\r\n+    private DateTimeType toDateTime(String date) {\r\n+        String[] dateTimeParts = null;\r\n+        String dateTime = date;\r\n+        dateTimeParts = date.split(\"\\\\.\"); // try to split date components\r\n+        if (dateTimeParts.length == 1) { // time\r\n+            return DateTimeType.valueOf(date);\r\n+        } else if (dateTimeParts.length == 3) { // date - we'll try the device's date format\r\n+            switch (this.dateFormat) {\r\n+                case 0: // dd.mm.yyyy\r\n+                    dateTime = dateTimeParts[2] + \"-\" + dateTimeParts[1] + \"-\" + dateTimeParts[0];\r\n+                    break;\r\n+                case 1: // mm.dd.yyyy\r\n+                    dateTime = dateTimeParts[2] + \"-\" + dateTimeParts[0] + \"-\" + dateTimeParts[1];\r\n+                    break;\r\n+                case 2: // yyyy.mm.dd\r\n+                    dateTime = dateTimeParts[0] + \"-\" + dateTimeParts[1] + \"-\" + dateTimeParts[2];\r\n+                    break;\r\n+                default:\r\n+                    dateTime = dateTimeParts[2] + \"-\" + dateTimeParts[1] + \"-\" + dateTimeParts[0];\r\n+                    break;\r\n+            }\r\n+            return DateTimeType.valueOf(dateTime);\r\n+        }\r\n+        // falling back to default date format (apparently using the configured format has failed)\r\n+        dateTime = dateTimeParts[2] + \"-\" + dateTimeParts[1] + \"-\" + dateTimeParts[0];\r\n+        return DateTimeType.valueOf(dateTime);\r\n+    }\r\n+\r\n+    private @Nullable QuantityType<?> toQuantityType(String value, @Nullable String unit) {\r\n+        if (unit == null) {\r\n+            return null;\r\n+        } else if (unit.equals(HeliosVariable.UNIT_DAY)) {\r\n+            return new QuantityType<>(Integer.parseInt(value), SmartHomeUnits.DAY);\r\n+        } else if (unit.equals(HeliosVariable.UNIT_HOUR)) {\r\n+            return new QuantityType<>(Integer.parseInt(value), SmartHomeUnits.HOUR);\r\n+        } else if (unit.equals(HeliosVariable.UNIT_MIN)) {\r\n+            return new QuantityType<>(Integer.parseInt(value), SmartHomeUnits.MINUTE);\r\n+        } else if (unit.equals(HeliosVariable.UNIT_SEC)) {\r\n+            return new QuantityType<>(Integer.parseInt(value), SmartHomeUnits.SECOND);\r\n+        } else if (unit.equals(HeliosVariable.UNIT_VOLT)) {\r\n+            return new QuantityType<>(Float.parseFloat(value), SmartHomeUnits.VOLT);\r\n+        } else if (unit.equals(HeliosVariable.UNIT_PERCENT)) {\r\n+            return new QuantityType<>(Float.parseFloat(value), SmartHomeUnits.PERCENT);\r\n+        } else if (unit.equals(HeliosVariable.UNIT_PPM)) {\r\n+            return new QuantityType<>(Float.parseFloat(value), SmartHomeUnits.PARTS_PER_MILLION);\r\n+        } else if (unit.equals(HeliosVariable.UNIT_TEMP)) {\r\n+            return new QuantityType<>(Float.parseFloat(value), SIUnits.CELSIUS);\r\n+        } else {\r\n+            return null;\r\n+        }\r\n+    }\r\n+\r\n+    // TODO: Set date, time and UTC delta together => also additional channel required\r\n+\r\n+    /**\r\n+     * Prepares the payload for the request\r\n+     *\r\n+     * @param payload The String representation of the payload\r\n+     * @return The Register representation of the payload\r\n+     */\r\n+    private ModbusRegister[] preparePayload(String payload) {\r\n+\r\n+        // determine number of registers\r\n+        int l = (payload.length() + 1) / 2; // +1 because we need to include at least one termination symbol 0x00\r\n+        if ((payload.length() + 1) % 2 != 0) {\r\n+            l++;\r\n+        }\r\n+\r\n+        ModbusRegister reg[] = new ModbusRegister[l];\r\n+        byte[] b = payload.getBytes();\r\n+        int ch = 0;\r\n+        for (int i = 0; i < reg.length; i++) {\r\n+            byte b1 = ch < b.length ? b[ch] : (byte) 0x00; // terminate with 0x00 if at the end of the payload\r\n+            ch++;\r\n+            byte b2 = ch < b.length ? b[ch] : (byte) 0x00;\r\n+            ch++;\r\n+            reg[i] = new ModbusRegister(b1, b2);\r\n+        }\r\n+        return reg;\r\n+    }\r\n+\r\n+    /**\r\n+     * Decodes the Helios device' response and updates the channel with the actual value of the variable\r\n+     *\r\n+     * @param response The registers received from the Helios device\r\n+     * @return The value or <tt>null</tt> if an error occurred\r\n+     */\r\n+    private void processResponse(HeliosVariable v, ModbusRegisterArray registers) {\r\n+        // decode response\r\n+        byte[] b = new byte[registers.size() * 2];\r\n+        int actSize = 0; // track the actual size of the usable array (excluding any 0x00\r\n+                         // characters)\r\n+        for (int i = 0; i < registers.size(); i++) {\r\n+            byte[] reg = registers.getRegister(i).getBytes();\r\n+            if (reg.length == 2) { // only add to the array if it's a usable character\r\n+                if (reg[0] != 0x00) {\r\n+                    b[actSize++] = reg[0];\r\n+                }\r\n+                if (reg[1] != 0x00) {\r\n+                    b[actSize++] = reg[1];\r\n+                }\r\n+            }\r\n+        }\r\n+        b = Arrays.copyOf(b, actSize); // before creating a string of it the array needs to be\r\n+                                       // truncated\r\n+        String r = new String(b, StandardCharsets.US_ASCII);\r\n+        String[] parts = r.split(\"=\", 2); // remove the part \"vXXXX=\" from the string\r\n+        // making sure we have a proper response and the response matches the requested variable\r\n+        if ((parts.length == 2) && (v.getVariableString().equals(parts[0]))) {\r\n+            if (this.isProperty(v.getName())) {\r\n+                try {\r\n+                    updateProperty(v.getName(), v.formatPropertyValue(parts[1]));\r\n+                } catch (HeliosException e) {\r\n+                    logger.warn(\"{} encountered Exception when trying to update property: {}\",\r\n+                            HeliosEasyControlsHandler.class.getSimpleName(), e.getMessage());\r\n+                }\r\n+            } else {\r\n+                this.updateState(v, parts[1]);\r\n+            }\r\n+        } else { // another variable was read\r\n+            logger.warn(\"{} tried to read value from variable {} and the result provided by the device was {}\",\r\n+                    HeliosEasyControlsHandler.class.getSimpleName(), v.getName(), r);\r\n+        }\r\n+    }\r\n+\r\n+    private void updateState(HeliosVariable v, String value) {\r\n+        String variableType = v.getType();\r\n+        // System date and time\r\n+        if (v.getName().equals(HeliosEasyControlsBindingConstants.DATE)) {\r\n+            this.updateSysDate(this.toDateTime(value));\r\n+        } else if (v.getName().equals(HeliosEasyControlsBindingConstants.TIME)) {\r\n+            this.updateSysTime(this.toDateTime(value));\r\n+        } else if (v.getName().equals(HeliosEasyControlsBindingConstants.TIME_ZONE_DIFFERENCE_TO_GMT)) {\r\n+            this.updateUtcOffset(Integer.parseInt(value));\r\n+            // Bypass\r\n+        } else if (v.getName().equals(HeliosEasyControlsBindingConstants.BYPASS_FROM_DAY)) {\r\n+            this.updateBypass(true, false, Integer.parseInt(value));\r\n+        } else if (v.getName().equals(HeliosEasyControlsBindingConstants.BYPASS_FROM_MONTH)) {\r\n+            this.updateBypass(true, true, Integer.parseInt(value));\r\n+        } else if (v.getName().equals(HeliosEasyControlsBindingConstants.BYPASS_TO_DAY)) {\r\n+            this.updateBypass(false, false, Integer.parseInt(value));\r\n+        } else if (v.getName().equals(HeliosEasyControlsBindingConstants.BYPASS_TO_MONTH)) {\r\n+            this.updateBypass(false, true, Integer.parseInt(value));\r\n+        } else {\r\n+            Channel channel = getThing().getChannel(v.getGroupAndName());\r\n+            String itemType;\r\n+            if (channel != null) {\r\n+                itemType = channel.getAcceptedItemType();\r\n+                if (itemType != null) {\r\n+                    if (itemType.startsWith(\"Number:\")) {\r\n+                        itemType = \"Number\";\r\n+                    }\r\n+                    switch (itemType) {\r\n+                        case \"Number\":\r\n+                            if (((variableType.equals(HeliosVariable.TYPE_INTEGER))\r\n+                                    || (variableType == HeliosVariable.TYPE_FLOAT)) && (!value.equals(\"-\"))) {\r\n+                                State state = null;\r\n+                                if (v.getUnit() == null) {\r\n+                                    state = DecimalType.valueOf(value);\r\n+                                } else { // QuantityType\r\n+                                    state = this.toQuantityType(value, v.getUnit());\r\n+                                }\r\n+                                if (state != null) {\r\n+                                    updateState(v.getGroupAndName(), state);\r\n+                                    updateStatus(ThingStatus.ONLINE);\r\n+                                    // update date format and UTC offset upon read\r\n+                                    if (v.getName().equals(HeliosEasyControlsBindingConstants.DATE_FORMAT)) {\r\n+                                        this.dateFormat = Integer.parseInt(value);\r\n+                                    }\r\n+                                }\r\n+                            }\r\n+                            break;\r\n+                        case \"Switch\":\r\n+                            if (variableType.equals(HeliosVariable.TYPE_INTEGER)) {\r\n+                                updateState(v.getGroupAndName(), value.equals(\"1\") ? OnOffType.ON : OnOffType.OFF);\r\n+                            }\r\n+                            break;\r\n+                        case \"String\":\r\n+                            if (variableType.equals(HeliosVariable.TYPE_STRING)) {\r\n+                                updateState(v.getGroupAndName(), StringType.valueOf(value));\r\n+                            }\r\n+                            break;\r\n+                        case \"DateTime\":\r\n+                            if (variableType.equals(HeliosVariable.TYPE_STRING)) {\r\n+                                updateState(v.getGroupAndName(), toDateTime(value));\r\n+                            }\r\n+                            break;\r\n+                    }\r\n+                } else { // itemType was null\r\n+                    logger.warn(\"{} couldn't determine item type of variable {}\",\r\n+                            HeliosEasyControlsHandler.class.getSimpleName(), v.getName());\r\n+                }\r\n+            } else { // channel was null\r\n+                logger.warn(\"{} couldn't find channel for variable {}\", HeliosEasyControlsHandler.class.getSimpleName(),\r\n+                        v.getName());\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Logs an error (as a warning entry) and updates the thing status\r\n+     *\r\n+     * @param errorMsg The error message to be logged and provided with the Thing's status update\r\n+     * @param status The Thing's new status\r\n+     */\r\n+    private void handleError(String errorMsg, ThingStatusDetail status) {\r\n+        // logger.warn(\"{}\", errorMsg);\r", "originalCommit": "265816de988695fb46c5a470145b22452d6038eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc4NTk4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r487785983", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\n          \n          \n            \n                private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsActions.class);", "author": "fwolter", "createdAt": "2020-09-14T09:46:55Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsActions.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class provides the actions available for the Helios device\n+ *\n+ * @author Bernhard Bauer - Initial contribution\n+ */\n+@ThingActionsScope(name = \"helios-ventilation-easycontrols\")\n+@NonNullByDefault\n+public class HeliosEasyControlsActions implements ThingActions {\n+\n+    private @Nullable HeliosEasyControlsHandler handler;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);", "originalCommit": "265816de988695fb46c5a470145b22452d6038eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d1576016145b13639a01c7a850f1e772fd2c155a", "url": "https://github.com/openhab/openhab-addons/commit/d1576016145b13639a01c7a850f1e772fd2c155a", "message": "Implementation of the inputs from todays's review.\n\nSigned-off-by: Bernhard Bauer <bern77@gmail.com>", "committedDate": "2020-09-14T10:30:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkzNzk2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r488937967", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Gson gson = new Gson();\n          \n          \n            \n                private final Gson gson = new Gson();", "author": "Hilbrand", "createdAt": "2020-09-15T19:58:37Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,798 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.IOException;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.nio.charset.StandardCharsets;\r\n+import java.time.ZoneId;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Collection;\r\n+import java.util.Collections;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.QuantityType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\r\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.eclipse.smarthome.core.types.State;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+@NonNullByDefault\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    private @Nullable HeliosEasyControlsConfiguration config;\r\n+\r\n+    private @Nullable ScheduledFuture<?> pollingJob;\r\n+\r\n+    private @Nullable Map<String, HeliosVariable> variableMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private Map<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<>();\r\n+\r\n+    private Gson gson = new Gson();\r", "originalCommit": "f5c6611b2a613ab45df34eb7ee960390f11e08cb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkzODMxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r488938311", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Map<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<>();\n          \n          \n            \n                private final Map<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<>();", "author": "Hilbrand", "createdAt": "2020-09-15T19:59:12Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,798 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.IOException;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.nio.charset.StandardCharsets;\r\n+import java.time.ZoneId;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Collection;\r\n+import java.util.Collections;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.QuantityType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\r\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.eclipse.smarthome.core.types.State;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+@NonNullByDefault\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    private @Nullable HeliosEasyControlsConfiguration config;\r\n+\r\n+    private @Nullable ScheduledFuture<?> pollingJob;\r\n+\r\n+    private @Nullable Map<String, HeliosVariable> variableMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private Map<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<>();\r", "originalCommit": "f5c6611b2a613ab45df34eb7ee960390f11e08cb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk0ODUzMw==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r488948533", "bodyText": "Can't this be a java switch statement? Same comment for the other large if-else blocks?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    if (unit.equals(HeliosVariable.UNIT_DAY)) {\n          \n          \n            \n                                    switch (unit) {\n          \n          \n            \n                                    case HeliosVariable.UNIT_DAY:\n          \n          \n            \n                                     ...", "author": "Hilbrand", "createdAt": "2020-09-15T20:19:11Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,798 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.IOException;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.nio.charset.StandardCharsets;\r\n+import java.time.ZoneId;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Collection;\r\n+import java.util.Collections;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.QuantityType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\r\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.eclipse.smarthome.core.types.State;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+@NonNullByDefault\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    private @Nullable HeliosEasyControlsConfiguration config;\r\n+\r\n+    private @Nullable ScheduledFuture<?> pollingJob;\r\n+\r\n+    private @Nullable Map<String, HeliosVariable> variableMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private Map<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<>();\r\n+\r\n+    private Gson gson = new Gson();\r\n+\r\n+    private @Nullable ModbusCommunicationInterface comms;\r\n+\r\n+    private int dateFormat = -1;\r\n+    private ZonedDateTime sysDate = ZonedDateTime.now(); // initialize with local system time as a best guess\r\n+                                                         // before reading from device\r\n+\r\n+    private class BypassDate {\r\n+        // initialization to avoid issues when updating before all variables were read\r\n+        private int month = 1;\r\n+        private int day = 1;\r\n+\r\n+        public void setMonth(int month) {\r\n+            this.month = month;\r\n+        }\r\n+\r\n+        public void setDay(int day) {\r\n+            this.day = day;\r\n+        }\r\n+\r\n+        public DateTimeType toDateTimeType() {\r\n+            return new DateTimeType(ZonedDateTime.of(1900, this.month, this.day, 0, 0, 0, 0, ZoneId.of(\"UTC+00:00\")));\r\n+        }\r\n+    }\r\n+\r\n+    private @Nullable BypassDate bypassFrom, bypassTo;\r\n+\r\n+    public HeliosEasyControlsHandler(Thing thing) {\r\n+        super(thing);\r\n+    }\r\n+\r\n+    /**\r\n+     * Reads variable definitions from JSON file and store them in variableMap\r\n+     */\r\n+    private void readVariableDefinition() {\r\n+        Type vMapType = new TypeToken<Map<String, HeliosVariable>>() {\r\n+        }.getType();\r\n+        try (InputStreamReader jsonFile = new InputStreamReader(\r\n+                getClass().getResourceAsStream(HeliosEasyControlsBindingConstants.VARIABLES_DEFINITION_FILE));\r\n+                BufferedReader reader = new BufferedReader(jsonFile)) {\r\n+            this.variableMap = gson.fromJson(reader, vMapType);\r\n+        } catch (IOException e) {\r\n+            this.handleError(\"Error reading variable definition file\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+        }\r\n+        if (variableMap != null) {\r\n+            // add the name to the variable itself\r\n+            for (Map.Entry<String, HeliosVariable> entry : this.variableMap.entrySet()) {\r\n+                entry.getValue().setName(entry.getKey()); // workaround to set the variable name inside the\r\n+                                                          // HeliosVariable object\r\n+                if (!entry.getValue().isOk()) {\r\n+                    this.handleError(\"Variables definition file contains inconsistent data\",\r\n+                            ThingStatusDetail.CONFIGURATION_ERROR);\r\n+                }\r\n+            }\r\n+        } else {\r\n+            this.handleError(\"Variables definition file not found or of illegal format\",\r\n+                    ThingStatusDetail.CONFIGURATION_ERROR);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the endpoint handler from the bridge this handler is connected to\r\n+     * Checks that we're connected to the right type of bridge\r\n+     *\r\n+     * @return the endpoint handler or null if the bridge does not exist\r\n+     */\r\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\r\n+        Bridge bridge = getBridge();\r\n+        if (bridge == null) {\r\n+            logger.debug(\"Bridge is null\");\r\n+            return null;\r\n+        }\r\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\r\n+            logger.debug(\"Bridge is not online\");\r\n+            return null;\r\n+        }\r\n+\r\n+        ThingHandler handler = bridge.getHandler();\r\n+        if (handler == null) {\r\n+            logger.debug(\"Bridge handler is null\");\r\n+            return null;\r\n+        }\r\n+\r\n+        if (handler instanceof ModbusEndpointThingHandler) {\r\n+            return (ModbusEndpointThingHandler) handler;\r\n+        } else {\r\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\r\n+            return null;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get a reference to the modbus endpoint\r\n+     */\r\n+    private void connectEndpoint() {\r\n+        if (this.comms != null) {\r\n+            return;\r\n+        }\r\n+\r\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\r\n+        if (slaveEndpointThingHandler == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' is offline\", label));\r\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\r\n+            return;\r\n+        }\r\n+\r\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\r\n+\r\n+        if (comms == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\r\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\r\n+            return;\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void initialize() {\r\n+        this.config = getConfigAs(HeliosEasyControlsConfiguration.class);\r\n+        this.readVariableDefinition();\r\n+        this.connectEndpoint();\r\n+        if ((this.comms != null) && (this.variableMap != null) && (this.config != null)) {\r\n+            this.transactionLocks.putIfAbsent(this.comms.getEndpoint(), new Semaphore(1, true));\r\n+            updateStatus(ThingStatus.UNKNOWN);\r\n+\r\n+            // background initialization\r\n+            scheduler.execute(() -> {\r\n+                readValue(HeliosEasyControlsBindingConstants.DATE_FORMAT);\r\n+                // status will be updated to ONLINE by the read callback function (via processResponse)\r\n+            });\r\n+\r\n+            // poll for status updates regularly\r\n+            HeliosEasyControlsConfiguration config = this.config;\r\n+            if (config != null) {\r\n+                this.pollingJob = scheduler.scheduleWithFixedDelay(() -> {\r\n+                    if (variableMap != null) {\r\n+                        for (Map.Entry<String, HeliosVariable> entry : variableMap.entrySet()) {\r\n+                            if (this.isProperty(entry.getKey()) || isLinked(entry.getValue().getGroupAndName())\r\n+                                    || HeliosEasyControlsBindingConstants.ALWAYS_UPDATE_VARIABLES\r\n+                                            .contains(entry.getKey())) {\r\n+                                readValue(entry.getKey());\r\n+                            }\r\n+                        }\r\n+                    } else {\r\n+                        handleError(\"Variable definition is null\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+                    }\r\n+                }, config.getRefreshInterval(), config.getRefreshInterval(), TimeUnit.MILLISECONDS);\r\n+            }\r\n+        } else { // at least one null assertion has failed, let's log the problem and update the thing status\r\n+            if (this.comms == null) {\r\n+                this.handleError(\"Modbus communication interface is unavailable\",\r\n+                        ThingStatusDetail.COMMUNICATION_ERROR);\r\n+            }\r\n+            if (this.variableMap == null) {\r\n+                this.handleError(\"Variable definition is unavailable\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            }\r\n+            if (this.config == null) {\r\n+                this.handleError(\"Binding configuration is unavailable\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void dispose() {\r\n+        if (this.pollingJob != null) {\r\n+            this.pollingJob.cancel(true);\r\n+        }\r\n+        this.comms = null;\r\n+    }\r\n+\r\n+    @Override\r\n+    public void handleCommand(ChannelUID channelUID, Command command) {\r\n+        String channelId = channelUID.getIdWithoutGroup();\r\n+        if (command instanceof RefreshType) {\r\n+            if (channelId.equals(HeliosEasyControlsBindingConstants.SYS_DATE)) {\r\n+                scheduler.submit(() -> readValue(HeliosEasyControlsBindingConstants.DATE));\r\n+                scheduler.submit(() -> readValue(HeliosEasyControlsBindingConstants.TIME));\r\n+            } else if (channelId.equals(HeliosEasyControlsBindingConstants.BYPASS_FROM)) {\r\n+                scheduler.submit(() -> readValue(HeliosEasyControlsBindingConstants.BYPASS_FROM_DAY));\r\n+                scheduler.submit(() -> readValue(HeliosEasyControlsBindingConstants.BYPASS_FROM_MONTH));\r\n+            } else if (channelId.equals(HeliosEasyControlsBindingConstants.BYPASS_TO)) {\r\n+                scheduler.submit(() -> readValue(HeliosEasyControlsBindingConstants.BYPASS_TO_DAY));\r\n+                scheduler.submit(() -> readValue(HeliosEasyControlsBindingConstants.BYPASS_TO_MONTH));\r\n+            } else {\r\n+                scheduler.submit(() -> readValue(channelId));\r\n+            }\r\n+        } else { // write command\r\n+            String value = null;\r\n+            if (command instanceof OnOffType) {\r\n+                value = command == OnOffType.ON ? \"1\" : \"0\";\r\n+            } else if (command instanceof DateTimeType) {\r\n+                ZonedDateTime d = ((DateTimeType) command).getZonedDateTime();\r\n+                if (channelId.equals(HeliosEasyControlsBindingConstants.SYS_DATE)) {\r\n+                    setSysDateTime(d);\r\n+                } else if (channelId.equals(HeliosEasyControlsBindingConstants.BYPASS_FROM)) {\r\n+                    this.setBypass(true, d.getDayOfMonth(), d.getMonthValue());\r\n+                } else if (channelId.equals(HeliosEasyControlsBindingConstants.BYPASS_TO)) {\r\n+                    this.setBypass(false, d.getDayOfMonth(), d.getMonthValue());\r\n+                } else {\r\n+                    value = formatDate(channelId, ((DateTimeType) command).getZonedDateTime());\r\n+                }\r\n+            } else if ((command instanceof DecimalType) || (command instanceof StringType)) {\r\n+                value = command.toString();\r\n+            } else if (command instanceof QuantityType<?>) {\r\n+                // convert item's unit to the Helios device's unit\r\n+                Map<String, HeliosVariable> variableMap = this.variableMap;\r\n+                if (variableMap != null) {\r\n+                    String unit = variableMap.get(channelId).getUnit();\r\n+                    QuantityType<?> val = (QuantityType<?>) command;\r\n+                    if (unit != null) {\r\n+                        if (unit.equals(HeliosVariable.UNIT_DAY)) {\r", "originalCommit": "f5c6611b2a613ab45df34eb7ee960390f11e08cb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "90a7bd47f21cb33ee852608a39d853104b21ab55", "url": "https://github.com/openhab/openhab-addons/commit/90a7bd47f21cb33ee852608a39d853104b21ab55", "message": "Moved variables.json to resources\n\nSigned-off-by: Bernhard Bauer <bern77@gmail.com>", "committedDate": "2020-09-16T19:04:01Z", "type": "forcePushed"}, {"oid": "f3cb2cd99a0d37e3b685c505d4fc100fe790d407", "url": "https://github.com/openhab/openhab-addons/commit/f3cb2cd99a0d37e3b685c505d4fc100fe790d407", "message": "Merge branch '2.5.x' of https://github.com/bern77/openhab-addons into 2.5.x\n\nSigned-off-by: Bernhard Bauer <bern77@gmail.com>", "committedDate": "2020-09-16T19:39:26Z", "type": "forcePushed"}, {"oid": "1510a300b1378cb013614da5ac644db926583a69", "url": "https://github.com/openhab/openhab-addons/commit/1510a300b1378cb013614da5ac644db926583a69", "message": "Another stab at fixing the pom.xml files\n\nSigned-off-by: Bernhard Bauer <bern77@gmail.com>", "committedDate": "2020-09-16T19:53:41Z", "type": "forcePushed"}, {"oid": "4d3ecd1fce9b3b8997195c3ff8b0543ad26a6ebf", "url": "https://github.com/openhab/openhab-addons/commit/4d3ecd1fce9b3b8997195c3ff8b0543ad26a6ebf", "message": "Another stab at fixing the pom.xml files\n\nSigned-off-by: Bernhard Bauer <bern77@gmail.com>", "committedDate": "2020-09-16T19:59:29Z", "type": "forcePushed"}, {"oid": "90a7bd47f21cb33ee852608a39d853104b21ab55", "url": "https://github.com/openhab/openhab-addons/commit/90a7bd47f21cb33ee852608a39d853104b21ab55", "message": "Moved variables.json to resources\n\nSigned-off-by: Bernhard Bauer <bern77@gmail.com>", "committedDate": "2020-09-16T19:04:01Z", "type": "forcePushed"}, {"oid": "25a80a60aac5f72bf7a5cea7cba54cc01a0926d5", "url": "https://github.com/openhab/openhab-addons/commit/25a80a60aac5f72bf7a5cea7cba54cc01a0926d5", "message": "removed Channels.xlsx\n\nSigned-off-by: Bernhard Bauer <bern77@gmail.com>", "committedDate": "2020-09-16T20:26:42Z", "type": "forcePushed"}, {"oid": "6218819cf142172cebe1b9a98b29c4c376dc211e", "url": "https://github.com/openhab/openhab-addons/commit/6218819cf142172cebe1b9a98b29c4c376dc211e", "message": "Reverting back to originals of pom.xml files\n\nSigned-off-by: Bernhard Bauer <bern77@gmail.com>", "committedDate": "2020-09-16T21:24:22Z", "type": "forcePushed"}, {"oid": "06658f4b9851cf2bb96449a1878fb295b72dc68f", "url": "https://github.com/openhab/openhab-addons/commit/06658f4b9851cf2bb96449a1878fb295b72dc68f", "message": "Reverting back to originals of pom.xml files\n\nSigned-off-by: Bernhard Bauer <bern77@gmail.com>", "committedDate": "2020-09-16T21:34:25Z", "type": "forcePushed"}, {"oid": "d7c5c667c49b5b5fb89dca43caff8663323c1a97", "url": "https://github.com/openhab/openhab-addons/commit/d7c5c667c49b5b5fb89dca43caff8663323c1a97", "message": "Another revert\n\nSigned-off-by: Bernhard Bauer <bern77@gmail.com>", "committedDate": "2020-09-16T21:39:12Z", "type": "forcePushed"}, {"oid": "46b70c06abe700d90de9938261f5f5d15211bbd8", "url": "https://github.com/openhab/openhab-addons/commit/46b70c06abe700d90de9938261f5f5d15211bbd8", "message": "Discarded unwanted changes to other bindings\n\nSigned-off-by: Bernhard <bern77@gmail.com>", "committedDate": "2020-09-18T16:26:36Z", "type": "commit"}, {"oid": "72f88018ac6fc43a6181f166f70fe66ae506bc67", "url": "https://github.com/openhab/openhab-addons/commit/72f88018ac6fc43a6181f166f70fe66ae506bc67", "message": "Version changed to 2.5.9-SNAPSHOT\n\nSigned-off-by: Bernhard <bern77@gmail.com>", "committedDate": "2020-09-18T16:26:36Z", "type": "commit"}, {"oid": "3b155807c072185bcf5ded21a3d7a147329bf9a7", "url": "https://github.com/openhab/openhab-addons/commit/3b155807c072185bcf5ded21a3d7a147329bf9a7", "message": "Fixed errors identified by Code Analysis Tool.\n\nSigned-off-by: Bernhard <bern77@gmail.com>", "committedDate": "2020-09-18T16:31:51Z", "type": "commit"}, {"oid": "a456fb3d57af0e111f2698bcde91b23244ec06d9", "url": "https://github.com/openhab/openhab-addons/commit/a456fb3d57af0e111f2698bcde91b23244ec06d9", "message": "Removed some whitespace...\n\nSigned-off-by: Bernhard <bern77@gmail.com>", "committedDate": "2020-09-18T16:31:51Z", "type": "commit"}, {"oid": "24c7e1cbe4eea79b937ad72ef95d3d51b5fab022", "url": "https://github.com/openhab/openhab-addons/commit/24c7e1cbe4eea79b937ad72ef95d3d51b5fab022", "message": "First changes to documentation based on @fwolter's review.\n\nSigned-off-by: Bernhard Bauer <bern77@gmail.com>", "committedDate": "2020-09-18T16:31:51Z", "type": "commit"}, {"oid": "8bd6ec2913ff6701c0355e8bde68d23716b97ca3", "url": "https://github.com/openhab/openhab-addons/commit/8bd6ec2913ff6701c0355e8bde68d23716b97ca3", "message": "Changes based on @fwolter's review:\n\n- Introduction of Actions\n- Introduction of Properties\n- Combined item for system date+time\n- Combined items to set bypass period\n- Simplified structure of thing-types.xml\n- General code improvements\n\nSigned-off-by: Bernhard Bauer <bern77@gmail.com>\nSigned-off-by: Bernhard <bern77@gmail.com>", "committedDate": "2020-09-18T16:31:51Z", "type": "commit"}, {"oid": "4a6f9e237bc559e8805d5f27a17b573f2d9df185", "url": "https://github.com/openhab/openhab-addons/commit/4a6f9e237bc559e8805d5f27a17b573f2d9df185", "message": "Small bugfix\n\nSigned-off-by: Bernhard Bauer <bern77@gmail.com>\nSigned-off-by: Bernhard <bern77@gmail.com>", "committedDate": "2020-09-18T16:31:51Z", "type": "commit"}, {"oid": "413da91c432d5dd78b540d4fb5539ac3ff5a668a", "url": "https://github.com/openhab/openhab-addons/commit/413da91c432d5dd78b540d4fb5539ac3ff5a668a", "message": "Improved state update mechanism\n\nSigned-off-by: Bernhard Bauer <bern77@gmail.com>", "committedDate": "2020-09-18T16:31:52Z", "type": "commit"}, {"oid": "7680255e2783846ef5ea657990a7d1b88371456e", "url": "https://github.com/openhab/openhab-addons/commit/7680255e2783846ef5ea657990a7d1b88371456e", "message": "Implementation of the inputs from todays's review.\n\nSigned-off-by: Bernhard Bauer <bern77@gmail.com>", "committedDate": "2020-09-18T16:31:52Z", "type": "commit"}, {"oid": "3a4db57d665624264b6be9925396e215139f837d", "url": "https://github.com/openhab/openhab-addons/commit/3a4db57d665624264b6be9925396e215139f837d", "message": "Changed thing name\n\nSigned-off-by: Bernhard Bauer <bern77@gmail.com>", "committedDate": "2020-09-18T16:31:52Z", "type": "commit"}, {"oid": "8170e6f1b5f00197030b5c558cc52609445538ed", "url": "https://github.com/openhab/openhab-addons/commit/8170e6f1b5f00197030b5c558cc52609445538ed", "message": "Changes based on @Hilbrand's review\n\nSigned-off-by: Bernhard Bauer <bern77@gmail.com>", "committedDate": "2020-09-18T16:33:26Z", "type": "commit"}, {"oid": "5415338be90283c1fe7e55ca2aa9cb1205a0208d", "url": "https://github.com/openhab/openhab-addons/commit/5415338be90283c1fe7e55ca2aa9cb1205a0208d", "message": "Example updated\n\nSigned-off-by: Bernhard Bauer <bern77@gmail.com>", "committedDate": "2020-09-18T16:33:41Z", "type": "commit"}, {"oid": "3a2c7c86b281ca1786f826b48142eb6656ed87e3", "url": "https://github.com/openhab/openhab-addons/commit/3a2c7c86b281ca1786f826b48142eb6656ed87e3", "message": "Moved variables.json to resources\n\nSigned-off-by: Bernhard Bauer <bern77@gmail.com>", "committedDate": "2020-09-18T16:33:42Z", "type": "commit"}, {"oid": "166f578a38a204454792558794fc318333fae9c6", "url": "https://github.com/openhab/openhab-addons/commit/166f578a38a204454792558794fc318333fae9c6", "message": "removed Channels.xlsx\n\nSigned-off-by: Bernhard Bauer <bern77@gmail.com>", "committedDate": "2020-09-18T16:35:07Z", "type": "commit"}, {"oid": "498e865924f4321c7786577579e4c0a933d7ddf3", "url": "https://github.com/openhab/openhab-addons/commit/498e865924f4321c7786577579e4c0a933d7ddf3", "message": "Another stab at fixing the 2 pom.xml files...\n\nSigned-off-by: Bernhard Bauer <bern77@gmail.com>", "committedDate": "2020-09-18T16:36:28Z", "type": "commit"}, {"oid": "a05eeaf8e12a1be1ea82c9577fef3265b37724d3", "url": "https://github.com/openhab/openhab-addons/commit/a05eeaf8e12a1be1ea82c9577fef3265b37724d3", "message": "and another...\n\nSigned-off-by: Bernhard Bauer <bern77@gmail.com>", "committedDate": "2020-09-18T16:37:59Z", "type": "commit"}, {"oid": "2ff4a6d19dd58396293fbe22fc9fce112db851c6", "url": "https://github.com/openhab/openhab-addons/commit/2ff4a6d19dd58396293fbe22fc9fce112db851c6", "message": "ran mvn spotless:apply, another stab at the pom.xml files\n\nSigned-off-by: Bernhard Bauer <bern77@gmail.com>", "committedDate": "2020-09-18T16:39:00Z", "type": "commit"}, {"oid": "3d4232b42762a9dbb5e4e69e26faacd962cb3f16", "url": "https://github.com/openhab/openhab-addons/commit/3d4232b42762a9dbb5e4e69e26faacd962cb3f16", "message": "Reverting back to originals of pom.xml files\n\nSigned-off-by: Bernhard Bauer <bern77@gmail.com>", "committedDate": "2020-09-18T16:39:56Z", "type": "commit"}, {"oid": "649f2890233301a962349aebc0a15b349b0c25e2", "url": "https://github.com/openhab/openhab-addons/commit/649f2890233301a962349aebc0a15b349b0c25e2", "message": "feature.xml cleaned up\n\nSigned-off-by: Bernhard Bauer <bern77@gmail.com>", "committedDate": "2020-09-18T16:45:19Z", "type": "commit"}, {"oid": "649f2890233301a962349aebc0a15b349b0c25e2", "url": "https://github.com/openhab/openhab-addons/commit/649f2890233301a962349aebc0a15b349b0c25e2", "message": "feature.xml cleaned up\n\nSigned-off-by: Bernhard Bauer <bern77@gmail.com>", "committedDate": "2020-09-18T16:45:19Z", "type": "forcePushed"}, {"oid": "66afff0e275e5ae8135c42c0492226c6db76fb4c", "url": "https://github.com/openhab/openhab-addons/commit/66afff0e275e5ae8135c42c0492226c6db76fb4c", "message": "Hopefully now fixed the pom.xml files\n\nSigned-off-by: Bernhard Bauer <bern77@gmail.com>", "committedDate": "2020-09-18T16:51:55Z", "type": "commit"}, {"oid": "cedb37d06103ebb07d3b7089f524766f506365cb", "url": "https://github.com/openhab/openhab-addons/commit/cedb37d06103ebb07d3b7089f524766f506365cb", "message": "Formatted feature.xml\n\nSigned-off-by: Bernhard Bauer <bern77@gmail.com>", "committedDate": "2020-09-18T17:01:32Z", "type": "commit"}, {"oid": "2f31f328b1966cf44af783896c9019914531c4e3", "url": "https://github.com/openhab/openhab-addons/commit/2f31f328b1966cf44af783896c9019914531c4e3", "message": "feature.xml\n\nSigned-off-by: Bernhard Bauer <bern77@gmail.com>", "committedDate": "2020-09-18T17:41:55Z", "type": "commit"}, {"oid": "b68a7d33431802eeb9c54d77cc7eafd73647801e", "url": "https://github.com/openhab/openhab-addons/commit/b68a7d33431802eeb9c54d77cc7eafd73647801e", "message": "feature.xml again...\n\nSigned-off-by: Bernhard Bauer <bern77@gmail.com>", "committedDate": "2020-09-18T18:12:00Z", "type": "commit"}, {"oid": "8b3121ee88787c30e8f80eb097463ba3125bce94", "url": "https://github.com/openhab/openhab-addons/commit/8b3121ee88787c30e8f80eb097463ba3125bce94", "message": "deactivated autocrlf\n\nSigned-off-by: Bernhard Bauer <bern77@gmail.com>", "committedDate": "2020-09-18T18:28:57Z", "type": "commit"}, {"oid": "8b3121ee88787c30e8f80eb097463ba3125bce94", "url": "https://github.com/openhab/openhab-addons/commit/8b3121ee88787c30e8f80eb097463ba3125bce94", "message": "deactivated autocrlf\n\nSigned-off-by: Bernhard Bauer <bern77@gmail.com>", "committedDate": "2020-09-18T18:28:57Z", "type": "forcePushed"}, {"oid": "333aee98ab6653da100393a068d14f4d05c9b05f", "url": "https://github.com/openhab/openhab-addons/commit/333aee98ab6653da100393a068d14f4d05c9b05f", "message": "feature.xml once again :(\n\nSigned-off-by: Bernhard Bauer <bern77@gmail.com>", "committedDate": "2020-09-18T18:44:30Z", "type": "commit"}, {"oid": "333aee98ab6653da100393a068d14f4d05c9b05f", "url": "https://github.com/openhab/openhab-addons/commit/333aee98ab6653da100393a068d14f4d05c9b05f", "message": "feature.xml once again :(\n\nSigned-off-by: Bernhard Bauer <bern77@gmail.com>", "committedDate": "2020-09-18T18:44:30Z", "type": "forcePushed"}, {"oid": "141d41a2f0f8082eefea8762d9e10925383fc051", "url": "https://github.com/openhab/openhab-addons/commit/141d41a2f0f8082eefea8762d9e10925383fc051", "message": "replaced CRLF by LF in thing-types.xml\n\nSigned-off-by: Bernhard Bauer <bern77@gmail.com>", "committedDate": "2020-09-19T05:10:47Z", "type": "commit"}, {"oid": "55b8d9e815e35e8bcf6470b2f8213474cc77bdcd", "url": "https://github.com/openhab/openhab-addons/commit/55b8d9e815e35e8bcf6470b2f8213474cc77bdcd", "message": "replaced CRLF by LF in binding.xml\n\nSigned-off-by: Bernhard Bauer <bern77@gmail.com>", "committedDate": "2020-09-19T05:18:02Z", "type": "commit"}, {"oid": "2b383a6bb81f554bf25038bb46369d95a2b30271", "url": "https://github.com/openhab/openhab-addons/commit/2b383a6bb81f554bf25038bb46369d95a2b30271", "message": "replaced CRLF by LF in binding's pom.xml\n\n\nSigned-off-by: Bernhard Bauer <bern77@gmail.com>", "committedDate": "2020-09-19T05:24:05Z", "type": "commit"}, {"oid": "8ec084e35b8d09f22a120fbff97519d1f29ef0c3", "url": "https://github.com/openhab/openhab-addons/commit/8ec084e35b8d09f22a120fbff97519d1f29ef0c3", "message": "replaced CRLF by LF in all files\n\nSigned-off-by: Bernhard Bauer <bern77@gmail.com>", "committedDate": "2020-09-19T05:36:19Z", "type": "commit"}, {"oid": "225bd3dcd64b07b92cd0fb43ff9dbd968dbf72bf", "url": "https://github.com/openhab/openhab-addons/commit/225bd3dcd64b07b92cd0fb43ff9dbd968dbf72bf", "message": "Changed feature.xml to properly reference modbus binding\n\nSigned-off-by: Bernhard Bauer <bern77@gmail.com>", "committedDate": "2020-09-19T05:47:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI3MTk3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r491271973", "bodyText": "You could consider ModbusBitUtilities utility function to parse string, perhaps it does the same thing you do here?", "author": "ssalonen", "createdAt": "2020-09-19T05:26:33Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,807 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.IOException;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.nio.charset.StandardCharsets;\r\n+import java.time.ZoneId;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Collection;\r\n+import java.util.Collections;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.QuantityType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\r\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.eclipse.smarthome.core.types.State;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+@NonNullByDefault\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    private @Nullable HeliosEasyControlsConfiguration config;\r\n+\r\n+    private @Nullable ScheduledFuture<?> pollingJob;\r\n+\r\n+    private @Nullable Map<String, HeliosVariable> variableMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private final Map<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<>();\r\n+\r\n+    private final Gson gson = new Gson();\r\n+\r\n+    private @Nullable ModbusCommunicationInterface comms;\r\n+\r\n+    private int dateFormat = -1;\r\n+    private ZonedDateTime sysDate = ZonedDateTime.now(); // initialize with local system time as a best guess\r\n+                                                         // before reading from device\r\n+\r\n+    private class BypassDate {\r\n+        // initialization to avoid issues when updating before all variables were read\r\n+        private int month = 1;\r\n+        private int day = 1;\r\n+\r\n+        public void setMonth(int month) {\r\n+            this.month = month;\r\n+        }\r\n+\r\n+        public void setDay(int day) {\r\n+            this.day = day;\r\n+        }\r\n+\r\n+        public DateTimeType toDateTimeType() {\r\n+            return new DateTimeType(ZonedDateTime.of(1900, this.month, this.day, 0, 0, 0, 0, ZoneId.of(\"UTC+00:00\")));\r\n+        }\r\n+    }\r\n+\r\n+    private @Nullable BypassDate bypassFrom, bypassTo;\r\n+\r\n+    public HeliosEasyControlsHandler(Thing thing) {\r\n+        super(thing);\r\n+    }\r\n+\r\n+    /**\r\n+     * Reads variable definitions from JSON file and store them in variableMap\r\n+     */\r\n+    private void readVariableDefinition() {\r\n+        Type vMapType = new TypeToken<Map<String, HeliosVariable>>() {\r\n+        }.getType();\r\n+        try (InputStreamReader jsonFile = new InputStreamReader(\r\n+                getClass().getResourceAsStream(HeliosEasyControlsBindingConstants.VARIABLES_DEFINITION_FILE));\r\n+                BufferedReader reader = new BufferedReader(jsonFile)) {\r\n+            this.variableMap = gson.fromJson(reader, vMapType);\r\n+        } catch (IOException e) {\r\n+            this.handleError(\"Error reading variable definition file\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+        }\r\n+        if (variableMap != null) {\r\n+            // add the name to the variable itself\r\n+            for (Map.Entry<String, HeliosVariable> entry : this.variableMap.entrySet()) {\r\n+                entry.getValue().setName(entry.getKey()); // workaround to set the variable name inside the\r\n+                                                          // HeliosVariable object\r\n+                if (!entry.getValue().isOk()) {\r\n+                    this.handleError(\"Variables definition file contains inconsistent data\",\r\n+                            ThingStatusDetail.CONFIGURATION_ERROR);\r\n+                }\r\n+            }\r\n+        } else {\r\n+            this.handleError(\"Variables definition file not found or of illegal format\",\r\n+                    ThingStatusDetail.CONFIGURATION_ERROR);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the endpoint handler from the bridge this handler is connected to\r\n+     * Checks that we're connected to the right type of bridge\r\n+     *\r\n+     * @return the endpoint handler or null if the bridge does not exist\r\n+     */\r\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\r\n+        Bridge bridge = getBridge();\r\n+        if (bridge == null) {\r\n+            logger.debug(\"Bridge is null\");\r\n+            return null;\r\n+        }\r\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\r\n+            logger.debug(\"Bridge is not online\");\r\n+            return null;\r\n+        }\r\n+\r\n+        ThingHandler handler = bridge.getHandler();\r\n+        if (handler == null) {\r\n+            logger.debug(\"Bridge handler is null\");\r\n+            return null;\r\n+        }\r\n+\r\n+        if (handler instanceof ModbusEndpointThingHandler) {\r\n+            return (ModbusEndpointThingHandler) handler;\r\n+        } else {\r\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\r\n+            return null;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get a reference to the modbus endpoint\r\n+     */\r\n+    private void connectEndpoint() {\r\n+        if (this.comms != null) {\r\n+            return;\r\n+        }\r\n+\r\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\r\n+        if (slaveEndpointThingHandler == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' is offline\", label));\r\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\r\n+            return;\r\n+        }\r\n+\r\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\r\n+\r\n+        if (comms == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\r\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\r\n+            return;\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void initialize() {\r\n+        this.config = getConfigAs(HeliosEasyControlsConfiguration.class);\r\n+        this.readVariableDefinition();\r\n+        this.connectEndpoint();\r\n+        if ((this.comms != null) && (this.variableMap != null) && (this.config != null)) {\r\n+            this.transactionLocks.putIfAbsent(this.comms.getEndpoint(), new Semaphore(1, true));\r\n+            updateStatus(ThingStatus.UNKNOWN);\r\n+\r\n+            // background initialization\r\n+            scheduler.execute(() -> {\r\n+                readValue(HeliosEasyControlsBindingConstants.DATE_FORMAT);\r\n+                // status will be updated to ONLINE by the read callback function (via processResponse)\r\n+            });\r\n+\r\n+            // poll for status updates regularly\r\n+            HeliosEasyControlsConfiguration config = this.config;\r\n+            if (config != null) {\r\n+                this.pollingJob = scheduler.scheduleWithFixedDelay(() -> {\r\n+                    if (variableMap != null) {\r\n+                        for (Map.Entry<String, HeliosVariable> entry : variableMap.entrySet()) {\r\n+                            if (this.isProperty(entry.getKey()) || isLinked(entry.getValue().getGroupAndName())\r\n+                                    || HeliosEasyControlsBindingConstants.ALWAYS_UPDATE_VARIABLES\r\n+                                            .contains(entry.getKey())) {\r\n+                                readValue(entry.getKey());\r\n+                            }\r\n+                        }\r\n+                    } else {\r\n+                        handleError(\"Variable definition is null\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+                    }\r\n+                }, config.getRefreshInterval(), config.getRefreshInterval(), TimeUnit.MILLISECONDS);\r\n+            }\r\n+        } else { // at least one null assertion has failed, let's log the problem and update the thing status\r\n+            if (this.comms == null) {\r\n+                this.handleError(\"Modbus communication interface is unavailable\",\r\n+                        ThingStatusDetail.COMMUNICATION_ERROR);\r\n+            }\r\n+            if (this.variableMap == null) {\r\n+                this.handleError(\"Variable definition is unavailable\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            }\r\n+            if (this.config == null) {\r\n+                this.handleError(\"Binding configuration is unavailable\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void dispose() {\r\n+        if (this.pollingJob != null) {\r\n+            this.pollingJob.cancel(true);\r\n+        }\r\n+        this.comms = null;\r\n+    }\r\n+\r\n+    @Override\r\n+    public void handleCommand(ChannelUID channelUID, Command command) {\r\n+        String channelId = channelUID.getIdWithoutGroup();\r\n+        if (command instanceof RefreshType) {\r\n+            if (channelId.equals(HeliosEasyControlsBindingConstants.SYS_DATE)) {\r\n+                scheduler.submit(() -> readValue(HeliosEasyControlsBindingConstants.DATE));\r\n+                scheduler.submit(() -> readValue(HeliosEasyControlsBindingConstants.TIME));\r\n+            } else if (channelId.equals(HeliosEasyControlsBindingConstants.BYPASS_FROM)) {\r\n+                scheduler.submit(() -> readValue(HeliosEasyControlsBindingConstants.BYPASS_FROM_DAY));\r\n+                scheduler.submit(() -> readValue(HeliosEasyControlsBindingConstants.BYPASS_FROM_MONTH));\r\n+            } else if (channelId.equals(HeliosEasyControlsBindingConstants.BYPASS_TO)) {\r\n+                scheduler.submit(() -> readValue(HeliosEasyControlsBindingConstants.BYPASS_TO_DAY));\r\n+                scheduler.submit(() -> readValue(HeliosEasyControlsBindingConstants.BYPASS_TO_MONTH));\r\n+            } else {\r\n+                scheduler.submit(() -> readValue(channelId));\r\n+            }\r\n+        } else { // write command\r\n+            String value = null;\r\n+            if (command instanceof OnOffType) {\r\n+                value = command == OnOffType.ON ? \"1\" : \"0\";\r\n+            } else if (command instanceof DateTimeType) {\r\n+                ZonedDateTime d = ((DateTimeType) command).getZonedDateTime();\r\n+                if (channelId.equals(HeliosEasyControlsBindingConstants.SYS_DATE)) {\r\n+                    setSysDateTime(d);\r\n+                } else if (channelId.equals(HeliosEasyControlsBindingConstants.BYPASS_FROM)) {\r\n+                    this.setBypass(true, d.getDayOfMonth(), d.getMonthValue());\r\n+                } else if (channelId.equals(HeliosEasyControlsBindingConstants.BYPASS_TO)) {\r\n+                    this.setBypass(false, d.getDayOfMonth(), d.getMonthValue());\r\n+                } else {\r\n+                    value = formatDate(channelId, ((DateTimeType) command).getZonedDateTime());\r\n+                }\r\n+            } else if ((command instanceof DecimalType) || (command instanceof StringType)) {\r\n+                value = command.toString();\r\n+            } else if (command instanceof QuantityType<?>) {\r\n+                // convert item's unit to the Helios device's unit\r\n+                Map<String, HeliosVariable> variableMap = this.variableMap;\r\n+                if (variableMap != null) {\r\n+                    String unit = variableMap.get(channelId).getUnit();\r\n+                    QuantityType<?> val = (QuantityType<?>) command;\r\n+                    if (unit != null) {\r\n+                        switch (unit) {\r\n+                            case HeliosVariable.UNIT_DAY:\r\n+                                val = val.toUnit(SmartHomeUnits.DAY);\r\n+                                break;\r\n+                            case HeliosVariable.UNIT_HOUR:\r\n+                                val = val.toUnit(SmartHomeUnits.HOUR);\r\n+                                break;\r\n+                            case HeliosVariable.UNIT_MIN:\r\n+                                val = val.toUnit(SmartHomeUnits.MINUTE);\r\n+                                break;\r\n+                            case HeliosVariable.UNIT_SEC:\r\n+                                val = val.toUnit(SmartHomeUnits.SECOND);\r\n+                                break;\r\n+                            case HeliosVariable.UNIT_VOLT:\r\n+                                val = val.toUnit(SmartHomeUnits.VOLT);\r\n+                                break;\r\n+                            case HeliosVariable.UNIT_PERCENT:\r\n+                                val = val.toUnit(SmartHomeUnits.PERCENT);\r\n+                                break;\r\n+                            case HeliosVariable.UNIT_PPM:\r\n+                                val = val.toUnit(SmartHomeUnits.PARTS_PER_MILLION);\r\n+                                break;\r\n+                            case HeliosVariable.UNIT_TEMP:\r\n+                                val = val.toUnit(SIUnits.CELSIUS);\r\n+                                break;\r\n+                        }\r\n+                        value = val != null ? String.valueOf(val.doubleValue()) : null; // ignore the UoM\r\n+                    }\r\n+                }\r\n+            }\r\n+            if (value != null) {\r\n+                final String v = value;\r\n+                scheduler.submit(() -> {\r\n+                    try {\r\n+                        writeValue(channelId, v);\r\n+                        if (variableMap != null) {\r\n+                            updateState(variableMap.get(channelId), v);\r\n+                            updateStatus(ThingStatus.ONLINE);\r\n+                        }\r\n+                    } catch (HeliosException e) {\r\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\r\n+                                \"Writing value \" + v + \"to channel \" + channelId + \" failed: \" + e.getMessage());\r\n+                    }\r\n+                });\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\r\n+        return Collections.singleton(HeliosEasyControlsActions.class);\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks if the provided variable name is a property\r\n+     *\r\n+     * @param variableName The variable's name\r\n+     * @return true if the variable is a property\r\n+     */\r\n+    private boolean isProperty(String variableName) {\r\n+        return HeliosEasyControlsBindingConstants.PROPERTY_NAMES.contains(variableName);\r\n+    }\r\n+\r\n+    /**\r\n+     * Writes a variable value to the Helios device\r\n+     *\r\n+     * @param variableName The variable name\r\n+     * @param value The new value\r\n+     * @return The value if the transaction succeeded, <tt>null</tt> otherwise\r\n+     * @throws HeliosException Thrown if the variable is read-only or the provided value is out of range\r\n+     */\r\n+    public void writeValue(String variableName, String value) throws HeliosException {\r\n+        if (this.variableMap == null) {\r\n+            this.handleError(\"Variable definition is unavailable.\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            return;\r\n+        } else {\r\n+            Map<String, HeliosVariable> variableMap = this.variableMap;\r\n+            if (variableMap != null) {\r\n+                HeliosVariable v = variableMap.get(variableName);\r\n+\r\n+                if (!v.hasWriteAccess()) {\r\n+                    throw new HeliosException(\"Variable \" + variableName + \" is read-only\");\r\n+                } else if (!v.isInAllowedRange(value)) {\r\n+                    throw new HeliosException(\r\n+                            \"Value \" + value + \" is outside of allowed range of variable \" + variableName);\r\n+                } else if (this.comms != null) {\r\n+                    // write to device\r\n+                    String payload = v.getVariableString() + \"=\" + value;\r\n+                    ModbusCommunicationInterface comms = this.comms;\r\n+                    if (comms != null) {\r\n+                        final Semaphore lock = transactionLocks.get(comms.getEndpoint());\r\n+                        try {\r\n+                            lock.acquire();\r\n+                            comms.submitOneTimeWrite(\r\n+                                    new ModbusWriteRegisterRequestBlueprint(HeliosEasyControlsBindingConstants.UNIT_ID,\r\n+                                            HeliosEasyControlsBindingConstants.START_ADDRESS,\r\n+                                            new ModbusRegisterArray(preparePayload(payload)), true,\r\n+                                            HeliosEasyControlsBindingConstants.MAX_TRIES),\r\n+                                    result -> {\r\n+                                        lock.release();\r\n+                                        updateStatus(ThingStatus.ONLINE);\r\n+                                    }, failureInfo -> {\r\n+                                        lock.release();\r\n+                                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\r\n+                                                \"Error writing to device: \" + failureInfo.getCause().getMessage());\r\n+                                    });\r\n+                        } catch (InterruptedException e) {\r\n+                            logger.warn(\r\n+                                    \"{} encountered Exception when trying to lock Semaphore for writing variable {} to the device: {}\",\r\n+                                    HeliosEasyControlsHandler.class.getSimpleName(), variableName, e.getMessage());\r\n+                        }\r\n+                    }\r\n+                } else { // comms is null\r\n+                    this.handleError(\"Modbus communication interface is null\", ThingStatusDetail.COMMUNICATION_ERROR);\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Read a variable from the Helios device\r\n+     *\r\n+     * @param variableName The variable name\r\n+     * @return The value\r\n+     */\r\n+    public void readValue(String variableName) {\r\n+        Map<String, HeliosVariable> variableMap = this.variableMap;\r\n+        ModbusCommunicationInterface comms = this.comms;\r\n+        if ((comms != null) && (variableMap != null)) {\r\n+            final Semaphore lock = transactionLocks.get(comms.getEndpoint());\r\n+            HeliosVariable v = variableMap.get(variableName);\r\n+            if (v.hasReadAccess()) {\r\n+                try {\r\n+                    lock.acquire(); // will block until lock is available\r\n+                } catch (InterruptedException e) {\r\n+                    logger.warn(\"{} encountered Exception when trying to read variable {} from the device: {}\",\r\n+                            HeliosEasyControlsHandler.class.getSimpleName(), variableName, e.getMessage());\r\n+                    return;\r\n+                }\r\n+                // write variable name to register\r\n+                String payload = v.getVariableString();\r\n+                comms.submitOneTimeWrite(new ModbusWriteRegisterRequestBlueprint(\r\n+                        HeliosEasyControlsBindingConstants.UNIT_ID, HeliosEasyControlsBindingConstants.START_ADDRESS,\r\n+                        new ModbusRegisterArray(preparePayload(payload)), true,\r\n+                        HeliosEasyControlsBindingConstants.MAX_TRIES), result -> {\r\n+                            comms.submitOneTimePoll(\r\n+                                    new ModbusReadRequestBlueprint(HeliosEasyControlsBindingConstants.UNIT_ID,\r\n+                                            ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS,\r\n+                                            HeliosEasyControlsBindingConstants.START_ADDRESS, v.getCount(),\r\n+                                            HeliosEasyControlsBindingConstants.MAX_TRIES),\r\n+                                    pollResult -> {\r\n+                                        lock.release();\r\n+                                        Optional<ModbusRegisterArray> registers = pollResult.getRegisters();\r\n+                                        if (registers.isPresent()) {\r\n+                                            processResponse(v, registers.get());\r\n+                                        }\r\n+                                    }, failureInfo -> {\r\n+                                        lock.release();\r\n+                                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\r\n+                                                \"Error reading from device: \" + failureInfo.getCause().getMessage());\r\n+                                    });\r\n+                        }, failureInfo -> {\r\n+                            lock.release();\r\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\r\n+                                    \"Error writing to device: \" + failureInfo.getCause().getMessage());\r\n+\r\n+                        });\r\n+            }\r\n+\r\n+        } else {\r\n+            if (this.comms == null) {\r\n+                this.handleError(\"Modbus communication interface is unavailable\",\r\n+                        ThingStatusDetail.COMMUNICATION_ERROR);\r\n+            }\r\n+            if (variableMap == null) {\r\n+                this.handleError(\"Variable definition is unavailable\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private void updateSysDate(DateTimeType dateTime) {\r\n+        this.updateSysDateTime(dateTime.getZonedDateTime(), true, sysDate.getOffset().getTotalSeconds() / 60 / 60);\r\n+    }\r\n+\r\n+    private void updateSysTime(DateTimeType dateTime) {\r\n+        this.updateSysDateTime(dateTime.getZonedDateTime(), false, sysDate.getOffset().getTotalSeconds() / 60 / 60);\r\n+    }\r\n+\r\n+    private void updateUtcOffset(int utcOffset) {\r\n+        this.updateSysDateTime(this.sysDate, true, sysDate.getOffset().getTotalSeconds() / 60 / 60);\r\n+    }\r\n+\r\n+    private void updateSysDateTime(ZonedDateTime dateTime, boolean updateDate, int utcOffset) {\r\n+        ZonedDateTime sysDate = this.sysDate;\r\n+        sysDate = ZonedDateTime.of(updateDate ? dateTime.getYear() : sysDate.getYear(),\r\n+                updateDate ? dateTime.getMonthValue() : sysDate.getMonthValue(),\r\n+                updateDate ? dateTime.getDayOfMonth() : sysDate.getDayOfMonth(),\r\n+                updateDate ? sysDate.getHour() : dateTime.getHour(),\r\n+                updateDate ? sysDate.getMinute() : dateTime.getMinute(),\r\n+                updateDate ? sysDate.getSecond() : dateTime.getSecond(), 0,\r\n+                ZoneId.of(\"UTC\" + (utcOffset >= 0 ? \"+\" : \"\") + String.format(\"%02d\", utcOffset) + \":00\"));\r\n+        updateState(\"general#\" + HeliosEasyControlsBindingConstants.SYS_DATE, new DateTimeType(sysDate));\r\n+        this.sysDate = sysDate;\r\n+    }\r\n+\r\n+    private void setSysDateTime(ZonedDateTime date) {\r\n+        try {\r\n+            this.writeValue(HeliosEasyControlsBindingConstants.DATE,\r\n+                    this.formatDate(HeliosEasyControlsBindingConstants.DATE, date));\r\n+            this.writeValue(HeliosEasyControlsBindingConstants.TIME,\r\n+                    date.getHour() + \":\" + date.getMinute() + \":\" + date.getSecond());\r\n+            this.writeValue(HeliosEasyControlsBindingConstants.TIME_ZONE_DIFFERENCE_TO_GMT,\r\n+                    Integer.toString(date.getOffset().getTotalSeconds() / 60 / 60));\r\n+        } catch (HeliosException e) {\r\n+            logger.warn(\"{} encountered Exception when trying to set system date: {}\",\r\n+                    HeliosEasyControlsHandler.class.getSimpleName(), e.getMessage());\r\n+        }\r\n+    }\r\n+\r\n+    protected void setSysDateTime() {\r\n+        this.setSysDateTime(ZonedDateTime.now());\r\n+    }\r\n+\r\n+    private void updateBypass(boolean from, boolean month, int val) {\r\n+        BypassDate bypassDate = from ? this.bypassFrom : this.bypassTo;\r\n+        if (bypassDate == null) {\r\n+            bypassDate = new BypassDate();\r\n+        }\r\n+        if (month) {\r\n+            bypassDate.setMonth(val);\r\n+\r\n+        } else {\r\n+            bypassDate.setDay(val);\r\n+        }\r\n+        updateState(\"unitConfig#\" + (from ? HeliosEasyControlsBindingConstants.BYPASS_FROM\r\n+                : HeliosEasyControlsBindingConstants.BYPASS_TO), bypassDate.toDateTimeType());\r\n+        if (from) {\r\n+            this.bypassFrom = bypassDate;\r\n+\r\n+        } else {\r\n+            this.bypassTo = bypassDate;\r\n+        }\r\n+    }\r\n+\r\n+    protected void setBypass(boolean from, int day, int month) {\r\n+        try {\r\n+            this.writeValue(from ? HeliosEasyControlsBindingConstants.BYPASS_FROM_DAY\r\n+                    : HeliosEasyControlsBindingConstants.BYPASS_TO_DAY, Integer.toString(day));\r\n+            this.writeValue(from ? HeliosEasyControlsBindingConstants.BYPASS_FROM_MONTH\r\n+                    : HeliosEasyControlsBindingConstants.BYPASS_TO_MONTH, Integer.toString(month));\r\n+        } catch (HeliosException e) {\r\n+            logger.warn(\"{} encountered Exception when trying to set bypass period: {}\",\r\n+                    HeliosEasyControlsHandler.class.getSimpleName(), e.getMessage());\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Formats the provided date to a string in the device's configured date format\r\n+     *\r\n+     * @param variableName the variable name\r\n+     * @param date the date to be formatted\r\n+     * @return a string in the device's configured date format\r\n+     */\r\n+    public String formatDate(String variableName, ZonedDateTime date) {\r\n+        String y = Integer.toString(date.getYear());\r\n+        String m = Integer.toString(date.getMonthValue());\r\n+        if (m.length() == 1) {\r\n+            m = \"0\" + m;\r\n+        }\r\n+        String d = Integer.toString(date.getDayOfMonth());\r\n+        if (d.length() == 1) {\r\n+            d = \"0\" + d;\r\n+        }\r\n+        if (variableName.equals(HeliosEasyControlsBindingConstants.DATE)) { // fixed format for writing the system date\r\n+            return d + \".\" + m + \".\" + y;\r\n+        } else {\r\n+            switch (this.dateFormat) {\r\n+                case 0: // dd.mm.yyyy\r\n+                    return d + \".\" + m + \".\" + y;\r\n+                case 1: // mm.dd.yyyy\r\n+                    return m + \".\" + d + \".\" + y;\r\n+                case 2: // yyyy.mm.dd\r\n+                    return y + \".\" + m + \".\" + d;\r\n+                default:\r\n+                    return d + \".\" + m + \".\" + y;\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Returns a DateTimeType object based on the provided String and the device's configured date format\r\n+     *\r\n+     * @param date The date string read from the device\r\n+     * @return A DateTimeType object representing the date or time specified\r\n+     */\r\n+    private DateTimeType toDateTime(String date) {\r\n+        String[] dateTimeParts = null;\r\n+        String dateTime = date;\r\n+        dateTimeParts = date.split(\"\\\\.\"); // try to split date components\r\n+        if (dateTimeParts.length == 1) { // time\r\n+            return DateTimeType.valueOf(date);\r\n+        } else if (dateTimeParts.length == 3) { // date - we'll try the device's date format\r\n+            switch (this.dateFormat) {\r\n+                case 0: // dd.mm.yyyy\r\n+                    dateTime = dateTimeParts[2] + \"-\" + dateTimeParts[1] + \"-\" + dateTimeParts[0];\r\n+                    break;\r\n+                case 1: // mm.dd.yyyy\r\n+                    dateTime = dateTimeParts[2] + \"-\" + dateTimeParts[0] + \"-\" + dateTimeParts[1];\r\n+                    break;\r\n+                case 2: // yyyy.mm.dd\r\n+                    dateTime = dateTimeParts[0] + \"-\" + dateTimeParts[1] + \"-\" + dateTimeParts[2];\r\n+                    break;\r\n+                default:\r\n+                    dateTime = dateTimeParts[2] + \"-\" + dateTimeParts[1] + \"-\" + dateTimeParts[0];\r\n+                    break;\r\n+            }\r\n+            return DateTimeType.valueOf(dateTime);\r\n+        }\r\n+        // falling back to default date format (apparently using the configured format has failed)\r\n+        dateTime = dateTimeParts[2] + \"-\" + dateTimeParts[1] + \"-\" + dateTimeParts[0];\r\n+        return DateTimeType.valueOf(dateTime);\r\n+    }\r\n+\r\n+    private @Nullable QuantityType<?> toQuantityType(String value, @Nullable String unit) {\r\n+        if (unit == null) {\r\n+            return null;\r\n+        } else if (unit.equals(HeliosVariable.UNIT_DAY)) {\r\n+            return new QuantityType<>(Integer.parseInt(value), SmartHomeUnits.DAY);\r\n+        } else if (unit.equals(HeliosVariable.UNIT_HOUR)) {\r\n+            return new QuantityType<>(Integer.parseInt(value), SmartHomeUnits.HOUR);\r\n+        } else if (unit.equals(HeliosVariable.UNIT_MIN)) {\r\n+            return new QuantityType<>(Integer.parseInt(value), SmartHomeUnits.MINUTE);\r\n+        } else if (unit.equals(HeliosVariable.UNIT_SEC)) {\r\n+            return new QuantityType<>(Integer.parseInt(value), SmartHomeUnits.SECOND);\r\n+        } else if (unit.equals(HeliosVariable.UNIT_VOLT)) {\r\n+            return new QuantityType<>(Float.parseFloat(value), SmartHomeUnits.VOLT);\r\n+        } else if (unit.equals(HeliosVariable.UNIT_PERCENT)) {\r\n+            return new QuantityType<>(Float.parseFloat(value), SmartHomeUnits.PERCENT);\r\n+        } else if (unit.equals(HeliosVariable.UNIT_PPM)) {\r\n+            return new QuantityType<>(Float.parseFloat(value), SmartHomeUnits.PARTS_PER_MILLION);\r\n+        } else if (unit.equals(HeliosVariable.UNIT_TEMP)) {\r\n+            return new QuantityType<>(Float.parseFloat(value), SIUnits.CELSIUS);\r\n+        } else {\r\n+            return null;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Prepares the payload for the request\r\n+     *\r\n+     * @param payload The String representation of the payload\r\n+     * @return The Register representation of the payload\r\n+     */\r\n+    private ModbusRegister[] preparePayload(String payload) {\r\n+\r\n+        // determine number of registers\r\n+        int l = (payload.length() + 1) / 2; // +1 because we need to include at least one termination symbol 0x00\r\n+        if ((payload.length() + 1) % 2 != 0) {\r\n+            l++;\r\n+        }\r\n+\r\n+        ModbusRegister reg[] = new ModbusRegister[l];\r\n+        byte[] b = payload.getBytes();\r\n+        int ch = 0;\r\n+        for (int i = 0; i < reg.length; i++) {\r\n+            byte b1 = ch < b.length ? b[ch] : (byte) 0x00; // terminate with 0x00 if at the end of the payload\r\n+            ch++;\r\n+            byte b2 = ch < b.length ? b[ch] : (byte) 0x00;\r\n+            ch++;\r\n+            reg[i] = new ModbusRegister(b1, b2);\r\n+        }\r\n+        return reg;\r\n+    }\r\n+\r\n+    /**\r\n+     * Decodes the Helios device' response and updates the channel with the actual value of the variable\r\n+     *\r\n+     * @param response The registers received from the Helios device\r\n+     * @return The value or <tt>null</tt> if an error occurred\r\n+     */\r\n+    private void processResponse(HeliosVariable v, ModbusRegisterArray registers) {\r\n+        // decode response\r\n+        byte[] b = new byte[registers.size() * 2];\r", "originalCommit": "2b383a6bb81f554bf25038bb46369d95a2b30271", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMxNjgxNA==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r491316814", "bodyText": "Should you convert ZonedDateTime to helios system time zone before extracting dayOfMonth etc?", "author": "ssalonen", "createdAt": "2020-09-19T07:45:39Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,807 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\r\n+\r\n+import java.io.BufferedReader;\r\n+import java.io.IOException;\r\n+import java.io.InputStreamReader;\r\n+import java.lang.reflect.Type;\r\n+import java.nio.charset.StandardCharsets;\r\n+import java.time.ZoneId;\r\n+import java.time.ZonedDateTime;\r\n+import java.util.Arrays;\r\n+import java.util.Collection;\r\n+import java.util.Collections;\r\n+import java.util.Map;\r\n+import java.util.Optional;\r\n+import java.util.concurrent.ConcurrentHashMap;\r\n+import java.util.concurrent.ScheduledFuture;\r\n+import java.util.concurrent.Semaphore;\r\n+import java.util.concurrent.TimeUnit;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\r\n+import org.eclipse.smarthome.core.library.types.DecimalType;\r\n+import org.eclipse.smarthome.core.library.types.OnOffType;\r\n+import org.eclipse.smarthome.core.library.types.QuantityType;\r\n+import org.eclipse.smarthome.core.library.types.StringType;\r\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\r\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\r\n+import org.eclipse.smarthome.core.thing.Bridge;\r\n+import org.eclipse.smarthome.core.thing.Channel;\r\n+import org.eclipse.smarthome.core.thing.ChannelUID;\r\n+import org.eclipse.smarthome.core.thing.Thing;\r\n+import org.eclipse.smarthome.core.thing.ThingStatus;\r\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\r\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\r\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\r\n+import org.eclipse.smarthome.core.types.Command;\r\n+import org.eclipse.smarthome.core.types.RefreshType;\r\n+import org.eclipse.smarthome.core.types.State;\r\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\r\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\r\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\r\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.ModbusRegister;\r\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\r\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\r\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.reflect.TypeToken;\r\n+\r\n+/**\r\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\r\n+ * sent to one of the channels.\r\n+ *\r\n+ * @author Bernhard Bauer - Initial contribution\r\n+ */\r\n+@NonNullByDefault\r\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\r\n+\r\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\r\n+\r\n+    private @Nullable HeliosEasyControlsConfiguration config;\r\n+\r\n+    private @Nullable ScheduledFuture<?> pollingJob;\r\n+\r\n+    private @Nullable Map<String, HeliosVariable> variableMap;\r\n+\r\n+    /**\r\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\r\n+     * another transaction\r\n+     */\r\n+    private final Map<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<>();\r\n+\r\n+    private final Gson gson = new Gson();\r\n+\r\n+    private @Nullable ModbusCommunicationInterface comms;\r\n+\r\n+    private int dateFormat = -1;\r\n+    private ZonedDateTime sysDate = ZonedDateTime.now(); // initialize with local system time as a best guess\r\n+                                                         // before reading from device\r\n+\r\n+    private class BypassDate {\r\n+        // initialization to avoid issues when updating before all variables were read\r\n+        private int month = 1;\r\n+        private int day = 1;\r\n+\r\n+        public void setMonth(int month) {\r\n+            this.month = month;\r\n+        }\r\n+\r\n+        public void setDay(int day) {\r\n+            this.day = day;\r\n+        }\r\n+\r\n+        public DateTimeType toDateTimeType() {\r\n+            return new DateTimeType(ZonedDateTime.of(1900, this.month, this.day, 0, 0, 0, 0, ZoneId.of(\"UTC+00:00\")));\r\n+        }\r\n+    }\r\n+\r\n+    private @Nullable BypassDate bypassFrom, bypassTo;\r\n+\r\n+    public HeliosEasyControlsHandler(Thing thing) {\r\n+        super(thing);\r\n+    }\r\n+\r\n+    /**\r\n+     * Reads variable definitions from JSON file and store them in variableMap\r\n+     */\r\n+    private void readVariableDefinition() {\r\n+        Type vMapType = new TypeToken<Map<String, HeliosVariable>>() {\r\n+        }.getType();\r\n+        try (InputStreamReader jsonFile = new InputStreamReader(\r\n+                getClass().getResourceAsStream(HeliosEasyControlsBindingConstants.VARIABLES_DEFINITION_FILE));\r\n+                BufferedReader reader = new BufferedReader(jsonFile)) {\r\n+            this.variableMap = gson.fromJson(reader, vMapType);\r\n+        } catch (IOException e) {\r\n+            this.handleError(\"Error reading variable definition file\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+        }\r\n+        if (variableMap != null) {\r\n+            // add the name to the variable itself\r\n+            for (Map.Entry<String, HeliosVariable> entry : this.variableMap.entrySet()) {\r\n+                entry.getValue().setName(entry.getKey()); // workaround to set the variable name inside the\r\n+                                                          // HeliosVariable object\r\n+                if (!entry.getValue().isOk()) {\r\n+                    this.handleError(\"Variables definition file contains inconsistent data\",\r\n+                            ThingStatusDetail.CONFIGURATION_ERROR);\r\n+                }\r\n+            }\r\n+        } else {\r\n+            this.handleError(\"Variables definition file not found or of illegal format\",\r\n+                    ThingStatusDetail.CONFIGURATION_ERROR);\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get the endpoint handler from the bridge this handler is connected to\r\n+     * Checks that we're connected to the right type of bridge\r\n+     *\r\n+     * @return the endpoint handler or null if the bridge does not exist\r\n+     */\r\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\r\n+        Bridge bridge = getBridge();\r\n+        if (bridge == null) {\r\n+            logger.debug(\"Bridge is null\");\r\n+            return null;\r\n+        }\r\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\r\n+            logger.debug(\"Bridge is not online\");\r\n+            return null;\r\n+        }\r\n+\r\n+        ThingHandler handler = bridge.getHandler();\r\n+        if (handler == null) {\r\n+            logger.debug(\"Bridge handler is null\");\r\n+            return null;\r\n+        }\r\n+\r\n+        if (handler instanceof ModbusEndpointThingHandler) {\r\n+            return (ModbusEndpointThingHandler) handler;\r\n+        } else {\r\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\r\n+            return null;\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Get a reference to the modbus endpoint\r\n+     */\r\n+    private void connectEndpoint() {\r\n+        if (this.comms != null) {\r\n+            return;\r\n+        }\r\n+\r\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\r\n+        if (slaveEndpointThingHandler == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' is offline\", label));\r\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\r\n+            return;\r\n+        }\r\n+\r\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\r\n+\r\n+        if (comms == null) {\r\n+            @SuppressWarnings(\"null\")\r\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\r\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\r\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\r\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\r\n+            return;\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void initialize() {\r\n+        this.config = getConfigAs(HeliosEasyControlsConfiguration.class);\r\n+        this.readVariableDefinition();\r\n+        this.connectEndpoint();\r\n+        if ((this.comms != null) && (this.variableMap != null) && (this.config != null)) {\r\n+            this.transactionLocks.putIfAbsent(this.comms.getEndpoint(), new Semaphore(1, true));\r\n+            updateStatus(ThingStatus.UNKNOWN);\r\n+\r\n+            // background initialization\r\n+            scheduler.execute(() -> {\r\n+                readValue(HeliosEasyControlsBindingConstants.DATE_FORMAT);\r\n+                // status will be updated to ONLINE by the read callback function (via processResponse)\r\n+            });\r\n+\r\n+            // poll for status updates regularly\r\n+            HeliosEasyControlsConfiguration config = this.config;\r\n+            if (config != null) {\r\n+                this.pollingJob = scheduler.scheduleWithFixedDelay(() -> {\r\n+                    if (variableMap != null) {\r\n+                        for (Map.Entry<String, HeliosVariable> entry : variableMap.entrySet()) {\r\n+                            if (this.isProperty(entry.getKey()) || isLinked(entry.getValue().getGroupAndName())\r\n+                                    || HeliosEasyControlsBindingConstants.ALWAYS_UPDATE_VARIABLES\r\n+                                            .contains(entry.getKey())) {\r\n+                                readValue(entry.getKey());\r\n+                            }\r\n+                        }\r\n+                    } else {\r\n+                        handleError(\"Variable definition is null\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+                    }\r\n+                }, config.getRefreshInterval(), config.getRefreshInterval(), TimeUnit.MILLISECONDS);\r\n+            }\r\n+        } else { // at least one null assertion has failed, let's log the problem and update the thing status\r\n+            if (this.comms == null) {\r\n+                this.handleError(\"Modbus communication interface is unavailable\",\r\n+                        ThingStatusDetail.COMMUNICATION_ERROR);\r\n+            }\r\n+            if (this.variableMap == null) {\r\n+                this.handleError(\"Variable definition is unavailable\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            }\r\n+            if (this.config == null) {\r\n+                this.handleError(\"Binding configuration is unavailable\", ThingStatusDetail.CONFIGURATION_ERROR);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    @Override\r\n+    public void dispose() {\r\n+        if (this.pollingJob != null) {\r\n+            this.pollingJob.cancel(true);\r\n+        }\r\n+        this.comms = null;\r\n+    }\r\n+\r\n+    @Override\r\n+    public void handleCommand(ChannelUID channelUID, Command command) {\r\n+        String channelId = channelUID.getIdWithoutGroup();\r\n+        if (command instanceof RefreshType) {\r\n+            if (channelId.equals(HeliosEasyControlsBindingConstants.SYS_DATE)) {\r\n+                scheduler.submit(() -> readValue(HeliosEasyControlsBindingConstants.DATE));\r\n+                scheduler.submit(() -> readValue(HeliosEasyControlsBindingConstants.TIME));\r\n+            } else if (channelId.equals(HeliosEasyControlsBindingConstants.BYPASS_FROM)) {\r\n+                scheduler.submit(() -> readValue(HeliosEasyControlsBindingConstants.BYPASS_FROM_DAY));\r\n+                scheduler.submit(() -> readValue(HeliosEasyControlsBindingConstants.BYPASS_FROM_MONTH));\r\n+            } else if (channelId.equals(HeliosEasyControlsBindingConstants.BYPASS_TO)) {\r\n+                scheduler.submit(() -> readValue(HeliosEasyControlsBindingConstants.BYPASS_TO_DAY));\r\n+                scheduler.submit(() -> readValue(HeliosEasyControlsBindingConstants.BYPASS_TO_MONTH));\r\n+            } else {\r\n+                scheduler.submit(() -> readValue(channelId));\r\n+            }\r\n+        } else { // write command\r\n+            String value = null;\r\n+            if (command instanceof OnOffType) {\r\n+                value = command == OnOffType.ON ? \"1\" : \"0\";\r\n+            } else if (command instanceof DateTimeType) {\r\n+                ZonedDateTime d = ((DateTimeType) command).getZonedDateTime();\r\n+                if (channelId.equals(HeliosEasyControlsBindingConstants.SYS_DATE)) {\r\n+                    setSysDateTime(d);\r\n+                } else if (channelId.equals(HeliosEasyControlsBindingConstants.BYPASS_FROM)) {\r\n+                    this.setBypass(true, d.getDayOfMonth(), d.getMonthValue());\r", "originalCommit": "2b383a6bb81f554bf25038bb46369d95a2b30271", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMyNzU1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r491327553", "bodyText": "I don't think this is necessary for setting the bypass' from and to date. These settings are independent from the actual system time.", "author": "bern77", "createdAt": "2020-09-19T08:20:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMxNjgxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMzMTkzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r491331939", "bodyText": "Let me try to make point in a different way\nSurely you agree that 2020-01-02 01:00 UTC and 2020-01-01 23:00 UTC-2h represent exactly same moment in time?\nJust extracting the date from \"local dates\" yields different results.", "author": "ssalonen", "createdAt": "2020-09-19T08:33:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMxNjgxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMzMzcxOA==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r491333718", "bodyText": "Yes, I'm aware of the GMT offset having an impact on the day in the date. But in this specific case (setting the bypass date) I don't see the relevance.\nThe user, a rule, etc. wants to change the day from which on the bypass functionality should be active or deactivated. This will result in a date with its day and month based on the local time zone being assigned to an item. Now I grab precisely this day and month and write this to the device.\nMaybe I'm missing something, but in this case I'm just using the DateTime type as a vehicle to get month and day set together. Please also see the private class BypassDate for my internal representation which is completely independent of any time zone.", "author": "bern77", "createdAt": "2020-09-19T08:40:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMxNjgxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTM1Mzc2OA==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r491353768", "bodyText": "I see what you are saying but I think you are missing my point.\nI will try describe the whole flow and why I think you should consider taking zones into account\nGiven\n\nuser with local time zone UTC -6. User has configured openhab correctly that it uses this timezone. Ui elements etc use UTC -6\nHelios with UTC timezone\n\nNow, user open openhab ui and sets bypass date to Jan 02.\nCurrently binding writes Jan 02 to Helios. Helios interprets Jan 02 date against its system time of course. So bypass mode gets actually activated Jan 02 00:00 UTC, which corresponds to Jan 01 18:00 in UTC-6.\nSo as summary user thought he set bypass to Jan 2 (his time) but it is actually Jan 1 (his time)\nI might be missing something as well but hopefully the above opens up my thinking", "author": "ssalonen", "createdAt": "2020-09-19T09:41:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMxNjgxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTM4NjM0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r491386345", "bodyText": "I think I get your point. However, if the user used the device's own configuration web interface and set the date there, the result would be the same. In the end the device will use its own system time to activate/deactivate the bypass.\nAfter all, it's more important that the settings in the device according to its local time zone are correct. The bypass depends both on a period of time in which it will be considered as well as on the outside and room temperature. So this is something very local and quite dpendent on the local time as well.\nSo even if it were a valid use case that I run an OH instance in Austria to control a ventilation system in the US, I would, as a user, still want to set the bypass to a specific date, when I want the bypass to become active in the US, not having to consider possible time zone differences.\nI know it's only one line of code, but I'm still not convinced \ud83d\ude09", "author": "bern77", "createdAt": "2020-09-19T11:09:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMxNjgxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMyMDQwMA==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r491320400", "bodyText": "Would this work?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // decode response\n          \n          \n            \n                    byte[] b = new byte[registers.size() * 2];\n          \n          \n            \n                    int actSize = 0; // track the actual size of the usable array (excluding any 0x00\n          \n          \n            \n                                     // characters)\n          \n          \n            \n                    for (int i = 0; i < registers.size(); i++) {\n          \n          \n            \n                        byte[] reg = registers.getRegister(i).getBytes();\n          \n          \n            \n                        if (reg.length == 2) { // only add to the array if it's a usable character\n          \n          \n            \n                            if (reg[0] != 0x00) {\n          \n          \n            \n                                b[actSize++] = reg[0];\n          \n          \n            \n                            }\n          \n          \n            \n                            if (reg[1] != 0x00) {\n          \n          \n            \n                                b[actSize++] = reg[1];\n          \n          \n            \n                            }\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                    b = Arrays.copyOf(b, actSize); // before creating a string of it the array needs to be\n          \n          \n            \n                                                   // truncated\n          \n          \n            \n                    String r = new String(b, StandardCharsets.US_ASCII);\n          \n          \n            \n                    String r = ModbusBitUtilities\n          \n          \n            \n                            .extractStringFromRegisters(registers, 0, registers.size() * 2, StandardCharsets.US_ASCII).toString();", "author": "ssalonen", "createdAt": "2020-09-19T07:57:32Z", "path": "bundles/org.openhab.binding.modbus.helioseasycontrols/src/main/java/org/openhab/binding/modbus/helioseasycontrols/internal/HeliosEasyControlsHandler.java", "diffHunk": "@@ -0,0 +1,807 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.helioseasycontrols.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.lang.reflect.Type;\n+import java.nio.charset.StandardCharsets;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegister;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusWriteRegisterRequestBlueprint;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.reflect.TypeToken;\n+\n+/**\n+ * The {@link HeliosEasyControlsHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Bernhard Bauer - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosEasyControlsHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(HeliosEasyControlsHandler.class);\n+\n+    private @Nullable HeliosEasyControlsConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private @Nullable Map<String, HeliosVariable> variableMap;\n+\n+    /**\n+     * This flag is used to ensure read requests (consisting of a write and subsequent read) are not influenced by\n+     * another transaction\n+     */\n+    private final Map<ModbusSlaveEndpoint, Semaphore> transactionLocks = new ConcurrentHashMap<>();\n+\n+    private final Gson gson = new Gson();\n+\n+    private @Nullable ModbusCommunicationInterface comms;\n+\n+    private int dateFormat = -1;\n+    private ZonedDateTime sysDate = ZonedDateTime.now(); // initialize with local system time as a best guess\n+                                                         // before reading from device\n+\n+    private class BypassDate {\n+        // initialization to avoid issues when updating before all variables were read\n+        private int month = 1;\n+        private int day = 1;\n+\n+        public void setMonth(int month) {\n+            this.month = month;\n+        }\n+\n+        public void setDay(int day) {\n+            this.day = day;\n+        }\n+\n+        public DateTimeType toDateTimeType() {\n+            return new DateTimeType(ZonedDateTime.of(1900, this.month, this.day, 0, 0, 0, 0, ZoneId.of(\"UTC+00:00\")));\n+        }\n+    }\n+\n+    private @Nullable BypassDate bypassFrom, bypassTo;\n+\n+    public HeliosEasyControlsHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /**\n+     * Reads variable definitions from JSON file and store them in variableMap\n+     */\n+    private void readVariableDefinition() {\n+        Type vMapType = new TypeToken<Map<String, HeliosVariable>>() {\n+        }.getType();\n+        try (InputStreamReader jsonFile = new InputStreamReader(\n+                getClass().getResourceAsStream(HeliosEasyControlsBindingConstants.VARIABLES_DEFINITION_FILE));\n+                BufferedReader reader = new BufferedReader(jsonFile)) {\n+            this.variableMap = gson.fromJson(reader, vMapType);\n+        } catch (IOException e) {\n+            this.handleError(\"Error reading variable definition file\", ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+        if (variableMap != null) {\n+            // add the name to the variable itself\n+            for (Map.Entry<String, HeliosVariable> entry : this.variableMap.entrySet()) {\n+                entry.getValue().setName(entry.getKey()); // workaround to set the variable name inside the\n+                                                          // HeliosVariable object\n+                if (!entry.getValue().isOk()) {\n+                    this.handleError(\"Variables definition file contains inconsistent data\",\n+                            ThingStatusDetail.CONFIGURATION_ERROR);\n+                }\n+            }\n+        } else {\n+            this.handleError(\"Variables definition file not found or of illegal format\",\n+                    ThingStatusDetail.CONFIGURATION_ERROR);\n+        }\n+    }\n+\n+    /**\n+     * Get the endpoint handler from the bridge this handler is connected to\n+     * Checks that we're connected to the right type of bridge\n+     *\n+     * @return the endpoint handler or null if the bridge does not exist\n+     */\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Bridge is null\");\n+            return null;\n+        }\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Bridge is not online\");\n+            return null;\n+        }\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler == null) {\n+            logger.debug(\"Bridge handler is null\");\n+            return null;\n+        }\n+\n+        if (handler instanceof ModbusEndpointThingHandler) {\n+            return (ModbusEndpointThingHandler) handler;\n+        } else {\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Get a reference to the modbus endpoint\n+     */\n+    private void connectEndpoint() {\n+        if (this.comms != null) {\n+            return;\n+        }\n+\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\n+        if (slaveEndpointThingHandler == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' is offline\", label));\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\n+            return;\n+        }\n+\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\n+\n+        if (comms == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\n+            return;\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        this.config = getConfigAs(HeliosEasyControlsConfiguration.class);\n+        this.readVariableDefinition();\n+        this.connectEndpoint();\n+        if ((this.comms != null) && (this.variableMap != null) && (this.config != null)) {\n+            this.transactionLocks.putIfAbsent(this.comms.getEndpoint(), new Semaphore(1, true));\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            // background initialization\n+            scheduler.execute(() -> {\n+                readValue(HeliosEasyControlsBindingConstants.DATE_FORMAT);\n+                // status will be updated to ONLINE by the read callback function (via processResponse)\n+            });\n+\n+            // poll for status updates regularly\n+            HeliosEasyControlsConfiguration config = this.config;\n+            if (config != null) {\n+                this.pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+                    if (variableMap != null) {\n+                        for (Map.Entry<String, HeliosVariable> entry : variableMap.entrySet()) {\n+                            if (this.isProperty(entry.getKey()) || isLinked(entry.getValue().getGroupAndName())\n+                                    || HeliosEasyControlsBindingConstants.ALWAYS_UPDATE_VARIABLES\n+                                            .contains(entry.getKey())) {\n+                                readValue(entry.getKey());\n+                            }\n+                        }\n+                    } else {\n+                        handleError(\"Variable definition is null\", ThingStatusDetail.CONFIGURATION_ERROR);\n+                    }\n+                }, config.getRefreshInterval(), config.getRefreshInterval(), TimeUnit.MILLISECONDS);\n+            }\n+        } else { // at least one null assertion has failed, let's log the problem and update the thing status\n+            if (this.comms == null) {\n+                this.handleError(\"Modbus communication interface is unavailable\",\n+                        ThingStatusDetail.COMMUNICATION_ERROR);\n+            }\n+            if (this.variableMap == null) {\n+                this.handleError(\"Variable definition is unavailable\", ThingStatusDetail.CONFIGURATION_ERROR);\n+            }\n+            if (this.config == null) {\n+                this.handleError(\"Binding configuration is unavailable\", ThingStatusDetail.CONFIGURATION_ERROR);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (this.pollingJob != null) {\n+            this.pollingJob.cancel(true);\n+        }\n+        this.comms = null;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channelId = channelUID.getIdWithoutGroup();\n+        if (command instanceof RefreshType) {\n+            if (channelId.equals(HeliosEasyControlsBindingConstants.SYS_DATE)) {\n+                scheduler.submit(() -> readValue(HeliosEasyControlsBindingConstants.DATE));\n+                scheduler.submit(() -> readValue(HeliosEasyControlsBindingConstants.TIME));\n+            } else if (channelId.equals(HeliosEasyControlsBindingConstants.BYPASS_FROM)) {\n+                scheduler.submit(() -> readValue(HeliosEasyControlsBindingConstants.BYPASS_FROM_DAY));\n+                scheduler.submit(() -> readValue(HeliosEasyControlsBindingConstants.BYPASS_FROM_MONTH));\n+            } else if (channelId.equals(HeliosEasyControlsBindingConstants.BYPASS_TO)) {\n+                scheduler.submit(() -> readValue(HeliosEasyControlsBindingConstants.BYPASS_TO_DAY));\n+                scheduler.submit(() -> readValue(HeliosEasyControlsBindingConstants.BYPASS_TO_MONTH));\n+            } else {\n+                scheduler.submit(() -> readValue(channelId));\n+            }\n+        } else { // write command\n+            String value = null;\n+            if (command instanceof OnOffType) {\n+                value = command == OnOffType.ON ? \"1\" : \"0\";\n+            } else if (command instanceof DateTimeType) {\n+                ZonedDateTime d = ((DateTimeType) command).getZonedDateTime();\n+                if (channelId.equals(HeliosEasyControlsBindingConstants.SYS_DATE)) {\n+                    setSysDateTime(d);\n+                } else if (channelId.equals(HeliosEasyControlsBindingConstants.BYPASS_FROM)) {\n+                    this.setBypass(true, d.getDayOfMonth(), d.getMonthValue());\n+                } else if (channelId.equals(HeliosEasyControlsBindingConstants.BYPASS_TO)) {\n+                    this.setBypass(false, d.getDayOfMonth(), d.getMonthValue());\n+                } else {\n+                    value = formatDate(channelId, ((DateTimeType) command).getZonedDateTime());\n+                }\n+            } else if ((command instanceof DecimalType) || (command instanceof StringType)) {\n+                value = command.toString();\n+            } else if (command instanceof QuantityType<?>) {\n+                // convert item's unit to the Helios device's unit\n+                Map<String, HeliosVariable> variableMap = this.variableMap;\n+                if (variableMap != null) {\n+                    String unit = variableMap.get(channelId).getUnit();\n+                    QuantityType<?> val = (QuantityType<?>) command;\n+                    if (unit != null) {\n+                        switch (unit) {\n+                            case HeliosVariable.UNIT_DAY:\n+                                val = val.toUnit(SmartHomeUnits.DAY);\n+                                break;\n+                            case HeliosVariable.UNIT_HOUR:\n+                                val = val.toUnit(SmartHomeUnits.HOUR);\n+                                break;\n+                            case HeliosVariable.UNIT_MIN:\n+                                val = val.toUnit(SmartHomeUnits.MINUTE);\n+                                break;\n+                            case HeliosVariable.UNIT_SEC:\n+                                val = val.toUnit(SmartHomeUnits.SECOND);\n+                                break;\n+                            case HeliosVariable.UNIT_VOLT:\n+                                val = val.toUnit(SmartHomeUnits.VOLT);\n+                                break;\n+                            case HeliosVariable.UNIT_PERCENT:\n+                                val = val.toUnit(SmartHomeUnits.PERCENT);\n+                                break;\n+                            case HeliosVariable.UNIT_PPM:\n+                                val = val.toUnit(SmartHomeUnits.PARTS_PER_MILLION);\n+                                break;\n+                            case HeliosVariable.UNIT_TEMP:\n+                                val = val.toUnit(SIUnits.CELSIUS);\n+                                break;\n+                        }\n+                        value = val != null ? String.valueOf(val.doubleValue()) : null; // ignore the UoM\n+                    }\n+                }\n+            }\n+            if (value != null) {\n+                final String v = value;\n+                scheduler.submit(() -> {\n+                    try {\n+                        writeValue(channelId, v);\n+                        if (variableMap != null) {\n+                            updateState(variableMap.get(channelId), v);\n+                            updateStatus(ThingStatus.ONLINE);\n+                        }\n+                    } catch (HeliosException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Writing value \" + v + \"to channel \" + channelId + \" failed: \" + e.getMessage());\n+                    }\n+                });\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(HeliosEasyControlsActions.class);\n+    }\n+\n+    /**\n+     * Checks if the provided variable name is a property\n+     *\n+     * @param variableName The variable's name\n+     * @return true if the variable is a property\n+     */\n+    private boolean isProperty(String variableName) {\n+        return HeliosEasyControlsBindingConstants.PROPERTY_NAMES.contains(variableName);\n+    }\n+\n+    /**\n+     * Writes a variable value to the Helios device\n+     *\n+     * @param variableName The variable name\n+     * @param value The new value\n+     * @return The value if the transaction succeeded, <tt>null</tt> otherwise\n+     * @throws HeliosException Thrown if the variable is read-only or the provided value is out of range\n+     */\n+    public void writeValue(String variableName, String value) throws HeliosException {\n+        if (this.variableMap == null) {\n+            this.handleError(\"Variable definition is unavailable.\", ThingStatusDetail.CONFIGURATION_ERROR);\n+            return;\n+        } else {\n+            Map<String, HeliosVariable> variableMap = this.variableMap;\n+            if (variableMap != null) {\n+                HeliosVariable v = variableMap.get(variableName);\n+\n+                if (!v.hasWriteAccess()) {\n+                    throw new HeliosException(\"Variable \" + variableName + \" is read-only\");\n+                } else if (!v.isInAllowedRange(value)) {\n+                    throw new HeliosException(\n+                            \"Value \" + value + \" is outside of allowed range of variable \" + variableName);\n+                } else if (this.comms != null) {\n+                    // write to device\n+                    String payload = v.getVariableString() + \"=\" + value;\n+                    ModbusCommunicationInterface comms = this.comms;\n+                    if (comms != null) {\n+                        final Semaphore lock = transactionLocks.get(comms.getEndpoint());\n+                        try {\n+                            lock.acquire();\n+                            comms.submitOneTimeWrite(\n+                                    new ModbusWriteRegisterRequestBlueprint(HeliosEasyControlsBindingConstants.UNIT_ID,\n+                                            HeliosEasyControlsBindingConstants.START_ADDRESS,\n+                                            new ModbusRegisterArray(preparePayload(payload)), true,\n+                                            HeliosEasyControlsBindingConstants.MAX_TRIES),\n+                                    result -> {\n+                                        lock.release();\n+                                        updateStatus(ThingStatus.ONLINE);\n+                                    }, failureInfo -> {\n+                                        lock.release();\n+                                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                                \"Error writing to device: \" + failureInfo.getCause().getMessage());\n+                                    });\n+                        } catch (InterruptedException e) {\n+                            logger.warn(\n+                                    \"{} encountered Exception when trying to lock Semaphore for writing variable {} to the device: {}\",\n+                                    HeliosEasyControlsHandler.class.getSimpleName(), variableName, e.getMessage());\n+                        }\n+                    }\n+                } else { // comms is null\n+                    this.handleError(\"Modbus communication interface is null\", ThingStatusDetail.COMMUNICATION_ERROR);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Read a variable from the Helios device\n+     *\n+     * @param variableName The variable name\n+     * @return The value\n+     */\n+    public void readValue(String variableName) {\n+        Map<String, HeliosVariable> variableMap = this.variableMap;\n+        ModbusCommunicationInterface comms = this.comms;\n+        if ((comms != null) && (variableMap != null)) {\n+            final Semaphore lock = transactionLocks.get(comms.getEndpoint());\n+            HeliosVariable v = variableMap.get(variableName);\n+            if (v.hasReadAccess()) {\n+                try {\n+                    lock.acquire(); // will block until lock is available\n+                } catch (InterruptedException e) {\n+                    logger.warn(\"{} encountered Exception when trying to read variable {} from the device: {}\",\n+                            HeliosEasyControlsHandler.class.getSimpleName(), variableName, e.getMessage());\n+                    return;\n+                }\n+                // write variable name to register\n+                String payload = v.getVariableString();\n+                comms.submitOneTimeWrite(new ModbusWriteRegisterRequestBlueprint(\n+                        HeliosEasyControlsBindingConstants.UNIT_ID, HeliosEasyControlsBindingConstants.START_ADDRESS,\n+                        new ModbusRegisterArray(preparePayload(payload)), true,\n+                        HeliosEasyControlsBindingConstants.MAX_TRIES), result -> {\n+                            comms.submitOneTimePoll(\n+                                    new ModbusReadRequestBlueprint(HeliosEasyControlsBindingConstants.UNIT_ID,\n+                                            ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS,\n+                                            HeliosEasyControlsBindingConstants.START_ADDRESS, v.getCount(),\n+                                            HeliosEasyControlsBindingConstants.MAX_TRIES),\n+                                    pollResult -> {\n+                                        lock.release();\n+                                        Optional<ModbusRegisterArray> registers = pollResult.getRegisters();\n+                                        if (registers.isPresent()) {\n+                                            processResponse(v, registers.get());\n+                                        }\n+                                    }, failureInfo -> {\n+                                        lock.release();\n+                                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                                \"Error reading from device: \" + failureInfo.getCause().getMessage());\n+                                    });\n+                        }, failureInfo -> {\n+                            lock.release();\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                    \"Error writing to device: \" + failureInfo.getCause().getMessage());\n+\n+                        });\n+            }\n+\n+        } else {\n+            if (this.comms == null) {\n+                this.handleError(\"Modbus communication interface is unavailable\",\n+                        ThingStatusDetail.COMMUNICATION_ERROR);\n+            }\n+            if (variableMap == null) {\n+                this.handleError(\"Variable definition is unavailable\", ThingStatusDetail.CONFIGURATION_ERROR);\n+            }\n+        }\n+    }\n+\n+    private void updateSysDate(DateTimeType dateTime) {\n+        this.updateSysDateTime(dateTime.getZonedDateTime(), true, sysDate.getOffset().getTotalSeconds() / 60 / 60);\n+    }\n+\n+    private void updateSysTime(DateTimeType dateTime) {\n+        this.updateSysDateTime(dateTime.getZonedDateTime(), false, sysDate.getOffset().getTotalSeconds() / 60 / 60);\n+    }\n+\n+    private void updateUtcOffset(int utcOffset) {\n+        this.updateSysDateTime(this.sysDate, true, sysDate.getOffset().getTotalSeconds() / 60 / 60);\n+    }\n+\n+    private void updateSysDateTime(ZonedDateTime dateTime, boolean updateDate, int utcOffset) {\n+        ZonedDateTime sysDate = this.sysDate;\n+        sysDate = ZonedDateTime.of(updateDate ? dateTime.getYear() : sysDate.getYear(),\n+                updateDate ? dateTime.getMonthValue() : sysDate.getMonthValue(),\n+                updateDate ? dateTime.getDayOfMonth() : sysDate.getDayOfMonth(),\n+                updateDate ? sysDate.getHour() : dateTime.getHour(),\n+                updateDate ? sysDate.getMinute() : dateTime.getMinute(),\n+                updateDate ? sysDate.getSecond() : dateTime.getSecond(), 0,\n+                ZoneId.of(\"UTC\" + (utcOffset >= 0 ? \"+\" : \"\") + String.format(\"%02d\", utcOffset) + \":00\"));\n+        updateState(\"general#\" + HeliosEasyControlsBindingConstants.SYS_DATE, new DateTimeType(sysDate));\n+        this.sysDate = sysDate;\n+    }\n+\n+    private void setSysDateTime(ZonedDateTime date) {\n+        try {\n+            this.writeValue(HeliosEasyControlsBindingConstants.DATE,\n+                    this.formatDate(HeliosEasyControlsBindingConstants.DATE, date));\n+            this.writeValue(HeliosEasyControlsBindingConstants.TIME,\n+                    date.getHour() + \":\" + date.getMinute() + \":\" + date.getSecond());\n+            this.writeValue(HeliosEasyControlsBindingConstants.TIME_ZONE_DIFFERENCE_TO_GMT,\n+                    Integer.toString(date.getOffset().getTotalSeconds() / 60 / 60));\n+        } catch (HeliosException e) {\n+            logger.warn(\"{} encountered Exception when trying to set system date: {}\",\n+                    HeliosEasyControlsHandler.class.getSimpleName(), e.getMessage());\n+        }\n+    }\n+\n+    protected void setSysDateTime() {\n+        this.setSysDateTime(ZonedDateTime.now());\n+    }\n+\n+    private void updateBypass(boolean from, boolean month, int val) {\n+        BypassDate bypassDate = from ? this.bypassFrom : this.bypassTo;\n+        if (bypassDate == null) {\n+            bypassDate = new BypassDate();\n+        }\n+        if (month) {\n+            bypassDate.setMonth(val);\n+\n+        } else {\n+            bypassDate.setDay(val);\n+        }\n+        updateState(\"unitConfig#\" + (from ? HeliosEasyControlsBindingConstants.BYPASS_FROM\n+                : HeliosEasyControlsBindingConstants.BYPASS_TO), bypassDate.toDateTimeType());\n+        if (from) {\n+            this.bypassFrom = bypassDate;\n+\n+        } else {\n+            this.bypassTo = bypassDate;\n+        }\n+    }\n+\n+    protected void setBypass(boolean from, int day, int month) {\n+        try {\n+            this.writeValue(from ? HeliosEasyControlsBindingConstants.BYPASS_FROM_DAY\n+                    : HeliosEasyControlsBindingConstants.BYPASS_TO_DAY, Integer.toString(day));\n+            this.writeValue(from ? HeliosEasyControlsBindingConstants.BYPASS_FROM_MONTH\n+                    : HeliosEasyControlsBindingConstants.BYPASS_TO_MONTH, Integer.toString(month));\n+        } catch (HeliosException e) {\n+            logger.warn(\"{} encountered Exception when trying to set bypass period: {}\",\n+                    HeliosEasyControlsHandler.class.getSimpleName(), e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Formats the provided date to a string in the device's configured date format\n+     *\n+     * @param variableName the variable name\n+     * @param date the date to be formatted\n+     * @return a string in the device's configured date format\n+     */\n+    public String formatDate(String variableName, ZonedDateTime date) {\n+        String y = Integer.toString(date.getYear());\n+        String m = Integer.toString(date.getMonthValue());\n+        if (m.length() == 1) {\n+            m = \"0\" + m;\n+        }\n+        String d = Integer.toString(date.getDayOfMonth());\n+        if (d.length() == 1) {\n+            d = \"0\" + d;\n+        }\n+        if (variableName.equals(HeliosEasyControlsBindingConstants.DATE)) { // fixed format for writing the system date\n+            return d + \".\" + m + \".\" + y;\n+        } else {\n+            switch (this.dateFormat) {\n+                case 0: // dd.mm.yyyy\n+                    return d + \".\" + m + \".\" + y;\n+                case 1: // mm.dd.yyyy\n+                    return m + \".\" + d + \".\" + y;\n+                case 2: // yyyy.mm.dd\n+                    return y + \".\" + m + \".\" + d;\n+                default:\n+                    return d + \".\" + m + \".\" + y;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns a DateTimeType object based on the provided String and the device's configured date format\n+     *\n+     * @param date The date string read from the device\n+     * @return A DateTimeType object representing the date or time specified\n+     */\n+    private DateTimeType toDateTime(String date) {\n+        String[] dateTimeParts = null;\n+        String dateTime = date;\n+        dateTimeParts = date.split(\"\\\\.\"); // try to split date components\n+        if (dateTimeParts.length == 1) { // time\n+            return DateTimeType.valueOf(date);\n+        } else if (dateTimeParts.length == 3) { // date - we'll try the device's date format\n+            switch (this.dateFormat) {\n+                case 0: // dd.mm.yyyy\n+                    dateTime = dateTimeParts[2] + \"-\" + dateTimeParts[1] + \"-\" + dateTimeParts[0];\n+                    break;\n+                case 1: // mm.dd.yyyy\n+                    dateTime = dateTimeParts[2] + \"-\" + dateTimeParts[0] + \"-\" + dateTimeParts[1];\n+                    break;\n+                case 2: // yyyy.mm.dd\n+                    dateTime = dateTimeParts[0] + \"-\" + dateTimeParts[1] + \"-\" + dateTimeParts[2];\n+                    break;\n+                default:\n+                    dateTime = dateTimeParts[2] + \"-\" + dateTimeParts[1] + \"-\" + dateTimeParts[0];\n+                    break;\n+            }\n+            return DateTimeType.valueOf(dateTime);\n+        }\n+        // falling back to default date format (apparently using the configured format has failed)\n+        dateTime = dateTimeParts[2] + \"-\" + dateTimeParts[1] + \"-\" + dateTimeParts[0];\n+        return DateTimeType.valueOf(dateTime);\n+    }\n+\n+    private @Nullable QuantityType<?> toQuantityType(String value, @Nullable String unit) {\n+        if (unit == null) {\n+            return null;\n+        } else if (unit.equals(HeliosVariable.UNIT_DAY)) {\n+            return new QuantityType<>(Integer.parseInt(value), SmartHomeUnits.DAY);\n+        } else if (unit.equals(HeliosVariable.UNIT_HOUR)) {\n+            return new QuantityType<>(Integer.parseInt(value), SmartHomeUnits.HOUR);\n+        } else if (unit.equals(HeliosVariable.UNIT_MIN)) {\n+            return new QuantityType<>(Integer.parseInt(value), SmartHomeUnits.MINUTE);\n+        } else if (unit.equals(HeliosVariable.UNIT_SEC)) {\n+            return new QuantityType<>(Integer.parseInt(value), SmartHomeUnits.SECOND);\n+        } else if (unit.equals(HeliosVariable.UNIT_VOLT)) {\n+            return new QuantityType<>(Float.parseFloat(value), SmartHomeUnits.VOLT);\n+        } else if (unit.equals(HeliosVariable.UNIT_PERCENT)) {\n+            return new QuantityType<>(Float.parseFloat(value), SmartHomeUnits.PERCENT);\n+        } else if (unit.equals(HeliosVariable.UNIT_PPM)) {\n+            return new QuantityType<>(Float.parseFloat(value), SmartHomeUnits.PARTS_PER_MILLION);\n+        } else if (unit.equals(HeliosVariable.UNIT_TEMP)) {\n+            return new QuantityType<>(Float.parseFloat(value), SIUnits.CELSIUS);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Prepares the payload for the request\n+     *\n+     * @param payload The String representation of the payload\n+     * @return The Register representation of the payload\n+     */\n+    private ModbusRegister[] preparePayload(String payload) {\n+\n+        // determine number of registers\n+        int l = (payload.length() + 1) / 2; // +1 because we need to include at least one termination symbol 0x00\n+        if ((payload.length() + 1) % 2 != 0) {\n+            l++;\n+        }\n+\n+        ModbusRegister reg[] = new ModbusRegister[l];\n+        byte[] b = payload.getBytes();\n+        int ch = 0;\n+        for (int i = 0; i < reg.length; i++) {\n+            byte b1 = ch < b.length ? b[ch] : (byte) 0x00; // terminate with 0x00 if at the end of the payload\n+            ch++;\n+            byte b2 = ch < b.length ? b[ch] : (byte) 0x00;\n+            ch++;\n+            reg[i] = new ModbusRegister(b1, b2);\n+        }\n+        return reg;\n+    }\n+\n+    /**\n+     * Decodes the Helios device' response and updates the channel with the actual value of the variable\n+     *\n+     * @param response The registers received from the Helios device\n+     * @return The value or <tt>null</tt> if an error occurred\n+     */\n+    private void processResponse(HeliosVariable v, ModbusRegisterArray registers) {\n+        // decode response\n+        byte[] b = new byte[registers.size() * 2];\n+        int actSize = 0; // track the actual size of the usable array (excluding any 0x00\n+                         // characters)\n+        for (int i = 0; i < registers.size(); i++) {\n+            byte[] reg = registers.getRegister(i).getBytes();\n+            if (reg.length == 2) { // only add to the array if it's a usable character\n+                if (reg[0] != 0x00) {\n+                    b[actSize++] = reg[0];\n+                }\n+                if (reg[1] != 0x00) {\n+                    b[actSize++] = reg[1];\n+                }\n+            }\n+        }\n+        b = Arrays.copyOf(b, actSize); // before creating a string of it the array needs to be\n+                                       // truncated\n+        String r = new String(b, StandardCharsets.US_ASCII);", "originalCommit": "225bd3dcd64b07b92cd0fb43ff9dbd968dbf72bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMyNjU1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8250#discussion_r491326556", "bodyText": "Yes, it works nicely - thanks for the hint!", "author": "bern77", "createdAt": "2020-09-19T08:17:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMyMDQwMA=="}], "type": "inlineReview"}, {"oid": "f862277724e24cd5409bcbe7a861d94e989351f0", "url": "https://github.com/openhab/openhab-addons/commit/f862277724e24cd5409bcbe7a861d94e989351f0", "message": "Implemented inputs from @ssalonen\n\nSigned-off-by: Bernhard Bauer <bern77@gmail.com>", "committedDate": "2020-09-19T08:29:24Z", "type": "commit"}]}