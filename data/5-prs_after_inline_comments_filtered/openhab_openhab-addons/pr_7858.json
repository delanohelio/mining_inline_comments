{"pr_number": 7858, "pr_title": "[heliosventilation] Helios Ventilation Binding Initial contribution", "pr_createdAt": "2020-06-04T22:23:59Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/7858", "timeline": [{"oid": "9990e798f58816cf510a02cf48be871f697f0548", "url": "https://github.com/openhab/openhab-addons/commit/9990e798f58816cf510a02cf48be871f697f0548", "message": "add new binding HelioVentilation\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2020-06-04T22:12:33Z", "type": "commit"}, {"oid": "c52601f38abf32f88039fbedc8187dbdcd33644b", "url": "https://github.com/openhab/openhab-addons/commit/c52601f38abf32f88039fbedc8187dbdcd33644b", "message": "fix file encoding\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2020-06-04T22:41:09Z", "type": "commit"}, {"oid": "361703be6950354911240a431cfdce7604537cb6", "url": "https://github.com/openhab/openhab-addons/commit/361703be6950354911240a431cfdce7604537cb6", "message": "fix whitespace issue which failed travis\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2020-06-04T22:41:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5NDk2NA==", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r435594964", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @NonNullByDefault({}) SerialPortManager serialPortManager;\n          \n          \n            \n                private SerialPortManager serialPortManager;", "author": "cpmeister", "createdAt": "2020-06-04T22:51:12Z", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandlerFactory.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import static org.openhab.binding.heliosventilation.internal.HeliosVentilationBindingConstants.THING_TYPE_HELIOS_VENTILATION;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link HeliosVentilationHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.heliosventilation\", service = ThingHandlerFactory.class)\n+public class HeliosVentilationHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections\n+            .singleton(THING_TYPE_HELIOS_VENTILATION);\n+\n+    private @NonNullByDefault({}) SerialPortManager serialPortManager;", "originalCommit": "361703be6950354911240a431cfdce7604537cb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5NjM3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r435696371", "bodyText": "Can be final", "author": "Hilbrand", "createdAt": "2020-06-05T05:24:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5NDk2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5NzIyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r435597225", "bodyText": "Why do you need to sleep here? Does InputStream.read not block for input?", "author": "cpmeister", "createdAt": "2020-06-04T22:57:58Z", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,438 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private @NonNullByDefault({}) HeliosVentilationConfiguration config;\n+\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+    private int pollCounter;\n+\n+    /**\n+     * store received data for read-modify-write operations on bitlevel\n+     */\n+    private HashMap<Byte, Byte> memory = new HashMap<Byte, Byte>();\n+\n+    public HeliosVentilationHandler(Thing thing, final SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(HeliosVentilationConfiguration.class);\n+\n+        logger.debug(\"Serial Port: {}, 9600 baud, PollPeriod: {}\", config.serialPort, config.pollPeriod);\n+\n+        if (config.serialPort.length() < 1) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return;\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+            if (this.config.pollPeriod > 0) {\n+                startPolling();\n+            }\n+        }\n+\n+        scheduler.execute(this::connect);\n+    }\n+\n+    private synchronized void connect() {\n+        logger.debug(\"HeliosVentilation: connecting...\");\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.serialPort);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Port \" + config.serialPort + \" is not known!\");\n+            serialPort = null;\n+            IOUtils.closeQuietly(inputStream);\n+            IOUtils.closeQuietly(outputStream);\n+        } else if (!isConnected()) {\n+            // initialize serial port\n+            try {\n+                SerialPort serial = portId.open(getThing().getUID().toString(), 2000);\n+                serial.setSerialPortParams(9600, SerialPort.DATABITS_8, SerialPort.STOPBITS_1, SerialPort.PARITY_NONE);\n+                serial.addEventListener(this);\n+\n+                IOUtils.closeQuietly(inputStream);\n+                IOUtils.closeQuietly(outputStream);\n+                inputStream = serial.getInputStream();\n+                outputStream = serial.getOutputStream();\n+\n+                // activate the DATA_AVAILABLE notifier\n+                serial.notifyOnDataAvailable(true);\n+                serialPort = serial;\n+                updateStatus(ThingStatus.UNKNOWN);\n+            } catch (final IOException ex) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            } catch (PortInUseException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            } catch (TooManyListenersException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Cannot attach listener to port!\");\n+            } catch (UnsupportedCommOperationException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Serial port does not support the RS485 parameters of the Helios remote protocol.\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolling();\n+        disconnect();\n+        super.dispose();\n+    }\n+\n+    /**\n+     * Start the polling task.\n+     */\n+    public synchronized void startPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && task.isCancelled()) {\n+            task.cancel(true);\n+        }\n+        if (config.pollPeriod > 0) {\n+            pollingTask = scheduler.scheduleWithFixedDelay(this::polling, 10, config.pollPeriod, TimeUnit.SECONDS);\n+        } else {\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Stop the polling task.\n+     */\n+    public synchronized void stopPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && !task.isCancelled()) {\n+            task.cancel(true);\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Method for polling the RS485 Helios RemoteContol bus\n+     */\n+    public synchronized void polling() {\n+        if (logger.isTraceEnabled()) {\n+            logger.trace(\"HeliosVentilation Polling data for '{}'\", getThing().getUID());\n+        }\n+        pollCounter++;\n+        if (pollCounter > POLL_OFFLINE_THRESHOLD) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.GONE, \"No data received!\");\n+            logger.info(\"No data received for '{}' disconnecting now...\", getThing().getUID());\n+            disconnect();\n+        }\n+\n+        if (!isConnected()) {\n+            connect(); // let's try to reconnect if the connection failed or was never established before\n+        }\n+\n+        HeliosVentilationBindingConstants.DATAPOINTS.values().forEach((v) -> {\n+            if (isLinked(v.getName())) {\n+                poll(v);\n+            }\n+        });\n+    }\n+\n+    private void disconnect() {\n+        if (thing.getStatus() != ThingStatus.REMOVING) {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+        synchronized (this) {\n+            SerialPort serial = serialPort;\n+            if (serial != null) {\n+                serial.close();\n+            }\n+        }\n+        IOUtils.closeQuietly(inputStream);\n+        IOUtils.closeQuietly(outputStream);\n+        outputStream = null;\n+        inputStream = null;\n+        serialPort = null;\n+    }\n+\n+    private void poll(HeliosVentilationDataPoint v) {\n+        byte txFrame[] = { 0x01, BUSMEMBER_ME, BUSMEMBER_MAINBOARD, 0x00, v.address(), 0x00 };\n+        txFrame[5] = (byte) checksum(txFrame);\n+\n+        tx(txFrame);\n+    }\n+\n+    /*\n+     * transmit a frame\n+     */\n+    private void tx(byte[] txFrame) {\n+        try {\n+            OutputStream out = outputStream;\n+            if (out != null) {\n+                if (logger.isTraceEnabled()) {\n+                    logger.trace(\"HeliosVentilation: Write to serial port: {}\",\n+                            String.format(\"%02x %02x %02x %02x\", txFrame[1], txFrame[2], txFrame[3], txFrame[4]));\n+                }\n+\n+                out.write(txFrame);\n+                out.flush();\n+                // after each frame we have to wait.\n+                // 30 ms is taken from what we roughly see the original remote control is doing\n+                Thread.sleep(30);\n+            }\n+        } catch (IOException e) {\n+            // in case we cannot write the connection is somehow broken, let's officially disconnect\n+            disconnect();\n+            connect();\n+        } catch (InterruptedException e) {\n+            // ignore if we got interrupted\n+        }\n+    }\n+\n+    /**\n+     * Check connection status\n+     *\n+     * @return true if currently connected\n+     */\n+    private boolean isConnected() {\n+        return serialPort != null && inputStream != null && outputStream != null;\n+    }\n+\n+    @Override\n+    public synchronized void serialEvent(SerialPortEvent event) {\n+        switch (event.getEventType()) {\n+            case SerialPortEvent.DATA_AVAILABLE:\n+                // we get here if data has been received\n+\n+                try {\n+                    // Wait roughly a frame length to increase the likelihood that the complete frame is already\n+                    // buffered. This improves the robustness for RS485/USB converters which sometimes duplicate bytes\n+                    // otherwise\n+                    Thread.sleep(8);\n+                } catch (InterruptedException e) {\n+                    // ignore interruption\n+                }\n+\n+                byte frame[] = { 0, 0, 0, 0, 0, 0 };\n+                InputStream in = inputStream;\n+                if (in != null) {\n+                    try {\n+                        do {\n+                            int cnt = 0;\n+                            do {\n+                                // read data from serial device\n+                                while (cnt < 6 && in.available() > 0) {\n+                                    final int bytes = in.read(frame, cnt, 1);\n+                                    if (cnt > 0 || frame[0] == 0x01) {\n+                                        // only proceed if the first byte was 0x01\n+                                        cnt += bytes;\n+                                    }\n+                                }\n+\n+                                if (cnt < 6 && in.available() < 1) {\n+                                    // frame not yet complete but no input available, let's wait a little to merge\n+                                    // interrupted transmissions\n+\n+                                    // 9600 baud yields about 1ms per byte, so let's wait the expected remaining time\n+                                    // for a frame\n+                                    try {\n+                                        Thread.sleep(1 * (6 - cnt));", "originalCommit": "361703be6950354911240a431cfdce7604537cb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0MjE1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r436142156", "bodyText": "good point. It is a relic from the early times, which I even reworked recently but I agree that it is not needed at all. Will remove it.", "author": "ramack", "createdAt": "2020-06-05T20:11:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5NzIyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYyODc0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r435628745", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private HashMap<Byte, Byte> memory = new HashMap<Byte, Byte>();\n          \n          \n            \n                private Map<Byte, Byte> memory = new HashMap<>();", "author": "cpmeister", "createdAt": "2020-06-05T00:31:59Z", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,438 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private @NonNullByDefault({}) HeliosVentilationConfiguration config;\n+\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+    private int pollCounter;\n+\n+    /**\n+     * store received data for read-modify-write operations on bitlevel\n+     */\n+    private HashMap<Byte, Byte> memory = new HashMap<Byte, Byte>();", "originalCommit": "361703be6950354911240a431cfdce7604537cb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYyOTI3OA==", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r435629278", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private String channelName;\n          \n          \n            \n                private String fullSpec;\n          \n          \n            \n                private String reason;\n          \n          \n            \n                private final String channelName;\n          \n          \n            \n                private final String fullSpec;\n          \n          \n            \n                private final String reason;", "author": "cpmeister", "createdAt": "2020-06-05T00:34:19Z", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosPropertiesFormatException.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link HeliosPropertiesFormatException} class defines an exception to describe parsing format errors\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosPropertiesFormatException extends Exception {\n+    private static final long serialVersionUID = 8051109351111509577L;\n+    private String channelName;\n+    private String fullSpec;\n+    private String reason;", "originalCommit": "361703be6950354911240a431cfdce7604537cb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5MzU0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r435693541", "bodyText": "We are trying to migrate away from using the apache util libraries. Can you implement this without using IOUtils?", "author": "cpmeister", "createdAt": "2020-06-05T05:12:17Z", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,438 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private @NonNullByDefault({}) HeliosVentilationConfiguration config;\n+\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+    private int pollCounter;\n+\n+    /**\n+     * store received data for read-modify-write operations on bitlevel\n+     */\n+    private HashMap<Byte, Byte> memory = new HashMap<Byte, Byte>();\n+\n+    public HeliosVentilationHandler(Thing thing, final SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(HeliosVentilationConfiguration.class);\n+\n+        logger.debug(\"Serial Port: {}, 9600 baud, PollPeriod: {}\", config.serialPort, config.pollPeriod);\n+\n+        if (config.serialPort.length() < 1) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return;\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+            if (this.config.pollPeriod > 0) {\n+                startPolling();\n+            }\n+        }\n+\n+        scheduler.execute(this::connect);\n+    }\n+\n+    private synchronized void connect() {\n+        logger.debug(\"HeliosVentilation: connecting...\");\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.serialPort);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Port \" + config.serialPort + \" is not known!\");\n+            serialPort = null;\n+            IOUtils.closeQuietly(inputStream);", "originalCommit": "361703be6950354911240a431cfdce7604537cb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5NDM1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r435694352", "bodyText": "I'm not sure that this does a proper conversion if the QuantityType supplied here is of an unexpected unit.", "author": "cpmeister", "createdAt": "2020-06-05T05:15:47Z", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationDataPoint.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+\n+/**\n+ * The {@link HeliosVentilationDataPoint} is a description of a datapoint in the Helios ventilation system.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationDataPoint {\n+    public enum DataType {\n+        TEMPERATURE,\n+        HYSTERESIS,\n+        FANSPEED,\n+        SWITCH,\n+        BYTE_PERCENT,\n+        PERCENT,\n+        NUMBER\n+    }\n+\n+    /**\n+     * mapping from temperature byte values to \u00b0C\n+     */\n+    private static final int TEMP_MAP[] = { -74, -70, -66, -62, -59, -56, -54, -52, -50, -48, -47, -46, -44, -43, -42,\n+            -41, -40, -39, -38, -37, -36, -35, -34, -33, -33, -32, -31, -30, -30, -29, -28, -28, -27, -27, -26, -25,\n+            -25, -24, -24, -23, -23, -22, -22, -21, -21, -20, -20, -19, -19, -19, -18, -18, -17, -17, -16, -16, -16,\n+            -15, -15, -14, -14, -14, -13, -13, -12, -12, -12, -11, -11, -11, -10, -10, -9, -9, -9, -8, -8, -8, -7, -7,\n+            -7, -6, -6, -6, -5, -5, -5, -4, -4, -4, -3, -3, -3, -2, -2, -2, -1, -1, -1, -1, 0, 0, 0, 1, 1, 1, 2, 2, 2,\n+            3, 3, 3, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 13,\n+            13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 18, 18, 18, 19, 19, 19, 20, 20, 21, 21, 21, 22, 22, 22,\n+            23, 23, 24, 24, 24, 25, 25, 26, 26, 27, 27, 27, 28, 28, 29, 29, 30, 30, 31, 31, 32, 32, 33, 33, 34, 34, 35,\n+            35, 36, 36, 37, 37, 38, 38, 39, 40, 40, 41, 41, 42, 43, 43, 44, 45, 45, 46, 47, 48, 48, 49, 50, 51, 52, 53,\n+            53, 54, 55, 56, 57, 59, 60, 61, 62, 63, 65, 66, 68, 69, 71, 73, 75, 77, 79, 81, 82, 86, 90, 93, 97, 100,\n+            100, 100, 100, 100, 100, 100, 100, 100 };\n+\n+    /**\n+     * mapping from human readable fanspeed to raw value\n+     */\n+    private static final int FANSPEED_MAP[] = { 0, 1, 3, 7, 15, 31, 63, 127, 255 };\n+\n+    private static final int BYTE_PERCENT_OFFSET = 52;\n+\n+    private String name;\n+    private boolean writable;\n+    private DataType datatype;\n+    private byte address;\n+    private int bitStart;\n+    private int bitLength;\n+\n+    private @Nullable HeliosVentilationDataPoint link;\n+\n+    /**\n+     * parse fullSpec in the properties format to declare a datapoint\n+     *\n+     * @param name the name of the datapoint\n+     * @param fullSpec datapoint specification, see format in datapoints.properties\n+     * @throws HeliosPropertiesFormatException in case fullSpec is not parsable\n+     */\n+    public HeliosVentilationDataPoint(String name, String fullSpec) throws HeliosPropertiesFormatException {\n+        String specWithoutComment;\n+        if (fullSpec.contains(\"#\")) {\n+            specWithoutComment = fullSpec.substring(0, fullSpec.indexOf(\"#\"));\n+        } else {\n+            specWithoutComment = fullSpec;\n+        }\n+        String[] tokens = specWithoutComment.split(\",\");\n+        this.name = name;\n+        if (tokens.length != 3) {\n+            throw new HeliosPropertiesFormatException(\"invalid length\", name, fullSpec);\n+        }\n+        try {\n+            String addr = tokens[0];\n+            String[] addrTokens;\n+            if (addr.contains(\":\")) {\n+                addrTokens = addr.split(\":\");\n+            } else {\n+                addrTokens = new String[] { addr };\n+            }\n+            bitLength = 8;\n+            bitStart = 0;\n+            this.address = (byte) (int) Integer.decode(addrTokens[0]);\n+            if (addrTokens.length > 1) {\n+                bitStart = (byte) (int) Integer.decode(addrTokens[1]);\n+                bitLength = 1;\n+            }\n+            if (addrTokens.length > 2) {\n+                bitLength = (byte) (int) Integer.decode(addrTokens[2]) - bitStart + 1;\n+            }\n+            if (addrTokens.length > 3) {\n+                throw new HeliosPropertiesFormatException(\n+                        \"invalid address spec: too many separators in bit specification\", name, fullSpec);\n+            }\n+        } catch (NumberFormatException e) {\n+            throw new HeliosPropertiesFormatException(\"invalid address spec\", name, fullSpec);\n+        }\n+\n+        this.writable = Boolean.parseBoolean(tokens[1]);\n+        try {\n+            this.datatype = DataType.valueOf(tokens[2].replaceAll(\"\\\\s+\", \"\"));\n+        } catch (IllegalArgumentException e) {\n+            throw new HeliosPropertiesFormatException(\"invalid type spec\", name, fullSpec);\n+        }\n+    }\n+\n+    public HeliosVentilationDataPoint(String name, byte address, boolean writable, DataType datatype) {\n+        this.datatype = datatype;\n+        this.writable = writable;\n+        this.name = name;\n+        this.address = address;\n+    }\n+\n+    public boolean isWritable() {\n+        return writable;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n+\n+    /**\n+     *\n+     * @return the name of the variable, which is also the channel name\n+     */\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /**\n+     *\n+     * @return address of the variable\n+     */\n+    public byte address() {\n+        return address;\n+    }\n+\n+    /**\n+     * @return the bit mask of the data point. 0xFF in case the full byte is used.\n+     */\n+    public byte bitMask() {\n+        byte mask = (byte) 0xff;\n+        if (datatype == DataType.NUMBER || datatype == DataType.SWITCH) {\n+            mask = (byte) (((1 << bitLength) - 1) << bitStart);\n+        }\n+        return mask;\n+    }\n+\n+    /**\n+     * interpret the given byte b and return the value as State.\n+     *\n+     * @param b\n+     * @return state representation of byte value b in current datatype\n+     */\n+    public State asState(byte b) {\n+        int val = b & 0xff;\n+        if (datatype == DataType.TEMPERATURE) {\n+            return new QuantityType<>(TEMP_MAP[val], SIUnits.CELSIUS);\n+        } else if (datatype == DataType.BYTE_PERCENT) {\n+            return new QuantityType<>((int) ((val - BYTE_PERCENT_OFFSET) * 100.0 / (255 - BYTE_PERCENT_OFFSET)),\n+                    SmartHomeUnits.PERCENT);\n+        } else if (datatype == DataType.SWITCH && bitLength == 1) {\n+            if ((b & (1 << bitStart)) != 0) {\n+                return OnOffType.ON;\n+            } else {\n+                return OnOffType.OFF;\n+            }\n+        } else if (datatype == DataType.NUMBER) {\n+            int value = (b & bitMask()) >> bitStart;\n+            return new DecimalType(value);\n+        } else if (datatype == DataType.PERCENT) {\n+            return new QuantityType<>(val, SmartHomeUnits.PERCENT);\n+        } else if (datatype == DataType.FANSPEED) {\n+            int i = 1;\n+            while (i < FANSPEED_MAP.length && FANSPEED_MAP[i] < val) {\n+                i++;\n+            }\n+            return new DecimalType(i);\n+        } else if (datatype == DataType.HYSTERESIS) {\n+            return new QuantityType<>(val / 3, SIUnits.CELSIUS);\n+        }\n+\n+        return UnDefType.UNDEF;\n+    }\n+\n+    /**\n+     * interpret the given byte b and return the value as string.\n+     *\n+     * @param b\n+     * @return sting representation of byte value b in current datatype\n+     */\n+    public String asString(byte b) {\n+        State ste = asState(b);\n+        String str = ste.toString();\n+        if (ste instanceof UnDefType) {\n+            return String.format(\"<unknown type> %02X \", b);\n+        } else {\n+            return str;\n+        }\n+    }\n+\n+    /**\n+     * generate byte data to transmit\n+     *\n+     * @param val is the state of a channel\n+     * @return byte value with RS485 representation. Bit level values are returned in the correct location, but other\n+     *         bits/datapoints in the same address are zero.\n+     */\n+    public byte getTransmitDataFor(State val) {\n+        byte result = 0;\n+        DecimalType value = val.as(DecimalType.class);", "originalCommit": "361703be6950354911240a431cfdce7604537cb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE1MDgyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r436150821", "bodyText": "With the unexpected unit we anyhow cannot do anything reasonable which is why the if (value == null) block is empty. And due to the thing/item types we should not get anything unexpected, should we?\nDo you have a concrete case in mind where this could happen and can you suggest something what to do here?", "author": "ramack", "createdAt": "2020-06-05T20:32:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5NDM1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE4MjQyMA==", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r436182420", "bodyText": "You simply need to convert the quantity type to the value you want:\n((QuantityType<?>) val).toUnit(SIUnits.CELSIUS).doubleValue()", "author": "cpmeister", "createdAt": "2020-06-05T21:58:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5NDM1Mg=="}], "type": "inlineReview"}, {"oid": "3090248d1c6e6ad826e8e9506a01eabf7b4c5015", "url": "https://github.com/openhab/openhab-addons/commit/3090248d1c6e6ad826e8e9506a01eabf7b4c5015", "message": "rework after review\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2020-06-05T20:37:19Z", "type": "commit"}, {"oid": "1a59f77d1c606a32180e2511e5df9e06ceb1807b", "url": "https://github.com/openhab/openhab-addons/commit/1a59f77d1c606a32180e2511e5df9e06ceb1807b", "message": "Convert QuantityType in expected unit Celcius\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2020-06-05T22:40:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMxNjA2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r436316061", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static HashMap<Byte, HeliosVentilationDataPoint> readChannelProperties() {\n          \n          \n            \n                private static Map<Byte, HeliosVentilationDataPoint> readChannelProperties() {", "author": "cpmeister", "createdAt": "2020-06-07T01:42:52Z", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationBindingConstants.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.net.URL;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.Properties;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationBindingConstants {\n+\n+    public static final String BINDING_ID = \"heliosventilation\";\n+\n+    public static final String DATAPOINT_FILE = \"datapoints.properties\";\n+\n+    // List of all Thing Type UIDs\n+    public static final ThingTypeUID THING_TYPE_HELIOS_VENTILATION = new ThingTypeUID(BINDING_ID, \"ventilation\");\n+\n+    public static final HashMap<Byte, HeliosVentilationDataPoint> DATAPOINTS;\n+\n+    private static final Logger LOGGER;\n+    static {\n+        /* logger is used by readChannelProperties() so we need to initialize logger first. */\n+        LOGGER = LoggerFactory.getLogger(HeliosVentilationBindingConstants.class);\n+        DATAPOINTS = readChannelProperties();\n+    }\n+    // List of all Channel ids\n+    // Channel ids are only in datapoints.properties and thing-types.xml\n+\n+    /**\n+     * parse datapoints from properties\n+     *\n+     */\n+    private static HashMap<Byte, HeliosVentilationDataPoint> readChannelProperties() {", "originalCommit": "1a59f77d1c606a32180e2511e5df9e06ceb1807b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMxNjA2NA==", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r436316064", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final HashMap<Byte, HeliosVentilationDataPoint> DATAPOINTS;\n          \n          \n            \n                public static final Map<Byte, HeliosVentilationDataPoint> DATAPOINTS;", "author": "cpmeister", "createdAt": "2020-06-07T01:42:59Z", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationBindingConstants.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.net.URL;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.Properties;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationBindingConstants {\n+\n+    public static final String BINDING_ID = \"heliosventilation\";\n+\n+    public static final String DATAPOINT_FILE = \"datapoints.properties\";\n+\n+    // List of all Thing Type UIDs\n+    public static final ThingTypeUID THING_TYPE_HELIOS_VENTILATION = new ThingTypeUID(BINDING_ID, \"ventilation\");\n+\n+    public static final HashMap<Byte, HeliosVentilationDataPoint> DATAPOINTS;", "originalCommit": "1a59f77d1c606a32180e2511e5df9e06ceb1807b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NTM4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r436395385", "bodyText": "configuration errors should be done in the initialize method, try to move this logic there instead.", "author": "cpmeister", "createdAt": "2020-06-07T19:43:39Z", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,454 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private @NonNullByDefault({}) HeliosVentilationConfiguration config;\n+\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+    private int pollCounter;\n+\n+    /**\n+     * store received data for read-modify-write operations on bitlevel\n+     */\n+    private Map<Byte, Byte> memory = new HashMap<Byte, Byte>();\n+\n+    public HeliosVentilationHandler(Thing thing, final SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(HeliosVentilationConfiguration.class);\n+\n+        logger.debug(\"Serial Port: {}, 9600 baud, PollPeriod: {}\", config.serialPort, config.pollPeriod);\n+\n+        if (config.serialPort.length() < 1) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return;\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+            if (this.config.pollPeriod > 0) {\n+                startPolling();\n+            }\n+        }\n+\n+        scheduler.execute(this::connect);\n+    }\n+\n+    private synchronized void connect() {\n+        logger.debug(\"HeliosVentilation: connecting...\");\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.serialPort);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Port \" + config.serialPort + \" is not known!\");\n+            serialPort = null;", "originalCommit": "1a59f77d1c606a32180e2511e5df9e06ceb1807b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTYzMjg5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r439632899", "bodyText": "As the port can also get removed after init (e.g. if a USB interface is unplugged) I think we should keep it here, but for sure we can add it in initialize().", "author": "ramack", "createdAt": "2020-06-12T20:40:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NTM4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NTgxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r436395815", "bodyText": "it doesn't look like this outer while loop serves any purpose.", "author": "cpmeister", "createdAt": "2020-06-07T19:49:05Z", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,454 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private @NonNullByDefault({}) HeliosVentilationConfiguration config;\n+\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+    private int pollCounter;\n+\n+    /**\n+     * store received data for read-modify-write operations on bitlevel\n+     */\n+    private Map<Byte, Byte> memory = new HashMap<Byte, Byte>();\n+\n+    public HeliosVentilationHandler(Thing thing, final SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(HeliosVentilationConfiguration.class);\n+\n+        logger.debug(\"Serial Port: {}, 9600 baud, PollPeriod: {}\", config.serialPort, config.pollPeriod);\n+\n+        if (config.serialPort.length() < 1) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return;\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+            if (this.config.pollPeriod > 0) {\n+                startPolling();\n+            }\n+        }\n+\n+        scheduler.execute(this::connect);\n+    }\n+\n+    private synchronized void connect() {\n+        logger.debug(\"HeliosVentilation: connecting...\");\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.serialPort);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Port \" + config.serialPort + \" is not known!\");\n+            serialPort = null;\n+\n+            disconnect();\n+        } else if (!isConnected()) {\n+            // initialize serial port\n+            try {\n+                SerialPort serial = portId.open(getThing().getUID().toString(), 2000);\n+                serial.setSerialPortParams(9600, SerialPort.DATABITS_8, SerialPort.STOPBITS_1, SerialPort.PARITY_NONE);\n+                serial.addEventListener(this);\n+\n+                try {\n+                    if (inputStream != null) {\n+                        inputStream.close();\n+                    }\n+                } catch (IOException e) {\n+                    // ignore the exception on close\n+                    inputStream = null;\n+                }\n+                try {\n+                    if (outputStream != null) {\n+                        outputStream.close();\n+                    }\n+                } catch (IOException e) {\n+                    // ignore the exception on close\n+                    outputStream = null;\n+                }\n+\n+                inputStream = serial.getInputStream();\n+                outputStream = serial.getOutputStream();\n+\n+                // activate the DATA_AVAILABLE notifier\n+                serial.notifyOnDataAvailable(true);\n+                serialPort = serial;\n+                updateStatus(ThingStatus.UNKNOWN);\n+            } catch (final IOException ex) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            } catch (PortInUseException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            } catch (TooManyListenersException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Cannot attach listener to port!\");\n+            } catch (UnsupportedCommOperationException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Serial port does not support the RS485 parameters of the Helios remote protocol.\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolling();\n+        disconnect();\n+        super.dispose();\n+    }\n+\n+    /**\n+     * Start the polling task.\n+     */\n+    public synchronized void startPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && task.isCancelled()) {\n+            task.cancel(true);\n+        }\n+        if (config.pollPeriod > 0) {\n+            pollingTask = scheduler.scheduleWithFixedDelay(this::polling, 10, config.pollPeriod, TimeUnit.SECONDS);\n+        } else {\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Stop the polling task.\n+     */\n+    public synchronized void stopPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && !task.isCancelled()) {\n+            task.cancel(true);\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Method for polling the RS485 Helios RemoteContol bus\n+     */\n+    public synchronized void polling() {\n+        if (logger.isTraceEnabled()) {\n+            logger.trace(\"HeliosVentilation Polling data for '{}'\", getThing().getUID());\n+        }\n+        pollCounter++;\n+        if (pollCounter > POLL_OFFLINE_THRESHOLD) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.GONE, \"No data received!\");\n+            logger.info(\"No data received for '{}' disconnecting now...\", getThing().getUID());\n+            disconnect();\n+        }\n+\n+        if (!isConnected()) {\n+            connect(); // let's try to reconnect if the connection failed or was never established before\n+        }\n+\n+        HeliosVentilationBindingConstants.DATAPOINTS.values().forEach((v) -> {\n+            if (isLinked(v.getName())) {\n+                poll(v);\n+            }\n+        });\n+    }\n+\n+    private void disconnect() {\n+        if (thing.getStatus() != ThingStatus.REMOVING) {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+        synchronized (this) {\n+            try {\n+                if (inputStream != null) {\n+                    inputStream.close();\n+                }\n+            } catch (IOException e) {\n+                // ignore the exception on close\n+                inputStream = null;\n+            }\n+            try {\n+                if (outputStream != null) {\n+                    outputStream.close();\n+                }\n+            } catch (IOException e) {\n+                // ignore the exception on close\n+                outputStream = null;\n+            }\n+\n+            SerialPort serial = serialPort;\n+            if (serial != null) {\n+                serial.close();\n+            }\n+            serialPort = null;\n+        }\n+\n+    }\n+\n+    private void poll(HeliosVentilationDataPoint v) {\n+        byte txFrame[] = { 0x01, BUSMEMBER_ME, BUSMEMBER_MAINBOARD, 0x00, v.address(), 0x00 };\n+        txFrame[5] = (byte) checksum(txFrame);\n+\n+        tx(txFrame);\n+    }\n+\n+    /*\n+     * transmit a frame\n+     */\n+    private void tx(byte[] txFrame) {\n+        try {\n+            OutputStream out = outputStream;\n+            if (out != null) {\n+                if (logger.isTraceEnabled()) {\n+                    logger.trace(\"HeliosVentilation: Write to serial port: {}\",\n+                            String.format(\"%02x %02x %02x %02x\", txFrame[1], txFrame[2], txFrame[3], txFrame[4]));\n+                }\n+\n+                out.write(txFrame);\n+                out.flush();\n+                // after each frame we have to wait.\n+                // 30 ms is taken from what we roughly see the original remote control is doing\n+                Thread.sleep(30);\n+            }\n+        } catch (IOException e) {\n+            // in case we cannot write the connection is somehow broken, let's officially disconnect\n+            disconnect();\n+            connect();\n+        } catch (InterruptedException e) {\n+            // ignore if we got interrupted\n+        }\n+    }\n+\n+    /**\n+     * Check connection status\n+     *\n+     * @return true if currently connected\n+     */\n+    private boolean isConnected() {\n+        return serialPort != null && inputStream != null && outputStream != null;\n+    }\n+\n+    @Override\n+    public synchronized void serialEvent(SerialPortEvent event) {\n+        switch (event.getEventType()) {\n+            case SerialPortEvent.DATA_AVAILABLE:\n+                // we get here if data has been received\n+\n+                try {\n+                    // Wait roughly a frame length to increase the likelihood that the complete frame is already\n+                    // buffered. This improves the robustness for RS485/USB converters which sometimes duplicate bytes\n+                    // otherwise\n+                    Thread.sleep(8);\n+                } catch (InterruptedException e) {\n+                    // ignore interruption\n+                }\n+\n+                byte frame[] = { 0, 0, 0, 0, 0, 0 };\n+                InputStream in = inputStream;\n+                if (in != null) {\n+                    try {\n+                        do {\n+                            int cnt = 0;\n+                            do {\n+                                // read data from serial device\n+                                while (cnt < 6 && in.available() > 0) {\n+                                    final int bytes = in.read(frame, cnt, 1);\n+                                    if (cnt > 0 || frame[0] == 0x01) {\n+                                        // only proceed if the first byte was 0x01\n+                                        cnt += bytes;\n+                                    }\n+                                }\n+                            } while (in.available() > 0 && cnt < 6);", "originalCommit": "1a59f77d1c606a32180e2511e5df9e06ceb1807b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTYzNDQ1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r439634456", "bodyText": "in case there are already more than 6 bytes read, the outer loop is there to start reading directly the next (already partially received) frame", "author": "ramack", "createdAt": "2020-06-12T20:44:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NTgxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTYzNTIyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r439635229", "bodyText": "ah no, you mean the \"inner\" outer loop :-) that one is useless I agree.", "author": "ramack", "createdAt": "2020-06-12T20:46:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NTgxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NjAwMA==", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r436396000", "bodyText": "why do you mean \"increase the likelihood\"? Is it possible to implement this in a foolproof manner?", "author": "cpmeister", "createdAt": "2020-06-07T19:51:10Z", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,454 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private @NonNullByDefault({}) HeliosVentilationConfiguration config;\n+\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+    private int pollCounter;\n+\n+    /**\n+     * store received data for read-modify-write operations on bitlevel\n+     */\n+    private Map<Byte, Byte> memory = new HashMap<Byte, Byte>();\n+\n+    public HeliosVentilationHandler(Thing thing, final SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(HeliosVentilationConfiguration.class);\n+\n+        logger.debug(\"Serial Port: {}, 9600 baud, PollPeriod: {}\", config.serialPort, config.pollPeriod);\n+\n+        if (config.serialPort.length() < 1) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return;\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+            if (this.config.pollPeriod > 0) {\n+                startPolling();\n+            }\n+        }\n+\n+        scheduler.execute(this::connect);\n+    }\n+\n+    private synchronized void connect() {\n+        logger.debug(\"HeliosVentilation: connecting...\");\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.serialPort);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Port \" + config.serialPort + \" is not known!\");\n+            serialPort = null;\n+\n+            disconnect();\n+        } else if (!isConnected()) {\n+            // initialize serial port\n+            try {\n+                SerialPort serial = portId.open(getThing().getUID().toString(), 2000);\n+                serial.setSerialPortParams(9600, SerialPort.DATABITS_8, SerialPort.STOPBITS_1, SerialPort.PARITY_NONE);\n+                serial.addEventListener(this);\n+\n+                try {\n+                    if (inputStream != null) {\n+                        inputStream.close();\n+                    }\n+                } catch (IOException e) {\n+                    // ignore the exception on close\n+                    inputStream = null;\n+                }\n+                try {\n+                    if (outputStream != null) {\n+                        outputStream.close();\n+                    }\n+                } catch (IOException e) {\n+                    // ignore the exception on close\n+                    outputStream = null;\n+                }\n+\n+                inputStream = serial.getInputStream();\n+                outputStream = serial.getOutputStream();\n+\n+                // activate the DATA_AVAILABLE notifier\n+                serial.notifyOnDataAvailable(true);\n+                serialPort = serial;\n+                updateStatus(ThingStatus.UNKNOWN);\n+            } catch (final IOException ex) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            } catch (PortInUseException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            } catch (TooManyListenersException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Cannot attach listener to port!\");\n+            } catch (UnsupportedCommOperationException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Serial port does not support the RS485 parameters of the Helios remote protocol.\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolling();\n+        disconnect();\n+        super.dispose();\n+    }\n+\n+    /**\n+     * Start the polling task.\n+     */\n+    public synchronized void startPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && task.isCancelled()) {\n+            task.cancel(true);\n+        }\n+        if (config.pollPeriod > 0) {\n+            pollingTask = scheduler.scheduleWithFixedDelay(this::polling, 10, config.pollPeriod, TimeUnit.SECONDS);\n+        } else {\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Stop the polling task.\n+     */\n+    public synchronized void stopPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && !task.isCancelled()) {\n+            task.cancel(true);\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Method for polling the RS485 Helios RemoteContol bus\n+     */\n+    public synchronized void polling() {\n+        if (logger.isTraceEnabled()) {\n+            logger.trace(\"HeliosVentilation Polling data for '{}'\", getThing().getUID());\n+        }\n+        pollCounter++;\n+        if (pollCounter > POLL_OFFLINE_THRESHOLD) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.GONE, \"No data received!\");\n+            logger.info(\"No data received for '{}' disconnecting now...\", getThing().getUID());\n+            disconnect();\n+        }\n+\n+        if (!isConnected()) {\n+            connect(); // let's try to reconnect if the connection failed or was never established before\n+        }\n+\n+        HeliosVentilationBindingConstants.DATAPOINTS.values().forEach((v) -> {\n+            if (isLinked(v.getName())) {\n+                poll(v);\n+            }\n+        });\n+    }\n+\n+    private void disconnect() {\n+        if (thing.getStatus() != ThingStatus.REMOVING) {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+        synchronized (this) {\n+            try {\n+                if (inputStream != null) {\n+                    inputStream.close();\n+                }\n+            } catch (IOException e) {\n+                // ignore the exception on close\n+                inputStream = null;\n+            }\n+            try {\n+                if (outputStream != null) {\n+                    outputStream.close();\n+                }\n+            } catch (IOException e) {\n+                // ignore the exception on close\n+                outputStream = null;\n+            }\n+\n+            SerialPort serial = serialPort;\n+            if (serial != null) {\n+                serial.close();\n+            }\n+            serialPort = null;\n+        }\n+\n+    }\n+\n+    private void poll(HeliosVentilationDataPoint v) {\n+        byte txFrame[] = { 0x01, BUSMEMBER_ME, BUSMEMBER_MAINBOARD, 0x00, v.address(), 0x00 };\n+        txFrame[5] = (byte) checksum(txFrame);\n+\n+        tx(txFrame);\n+    }\n+\n+    /*\n+     * transmit a frame\n+     */\n+    private void tx(byte[] txFrame) {\n+        try {\n+            OutputStream out = outputStream;\n+            if (out != null) {\n+                if (logger.isTraceEnabled()) {\n+                    logger.trace(\"HeliosVentilation: Write to serial port: {}\",\n+                            String.format(\"%02x %02x %02x %02x\", txFrame[1], txFrame[2], txFrame[3], txFrame[4]));\n+                }\n+\n+                out.write(txFrame);\n+                out.flush();\n+                // after each frame we have to wait.\n+                // 30 ms is taken from what we roughly see the original remote control is doing\n+                Thread.sleep(30);\n+            }\n+        } catch (IOException e) {\n+            // in case we cannot write the connection is somehow broken, let's officially disconnect\n+            disconnect();\n+            connect();\n+        } catch (InterruptedException e) {\n+            // ignore if we got interrupted\n+        }\n+    }\n+\n+    /**\n+     * Check connection status\n+     *\n+     * @return true if currently connected\n+     */\n+    private boolean isConnected() {\n+        return serialPort != null && inputStream != null && outputStream != null;\n+    }\n+\n+    @Override\n+    public synchronized void serialEvent(SerialPortEvent event) {\n+        switch (event.getEventType()) {\n+            case SerialPortEvent.DATA_AVAILABLE:\n+                // we get here if data has been received\n+\n+                try {\n+                    // Wait roughly a frame length to increase the likelihood that the complete frame is already\n+                    // buffered. This improves the robustness for RS485/USB converters which sometimes duplicate bytes\n+                    // otherwise\n+                    Thread.sleep(8);", "originalCommit": "1a59f77d1c606a32180e2511e5df9e06ceb1807b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTYzODA0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r439638043", "bodyText": "I recently changed that already compared to the initial (abandoned) PR from 5 to 8, which was the change from \"improving\" to surly waiting until the frame is fully buffered. Will update the comment accordingly.", "author": "ramack", "createdAt": "2020-06-12T20:54:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NjAwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NjExMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r436396111", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            byte frame[] = { 0, 0, 0, 0, 0, 0 };\n          \n          \n            \n                            byte[] frame = { 0, 0, 0, 0, 0, 0 };", "author": "cpmeister", "createdAt": "2020-06-07T19:52:29Z", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,454 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private @NonNullByDefault({}) HeliosVentilationConfiguration config;\n+\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+    private int pollCounter;\n+\n+    /**\n+     * store received data for read-modify-write operations on bitlevel\n+     */\n+    private Map<Byte, Byte> memory = new HashMap<Byte, Byte>();\n+\n+    public HeliosVentilationHandler(Thing thing, final SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(HeliosVentilationConfiguration.class);\n+\n+        logger.debug(\"Serial Port: {}, 9600 baud, PollPeriod: {}\", config.serialPort, config.pollPeriod);\n+\n+        if (config.serialPort.length() < 1) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return;\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+            if (this.config.pollPeriod > 0) {\n+                startPolling();\n+            }\n+        }\n+\n+        scheduler.execute(this::connect);\n+    }\n+\n+    private synchronized void connect() {\n+        logger.debug(\"HeliosVentilation: connecting...\");\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.serialPort);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Port \" + config.serialPort + \" is not known!\");\n+            serialPort = null;\n+\n+            disconnect();\n+        } else if (!isConnected()) {\n+            // initialize serial port\n+            try {\n+                SerialPort serial = portId.open(getThing().getUID().toString(), 2000);\n+                serial.setSerialPortParams(9600, SerialPort.DATABITS_8, SerialPort.STOPBITS_1, SerialPort.PARITY_NONE);\n+                serial.addEventListener(this);\n+\n+                try {\n+                    if (inputStream != null) {\n+                        inputStream.close();\n+                    }\n+                } catch (IOException e) {\n+                    // ignore the exception on close\n+                    inputStream = null;\n+                }\n+                try {\n+                    if (outputStream != null) {\n+                        outputStream.close();\n+                    }\n+                } catch (IOException e) {\n+                    // ignore the exception on close\n+                    outputStream = null;\n+                }\n+\n+                inputStream = serial.getInputStream();\n+                outputStream = serial.getOutputStream();\n+\n+                // activate the DATA_AVAILABLE notifier\n+                serial.notifyOnDataAvailable(true);\n+                serialPort = serial;\n+                updateStatus(ThingStatus.UNKNOWN);\n+            } catch (final IOException ex) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            } catch (PortInUseException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            } catch (TooManyListenersException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Cannot attach listener to port!\");\n+            } catch (UnsupportedCommOperationException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Serial port does not support the RS485 parameters of the Helios remote protocol.\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolling();\n+        disconnect();\n+        super.dispose();\n+    }\n+\n+    /**\n+     * Start the polling task.\n+     */\n+    public synchronized void startPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && task.isCancelled()) {\n+            task.cancel(true);\n+        }\n+        if (config.pollPeriod > 0) {\n+            pollingTask = scheduler.scheduleWithFixedDelay(this::polling, 10, config.pollPeriod, TimeUnit.SECONDS);\n+        } else {\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Stop the polling task.\n+     */\n+    public synchronized void stopPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && !task.isCancelled()) {\n+            task.cancel(true);\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Method for polling the RS485 Helios RemoteContol bus\n+     */\n+    public synchronized void polling() {\n+        if (logger.isTraceEnabled()) {\n+            logger.trace(\"HeliosVentilation Polling data for '{}'\", getThing().getUID());\n+        }\n+        pollCounter++;\n+        if (pollCounter > POLL_OFFLINE_THRESHOLD) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.GONE, \"No data received!\");\n+            logger.info(\"No data received for '{}' disconnecting now...\", getThing().getUID());\n+            disconnect();\n+        }\n+\n+        if (!isConnected()) {\n+            connect(); // let's try to reconnect if the connection failed or was never established before\n+        }\n+\n+        HeliosVentilationBindingConstants.DATAPOINTS.values().forEach((v) -> {\n+            if (isLinked(v.getName())) {\n+                poll(v);\n+            }\n+        });\n+    }\n+\n+    private void disconnect() {\n+        if (thing.getStatus() != ThingStatus.REMOVING) {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+        synchronized (this) {\n+            try {\n+                if (inputStream != null) {\n+                    inputStream.close();\n+                }\n+            } catch (IOException e) {\n+                // ignore the exception on close\n+                inputStream = null;\n+            }\n+            try {\n+                if (outputStream != null) {\n+                    outputStream.close();\n+                }\n+            } catch (IOException e) {\n+                // ignore the exception on close\n+                outputStream = null;\n+            }\n+\n+            SerialPort serial = serialPort;\n+            if (serial != null) {\n+                serial.close();\n+            }\n+            serialPort = null;\n+        }\n+\n+    }\n+\n+    private void poll(HeliosVentilationDataPoint v) {\n+        byte txFrame[] = { 0x01, BUSMEMBER_ME, BUSMEMBER_MAINBOARD, 0x00, v.address(), 0x00 };\n+        txFrame[5] = (byte) checksum(txFrame);\n+\n+        tx(txFrame);\n+    }\n+\n+    /*\n+     * transmit a frame\n+     */\n+    private void tx(byte[] txFrame) {\n+        try {\n+            OutputStream out = outputStream;\n+            if (out != null) {\n+                if (logger.isTraceEnabled()) {\n+                    logger.trace(\"HeliosVentilation: Write to serial port: {}\",\n+                            String.format(\"%02x %02x %02x %02x\", txFrame[1], txFrame[2], txFrame[3], txFrame[4]));\n+                }\n+\n+                out.write(txFrame);\n+                out.flush();\n+                // after each frame we have to wait.\n+                // 30 ms is taken from what we roughly see the original remote control is doing\n+                Thread.sleep(30);\n+            }\n+        } catch (IOException e) {\n+            // in case we cannot write the connection is somehow broken, let's officially disconnect\n+            disconnect();\n+            connect();\n+        } catch (InterruptedException e) {\n+            // ignore if we got interrupted\n+        }\n+    }\n+\n+    /**\n+     * Check connection status\n+     *\n+     * @return true if currently connected\n+     */\n+    private boolean isConnected() {\n+        return serialPort != null && inputStream != null && outputStream != null;\n+    }\n+\n+    @Override\n+    public synchronized void serialEvent(SerialPortEvent event) {\n+        switch (event.getEventType()) {\n+            case SerialPortEvent.DATA_AVAILABLE:\n+                // we get here if data has been received\n+\n+                try {\n+                    // Wait roughly a frame length to increase the likelihood that the complete frame is already\n+                    // buffered. This improves the robustness for RS485/USB converters which sometimes duplicate bytes\n+                    // otherwise\n+                    Thread.sleep(8);\n+                } catch (InterruptedException e) {\n+                    // ignore interruption\n+                }\n+\n+                byte frame[] = { 0, 0, 0, 0, 0, 0 };", "originalCommit": "1a59f77d1c606a32180e2511e5df9e06ceb1807b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NjI2NA==", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r436396264", "bodyText": "There is a bug in the core that causes handleCommand to sometimes get called before the handler's initialize is called. So we recommend to just populate the configuration with a default instance to avoid NPE issues.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @NonNullByDefault({}) HeliosVentilationConfiguration config;\n          \n          \n            \n                private HeliosVentilationConfiguration config = new HeliosVentilationConfiguration();", "author": "cpmeister", "createdAt": "2020-06-07T19:54:54Z", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,454 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private @NonNullByDefault({}) HeliosVentilationConfiguration config;", "originalCommit": "1a59f77d1c606a32180e2511e5df9e06ceb1807b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7b1658af39ccc8a2f98f4cc318896c32ee4ff9a4", "url": "https://github.com/openhab/openhab-addons/commit/7b1658af39ccc8a2f98f4cc318896c32ee4ff9a4", "message": "rework after review\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2020-06-12T21:05:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MTUyMA==", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r439681520", "bodyText": "if thing.getStatus() == ThingStatus.REMOVING shouldn't you exit early?", "author": "cpmeister", "createdAt": "2020-06-12T23:44:10Z", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,459 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    /* init to default to avoid NPE in case handleCommand() is called before initialize() */\n+    private HeliosVentilationConfiguration config = new HeliosVentilationConfiguration();\n+\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+    private int pollCounter;\n+\n+    /**\n+     * store received data for read-modify-write operations on bitlevel\n+     */\n+    private Map<Byte, Byte> memory = new HashMap<Byte, Byte>();\n+\n+    public HeliosVentilationHandler(Thing thing, final SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(HeliosVentilationConfiguration.class);\n+\n+        logger.debug(\"Serial Port: {}, 9600 baud, PollPeriod: {}\", config.serialPort, config.pollPeriod);\n+\n+        if (config.serialPort.length() < 1) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return;\n+        } else {\n+            SerialPortIdentifier portId = serialPortManager.getIdentifier(config.serialPort);\n+            if (portId == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Port \" + config.serialPort + \" is not known!\");\n+                serialPort = null;\n+            } else {\n+                updateStatus(ThingStatus.UNKNOWN);\n+                if (this.config.pollPeriod > 0) {\n+                    startPolling();\n+                }\n+            }\n+        }\n+\n+        scheduler.execute(this::connect);\n+    }\n+\n+    private synchronized void connect() {\n+        logger.debug(\"HeliosVentilation: connecting...\");\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.serialPort);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Port \" + config.serialPort + \" is not known!\");\n+            serialPort = null;\n+\n+            disconnect();\n+        } else if (!isConnected()) {\n+            // initialize serial port\n+            try {\n+                SerialPort serial = portId.open(getThing().getUID().toString(), 2000);\n+                serial.setSerialPortParams(9600, SerialPort.DATABITS_8, SerialPort.STOPBITS_1, SerialPort.PARITY_NONE);\n+                serial.addEventListener(this);\n+\n+                try {\n+                    if (inputStream != null) {\n+                        inputStream.close();\n+                    }\n+                } catch (IOException e) {\n+                    // ignore the exception on close\n+                    inputStream = null;\n+                }\n+                try {\n+                    if (outputStream != null) {\n+                        outputStream.close();\n+                    }\n+                } catch (IOException e) {\n+                    // ignore the exception on close\n+                    outputStream = null;\n+                }\n+\n+                inputStream = serial.getInputStream();\n+                outputStream = serial.getOutputStream();\n+\n+                // activate the DATA_AVAILABLE notifier\n+                serial.notifyOnDataAvailable(true);\n+                serialPort = serial;\n+                updateStatus(ThingStatus.UNKNOWN);\n+            } catch (final IOException ex) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            } catch (PortInUseException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            } catch (TooManyListenersException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Cannot attach listener to port!\");\n+            } catch (UnsupportedCommOperationException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Serial port does not support the RS485 parameters of the Helios remote protocol.\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolling();\n+        disconnect();\n+        super.dispose();\n+    }\n+\n+    /**\n+     * Start the polling task.\n+     */\n+    public synchronized void startPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && task.isCancelled()) {\n+            task.cancel(true);\n+        }\n+        if (config.pollPeriod > 0) {\n+            pollingTask = scheduler.scheduleWithFixedDelay(this::polling, 10, config.pollPeriod, TimeUnit.SECONDS);\n+        } else {\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Stop the polling task.\n+     */\n+    public synchronized void stopPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && !task.isCancelled()) {\n+            task.cancel(true);\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Method for polling the RS485 Helios RemoteContol bus\n+     */\n+    public synchronized void polling() {\n+        if (logger.isTraceEnabled()) {\n+            logger.trace(\"HeliosVentilation Polling data for '{}'\", getThing().getUID());\n+        }\n+        pollCounter++;\n+        if (pollCounter > POLL_OFFLINE_THRESHOLD) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.GONE, \"No data received!\");\n+            logger.info(\"No data received for '{}' disconnecting now...\", getThing().getUID());\n+            disconnect();\n+        }\n+\n+        if (!isConnected()) {\n+            connect(); // let's try to reconnect if the connection failed or was never established before\n+        }\n+\n+        HeliosVentilationBindingConstants.DATAPOINTS.values().forEach((v) -> {\n+            if (isLinked(v.getName())) {\n+                poll(v);\n+            }\n+        });\n+    }\n+\n+    private void disconnect() {\n+        if (thing.getStatus() != ThingStatus.REMOVING) {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+        synchronized (this) {\n+            try {\n+                if (inputStream != null) {\n+                    inputStream.close();\n+                }\n+            } catch (IOException e) {\n+                // ignore the exception on close\n+                inputStream = null;\n+            }\n+            try {\n+                if (outputStream != null) {\n+                    outputStream.close();\n+                }\n+            } catch (IOException e) {\n+                // ignore the exception on close\n+                outputStream = null;\n+            }\n+\n+            SerialPort serial = serialPort;\n+            if (serial != null) {\n+                serial.close();\n+            }\n+            serialPort = null;\n+        }\n+\n+    }\n+\n+    private void poll(HeliosVentilationDataPoint v) {\n+        byte[] txFrame = { 0x01, BUSMEMBER_ME, BUSMEMBER_MAINBOARD, 0x00, v.address(), 0x00 };\n+        txFrame[5] = (byte) checksum(txFrame);\n+\n+        tx(txFrame);\n+    }\n+\n+    /*\n+     * transmit a frame\n+     */\n+    private void tx(byte[] txFrame) {\n+        try {\n+            OutputStream out = outputStream;\n+            if (out != null) {\n+                if (logger.isTraceEnabled()) {\n+                    logger.trace(\"HeliosVentilation: Write to serial port: {}\",\n+                            String.format(\"%02x %02x %02x %02x\", txFrame[1], txFrame[2], txFrame[3], txFrame[4]));\n+                }\n+\n+                out.write(txFrame);\n+                out.flush();\n+                // after each frame we have to wait.\n+                // 30 ms is taken from what we roughly see the original remote control is doing\n+                Thread.sleep(30);\n+            }\n+        } catch (IOException e) {\n+            // in case we cannot write the connection is somehow broken, let's officially disconnect\n+            disconnect();\n+            connect();\n+        } catch (InterruptedException e) {\n+            // ignore if we got interrupted\n+        }\n+    }\n+\n+    /**\n+     * Check connection status\n+     *\n+     * @return true if currently connected\n+     */\n+    private boolean isConnected() {\n+        return serialPort != null && inputStream != null && outputStream != null;\n+    }\n+\n+    @Override\n+    public synchronized void serialEvent(SerialPortEvent event) {\n+        switch (event.getEventType()) {\n+            case SerialPortEvent.DATA_AVAILABLE:\n+                // we get here if data has been received\n+\n+                try {\n+                    // Wait roughly a frame length to ensure that the complete frame is already buffered. This improves\n+                    // the robustness for RS485/USB converters which sometimes duplicate bytes otherwise.\n+                    Thread.sleep(8);\n+                } catch (InterruptedException e) {\n+                    // ignore interruption\n+                }\n+\n+                byte[] frame = { 0, 0, 0, 0, 0, 0 };\n+                InputStream in = inputStream;\n+                if (in != null) {\n+                    try {\n+                        do {\n+                            int cnt = 0;\n+                            // read data from serial device\n+                            while (cnt < 6 && in.available() > 0) {\n+                                final int bytes = in.read(frame, cnt, 1);\n+                                if (cnt > 0 || frame[0] == 0x01) {\n+                                    // only proceed if the first byte was 0x01\n+                                    cnt += bytes;\n+                                }\n+                            }\n+                            int sum = checksum(frame);\n+                            if (sum == (frame[5] & 0xff)) {\n+                                if (logger.isTraceEnabled()) {\n+                                    logger.trace(\"HeliosVentilation: Read from serial port: {}\", String\n+                                            .format(\"%02x %02x %02x %02x\", frame[1], frame[2], frame[3], frame[4]));\n+                                }\n+                                interpretFrame(frame);\n+\n+                            } else {\n+                                if (logger.isTraceEnabled()) {\n+                                    logger.trace(\n+                                            \"HeliosVentilation: Read frame with not matching checksum from serial port: {}\",\n+                                            String.format(\"%02x %02x %02x %02x %02x %02x (expected %02x)\", frame[0],\n+                                                    frame[1], frame[2], frame[3], frame[4], frame[5], sum));\n+                                }\n+\n+                            }\n+\n+                        } while (in.available() > 0);\n+\n+                    } catch (IOException e1) {\n+                        logger.debug(\"Error reading from serial port: {}\", e1.getMessage(), e1);\n+                    }\n+                }\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            scheduler.execute(this::polling);\n+        } else if (command instanceof DecimalType || command instanceof QuantityType || command instanceof OnOffType) {\n+            scheduler.execute(() -> update(channelUID, command));\n+        }\n+    }\n+\n+    /**\n+     * Update the variable corresponding to given channel/command\n+     *\n+     * @param channelUID UID of the channel to update\n+     * @param command data element to write\n+     *\n+     */\n+    public void update(ChannelUID channelUID, Command command) {\n+        HeliosVentilationBindingConstants.DATAPOINTS.values().forEach((outer) -> {\n+            HeliosVentilationDataPoint v = outer;\n+            do {\n+                if (channelUID.getThingUID().equals(thing.getUID()) && v.getName().equals(channelUID.getId())) {\n+                    if (v.isWritable()) {\n+                        byte[] txFrame = { 0x01, BUSMEMBER_ME, BUSMEMBER_CONTROLBOARDS, v.address(), 0x00, 0x00 };\n+                        txFrame[4] = v.getTransmitDataFor((State) command);\n+                        if (v.requiresReadModifyWrite()) {\n+                            txFrame[4] |= memory.get(v.address()) & ~v.bitMask();\n+                            memory.put(v.address(), txFrame[4]);\n+                        }\n+                        txFrame[5] = (byte) checksum(txFrame);\n+                        tx(txFrame);\n+\n+                        txFrame[2] = BUSMEMBER_SLAVEBOARDS;\n+                        txFrame[5] = (byte) checksum(txFrame);\n+                        tx(txFrame);\n+\n+                        txFrame[2] = BUSMEMBER_MAINBOARD;\n+                        txFrame[5] = (byte) checksum(txFrame);\n+                        tx(txFrame);\n+                    }\n+                }\n+                v = v.link();\n+            } while (v != null);\n+        });\n+\n+    }\n+\n+    /**\n+     * calculate checksum of a frame\n+     *\n+     * @param frame filled with 5 bytes\n+     * @return checksum of the first 5 bytes of frame\n+     */\n+    private int checksum(byte[] frame) {\n+        int sum = 0;\n+        for (int a = 0; a < 5; a++) {\n+            sum += frame[a] & 0xff;\n+        }\n+        sum %= 256;\n+        return sum;\n+    }\n+\n+    /**\n+     * interpret a frame, which is already validated to be in correct format with valid checksum\n+     *\n+     * @param frame 6 bytes long data with 0x01, sender, receiver, address, value, checksum\n+     */\n+    private void interpretFrame(byte[] frame) {\n+        if ((frame[2] & BUSMEMBER_REC_MASK) == (BUSMEMBER_ME & BUSMEMBER_REC_MASK)) {\n+            // something to read for us\n+            byte var = frame[3];\n+            byte val = frame[4];\n+            if (HeliosVentilationBindingConstants.DATAPOINTS.containsKey(var)) {\n+                HeliosVentilationDataPoint datapoint = HeliosVentilationBindingConstants.DATAPOINTS.get(var);\n+                if (datapoint.requiresReadModifyWrite()) {\n+                    memory.put(var, val);\n+                }\n+                do {\n+                    if (logger.isTraceEnabled()) {\n+                        String t = datapoint.asString(val);\n+                        logger.trace(\"Received {} = {}\", datapoint, t);\n+                    }\n+                    if (thing.getStatus() != ThingStatus.REMOVING) {", "originalCommit": "7b1658af39ccc8a2f98f4cc318896c32ee4ff9a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTgzNzk1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r439837959", "bodyText": "I didn't put this for fun but think that I had an issue that serialEvent was still called in another thread before everything was closed, and updating state and status doesn't in this case doesn't make any sense.", "author": "ramack", "createdAt": "2020-06-14T14:55:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MTUyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY5NzUzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r441697539", "bodyText": "Interesting. Before the thing is removed, it should have completed dispose() and nothing should be alive then. If this happens, either this is a bug in the framework or something from the serial handling is still alive when dispose() finished.", "author": "J-N-K", "createdAt": "2020-06-17T17:07:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MTUyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI0OTc2MA==", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r443249760", "bodyText": "ok, I tried again and the need for this condition did not show up again, so I removed it now. I believe that one of the recently added synchronized keywords helped here or the openhab core changed since I initially wrote that some months ago.", "author": "ramack", "createdAt": "2020-06-21T19:31:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MTUyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MTcyMw==", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r439681723", "bodyText": "I suspect this might be used by multiple threads at once, so lets make it thread-safe and final.\nThen move the final fields above all the non-final fields.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Map<Byte, Byte> memory = new HashMap<Byte, Byte>();\n          \n          \n            \n                private final Map<Byte, Byte> memory = new ConcurrentHashMap<Byte, Byte>();", "author": "cpmeister", "createdAt": "2020-06-12T23:45:26Z", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,459 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    /* init to default to avoid NPE in case handleCommand() is called before initialize() */\n+    private HeliosVentilationConfiguration config = new HeliosVentilationConfiguration();\n+\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+    private int pollCounter;\n+\n+    /**\n+     * store received data for read-modify-write operations on bitlevel\n+     */\n+    private Map<Byte, Byte> memory = new HashMap<Byte, Byte>();", "originalCommit": "7b1658af39ccc8a2f98f4cc318896c32ee4ff9a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MTk5OA==", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r439681998", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private SerialPortManager serialPortManager;\n          \n          \n            \n                private final SerialPortManager serialPortManager;", "author": "cpmeister", "createdAt": "2020-06-12T23:47:10Z", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,459 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    /* init to default to avoid NPE in case handleCommand() is called before initialize() */\n+    private HeliosVentilationConfiguration config = new HeliosVentilationConfiguration();\n+\n+    private SerialPortManager serialPortManager;", "originalCommit": "7b1658af39ccc8a2f98f4cc318896c32ee4ff9a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4Mjc5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r439682791", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final int FANSPEED_MAP[] = { 0, 1, 3, 7, 15, 31, 63, 127, 255 };\n          \n          \n            \n                private static final int[] FANSPEED_MAP = { 0, 1, 3, 7, 15, 31, 63, 127, 255 };", "author": "cpmeister", "createdAt": "2020-06-12T23:52:00Z", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationDataPoint.java", "diffHunk": "@@ -0,0 +1,324 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+\n+/**\n+ * The {@link HeliosVentilationDataPoint} is a description of a datapoint in the Helios ventilation system.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationDataPoint {\n+    public enum DataType {\n+        TEMPERATURE,\n+        HYSTERESIS,\n+        FANSPEED,\n+        SWITCH,\n+        BYTE_PERCENT,\n+        PERCENT,\n+        NUMBER\n+    }\n+\n+    /**\n+     * mapping from temperature byte values to \u00b0C\n+     */\n+    private static final int TEMP_MAP[] = { -74, -70, -66, -62, -59, -56, -54, -52, -50, -48, -47, -46, -44, -43, -42,\n+            -41, -40, -39, -38, -37, -36, -35, -34, -33, -33, -32, -31, -30, -30, -29, -28, -28, -27, -27, -26, -25,\n+            -25, -24, -24, -23, -23, -22, -22, -21, -21, -20, -20, -19, -19, -19, -18, -18, -17, -17, -16, -16, -16,\n+            -15, -15, -14, -14, -14, -13, -13, -12, -12, -12, -11, -11, -11, -10, -10, -9, -9, -9, -8, -8, -8, -7, -7,\n+            -7, -6, -6, -6, -5, -5, -5, -4, -4, -4, -3, -3, -3, -2, -2, -2, -1, -1, -1, -1, 0, 0, 0, 1, 1, 1, 2, 2, 2,\n+            3, 3, 3, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 13,\n+            13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 18, 18, 18, 19, 19, 19, 20, 20, 21, 21, 21, 22, 22, 22,\n+            23, 23, 24, 24, 24, 25, 25, 26, 26, 27, 27, 27, 28, 28, 29, 29, 30, 30, 31, 31, 32, 32, 33, 33, 34, 34, 35,\n+            35, 36, 36, 37, 37, 38, 38, 39, 40, 40, 41, 41, 42, 43, 43, 44, 45, 45, 46, 47, 48, 48, 49, 50, 51, 52, 53,\n+            53, 54, 55, 56, 57, 59, 60, 61, 62, 63, 65, 66, 68, 69, 71, 73, 75, 77, 79, 81, 82, 86, 90, 93, 97, 100,\n+            100, 100, 100, 100, 100, 100, 100, 100 };\n+\n+    /**\n+     * mapping from human readable fanspeed to raw value\n+     */\n+    private static final int FANSPEED_MAP[] = { 0, 1, 3, 7, 15, 31, 63, 127, 255 };", "originalCommit": "7b1658af39ccc8a2f98f4cc318896c32ee4ff9a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MjgxMg==", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r439682812", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final int TEMP_MAP[] = { -74, -70, -66, -62, -59, -56, -54, -52, -50, -48, -47, -46, -44, -43, -42,\n          \n          \n            \n                private static final int[] TEMP_MAP = { -74, -70, -66, -62, -59, -56, -54, -52, -50, -48, -47, -46, -44, -43, -42,", "author": "cpmeister", "createdAt": "2020-06-12T23:52:07Z", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationDataPoint.java", "diffHunk": "@@ -0,0 +1,324 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+\n+/**\n+ * The {@link HeliosVentilationDataPoint} is a description of a datapoint in the Helios ventilation system.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationDataPoint {\n+    public enum DataType {\n+        TEMPERATURE,\n+        HYSTERESIS,\n+        FANSPEED,\n+        SWITCH,\n+        BYTE_PERCENT,\n+        PERCENT,\n+        NUMBER\n+    }\n+\n+    /**\n+     * mapping from temperature byte values to \u00b0C\n+     */\n+    private static final int TEMP_MAP[] = { -74, -70, -66, -62, -59, -56, -54, -52, -50, -48, -47, -46, -44, -43, -42,", "originalCommit": "7b1658af39ccc8a2f98f4cc318896c32ee4ff9a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MzM2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r439683365", "bodyText": "QuantityType extend Number so you don't need to convert them to a DecimalType.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            value = quantvalue.as(DecimalType.class);\n          \n          \n            \n                            if (value != null) {\n          \n          \n            \n                                result = (byte) (value.intValue() * 3);\n          \n          \n            \n                            }\n          \n          \n            \n                            result = (byte) (quantvalue.intValue() * 3);", "author": "cpmeister", "createdAt": "2020-06-12T23:55:35Z", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationDataPoint.java", "diffHunk": "@@ -0,0 +1,324 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+\n+/**\n+ * The {@link HeliosVentilationDataPoint} is a description of a datapoint in the Helios ventilation system.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationDataPoint {\n+    public enum DataType {\n+        TEMPERATURE,\n+        HYSTERESIS,\n+        FANSPEED,\n+        SWITCH,\n+        BYTE_PERCENT,\n+        PERCENT,\n+        NUMBER\n+    }\n+\n+    /**\n+     * mapping from temperature byte values to \u00b0C\n+     */\n+    private static final int TEMP_MAP[] = { -74, -70, -66, -62, -59, -56, -54, -52, -50, -48, -47, -46, -44, -43, -42,\n+            -41, -40, -39, -38, -37, -36, -35, -34, -33, -33, -32, -31, -30, -30, -29, -28, -28, -27, -27, -26, -25,\n+            -25, -24, -24, -23, -23, -22, -22, -21, -21, -20, -20, -19, -19, -19, -18, -18, -17, -17, -16, -16, -16,\n+            -15, -15, -14, -14, -14, -13, -13, -12, -12, -12, -11, -11, -11, -10, -10, -9, -9, -9, -8, -8, -8, -7, -7,\n+            -7, -6, -6, -6, -5, -5, -5, -4, -4, -4, -3, -3, -3, -2, -2, -2, -1, -1, -1, -1, 0, 0, 0, 1, 1, 1, 2, 2, 2,\n+            3, 3, 3, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 13,\n+            13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 18, 18, 18, 19, 19, 19, 20, 20, 21, 21, 21, 22, 22, 22,\n+            23, 23, 24, 24, 24, 25, 25, 26, 26, 27, 27, 27, 28, 28, 29, 29, 30, 30, 31, 31, 32, 32, 33, 33, 34, 34, 35,\n+            35, 36, 36, 37, 37, 38, 38, 39, 40, 40, 41, 41, 42, 43, 43, 44, 45, 45, 46, 47, 48, 48, 49, 50, 51, 52, 53,\n+            53, 54, 55, 56, 57, 59, 60, 61, 62, 63, 65, 66, 68, 69, 71, 73, 75, 77, 79, 81, 82, 86, 90, 93, 97, 100,\n+            100, 100, 100, 100, 100, 100, 100, 100 };\n+\n+    /**\n+     * mapping from human readable fanspeed to raw value\n+     */\n+    private static final int FANSPEED_MAP[] = { 0, 1, 3, 7, 15, 31, 63, 127, 255 };\n+\n+    private static final int BYTE_PERCENT_OFFSET = 52;\n+\n+    private String name;\n+    private boolean writable;\n+    private DataType datatype;\n+    private byte address;\n+    private int bitStart;\n+    private int bitLength;\n+\n+    private @Nullable HeliosVentilationDataPoint link;\n+\n+    /**\n+     * parse fullSpec in the properties format to declare a datapoint\n+     *\n+     * @param name the name of the datapoint\n+     * @param fullSpec datapoint specification, see format in datapoints.properties\n+     * @throws HeliosPropertiesFormatException in case fullSpec is not parsable\n+     */\n+    public HeliosVentilationDataPoint(String name, String fullSpec) throws HeliosPropertiesFormatException {\n+        String specWithoutComment;\n+        if (fullSpec.contains(\"#\")) {\n+            specWithoutComment = fullSpec.substring(0, fullSpec.indexOf(\"#\"));\n+        } else {\n+            specWithoutComment = fullSpec;\n+        }\n+        String[] tokens = specWithoutComment.split(\",\");\n+        this.name = name;\n+        if (tokens.length != 3) {\n+            throw new HeliosPropertiesFormatException(\"invalid length\", name, fullSpec);\n+        }\n+        try {\n+            String addr = tokens[0];\n+            String[] addrTokens;\n+            if (addr.contains(\":\")) {\n+                addrTokens = addr.split(\":\");\n+            } else {\n+                addrTokens = new String[] { addr };\n+            }\n+            bitLength = 8;\n+            bitStart = 0;\n+            this.address = (byte) (int) Integer.decode(addrTokens[0]);\n+            if (addrTokens.length > 1) {\n+                bitStart = (byte) (int) Integer.decode(addrTokens[1]);\n+                bitLength = 1;\n+            }\n+            if (addrTokens.length > 2) {\n+                bitLength = (byte) (int) Integer.decode(addrTokens[2]) - bitStart + 1;\n+            }\n+            if (addrTokens.length > 3) {\n+                throw new HeliosPropertiesFormatException(\n+                        \"invalid address spec: too many separators in bit specification\", name, fullSpec);\n+            }\n+        } catch (NumberFormatException e) {\n+            throw new HeliosPropertiesFormatException(\"invalid address spec\", name, fullSpec);\n+        }\n+\n+        this.writable = Boolean.parseBoolean(tokens[1]);\n+        try {\n+            this.datatype = DataType.valueOf(tokens[2].replaceAll(\"\\\\s+\", \"\"));\n+        } catch (IllegalArgumentException e) {\n+            throw new HeliosPropertiesFormatException(\"invalid type spec\", name, fullSpec);\n+        }\n+    }\n+\n+    public HeliosVentilationDataPoint(String name, byte address, boolean writable, DataType datatype) {\n+        this.datatype = datatype;\n+        this.writable = writable;\n+        this.name = name;\n+        this.address = address;\n+    }\n+\n+    public boolean isWritable() {\n+        return writable;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n+\n+    /**\n+     *\n+     * @return the name of the variable, which is also the channel name\n+     */\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /**\n+     *\n+     * @return address of the variable\n+     */\n+    public byte address() {\n+        return address;\n+    }\n+\n+    /**\n+     * @return the bit mask of the data point. 0xFF in case the full byte is used.\n+     */\n+    public byte bitMask() {\n+        byte mask = (byte) 0xff;\n+        if (datatype == DataType.NUMBER || datatype == DataType.SWITCH) {\n+            mask = (byte) (((1 << bitLength) - 1) << bitStart);\n+        }\n+        return mask;\n+    }\n+\n+    /**\n+     * interpret the given byte b and return the value as State.\n+     *\n+     * @param b\n+     * @return state representation of byte value b in current datatype\n+     */\n+    public State asState(byte b) {\n+        int val = b & 0xff;\n+        if (datatype == DataType.TEMPERATURE) {\n+            return new QuantityType<>(TEMP_MAP[val], SIUnits.CELSIUS);\n+        } else if (datatype == DataType.BYTE_PERCENT) {\n+            return new QuantityType<>((int) ((val - BYTE_PERCENT_OFFSET) * 100.0 / (255 - BYTE_PERCENT_OFFSET)),\n+                    SmartHomeUnits.PERCENT);\n+        } else if (datatype == DataType.SWITCH && bitLength == 1) {\n+            if ((b & (1 << bitStart)) != 0) {\n+                return OnOffType.ON;\n+            } else {\n+                return OnOffType.OFF;\n+            }\n+        } else if (datatype == DataType.NUMBER) {\n+            int value = (b & bitMask()) >> bitStart;\n+            return new DecimalType(value);\n+        } else if (datatype == DataType.PERCENT) {\n+            return new QuantityType<>(val, SmartHomeUnits.PERCENT);\n+        } else if (datatype == DataType.FANSPEED) {\n+            int i = 1;\n+            while (i < FANSPEED_MAP.length && FANSPEED_MAP[i] < val) {\n+                i++;\n+            }\n+            return new DecimalType(i);\n+        } else if (datatype == DataType.HYSTERESIS) {\n+            return new QuantityType<>(val / 3, SIUnits.CELSIUS);\n+        }\n+\n+        return UnDefType.UNDEF;\n+    }\n+\n+    /**\n+     * interpret the given byte b and return the value as string.\n+     *\n+     * @param b\n+     * @return sting representation of byte value b in current datatype\n+     */\n+    public String asString(byte b) {\n+        State ste = asState(b);\n+        String str = ste.toString();\n+        if (ste instanceof UnDefType) {\n+            return String.format(\"<unknown type> %02X \", b);\n+        } else {\n+            return str;\n+        }\n+    }\n+\n+    /**\n+     * generate byte data to transmit\n+     *\n+     * @param val is the state of a channel\n+     * @return byte value with RS485 representation. Bit level values are returned in the correct location, but other\n+     *         bits/datapoints in the same address are zero.\n+     */\n+    public byte getTransmitDataFor(State val) {\n+        byte result = 0;\n+        DecimalType value = val.as(DecimalType.class);\n+        if (value == null) {\n+            /*\n+             * if value is not convertible to a numeric type we cannot do anything reasonable with it, let's use the\n+             * initial value for it\n+             */\n+        } else if (datatype == DataType.TEMPERATURE) {\n+            QuantityType<?> quantvalue = ((QuantityType<?>) val);\n+            quantvalue = quantvalue.toUnit(SIUnits.CELSIUS);\n+            if (quantvalue != null) {\n+                value = quantvalue.as(DecimalType.class);\n+                if (value != null) {\n+                    int temp = (int) Math.round(value.doubleValue());\n+                    int i = 0;\n+                    while (i < TEMP_MAP.length && TEMP_MAP[i] < temp) {\n+                        i++;\n+                    }\n+                    result = (byte) i;\n+                }\n+            }\n+        } else if (datatype == DataType.FANSPEED) {\n+            int i = value.intValue();\n+            if (i < 0) {\n+                i = 0;\n+            } else if (i > 8) {\n+                i = 8;\n+            }\n+            result = (byte) FANSPEED_MAP[i];\n+        } else if (datatype == DataType.BYTE_PERCENT) {\n+            result = (byte) ((value.doubleValue() / 100.0) * (255 - BYTE_PERCENT_OFFSET) + BYTE_PERCENT_OFFSET);\n+        } else if (datatype == DataType.PERCENT) {\n+            double d = (Math.round(value.doubleValue()));\n+            if (d < 0.0) {\n+                d = 0.0;\n+            } else if (d > 100.0) {\n+                d = 100.0;\n+            }\n+            result = (byte) d;\n+        } else if (datatype == DataType.HYSTERESIS) {\n+            QuantityType<?> quantvalue = ((QuantityType<?>) val);\n+            quantvalue = quantvalue.toUnit(SIUnits.CELSIUS);\n+            if (quantvalue != null) {\n+                value = quantvalue.as(DecimalType.class);\n+                if (value != null) {\n+                    result = (byte) (value.intValue() * 3);\n+                }", "originalCommit": "7b1658af39ccc8a2f98f4cc318896c32ee4ff9a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MzgyMg==", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r439683822", "bodyText": "This would be a good place to use a switch statement.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } else if (datatype == DataType.TEMPERATURE) {\n          \n          \n            \n                    } else switch(datatype) {\n          \n          \n            \n                        case TEMPERATURE:", "author": "cpmeister", "createdAt": "2020-06-12T23:58:18Z", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationDataPoint.java", "diffHunk": "@@ -0,0 +1,324 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+\n+/**\n+ * The {@link HeliosVentilationDataPoint} is a description of a datapoint in the Helios ventilation system.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationDataPoint {\n+    public enum DataType {\n+        TEMPERATURE,\n+        HYSTERESIS,\n+        FANSPEED,\n+        SWITCH,\n+        BYTE_PERCENT,\n+        PERCENT,\n+        NUMBER\n+    }\n+\n+    /**\n+     * mapping from temperature byte values to \u00b0C\n+     */\n+    private static final int TEMP_MAP[] = { -74, -70, -66, -62, -59, -56, -54, -52, -50, -48, -47, -46, -44, -43, -42,\n+            -41, -40, -39, -38, -37, -36, -35, -34, -33, -33, -32, -31, -30, -30, -29, -28, -28, -27, -27, -26, -25,\n+            -25, -24, -24, -23, -23, -22, -22, -21, -21, -20, -20, -19, -19, -19, -18, -18, -17, -17, -16, -16, -16,\n+            -15, -15, -14, -14, -14, -13, -13, -12, -12, -12, -11, -11, -11, -10, -10, -9, -9, -9, -8, -8, -8, -7, -7,\n+            -7, -6, -6, -6, -5, -5, -5, -4, -4, -4, -3, -3, -3, -2, -2, -2, -1, -1, -1, -1, 0, 0, 0, 1, 1, 1, 2, 2, 2,\n+            3, 3, 3, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 13,\n+            13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 18, 18, 18, 19, 19, 19, 20, 20, 21, 21, 21, 22, 22, 22,\n+            23, 23, 24, 24, 24, 25, 25, 26, 26, 27, 27, 27, 28, 28, 29, 29, 30, 30, 31, 31, 32, 32, 33, 33, 34, 34, 35,\n+            35, 36, 36, 37, 37, 38, 38, 39, 40, 40, 41, 41, 42, 43, 43, 44, 45, 45, 46, 47, 48, 48, 49, 50, 51, 52, 53,\n+            53, 54, 55, 56, 57, 59, 60, 61, 62, 63, 65, 66, 68, 69, 71, 73, 75, 77, 79, 81, 82, 86, 90, 93, 97, 100,\n+            100, 100, 100, 100, 100, 100, 100, 100 };\n+\n+    /**\n+     * mapping from human readable fanspeed to raw value\n+     */\n+    private static final int FANSPEED_MAP[] = { 0, 1, 3, 7, 15, 31, 63, 127, 255 };\n+\n+    private static final int BYTE_PERCENT_OFFSET = 52;\n+\n+    private String name;\n+    private boolean writable;\n+    private DataType datatype;\n+    private byte address;\n+    private int bitStart;\n+    private int bitLength;\n+\n+    private @Nullable HeliosVentilationDataPoint link;\n+\n+    /**\n+     * parse fullSpec in the properties format to declare a datapoint\n+     *\n+     * @param name the name of the datapoint\n+     * @param fullSpec datapoint specification, see format in datapoints.properties\n+     * @throws HeliosPropertiesFormatException in case fullSpec is not parsable\n+     */\n+    public HeliosVentilationDataPoint(String name, String fullSpec) throws HeliosPropertiesFormatException {\n+        String specWithoutComment;\n+        if (fullSpec.contains(\"#\")) {\n+            specWithoutComment = fullSpec.substring(0, fullSpec.indexOf(\"#\"));\n+        } else {\n+            specWithoutComment = fullSpec;\n+        }\n+        String[] tokens = specWithoutComment.split(\",\");\n+        this.name = name;\n+        if (tokens.length != 3) {\n+            throw new HeliosPropertiesFormatException(\"invalid length\", name, fullSpec);\n+        }\n+        try {\n+            String addr = tokens[0];\n+            String[] addrTokens;\n+            if (addr.contains(\":\")) {\n+                addrTokens = addr.split(\":\");\n+            } else {\n+                addrTokens = new String[] { addr };\n+            }\n+            bitLength = 8;\n+            bitStart = 0;\n+            this.address = (byte) (int) Integer.decode(addrTokens[0]);\n+            if (addrTokens.length > 1) {\n+                bitStart = (byte) (int) Integer.decode(addrTokens[1]);\n+                bitLength = 1;\n+            }\n+            if (addrTokens.length > 2) {\n+                bitLength = (byte) (int) Integer.decode(addrTokens[2]) - bitStart + 1;\n+            }\n+            if (addrTokens.length > 3) {\n+                throw new HeliosPropertiesFormatException(\n+                        \"invalid address spec: too many separators in bit specification\", name, fullSpec);\n+            }\n+        } catch (NumberFormatException e) {\n+            throw new HeliosPropertiesFormatException(\"invalid address spec\", name, fullSpec);\n+        }\n+\n+        this.writable = Boolean.parseBoolean(tokens[1]);\n+        try {\n+            this.datatype = DataType.valueOf(tokens[2].replaceAll(\"\\\\s+\", \"\"));\n+        } catch (IllegalArgumentException e) {\n+            throw new HeliosPropertiesFormatException(\"invalid type spec\", name, fullSpec);\n+        }\n+    }\n+\n+    public HeliosVentilationDataPoint(String name, byte address, boolean writable, DataType datatype) {\n+        this.datatype = datatype;\n+        this.writable = writable;\n+        this.name = name;\n+        this.address = address;\n+    }\n+\n+    public boolean isWritable() {\n+        return writable;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n+\n+    /**\n+     *\n+     * @return the name of the variable, which is also the channel name\n+     */\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /**\n+     *\n+     * @return address of the variable\n+     */\n+    public byte address() {\n+        return address;\n+    }\n+\n+    /**\n+     * @return the bit mask of the data point. 0xFF in case the full byte is used.\n+     */\n+    public byte bitMask() {\n+        byte mask = (byte) 0xff;\n+        if (datatype == DataType.NUMBER || datatype == DataType.SWITCH) {\n+            mask = (byte) (((1 << bitLength) - 1) << bitStart);\n+        }\n+        return mask;\n+    }\n+\n+    /**\n+     * interpret the given byte b and return the value as State.\n+     *\n+     * @param b\n+     * @return state representation of byte value b in current datatype\n+     */\n+    public State asState(byte b) {\n+        int val = b & 0xff;\n+        if (datatype == DataType.TEMPERATURE) {\n+            return new QuantityType<>(TEMP_MAP[val], SIUnits.CELSIUS);\n+        } else if (datatype == DataType.BYTE_PERCENT) {\n+            return new QuantityType<>((int) ((val - BYTE_PERCENT_OFFSET) * 100.0 / (255 - BYTE_PERCENT_OFFSET)),\n+                    SmartHomeUnits.PERCENT);\n+        } else if (datatype == DataType.SWITCH && bitLength == 1) {\n+            if ((b & (1 << bitStart)) != 0) {\n+                return OnOffType.ON;\n+            } else {\n+                return OnOffType.OFF;\n+            }\n+        } else if (datatype == DataType.NUMBER) {\n+            int value = (b & bitMask()) >> bitStart;\n+            return new DecimalType(value);\n+        } else if (datatype == DataType.PERCENT) {\n+            return new QuantityType<>(val, SmartHomeUnits.PERCENT);\n+        } else if (datatype == DataType.FANSPEED) {\n+            int i = 1;\n+            while (i < FANSPEED_MAP.length && FANSPEED_MAP[i] < val) {\n+                i++;\n+            }\n+            return new DecimalType(i);\n+        } else if (datatype == DataType.HYSTERESIS) {\n+            return new QuantityType<>(val / 3, SIUnits.CELSIUS);\n+        }\n+\n+        return UnDefType.UNDEF;\n+    }\n+\n+    /**\n+     * interpret the given byte b and return the value as string.\n+     *\n+     * @param b\n+     * @return sting representation of byte value b in current datatype\n+     */\n+    public String asString(byte b) {\n+        State ste = asState(b);\n+        String str = ste.toString();\n+        if (ste instanceof UnDefType) {\n+            return String.format(\"<unknown type> %02X \", b);\n+        } else {\n+            return str;\n+        }\n+    }\n+\n+    /**\n+     * generate byte data to transmit\n+     *\n+     * @param val is the state of a channel\n+     * @return byte value with RS485 representation. Bit level values are returned in the correct location, but other\n+     *         bits/datapoints in the same address are zero.\n+     */\n+    public byte getTransmitDataFor(State val) {\n+        byte result = 0;\n+        DecimalType value = val.as(DecimalType.class);\n+        if (value == null) {\n+            /*\n+             * if value is not convertible to a numeric type we cannot do anything reasonable with it, let's use the\n+             * initial value for it\n+             */\n+        } else if (datatype == DataType.TEMPERATURE) {", "originalCommit": "7b1658af39ccc8a2f98f4cc318896c32ee4ff9a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTgzODc1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r439838751", "bodyText": "I will do that, but can you explain me why that is better in your eyes?", "author": "ramack", "createdAt": "2020-06-14T15:04:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MzgyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NDA1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r439684053", "bodyText": "I'd prefer if you renamed the field and this method to next.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public @Nullable HeliosVentilationDataPoint link() {\n          \n          \n            \n                    return link;\n          \n          \n            \n                }\n          \n          \n            \n                public @Nullable HeliosVentilationDataPoint next() {\n          \n          \n            \n                    return next;\n          \n          \n            \n                }", "author": "cpmeister", "createdAt": "2020-06-12T23:59:57Z", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationDataPoint.java", "diffHunk": "@@ -0,0 +1,324 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+\n+/**\n+ * The {@link HeliosVentilationDataPoint} is a description of a datapoint in the Helios ventilation system.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationDataPoint {\n+    public enum DataType {\n+        TEMPERATURE,\n+        HYSTERESIS,\n+        FANSPEED,\n+        SWITCH,\n+        BYTE_PERCENT,\n+        PERCENT,\n+        NUMBER\n+    }\n+\n+    /**\n+     * mapping from temperature byte values to \u00b0C\n+     */\n+    private static final int TEMP_MAP[] = { -74, -70, -66, -62, -59, -56, -54, -52, -50, -48, -47, -46, -44, -43, -42,\n+            -41, -40, -39, -38, -37, -36, -35, -34, -33, -33, -32, -31, -30, -30, -29, -28, -28, -27, -27, -26, -25,\n+            -25, -24, -24, -23, -23, -22, -22, -21, -21, -20, -20, -19, -19, -19, -18, -18, -17, -17, -16, -16, -16,\n+            -15, -15, -14, -14, -14, -13, -13, -12, -12, -12, -11, -11, -11, -10, -10, -9, -9, -9, -8, -8, -8, -7, -7,\n+            -7, -6, -6, -6, -5, -5, -5, -4, -4, -4, -3, -3, -3, -2, -2, -2, -1, -1, -1, -1, 0, 0, 0, 1, 1, 1, 2, 2, 2,\n+            3, 3, 3, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 13,\n+            13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 18, 18, 18, 19, 19, 19, 20, 20, 21, 21, 21, 22, 22, 22,\n+            23, 23, 24, 24, 24, 25, 25, 26, 26, 27, 27, 27, 28, 28, 29, 29, 30, 30, 31, 31, 32, 32, 33, 33, 34, 34, 35,\n+            35, 36, 36, 37, 37, 38, 38, 39, 40, 40, 41, 41, 42, 43, 43, 44, 45, 45, 46, 47, 48, 48, 49, 50, 51, 52, 53,\n+            53, 54, 55, 56, 57, 59, 60, 61, 62, 63, 65, 66, 68, 69, 71, 73, 75, 77, 79, 81, 82, 86, 90, 93, 97, 100,\n+            100, 100, 100, 100, 100, 100, 100, 100 };\n+\n+    /**\n+     * mapping from human readable fanspeed to raw value\n+     */\n+    private static final int FANSPEED_MAP[] = { 0, 1, 3, 7, 15, 31, 63, 127, 255 };\n+\n+    private static final int BYTE_PERCENT_OFFSET = 52;\n+\n+    private String name;\n+    private boolean writable;\n+    private DataType datatype;\n+    private byte address;\n+    private int bitStart;\n+    private int bitLength;\n+\n+    private @Nullable HeliosVentilationDataPoint link;\n+\n+    /**\n+     * parse fullSpec in the properties format to declare a datapoint\n+     *\n+     * @param name the name of the datapoint\n+     * @param fullSpec datapoint specification, see format in datapoints.properties\n+     * @throws HeliosPropertiesFormatException in case fullSpec is not parsable\n+     */\n+    public HeliosVentilationDataPoint(String name, String fullSpec) throws HeliosPropertiesFormatException {\n+        String specWithoutComment;\n+        if (fullSpec.contains(\"#\")) {\n+            specWithoutComment = fullSpec.substring(0, fullSpec.indexOf(\"#\"));\n+        } else {\n+            specWithoutComment = fullSpec;\n+        }\n+        String[] tokens = specWithoutComment.split(\",\");\n+        this.name = name;\n+        if (tokens.length != 3) {\n+            throw new HeliosPropertiesFormatException(\"invalid length\", name, fullSpec);\n+        }\n+        try {\n+            String addr = tokens[0];\n+            String[] addrTokens;\n+            if (addr.contains(\":\")) {\n+                addrTokens = addr.split(\":\");\n+            } else {\n+                addrTokens = new String[] { addr };\n+            }\n+            bitLength = 8;\n+            bitStart = 0;\n+            this.address = (byte) (int) Integer.decode(addrTokens[0]);\n+            if (addrTokens.length > 1) {\n+                bitStart = (byte) (int) Integer.decode(addrTokens[1]);\n+                bitLength = 1;\n+            }\n+            if (addrTokens.length > 2) {\n+                bitLength = (byte) (int) Integer.decode(addrTokens[2]) - bitStart + 1;\n+            }\n+            if (addrTokens.length > 3) {\n+                throw new HeliosPropertiesFormatException(\n+                        \"invalid address spec: too many separators in bit specification\", name, fullSpec);\n+            }\n+        } catch (NumberFormatException e) {\n+            throw new HeliosPropertiesFormatException(\"invalid address spec\", name, fullSpec);\n+        }\n+\n+        this.writable = Boolean.parseBoolean(tokens[1]);\n+        try {\n+            this.datatype = DataType.valueOf(tokens[2].replaceAll(\"\\\\s+\", \"\"));\n+        } catch (IllegalArgumentException e) {\n+            throw new HeliosPropertiesFormatException(\"invalid type spec\", name, fullSpec);\n+        }\n+    }\n+\n+    public HeliosVentilationDataPoint(String name, byte address, boolean writable, DataType datatype) {\n+        this.datatype = datatype;\n+        this.writable = writable;\n+        this.name = name;\n+        this.address = address;\n+    }\n+\n+    public boolean isWritable() {\n+        return writable;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n+\n+    /**\n+     *\n+     * @return the name of the variable, which is also the channel name\n+     */\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /**\n+     *\n+     * @return address of the variable\n+     */\n+    public byte address() {\n+        return address;\n+    }\n+\n+    /**\n+     * @return the bit mask of the data point. 0xFF in case the full byte is used.\n+     */\n+    public byte bitMask() {\n+        byte mask = (byte) 0xff;\n+        if (datatype == DataType.NUMBER || datatype == DataType.SWITCH) {\n+            mask = (byte) (((1 << bitLength) - 1) << bitStart);\n+        }\n+        return mask;\n+    }\n+\n+    /**\n+     * interpret the given byte b and return the value as State.\n+     *\n+     * @param b\n+     * @return state representation of byte value b in current datatype\n+     */\n+    public State asState(byte b) {\n+        int val = b & 0xff;\n+        if (datatype == DataType.TEMPERATURE) {\n+            return new QuantityType<>(TEMP_MAP[val], SIUnits.CELSIUS);\n+        } else if (datatype == DataType.BYTE_PERCENT) {\n+            return new QuantityType<>((int) ((val - BYTE_PERCENT_OFFSET) * 100.0 / (255 - BYTE_PERCENT_OFFSET)),\n+                    SmartHomeUnits.PERCENT);\n+        } else if (datatype == DataType.SWITCH && bitLength == 1) {\n+            if ((b & (1 << bitStart)) != 0) {\n+                return OnOffType.ON;\n+            } else {\n+                return OnOffType.OFF;\n+            }\n+        } else if (datatype == DataType.NUMBER) {\n+            int value = (b & bitMask()) >> bitStart;\n+            return new DecimalType(value);\n+        } else if (datatype == DataType.PERCENT) {\n+            return new QuantityType<>(val, SmartHomeUnits.PERCENT);\n+        } else if (datatype == DataType.FANSPEED) {\n+            int i = 1;\n+            while (i < FANSPEED_MAP.length && FANSPEED_MAP[i] < val) {\n+                i++;\n+            }\n+            return new DecimalType(i);\n+        } else if (datatype == DataType.HYSTERESIS) {\n+            return new QuantityType<>(val / 3, SIUnits.CELSIUS);\n+        }\n+\n+        return UnDefType.UNDEF;\n+    }\n+\n+    /**\n+     * interpret the given byte b and return the value as string.\n+     *\n+     * @param b\n+     * @return sting representation of byte value b in current datatype\n+     */\n+    public String asString(byte b) {\n+        State ste = asState(b);\n+        String str = ste.toString();\n+        if (ste instanceof UnDefType) {\n+            return String.format(\"<unknown type> %02X \", b);\n+        } else {\n+            return str;\n+        }\n+    }\n+\n+    /**\n+     * generate byte data to transmit\n+     *\n+     * @param val is the state of a channel\n+     * @return byte value with RS485 representation. Bit level values are returned in the correct location, but other\n+     *         bits/datapoints in the same address are zero.\n+     */\n+    public byte getTransmitDataFor(State val) {\n+        byte result = 0;\n+        DecimalType value = val.as(DecimalType.class);\n+        if (value == null) {\n+            /*\n+             * if value is not convertible to a numeric type we cannot do anything reasonable with it, let's use the\n+             * initial value for it\n+             */\n+        } else if (datatype == DataType.TEMPERATURE) {\n+            QuantityType<?> quantvalue = ((QuantityType<?>) val);\n+            quantvalue = quantvalue.toUnit(SIUnits.CELSIUS);\n+            if (quantvalue != null) {\n+                value = quantvalue.as(DecimalType.class);\n+                if (value != null) {\n+                    int temp = (int) Math.round(value.doubleValue());\n+                    int i = 0;\n+                    while (i < TEMP_MAP.length && TEMP_MAP[i] < temp) {\n+                        i++;\n+                    }\n+                    result = (byte) i;\n+                }\n+            }\n+        } else if (datatype == DataType.FANSPEED) {\n+            int i = value.intValue();\n+            if (i < 0) {\n+                i = 0;\n+            } else if (i > 8) {\n+                i = 8;\n+            }\n+            result = (byte) FANSPEED_MAP[i];\n+        } else if (datatype == DataType.BYTE_PERCENT) {\n+            result = (byte) ((value.doubleValue() / 100.0) * (255 - BYTE_PERCENT_OFFSET) + BYTE_PERCENT_OFFSET);\n+        } else if (datatype == DataType.PERCENT) {\n+            double d = (Math.round(value.doubleValue()));\n+            if (d < 0.0) {\n+                d = 0.0;\n+            } else if (d > 100.0) {\n+                d = 100.0;\n+            }\n+            result = (byte) d;\n+        } else if (datatype == DataType.HYSTERESIS) {\n+            QuantityType<?> quantvalue = ((QuantityType<?>) val);\n+            quantvalue = quantvalue.toUnit(SIUnits.CELSIUS);\n+            if (quantvalue != null) {\n+                value = quantvalue.as(DecimalType.class);\n+                if (value != null) {\n+                    result = (byte) (value.intValue() * 3);\n+                }\n+            }\n+        } else if (datatype == DataType.SWITCH || datatype == DataType.NUMBER) {\n+            // those are the types supporting bit level specification\n+            // output only the relevant bits\n+            result = (byte) (value.intValue() << bitStart);\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Get further datapoint linked to the same address.\n+     *\n+     * @return sister datapoint\n+     */\n+    public @Nullable HeliosVentilationDataPoint link() {\n+        return link;\n+    }", "originalCommit": "7b1658af39ccc8a2f98f4cc318896c32ee4ff9a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NDE1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r439684153", "bodyText": "You can use a switch statement here as well.", "author": "cpmeister", "createdAt": "2020-06-13T00:00:46Z", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationDataPoint.java", "diffHunk": "@@ -0,0 +1,324 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+\n+/**\n+ * The {@link HeliosVentilationDataPoint} is a description of a datapoint in the Helios ventilation system.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationDataPoint {\n+    public enum DataType {\n+        TEMPERATURE,\n+        HYSTERESIS,\n+        FANSPEED,\n+        SWITCH,\n+        BYTE_PERCENT,\n+        PERCENT,\n+        NUMBER\n+    }\n+\n+    /**\n+     * mapping from temperature byte values to \u00b0C\n+     */\n+    private static final int TEMP_MAP[] = { -74, -70, -66, -62, -59, -56, -54, -52, -50, -48, -47, -46, -44, -43, -42,\n+            -41, -40, -39, -38, -37, -36, -35, -34, -33, -33, -32, -31, -30, -30, -29, -28, -28, -27, -27, -26, -25,\n+            -25, -24, -24, -23, -23, -22, -22, -21, -21, -20, -20, -19, -19, -19, -18, -18, -17, -17, -16, -16, -16,\n+            -15, -15, -14, -14, -14, -13, -13, -12, -12, -12, -11, -11, -11, -10, -10, -9, -9, -9, -8, -8, -8, -7, -7,\n+            -7, -6, -6, -6, -5, -5, -5, -4, -4, -4, -3, -3, -3, -2, -2, -2, -1, -1, -1, -1, 0, 0, 0, 1, 1, 1, 2, 2, 2,\n+            3, 3, 3, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 13,\n+            13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 18, 18, 18, 19, 19, 19, 20, 20, 21, 21, 21, 22, 22, 22,\n+            23, 23, 24, 24, 24, 25, 25, 26, 26, 27, 27, 27, 28, 28, 29, 29, 30, 30, 31, 31, 32, 32, 33, 33, 34, 34, 35,\n+            35, 36, 36, 37, 37, 38, 38, 39, 40, 40, 41, 41, 42, 43, 43, 44, 45, 45, 46, 47, 48, 48, 49, 50, 51, 52, 53,\n+            53, 54, 55, 56, 57, 59, 60, 61, 62, 63, 65, 66, 68, 69, 71, 73, 75, 77, 79, 81, 82, 86, 90, 93, 97, 100,\n+            100, 100, 100, 100, 100, 100, 100, 100 };\n+\n+    /**\n+     * mapping from human readable fanspeed to raw value\n+     */\n+    private static final int FANSPEED_MAP[] = { 0, 1, 3, 7, 15, 31, 63, 127, 255 };\n+\n+    private static final int BYTE_PERCENT_OFFSET = 52;\n+\n+    private String name;\n+    private boolean writable;\n+    private DataType datatype;\n+    private byte address;\n+    private int bitStart;\n+    private int bitLength;\n+\n+    private @Nullable HeliosVentilationDataPoint link;\n+\n+    /**\n+     * parse fullSpec in the properties format to declare a datapoint\n+     *\n+     * @param name the name of the datapoint\n+     * @param fullSpec datapoint specification, see format in datapoints.properties\n+     * @throws HeliosPropertiesFormatException in case fullSpec is not parsable\n+     */\n+    public HeliosVentilationDataPoint(String name, String fullSpec) throws HeliosPropertiesFormatException {\n+        String specWithoutComment;\n+        if (fullSpec.contains(\"#\")) {\n+            specWithoutComment = fullSpec.substring(0, fullSpec.indexOf(\"#\"));\n+        } else {\n+            specWithoutComment = fullSpec;\n+        }\n+        String[] tokens = specWithoutComment.split(\",\");\n+        this.name = name;\n+        if (tokens.length != 3) {\n+            throw new HeliosPropertiesFormatException(\"invalid length\", name, fullSpec);\n+        }\n+        try {\n+            String addr = tokens[0];\n+            String[] addrTokens;\n+            if (addr.contains(\":\")) {\n+                addrTokens = addr.split(\":\");\n+            } else {\n+                addrTokens = new String[] { addr };\n+            }\n+            bitLength = 8;\n+            bitStart = 0;\n+            this.address = (byte) (int) Integer.decode(addrTokens[0]);\n+            if (addrTokens.length > 1) {\n+                bitStart = (byte) (int) Integer.decode(addrTokens[1]);\n+                bitLength = 1;\n+            }\n+            if (addrTokens.length > 2) {\n+                bitLength = (byte) (int) Integer.decode(addrTokens[2]) - bitStart + 1;\n+            }\n+            if (addrTokens.length > 3) {\n+                throw new HeliosPropertiesFormatException(\n+                        \"invalid address spec: too many separators in bit specification\", name, fullSpec);\n+            }\n+        } catch (NumberFormatException e) {\n+            throw new HeliosPropertiesFormatException(\"invalid address spec\", name, fullSpec);\n+        }\n+\n+        this.writable = Boolean.parseBoolean(tokens[1]);\n+        try {\n+            this.datatype = DataType.valueOf(tokens[2].replaceAll(\"\\\\s+\", \"\"));\n+        } catch (IllegalArgumentException e) {\n+            throw new HeliosPropertiesFormatException(\"invalid type spec\", name, fullSpec);\n+        }\n+    }\n+\n+    public HeliosVentilationDataPoint(String name, byte address, boolean writable, DataType datatype) {\n+        this.datatype = datatype;\n+        this.writable = writable;\n+        this.name = name;\n+        this.address = address;\n+    }\n+\n+    public boolean isWritable() {\n+        return writable;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n+\n+    /**\n+     *\n+     * @return the name of the variable, which is also the channel name\n+     */\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /**\n+     *\n+     * @return address of the variable\n+     */\n+    public byte address() {\n+        return address;\n+    }\n+\n+    /**\n+     * @return the bit mask of the data point. 0xFF in case the full byte is used.\n+     */\n+    public byte bitMask() {\n+        byte mask = (byte) 0xff;\n+        if (datatype == DataType.NUMBER || datatype == DataType.SWITCH) {\n+            mask = (byte) (((1 << bitLength) - 1) << bitStart);\n+        }\n+        return mask;\n+    }\n+\n+    /**\n+     * interpret the given byte b and return the value as State.\n+     *\n+     * @param b\n+     * @return state representation of byte value b in current datatype\n+     */\n+    public State asState(byte b) {\n+        int val = b & 0xff;\n+        if (datatype == DataType.TEMPERATURE) {", "originalCommit": "7b1658af39ccc8a2f98f4cc318896c32ee4ff9a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4ca34287fdd55df6f75df4d9f2af94a9b46ff6c4", "url": "https://github.com/openhab/openhab-addons/commit/4ca34287fdd55df6f75df4d9f2af94a9b46ff6c4", "message": "rework after review\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2020-06-14T15:18:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY3MTc2NA==", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r441671764", "bodyText": "Since this does not affect the stability of openHAB, ERROR is too much. Please reduce to WARN. The question is: if this can't be read, the binding won't work, correct? I wonder if we should throw an exception so that the binding initialization fails.\nSidenote: I know the log level is wrong in onewire. Will fix that.", "author": "J-N-K", "createdAt": "2020-06-17T16:25:28Z", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationBindingConstants.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.net.URL;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationBindingConstants {\n+\n+    public static final String BINDING_ID = \"heliosventilation\";\n+\n+    public static final String DATAPOINT_FILE = \"datapoints.properties\";\n+\n+    // List of all Thing Type UIDs\n+    public static final ThingTypeUID THING_TYPE_HELIOS_VENTILATION = new ThingTypeUID(BINDING_ID, \"ventilation\");\n+\n+    public static final Map<Byte, HeliosVentilationDataPoint> DATAPOINTS;\n+\n+    private static final Logger LOGGER;\n+    static {\n+        /* logger is used by readChannelProperties() so we need to initialize logger first. */\n+        LOGGER = LoggerFactory.getLogger(HeliosVentilationBindingConstants.class);\n+        DATAPOINTS = readChannelProperties();\n+    }\n+    // List of all Channel ids\n+    // Channel ids are only in datapoints.properties and thing-types.xml\n+\n+    /**\n+     * parse datapoints from properties\n+     *\n+     */\n+    private static Map<Byte, HeliosVentilationDataPoint> readChannelProperties() {\n+        HashMap<Byte, HeliosVentilationDataPoint> result = new HashMap<Byte, HeliosVentilationDataPoint>();\n+\n+        URL resource = Thread.currentThread().getContextClassLoader().getResource(DATAPOINT_FILE);\n+        Properties properties = new Properties();\n+        try {\n+            properties.load(resource.openStream());\n+\n+            Enumeration<Object> keys = properties.keys();\n+            while (keys.hasMoreElements()) {\n+                String channel = (String) keys.nextElement();\n+                HeliosVentilationDataPoint dp;\n+                try {\n+                    dp = new HeliosVentilationDataPoint(channel, properties.getProperty(channel));\n+                    if (result.containsKey(dp.address())) {\n+                        result.get(dp.address()).append(dp);\n+                    } else {\n+                        result.put(dp.address(), dp);\n+                    }\n+                } catch (HeliosPropertiesFormatException e) {\n+                    LOGGER.error(\"could not read resource file {}, binding will probably fail: {}\", DATAPOINT_FILE,", "originalCommit": "4ca34287fdd55df6f75df4d9f2af94a9b46ff6c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY3Mjk4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r441672989", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return true iff writing to this datapoint requires a read-modify-write on the address\n          \n          \n            \n                 * @return true if writing to this datapoint requires a read-modify-write on the address", "author": "J-N-K", "createdAt": "2020-06-17T16:27:26Z", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationDataPoint.java", "diffHunk": "@@ -0,0 +1,334 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+\n+/**\n+ * The {@next HeliosVentilationDataPoint} is a description of a datapoint in the Helios ventilation system.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationDataPoint {\n+    public enum DataType {\n+        TEMPERATURE,\n+        HYSTERESIS,\n+        FANSPEED,\n+        SWITCH,\n+        BYTE_PERCENT,\n+        PERCENT,\n+        NUMBER\n+    }\n+\n+    /**\n+     * mapping from temperature byte values to \u00b0C\n+     */\n+    private static final int[] TEMP_MAP = { -74, -70, -66, -62, -59, -56, -54, -52, -50, -48, -47, -46, -44, -43, -42,\n+            -41, -40, -39, -38, -37, -36, -35, -34, -33, -33, -32, -31, -30, -30, -29, -28, -28, -27, -27, -26, -25,\n+            -25, -24, -24, -23, -23, -22, -22, -21, -21, -20, -20, -19, -19, -19, -18, -18, -17, -17, -16, -16, -16,\n+            -15, -15, -14, -14, -14, -13, -13, -12, -12, -12, -11, -11, -11, -10, -10, -9, -9, -9, -8, -8, -8, -7, -7,\n+            -7, -6, -6, -6, -5, -5, -5, -4, -4, -4, -3, -3, -3, -2, -2, -2, -1, -1, -1, -1, 0, 0, 0, 1, 1, 1, 2, 2, 2,\n+            3, 3, 3, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 13,\n+            13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 18, 18, 18, 19, 19, 19, 20, 20, 21, 21, 21, 22, 22, 22,\n+            23, 23, 24, 24, 24, 25, 25, 26, 26, 27, 27, 27, 28, 28, 29, 29, 30, 30, 31, 31, 32, 32, 33, 33, 34, 34, 35,\n+            35, 36, 36, 37, 37, 38, 38, 39, 40, 40, 41, 41, 42, 43, 43, 44, 45, 45, 46, 47, 48, 48, 49, 50, 51, 52, 53,\n+            53, 54, 55, 56, 57, 59, 60, 61, 62, 63, 65, 66, 68, 69, 71, 73, 75, 77, 79, 81, 82, 86, 90, 93, 97, 100,\n+            100, 100, 100, 100, 100, 100, 100, 100 };\n+\n+    /**\n+     * mapping from human readable fanspeed to raw value\n+     */\n+    private static final int[] FANSPEED_MAP = { 0, 1, 3, 7, 15, 31, 63, 127, 255 };\n+\n+    private static final int BYTE_PERCENT_OFFSET = 52;\n+\n+    private String name;\n+    private boolean writable;\n+    private DataType datatype;\n+    private byte address;\n+    private int bitStart;\n+    private int bitLength;\n+\n+    private @Nullable HeliosVentilationDataPoint next;\n+\n+    /**\n+     * parse fullSpec in the properties format to declare a datapoint\n+     *\n+     * @param name the name of the datapoint\n+     * @param fullSpec datapoint specification, see format in datapoints.properties\n+     * @throws HeliosPropertiesFormatException in case fullSpec is not parsable\n+     */\n+    public HeliosVentilationDataPoint(String name, String fullSpec) throws HeliosPropertiesFormatException {\n+        String specWithoutComment;\n+        if (fullSpec.contains(\"#\")) {\n+            specWithoutComment = fullSpec.substring(0, fullSpec.indexOf(\"#\"));\n+        } else {\n+            specWithoutComment = fullSpec;\n+        }\n+        String[] tokens = specWithoutComment.split(\",\");\n+        this.name = name;\n+        if (tokens.length != 3) {\n+            throw new HeliosPropertiesFormatException(\"invalid length\", name, fullSpec);\n+        }\n+        try {\n+            String addr = tokens[0];\n+            String[] addrTokens;\n+            if (addr.contains(\":\")) {\n+                addrTokens = addr.split(\":\");\n+            } else {\n+                addrTokens = new String[] { addr };\n+            }\n+            bitLength = 8;\n+            bitStart = 0;\n+            this.address = (byte) (int) Integer.decode(addrTokens[0]);\n+            if (addrTokens.length > 1) {\n+                bitStart = (byte) (int) Integer.decode(addrTokens[1]);\n+                bitLength = 1;\n+            }\n+            if (addrTokens.length > 2) {\n+                bitLength = (byte) (int) Integer.decode(addrTokens[2]) - bitStart + 1;\n+            }\n+            if (addrTokens.length > 3) {\n+                throw new HeliosPropertiesFormatException(\n+                        \"invalid address spec: too many separators in bit specification\", name, fullSpec);\n+            }\n+        } catch (NumberFormatException e) {\n+            throw new HeliosPropertiesFormatException(\"invalid address spec\", name, fullSpec);\n+        }\n+\n+        this.writable = Boolean.parseBoolean(tokens[1]);\n+        try {\n+            this.datatype = DataType.valueOf(tokens[2].replaceAll(\"\\\\s+\", \"\"));\n+        } catch (IllegalArgumentException e) {\n+            throw new HeliosPropertiesFormatException(\"invalid type spec\", name, fullSpec);\n+        }\n+    }\n+\n+    public HeliosVentilationDataPoint(String name, byte address, boolean writable, DataType datatype) {\n+        this.datatype = datatype;\n+        this.writable = writable;\n+        this.name = name;\n+        this.address = address;\n+    }\n+\n+    public boolean isWritable() {\n+        return writable;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n+\n+    /**\n+     *\n+     * @return the name of the variable, which is also the channel name\n+     */\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /**\n+     *\n+     * @return address of the variable\n+     */\n+    public byte address() {\n+        return address;\n+    }\n+\n+    /**\n+     * @return the bit mask of the data point. 0xFF in case the full byte is used.\n+     */\n+    public byte bitMask() {\n+        byte mask = (byte) 0xff;\n+        if (datatype == DataType.NUMBER || datatype == DataType.SWITCH) {\n+            mask = (byte) (((1 << bitLength) - 1) << bitStart);\n+        }\n+        return mask;\n+    }\n+\n+    /**\n+     * interpret the given byte b and return the value as State.\n+     *\n+     * @param b\n+     * @return state representation of byte value b in current datatype\n+     */\n+    public State asState(byte b) {\n+        int val = b & 0xff;\n+        switch (datatype) {\n+            case TEMPERATURE:\n+                return new QuantityType<>(TEMP_MAP[val], SIUnits.CELSIUS);\n+            case BYTE_PERCENT:\n+                return new QuantityType<>((int) ((val - BYTE_PERCENT_OFFSET) * 100.0 / (255 - BYTE_PERCENT_OFFSET)),\n+                        SmartHomeUnits.PERCENT);\n+            case SWITCH:\n+                if (bitLength != 1) {\n+                    return UnDefType.UNDEF;\n+                } else if ((b & (1 << bitStart)) != 0) {\n+                    return OnOffType.ON;\n+                } else {\n+                    return OnOffType.OFF;\n+                }\n+            case NUMBER:\n+                int value = (b & bitMask()) >> bitStart;\n+                return new DecimalType(value);\n+            case PERCENT:\n+                return new QuantityType<>(val, SmartHomeUnits.PERCENT);\n+            case FANSPEED:\n+                int i = 1;\n+                while (i < FANSPEED_MAP.length && FANSPEED_MAP[i] < val) {\n+                    i++;\n+                }\n+                return new DecimalType(i);\n+            case HYSTERESIS:\n+                return new QuantityType<>(val / 3, SIUnits.CELSIUS);\n+            default:\n+                return UnDefType.UNDEF;\n+        }\n+    }\n+\n+    /**\n+     * interpret the given byte b and return the value as string.\n+     *\n+     * @param b\n+     * @return sting representation of byte value b in current datatype\n+     */\n+    public String asString(byte b) {\n+        State ste = asState(b);\n+        String str = ste.toString();\n+        if (ste instanceof UnDefType) {\n+            return String.format(\"<unknown type> %02X \", b);\n+        } else {\n+            return str;\n+        }\n+    }\n+\n+    /**\n+     * generate byte data to transmit\n+     *\n+     * @param val is the state of a channel\n+     * @return byte value with RS485 representation. Bit level values are returned in the correct location, but other\n+     *         bits/datapoints in the same address are zero.\n+     */\n+    public byte getTransmitDataFor(State val) {\n+        byte result = 0;\n+        DecimalType value = val.as(DecimalType.class);\n+        if (value == null) {\n+            /*\n+             * if value is not convertible to a numeric type we cannot do anything reasonable with it, let's use the\n+             * initial value for it\n+             */\n+        } else {\n+            QuantityType<?> quantvalue;\n+            switch (datatype) {\n+                case TEMPERATURE:\n+                    quantvalue = ((QuantityType<?>) val);\n+                    quantvalue = quantvalue.toUnit(SIUnits.CELSIUS);\n+                    if (quantvalue != null) {\n+                        value = quantvalue.as(DecimalType.class);\n+                        if (value != null) {\n+                            int temp = (int) Math.round(value.doubleValue());\n+                            int i = 0;\n+                            while (i < TEMP_MAP.length && TEMP_MAP[i] < temp) {\n+                                i++;\n+                            }\n+                            result = (byte) i;\n+                        }\n+                    }\n+                    break;\n+                case FANSPEED:\n+                    int i = value.intValue();\n+                    if (i < 0) {\n+                        i = 0;\n+                    } else if (i > 8) {\n+                        i = 8;\n+                    }\n+                    result = (byte) FANSPEED_MAP[i];\n+                    break;\n+                case BYTE_PERCENT:\n+                    result = (byte) ((value.doubleValue() / 100.0) * (255 - BYTE_PERCENT_OFFSET) + BYTE_PERCENT_OFFSET);\n+                    break;\n+                case PERCENT:\n+                    double d = (Math.round(value.doubleValue()));\n+                    if (d < 0.0) {\n+                        d = 0.0;\n+                    } else if (d > 100.0) {\n+                        d = 100.0;\n+                    }\n+                    result = (byte) d;\n+                    break;\n+                case HYSTERESIS:\n+                    quantvalue = ((QuantityType<?>) val).toUnit(SIUnits.CELSIUS);\n+                    if (quantvalue != null) {\n+                        result = (byte) (quantvalue.intValue() * 3);\n+                    }\n+                    break;\n+                case SWITCH:\n+                case NUMBER:\n+                    // those are the types supporting bit level specification\n+                    // output only the relevant bits\n+                    result = (byte) (value.intValue() << bitStart);\n+                    break;\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Get further datapoint linked to the same address.\n+     *\n+     * @return sister datapoint\n+     */\n+    public @Nullable HeliosVentilationDataPoint next() {\n+        return next;\n+    }\n+\n+    /**\n+     * Add a next to a datapoint on the same address.\n+     * Caller has to ensure that identical datapoints are not added several times.\n+     *\n+     * @param next is the sister datapoint\n+     */\n+    public void append(HeliosVentilationDataPoint next) {\n+        HeliosVentilationDataPoint existing = this.next;\n+        if (this == next) {\n+            // this datapoint is already there, so we do nothing and return\n+            return;\n+        } else if (existing != null) {\n+            existing.append(next);\n+        } else {\n+            this.next = next;\n+        }\n+    }\n+\n+    /**\n+     * @return true iff writing to this datapoint requires a read-modify-write on the address", "originalCommit": "4ca34287fdd55df6f75df4d9f2af94a9b46ff6c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY5NDc4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r441694789", "bodyText": "Why do you do this? Wouldn't\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n          \n          \n            \n                private final Logger logger = LoggerFactory.getLogger(HeliosVentilationHandler.class);\n          \n      \n    \n    \n  \n\nalso work?", "author": "J-N-K", "createdAt": "2020-06-17T17:02:39Z", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,461 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());", "originalCommit": "4ca34287fdd55df6f75df4d9f2af94a9b46ff6c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI0OTg4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r443249885", "bodyText": "yes, works also. I guess I have seen that somewhere in another binding.", "author": "ramack", "createdAt": "2020-06-21T19:33:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY5NDc4OQ=="}], "type": "inlineReview"}, {"oid": "3b74408895bd3409705ecb810bc4fb274940d914", "url": "https://github.com/openhab/openhab-addons/commit/3b74408895bd3409705ecb810bc4fb274940d914", "message": "rework after review\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2020-06-21T19:34:44Z", "type": "commit"}, {"oid": "7bf1054e3713fc8265f6168ebfd0881c41450e78", "url": "https://github.com/openhab/openhab-addons/commit/7bf1054e3713fc8265f6168ebfd0881c41450e78", "message": "adjusting version\n\nSigned-off-by: Raphael Mack <ramack@raphael-mack.de>", "committedDate": "2020-06-27T17:52:09Z", "type": "commit"}]}