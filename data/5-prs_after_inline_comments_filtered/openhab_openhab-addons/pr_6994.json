{"pr_number": 6994, "pr_title": "[sunspec] Modbus: sunspec bundle auto discovery", "pr_createdAt": "2020-02-10T23:07:26Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/6994", "timeline": [{"oid": "c79dfafc15635c3d5ea30a09bb2785bba6919288", "url": "https://github.com/openhab/openhab-addons/commit/c79dfafc15635c3d5ea30a09bb2785bba6919288", "message": "[sunspec] Added discovery process\n\n\nSigned-off-by: Nagy Attila Gabor <mrbig@sneaker.hu>", "committedDate": "2020-03-12T23:19:14Z", "type": "forcePushed"}, {"oid": "2dce455a3cb6f279720ceedbb33b9f61c08356c3", "url": "https://github.com/openhab/openhab-addons/commit/2dce455a3cb6f279720ceedbb33b9f61c08356c3", "message": "[sunspec] Added discovery process\n\n\nSigned-off-by: Nagy Attila Gabor <mrbig@sneaker.hu>", "committedDate": "2020-03-15T17:35:37Z", "type": "forcePushed"}, {"oid": "fb700437619f4982034d2df01b75d17d2881deb3", "url": "https://github.com/openhab/openhab-addons/commit/fb700437619f4982034d2df01b75d17d2881deb3", "message": "[sunspec] Added discovery process\n\n\nSigned-off-by: Nagy Attila Gabor <mrbig@sneaker.hu>", "committedDate": "2020-04-17T22:09:46Z", "type": "forcePushed"}, {"oid": "1cb2d390458d9ad3b81aed783520aa199f1cb7ef", "url": "https://github.com/openhab/openhab-addons/commit/1cb2d390458d9ad3b81aed783520aa199f1cb7ef", "message": "[sunspec] Added discovery process to SunSpec bundle\n\nThe discovery process will read the common model block of the device\nwhich must be supported by every SunSpec compatible device.\n\nFor there model types are organized into block, so we hop through\nall the supported blocks and emit them as discovered.\n\nDiscovered devices will contain theire start address and block length in\nthe configuration properties.\n\nSigned-off-by: Nagy Attila Gabor <mrbig@sneaker.hu>", "committedDate": "2020-04-18T11:58:50Z", "type": "commit"}, {"oid": "1cb2d390458d9ad3b81aed783520aa199f1cb7ef", "url": "https://github.com/openhab/openhab-addons/commit/1cb2d390458d9ad3b81aed783520aa199f1cb7ef", "message": "[sunspec] Added discovery process to SunSpec bundle\n\nThe discovery process will read the common model block of the device\nwhich must be supported by every SunSpec compatible device.\n\nFor there model types are organized into block, so we hop through\nall the supported blocks and emit them as discovered.\n\nDiscovered devices will contain theire start address and block length in\nthe configuration properties.\n\nSigned-off-by: Nagy Attila Gabor <mrbig@sneaker.hu>", "committedDate": "2020-04-18T11:58:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc3NTcxOA==", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r410775718", "bodyText": "Is this used?", "author": "cpmeister", "createdAt": "2020-04-19T00:01:50Z", "path": "bundles/org.openhab.binding.modbus.sunspec/src/main/java/org/openhab/binding/modbus/sunspec/internal/discovery/SunspecDiscoveryProcess.java", "diffHunk": "@@ -0,0 +1,425 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.sunspec.internal.discovery;\n+\n+import static org.openhab.binding.modbus.sunspec.internal.SunSpecConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.modbus.discovery.ModbusDiscoveryListener;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.sunspec.internal.dto.CommonModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.dto.ModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.parser.CommonModelParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusBitUtilities;\n+import org.openhab.io.transport.modbus.ModbusConstants.ValueType;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusSlaveErrorResponseException;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used by the SunspecDiscoveryParticipant to detect\n+ * the model blocks defined by the given device.\n+ * It scans trough the defined model items and notifies the\n+ * discovery service about the discovered devices\n+ *\n+ * @author Nagy Attila Gabor - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SunspecDiscoveryProcess {\n+\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(SunspecDiscoveryProcess.class);\n+\n+    /**\n+     * The handler instance for this device\n+     */\n+    private final ModbusEndpointThingHandler handler;\n+\n+    /**\n+     * The endpoint where we can reach the device\n+     */\n+    private final Optional<ModbusSlaveEndpoint> endpoint;\n+\n+    /**\n+     * Listener for the discovered devices. We get this\n+     * from the main discovery service, and it is used to\n+     * submit any discovered Sunspec devices\n+     */\n+    private final ModbusDiscoveryListener listener;\n+\n+    /**\n+     * The endpoint's slave id\n+     */\n+    private Integer slaveId;\n+\n+    /**\n+     * Number of maximum retries\n+     */\n+    private Integer maxTries = 3;\n+\n+    /**\n+     * List of start addresses to try\n+     */\n+    private List<Integer> possibleAddresses;\n+\n+    /**\n+     * This is the base address where the next block should be searched for\n+     */\n+    private int baseAddress = 40000;\n+\n+    /**\n+     * Count of valid Sunspec blocks found\n+     */\n+    private int blocksFound = 0;\n+\n+    /**\n+     * Parser for commonblock\n+     */\n+    private final CommonModelParser commonBlockParser;\n+\n+    /**\n+     * The last common block found. This is used\n+     * to get the details of any found devices\n+     */\n+    private Optional<CommonModelBlock> lastCommonBlock = Optional.empty();\n+\n+    /**\n+     * New instances of this class should get a reference to the handler\n+     *\n+     * @throws EndpointNotInitializedException\n+     */\n+    public SunspecDiscoveryProcess(ModbusEndpointThingHandler handler, ModbusDiscoveryListener listener)\n+            throws EndpointNotInitializedException {\n+        this.handler = handler;\n+        ModbusSlaveEndpoint endpoint = this.handler.asSlaveEndpoint();\n+        if (endpoint != null) {\n+            this.endpoint = Optional.of(endpoint);\n+        } else {\n+            this.endpoint = Optional.empty();\n+        }\n+        slaveId = handler.getSlaveId();\n+        this.listener = listener;\n+        commonBlockParser = new CommonModelParser();\n+        possibleAddresses = new CopyOnWriteArrayList<>();\n+        // Preferred and alternate base registers\n+        // @see SunSpec Information Model Overview\n+        possibleAddresses.add(40000);\n+        possibleAddresses.add(50000);\n+        possibleAddresses.add(0);\n+    }\n+\n+    /**\n+     * Set the maximum number of retries for operations\n+     *\n+     * @param num the new value to set\n+     * @return\n+     */\n+    public SunspecDiscoveryProcess setMaxTries(Integer num) {", "originalCommit": "1cb2d390458d9ad3b81aed783520aa199f1cb7ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDg1NDEzMA==", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r410854130", "bodyText": "not at the moment. Removed, I can add it back later if there will be a need to set this value.\nAccording to this changed the maxTries property to static final", "author": "mrbig", "createdAt": "2020-04-19T08:47:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc3NTcxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc3NjE1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r410776152", "bodyText": "please remove this blank line", "author": "cpmeister", "createdAt": "2020-04-19T00:05:03Z", "path": "bundles/org.openhab.binding.modbus.sunspec/src/main/java/org/openhab/binding/modbus/sunspec/internal/discovery/SunspecDiscoveryProcess.java", "diffHunk": "@@ -0,0 +1,425 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.sunspec.internal.discovery;\n+\n+import static org.openhab.binding.modbus.sunspec.internal.SunSpecConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.modbus.discovery.ModbusDiscoveryListener;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.sunspec.internal.dto.CommonModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.dto.ModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.parser.CommonModelParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusBitUtilities;\n+import org.openhab.io.transport.modbus.ModbusConstants.ValueType;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusSlaveErrorResponseException;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used by the SunspecDiscoveryParticipant to detect\n+ * the model blocks defined by the given device.\n+ * It scans trough the defined model items and notifies the\n+ * discovery service about the discovered devices\n+ *\n+ * @author Nagy Attila Gabor - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SunspecDiscoveryProcess {\n+\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(SunspecDiscoveryProcess.class);\n+\n+    /**\n+     * The handler instance for this device\n+     */\n+    private final ModbusEndpointThingHandler handler;\n+\n+    /**\n+     * The endpoint where we can reach the device\n+     */\n+    private final Optional<ModbusSlaveEndpoint> endpoint;\n+\n+    /**\n+     * Listener for the discovered devices. We get this\n+     * from the main discovery service, and it is used to\n+     * submit any discovered Sunspec devices\n+     */\n+    private final ModbusDiscoveryListener listener;\n+\n+    /**\n+     * The endpoint's slave id\n+     */\n+    private Integer slaveId;\n+\n+    /**\n+     * Number of maximum retries\n+     */\n+    private Integer maxTries = 3;\n+\n+    /**\n+     * List of start addresses to try\n+     */\n+    private List<Integer> possibleAddresses;\n+\n+    /**\n+     * This is the base address where the next block should be searched for\n+     */\n+    private int baseAddress = 40000;\n+\n+    /**\n+     * Count of valid Sunspec blocks found\n+     */\n+    private int blocksFound = 0;\n+\n+    /**\n+     * Parser for commonblock\n+     */\n+    private final CommonModelParser commonBlockParser;\n+\n+    /**\n+     * The last common block found. This is used\n+     * to get the details of any found devices\n+     */\n+    private Optional<CommonModelBlock> lastCommonBlock = Optional.empty();\n+\n+    /**\n+     * New instances of this class should get a reference to the handler\n+     *\n+     * @throws EndpointNotInitializedException\n+     */\n+    public SunspecDiscoveryProcess(ModbusEndpointThingHandler handler, ModbusDiscoveryListener listener)\n+            throws EndpointNotInitializedException {\n+        this.handler = handler;\n+        ModbusSlaveEndpoint endpoint = this.handler.asSlaveEndpoint();\n+        if (endpoint != null) {\n+            this.endpoint = Optional.of(endpoint);\n+        } else {\n+            this.endpoint = Optional.empty();\n+        }\n+        slaveId = handler.getSlaveId();\n+        this.listener = listener;\n+        commonBlockParser = new CommonModelParser();\n+        possibleAddresses = new CopyOnWriteArrayList<>();\n+        // Preferred and alternate base registers\n+        // @see SunSpec Information Model Overview\n+        possibleAddresses.add(40000);\n+        possibleAddresses.add(50000);\n+        possibleAddresses.add(0);\n+    }\n+\n+    /**\n+     * Set the maximum number of retries for operations\n+     *\n+     * @param num the new value to set\n+     * @return\n+     */\n+    public SunspecDiscoveryProcess setMaxTries(Integer num) {\n+        this.maxTries = num;\n+        return this;\n+    }\n+\n+    /**\n+     * Start model detection\n+     *\n+     * @param uid the thing type to look for\n+     * @throws EndpointNotInitializedException\n+     */\n+    public void detectModel() throws EndpointNotInitializedException {\n+\n+        if (!this.endpoint.isPresent()) {\n+            logger.debug(\"Endpoint is null, can not continue with discovery\");\n+            throw new EndpointNotInitializedException();\n+        }\n+\n+        if (possibleAddresses.size() < 1) {\n+            parsingFinished();\n+            return;\n+        }\n+        // Try the next address from the possibles\n+        baseAddress = possibleAddresses.get(0);\n+        logger.trace(\"Beginning scan for SunSpec device at address {}\", baseAddress);\n+\n+        BasicModbusReadRequestBlueprint request = new BasicModbusReadRequestBlueprint(slaveId,\n+                ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS, baseAddress, // Start address\n+                SUNSPEC_ID_SIZE, // number or words to return\n+                maxTries);\n+\n+        PollTask task = new BasicPollTaskImpl(endpoint.get(), request, new ModbusReadCallback() {\n+\n+            @Override\n+            public void onRegisters(ModbusReadRequestBlueprint request, ModbusRegisterArray registers) {\n+\n+                headerReceived(registers);\n+\n+            }\n+\n+            @Override\n+            public void onError(ModbusReadRequestBlueprint request, Exception error) {\n+                handleError(error);\n+            }\n+\n+            @Override\n+            public void onBits(@Nullable ModbusReadRequestBlueprint request, @Nullable BitArray bits) {\n+                // don't care, we don't expect this result\n+            }\n+        });\n+\n+        handler.getManagerRef().get().submitOneTimePoll(task);\n+    }\n+\n+    /**\n+     * We received the first two words, that should equal to SunS\n+     */\n+    private void headerReceived(ModbusRegisterArray registers) {\n+        logger.trace(\"Received response from device {}\", registers.toString());\n+\n+        Optional<DecimalType> id = ModbusBitUtilities.extractStateFromRegisters(registers, 0, ValueType.UINT32);\n+\n+        if (!id.isPresent() || id.get().longValue() != SUNSPEC_ID) {\n+            logger.debug(\"Could not find SunSpec DID at address {}, received: {}, expected: {}\", baseAddress, id,\n+                    SUNSPEC_ID);\n+            possibleAddresses.remove(0);\n+            try {\n+                detectModel();\n+            } catch (EndpointNotInitializedException ex) {\n+                // This should not happen\n+                parsingFinished();\n+            }\n+            return;\n+        }\n+\n+        logger.trace(\"Header looks correct\");\n+        baseAddress += SUNSPEC_ID_SIZE;\n+\n+        lookForModelBlock();\n+    }\n+\n+    /**\n+     * Look for a valid model block at the current base address\n+     */\n+    private void lookForModelBlock() {\n+        BasicModbusReadRequestBlueprint request = new BasicModbusReadRequestBlueprint(slaveId,\n+                ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS, baseAddress, // Start address\n+                MODEL_HEADER_SIZE, // number or words to return\n+                maxTries);\n+\n+        PollTask task = new BasicPollTaskImpl(endpoint.get(), request, new ModbusReadCallback() {\n+\n+            @Override\n+            public void onRegisters(ModbusReadRequestBlueprint request, ModbusRegisterArray registers) {\n+", "originalCommit": "1cb2d390458d9ad3b81aed783520aa199f1cb7ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDg1NDE0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r410854142", "bodyText": "ok", "author": "mrbig", "createdAt": "2020-04-19T08:47:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc3NjE1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc3NjI3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r410776279", "bodyText": "please remove blank line", "author": "cpmeister", "createdAt": "2020-04-19T00:06:02Z", "path": "bundles/org.openhab.binding.modbus.sunspec/src/main/java/org/openhab/binding/modbus/sunspec/internal/discovery/SunspecDiscoveryProcess.java", "diffHunk": "@@ -0,0 +1,425 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.sunspec.internal.discovery;\n+\n+import static org.openhab.binding.modbus.sunspec.internal.SunSpecConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.modbus.discovery.ModbusDiscoveryListener;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.sunspec.internal.dto.CommonModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.dto.ModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.parser.CommonModelParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusBitUtilities;\n+import org.openhab.io.transport.modbus.ModbusConstants.ValueType;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusSlaveErrorResponseException;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used by the SunspecDiscoveryParticipant to detect\n+ * the model blocks defined by the given device.\n+ * It scans trough the defined model items and notifies the\n+ * discovery service about the discovered devices\n+ *\n+ * @author Nagy Attila Gabor - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SunspecDiscoveryProcess {\n+\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(SunspecDiscoveryProcess.class);\n+\n+    /**\n+     * The handler instance for this device\n+     */\n+    private final ModbusEndpointThingHandler handler;\n+\n+    /**\n+     * The endpoint where we can reach the device\n+     */\n+    private final Optional<ModbusSlaveEndpoint> endpoint;\n+\n+    /**\n+     * Listener for the discovered devices. We get this\n+     * from the main discovery service, and it is used to\n+     * submit any discovered Sunspec devices\n+     */\n+    private final ModbusDiscoveryListener listener;\n+\n+    /**\n+     * The endpoint's slave id\n+     */\n+    private Integer slaveId;\n+\n+    /**\n+     * Number of maximum retries\n+     */\n+    private Integer maxTries = 3;\n+\n+    /**\n+     * List of start addresses to try\n+     */\n+    private List<Integer> possibleAddresses;\n+\n+    /**\n+     * This is the base address where the next block should be searched for\n+     */\n+    private int baseAddress = 40000;\n+\n+    /**\n+     * Count of valid Sunspec blocks found\n+     */\n+    private int blocksFound = 0;\n+\n+    /**\n+     * Parser for commonblock\n+     */\n+    private final CommonModelParser commonBlockParser;\n+\n+    /**\n+     * The last common block found. This is used\n+     * to get the details of any found devices\n+     */\n+    private Optional<CommonModelBlock> lastCommonBlock = Optional.empty();\n+\n+    /**\n+     * New instances of this class should get a reference to the handler\n+     *\n+     * @throws EndpointNotInitializedException\n+     */\n+    public SunspecDiscoveryProcess(ModbusEndpointThingHandler handler, ModbusDiscoveryListener listener)\n+            throws EndpointNotInitializedException {\n+        this.handler = handler;\n+        ModbusSlaveEndpoint endpoint = this.handler.asSlaveEndpoint();\n+        if (endpoint != null) {\n+            this.endpoint = Optional.of(endpoint);\n+        } else {\n+            this.endpoint = Optional.empty();\n+        }\n+        slaveId = handler.getSlaveId();\n+        this.listener = listener;\n+        commonBlockParser = new CommonModelParser();\n+        possibleAddresses = new CopyOnWriteArrayList<>();\n+        // Preferred and alternate base registers\n+        // @see SunSpec Information Model Overview\n+        possibleAddresses.add(40000);\n+        possibleAddresses.add(50000);\n+        possibleAddresses.add(0);\n+    }\n+\n+    /**\n+     * Set the maximum number of retries for operations\n+     *\n+     * @param num the new value to set\n+     * @return\n+     */\n+    public SunspecDiscoveryProcess setMaxTries(Integer num) {\n+        this.maxTries = num;\n+        return this;\n+    }\n+\n+    /**\n+     * Start model detection\n+     *\n+     * @param uid the thing type to look for\n+     * @throws EndpointNotInitializedException\n+     */\n+    public void detectModel() throws EndpointNotInitializedException {\n+\n+        if (!this.endpoint.isPresent()) {\n+            logger.debug(\"Endpoint is null, can not continue with discovery\");\n+            throw new EndpointNotInitializedException();\n+        }\n+\n+        if (possibleAddresses.size() < 1) {\n+            parsingFinished();\n+            return;\n+        }\n+        // Try the next address from the possibles\n+        baseAddress = possibleAddresses.get(0);\n+        logger.trace(\"Beginning scan for SunSpec device at address {}\", baseAddress);\n+\n+        BasicModbusReadRequestBlueprint request = new BasicModbusReadRequestBlueprint(slaveId,\n+                ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS, baseAddress, // Start address\n+                SUNSPEC_ID_SIZE, // number or words to return\n+                maxTries);\n+\n+        PollTask task = new BasicPollTaskImpl(endpoint.get(), request, new ModbusReadCallback() {\n+\n+            @Override\n+            public void onRegisters(ModbusReadRequestBlueprint request, ModbusRegisterArray registers) {\n+\n+                headerReceived(registers);\n+\n+            }\n+\n+            @Override\n+            public void onError(ModbusReadRequestBlueprint request, Exception error) {\n+                handleError(error);\n+            }\n+\n+            @Override\n+            public void onBits(@Nullable ModbusReadRequestBlueprint request, @Nullable BitArray bits) {\n+                // don't care, we don't expect this result\n+            }\n+        });\n+\n+        handler.getManagerRef().get().submitOneTimePoll(task);\n+    }\n+\n+    /**\n+     * We received the first two words, that should equal to SunS\n+     */\n+    private void headerReceived(ModbusRegisterArray registers) {\n+        logger.trace(\"Received response from device {}\", registers.toString());\n+\n+        Optional<DecimalType> id = ModbusBitUtilities.extractStateFromRegisters(registers, 0, ValueType.UINT32);\n+\n+        if (!id.isPresent() || id.get().longValue() != SUNSPEC_ID) {\n+            logger.debug(\"Could not find SunSpec DID at address {}, received: {}, expected: {}\", baseAddress, id,\n+                    SUNSPEC_ID);\n+            possibleAddresses.remove(0);\n+            try {\n+                detectModel();\n+            } catch (EndpointNotInitializedException ex) {\n+                // This should not happen\n+                parsingFinished();\n+            }\n+            return;\n+        }\n+\n+        logger.trace(\"Header looks correct\");\n+        baseAddress += SUNSPEC_ID_SIZE;\n+\n+        lookForModelBlock();\n+    }\n+\n+    /**\n+     * Look for a valid model block at the current base address\n+     */\n+    private void lookForModelBlock() {\n+        BasicModbusReadRequestBlueprint request = new BasicModbusReadRequestBlueprint(slaveId,\n+                ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS, baseAddress, // Start address\n+                MODEL_HEADER_SIZE, // number or words to return\n+                maxTries);\n+\n+        PollTask task = new BasicPollTaskImpl(endpoint.get(), request, new ModbusReadCallback() {\n+\n+            @Override\n+            public void onRegisters(ModbusReadRequestBlueprint request, ModbusRegisterArray registers) {\n+\n+                modelBlockReceived(registers);\n+", "originalCommit": "1cb2d390458d9ad3b81aed783520aa199f1cb7ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDg1NDE1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r410854156", "bodyText": "ok", "author": "mrbig", "createdAt": "2020-04-19T08:47:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc3NjI3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc3NjkxNA==", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r410776914", "bodyText": "The use of Optional here would be better substituted by returning a nullable ModelBlock instead.", "author": "cpmeister", "createdAt": "2020-04-19T00:10:49Z", "path": "bundles/org.openhab.binding.modbus.sunspec/src/main/java/org/openhab/binding/modbus/sunspec/internal/handler/AbstractSunSpecHandler.java", "diffHunk": "@@ -164,6 +170,26 @@ private void startUp() {\n         }\n     }\n \n+    /**\n+     * Load and parse configuration from the properties\n+     * These will be set by the auto discovery process\n+     */\n+    private Optional<ModelBlock> getAddressFromProperties() {", "originalCommit": "1cb2d390458d9ad3b81aed783520aa199f1cb7ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDg1NDE5MA==", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r410854190", "bodyText": "Ok, changed to nullable.", "author": "mrbig", "createdAt": "2020-04-19T08:48:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc3NjkxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc3NzUwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r410777505", "bodyText": "I would prefer if this was a nullable field instead.", "author": "cpmeister", "createdAt": "2020-04-19T00:15:05Z", "path": "bundles/org.openhab.binding.modbus.sunspec/src/main/java/org/openhab/binding/modbus/sunspec/internal/discovery/SunspecDiscoveryProcess.java", "diffHunk": "@@ -0,0 +1,425 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.sunspec.internal.discovery;\n+\n+import static org.openhab.binding.modbus.sunspec.internal.SunSpecConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.modbus.discovery.ModbusDiscoveryListener;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.sunspec.internal.dto.CommonModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.dto.ModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.parser.CommonModelParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusBitUtilities;\n+import org.openhab.io.transport.modbus.ModbusConstants.ValueType;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusSlaveErrorResponseException;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used by the SunspecDiscoveryParticipant to detect\n+ * the model blocks defined by the given device.\n+ * It scans trough the defined model items and notifies the\n+ * discovery service about the discovered devices\n+ *\n+ * @author Nagy Attila Gabor - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SunspecDiscoveryProcess {\n+\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(SunspecDiscoveryProcess.class);\n+\n+    /**\n+     * The handler instance for this device\n+     */\n+    private final ModbusEndpointThingHandler handler;\n+\n+    /**\n+     * The endpoint where we can reach the device\n+     */\n+    private final Optional<ModbusSlaveEndpoint> endpoint;\n+\n+    /**\n+     * Listener for the discovered devices. We get this\n+     * from the main discovery service, and it is used to\n+     * submit any discovered Sunspec devices\n+     */\n+    private final ModbusDiscoveryListener listener;\n+\n+    /**\n+     * The endpoint's slave id\n+     */\n+    private Integer slaveId;\n+\n+    /**\n+     * Number of maximum retries\n+     */\n+    private Integer maxTries = 3;\n+\n+    /**\n+     * List of start addresses to try\n+     */\n+    private List<Integer> possibleAddresses;\n+\n+    /**\n+     * This is the base address where the next block should be searched for\n+     */\n+    private int baseAddress = 40000;\n+\n+    /**\n+     * Count of valid Sunspec blocks found\n+     */\n+    private int blocksFound = 0;\n+\n+    /**\n+     * Parser for commonblock\n+     */\n+    private final CommonModelParser commonBlockParser;\n+\n+    /**\n+     * The last common block found. This is used\n+     * to get the details of any found devices\n+     */\n+    private Optional<CommonModelBlock> lastCommonBlock = Optional.empty();", "originalCommit": "1cb2d390458d9ad3b81aed783520aa199f1cb7ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDg1NDIwMw==", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r410854203", "bodyText": "ok, changed to nullable", "author": "mrbig", "createdAt": "2020-04-19T08:48:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc3NzUwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc3NzU4NA==", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r410777584", "bodyText": "Can you make this primitive?", "author": "cpmeister", "createdAt": "2020-04-19T00:15:45Z", "path": "bundles/org.openhab.binding.modbus.sunspec/src/main/java/org/openhab/binding/modbus/sunspec/internal/discovery/SunspecDiscoveryProcess.java", "diffHunk": "@@ -0,0 +1,425 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.sunspec.internal.discovery;\n+\n+import static org.openhab.binding.modbus.sunspec.internal.SunSpecConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.modbus.discovery.ModbusDiscoveryListener;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.sunspec.internal.dto.CommonModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.dto.ModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.parser.CommonModelParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusBitUtilities;\n+import org.openhab.io.transport.modbus.ModbusConstants.ValueType;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusSlaveErrorResponseException;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used by the SunspecDiscoveryParticipant to detect\n+ * the model blocks defined by the given device.\n+ * It scans trough the defined model items and notifies the\n+ * discovery service about the discovered devices\n+ *\n+ * @author Nagy Attila Gabor - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SunspecDiscoveryProcess {\n+\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(SunspecDiscoveryProcess.class);\n+\n+    /**\n+     * The handler instance for this device\n+     */\n+    private final ModbusEndpointThingHandler handler;\n+\n+    /**\n+     * The endpoint where we can reach the device\n+     */\n+    private final Optional<ModbusSlaveEndpoint> endpoint;\n+\n+    /**\n+     * Listener for the discovered devices. We get this\n+     * from the main discovery service, and it is used to\n+     * submit any discovered Sunspec devices\n+     */\n+    private final ModbusDiscoveryListener listener;\n+\n+    /**\n+     * The endpoint's slave id\n+     */\n+    private Integer slaveId;", "originalCommit": "1cb2d390458d9ad3b81aed783520aa199f1cb7ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDg1NDI1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r410854251", "bodyText": "no problem.", "author": "mrbig", "createdAt": "2020-04-19T08:48:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc3NzU4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc3NzYwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r410777601", "bodyText": "Can you make this primitive?", "author": "cpmeister", "createdAt": "2020-04-19T00:15:54Z", "path": "bundles/org.openhab.binding.modbus.sunspec/src/main/java/org/openhab/binding/modbus/sunspec/internal/discovery/SunspecDiscoveryProcess.java", "diffHunk": "@@ -0,0 +1,425 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.sunspec.internal.discovery;\n+\n+import static org.openhab.binding.modbus.sunspec.internal.SunSpecConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.modbus.discovery.ModbusDiscoveryListener;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.sunspec.internal.dto.CommonModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.dto.ModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.parser.CommonModelParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusBitUtilities;\n+import org.openhab.io.transport.modbus.ModbusConstants.ValueType;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusSlaveErrorResponseException;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used by the SunspecDiscoveryParticipant to detect\n+ * the model blocks defined by the given device.\n+ * It scans trough the defined model items and notifies the\n+ * discovery service about the discovered devices\n+ *\n+ * @author Nagy Attila Gabor - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SunspecDiscoveryProcess {\n+\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(SunspecDiscoveryProcess.class);\n+\n+    /**\n+     * The handler instance for this device\n+     */\n+    private final ModbusEndpointThingHandler handler;\n+\n+    /**\n+     * The endpoint where we can reach the device\n+     */\n+    private final Optional<ModbusSlaveEndpoint> endpoint;\n+\n+    /**\n+     * Listener for the discovered devices. We get this\n+     * from the main discovery service, and it is used to\n+     * submit any discovered Sunspec devices\n+     */\n+    private final ModbusDiscoveryListener listener;\n+\n+    /**\n+     * The endpoint's slave id\n+     */\n+    private Integer slaveId;\n+\n+    /**\n+     * Number of maximum retries\n+     */\n+    private Integer maxTries = 3;", "originalCommit": "1cb2d390458d9ad3b81aed783520aa199f1cb7ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDg1NDMzMg==", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r410854332", "bodyText": "yes, also now it's static final, because it's fixed at the moment.", "author": "mrbig", "createdAt": "2020-04-19T08:48:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc3NzYwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc3ODAyMw==", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r410778023", "bodyText": "You can make this a nullable field instead. Because the field is final you won't have to cache it to a local variable for null checks.", "author": "cpmeister", "createdAt": "2020-04-19T00:18:54Z", "path": "bundles/org.openhab.binding.modbus.sunspec/src/main/java/org/openhab/binding/modbus/sunspec/internal/discovery/SunspecDiscoveryProcess.java", "diffHunk": "@@ -0,0 +1,425 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.sunspec.internal.discovery;\n+\n+import static org.openhab.binding.modbus.sunspec.internal.SunSpecConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.modbus.discovery.ModbusDiscoveryListener;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.sunspec.internal.dto.CommonModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.dto.ModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.parser.CommonModelParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusBitUtilities;\n+import org.openhab.io.transport.modbus.ModbusConstants.ValueType;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusSlaveErrorResponseException;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used by the SunspecDiscoveryParticipant to detect\n+ * the model blocks defined by the given device.\n+ * It scans trough the defined model items and notifies the\n+ * discovery service about the discovered devices\n+ *\n+ * @author Nagy Attila Gabor - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SunspecDiscoveryProcess {\n+\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(SunspecDiscoveryProcess.class);\n+\n+    /**\n+     * The handler instance for this device\n+     */\n+    private final ModbusEndpointThingHandler handler;\n+\n+    /**\n+     * The endpoint where we can reach the device\n+     */\n+    private final Optional<ModbusSlaveEndpoint> endpoint;", "originalCommit": "1cb2d390458d9ad3b81aed783520aa199f1cb7ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDg1NDM4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r410854387", "bodyText": "Instead I was able to refactor it to be true NonNull. (There's no point in starting a discovery if this is not set)", "author": "mrbig", "createdAt": "2020-04-19T08:48:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc3ODAyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc3ODA4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r410778087", "bodyText": "Can you make this set static?", "author": "cpmeister", "createdAt": "2020-04-19T00:19:23Z", "path": "bundles/org.openhab.binding.modbus.sunspec/src/main/java/org/openhab/binding/modbus/sunspec/internal/discovery/SunspecDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.sunspec.internal.discovery;\n+\n+import static org.openhab.binding.modbus.sunspec.internal.SunSpecConstants.SUPPORTED_THING_TYPES_UIDS;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.openhab.binding.modbus.discovery.ModbusDiscoveryListener;\n+import org.openhab.binding.modbus.discovery.ModbusDiscoveryParticipant;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Discovery service for sunspec\n+ *\n+ * @author Nagy Attila Gabor - initial contribution\n+ *\n+ */\n+@Component(immediate = true)\n+@NonNullByDefault\n+public class SunspecDiscoveryParticipant implements ModbusDiscoveryParticipant {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SunspecDiscoveryParticipant.class);\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypeUIDs() {\n+        return new HashSet<ThingTypeUID>(SUPPORTED_THING_TYPES_UIDS.values());", "originalCommit": "1cb2d390458d9ad3b81aed783520aa199f1cb7ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDg1NDQwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r410854409", "bodyText": "I'm afraid I don't understand you request. The SUPPORTED_THING_TYPES_UIDS is a static map in the SunSpecConstants class. All I do here is that I return the values as a set as requested by the interface.\nCreating a second static set to support this method would be a duplication of the configuration.\nCan you please give me a hint what you would like better?", "author": "mrbig", "createdAt": "2020-04-19T08:49:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc3ODA4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA5NTc3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r411095772", "bodyText": "Actually, I think you are correct here. I'm not entirely sure what I saw here when I recommended the change. I need to stop doing code reviews when I'm tired.", "author": "cpmeister", "createdAt": "2020-04-20T05:06:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc3ODA4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc3ODI0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r410778242", "bodyText": "any reason these Integer fields couldn't be int instead?", "author": "cpmeister", "createdAt": "2020-04-19T00:20:27Z", "path": "bundles/org.openhab.binding.modbus.sunspec/src/main/java/org/openhab/binding/modbus/sunspec/internal/dto/CommonModelBlock.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.sunspec.internal.dto;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * This class contains information parsed from the Common Model block\n+ *\n+ * @author Nagy Attila Gabor - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class CommonModelBlock {\n+\n+    /**\n+     * Value = 0x0001. Uniquely identifies this as a SunSpec Common Model Block\n+     */\n+    public Integer sunSpecDID = 0x0001;", "originalCommit": "1cb2d390458d9ad3b81aed783520aa199f1cb7ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDg1NDQyNA==", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r410854424", "bodyText": "changed them to primitives", "author": "mrbig", "createdAt": "2020-04-19T08:49:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc3ODI0Mg=="}], "type": "inlineReview"}, {"oid": "83f52ba6affa07ea2846e6619418d74c176d6ba6", "url": "https://github.com/openhab/openhab-addons/commit/83f52ba6affa07ea2846e6619418d74c176d6ba6", "message": "[sunspec] object changed to primitives\n\nSigned-off-by: Nagy Attila Gabor <mrbig@sneaker.hu>", "committedDate": "2020-04-19T07:14:40Z", "type": "commit"}, {"oid": "9f7721e9b26d8b2c834cb74ecbbc9a880d7ecdea", "url": "https://github.com/openhab/openhab-addons/commit/9f7721e9b26d8b2c834cb74ecbbc9a880d7ecdea", "message": "[sunspec] ModbusEndpoint changed to NonNull\n\nSigned-off-by: Nagy Attila Gabor <mrbig@sneaker.hu>", "committedDate": "2020-04-19T08:33:02Z", "type": "commit"}, {"oid": "fc81ca045f9bb7f80dff8801e58bd68dd0e8badc", "url": "https://github.com/openhab/openhab-addons/commit/fc81ca045f9bb7f80dff8801e58bd68dd0e8badc", "message": "[sunspec] Optionals changed to nullable\n\nSigned-off-by: Nagy Attila Gabor <mrbig@sneaker.hu>", "committedDate": "2020-04-19T08:41:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA5ODIxNA==", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r411098214", "bodyText": "From the way you are using this field, it should be a Queue instead.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private List<Integer> possibleAddresses;\n          \n          \n            \n                private Queue<Integer> possibleAddresses;", "author": "cpmeister", "createdAt": "2020-04-20T05:15:10Z", "path": "bundles/org.openhab.binding.modbus.sunspec/src/main/java/org/openhab/binding/modbus/sunspec/internal/discovery/SunspecDiscoveryProcess.java", "diffHunk": "@@ -0,0 +1,397 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.sunspec.internal.discovery;\n+\n+import static org.openhab.binding.modbus.sunspec.internal.SunSpecConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.modbus.discovery.ModbusDiscoveryListener;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.sunspec.internal.dto.CommonModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.dto.ModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.parser.CommonModelParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusBitUtilities;\n+import org.openhab.io.transport.modbus.ModbusConstants.ValueType;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusSlaveErrorResponseException;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used by the SunspecDiscoveryParticipant to detect\n+ * the model blocks defined by the given device.\n+ * It scans trough the defined model items and notifies the\n+ * discovery service about the discovered devices\n+ *\n+ * @author Nagy Attila Gabor - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SunspecDiscoveryProcess {\n+\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(SunspecDiscoveryProcess.class);\n+\n+    /**\n+     * The handler instance for this device\n+     */\n+    private final ModbusEndpointThingHandler handler;\n+\n+    /**\n+     * The endpoint where we can reach the device\n+     */\n+    private final ModbusSlaveEndpoint endpoint;\n+\n+    /**\n+     * Listener for the discovered devices. We get this\n+     * from the main discovery service, and it is used to\n+     * submit any discovered Sunspec devices\n+     */\n+    private final ModbusDiscoveryListener listener;\n+\n+    /**\n+     * The endpoint's slave id\n+     */\n+    private int slaveId;\n+\n+    /**\n+     * Number of maximum retries\n+     */\n+    private static final int maxTries = 3;\n+\n+    /**\n+     * List of start addresses to try\n+     */\n+    private List<Integer> possibleAddresses;", "originalCommit": "fc81ca045f9bb7f80dff8801e58bd68dd0e8badc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE0OTU4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r411149583", "bodyText": "You are right, this suits the scenario much better.", "author": "mrbig", "createdAt": "2020-04-20T07:19:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA5ODIxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA5ODMxNg==", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r411098316", "bodyText": "If you want a thread-safe queue you can use this:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    possibleAddresses = new CopyOnWriteArrayList<>();\n          \n          \n            \n                    possibleAddresses = new ConcurrentLinkedQueue<>();\n          \n      \n    \n    \n  \n\nBut I'm not entirely sure that you need a thread-safe queue implementation here anyway...", "author": "cpmeister", "createdAt": "2020-04-20T05:15:29Z", "path": "bundles/org.openhab.binding.modbus.sunspec/src/main/java/org/openhab/binding/modbus/sunspec/internal/discovery/SunspecDiscoveryProcess.java", "diffHunk": "@@ -0,0 +1,397 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.sunspec.internal.discovery;\n+\n+import static org.openhab.binding.modbus.sunspec.internal.SunSpecConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.modbus.discovery.ModbusDiscoveryListener;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.sunspec.internal.dto.CommonModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.dto.ModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.parser.CommonModelParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusBitUtilities;\n+import org.openhab.io.transport.modbus.ModbusConstants.ValueType;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusSlaveErrorResponseException;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used by the SunspecDiscoveryParticipant to detect\n+ * the model blocks defined by the given device.\n+ * It scans trough the defined model items and notifies the\n+ * discovery service about the discovered devices\n+ *\n+ * @author Nagy Attila Gabor - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SunspecDiscoveryProcess {\n+\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(SunspecDiscoveryProcess.class);\n+\n+    /**\n+     * The handler instance for this device\n+     */\n+    private final ModbusEndpointThingHandler handler;\n+\n+    /**\n+     * The endpoint where we can reach the device\n+     */\n+    private final ModbusSlaveEndpoint endpoint;\n+\n+    /**\n+     * Listener for the discovered devices. We get this\n+     * from the main discovery service, and it is used to\n+     * submit any discovered Sunspec devices\n+     */\n+    private final ModbusDiscoveryListener listener;\n+\n+    /**\n+     * The endpoint's slave id\n+     */\n+    private int slaveId;\n+\n+    /**\n+     * Number of maximum retries\n+     */\n+    private static final int maxTries = 3;\n+\n+    /**\n+     * List of start addresses to try\n+     */\n+    private List<Integer> possibleAddresses;\n+\n+    /**\n+     * This is the base address where the next block should be searched for\n+     */\n+    private int baseAddress = 40000;\n+\n+    /**\n+     * Count of valid Sunspec blocks found\n+     */\n+    private int blocksFound = 0;\n+\n+    /**\n+     * Parser for commonblock\n+     */\n+    private final CommonModelParser commonBlockParser;\n+\n+    /**\n+     * The last common block found. This is used\n+     * to get the details of any found devices\n+     */\n+    private @Nullable CommonModelBlock lastCommonBlock = null;\n+\n+    /**\n+     * New instances of this class should get a reference to the handler\n+     *\n+     * @throws EndpointNotInitializedException\n+     */\n+    public SunspecDiscoveryProcess(ModbusEndpointThingHandler handler, ModbusDiscoveryListener listener)\n+            throws EndpointNotInitializedException {\n+        this.handler = handler;\n+\n+        ModbusSlaveEndpoint endpoint = this.handler.asSlaveEndpoint();\n+        if (endpoint != null) {\n+            this.endpoint = endpoint;\n+        } else {\n+            throw new EndpointNotInitializedException();\n+        }\n+        slaveId = handler.getSlaveId();\n+        this.listener = listener;\n+        commonBlockParser = new CommonModelParser();\n+        possibleAddresses = new CopyOnWriteArrayList<>();", "originalCommit": "fc81ca045f9bb7f80dff8801e58bd68dd0e8badc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE0OTY0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r411149645", "bodyText": "Thanks I changed this.\nThe main idea here is to create a new instance of SunspecDiscoveryProcess for each discovery request, so it can keep track of the discovery messages. So concurrent access is highly unlikely but it's better to be safe than sorry.", "author": "mrbig", "createdAt": "2020-04-20T07:19:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA5ODMxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA5ODM5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r411098399", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (possibleAddresses.size() < 1) {\n          \n          \n            \n                    if (possibleAddresses.isEmpty()) {", "author": "cpmeister", "createdAt": "2020-04-20T05:15:42Z", "path": "bundles/org.openhab.binding.modbus.sunspec/src/main/java/org/openhab/binding/modbus/sunspec/internal/discovery/SunspecDiscoveryProcess.java", "diffHunk": "@@ -0,0 +1,397 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.sunspec.internal.discovery;\n+\n+import static org.openhab.binding.modbus.sunspec.internal.SunSpecConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.modbus.discovery.ModbusDiscoveryListener;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.sunspec.internal.dto.CommonModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.dto.ModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.parser.CommonModelParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusBitUtilities;\n+import org.openhab.io.transport.modbus.ModbusConstants.ValueType;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusSlaveErrorResponseException;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used by the SunspecDiscoveryParticipant to detect\n+ * the model blocks defined by the given device.\n+ * It scans trough the defined model items and notifies the\n+ * discovery service about the discovered devices\n+ *\n+ * @author Nagy Attila Gabor - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SunspecDiscoveryProcess {\n+\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(SunspecDiscoveryProcess.class);\n+\n+    /**\n+     * The handler instance for this device\n+     */\n+    private final ModbusEndpointThingHandler handler;\n+\n+    /**\n+     * The endpoint where we can reach the device\n+     */\n+    private final ModbusSlaveEndpoint endpoint;\n+\n+    /**\n+     * Listener for the discovered devices. We get this\n+     * from the main discovery service, and it is used to\n+     * submit any discovered Sunspec devices\n+     */\n+    private final ModbusDiscoveryListener listener;\n+\n+    /**\n+     * The endpoint's slave id\n+     */\n+    private int slaveId;\n+\n+    /**\n+     * Number of maximum retries\n+     */\n+    private static final int maxTries = 3;\n+\n+    /**\n+     * List of start addresses to try\n+     */\n+    private List<Integer> possibleAddresses;\n+\n+    /**\n+     * This is the base address where the next block should be searched for\n+     */\n+    private int baseAddress = 40000;\n+\n+    /**\n+     * Count of valid Sunspec blocks found\n+     */\n+    private int blocksFound = 0;\n+\n+    /**\n+     * Parser for commonblock\n+     */\n+    private final CommonModelParser commonBlockParser;\n+\n+    /**\n+     * The last common block found. This is used\n+     * to get the details of any found devices\n+     */\n+    private @Nullable CommonModelBlock lastCommonBlock = null;\n+\n+    /**\n+     * New instances of this class should get a reference to the handler\n+     *\n+     * @throws EndpointNotInitializedException\n+     */\n+    public SunspecDiscoveryProcess(ModbusEndpointThingHandler handler, ModbusDiscoveryListener listener)\n+            throws EndpointNotInitializedException {\n+        this.handler = handler;\n+\n+        ModbusSlaveEndpoint endpoint = this.handler.asSlaveEndpoint();\n+        if (endpoint != null) {\n+            this.endpoint = endpoint;\n+        } else {\n+            throw new EndpointNotInitializedException();\n+        }\n+        slaveId = handler.getSlaveId();\n+        this.listener = listener;\n+        commonBlockParser = new CommonModelParser();\n+        possibleAddresses = new CopyOnWriteArrayList<>();\n+        // Preferred and alternate base registers\n+        // @see SunSpec Information Model Overview\n+        possibleAddresses.add(40000);\n+        possibleAddresses.add(50000);\n+        possibleAddresses.add(0);\n+    }\n+\n+    /**\n+     * Start model detection\n+     *\n+     * @param uid the thing type to look for\n+     * @throws EndpointNotInitializedException\n+     */\n+    public void detectModel() {\n+\n+        if (possibleAddresses.size() < 1) {", "originalCommit": "fc81ca045f9bb7f80dff8801e58bd68dd0e8badc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE0OTk4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r411149987", "bodyText": "thanks, accepted.", "author": "mrbig", "createdAt": "2020-04-20T07:20:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA5ODM5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA5ODcyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r411098721", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    baseAddress = possibleAddresses.get(0);\n          \n          \n            \n                    baseAddress = possibleAddresses.poll();", "author": "cpmeister", "createdAt": "2020-04-20T05:16:49Z", "path": "bundles/org.openhab.binding.modbus.sunspec/src/main/java/org/openhab/binding/modbus/sunspec/internal/discovery/SunspecDiscoveryProcess.java", "diffHunk": "@@ -0,0 +1,397 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.sunspec.internal.discovery;\n+\n+import static org.openhab.binding.modbus.sunspec.internal.SunSpecConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.modbus.discovery.ModbusDiscoveryListener;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.sunspec.internal.dto.CommonModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.dto.ModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.parser.CommonModelParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusBitUtilities;\n+import org.openhab.io.transport.modbus.ModbusConstants.ValueType;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusSlaveErrorResponseException;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used by the SunspecDiscoveryParticipant to detect\n+ * the model blocks defined by the given device.\n+ * It scans trough the defined model items and notifies the\n+ * discovery service about the discovered devices\n+ *\n+ * @author Nagy Attila Gabor - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SunspecDiscoveryProcess {\n+\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(SunspecDiscoveryProcess.class);\n+\n+    /**\n+     * The handler instance for this device\n+     */\n+    private final ModbusEndpointThingHandler handler;\n+\n+    /**\n+     * The endpoint where we can reach the device\n+     */\n+    private final ModbusSlaveEndpoint endpoint;\n+\n+    /**\n+     * Listener for the discovered devices. We get this\n+     * from the main discovery service, and it is used to\n+     * submit any discovered Sunspec devices\n+     */\n+    private final ModbusDiscoveryListener listener;\n+\n+    /**\n+     * The endpoint's slave id\n+     */\n+    private int slaveId;\n+\n+    /**\n+     * Number of maximum retries\n+     */\n+    private static final int maxTries = 3;\n+\n+    /**\n+     * List of start addresses to try\n+     */\n+    private List<Integer> possibleAddresses;\n+\n+    /**\n+     * This is the base address where the next block should be searched for\n+     */\n+    private int baseAddress = 40000;\n+\n+    /**\n+     * Count of valid Sunspec blocks found\n+     */\n+    private int blocksFound = 0;\n+\n+    /**\n+     * Parser for commonblock\n+     */\n+    private final CommonModelParser commonBlockParser;\n+\n+    /**\n+     * The last common block found. This is used\n+     * to get the details of any found devices\n+     */\n+    private @Nullable CommonModelBlock lastCommonBlock = null;\n+\n+    /**\n+     * New instances of this class should get a reference to the handler\n+     *\n+     * @throws EndpointNotInitializedException\n+     */\n+    public SunspecDiscoveryProcess(ModbusEndpointThingHandler handler, ModbusDiscoveryListener listener)\n+            throws EndpointNotInitializedException {\n+        this.handler = handler;\n+\n+        ModbusSlaveEndpoint endpoint = this.handler.asSlaveEndpoint();\n+        if (endpoint != null) {\n+            this.endpoint = endpoint;\n+        } else {\n+            throw new EndpointNotInitializedException();\n+        }\n+        slaveId = handler.getSlaveId();\n+        this.listener = listener;\n+        commonBlockParser = new CommonModelParser();\n+        possibleAddresses = new CopyOnWriteArrayList<>();\n+        // Preferred and alternate base registers\n+        // @see SunSpec Information Model Overview\n+        possibleAddresses.add(40000);\n+        possibleAddresses.add(50000);\n+        possibleAddresses.add(0);\n+    }\n+\n+    /**\n+     * Start model detection\n+     *\n+     * @param uid the thing type to look for\n+     * @throws EndpointNotInitializedException\n+     */\n+    public void detectModel() {\n+\n+        if (possibleAddresses.size() < 1) {\n+            parsingFinished();\n+            return;\n+        }\n+        // Try the next address from the possibles\n+        baseAddress = possibleAddresses.get(0);", "originalCommit": "fc81ca045f9bb7f80dff8801e58bd68dd0e8badc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE0OTY5NA==", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r411149694", "bodyText": "thanks, accepted.", "author": "mrbig", "createdAt": "2020-04-20T07:19:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA5ODcyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTEwMzA4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r411103085", "bodyText": "Why are you parsing as a double then casting it to an int? Are you expecting the properties to have decimal points?\nCould you just parse it as an int instead?", "author": "cpmeister", "createdAt": "2020-04-20T05:30:38Z", "path": "bundles/org.openhab.binding.modbus.sunspec/src/main/java/org/openhab/binding/modbus/sunspec/internal/handler/AbstractSunSpecHandler.java", "diffHunk": "@@ -152,31 +152,58 @@ private void startUp() {\n             return;\n         }\n \n-        Optional<ModelBlock> mainBlock = getAddressFromConfig();\n-        if (mainBlock.isPresent()) {\n-            publishUniqueAddress(mainBlock.get());\n+        // Try properties first\n+        @Nullable\n+        ModelBlock mainBlock = getAddressFromProperties();\n+\n+        if (mainBlock == null) {\n+            mainBlock = getAddressFromConfig();\n+        }\n+\n+        if (mainBlock != null) {\n+            publishUniqueAddress(mainBlock);\n             updateStatus(ThingStatus.UNKNOWN);\n-            registerPollTask(mainBlock.get());\n+            registerPollTask(mainBlock);\n         } else {\n             updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n                     \"SunSpec item should either have the address and length configuration set or should been created by auto discovery\");\n             return;\n         }\n     }\n \n+    /**\n+     * Load and parse configuration from the properties\n+     * These will be set by the auto discovery process\n+     */\n+    private @Nullable ModelBlock getAddressFromProperties() {\n+        Map<String, String> properties = thing.getProperties();\n+        if (!properties.containsKey(PROPERTY_BLOCK_ADDRESS) || !properties.containsKey(PROPERTY_BLOCK_LENGTH)) {\n+            return null;\n+        }\n+        try {\n+            ModelBlock block = new ModelBlock();\n+            block.address = (int) Double.parseDouble(thing.getProperties().get(PROPERTY_BLOCK_ADDRESS));\n+            block.length = (int) Double.parseDouble(thing.getProperties().get(PROPERTY_BLOCK_LENGTH));", "originalCommit": "fc81ca045f9bb7f80dff8801e58bd68dd0e8badc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE0OTc1NA==", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r411149754", "bodyText": "Yes of course. I don't know anymore what I was doing here. Possibly a cope&paste mistake.", "author": "mrbig", "createdAt": "2020-04-20T07:19:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTEwMzA4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA2ODYyNg==", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r414068626", "bodyText": "Now I remember what's been the problem here: some older versions of OH return the property value with decimal points even though I set them as integers.\nOn the current state of 2.5.x branch this didn't happen, but others testing this bundle reported the problem.\nI'm not familiar with the internals of OH, and how the properties are stored, or if there has been a change on this recently. @cpmeister do you have any information regarding this?", "author": "mrbig", "createdAt": "2020-04-23T19:33:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTEwMzA4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTEwNTYzNA==", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r411105634", "bodyText": "If you poll within detectModel() you can remove this", "author": "cpmeister", "createdAt": "2020-04-20T05:38:49Z", "path": "bundles/org.openhab.binding.modbus.sunspec/src/main/java/org/openhab/binding/modbus/sunspec/internal/discovery/SunspecDiscoveryProcess.java", "diffHunk": "@@ -0,0 +1,397 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.sunspec.internal.discovery;\n+\n+import static org.openhab.binding.modbus.sunspec.internal.SunSpecConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.modbus.discovery.ModbusDiscoveryListener;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.sunspec.internal.dto.CommonModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.dto.ModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.parser.CommonModelParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusBitUtilities;\n+import org.openhab.io.transport.modbus.ModbusConstants.ValueType;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusSlaveErrorResponseException;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used by the SunspecDiscoveryParticipant to detect\n+ * the model blocks defined by the given device.\n+ * It scans trough the defined model items and notifies the\n+ * discovery service about the discovered devices\n+ *\n+ * @author Nagy Attila Gabor - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SunspecDiscoveryProcess {\n+\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(SunspecDiscoveryProcess.class);\n+\n+    /**\n+     * The handler instance for this device\n+     */\n+    private final ModbusEndpointThingHandler handler;\n+\n+    /**\n+     * The endpoint where we can reach the device\n+     */\n+    private final ModbusSlaveEndpoint endpoint;\n+\n+    /**\n+     * Listener for the discovered devices. We get this\n+     * from the main discovery service, and it is used to\n+     * submit any discovered Sunspec devices\n+     */\n+    private final ModbusDiscoveryListener listener;\n+\n+    /**\n+     * The endpoint's slave id\n+     */\n+    private int slaveId;\n+\n+    /**\n+     * Number of maximum retries\n+     */\n+    private static final int maxTries = 3;\n+\n+    /**\n+     * List of start addresses to try\n+     */\n+    private List<Integer> possibleAddresses;\n+\n+    /**\n+     * This is the base address where the next block should be searched for\n+     */\n+    private int baseAddress = 40000;\n+\n+    /**\n+     * Count of valid Sunspec blocks found\n+     */\n+    private int blocksFound = 0;\n+\n+    /**\n+     * Parser for commonblock\n+     */\n+    private final CommonModelParser commonBlockParser;\n+\n+    /**\n+     * The last common block found. This is used\n+     * to get the details of any found devices\n+     */\n+    private @Nullable CommonModelBlock lastCommonBlock = null;\n+\n+    /**\n+     * New instances of this class should get a reference to the handler\n+     *\n+     * @throws EndpointNotInitializedException\n+     */\n+    public SunspecDiscoveryProcess(ModbusEndpointThingHandler handler, ModbusDiscoveryListener listener)\n+            throws EndpointNotInitializedException {\n+        this.handler = handler;\n+\n+        ModbusSlaveEndpoint endpoint = this.handler.asSlaveEndpoint();\n+        if (endpoint != null) {\n+            this.endpoint = endpoint;\n+        } else {\n+            throw new EndpointNotInitializedException();\n+        }\n+        slaveId = handler.getSlaveId();\n+        this.listener = listener;\n+        commonBlockParser = new CommonModelParser();\n+        possibleAddresses = new CopyOnWriteArrayList<>();\n+        // Preferred and alternate base registers\n+        // @see SunSpec Information Model Overview\n+        possibleAddresses.add(40000);\n+        possibleAddresses.add(50000);\n+        possibleAddresses.add(0);\n+    }\n+\n+    /**\n+     * Start model detection\n+     *\n+     * @param uid the thing type to look for\n+     * @throws EndpointNotInitializedException\n+     */\n+    public void detectModel() {\n+\n+        if (possibleAddresses.size() < 1) {\n+            parsingFinished();\n+            return;\n+        }\n+        // Try the next address from the possibles\n+        baseAddress = possibleAddresses.get(0);\n+        logger.trace(\"Beginning scan for SunSpec device at address {}\", baseAddress);\n+\n+        BasicModbusReadRequestBlueprint request = new BasicModbusReadRequestBlueprint(slaveId,\n+                ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS, baseAddress, // Start address\n+                SUNSPEC_ID_SIZE, // number or words to return\n+                maxTries);\n+\n+        PollTask task = new BasicPollTaskImpl(endpoint, request, new ModbusReadCallback() {\n+\n+            @Override\n+            public void onRegisters(ModbusReadRequestBlueprint request, ModbusRegisterArray registers) {\n+                headerReceived(registers);\n+            }\n+\n+            @Override\n+            public void onError(ModbusReadRequestBlueprint request, Exception error) {\n+                handleError(error);\n+            }\n+\n+            @Override\n+            public void onBits(@Nullable ModbusReadRequestBlueprint request, @Nullable BitArray bits) {\n+                // don't care, we don't expect this result\n+            }\n+        });\n+\n+        handler.getManagerRef().get().submitOneTimePoll(task);\n+    }\n+\n+    /**\n+     * We received the first two words, that should equal to SunS\n+     */\n+    private void headerReceived(ModbusRegisterArray registers) {\n+        logger.trace(\"Received response from device {}\", registers.toString());\n+\n+        Optional<DecimalType> id = ModbusBitUtilities.extractStateFromRegisters(registers, 0, ValueType.UINT32);\n+\n+        if (!id.isPresent() || id.get().longValue() != SUNSPEC_ID) {\n+            logger.debug(\"Could not find SunSpec DID at address {}, received: {}, expected: {}\", baseAddress, id,\n+                    SUNSPEC_ID);\n+            possibleAddresses.remove(0);", "originalCommit": "fc81ca045f9bb7f80dff8801e58bd68dd0e8badc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE0OTg4NA==", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r411149884", "bodyText": "thanks, removed.", "author": "mrbig", "createdAt": "2020-04-20T07:20:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTEwNTYzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTEwNTcxNg==", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r411105716", "bodyText": "If you poll within detectModel() you can remove this", "author": "cpmeister", "createdAt": "2020-04-20T05:39:06Z", "path": "bundles/org.openhab.binding.modbus.sunspec/src/main/java/org/openhab/binding/modbus/sunspec/internal/discovery/SunspecDiscoveryProcess.java", "diffHunk": "@@ -0,0 +1,397 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.sunspec.internal.discovery;\n+\n+import static org.openhab.binding.modbus.sunspec.internal.SunSpecConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.modbus.discovery.ModbusDiscoveryListener;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.sunspec.internal.dto.CommonModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.dto.ModelBlock;\n+import org.openhab.binding.modbus.sunspec.internal.parser.CommonModelParser;\n+import org.openhab.io.transport.modbus.BasicModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.BasicPollTaskImpl;\n+import org.openhab.io.transport.modbus.BitArray;\n+import org.openhab.io.transport.modbus.ModbusBitUtilities;\n+import org.openhab.io.transport.modbus.ModbusConstants.ValueType;\n+import org.openhab.io.transport.modbus.ModbusReadCallback;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.ModbusSlaveErrorResponseException;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.openhab.io.transport.modbus.endpoint.ModbusSlaveEndpoint;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used by the SunspecDiscoveryParticipant to detect\n+ * the model blocks defined by the given device.\n+ * It scans trough the defined model items and notifies the\n+ * discovery service about the discovered devices\n+ *\n+ * @author Nagy Attila Gabor - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SunspecDiscoveryProcess {\n+\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(SunspecDiscoveryProcess.class);\n+\n+    /**\n+     * The handler instance for this device\n+     */\n+    private final ModbusEndpointThingHandler handler;\n+\n+    /**\n+     * The endpoint where we can reach the device\n+     */\n+    private final ModbusSlaveEndpoint endpoint;\n+\n+    /**\n+     * Listener for the discovered devices. We get this\n+     * from the main discovery service, and it is used to\n+     * submit any discovered Sunspec devices\n+     */\n+    private final ModbusDiscoveryListener listener;\n+\n+    /**\n+     * The endpoint's slave id\n+     */\n+    private int slaveId;\n+\n+    /**\n+     * Number of maximum retries\n+     */\n+    private static final int maxTries = 3;\n+\n+    /**\n+     * List of start addresses to try\n+     */\n+    private List<Integer> possibleAddresses;\n+\n+    /**\n+     * This is the base address where the next block should be searched for\n+     */\n+    private int baseAddress = 40000;\n+\n+    /**\n+     * Count of valid Sunspec blocks found\n+     */\n+    private int blocksFound = 0;\n+\n+    /**\n+     * Parser for commonblock\n+     */\n+    private final CommonModelParser commonBlockParser;\n+\n+    /**\n+     * The last common block found. This is used\n+     * to get the details of any found devices\n+     */\n+    private @Nullable CommonModelBlock lastCommonBlock = null;\n+\n+    /**\n+     * New instances of this class should get a reference to the handler\n+     *\n+     * @throws EndpointNotInitializedException\n+     */\n+    public SunspecDiscoveryProcess(ModbusEndpointThingHandler handler, ModbusDiscoveryListener listener)\n+            throws EndpointNotInitializedException {\n+        this.handler = handler;\n+\n+        ModbusSlaveEndpoint endpoint = this.handler.asSlaveEndpoint();\n+        if (endpoint != null) {\n+            this.endpoint = endpoint;\n+        } else {\n+            throw new EndpointNotInitializedException();\n+        }\n+        slaveId = handler.getSlaveId();\n+        this.listener = listener;\n+        commonBlockParser = new CommonModelParser();\n+        possibleAddresses = new CopyOnWriteArrayList<>();\n+        // Preferred and alternate base registers\n+        // @see SunSpec Information Model Overview\n+        possibleAddresses.add(40000);\n+        possibleAddresses.add(50000);\n+        possibleAddresses.add(0);\n+    }\n+\n+    /**\n+     * Start model detection\n+     *\n+     * @param uid the thing type to look for\n+     * @throws EndpointNotInitializedException\n+     */\n+    public void detectModel() {\n+\n+        if (possibleAddresses.size() < 1) {\n+            parsingFinished();\n+            return;\n+        }\n+        // Try the next address from the possibles\n+        baseAddress = possibleAddresses.get(0);\n+        logger.trace(\"Beginning scan for SunSpec device at address {}\", baseAddress);\n+\n+        BasicModbusReadRequestBlueprint request = new BasicModbusReadRequestBlueprint(slaveId,\n+                ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS, baseAddress, // Start address\n+                SUNSPEC_ID_SIZE, // number or words to return\n+                maxTries);\n+\n+        PollTask task = new BasicPollTaskImpl(endpoint, request, new ModbusReadCallback() {\n+\n+            @Override\n+            public void onRegisters(ModbusReadRequestBlueprint request, ModbusRegisterArray registers) {\n+                headerReceived(registers);\n+            }\n+\n+            @Override\n+            public void onError(ModbusReadRequestBlueprint request, Exception error) {\n+                handleError(error);\n+            }\n+\n+            @Override\n+            public void onBits(@Nullable ModbusReadRequestBlueprint request, @Nullable BitArray bits) {\n+                // don't care, we don't expect this result\n+            }\n+        });\n+\n+        handler.getManagerRef().get().submitOneTimePoll(task);\n+    }\n+\n+    /**\n+     * We received the first two words, that should equal to SunS\n+     */\n+    private void headerReceived(ModbusRegisterArray registers) {\n+        logger.trace(\"Received response from device {}\", registers.toString());\n+\n+        Optional<DecimalType> id = ModbusBitUtilities.extractStateFromRegisters(registers, 0, ValueType.UINT32);\n+\n+        if (!id.isPresent() || id.get().longValue() != SUNSPEC_ID) {\n+            logger.debug(\"Could not find SunSpec DID at address {}, received: {}, expected: {}\", baseAddress, id,\n+                    SUNSPEC_ID);\n+            possibleAddresses.remove(0);\n+            detectModel();\n+            return;\n+        }\n+\n+        logger.trace(\"Header looks correct\");\n+        baseAddress += SUNSPEC_ID_SIZE;\n+\n+        lookForModelBlock();\n+    }\n+\n+    /**\n+     * Look for a valid model block at the current base address\n+     */\n+    private void lookForModelBlock() {\n+\n+        BasicModbusReadRequestBlueprint request = new BasicModbusReadRequestBlueprint(slaveId,\n+                ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS, baseAddress, // Start address\n+                MODEL_HEADER_SIZE, // number or words to return\n+                maxTries);\n+\n+        PollTask task = new BasicPollTaskImpl(endpoint, request, new ModbusReadCallback() {\n+\n+            @Override\n+            public void onRegisters(ModbusReadRequestBlueprint request, ModbusRegisterArray registers) {\n+                modelBlockReceived(registers);\n+            }\n+\n+            @Override\n+            public void onError(ModbusReadRequestBlueprint request, Exception error) {\n+                handleError(error);\n+            }\n+\n+            @Override\n+            public void onBits(@Nullable ModbusReadRequestBlueprint request, @Nullable BitArray bits) {\n+                // don't care, we don't expect this result\n+            }\n+        });\n+\n+        handler.getManagerRef().get().submitOneTimePoll(task);\n+    }\n+\n+    /**\n+     * We received a model block header\n+     */\n+    private void modelBlockReceived(ModbusRegisterArray registers) {\n+        logger.debug(\"Received response from device {}\", registers.toString());\n+\n+        Optional<DecimalType> moduleID = ModbusBitUtilities.extractStateFromRegisters(registers, 0, ValueType.UINT16);\n+        Optional<DecimalType> blockLength = ModbusBitUtilities.extractStateFromRegisters(registers, 1,\n+                ValueType.UINT16);\n+\n+        if (!moduleID.isPresent() || !blockLength.isPresent()) {\n+            logger.info(\"Could not find valid module id or block length field.\");\n+            parsingFinished();\n+            return;\n+        }\n+        ModelBlock block = new ModelBlock();\n+        block.address = baseAddress;\n+        block.moduleID = moduleID.get().intValue();\n+        block.length = blockLength.get().intValue() + MODEL_HEADER_SIZE;\n+        logger.debug(\"SunSpec detector found block {}\", block);\n+\n+        blocksFound++;\n+\n+        if (block.moduleID == FINAL_BLOCK) {\n+            parsingFinished();\n+        } else {\n+            baseAddress += block.length;\n+            if (block.moduleID == COMMON_BLOCK) {\n+                readCommonBlock(block); // This is an asynchronous task\n+                return;\n+            } else {\n+                createDiscoveryResult(block);\n+                lookForModelBlock();\n+            }\n+\n+        }\n+    }\n+\n+    /**\n+     * Start reading common block\n+     *\n+     * @param block\n+     */\n+    private void readCommonBlock(ModelBlock block) {\n+        BasicModbusReadRequestBlueprint request = new BasicModbusReadRequestBlueprint(slaveId,\n+                ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS, block.address, // Start address\n+                block.length, // number or words to return\n+                maxTries);\n+\n+        PollTask task = new BasicPollTaskImpl(endpoint, request, new ModbusReadCallback() {\n+\n+            @Override\n+            public void onRegisters(ModbusReadRequestBlueprint request, ModbusRegisterArray registers) {\n+                parseCommonBlock(registers);\n+            }\n+\n+            @Override\n+            public void onError(ModbusReadRequestBlueprint request, Exception error) {\n+                handleError(error);\n+            }\n+\n+            @Override\n+            public void onBits(@Nullable ModbusReadRequestBlueprint request, @Nullable BitArray bits) {\n+                // don't care, we don't expect this result\n+            }\n+        });\n+\n+        handler.getManagerRef().get().submitOneTimePoll(task);\n+    }\n+\n+    /**\n+     * We've read the details of a common block now parse it, and\n+     * store for later use\n+     *\n+     * @param registers\n+     */\n+    private void parseCommonBlock(ModbusRegisterArray registers) {\n+        logger.trace(\"Got common block data: {}\", registers);\n+        lastCommonBlock = commonBlockParser.parse(registers);\n+        lookForModelBlock(); // Continue parsing\n+    }\n+\n+    /**\n+     * Create a discovery result from a model block\n+     *\n+     * @param block the block we've found\n+     */\n+    private void createDiscoveryResult(ModelBlock block) {\n+        if (!SUPPORTED_THING_TYPES_UIDS.containsKey(block.moduleID)) {\n+            logger.debug(\"ModuleID {} is not supported, skipping this block\", block.moduleID);\n+            return;\n+        }\n+\n+        CommonModelBlock commonBlock = lastCommonBlock;\n+\n+        if (commonBlock == null) {\n+            logger.warn(\n+                    \"Found model block without a preceding common block. Can't add device because details are unkown\");\n+            return;\n+        }\n+\n+        ThingUID thingUID = new ThingUID(SUPPORTED_THING_TYPES_UIDS.get(block.moduleID), handler.getUID(),\n+                Integer.toString(block.address));\n+\n+        Map<String, Object> properties = new HashMap<>();\n+        properties.put(PROPERTY_VENDOR, commonBlock.manufacturer);\n+        properties.put(PROPERTY_MODEL, commonBlock.model);\n+        properties.put(PROPERTY_SERIAL_NUMBER, commonBlock.serialNumber);\n+        properties.put(PROPERTY_VERSION, commonBlock.version);\n+        properties.put(PROPERTY_BLOCK_ADDRESS, block.address);\n+        properties.put(PROPERTY_BLOCK_LENGTH, block.length);\n+        properties.put(PROPERTY_UNIQUE_ADDRESS, handler.getUID().getAsString() + \":\" + block.address);\n+\n+        DiscoveryResult result = DiscoveryResultBuilder.create(thingUID).withProperties(properties)\n+                .withRepresentationProperty(PROPERTY_UNIQUE_ADDRESS).withBridge(handler.getUID())\n+                .withLabel(commonBlock.manufacturer + \" \" + commonBlock.model).build();\n+\n+        listener.thingDiscovered(result);\n+    }\n+\n+    /**\n+     * Parsing of model blocks finished\n+     * Now we have to report back to the handler the common block and the block we were looking for\n+     */\n+    private void parsingFinished() {\n+        listener.discoveryFinished();\n+    }\n+\n+    /**\n+     * Handle errors received during communication\n+     */\n+    private void handleError(Exception error) {\n+        String msg = \"\";\n+        String cls = \"\";\n+\n+        if (blocksFound > 1 && error instanceof ModbusSlaveErrorResponseException) {\n+            int code = ((ModbusSlaveErrorResponseException) error).getExceptionCode();\n+            if (code == ModbusSlaveErrorResponseException.ILLEGAL_DATA_ACCESS\n+                    || code == ModbusSlaveErrorResponseException.ILLEGAL_DATA_VALUE) {\n+                // It is very likely that the slave does not report an end block (0xffff) after the main blocks\n+                // so we treat this situation as normal.\n+                logger.debug(\n+                        \"Seems like slave device does not report an end block. Continouing with the dectected blocks\");\n+                parsingFinished();\n+                return;\n+            }\n+        }\n+\n+        cls = error.getClass().getName();\n+        msg = error.getMessage();\n+\n+        logger.warn(\"Error with read at address {}: {} {}\", baseAddress, cls, msg);\n+\n+        possibleAddresses.remove(0); // Drop the current base address, and continue with the next one", "originalCommit": "fc81ca045f9bb7f80dff8801e58bd68dd0e8badc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE0OTkyNw==", "url": "https://github.com/openhab/openhab-addons/pull/6994#discussion_r411149927", "bodyText": "thanks, removed.", "author": "mrbig", "createdAt": "2020-04-20T07:20:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTEwNTcxNg=="}], "type": "inlineReview"}, {"oid": "f8e83ce9e09bdda8f811abed0eef808be8b1fd22", "url": "https://github.com/openhab/openhab-addons/commit/f8e83ce9e09bdda8f811abed0eef808be8b1fd22", "message": "[sunspec] discovery process thread safe refactoring\n\n\nSigned-off-by: Nagy Attila Gabor <mrbig@sneaker.hu>", "committedDate": "2020-04-20T07:19:19Z", "type": "commit"}]}