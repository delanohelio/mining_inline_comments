{"pr_number": 7434, "pr_title": "[bluetooth.daikinmadoka] Daikinmadoka binding initial contribution", "pr_createdAt": "2020-04-20T21:25:45Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/7434", "timeline": [{"oid": "1b510f0d5787d397cd438e8e7c65081f008d4e70", "url": "https://github.com/openhab/openhab-addons/commit/1b510f0d5787d397cd438e8e7c65081f008d4e70", "message": "Add Daikin Madoka BLE binding\n\nSigned-off-by: Benjamin Lafois <benjamin@lafois.com>", "committedDate": "2020-04-13T10:11:59Z", "type": "commit"}, {"oid": "e967483c94412b42db40b5fc032c9e0dde508e5d", "url": "https://github.com/openhab/openhab-addons/commit/e967483c94412b42db40b5fc032c9e0dde508e5d", "message": "updated doc\n\nSigned-off-by: Benjamin Lafois <benjamin@lafois.com>", "committedDate": "2020-04-13T12:34:32Z", "type": "commit"}, {"oid": "06386ead59999fa0e2d23c6b3fe45c00be79a3c1", "url": "https://github.com/openhab/openhab-addons/commit/06386ead59999fa0e2d23c6b3fe45c00be79a3c1", "message": "fixed PR comments\n\nSigned-off-by: Benjamin Lafois <benjamin@lafois.com>", "committedDate": "2020-04-19T15:00:58Z", "type": "commit"}, {"oid": "4efef432272ce52b549067c3aef0fa30b5b26213", "url": "https://github.com/openhab/openhab-addons/commit/4efef432272ce52b549067c3aef0fa30b5b26213", "message": "Fixed everything according to PR comments\n\nSigned-off-by: Benjamin Lafois <benjamin@lafois.com>", "committedDate": "2020-04-19T15:05:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcwOTQyMA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411709420", "bodyText": "Please remove this unneeded wrapping statement block.", "author": "cpmeister", "createdAt": "2020-04-20T21:37:27Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class BRC1HUartProcessor {\n+\n+    /**\n+     * In the unlikely event of messages arrive in wrong order, this comparator will sort the queue\n+     */\n+    private Comparator<byte[]> chunkSorter = (byte[] m1, byte[] m2) -> m1[0] - m2[0];\n+\n+    private final Logger logger = LoggerFactory.getLogger(BRC1HUartProcessor.class);\n+\n+    private ConcurrentSkipListSet<byte[]> uartMessages = new ConcurrentSkipListSet<>(chunkSorter);\n+\n+    private ResponseListener responseListener;\n+\n+    public BRC1HUartProcessor(ResponseListener responseListener) {\n+        this.responseListener = responseListener;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    private boolean isMessageComplete() {\n+\n+        int messagesInQueue = this.uartMessages.size();\n+\n+        if (messagesInQueue <= 0) {\n+            return false;\n+        }\n+\n+        byte[] firstMessageInQueue = uartMessages.first();\n+        if (firstMessageInQueue[0] != 0) {\n+            return false;\n+        }\n+\n+        if (firstMessageInQueue.length < 2) {\n+            return false;\n+        }\n+\n+        int expectedChunks = (firstMessageInQueue[1] / 19) + (firstMessageInQueue[1] % 19 > 0 ? 1 : 0);\n+        if (expectedChunks != this.uartMessages.size()) {\n+            return false;\n+        }\n+        {", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcwOTgyNg==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411709826", "bodyText": "Please change this to an appropriate log level.", "author": "cpmeister", "createdAt": "2020-04-20T21:38:09Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class BRC1HUartProcessor {\n+\n+    /**\n+     * In the unlikely event of messages arrive in wrong order, this comparator will sort the queue\n+     */\n+    private Comparator<byte[]> chunkSorter = (byte[] m1, byte[] m2) -> m1[0] - m2[0];\n+\n+    private final Logger logger = LoggerFactory.getLogger(BRC1HUartProcessor.class);\n+\n+    private ConcurrentSkipListSet<byte[]> uartMessages = new ConcurrentSkipListSet<>(chunkSorter);\n+\n+    private ResponseListener responseListener;\n+\n+    public BRC1HUartProcessor(ResponseListener responseListener) {\n+        this.responseListener = responseListener;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    private boolean isMessageComplete() {\n+\n+        int messagesInQueue = this.uartMessages.size();\n+\n+        if (messagesInQueue <= 0) {\n+            return false;\n+        }\n+\n+        byte[] firstMessageInQueue = uartMessages.first();\n+        if (firstMessageInQueue[0] != 0) {\n+            return false;\n+        }\n+\n+        if (firstMessageInQueue.length < 2) {\n+            return false;\n+        }\n+\n+        int expectedChunks = (firstMessageInQueue[1] / 19) + (firstMessageInQueue[1] % 19 > 0 ? 1 : 0);\n+        if (expectedChunks != this.uartMessages.size()) {\n+            return false;\n+        }\n+        {\n+            // Check that we have every single ID\n+            int expected = 0;\n+            for (byte[] m : this.uartMessages) {\n+                if (m.length < 2) {\n+                    return false;\n+                }\n+\n+                if (m[0] != expected++) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+\n+    }\n+\n+    public void chunkReceived(byte[] byteValue) {\n+\n+        this.uartMessages.add(byteValue);\n+        if (isMessageComplete()) {\n+\n+            // Beyond this point, full message received\n+            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+\n+            for (byte[] msg : uartMessages) {\n+                try {\n+                    bos.write(Arrays.copyOfRange(msg, 1, msg.length));\n+                } catch (Exception e) {\n+                    // should never happen.\n+                    logger.error(\"Unexpected error\", e);", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMTE3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411711171", "bodyText": "This is already checked for you in the loop at the end of the method.", "author": "cpmeister", "createdAt": "2020-04-20T21:40:41Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class BRC1HUartProcessor {\n+\n+    /**\n+     * In the unlikely event of messages arrive in wrong order, this comparator will sort the queue\n+     */\n+    private Comparator<byte[]> chunkSorter = (byte[] m1, byte[] m2) -> m1[0] - m2[0];\n+\n+    private final Logger logger = LoggerFactory.getLogger(BRC1HUartProcessor.class);\n+\n+    private ConcurrentSkipListSet<byte[]> uartMessages = new ConcurrentSkipListSet<>(chunkSorter);\n+\n+    private ResponseListener responseListener;\n+\n+    public BRC1HUartProcessor(ResponseListener responseListener) {\n+        this.responseListener = responseListener;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    private boolean isMessageComplete() {\n+\n+        int messagesInQueue = this.uartMessages.size();\n+\n+        if (messagesInQueue <= 0) {\n+            return false;\n+        }\n+\n+        byte[] firstMessageInQueue = uartMessages.first();\n+        if (firstMessageInQueue[0] != 0) {\n+            return false;\n+        }", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMTYxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411711619", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (expectedChunks != this.uartMessages.size()) {\n          \n          \n            \n                    if (expectedChunks != messagesInQueue) {", "author": "cpmeister", "createdAt": "2020-04-20T21:41:31Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class BRC1HUartProcessor {\n+\n+    /**\n+     * In the unlikely event of messages arrive in wrong order, this comparator will sort the queue\n+     */\n+    private Comparator<byte[]> chunkSorter = (byte[] m1, byte[] m2) -> m1[0] - m2[0];\n+\n+    private final Logger logger = LoggerFactory.getLogger(BRC1HUartProcessor.class);\n+\n+    private ConcurrentSkipListSet<byte[]> uartMessages = new ConcurrentSkipListSet<>(chunkSorter);\n+\n+    private ResponseListener responseListener;\n+\n+    public BRC1HUartProcessor(ResponseListener responseListener) {\n+        this.responseListener = responseListener;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    private boolean isMessageComplete() {\n+\n+        int messagesInQueue = this.uartMessages.size();\n+\n+        if (messagesInQueue <= 0) {\n+            return false;\n+        }\n+\n+        byte[] firstMessageInQueue = uartMessages.first();\n+        if (firstMessageInQueue[0] != 0) {\n+            return false;\n+        }\n+\n+        if (firstMessageInQueue.length < 2) {\n+            return false;\n+        }\n+\n+        int expectedChunks = (firstMessageInQueue[1] / 19) + (firstMessageInQueue[1] % 19 > 0 ? 1 : 0);\n+        if (expectedChunks != this.uartMessages.size()) {", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxNTc0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411715747", "bodyText": "I think using Math.ceil makes what you are doing a bit more clear.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    int expectedChunks = (firstMessageInQueue[1] / 19) + (firstMessageInQueue[1] % 19 > 0 ? 1 : 0);\n          \n          \n            \n                    int expectedChunks = (int) Math.ceil(firstMessageInQueue[1] / 19.0);", "author": "cpmeister", "createdAt": "2020-04-20T21:49:37Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class BRC1HUartProcessor {\n+\n+    /**\n+     * In the unlikely event of messages arrive in wrong order, this comparator will sort the queue\n+     */\n+    private Comparator<byte[]> chunkSorter = (byte[] m1, byte[] m2) -> m1[0] - m2[0];\n+\n+    private final Logger logger = LoggerFactory.getLogger(BRC1HUartProcessor.class);\n+\n+    private ConcurrentSkipListSet<byte[]> uartMessages = new ConcurrentSkipListSet<>(chunkSorter);\n+\n+    private ResponseListener responseListener;\n+\n+    public BRC1HUartProcessor(ResponseListener responseListener) {\n+        this.responseListener = responseListener;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    private boolean isMessageComplete() {\n+\n+        int messagesInQueue = this.uartMessages.size();\n+\n+        if (messagesInQueue <= 0) {\n+            return false;\n+        }\n+\n+        byte[] firstMessageInQueue = uartMessages.first();\n+        if (firstMessageInQueue[0] != 0) {\n+            return false;\n+        }\n+\n+        if (firstMessageInQueue.length < 2) {\n+            return false;\n+        }\n+\n+        int expectedChunks = (firstMessageInQueue[1] / 19) + (firstMessageInQueue[1] % 19 > 0 ? 1 : 0);", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxNjQ1OA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411716458", "bodyText": "remove this blank line", "author": "cpmeister", "createdAt": "2020-04-20T21:50:54Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class MadokaMessage {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(MadokaMessage.class);\n+\n+    /**\n+     * Maximum number of bytes per message chunk, including headers\n+     */\n+    public static final int MAX_CHUNK_SIZE = 20;\n+\n+    private int messageId;\n+    private Map<Integer, MadokaValue> values;\n+\n+    private MadokaMessage() {\n+        values = new HashMap<>();\n+    }\n+\n+    public static byte[] createRequest(BRC1HCommand command, MadokaValue... parameters) {\n+        try {\n+            ByteArrayOutputStream output = new ByteArrayOutputStream();\n+            DataOutputStream request = new DataOutputStream(output);\n+\n+            // Message Length - Computed in the end\n+            request.writeByte(0);\n+            request.writeByte(0);\n+\n+            // Command ID, coded on 3 bytes\n+            request.writeByte(0);\n+            request.writeShort(command.getCommandId());\n+\n+            if (parameters.length == 0) {\n+                request.writeByte(0);\n+                request.writeByte(0);\n+            } else {\n+", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxNjUzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411716531", "bodyText": "remove this blank line", "author": "cpmeister", "createdAt": "2020-04-20T21:51:00Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class MadokaMessage {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(MadokaMessage.class);\n+\n+    /**\n+     * Maximum number of bytes per message chunk, including headers\n+     */\n+    public static final int MAX_CHUNK_SIZE = 20;\n+\n+    private int messageId;\n+    private Map<Integer, MadokaValue> values;\n+\n+    private MadokaMessage() {\n+        values = new HashMap<>();\n+    }\n+\n+    public static byte[] createRequest(BRC1HCommand command, MadokaValue... parameters) {\n+        try {\n+            ByteArrayOutputStream output = new ByteArrayOutputStream();\n+            DataOutputStream request = new DataOutputStream(output);\n+\n+            // Message Length - Computed in the end\n+            request.writeByte(0);\n+            request.writeByte(0);\n+\n+            // Command ID, coded on 3 bytes\n+            request.writeByte(0);\n+            request.writeShort(command.getCommandId());\n+\n+            if (parameters.length == 0) {\n+                request.writeByte(0);\n+                request.writeByte(0);\n+            } else {\n+\n+                for (MadokaValue mv : parameters) {\n+                    request.writeByte(mv.getId());\n+                    request.writeByte(mv.getSize());\n+                    request.write(mv.getRawValue());\n+                }\n+", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxNzEwOA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411717108", "bodyText": "Please catch specific exceptions.", "author": "cpmeister", "createdAt": "2020-04-20T21:52:12Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class MadokaMessage {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(MadokaMessage.class);\n+\n+    /**\n+     * Maximum number of bytes per message chunk, including headers\n+     */\n+    public static final int MAX_CHUNK_SIZE = 20;\n+\n+    private int messageId;\n+    private Map<Integer, MadokaValue> values;\n+\n+    private MadokaMessage() {\n+        values = new HashMap<>();\n+    }\n+\n+    public static byte[] createRequest(BRC1HCommand command, MadokaValue... parameters) {\n+        try {\n+            ByteArrayOutputStream output = new ByteArrayOutputStream();\n+            DataOutputStream request = new DataOutputStream(output);\n+\n+            // Message Length - Computed in the end\n+            request.writeByte(0);\n+            request.writeByte(0);\n+\n+            // Command ID, coded on 3 bytes\n+            request.writeByte(0);\n+            request.writeShort(command.getCommandId());\n+\n+            if (parameters.length == 0) {\n+                request.writeByte(0);\n+                request.writeByte(0);\n+            } else {\n+\n+                for (MadokaValue mv : parameters) {\n+                    request.writeByte(mv.getId());\n+                    request.writeByte(mv.getSize());\n+                    request.write(mv.getRawValue());\n+                }\n+\n+            }\n+\n+            // Finally, compute array size\n+            byte[] ret = output.toByteArray();\n+            ret[1] = (byte) (ret.length - 1);\n+\n+            return ret;\n+        } catch (Exception e) {", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxNzc3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411717776", "bodyText": "If there is no way you could anticipate createRequest throwing an error, then I would suggest that instead of logging it you just throw some RuntimeException here instead.", "author": "cpmeister", "createdAt": "2020-04-20T21:53:28Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class MadokaMessage {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(MadokaMessage.class);\n+\n+    /**\n+     * Maximum number of bytes per message chunk, including headers\n+     */\n+    public static final int MAX_CHUNK_SIZE = 20;\n+\n+    private int messageId;\n+    private Map<Integer, MadokaValue> values;\n+\n+    private MadokaMessage() {\n+        values = new HashMap<>();\n+    }\n+\n+    public static byte[] createRequest(BRC1HCommand command, MadokaValue... parameters) {\n+        try {\n+            ByteArrayOutputStream output = new ByteArrayOutputStream();\n+            DataOutputStream request = new DataOutputStream(output);\n+\n+            // Message Length - Computed in the end\n+            request.writeByte(0);\n+            request.writeByte(0);\n+\n+            // Command ID, coded on 3 bytes\n+            request.writeByte(0);\n+            request.writeShort(command.getCommandId());\n+\n+            if (parameters.length == 0) {\n+                request.writeByte(0);\n+                request.writeByte(0);\n+            } else {\n+\n+                for (MadokaValue mv : parameters) {\n+                    request.writeByte(mv.getId());\n+                    request.writeByte(mv.getSize());\n+                    request.write(mv.getRawValue());\n+                }\n+\n+            }\n+\n+            // Finally, compute array size\n+            byte[] ret = output.toByteArray();\n+            ret[1] = (byte) (ret.length - 1);\n+\n+            return ret;\n+        } catch (Exception e) {\n+            logger.info(\"Error while building request\", e);\n+            return new byte[] {};", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxNzg2NA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411717864", "bodyText": "please remove this blank line", "author": "cpmeister", "createdAt": "2020-04-20T21:53:40Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class MadokaMessage {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(MadokaMessage.class);\n+\n+    /**\n+     * Maximum number of bytes per message chunk, including headers\n+     */\n+    public static final int MAX_CHUNK_SIZE = 20;\n+\n+    private int messageId;\n+    private Map<Integer, MadokaValue> values;\n+\n+    private MadokaMessage() {\n+        values = new HashMap<>();\n+    }\n+\n+    public static byte[] createRequest(BRC1HCommand command, MadokaValue... parameters) {\n+        try {\n+            ByteArrayOutputStream output = new ByteArrayOutputStream();\n+            DataOutputStream request = new DataOutputStream(output);\n+\n+            // Message Length - Computed in the end\n+            request.writeByte(0);\n+            request.writeByte(0);\n+\n+            // Command ID, coded on 3 bytes\n+            request.writeByte(0);\n+            request.writeShort(command.getCommandId());\n+\n+            if (parameters.length == 0) {\n+                request.writeByte(0);\n+                request.writeByte(0);\n+            } else {\n+\n+                for (MadokaValue mv : parameters) {\n+                    request.writeByte(mv.getId());\n+                    request.writeByte(mv.getSize());\n+                    request.write(mv.getRawValue());\n+                }\n+\n+            }\n+\n+            // Finally, compute array size\n+            byte[] ret = output.toByteArray();\n+            ret[1] = (byte) (ret.length - 1);\n+\n+            return ret;\n+        } catch (Exception e) {\n+            logger.info(\"Error while building request\", e);\n+            return new byte[] {};\n+        }\n+    }\n+\n+    public static MadokaMessage parse(byte[] msg) throws MadokaParsingException {\n+        if (msg.length < 1) {\n+            throw new MadokaParsingException(\"Message received is too short to be parsed.\");\n+        }\n+        if (msg[0] != msg.length) {\n+            throw new MadokaParsingException(\"Message size is not valid (different from byte[0]).\");\n+        }\n+\n+        MadokaMessage m = new MadokaMessage();\n+        // m.messageId = ByteBuffer.wrap(msg, 2, 2).getShort();\n+        m.messageId = ((msg[0] & 0xff) << 8) | (msg[1] & 0xff);\n+\n+        MadokaValue mv = null;\n+\n+        for (int i = 4; i < msg.length;) {\n+", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxODcxNA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411718714", "bodyText": "If you expect size to be an unsigned int then you could do this instead:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        mv.setSize(msg[i + 1]);\n          \n          \n            \n                        mv.setSize(Byte.toUnsignedInt(msg[i + 1]));", "author": "cpmeister", "createdAt": "2020-04-20T21:55:24Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class MadokaMessage {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(MadokaMessage.class);\n+\n+    /**\n+     * Maximum number of bytes per message chunk, including headers\n+     */\n+    public static final int MAX_CHUNK_SIZE = 20;\n+\n+    private int messageId;\n+    private Map<Integer, MadokaValue> values;\n+\n+    private MadokaMessage() {\n+        values = new HashMap<>();\n+    }\n+\n+    public static byte[] createRequest(BRC1HCommand command, MadokaValue... parameters) {\n+        try {\n+            ByteArrayOutputStream output = new ByteArrayOutputStream();\n+            DataOutputStream request = new DataOutputStream(output);\n+\n+            // Message Length - Computed in the end\n+            request.writeByte(0);\n+            request.writeByte(0);\n+\n+            // Command ID, coded on 3 bytes\n+            request.writeByte(0);\n+            request.writeShort(command.getCommandId());\n+\n+            if (parameters.length == 0) {\n+                request.writeByte(0);\n+                request.writeByte(0);\n+            } else {\n+\n+                for (MadokaValue mv : parameters) {\n+                    request.writeByte(mv.getId());\n+                    request.writeByte(mv.getSize());\n+                    request.write(mv.getRawValue());\n+                }\n+\n+            }\n+\n+            // Finally, compute array size\n+            byte[] ret = output.toByteArray();\n+            ret[1] = (byte) (ret.length - 1);\n+\n+            return ret;\n+        } catch (Exception e) {\n+            logger.info(\"Error while building request\", e);\n+            return new byte[] {};\n+        }\n+    }\n+\n+    public static MadokaMessage parse(byte[] msg) throws MadokaParsingException {\n+        if (msg.length < 1) {\n+            throw new MadokaParsingException(\"Message received is too short to be parsed.\");\n+        }\n+        if (msg[0] != msg.length) {\n+            throw new MadokaParsingException(\"Message size is not valid (different from byte[0]).\");\n+        }\n+\n+        MadokaMessage m = new MadokaMessage();\n+        // m.messageId = ByteBuffer.wrap(msg, 2, 2).getShort();\n+        m.messageId = ((msg[0] & 0xff) << 8) | (msg[1] & 0xff);\n+\n+        MadokaValue mv = null;\n+\n+        for (int i = 4; i < msg.length;) {\n+\n+            mv = new MadokaValue();\n+            mv.setId(msg[i]);\n+            mv.setSize(msg[i + 1]);", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxOTc4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411719787", "bodyText": "Shouldn't you be calling this method in BRC1HUartProcessor.isMessageComplete()?", "author": "cpmeister", "createdAt": "2020-04-20T21:57:28Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class MadokaMessage {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(MadokaMessage.class);\n+\n+    /**\n+     * Maximum number of bytes per message chunk, including headers\n+     */\n+    public static final int MAX_CHUNK_SIZE = 20;\n+\n+    private int messageId;\n+    private Map<Integer, MadokaValue> values;\n+\n+    private MadokaMessage() {\n+        values = new HashMap<>();\n+    }\n+\n+    public static byte[] createRequest(BRC1HCommand command, MadokaValue... parameters) {\n+        try {\n+            ByteArrayOutputStream output = new ByteArrayOutputStream();\n+            DataOutputStream request = new DataOutputStream(output);\n+\n+            // Message Length - Computed in the end\n+            request.writeByte(0);\n+            request.writeByte(0);\n+\n+            // Command ID, coded on 3 bytes\n+            request.writeByte(0);\n+            request.writeShort(command.getCommandId());\n+\n+            if (parameters.length == 0) {\n+                request.writeByte(0);\n+                request.writeByte(0);\n+            } else {\n+\n+                for (MadokaValue mv : parameters) {\n+                    request.writeByte(mv.getId());\n+                    request.writeByte(mv.getSize());\n+                    request.write(mv.getRawValue());\n+                }\n+\n+            }\n+\n+            // Finally, compute array size\n+            byte[] ret = output.toByteArray();\n+            ret[1] = (byte) (ret.length - 1);\n+\n+            return ret;\n+        } catch (Exception e) {\n+            logger.info(\"Error while building request\", e);\n+            return new byte[] {};\n+        }\n+    }\n+\n+    public static MadokaMessage parse(byte[] msg) throws MadokaParsingException {\n+        if (msg.length < 1) {\n+            throw new MadokaParsingException(\"Message received is too short to be parsed.\");\n+        }\n+        if (msg[0] != msg.length) {\n+            throw new MadokaParsingException(\"Message size is not valid (different from byte[0]).\");\n+        }\n+\n+        MadokaMessage m = new MadokaMessage();\n+        // m.messageId = ByteBuffer.wrap(msg, 2, 2).getShort();\n+        m.messageId = ((msg[0] & 0xff) << 8) | (msg[1] & 0xff);\n+\n+        MadokaValue mv = null;\n+\n+        for (int i = 4; i < msg.length;) {\n+\n+            mv = new MadokaValue();\n+            mv.setId(msg[i]);\n+            mv.setSize(msg[i + 1]);\n+\n+            if (mv.getSize() < 0) {\n+                logger.info(\"*** TO BE TRACKED *** NEGATIVE VALUE ***\");\n+                mv.setSize(mv.getSize() + 128);\n+            }\n+\n+            mv.setRawValue(Arrays.copyOfRange(msg, i + 2, i + 2 + mv.getSize()));\n+\n+            i += 2 + mv.getSize();\n+\n+            m.values.put(mv.getId(), mv);\n+        }\n+\n+        return m;\n+    }\n+\n+    public int getMessageId() {\n+        return messageId;\n+    }\n+\n+    public Map<Integer, MadokaValue> getValues() {\n+        return values;\n+    }\n+\n+    public static int expectedMessageChunks(byte[] firstMessage) {", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTk5ODg0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411998845", "bodyText": "Actually this method was not needed anymore - have removed it.", "author": "blafois", "createdAt": "2020-04-21T08:51:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxOTc4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyMDYyNg==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411720626", "bodyText": "You should apply my earlier suggestion here as well.", "author": "cpmeister", "createdAt": "2020-04-20T21:59:07Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class MadokaMessage {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(MadokaMessage.class);\n+\n+    /**\n+     * Maximum number of bytes per message chunk, including headers\n+     */\n+    public static final int MAX_CHUNK_SIZE = 20;\n+\n+    private int messageId;\n+    private Map<Integer, MadokaValue> values;\n+\n+    private MadokaMessage() {\n+        values = new HashMap<>();\n+    }\n+\n+    public static byte[] createRequest(BRC1HCommand command, MadokaValue... parameters) {\n+        try {\n+            ByteArrayOutputStream output = new ByteArrayOutputStream();\n+            DataOutputStream request = new DataOutputStream(output);\n+\n+            // Message Length - Computed in the end\n+            request.writeByte(0);\n+            request.writeByte(0);\n+\n+            // Command ID, coded on 3 bytes\n+            request.writeByte(0);\n+            request.writeShort(command.getCommandId());\n+\n+            if (parameters.length == 0) {\n+                request.writeByte(0);\n+                request.writeByte(0);\n+            } else {\n+\n+                for (MadokaValue mv : parameters) {\n+                    request.writeByte(mv.getId());\n+                    request.writeByte(mv.getSize());\n+                    request.write(mv.getRawValue());\n+                }\n+\n+            }\n+\n+            // Finally, compute array size\n+            byte[] ret = output.toByteArray();\n+            ret[1] = (byte) (ret.length - 1);\n+\n+            return ret;\n+        } catch (Exception e) {\n+            logger.info(\"Error while building request\", e);\n+            return new byte[] {};\n+        }\n+    }\n+\n+    public static MadokaMessage parse(byte[] msg) throws MadokaParsingException {\n+        if (msg.length < 1) {\n+            throw new MadokaParsingException(\"Message received is too short to be parsed.\");\n+        }\n+        if (msg[0] != msg.length) {\n+            throw new MadokaParsingException(\"Message size is not valid (different from byte[0]).\");\n+        }\n+\n+        MadokaMessage m = new MadokaMessage();\n+        // m.messageId = ByteBuffer.wrap(msg, 2, 2).getShort();\n+        m.messageId = ((msg[0] & 0xff) << 8) | (msg[1] & 0xff);\n+\n+        MadokaValue mv = null;\n+\n+        for (int i = 4; i < msg.length;) {\n+\n+            mv = new MadokaValue();\n+            mv.setId(msg[i]);\n+            mv.setSize(msg[i + 1]);\n+\n+            if (mv.getSize() < 0) {\n+                logger.info(\"*** TO BE TRACKED *** NEGATIVE VALUE ***\");\n+                mv.setSize(mv.getSize() + 128);\n+            }\n+\n+            mv.setRawValue(Arrays.copyOfRange(msg, i + 2, i + 2 + mv.getSize()));\n+\n+            i += 2 + mv.getSize();\n+\n+            m.values.put(mv.getId(), mv);\n+        }\n+\n+        return m;\n+    }\n+\n+    public int getMessageId() {\n+        return messageId;\n+    }\n+\n+    public Map<Integer, MadokaValue> getValues() {\n+        return values;\n+    }\n+\n+    public static int expectedMessageChunks(byte[] firstMessage) {\n+        if (firstMessage.length < 2) {\n+            return -1;\n+        }\n+\n+        if (firstMessage[0] != 0) {\n+            // This is not the first message so cannot be used\n+            return -1;\n+        }\n+\n+        int expectedTotalBytes = firstMessage[1];\n+\n+        return ((expectedTotalBytes / (MAX_CHUNK_SIZE - 1))\n+                + ((expectedTotalBytes % (MAX_CHUNK_SIZE - 1)) > 0 ? 1 : 0));", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyMTkzMA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411721930", "bodyText": "Please make sure your enum names are camelcase.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public enum FAN_SPEED {\n          \n          \n            \n                public enum FanSpeed {", "author": "cpmeister", "createdAt": "2020-04-20T22:01:57Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaProperties.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class MadokaProperties {\n+\n+    public enum FAN_SPEED {", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyMjAwNg==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411722006", "bodyText": "please make this camelcase as well.", "author": "cpmeister", "createdAt": "2020-04-20T22:02:09Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaProperties.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class MadokaProperties {\n+\n+    public enum FAN_SPEED {\n+        MAX(5),\n+        MEDIUM(3),\n+        LOW(1);\n+\n+        private int v;\n+\n+        FAN_SPEED(int v) {\n+            this.v = v;\n+        }\n+\n+        public static FAN_SPEED valueOf(int v) {\n+            if (v == 5) {\n+                return MAX;\n+            } else if (v >= 2 && v <= 4) {\n+                return MEDIUM;\n+            } else {\n+                return LOW;\n+            }\n+        }\n+\n+        public int value() {\n+            return v;\n+        }\n+    }\n+\n+    public enum OPERATION_MODE {", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyMjkyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411722921", "bodyText": "The state shouldn't be nullable since the initial state should be NEW.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private volatile @Nullable State state;\n          \n          \n            \n                private volatile State state = State.NEW;", "author": "cpmeister", "createdAt": "2020-04-20T22:04:07Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/BRC1HCommand.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n+\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Condition;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public abstract class BRC1HCommand {\n+\n+    public enum State {\n+        NEW,\n+        ENQUEUED,\n+        SENT,\n+        SUCCEEDED,\n+        FAILED\n+    }\n+\n+    private volatile @Nullable State state;", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyMzEzNA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411723134", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public @Nullable State getState() {\n          \n          \n            \n                public State getState() {", "author": "cpmeister", "createdAt": "2020-04-20T22:04:36Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/BRC1HCommand.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n+\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Condition;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public abstract class BRC1HCommand {\n+\n+    public enum State {\n+        NEW,\n+        ENQUEUED,\n+        SENT,\n+        SUCCEEDED,\n+        FAILED\n+    }\n+\n+    private volatile @Nullable State state;\n+\n+    private final Lock stateLock = new ReentrantLock();\n+\n+    private final Condition stateCondition = stateLock.newCondition();\n+\n+    public abstract boolean handleResponse(Executor executor, ResponseListener listener, byte @Nullable [] response);\n+\n+    /**\n+     * THis command returns the message to be sent\n+     *\n+     * @return\n+     */\n+    public abstract byte[] getRequest();\n+\n+    /**\n+     * This is the command number, in the protocol\n+     *\n+     * @return\n+     */\n+    public abstract int getCommandId();\n+\n+    /**\n+     * Returns current state of the command.\n+     *\n+     * @return current state\n+     */\n+    public @Nullable State getState() {", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyMzM2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411723367", "bodyText": "please remove this blank line", "author": "cpmeister", "createdAt": "2020-04-20T22:05:07Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetFanspeedCommand.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n+\n+import java.util.concurrent.Executor;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.FAN_SPEED;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class GetFanspeedCommand extends BRC1HCommand {\n+\n+    private final Logger logger = LoggerFactory.getLogger(GetFanspeedCommand.class);\n+\n+    private @Nullable FAN_SPEED coolingFanSpeed;\n+    private @Nullable FAN_SPEED heatingFanSpeed;\n+\n+    @Override\n+    public byte[] getRequest() {\n+        return MadokaMessage.createRequest(this);\n+    }\n+\n+    @Override\n+    public boolean handleResponse(Executor executor, ResponseListener listener, byte @Nullable [] response) {\n+", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyNDM2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411724362", "bodyText": "Did you see my other comment about this: #7372 (comment)", "author": "cpmeister", "createdAt": "2020-04-20T22:07:07Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetOperationmodeCommand.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n+\n+import java.util.concurrent.Executor;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.OPERATION_MODE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+public class GetOperationmodeCommand extends BRC1HCommand {\n+\n+    private final Logger logger = LoggerFactory.getLogger(GetOperationmodeCommand.class);\n+\n+    private OPERATION_MODE operationMode;\n+\n+    @Override\n+    public byte[] getRequest() {\n+        return MadokaMessage.createRequest(this);\n+    }\n+\n+    @Override\n+    public boolean handleResponse(Executor executor, ResponseListener listener, byte @Nullable [] response) {\n+        if (response == null) {\n+            return false;\n+        }\n+\n+        try {\n+\n+            MadokaMessage mm = MadokaMessage.parse(response);\n+\n+            operationMode = OPERATION_MODE.valueOf(mm.getValues().get(0x20).getRawValue()[0]);\n+\n+            logger.debug(\"operationMode: {}\", operationMode);\n+\n+            listener.receivedResponse(this);", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyNjEyOA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411726128", "bodyText": "Please remove all of these autogenerated comments", "author": "cpmeister", "createdAt": "2020-04-20T22:10:50Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/test/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DummyThing.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.handler;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class DummyThing implements Thing {\n+\n+    @Override\n+    public @Nullable String getLabel() {\n+        // TODO Auto-generated method stub\n+        return null;\n+    }\n+\n+    @Override\n+    public void setLabel(@Nullable String label) {\n+        // TODO Auto-generated method stub\n+\n+    }\n+\n+    @Override\n+    public List<@NonNull Channel> getChannels() {\n+        // TODO Auto-generated method stub\n+        return new ArrayList<Channel>();\n+    }\n+\n+    @Override\n+    public List<@NonNull Channel> getChannelsOfGroup(String channelGroupId) {\n+        // TODO Auto-generated method stub\n+        return new ArrayList<Channel>();\n+    }\n+\n+    @Override\n+    public @Nullable Channel getChannel(String channelId) {\n+        // TODO Auto-generated method stub\n+        return null;\n+    }\n+\n+    @Override\n+    public @Nullable Channel getChannel(ChannelUID channelUID) {\n+        // TODO Auto-generated method stub\n+        return null;\n+    }\n+\n+    @Override\n+    public ThingStatus getStatus() {\n+        // TODO Auto-generated method stub\n+        return ThingStatus.ONLINE;\n+    }\n+\n+    @Override\n+    public ThingStatusInfo getStatusInfo() {\n+        // TODO Auto-generated method stub\n+        return new ThingStatusInfo(ThingStatus.ONLINE, ThingStatusDetail.NONE, \"Dummy\");\n+    }\n+\n+    @Override\n+    public void setStatusInfo(ThingStatusInfo status) {\n+        // TODO Auto-generated method stub\n+\n+    }\n+\n+    @Override\n+    public void setHandler(@Nullable ThingHandler thingHandler) {\n+        // TODO Auto-generated method stub\n+\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getHandler() {\n+        // TODO Auto-generated method stub\n+        return null;\n+    }\n+\n+    @Override\n+    public @Nullable ThingUID getBridgeUID() {\n+        // TODO Auto-generated method stub\n+        return null;\n+    }\n+\n+    @Override\n+    public void setBridgeUID(@Nullable ThingUID bridgeUID) {\n+        // TODO Auto-generated method stub\n+\n+    }\n+\n+    @Override\n+    public Configuration getConfiguration() {\n+        // TODO Auto-generated method stub\n+        return new Configuration();\n+    }\n+\n+    @Override\n+    public ThingUID getUID() {\n+        // TODO Auto-generated method stub\n+        return new ThingUID(\"dummy\");\n+    }\n+\n+    @Override\n+    public ThingTypeUID getThingTypeUID() {\n+        // TODO Auto-generated method stub\n+        return new ThingTypeUID(\"dummy\");\n+    }\n+\n+    @Override\n+    public Map<@NonNull String, @NonNull String> getProperties() {\n+        // TODO Auto-generated method stub\n+        return new HashMap<String, String>();\n+    }\n+\n+    @Override\n+    public @Nullable String setProperty(String name, @Nullable String value) {\n+        // TODO Auto-generated method stub\n+        return null;\n+    }\n+\n+    @Override\n+    public void setProperties(Map<@NonNull String, @NonNull String> properties) {\n+        // TODO Auto-generated method stub\n+\n+    }\n+\n+    @Override\n+    public @Nullable String getLocation() {\n+        // TODO Auto-generated method stub", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyNjM4OA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411726388", "bodyText": "Please remove the excess blank lines in all the methods in this file.", "author": "cpmeister", "createdAt": "2020-04-20T22:11:21Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/test/java/org/openhab/binding/bluetooth/daikinmadoka/internal/MadokaMessageTest.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal;\n+\n+import static org.junit.Assert.*;\n+\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.junit.Test;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaValue;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetIndoorOutoorTemperatures;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetPowerstateCommand;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+public class MadokaMessageTest {\n+\n+    @Test\n+    public void testExpectedMessageChunks0() {\n+", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyNzYwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411727605", "bodyText": "The error logging level should be reserved for issues catastrophic enough to threaten the operation of openHab itself. An error in a binding shouldn't qualify for this. Please read the openHab coding guidelines for expected use of logging in bindings.\nMy general rule for logging levels is:\n\ntrace - used for normal expected execution paths\ndebug - used for unexepected execution paths, but well within normal operation\ninfo - used for notable points in an execution path, like a milestone. (in openhab we try reserve this logging level for the core, so bindings should rarely ever call this.)\nwarn - used for notable unexpected execution paths that a regular user (not just a developer) should be notified of. Warnings should be used to indicate that something not-normal occurred and user intervention is required to resolve. Warnings do not indicate a failure to operate merely an abnormal condition of operation that can still be handled by the binding. Failures in binding operation should be indicated by changing the thing status to offline.\nerror - used to indicate catastrophic program failure. This should be used to indicate a catastrophic failure in openhab's ability to operate. A failure in a binding would never cause openhab as a whole to fail so a failure in a bindings should never log an error. Instead that failure should be indicated by changing the thing status.\n\nPlease make changes elsewhere as appropriate.", "author": "cpmeister", "createdAt": "2020-04-20T22:14:06Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetVersionCommand.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n+\n+import java.util.concurrent.Executor;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+public class GetVersionCommand extends BRC1HCommand {\n+\n+    private final Logger logger = LoggerFactory.getLogger(GetVersionCommand.class);\n+    private String remoteControllerVersion;\n+    private String communicationControllerVersion;\n+\n+    @Override\n+    public byte[] getRequest() {\n+        return MadokaMessage.createRequest(this);\n+    }\n+\n+    @Override\n+    public boolean handleResponse(Executor executor, ResponseListener listener, byte @Nullable [] response) {\n+        if (response == null) {\n+            return false;\n+        }\n+\n+        try {\n+\n+            MadokaMessage mm = MadokaMessage.parse(response);\n+\n+            int remoteControllerMajor = Integer.valueOf(mm.getValues().get(0x45).getRawValue()[0]);\n+            int remoteControllerMinor = Integer.valueOf(mm.getValues().get(0x45).getRawValue()[1]);\n+            int remoteControllerRevision = Integer.valueOf(mm.getValues().get(0x45).getRawValue()[2]);\n+\n+            this.remoteControllerVersion = remoteControllerMajor + \".\" + remoteControllerMinor + \".\"\n+                    + remoteControllerRevision;\n+\n+            int commControllerMajor = Integer.valueOf(mm.getValues().get(0x46).getRawValue()[0]);\n+            int commControllerMinor = Integer.valueOf(mm.getValues().get(0x46).getRawValue()[1]);\n+\n+            this.communicationControllerVersion = commControllerMajor + \".\" + commControllerMinor;\n+\n+            listener.receivedResponse(this);\n+            setState(State.SUCCEEDED);\n+            return true;\n+        } catch (Exception e) {\n+            logger.error(\"Error while parsing response\", e);", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyNzk3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411727975", "bodyText": "Please cache mm.getValues().get(0x45).getRawValue() and mm.getValues().get(0x46).getRawValue() in local variables so you can reuse them.", "author": "cpmeister", "createdAt": "2020-04-20T22:15:01Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetVersionCommand.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n+\n+import java.util.concurrent.Executor;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+public class GetVersionCommand extends BRC1HCommand {\n+\n+    private final Logger logger = LoggerFactory.getLogger(GetVersionCommand.class);\n+    private String remoteControllerVersion;\n+    private String communicationControllerVersion;\n+\n+    @Override\n+    public byte[] getRequest() {\n+        return MadokaMessage.createRequest(this);\n+    }\n+\n+    @Override\n+    public boolean handleResponse(Executor executor, ResponseListener listener, byte @Nullable [] response) {\n+        if (response == null) {\n+            return false;\n+        }\n+\n+        try {\n+\n+            MadokaMessage mm = MadokaMessage.parse(response);\n+\n+            int remoteControllerMajor = Integer.valueOf(mm.getValues().get(0x45).getRawValue()[0]);", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTczMDU4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r411730585", "bodyText": "To reduce the amount of redundant logic that subclasses must implement I suggest changing this method signature so that all the redundant logic is handled in by the method caller instead:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public abstract boolean handleResponse(Executor executor, ResponseListener listener, byte @Nullable [] response);\n          \n          \n            \n                public abstract void handleResponse(ResponseListener listener, MadokaMessage mm);", "author": "cpmeister", "createdAt": "2020-04-20T22:20:34Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/BRC1HCommand.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n+\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Condition;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public abstract class BRC1HCommand {\n+\n+    public enum State {\n+        NEW,\n+        ENQUEUED,\n+        SENT,\n+        SUCCEEDED,\n+        FAILED\n+    }\n+\n+    private volatile @Nullable State state;\n+\n+    private final Lock stateLock = new ReentrantLock();\n+\n+    private final Condition stateCondition = stateLock.newCondition();\n+\n+    public abstract boolean handleResponse(Executor executor, ResponseListener listener, byte @Nullable [] response);", "originalCommit": "4efef432272ce52b549067c3aef0fa30b5b26213", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "url": "https://github.com/openhab/openhab-addons/commit/4023fa4afda298d1796ec0cf4b28ce44f36dff73", "message": "Fixed all remarks in PR.\nAdded chapter on Bluetooth pairing in README.md\n\nSigned-off-by: Benjamin Lafois <benjamin@lafois.com>", "committedDate": "2020-04-21T09:45:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQyMzM5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412423393", "bodyText": "Can you please add @NonNullByDefault to all of your command classes", "author": "cpmeister", "createdAt": "2020-04-21T19:14:51Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetPowerstateCommand.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n+\n+import java.util.concurrent.Executor;\n+\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+public class GetPowerstateCommand extends BRC1HCommand {", "originalCommit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQzMTUyNw==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412431527", "bodyText": "Is this one of those unsigned byte issues again? Can you just use Byte.toUnsignedInt when parsing it instead?", "author": "cpmeister", "createdAt": "2020-04-21T19:27:17Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetIndoorOutoorTemperatures.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n+\n+import java.util.concurrent.Executor;\n+\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+public class GetIndoorOutoorTemperatures extends BRC1HCommand {\n+\n+    private final Logger logger = LoggerFactory.getLogger(GetIndoorOutoorTemperatures.class);\n+\n+    private DecimalType indoorTemperature;\n+    private DecimalType outdoorTemperature;\n+\n+    @Override\n+    public byte[] getRequest() {\n+        return MadokaMessage.createRequest(this);\n+    }\n+\n+    @Override\n+    public boolean handleResponse(Executor executor, ResponseListener listener, MadokaMessage mm) {\n+        try {\n+            Integer iIndoorTemperature = Integer.valueOf(mm.getValues().get(0x40).getRawValue()[0]);\n+            Integer iOutdoorTemperature = Integer.valueOf(mm.getValues().get(0x41).getRawValue()[0]);\n+\n+            if (iOutdoorTemperature == -1) {\n+                iOutdoorTemperature = null;\n+            } else {\n+                if (iOutdoorTemperature < 0) {\n+                    iOutdoorTemperature = ((iOutdoorTemperature + 256) - 128) * -1;", "originalCommit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc5NDA0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412794045", "bodyText": "No this one is different - it is the encoding of the temperature from the thermostat. It must supports negative values from outdoor temperature.", "author": "blafois", "createdAt": "2020-04-22T08:48:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQzMTUyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQzNTc0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412435747", "bodyText": "Integer.valueOf isn't needed to convert a byte to an int.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        int remoteControllerMajor = Integer.valueOf(mv45[0]);\n          \n          \n            \n                        int remoteControllerMajor = mv45[0];", "author": "cpmeister", "createdAt": "2020-04-21T19:34:18Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetVersionCommand.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n+\n+import java.util.concurrent.Executor;\n+\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+public class GetVersionCommand extends BRC1HCommand {\n+\n+    private final Logger logger = LoggerFactory.getLogger(GetVersionCommand.class);\n+    private String remoteControllerVersion;\n+    private String communicationControllerVersion;\n+\n+    @Override\n+    public byte[] getRequest() {\n+        return MadokaMessage.createRequest(this);\n+    }\n+\n+    @Override\n+    public boolean handleResponse(Executor executor, ResponseListener listener, MadokaMessage mm) {\n+        try {\n+            byte[] mv45 = mm.getValues().get(0x45).getRawValue();\n+\n+            int remoteControllerMajor = Integer.valueOf(mv45[0]);", "originalCommit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQzNzY4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412437683", "bodyText": "please remove this blank line", "author": "cpmeister", "createdAt": "2020-04-21T19:37:30Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class BRC1HUartProcessor {\n+\n+    /**\n+     * In the unlikely event of messages arrive in wrong order, this comparator will sort the queue\n+     */\n+    private Comparator<byte[]> chunkSorter = (byte[] m1, byte[] m2) -> m1[0] - m2[0];\n+\n+    private final Logger logger = LoggerFactory.getLogger(BRC1HUartProcessor.class);\n+\n+    private ConcurrentSkipListSet<byte[]> uartMessages = new ConcurrentSkipListSet<>(chunkSorter);\n+\n+    private ResponseListener responseListener;\n+\n+    public BRC1HUartProcessor(ResponseListener responseListener) {\n+        this.responseListener = responseListener;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    private boolean isMessageComplete() {\n+\n+        int messagesInQueue = this.uartMessages.size();\n+\n+        if (messagesInQueue <= 0) {\n+            return false;\n+        }\n+\n+        byte[] firstMessageInQueue = uartMessages.first();\n+\n+        if (firstMessageInQueue.length < 2) {\n+            return false;\n+        }\n+\n+        int expectedChunks = (int) Math.ceil(firstMessageInQueue[1] / 19.0);\n+        if (expectedChunks != messagesInQueue) {\n+            return false;\n+        }\n+\n+        // Check that we have every single ID\n+        int expected = 0;\n+        for (byte[] m : this.uartMessages) {\n+            if (m.length < 2) {\n+                return false;\n+            }\n+\n+            if (m[0] != expected++) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    public void chunkReceived(byte[] byteValue) {\n+", "originalCommit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQzNzc1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412437755", "bodyText": "please remove this blank line", "author": "cpmeister", "createdAt": "2020-04-21T19:37:38Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class BRC1HUartProcessor {\n+\n+    /**\n+     * In the unlikely event of messages arrive in wrong order, this comparator will sort the queue\n+     */\n+    private Comparator<byte[]> chunkSorter = (byte[] m1, byte[] m2) -> m1[0] - m2[0];\n+\n+    private final Logger logger = LoggerFactory.getLogger(BRC1HUartProcessor.class);\n+\n+    private ConcurrentSkipListSet<byte[]> uartMessages = new ConcurrentSkipListSet<>(chunkSorter);\n+\n+    private ResponseListener responseListener;\n+\n+    public BRC1HUartProcessor(ResponseListener responseListener) {\n+        this.responseListener = responseListener;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    private boolean isMessageComplete() {\n+", "originalCommit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQzOTIzMw==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412439233", "bodyText": "You should add another constructor allowing you to provide a cause throwable.", "author": "cpmeister", "createdAt": "2020-04-21T19:40:06Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaParsingException.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class MadokaParsingException extends Exception {\n+\n+    private String message;\n+\n+    public MadokaParsingException(String message) {\n+        this.message = message;\n+    }\n+", "originalCommit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ1Mjg2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412452866", "bodyText": "It seems that your handler will log any failures when calling handleResponse already. So I think you would end up having duplicate logs in the event of exceptions in your commands.\nSince the handler already handles any MadokaParsingException thrown, and since it appears that any exception here could be classified as a parsing exception, I suggest wrapping any exceptions that occur in a MadokaParsingException and passing the exception up the line.\nDoing that would eliminate the double logging issue and would also eliminate the need to return a boolean since any failures would be thrown as an exception instead.\nThis should cleanup a bit of code in both the commands and the handler.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean handleResponse(Executor executor, ResponseListener listener, MadokaMessage mm) {\n          \n          \n            \n                    try {\n          \n          \n            \n                        operationMode = OperationMode.valueOf(mm.getValues().get(0x20).getRawValue()[0]);\n          \n          \n            \n            \n          \n          \n            \n                        logger.debug(\"operationMode: {}\", operationMode);\n          \n          \n            \n            \n          \n          \n            \n                        setState(State.SUCCEEDED);\n          \n          \n            \n                        executor.execute(() -> listener.receivedResponse(this));\n          \n          \n            \n            \n          \n          \n            \n                        return true;\n          \n          \n            \n                    } catch (Exception e) {\n          \n          \n            \n                        logger.debug(\"Error while parsing response\", e);\n          \n          \n            \n                        setState(State.FAILED);\n          \n          \n            \n                    }\n          \n          \n            \n                    return false;\n          \n          \n            \n                public void handleResponse(Executor executor, ResponseListener listener, MadokaMessage mm) {\n          \n          \n            \n                    try {\n          \n          \n            \n                        operationMode = OperationMode.valueOf(mm.getValues().get(0x20).getRawValue()[0]);\n          \n          \n            \n            \n          \n          \n            \n                        logger.debug(\"operationMode: {}\", operationMode);\n          \n          \n            \n            \n          \n          \n            \n                        setState(State.SUCCEEDED);\n          \n          \n            \n                        executor.execute(() -> listener.receivedResponse(this));\n          \n          \n            \n                    } catch (Exception e) {\n          \n          \n            \n                        setState(State.FAILED);\n          \n          \n            \n                        throw new MadokaParsingException(e);\n          \n          \n            \n                    }", "author": "cpmeister", "createdAt": "2020-04-21T20:01:52Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetOperationmodeCommand.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n+\n+import java.util.concurrent.Executor;\n+\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.OperationMode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+public class GetOperationmodeCommand extends BRC1HCommand {\n+\n+    private final Logger logger = LoggerFactory.getLogger(GetOperationmodeCommand.class);\n+\n+    private OperationMode operationMode;\n+\n+    @Override\n+    public byte[] getRequest() {\n+        return MadokaMessage.createRequest(this);\n+    }\n+\n+    @Override\n+    public boolean handleResponse(Executor executor, ResponseListener listener, MadokaMessage mm) {\n+        try {\n+            operationMode = OperationMode.valueOf(mm.getValues().get(0x20).getRawValue()[0]);\n+\n+            logger.debug(\"operationMode: {}\", operationMode);\n+\n+            setState(State.SUCCEEDED);\n+            executor.execute(() -> listener.receivedResponse(this));\n+\n+            return true;\n+        } catch (Exception e) {\n+            logger.debug(\"Error while parsing response\", e);\n+            setState(State.FAILED);\n+        }\n+        return false;", "originalCommit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ1NDI0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412454245", "bodyText": "Why is this returning long if the largest value it would return is an int?", "author": "cpmeister", "createdAt": "2020-04-21T20:04:12Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaValue.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import java.nio.ByteBuffer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ *\n+ * @author blafois\n+ */\n+@NonNullByDefault\n+public class MadokaValue {\n+\n+    private int id;\n+    private int size;\n+    private byte @Nullable [] rawValue;\n+\n+    public MadokaValue(int id, int size, byte[] rawValue) {\n+        this.id = id;\n+        this.size = size;\n+        this.rawValue = rawValue;\n+    }\n+\n+    public MadokaValue() {\n+    }\n+\n+    public int getId() {\n+        return id;\n+    }\n+\n+    public void setId(int id) {\n+        this.id = id;\n+    }\n+\n+    public int getSize() {\n+        return size;\n+    }\n+\n+    public void setSize(int size) {\n+        this.size = size;\n+    }\n+\n+    public byte @Nullable [] getRawValue() {\n+        return rawValue;\n+    }\n+\n+    public void setRawValue(byte[] rawValue) {\n+        this.rawValue = rawValue;\n+    }\n+\n+    public long getComputedValue() {", "originalCommit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ1NjkxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412456919", "bodyText": "Since a lot of the commands that use this as their implementation perhaps you should make this the default implementation in BRC1HCommand.", "author": "cpmeister", "createdAt": "2020-04-21T20:08:32Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetIndoorOutoorTemperatures.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n+\n+import java.util.concurrent.Executor;\n+\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+public class GetIndoorOutoorTemperatures extends BRC1HCommand {\n+\n+    private final Logger logger = LoggerFactory.getLogger(GetIndoorOutoorTemperatures.class);\n+\n+    private DecimalType indoorTemperature;\n+    private DecimalType outdoorTemperature;\n+\n+    @Override\n+    public byte[] getRequest() {\n+        return MadokaMessage.createRequest(this);\n+    }", "originalCommit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ1NzI2MA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412457260", "bodyText": "Please make sure all of your authoring tags use your real name.", "author": "cpmeister", "createdAt": "2020-04-21T20:09:05Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetPowerstateCommand.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n+\n+import java.util.concurrent.Executor;\n+\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois", "originalCommit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ1OTk0MA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412459940", "bodyText": "After a bit of research and a change of heart, I changed my mind and feel that the readability of using ByteBuffer outweighs the performance loss. So you can use ByteBuffer as you originally did.", "author": "cpmeister", "createdAt": "2020-04-21T20:13:36Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class MadokaMessage {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(MadokaMessage.class);\n+\n+    /**\n+     * Maximum number of bytes per message chunk, including headers\n+     */\n+    public static final int MAX_CHUNK_SIZE = 20;\n+\n+    private int messageId;\n+    private Map<Integer, MadokaValue> values;\n+\n+    private byte @Nullable [] rawMessage;\n+\n+    private MadokaMessage() {\n+        values = new HashMap<>();\n+    }\n+\n+    public static byte[] createRequest(BRC1HCommand command, MadokaValue... parameters) {\n+        try {\n+            ByteArrayOutputStream output = new ByteArrayOutputStream();\n+            DataOutputStream request = new DataOutputStream(output);\n+\n+            // Message Length - Computed in the end\n+            request.writeByte(0);\n+            request.writeByte(0);\n+\n+            // Command ID, coded on 3 bytes\n+            request.writeByte(0);\n+            request.writeShort(command.getCommandId());\n+\n+            if (parameters.length == 0) {\n+                request.writeByte(0);\n+                request.writeByte(0);\n+            } else {\n+                for (MadokaValue mv : parameters) {\n+                    request.writeByte(mv.getId());\n+                    request.writeByte(mv.getSize());\n+                    request.write(mv.getRawValue());\n+                }\n+            }\n+\n+            // Finally, compute array size\n+            byte[] ret = output.toByteArray();\n+            ret[1] = (byte) (ret.length - 1);\n+\n+            return ret;\n+        } catch (IOException e) {\n+            logger.info(\"Error while building request\", e);\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static MadokaMessage parse(byte[] msg) throws MadokaParsingException {\n+        if (msg.length < 1) {\n+            throw new MadokaParsingException(\"Message received is too short to be parsed.\");\n+        }\n+        if (msg[0] != msg.length) {\n+            throw new MadokaParsingException(\"Message size is not valid (different from byte[0]).\");\n+        }\n+\n+        MadokaMessage m = new MadokaMessage();\n+        m.setRawMessage(msg);\n+        // m.messageId = ByteBuffer.wrap(msg, 2, 2).getShort();\n+        m.messageId = ((msg[0] & 0xff) << 8) | (msg[1] & 0xff);", "originalCommit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgxMDU1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412810552", "bodyText": "lol. ok.", "author": "blafois", "createdAt": "2020-04-22T09:10:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ1OTk0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ2NTEwMw==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412465103", "bodyText": "This loop seems generally unsafe since you are not checking if msg is large enough before trying to access values in it.", "author": "cpmeister", "createdAt": "2020-04-21T20:22:09Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class MadokaMessage {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(MadokaMessage.class);\n+\n+    /**\n+     * Maximum number of bytes per message chunk, including headers\n+     */\n+    public static final int MAX_CHUNK_SIZE = 20;\n+\n+    private int messageId;\n+    private Map<Integer, MadokaValue> values;\n+\n+    private byte @Nullable [] rawMessage;\n+\n+    private MadokaMessage() {\n+        values = new HashMap<>();\n+    }\n+\n+    public static byte[] createRequest(BRC1HCommand command, MadokaValue... parameters) {\n+        try {\n+            ByteArrayOutputStream output = new ByteArrayOutputStream();\n+            DataOutputStream request = new DataOutputStream(output);\n+\n+            // Message Length - Computed in the end\n+            request.writeByte(0);\n+            request.writeByte(0);\n+\n+            // Command ID, coded on 3 bytes\n+            request.writeByte(0);\n+            request.writeShort(command.getCommandId());\n+\n+            if (parameters.length == 0) {\n+                request.writeByte(0);\n+                request.writeByte(0);\n+            } else {\n+                for (MadokaValue mv : parameters) {\n+                    request.writeByte(mv.getId());\n+                    request.writeByte(mv.getSize());\n+                    request.write(mv.getRawValue());\n+                }\n+            }\n+\n+            // Finally, compute array size\n+            byte[] ret = output.toByteArray();\n+            ret[1] = (byte) (ret.length - 1);\n+\n+            return ret;\n+        } catch (IOException e) {\n+            logger.info(\"Error while building request\", e);\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static MadokaMessage parse(byte[] msg) throws MadokaParsingException {\n+        if (msg.length < 1) {\n+            throw new MadokaParsingException(\"Message received is too short to be parsed.\");\n+        }\n+        if (msg[0] != msg.length) {\n+            throw new MadokaParsingException(\"Message size is not valid (different from byte[0]).\");\n+        }\n+\n+        MadokaMessage m = new MadokaMessage();\n+        m.setRawMessage(msg);\n+        // m.messageId = ByteBuffer.wrap(msg, 2, 2).getShort();\n+        m.messageId = ((msg[0] & 0xff) << 8) | (msg[1] & 0xff);\n+\n+        MadokaValue mv = null;\n+\n+        for (int i = 4; i < msg.length;) {\n+            mv = new MadokaValue();\n+            mv.setId(msg[i]);\n+            mv.setSize(Byte.toUnsignedInt(msg[i + 1]));\n+            mv.setRawValue(Arrays.copyOfRange(msg, i + 2, i + 2 + mv.getSize()));\n+\n+            i += 2 + mv.getSize();\n+\n+            m.values.put(mv.getId(), mv);\n+        }", "originalCommit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ2ODA1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412468059", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Map<Integer, MadokaValue> values;\n          \n          \n            \n                private final Map<Integer, MadokaValue> values;", "author": "cpmeister", "createdAt": "2020-04-21T20:27:07Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class MadokaMessage {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(MadokaMessage.class);\n+\n+    /**\n+     * Maximum number of bytes per message chunk, including headers\n+     */\n+    public static final int MAX_CHUNK_SIZE = 20;\n+\n+    private int messageId;\n+    private Map<Integer, MadokaValue> values;", "originalCommit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ3NDI1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412474253", "bodyText": "Since you start at index 4, does that mean that you skip the command id of the returned message? Wouldn't that be important to know in order to make sure that a particular response corresponds to a particular request?", "author": "cpmeister", "createdAt": "2020-04-21T20:37:25Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class MadokaMessage {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(MadokaMessage.class);\n+\n+    /**\n+     * Maximum number of bytes per message chunk, including headers\n+     */\n+    public static final int MAX_CHUNK_SIZE = 20;\n+\n+    private int messageId;\n+    private Map<Integer, MadokaValue> values;\n+\n+    private byte @Nullable [] rawMessage;\n+\n+    private MadokaMessage() {\n+        values = new HashMap<>();\n+    }\n+\n+    public static byte[] createRequest(BRC1HCommand command, MadokaValue... parameters) {\n+        try {\n+            ByteArrayOutputStream output = new ByteArrayOutputStream();\n+            DataOutputStream request = new DataOutputStream(output);\n+\n+            // Message Length - Computed in the end\n+            request.writeByte(0);\n+            request.writeByte(0);\n+\n+            // Command ID, coded on 3 bytes\n+            request.writeByte(0);\n+            request.writeShort(command.getCommandId());\n+\n+            if (parameters.length == 0) {\n+                request.writeByte(0);\n+                request.writeByte(0);\n+            } else {\n+                for (MadokaValue mv : parameters) {\n+                    request.writeByte(mv.getId());\n+                    request.writeByte(mv.getSize());\n+                    request.write(mv.getRawValue());\n+                }\n+            }\n+\n+            // Finally, compute array size\n+            byte[] ret = output.toByteArray();\n+            ret[1] = (byte) (ret.length - 1);\n+\n+            return ret;\n+        } catch (IOException e) {\n+            logger.info(\"Error while building request\", e);\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static MadokaMessage parse(byte[] msg) throws MadokaParsingException {\n+        if (msg.length < 1) {\n+            throw new MadokaParsingException(\"Message received is too short to be parsed.\");\n+        }\n+        if (msg[0] != msg.length) {\n+            throw new MadokaParsingException(\"Message size is not valid (different from byte[0]).\");\n+        }\n+\n+        MadokaMessage m = new MadokaMessage();\n+        m.setRawMessage(msg);\n+        // m.messageId = ByteBuffer.wrap(msg, 2, 2).getShort();\n+        m.messageId = ((msg[0] & 0xff) << 8) | (msg[1] & 0xff);\n+\n+        MadokaValue mv = null;\n+\n+        for (int i = 4; i < msg.length;) {", "originalCommit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgyMTM3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412821372", "bodyText": "No I don't, the message ID is parsed and saved 2 lines before. At 4, only parameter values start.", "author": "blafois", "createdAt": "2020-04-22T09:26:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ3NDI1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ3NzA3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412477075", "bodyText": "Shouldn't this constant be defined and used in the BRC1HUartProcessor instead?", "author": "cpmeister", "createdAt": "2020-04-21T20:41:51Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author blafois\n+ *\n+ */\n+@NonNullByDefault\n+public class MadokaMessage {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(MadokaMessage.class);\n+\n+    /**\n+     * Maximum number of bytes per message chunk, including headers\n+     */\n+    public static final int MAX_CHUNK_SIZE = 20;", "originalCommit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ3Nzk0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412477947", "bodyText": "Do not use casting to get around the null checker. It should be sufficient to store it in a local variable then null check that.", "author": "cpmeister", "createdAt": "2020-04-21T20:43:23Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java", "diffHunk": "@@ -0,0 +1,761 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.handler;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.common.NamedThreadFactory;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDevice.ConnectionState;\n+import org.openhab.binding.bluetooth.ConnectedBluetoothHandler;\n+import org.openhab.binding.bluetooth.daikinmadoka.DaikinMadokaBindingConstants;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.BRC1HUartProcessor;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.DaikinMadokaConfiguration;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaParsingException;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.FanSpeed;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.OperationMode;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaSettings;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetIndoorOutoorTemperatures;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetSetpointCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetVersionCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetSetpointCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DaikinMadokaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Benjamin Lafois - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements ResponseListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DaikinMadokaHandler.class);\n+\n+    private @Nullable DaikinMadokaConfiguration config;\n+\n+    private @Nullable ExecutorService commandExecutor;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    // UART Processor is in charge of reassembling chunks\n+    private BRC1HUartProcessor uartProcessor = new BRC1HUartProcessor(this);\n+\n+    private volatile @Nullable BRC1HCommand currentCommand = null;\n+\n+    private MadokaSettings madokaSettings = new MadokaSettings();\n+\n+    public DaikinMadokaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"[{}] Start initializing!\", super.thing.getUID().getId());\n+\n+        // Load Configuration\n+        config = getConfigAs(DaikinMadokaConfiguration.class);\n+\n+        logger.debug(\"[{}] Parameter value [refreshInterval]: {}\", super.thing.getUID().getId(),\n+                config.refreshInterval);\n+        logger.debug(\"[{}] Parameter value [commandTimeout]: {}\", super.thing.getUID().getId(), config.commandTimeout);\n+\n+        if (getBridge() == null) {\n+            logger.debug(\"[{}] Bridge is null. Exiting.\", super.thing.getUID().getId());\n+            return;\n+        }\n+\n+        this.commandExecutor = Executors\n+                .newSingleThreadExecutor(new NamedThreadFactory(thing.getUID().getAsString(), true));\n+\n+        this.refreshJob = scheduler.scheduleWithFixedDelay(() -> {\n+            // It is useless to refresh version all the time ! Just once.\n+            if (this.madokaSettings.getCommunicationControllerVersion() == null\n+                    || this.madokaSettings.getRemoteControllerVersion() == null) {\n+                submitCommand(new GetVersionCommand());\n+            }\n+            submitCommand(new GetIndoorOutoorTemperatures());\n+            submitCommand(new GetOperationmodeCommand());\n+            submitCommand(new GetPowerstateCommand()); // always keep the \"GetPowerState\" aftern the \"GetOperationMode\"\n+            submitCommand(new GetSetpointCommand());\n+            submitCommand(new GetFanspeedCommand());\n+        }, 10, this.config.refreshInterval, TimeUnit.SECONDS);\n+\n+    }\n+\n+    @Override\n+    public void dispose() {\n+\n+        logger.debug(\"[{}] dispose()\", super.thing.getUID().getId());\n+\n+        dispose(refreshJob);\n+        dispose(commandExecutor);\n+        dispose(currentCommand);\n+\n+        // Unsubscribe to characteristic notifications\n+        if (this.device != null) {\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                @NonNull\n+                BluetoothCharacteristic c = charNotif;\n+                this.device.disableNotifications(c);\n+            }\n+        }\n+\n+        // Disconnect from the device\n+        if (this.device != null) {\n+            this.device.disconnect();\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private static void dispose(@Nullable ExecutorService executor) {\n+        if (executor != null) {\n+            executor.shutdownNow();\n+        }\n+    }\n+\n+    private static void dispose(@Nullable ScheduledFuture<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private static void dispose(@Nullable BRC1HCommand command) {\n+        if (command != null) {\n+            // even if it already completed it doesn't really matter.\n+            // on the off chance that the commandExecutor is waiting on the command, we can wake it up and cause it to\n+            // terminate\n+            command.setState(BRC1HCommand.State.FAILED);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"[{}] Channel: {}, Command: {}\", super.thing.getUID().getId(), channelUID, command);\n+\n+        if (command instanceof RefreshType) {\n+            // The refresh commands are not supported in query mode.\n+            // The binding will notify updates on channels\n+            return;\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_SETPOINT:\n+                try {\n+                    @SuppressWarnings(\"rawtypes\")\n+                    QuantityType setpoint = (QuantityType) command;\n+                    DecimalType dt = new DecimalType(setpoint.intValue());\n+                    submitCommand(new SetSetpointCommand(dt, dt));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid temperature\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_ONOFF_STATUS:\n+                try {\n+                    OnOffType oot = (OnOffType) command;\n+                    submitCommand(new SetPowerstateCommand(oot));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid on/off status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_FAN_SPEED:\n+                try {\n+                    DecimalType fanSpeed = (DecimalType) command;\n+                    FanSpeed fs = FanSpeed.valueOf(fanSpeed.intValue());\n+                    submitCommand(new SetFanspeedCommand(fs, fs));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid FanSpeed status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_OPERATION_MODE:\n+                try {\n+                    StringType operationMode = (StringType) command;\n+                    OperationMode m = OperationMode.valueOf(operationMode.toFullString());\n+\n+                    submitCommand(new SetOperationmodeCommand(m));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid OPERATION MODE\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE:\n+                try {\n+                    StringType homekitOperationMode = (StringType) command;\n+\n+                    switch (homekitOperationMode.toString()) {\n+                        case \"Off\":\n+                            submitCommand(new SetPowerstateCommand(OnOffType.OFF));\n+                            break;\n+                        case \"CoolOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.COOL));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"HeatOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.HEAT));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"Auto\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.AUTO));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+\n+                } catch (Exception e) {\n+                    logger.info(\"Error while setting mode through HomeKIt received Mode\");\n+                }\n+            default:\n+                break;\n+\n+        }\n+\n+    }\n+\n+    @Override\n+    public void onCharacteristicUpdate(BluetoothCharacteristic characteristic) {\n+        super.onCharacteristicUpdate(characteristic);\n+\n+        // Check that arguments are valid.\n+        if (characteristic.getUuid() == null) {\n+            return;\n+        }\n+\n+        // We are only interested in the Notify Characteristic of UART service\n+        if (!characteristic.getUuid().equals(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID)) {\n+            return;\n+        }\n+\n+        // A message cannot be null or have a 0-byte length\n+        if (characteristic.getByteValue() == null || characteristic.getByteValue().length == 0) {\n+            return;\n+        }\n+\n+        this.uartProcessor.chunkReceived(characteristic.getByteValue());\n+\n+    }\n+\n+    private void submitCommand(BRC1HCommand command) {\n+        Executor executor = commandExecutor;\n+\n+        if (executor != null) {\n+            executor.execute(() -> processCommand(command));\n+        }\n+    }\n+\n+    private void processCommand(BRC1HCommand command) {\n+        logger.debug(\"[{}] ProcessCommand {}\", super.thing.getUID().getId(), command.getClass().getSimpleName());\n+\n+        try {\n+            currentCommand = command;\n+            uartProcessor.abandon();\n+\n+            if (command.getRequest() == null) {\n+                logger.debug(\"Unable to send command {} to device {}: Request NULL.\",\n+                        command.getClass().getSimpleName(), device.getAddress());\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            if (device == null || device.getConnectionState() != ConnectionState.CONNECTED) {\n+                logger.debug(\"Unable to send command {} to device {}: not connected\",\n+                        command.getClass().getSimpleName(), address);\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            if (!resolved) {\n+                logger.debug(\"Unable to send command {} to device {}: services not resolved\",\n+                        command.getClass().getSimpleName(), device.getAddress());\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            BluetoothCharacteristic charWrite = device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_WRITE_WITHOUT_RESPONSE_UUID);\n+            if (charWrite == null) {\n+                logger.warn(\"Unable to execute {}. Characteristic '{}' could not be found.\",\n+                        command.getClass().getSimpleName(),\n+                        DaikinMadokaBindingConstants.CHAR_WRITE_WITHOUT_RESPONSE_UUID);\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                @NonNull\n+                BluetoothCharacteristic c = charNotif;\n+                device.enableNotifications(c);\n+            }\n+\n+            charWrite.setValue(command.getRequest());\n+            command.setState(BRC1HCommand.State.ENQUEUED);\n+            device.writeCharacteristic(charWrite);\n+\n+            if (!command.awaitStateChange(this.config.commandTimeout, TimeUnit.MILLISECONDS,\n+                    BRC1HCommand.State.SUCCEEDED, BRC1HCommand.State.FAILED)) {\n+                logger.debug(\"Command {} to device {} timed out\", command, device.getAddress());\n+                command.setState(BRC1HCommand.State.FAILED);\n+            }\n+\n+        } catch (Exception e) {\n+            logger.debug(\"Error\", e);\n+        } finally {\n+            logger.debug(\"Command final state: {}\", command.getState());\n+            currentCommand = null;\n+        }\n+\n+        try {\n+            Thread.sleep(200);\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+        }\n+    }\n+\n+    @Override\n+    public void onCharacteristicWriteComplete(BluetoothCharacteristic characteristic,\n+            BluetoothCompletionStatus status) {\n+\n+        super.onCharacteristicWriteComplete(characteristic, status);\n+\n+        byte[] request = characteristic.getByteValue();\n+\n+        BRC1HCommand command = currentCommand;\n+\n+        if (command != null) {\n+            if (!Arrays.equals(request, command.getRequest())) {\n+                logger.debug(\"Write completed for unknown command\");\n+                return;\n+            }\n+            switch (status) {\n+                case SUCCESS:\n+                    command.setState(BRC1HCommand.State.SENT);\n+                    break;\n+                case ERROR:\n+                    command.setState(BRC1HCommand.State.FAILED);\n+                    break;\n+            }\n+        } else {\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"No command found that matches request {}\", HexUtils.bytesToHex(request));\n+            }\n+        }\n+\n+    }\n+\n+    /**\n+     * When the method is triggered, it means that all message chunks have been received, re-assembled in the right\n+     * order and that the payload is ready to be processed.\n+     */\n+    @Override\n+    public void receivedResponse(byte[] response) {\n+        logger.debug(\"Received Response\");\n+        BRC1HCommand command = currentCommand;\n+\n+        if (command == null) {\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"No command present to handle response {}\", HexUtils.bytesToHex(response));\n+            }\n+        } else {\n+            try {\n+                if ((!command.handleResponse(scheduler, this, MadokaMessage.parse(response)))) {\n+                    logger.debug(\"Command {} could not handle response {}\", command.getClass().getSimpleName(),\n+                            HexUtils.bytesToHex(response));\n+                }\n+            } catch (MadokaParsingException e) {\n+                logger.debug(\"Response message could not be parsed correctly ({}): {}\",\n+                        command.getClass().getSimpleName(), HexUtils.bytesToHex(response));\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetVersionCommand command) {\n+        this.madokaSettings.setCommunicationControllerVersion(command.getCommunicationControllerVersion());\n+        this.madokaSettings.setRemoteControllerVersion(command.getRemoteControllerVersion());\n+\n+        updateStateIfLinked(\n+                new ChannelUID(getThing().getUID(),\n+                        DaikinMadokaBindingConstants.CHANNEL_ID_COMMUNICATION_CONTROLLER_VERSION),\n+                new StringType(command.getCommunicationControllerVersion()));\n+\n+        updateStateIfLinked(\n+                new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_REMOTE_CONTROLLER_VERSION),\n+                new StringType(command.getRemoteControllerVersion()));\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetFanspeedCommand command) {\n+\n+        if (command.getCoolingFanSpeed() == null || command.getHeatingFanSpeed() == null) {\n+            return;\n+        }\n+\n+        // We need the current operation mode to determine which Fan Speed we use (cooling or heating)\n+        if (this.madokaSettings.getOperationMode() == null) {\n+            return;\n+        }\n+\n+        FanSpeed fs = null;\n+\n+        switch (this.madokaSettings.getOperationMode()) {\n+            case AUTO:\n+                // TODO confirm it works in all conditions\n+                logger.debug(\"In AutoMode, CoolingFanSpeed = {}, HeatingFanSpeed = {}\", command.getCoolingFanSpeed(),\n+                        command.getHeatingFanSpeed());\n+                fs = command.getHeatingFanSpeed();\n+                break;\n+            case HEAT:\n+                fs = command.getHeatingFanSpeed();\n+                break;\n+            case COOL:\n+                fs = command.getCoolingFanSpeed();\n+                break;\n+            default:\n+                return;\n+        }\n+\n+        // No need to re-set if it is the same value\n+        if (fs.equals(this.madokaSettings.getFanspeed())) {\n+            return;\n+        }\n+\n+        this.madokaSettings.setFanspeed(fs);\n+        updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_FAN_SPEED),\n+                new DecimalType(fs.value()));\n+\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetSetpointCommand command) {\n+        if (command.getCoolingSetpoint() == null || command.getHeatingSetpoint() == null) {\n+            return;\n+        }\n+\n+        // We need the current operation mode to determine which Fan Speed we use (cooling or heating)\n+        if (this.madokaSettings.getOperationMode() == null) {\n+            return;\n+        }\n+\n+        DecimalType sp = null;\n+\n+        switch (this.madokaSettings.getOperationMode()) {\n+            case AUTO:\n+                // TODO confirm it works in all conditions\n+                logger.debug(\"In AutoMode, CoolingSetpoint = {}, HeatingSetpoint = {}\", command.getCoolingSetpoint(),\n+                        command.getHeatingSetpoint());\n+                sp = command.getHeatingSetpoint();\n+                break;\n+            case HEAT:\n+                sp = command.getHeatingSetpoint();\n+                break;\n+            case COOL:\n+                sp = command.getCoolingSetpoint();\n+                break;\n+            default:\n+                return;\n+        }\n+\n+        // No need to re-set if it is the same value\n+        if (sp.equals(this.madokaSettings.getSetpoint())) {\n+            return;\n+        }\n+\n+        this.madokaSettings.setSetpoint(sp);\n+        if (this.madokaSettings.getSetpoint() != null) {\n+            @NonNull\n+            DecimalType dt = (@NonNull DecimalType) this.madokaSettings.getSetpoint();\n+            updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_SETPOINT),\n+                    dt);\n+        }\n+\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetOperationmodeCommand command) {\n+        if (command.getOperationMode() == null) {\n+            return;\n+        }\n+\n+        // If the mode has not changed - no need to refresh everything\n+        if (command.getOperationMode().equals(this.madokaSettings.getOperationMode())) {\n+            return;\n+        }\n+\n+        this.madokaSettings.setOperationMode(command.getOperationMode());\n+\n+        updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_OPERATION_MODE),\n+                new StringType(command.getOperationMode().name()));\n+\n+        // For HomeKit channel, we need to map it to HomeKit supported strings\n+        switch (command.getOperationMode()) {\n+            case COOL:\n+                updateStateIfLinked(\n+                        new ChannelUID(getThing().getUID(),\n+                                DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                        new StringType(\"Cooling\"));\n+                break;\n+            case HEAT:\n+                updateStateIfLinked(\n+                        new ChannelUID(getThing().getUID(),\n+                                DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                        new StringType(\"Heating\"));\n+                break;\n+            default:\n+                break;\n+        }\n+\n+        // If this is the first channel update - then we set target = current mode\n+        if (this.madokaSettings.getHomekitTargetMode() == null) {\n+            String newHomekitTargetStatus = null;\n+\n+            // For HomeKit channel, we need to map it to HomeKit supported strings\n+            switch (command.getOperationMode()) {\n+                case COOL:\n+                    newHomekitTargetStatus = \"CoolOn\";\n+                    break;\n+                case HEAT:\n+                    newHomekitTargetStatus = \"HeatOn\";\n+                    break;\n+                default:\n+                    return;\n+            }\n+            this.madokaSettings.setHomekitTargetMode(newHomekitTargetStatus);\n+\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(),\n+                            DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE),\n+                    new StringType(newHomekitTargetStatus));\n+        }\n+\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetPowerstateCommand command) {\n+        if (command.isPowerState() == null) {\n+            return;\n+        }\n+\n+        OnOffType oot = command.isPowerState() ? OnOffType.ON : OnOffType.OFF;\n+\n+        if (oot.equals(this.madokaSettings.getOnOffState())) {\n+            return;\n+        }\n+\n+        this.madokaSettings.setOnOffState(oot);\n+\n+        updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_ONOFF_STATUS),\n+                oot);\n+\n+        if (oot.equals(OnOffType.OFF)) {\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(),\n+                            DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                    new StringType(\"Off\"));\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(),\n+                            DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE),\n+                    new StringType(\"Off\"));\n+        }\n+\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetIndoorOutoorTemperatures command) {\n+\n+        if (command.getIndoorTemperature() != null\n+                && (!command.getIndoorTemperature().equals(this.madokaSettings.getIndoorTemperature()))) {\n+            this.madokaSettings.setIndoorTemperature(command.getIndoorTemperature());\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_INDOOR_TEMPERATURE),\n+                    command.getIndoorTemperature());\n+        }\n+\n+        if (command.getOutdoorTemperature() == null) {\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_OUTDOOR_TEMPERATURE),\n+                    UnDefType.UNDEF);\n+        } else if (!command.getOutdoorTemperature().equals(this.madokaSettings.getOutdoorTemperature())) {\n+            this.madokaSettings.setOutdoorTemperature(command.getOutdoorTemperature());\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_OUTDOOR_TEMPERATURE),\n+                    command.getOutdoorTemperature());\n+        }\n+\n+    }\n+\n+    @Override\n+    public void receivedResponse(SetPowerstateCommand command) {\n+\n+        updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_ONOFF_STATUS),\n+                command.getPowerState());\n+\n+        madokaSettings.setOnOffState(command.getPowerState());\n+\n+        if (command.getPowerState() == OnOffType.ON) {\n+            // Depending on the state\n+            if (madokaSettings.getOperationMode() == null) {\n+                return;\n+            }\n+\n+            switch (madokaSettings.getOperationMode()) {\n+                case AUTO:\n+                    updateStateIfLinked(\n+                            new ChannelUID(getThing().getUID(),\n+                                    DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                            new StringType(\"Auto\"));\n+                    break;\n+                case HEAT:\n+                    updateStateIfLinked(\n+                            new ChannelUID(getThing().getUID(),\n+                                    DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                            new StringType(\"Heating\"));\n+                    break;\n+                case COOL:\n+                    updateStateIfLinked(\n+                            new ChannelUID(getThing().getUID(),\n+                                    DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                            new StringType(\"Cooling\"));\n+                    break;\n+                default: // Other Modes are not [yet] supported\n+                    break;\n+            }\n+        } else {\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(),\n+                            DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                    new StringType(\"Off\"));\n+\n+        }\n+    }\n+\n+    @Override\n+    public void receivedResponse(SetSetpointCommand command) {\n+\n+        // The update depends on the mode - so if not set - skip\n+        if (this.madokaSettings.getOperationMode() == null) {\n+            return;\n+        }\n+\n+        switch (this.madokaSettings.getOperationMode()) {\n+            case HEAT:\n+                this.madokaSettings.setSetpoint(command.getHeatingSetpoint());\n+                break;\n+            case COOL:\n+                this.madokaSettings.setSetpoint(command.getCoolingSetpoint());\n+                break;\n+            case AUTO:\n+                // TODO\n+                break;\n+            default:\n+                return;\n+        }\n+\n+        if (madokaSettings.getSetpoint() != null) {\n+            @NonNull\n+            DecimalType dt = (@NonNull DecimalType) madokaSettings.getSetpoint();", "originalCommit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ3ODQ1NA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412478454", "bodyText": "can you implement this?", "author": "cpmeister", "createdAt": "2020-04-21T20:44:14Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java", "diffHunk": "@@ -0,0 +1,761 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.handler;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.common.NamedThreadFactory;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDevice.ConnectionState;\n+import org.openhab.binding.bluetooth.ConnectedBluetoothHandler;\n+import org.openhab.binding.bluetooth.daikinmadoka.DaikinMadokaBindingConstants;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.BRC1HUartProcessor;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.DaikinMadokaConfiguration;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaParsingException;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.FanSpeed;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.OperationMode;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaSettings;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetIndoorOutoorTemperatures;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetSetpointCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetVersionCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetSetpointCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DaikinMadokaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Benjamin Lafois - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements ResponseListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DaikinMadokaHandler.class);\n+\n+    private @Nullable DaikinMadokaConfiguration config;\n+\n+    private @Nullable ExecutorService commandExecutor;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    // UART Processor is in charge of reassembling chunks\n+    private BRC1HUartProcessor uartProcessor = new BRC1HUartProcessor(this);\n+\n+    private volatile @Nullable BRC1HCommand currentCommand = null;\n+\n+    private MadokaSettings madokaSettings = new MadokaSettings();\n+\n+    public DaikinMadokaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"[{}] Start initializing!\", super.thing.getUID().getId());\n+\n+        // Load Configuration\n+        config = getConfigAs(DaikinMadokaConfiguration.class);\n+\n+        logger.debug(\"[{}] Parameter value [refreshInterval]: {}\", super.thing.getUID().getId(),\n+                config.refreshInterval);\n+        logger.debug(\"[{}] Parameter value [commandTimeout]: {}\", super.thing.getUID().getId(), config.commandTimeout);\n+\n+        if (getBridge() == null) {\n+            logger.debug(\"[{}] Bridge is null. Exiting.\", super.thing.getUID().getId());\n+            return;\n+        }\n+\n+        this.commandExecutor = Executors\n+                .newSingleThreadExecutor(new NamedThreadFactory(thing.getUID().getAsString(), true));\n+\n+        this.refreshJob = scheduler.scheduleWithFixedDelay(() -> {\n+            // It is useless to refresh version all the time ! Just once.\n+            if (this.madokaSettings.getCommunicationControllerVersion() == null\n+                    || this.madokaSettings.getRemoteControllerVersion() == null) {\n+                submitCommand(new GetVersionCommand());\n+            }\n+            submitCommand(new GetIndoorOutoorTemperatures());\n+            submitCommand(new GetOperationmodeCommand());\n+            submitCommand(new GetPowerstateCommand()); // always keep the \"GetPowerState\" aftern the \"GetOperationMode\"\n+            submitCommand(new GetSetpointCommand());\n+            submitCommand(new GetFanspeedCommand());\n+        }, 10, this.config.refreshInterval, TimeUnit.SECONDS);\n+\n+    }\n+\n+    @Override\n+    public void dispose() {\n+\n+        logger.debug(\"[{}] dispose()\", super.thing.getUID().getId());\n+\n+        dispose(refreshJob);\n+        dispose(commandExecutor);\n+        dispose(currentCommand);\n+\n+        // Unsubscribe to characteristic notifications\n+        if (this.device != null) {\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                @NonNull\n+                BluetoothCharacteristic c = charNotif;\n+                this.device.disableNotifications(c);\n+            }\n+        }\n+\n+        // Disconnect from the device\n+        if (this.device != null) {\n+            this.device.disconnect();\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private static void dispose(@Nullable ExecutorService executor) {\n+        if (executor != null) {\n+            executor.shutdownNow();\n+        }\n+    }\n+\n+    private static void dispose(@Nullable ScheduledFuture<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private static void dispose(@Nullable BRC1HCommand command) {\n+        if (command != null) {\n+            // even if it already completed it doesn't really matter.\n+            // on the off chance that the commandExecutor is waiting on the command, we can wake it up and cause it to\n+            // terminate\n+            command.setState(BRC1HCommand.State.FAILED);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"[{}] Channel: {}, Command: {}\", super.thing.getUID().getId(), channelUID, command);\n+\n+        if (command instanceof RefreshType) {\n+            // The refresh commands are not supported in query mode.\n+            // The binding will notify updates on channels\n+            return;\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_SETPOINT:\n+                try {\n+                    @SuppressWarnings(\"rawtypes\")\n+                    QuantityType setpoint = (QuantityType) command;\n+                    DecimalType dt = new DecimalType(setpoint.intValue());\n+                    submitCommand(new SetSetpointCommand(dt, dt));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid temperature\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_ONOFF_STATUS:\n+                try {\n+                    OnOffType oot = (OnOffType) command;\n+                    submitCommand(new SetPowerstateCommand(oot));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid on/off status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_FAN_SPEED:\n+                try {\n+                    DecimalType fanSpeed = (DecimalType) command;\n+                    FanSpeed fs = FanSpeed.valueOf(fanSpeed.intValue());\n+                    submitCommand(new SetFanspeedCommand(fs, fs));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid FanSpeed status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_OPERATION_MODE:\n+                try {\n+                    StringType operationMode = (StringType) command;\n+                    OperationMode m = OperationMode.valueOf(operationMode.toFullString());\n+\n+                    submitCommand(new SetOperationmodeCommand(m));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid OPERATION MODE\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE:\n+                try {\n+                    StringType homekitOperationMode = (StringType) command;\n+\n+                    switch (homekitOperationMode.toString()) {\n+                        case \"Off\":\n+                            submitCommand(new SetPowerstateCommand(OnOffType.OFF));\n+                            break;\n+                        case \"CoolOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.COOL));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"HeatOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.HEAT));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"Auto\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.AUTO));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+\n+                } catch (Exception e) {\n+                    logger.info(\"Error while setting mode through HomeKIt received Mode\");\n+                }\n+            default:\n+                break;\n+\n+        }\n+\n+    }\n+\n+    @Override\n+    public void onCharacteristicUpdate(BluetoothCharacteristic characteristic) {\n+        super.onCharacteristicUpdate(characteristic);\n+\n+        // Check that arguments are valid.\n+        if (characteristic.getUuid() == null) {\n+            return;\n+        }\n+\n+        // We are only interested in the Notify Characteristic of UART service\n+        if (!characteristic.getUuid().equals(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID)) {\n+            return;\n+        }\n+\n+        // A message cannot be null or have a 0-byte length\n+        if (characteristic.getByteValue() == null || characteristic.getByteValue().length == 0) {\n+            return;\n+        }\n+\n+        this.uartProcessor.chunkReceived(characteristic.getByteValue());\n+\n+    }\n+\n+    private void submitCommand(BRC1HCommand command) {\n+        Executor executor = commandExecutor;\n+\n+        if (executor != null) {\n+            executor.execute(() -> processCommand(command));\n+        }\n+    }\n+\n+    private void processCommand(BRC1HCommand command) {\n+        logger.debug(\"[{}] ProcessCommand {}\", super.thing.getUID().getId(), command.getClass().getSimpleName());\n+\n+        try {\n+            currentCommand = command;\n+            uartProcessor.abandon();\n+\n+            if (command.getRequest() == null) {\n+                logger.debug(\"Unable to send command {} to device {}: Request NULL.\",\n+                        command.getClass().getSimpleName(), device.getAddress());\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            if (device == null || device.getConnectionState() != ConnectionState.CONNECTED) {\n+                logger.debug(\"Unable to send command {} to device {}: not connected\",\n+                        command.getClass().getSimpleName(), address);\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            if (!resolved) {\n+                logger.debug(\"Unable to send command {} to device {}: services not resolved\",\n+                        command.getClass().getSimpleName(), device.getAddress());\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            BluetoothCharacteristic charWrite = device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_WRITE_WITHOUT_RESPONSE_UUID);\n+            if (charWrite == null) {\n+                logger.warn(\"Unable to execute {}. Characteristic '{}' could not be found.\",\n+                        command.getClass().getSimpleName(),\n+                        DaikinMadokaBindingConstants.CHAR_WRITE_WITHOUT_RESPONSE_UUID);\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                @NonNull\n+                BluetoothCharacteristic c = charNotif;\n+                device.enableNotifications(c);\n+            }\n+\n+            charWrite.setValue(command.getRequest());\n+            command.setState(BRC1HCommand.State.ENQUEUED);\n+            device.writeCharacteristic(charWrite);\n+\n+            if (!command.awaitStateChange(this.config.commandTimeout, TimeUnit.MILLISECONDS,\n+                    BRC1HCommand.State.SUCCEEDED, BRC1HCommand.State.FAILED)) {\n+                logger.debug(\"Command {} to device {} timed out\", command, device.getAddress());\n+                command.setState(BRC1HCommand.State.FAILED);\n+            }\n+\n+        } catch (Exception e) {\n+            logger.debug(\"Error\", e);\n+        } finally {\n+            logger.debug(\"Command final state: {}\", command.getState());\n+            currentCommand = null;\n+        }\n+\n+        try {\n+            Thread.sleep(200);\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+        }\n+    }\n+\n+    @Override\n+    public void onCharacteristicWriteComplete(BluetoothCharacteristic characteristic,\n+            BluetoothCompletionStatus status) {\n+\n+        super.onCharacteristicWriteComplete(characteristic, status);\n+\n+        byte[] request = characteristic.getByteValue();\n+\n+        BRC1HCommand command = currentCommand;\n+\n+        if (command != null) {\n+            if (!Arrays.equals(request, command.getRequest())) {\n+                logger.debug(\"Write completed for unknown command\");\n+                return;\n+            }\n+            switch (status) {\n+                case SUCCESS:\n+                    command.setState(BRC1HCommand.State.SENT);\n+                    break;\n+                case ERROR:\n+                    command.setState(BRC1HCommand.State.FAILED);\n+                    break;\n+            }\n+        } else {\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"No command found that matches request {}\", HexUtils.bytesToHex(request));\n+            }\n+        }\n+\n+    }\n+\n+    /**\n+     * When the method is triggered, it means that all message chunks have been received, re-assembled in the right\n+     * order and that the payload is ready to be processed.\n+     */\n+    @Override\n+    public void receivedResponse(byte[] response) {\n+        logger.debug(\"Received Response\");\n+        BRC1HCommand command = currentCommand;\n+\n+        if (command == null) {\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"No command present to handle response {}\", HexUtils.bytesToHex(response));\n+            }\n+        } else {\n+            try {\n+                if ((!command.handleResponse(scheduler, this, MadokaMessage.parse(response)))) {\n+                    logger.debug(\"Command {} could not handle response {}\", command.getClass().getSimpleName(),\n+                            HexUtils.bytesToHex(response));\n+                }\n+            } catch (MadokaParsingException e) {\n+                logger.debug(\"Response message could not be parsed correctly ({}): {}\",\n+                        command.getClass().getSimpleName(), HexUtils.bytesToHex(response));\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetVersionCommand command) {\n+        this.madokaSettings.setCommunicationControllerVersion(command.getCommunicationControllerVersion());\n+        this.madokaSettings.setRemoteControllerVersion(command.getRemoteControllerVersion());\n+\n+        updateStateIfLinked(\n+                new ChannelUID(getThing().getUID(),\n+                        DaikinMadokaBindingConstants.CHANNEL_ID_COMMUNICATION_CONTROLLER_VERSION),\n+                new StringType(command.getCommunicationControllerVersion()));\n+\n+        updateStateIfLinked(\n+                new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_REMOTE_CONTROLLER_VERSION),\n+                new StringType(command.getRemoteControllerVersion()));\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetFanspeedCommand command) {\n+\n+        if (command.getCoolingFanSpeed() == null || command.getHeatingFanSpeed() == null) {\n+            return;\n+        }\n+\n+        // We need the current operation mode to determine which Fan Speed we use (cooling or heating)\n+        if (this.madokaSettings.getOperationMode() == null) {\n+            return;\n+        }\n+\n+        FanSpeed fs = null;\n+\n+        switch (this.madokaSettings.getOperationMode()) {\n+            case AUTO:\n+                // TODO confirm it works in all conditions\n+                logger.debug(\"In AutoMode, CoolingFanSpeed = {}, HeatingFanSpeed = {}\", command.getCoolingFanSpeed(),\n+                        command.getHeatingFanSpeed());\n+                fs = command.getHeatingFanSpeed();\n+                break;\n+            case HEAT:\n+                fs = command.getHeatingFanSpeed();\n+                break;\n+            case COOL:\n+                fs = command.getCoolingFanSpeed();\n+                break;\n+            default:\n+                return;\n+        }\n+\n+        // No need to re-set if it is the same value\n+        if (fs.equals(this.madokaSettings.getFanspeed())) {\n+            return;\n+        }\n+\n+        this.madokaSettings.setFanspeed(fs);\n+        updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_FAN_SPEED),\n+                new DecimalType(fs.value()));\n+\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetSetpointCommand command) {\n+        if (command.getCoolingSetpoint() == null || command.getHeatingSetpoint() == null) {\n+            return;\n+        }\n+\n+        // We need the current operation mode to determine which Fan Speed we use (cooling or heating)\n+        if (this.madokaSettings.getOperationMode() == null) {\n+            return;\n+        }\n+\n+        DecimalType sp = null;\n+\n+        switch (this.madokaSettings.getOperationMode()) {\n+            case AUTO:\n+                // TODO confirm it works in all conditions\n+                logger.debug(\"In AutoMode, CoolingSetpoint = {}, HeatingSetpoint = {}\", command.getCoolingSetpoint(),\n+                        command.getHeatingSetpoint());\n+                sp = command.getHeatingSetpoint();\n+                break;\n+            case HEAT:\n+                sp = command.getHeatingSetpoint();\n+                break;\n+            case COOL:\n+                sp = command.getCoolingSetpoint();\n+                break;\n+            default:\n+                return;\n+        }\n+\n+        // No need to re-set if it is the same value\n+        if (sp.equals(this.madokaSettings.getSetpoint())) {\n+            return;\n+        }\n+\n+        this.madokaSettings.setSetpoint(sp);\n+        if (this.madokaSettings.getSetpoint() != null) {\n+            @NonNull\n+            DecimalType dt = (@NonNull DecimalType) this.madokaSettings.getSetpoint();\n+            updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_SETPOINT),\n+                    dt);\n+        }\n+\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetOperationmodeCommand command) {\n+        if (command.getOperationMode() == null) {\n+            return;\n+        }\n+\n+        // If the mode has not changed - no need to refresh everything\n+        if (command.getOperationMode().equals(this.madokaSettings.getOperationMode())) {\n+            return;\n+        }\n+\n+        this.madokaSettings.setOperationMode(command.getOperationMode());\n+\n+        updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_OPERATION_MODE),\n+                new StringType(command.getOperationMode().name()));\n+\n+        // For HomeKit channel, we need to map it to HomeKit supported strings\n+        switch (command.getOperationMode()) {\n+            case COOL:\n+                updateStateIfLinked(\n+                        new ChannelUID(getThing().getUID(),\n+                                DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                        new StringType(\"Cooling\"));\n+                break;\n+            case HEAT:\n+                updateStateIfLinked(\n+                        new ChannelUID(getThing().getUID(),\n+                                DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                        new StringType(\"Heating\"));\n+                break;\n+            default:\n+                break;\n+        }\n+\n+        // If this is the first channel update - then we set target = current mode\n+        if (this.madokaSettings.getHomekitTargetMode() == null) {\n+            String newHomekitTargetStatus = null;\n+\n+            // For HomeKit channel, we need to map it to HomeKit supported strings\n+            switch (command.getOperationMode()) {\n+                case COOL:\n+                    newHomekitTargetStatus = \"CoolOn\";\n+                    break;\n+                case HEAT:\n+                    newHomekitTargetStatus = \"HeatOn\";\n+                    break;\n+                default:\n+                    return;\n+            }\n+            this.madokaSettings.setHomekitTargetMode(newHomekitTargetStatus);\n+\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(),\n+                            DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE),\n+                    new StringType(newHomekitTargetStatus));\n+        }\n+\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetPowerstateCommand command) {\n+        if (command.isPowerState() == null) {\n+            return;\n+        }\n+\n+        OnOffType oot = command.isPowerState() ? OnOffType.ON : OnOffType.OFF;\n+\n+        if (oot.equals(this.madokaSettings.getOnOffState())) {\n+            return;\n+        }\n+\n+        this.madokaSettings.setOnOffState(oot);\n+\n+        updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_ONOFF_STATUS),\n+                oot);\n+\n+        if (oot.equals(OnOffType.OFF)) {\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(),\n+                            DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                    new StringType(\"Off\"));\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(),\n+                            DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE),\n+                    new StringType(\"Off\"));\n+        }\n+\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetIndoorOutoorTemperatures command) {\n+\n+        if (command.getIndoorTemperature() != null\n+                && (!command.getIndoorTemperature().equals(this.madokaSettings.getIndoorTemperature()))) {\n+            this.madokaSettings.setIndoorTemperature(command.getIndoorTemperature());\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_INDOOR_TEMPERATURE),\n+                    command.getIndoorTemperature());\n+        }\n+\n+        if (command.getOutdoorTemperature() == null) {\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_OUTDOOR_TEMPERATURE),\n+                    UnDefType.UNDEF);\n+        } else if (!command.getOutdoorTemperature().equals(this.madokaSettings.getOutdoorTemperature())) {\n+            this.madokaSettings.setOutdoorTemperature(command.getOutdoorTemperature());\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_OUTDOOR_TEMPERATURE),\n+                    command.getOutdoorTemperature());\n+        }\n+\n+    }\n+\n+    @Override\n+    public void receivedResponse(SetPowerstateCommand command) {\n+\n+        updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_ONOFF_STATUS),\n+                command.getPowerState());\n+\n+        madokaSettings.setOnOffState(command.getPowerState());\n+\n+        if (command.getPowerState() == OnOffType.ON) {\n+            // Depending on the state\n+            if (madokaSettings.getOperationMode() == null) {\n+                return;\n+            }\n+\n+            switch (madokaSettings.getOperationMode()) {\n+                case AUTO:\n+                    updateStateIfLinked(\n+                            new ChannelUID(getThing().getUID(),\n+                                    DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                            new StringType(\"Auto\"));\n+                    break;\n+                case HEAT:\n+                    updateStateIfLinked(\n+                            new ChannelUID(getThing().getUID(),\n+                                    DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                            new StringType(\"Heating\"));\n+                    break;\n+                case COOL:\n+                    updateStateIfLinked(\n+                            new ChannelUID(getThing().getUID(),\n+                                    DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                            new StringType(\"Cooling\"));\n+                    break;\n+                default: // Other Modes are not [yet] supported\n+                    break;\n+            }\n+        } else {\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(),\n+                            DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                    new StringType(\"Off\"));\n+\n+        }\n+    }\n+\n+    @Override\n+    public void receivedResponse(SetSetpointCommand command) {\n+\n+        // The update depends on the mode - so if not set - skip\n+        if (this.madokaSettings.getOperationMode() == null) {\n+            return;\n+        }\n+\n+        switch (this.madokaSettings.getOperationMode()) {\n+            case HEAT:\n+                this.madokaSettings.setSetpoint(command.getHeatingSetpoint());\n+                break;\n+            case COOL:\n+                this.madokaSettings.setSetpoint(command.getCoolingSetpoint());\n+                break;\n+            case AUTO:\n+                // TODO", "originalCommit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ4MDU4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412480582", "bodyText": "What is wrong with doing this?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            @NonNull\n          \n          \n            \n                            BluetoothCharacteristic c = charNotif;\n          \n          \n            \n                            device.enableNotifications(c);\n          \n          \n            \n                            device.enableNotifications(charNotif);", "author": "cpmeister", "createdAt": "2020-04-21T20:47:54Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java", "diffHunk": "@@ -0,0 +1,761 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.handler;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.common.NamedThreadFactory;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDevice.ConnectionState;\n+import org.openhab.binding.bluetooth.ConnectedBluetoothHandler;\n+import org.openhab.binding.bluetooth.daikinmadoka.DaikinMadokaBindingConstants;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.BRC1HUartProcessor;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.DaikinMadokaConfiguration;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaParsingException;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.FanSpeed;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.OperationMode;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaSettings;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetIndoorOutoorTemperatures;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetSetpointCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetVersionCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetSetpointCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DaikinMadokaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Benjamin Lafois - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements ResponseListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DaikinMadokaHandler.class);\n+\n+    private @Nullable DaikinMadokaConfiguration config;\n+\n+    private @Nullable ExecutorService commandExecutor;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    // UART Processor is in charge of reassembling chunks\n+    private BRC1HUartProcessor uartProcessor = new BRC1HUartProcessor(this);\n+\n+    private volatile @Nullable BRC1HCommand currentCommand = null;\n+\n+    private MadokaSettings madokaSettings = new MadokaSettings();\n+\n+    public DaikinMadokaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"[{}] Start initializing!\", super.thing.getUID().getId());\n+\n+        // Load Configuration\n+        config = getConfigAs(DaikinMadokaConfiguration.class);\n+\n+        logger.debug(\"[{}] Parameter value [refreshInterval]: {}\", super.thing.getUID().getId(),\n+                config.refreshInterval);\n+        logger.debug(\"[{}] Parameter value [commandTimeout]: {}\", super.thing.getUID().getId(), config.commandTimeout);\n+\n+        if (getBridge() == null) {\n+            logger.debug(\"[{}] Bridge is null. Exiting.\", super.thing.getUID().getId());\n+            return;\n+        }\n+\n+        this.commandExecutor = Executors\n+                .newSingleThreadExecutor(new NamedThreadFactory(thing.getUID().getAsString(), true));\n+\n+        this.refreshJob = scheduler.scheduleWithFixedDelay(() -> {\n+            // It is useless to refresh version all the time ! Just once.\n+            if (this.madokaSettings.getCommunicationControllerVersion() == null\n+                    || this.madokaSettings.getRemoteControllerVersion() == null) {\n+                submitCommand(new GetVersionCommand());\n+            }\n+            submitCommand(new GetIndoorOutoorTemperatures());\n+            submitCommand(new GetOperationmodeCommand());\n+            submitCommand(new GetPowerstateCommand()); // always keep the \"GetPowerState\" aftern the \"GetOperationMode\"\n+            submitCommand(new GetSetpointCommand());\n+            submitCommand(new GetFanspeedCommand());\n+        }, 10, this.config.refreshInterval, TimeUnit.SECONDS);\n+\n+    }\n+\n+    @Override\n+    public void dispose() {\n+\n+        logger.debug(\"[{}] dispose()\", super.thing.getUID().getId());\n+\n+        dispose(refreshJob);\n+        dispose(commandExecutor);\n+        dispose(currentCommand);\n+\n+        // Unsubscribe to characteristic notifications\n+        if (this.device != null) {\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                @NonNull\n+                BluetoothCharacteristic c = charNotif;\n+                this.device.disableNotifications(c);\n+            }\n+        }\n+\n+        // Disconnect from the device\n+        if (this.device != null) {\n+            this.device.disconnect();\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private static void dispose(@Nullable ExecutorService executor) {\n+        if (executor != null) {\n+            executor.shutdownNow();\n+        }\n+    }\n+\n+    private static void dispose(@Nullable ScheduledFuture<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private static void dispose(@Nullable BRC1HCommand command) {\n+        if (command != null) {\n+            // even if it already completed it doesn't really matter.\n+            // on the off chance that the commandExecutor is waiting on the command, we can wake it up and cause it to\n+            // terminate\n+            command.setState(BRC1HCommand.State.FAILED);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"[{}] Channel: {}, Command: {}\", super.thing.getUID().getId(), channelUID, command);\n+\n+        if (command instanceof RefreshType) {\n+            // The refresh commands are not supported in query mode.\n+            // The binding will notify updates on channels\n+            return;\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_SETPOINT:\n+                try {\n+                    @SuppressWarnings(\"rawtypes\")\n+                    QuantityType setpoint = (QuantityType) command;\n+                    DecimalType dt = new DecimalType(setpoint.intValue());\n+                    submitCommand(new SetSetpointCommand(dt, dt));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid temperature\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_ONOFF_STATUS:\n+                try {\n+                    OnOffType oot = (OnOffType) command;\n+                    submitCommand(new SetPowerstateCommand(oot));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid on/off status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_FAN_SPEED:\n+                try {\n+                    DecimalType fanSpeed = (DecimalType) command;\n+                    FanSpeed fs = FanSpeed.valueOf(fanSpeed.intValue());\n+                    submitCommand(new SetFanspeedCommand(fs, fs));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid FanSpeed status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_OPERATION_MODE:\n+                try {\n+                    StringType operationMode = (StringType) command;\n+                    OperationMode m = OperationMode.valueOf(operationMode.toFullString());\n+\n+                    submitCommand(new SetOperationmodeCommand(m));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid OPERATION MODE\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE:\n+                try {\n+                    StringType homekitOperationMode = (StringType) command;\n+\n+                    switch (homekitOperationMode.toString()) {\n+                        case \"Off\":\n+                            submitCommand(new SetPowerstateCommand(OnOffType.OFF));\n+                            break;\n+                        case \"CoolOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.COOL));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"HeatOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.HEAT));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"Auto\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.AUTO));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+\n+                } catch (Exception e) {\n+                    logger.info(\"Error while setting mode through HomeKIt received Mode\");\n+                }\n+            default:\n+                break;\n+\n+        }\n+\n+    }\n+\n+    @Override\n+    public void onCharacteristicUpdate(BluetoothCharacteristic characteristic) {\n+        super.onCharacteristicUpdate(characteristic);\n+\n+        // Check that arguments are valid.\n+        if (characteristic.getUuid() == null) {\n+            return;\n+        }\n+\n+        // We are only interested in the Notify Characteristic of UART service\n+        if (!characteristic.getUuid().equals(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID)) {\n+            return;\n+        }\n+\n+        // A message cannot be null or have a 0-byte length\n+        if (characteristic.getByteValue() == null || characteristic.getByteValue().length == 0) {\n+            return;\n+        }\n+\n+        this.uartProcessor.chunkReceived(characteristic.getByteValue());\n+\n+    }\n+\n+    private void submitCommand(BRC1HCommand command) {\n+        Executor executor = commandExecutor;\n+\n+        if (executor != null) {\n+            executor.execute(() -> processCommand(command));\n+        }\n+    }\n+\n+    private void processCommand(BRC1HCommand command) {\n+        logger.debug(\"[{}] ProcessCommand {}\", super.thing.getUID().getId(), command.getClass().getSimpleName());\n+\n+        try {\n+            currentCommand = command;\n+            uartProcessor.abandon();\n+\n+            if (command.getRequest() == null) {\n+                logger.debug(\"Unable to send command {} to device {}: Request NULL.\",\n+                        command.getClass().getSimpleName(), device.getAddress());\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            if (device == null || device.getConnectionState() != ConnectionState.CONNECTED) {\n+                logger.debug(\"Unable to send command {} to device {}: not connected\",\n+                        command.getClass().getSimpleName(), address);\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            if (!resolved) {\n+                logger.debug(\"Unable to send command {} to device {}: services not resolved\",\n+                        command.getClass().getSimpleName(), device.getAddress());\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            BluetoothCharacteristic charWrite = device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_WRITE_WITHOUT_RESPONSE_UUID);\n+            if (charWrite == null) {\n+                logger.warn(\"Unable to execute {}. Characteristic '{}' could not be found.\",\n+                        command.getClass().getSimpleName(),\n+                        DaikinMadokaBindingConstants.CHAR_WRITE_WITHOUT_RESPONSE_UUID);\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                @NonNull\n+                BluetoothCharacteristic c = charNotif;\n+                device.enableNotifications(c);", "originalCommit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgzNTUyNg==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412835526", "bodyText": "No idea! I might have been drunk when coding this :-D", "author": "blafois", "createdAt": "2020-04-22T09:46:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ4MDU4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ4MjE1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412482156", "bodyText": "What do you mean by query mode?\nWhy can't you use your getter commands to handle the refresh?", "author": "cpmeister", "createdAt": "2020-04-21T20:50:34Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java", "diffHunk": "@@ -0,0 +1,761 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.handler;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.common.NamedThreadFactory;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDevice.ConnectionState;\n+import org.openhab.binding.bluetooth.ConnectedBluetoothHandler;\n+import org.openhab.binding.bluetooth.daikinmadoka.DaikinMadokaBindingConstants;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.BRC1HUartProcessor;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.DaikinMadokaConfiguration;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaParsingException;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.FanSpeed;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.OperationMode;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaSettings;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetIndoorOutoorTemperatures;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetSetpointCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetVersionCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetSetpointCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DaikinMadokaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Benjamin Lafois - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements ResponseListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DaikinMadokaHandler.class);\n+\n+    private @Nullable DaikinMadokaConfiguration config;\n+\n+    private @Nullable ExecutorService commandExecutor;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    // UART Processor is in charge of reassembling chunks\n+    private BRC1HUartProcessor uartProcessor = new BRC1HUartProcessor(this);\n+\n+    private volatile @Nullable BRC1HCommand currentCommand = null;\n+\n+    private MadokaSettings madokaSettings = new MadokaSettings();\n+\n+    public DaikinMadokaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"[{}] Start initializing!\", super.thing.getUID().getId());\n+\n+        // Load Configuration\n+        config = getConfigAs(DaikinMadokaConfiguration.class);\n+\n+        logger.debug(\"[{}] Parameter value [refreshInterval]: {}\", super.thing.getUID().getId(),\n+                config.refreshInterval);\n+        logger.debug(\"[{}] Parameter value [commandTimeout]: {}\", super.thing.getUID().getId(), config.commandTimeout);\n+\n+        if (getBridge() == null) {\n+            logger.debug(\"[{}] Bridge is null. Exiting.\", super.thing.getUID().getId());\n+            return;\n+        }\n+\n+        this.commandExecutor = Executors\n+                .newSingleThreadExecutor(new NamedThreadFactory(thing.getUID().getAsString(), true));\n+\n+        this.refreshJob = scheduler.scheduleWithFixedDelay(() -> {\n+            // It is useless to refresh version all the time ! Just once.\n+            if (this.madokaSettings.getCommunicationControllerVersion() == null\n+                    || this.madokaSettings.getRemoteControllerVersion() == null) {\n+                submitCommand(new GetVersionCommand());\n+            }\n+            submitCommand(new GetIndoorOutoorTemperatures());\n+            submitCommand(new GetOperationmodeCommand());\n+            submitCommand(new GetPowerstateCommand()); // always keep the \"GetPowerState\" aftern the \"GetOperationMode\"\n+            submitCommand(new GetSetpointCommand());\n+            submitCommand(new GetFanspeedCommand());\n+        }, 10, this.config.refreshInterval, TimeUnit.SECONDS);\n+\n+    }\n+\n+    @Override\n+    public void dispose() {\n+\n+        logger.debug(\"[{}] dispose()\", super.thing.getUID().getId());\n+\n+        dispose(refreshJob);\n+        dispose(commandExecutor);\n+        dispose(currentCommand);\n+\n+        // Unsubscribe to characteristic notifications\n+        if (this.device != null) {\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                @NonNull\n+                BluetoothCharacteristic c = charNotif;\n+                this.device.disableNotifications(c);\n+            }\n+        }\n+\n+        // Disconnect from the device\n+        if (this.device != null) {\n+            this.device.disconnect();\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private static void dispose(@Nullable ExecutorService executor) {\n+        if (executor != null) {\n+            executor.shutdownNow();\n+        }\n+    }\n+\n+    private static void dispose(@Nullable ScheduledFuture<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private static void dispose(@Nullable BRC1HCommand command) {\n+        if (command != null) {\n+            // even if it already completed it doesn't really matter.\n+            // on the off chance that the commandExecutor is waiting on the command, we can wake it up and cause it to\n+            // terminate\n+            command.setState(BRC1HCommand.State.FAILED);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"[{}] Channel: {}, Command: {}\", super.thing.getUID().getId(), channelUID, command);\n+\n+        if (command instanceof RefreshType) {\n+            // The refresh commands are not supported in query mode.\n+            // The binding will notify updates on channels", "originalCommit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgzNzM0OA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412837348", "bodyText": "It was just done on purpose - channels are only refreshed when the bindings decides it - ie. with the refresh timer. It was to avoid too many refreshes coming from elsewhere. The BRC1H does not handle very well too many queries, and when it is stuck, you have to completely power off your entire AC installation (from the switchboard) which is not super convienient.", "author": "blafois", "createdAt": "2020-04-22T09:49:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ4MjE1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ4MzUyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412483521", "bodyText": "Device disconnect/cleanup is already handled for you as part of super.dispose(). So you don't need to handle it yourself.", "author": "cpmeister", "createdAt": "2020-04-21T20:53:00Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java", "diffHunk": "@@ -0,0 +1,761 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.handler;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.common.NamedThreadFactory;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDevice.ConnectionState;\n+import org.openhab.binding.bluetooth.ConnectedBluetoothHandler;\n+import org.openhab.binding.bluetooth.daikinmadoka.DaikinMadokaBindingConstants;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.BRC1HUartProcessor;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.DaikinMadokaConfiguration;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaParsingException;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.FanSpeed;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.OperationMode;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaSettings;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetIndoorOutoorTemperatures;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetSetpointCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetVersionCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetSetpointCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DaikinMadokaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Benjamin Lafois - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements ResponseListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DaikinMadokaHandler.class);\n+\n+    private @Nullable DaikinMadokaConfiguration config;\n+\n+    private @Nullable ExecutorService commandExecutor;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    // UART Processor is in charge of reassembling chunks\n+    private BRC1HUartProcessor uartProcessor = new BRC1HUartProcessor(this);\n+\n+    private volatile @Nullable BRC1HCommand currentCommand = null;\n+\n+    private MadokaSettings madokaSettings = new MadokaSettings();\n+\n+    public DaikinMadokaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"[{}] Start initializing!\", super.thing.getUID().getId());\n+\n+        // Load Configuration\n+        config = getConfigAs(DaikinMadokaConfiguration.class);\n+\n+        logger.debug(\"[{}] Parameter value [refreshInterval]: {}\", super.thing.getUID().getId(),\n+                config.refreshInterval);\n+        logger.debug(\"[{}] Parameter value [commandTimeout]: {}\", super.thing.getUID().getId(), config.commandTimeout);\n+\n+        if (getBridge() == null) {\n+            logger.debug(\"[{}] Bridge is null. Exiting.\", super.thing.getUID().getId());\n+            return;\n+        }\n+\n+        this.commandExecutor = Executors\n+                .newSingleThreadExecutor(new NamedThreadFactory(thing.getUID().getAsString(), true));\n+\n+        this.refreshJob = scheduler.scheduleWithFixedDelay(() -> {\n+            // It is useless to refresh version all the time ! Just once.\n+            if (this.madokaSettings.getCommunicationControllerVersion() == null\n+                    || this.madokaSettings.getRemoteControllerVersion() == null) {\n+                submitCommand(new GetVersionCommand());\n+            }\n+            submitCommand(new GetIndoorOutoorTemperatures());\n+            submitCommand(new GetOperationmodeCommand());\n+            submitCommand(new GetPowerstateCommand()); // always keep the \"GetPowerState\" aftern the \"GetOperationMode\"\n+            submitCommand(new GetSetpointCommand());\n+            submitCommand(new GetFanspeedCommand());\n+        }, 10, this.config.refreshInterval, TimeUnit.SECONDS);\n+\n+    }\n+\n+    @Override\n+    public void dispose() {\n+\n+        logger.debug(\"[{}] dispose()\", super.thing.getUID().getId());\n+\n+        dispose(refreshJob);\n+        dispose(commandExecutor);\n+        dispose(currentCommand);\n+\n+        // Unsubscribe to characteristic notifications\n+        if (this.device != null) {\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                @NonNull\n+                BluetoothCharacteristic c = charNotif;\n+                this.device.disableNotifications(c);\n+            }\n+        }\n+\n+        // Disconnect from the device\n+        if (this.device != null) {\n+            this.device.disconnect();\n+        }", "originalCommit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ4NDY4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r412484681", "bodyText": "Please try not to suppress any warnings. What is preventing you from removing this?", "author": "cpmeister", "createdAt": "2020-04-21T20:55:01Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java", "diffHunk": "@@ -0,0 +1,761 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.handler;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.common.NamedThreadFactory;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDevice.ConnectionState;\n+import org.openhab.binding.bluetooth.ConnectedBluetoothHandler;\n+import org.openhab.binding.bluetooth.daikinmadoka.DaikinMadokaBindingConstants;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.BRC1HUartProcessor;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.DaikinMadokaConfiguration;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaParsingException;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.FanSpeed;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.OperationMode;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaSettings;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetIndoorOutoorTemperatures;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetSetpointCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetVersionCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetSetpointCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DaikinMadokaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Benjamin Lafois - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements ResponseListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DaikinMadokaHandler.class);\n+\n+    private @Nullable DaikinMadokaConfiguration config;\n+\n+    private @Nullable ExecutorService commandExecutor;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    // UART Processor is in charge of reassembling chunks\n+    private BRC1HUartProcessor uartProcessor = new BRC1HUartProcessor(this);\n+\n+    private volatile @Nullable BRC1HCommand currentCommand = null;\n+\n+    private MadokaSettings madokaSettings = new MadokaSettings();\n+\n+    public DaikinMadokaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @SuppressWarnings(\"null\")", "originalCommit": "4023fa4afda298d1796ec0cf4b28ce44f36dff73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a508dbf12b8333bd292d4b0a6ea77a164d2fcf60", "url": "https://github.com/openhab/openhab-addons/commit/a508dbf12b8333bd292d4b0a6ea77a164d2fcf60", "message": "Merge branch '2.5.x' into add-daikinmadoka-binding following 2.5.5 release", "committedDate": "2020-04-22T08:14:03Z", "type": "commit"}, {"oid": "f3e5557ead5d8b53513249e414070989ae8d2d02", "url": "https://github.com/openhab/openhab-addons/commit/f3e5557ead5d8b53513249e414070989ae8d2d02", "message": "Updates following @cpmeister comments on PR 7434\n\nSigned-off-by: Benjamin Lafois <benjamin@lafois.com>", "committedDate": "2020-04-22T09:52:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM5NjgxNw==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r425396817", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                bos.write(Arrays.copyOfRange(msg, 1, msg.length));\n          \n          \n            \n                                bos.write(msg, 1, msg.length - 1);", "author": "cpmeister", "createdAt": "2020-05-14T20:01:35Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Benjamin Lafois\n+ *\n+ */\n+@NonNullByDefault\n+public class BRC1HUartProcessor {\n+\n+    /**\n+     * Maximum number of bytes per message chunk, including headers\n+     */\n+    public static final int MAX_CHUNK_SIZE = 20;\n+\n+    /**\n+     * In the unlikely event of messages arrive in wrong order, this comparator will sort the queue\n+     */\n+    private Comparator<byte[]> chunkSorter = (byte[] m1, byte[] m2) -> m1[0] - m2[0];\n+\n+    private final Logger logger = LoggerFactory.getLogger(BRC1HUartProcessor.class);\n+\n+    private ConcurrentSkipListSet<byte[]> uartMessages = new ConcurrentSkipListSet<>(chunkSorter);\n+\n+    private ResponseListener responseListener;\n+\n+    public BRC1HUartProcessor(ResponseListener responseListener) {\n+        this.responseListener = responseListener;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    private boolean isMessageComplete() {\n+        int messagesInQueue = this.uartMessages.size();\n+\n+        if (messagesInQueue <= 0) {\n+            return false;\n+        }\n+\n+        byte[] firstMessageInQueue = uartMessages.first();\n+        if (firstMessageInQueue.length < 2) {\n+            return false;\n+        }\n+\n+        int expectedChunks = (int) Math.ceil(firstMessageInQueue[1] / (MAX_CHUNK_SIZE - 1.0));\n+        if (expectedChunks != messagesInQueue) {\n+            return false;\n+        }\n+\n+        // Check that we have every single ID\n+        int expected = 0;\n+        for (byte[] m : this.uartMessages) {\n+            if (m.length < 2) {\n+                return false;\n+            }\n+\n+            if (m[0] != expected++) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    public void chunkReceived(byte[] byteValue) {\n+        this.uartMessages.add(byteValue);\n+        if (isMessageComplete()) {\n+\n+            // Beyond this point, full message received\n+            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+\n+            for (byte[] msg : uartMessages) {\n+                try {\n+                    bos.write(Arrays.copyOfRange(msg, 1, msg.length));", "originalCommit": "f3e5557ead5d8b53513249e414070989ae8d2d02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQyMzU1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r425423556", "bodyText": "I assume this is some out of bounds exception regarding the messages. Instead of catching an exception here just perform a check to make sure that the exception doesn't occur.", "author": "cpmeister", "createdAt": "2020-05-14T20:53:17Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Benjamin Lafois\n+ *\n+ */\n+@NonNullByDefault\n+public class BRC1HUartProcessor {\n+\n+    /**\n+     * Maximum number of bytes per message chunk, including headers\n+     */\n+    public static final int MAX_CHUNK_SIZE = 20;\n+\n+    /**\n+     * In the unlikely event of messages arrive in wrong order, this comparator will sort the queue\n+     */\n+    private Comparator<byte[]> chunkSorter = (byte[] m1, byte[] m2) -> m1[0] - m2[0];\n+\n+    private final Logger logger = LoggerFactory.getLogger(BRC1HUartProcessor.class);\n+\n+    private ConcurrentSkipListSet<byte[]> uartMessages = new ConcurrentSkipListSet<>(chunkSorter);\n+\n+    private ResponseListener responseListener;\n+\n+    public BRC1HUartProcessor(ResponseListener responseListener) {\n+        this.responseListener = responseListener;\n+    }\n+\n+    /**\n+     *\n+     * @return\n+     */\n+    private boolean isMessageComplete() {\n+        int messagesInQueue = this.uartMessages.size();\n+\n+        if (messagesInQueue <= 0) {\n+            return false;\n+        }\n+\n+        byte[] firstMessageInQueue = uartMessages.first();\n+        if (firstMessageInQueue.length < 2) {\n+            return false;\n+        }\n+\n+        int expectedChunks = (int) Math.ceil(firstMessageInQueue[1] / (MAX_CHUNK_SIZE - 1.0));\n+        if (expectedChunks != messagesInQueue) {\n+            return false;\n+        }\n+\n+        // Check that we have every single ID\n+        int expected = 0;\n+        for (byte[] m : this.uartMessages) {\n+            if (m.length < 2) {\n+                return false;\n+            }\n+\n+            if (m[0] != expected++) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    public void chunkReceived(byte[] byteValue) {\n+        this.uartMessages.add(byteValue);\n+        if (isMessageComplete()) {\n+\n+            // Beyond this point, full message received\n+            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+\n+            for (byte[] msg : uartMessages) {\n+                try {\n+                    bos.write(Arrays.copyOfRange(msg, 1, msg.length));\n+                } catch (Exception e) {\n+                    // should never happen.\n+                    logger.info(\"An unexpected error occured while re-assembling message chunks\", e);\n+                }", "originalCommit": "f3e5557ead5d8b53513249e414070989ae8d2d02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQyNTQ4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r425425487", "bodyText": "It should be safe to change the return type to void since commands will just throw an exception if they fail.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public abstract boolean handleResponse(Executor executor, ResponseListener listener, MadokaMessage mm)\n          \n          \n            \n                public abstract void handleResponse(Executor executor, ResponseListener listener, MadokaMessage mm)", "author": "cpmeister", "createdAt": "2020-05-14T20:56:51Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/BRC1HCommand.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n+\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Condition;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaParsingException;\n+\n+/**\n+ *\n+ * @author Benjamin Lafois\n+ *\n+ */\n+@NonNullByDefault\n+public abstract class BRC1HCommand {\n+\n+    public enum State {\n+        NEW,\n+        ENQUEUED,\n+        SENT,\n+        SUCCEEDED,\n+        FAILED\n+    }\n+\n+    private volatile State state = State.NEW;\n+\n+    private final Lock stateLock = new ReentrantLock();\n+\n+    private final Condition stateCondition = stateLock.newCondition();\n+\n+    public abstract boolean handleResponse(Executor executor, ResponseListener listener, MadokaMessage mm)", "originalCommit": "f3e5557ead5d8b53513249e414070989ae8d2d02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQyNTg3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r425425879", "bodyText": "What exception can be thrown here, can you make it specific?", "author": "cpmeister", "createdAt": "2020-05-14T20:57:35Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/GetPowerstateCommand.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n+\n+import java.util.concurrent.Executor;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaParsingException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Benjamin Lafois\n+ *\n+ */\n+@NonNullByDefault\n+public class GetPowerstateCommand extends BRC1HCommand {\n+\n+    private final Logger logger = LoggerFactory.getLogger(GetPowerstateCommand.class);\n+\n+    private @Nullable Boolean powerState;\n+\n+    @Override\n+    public byte[] getRequest() {\n+        return MadokaMessage.createRequest(this);\n+    }\n+\n+    @Override\n+    public boolean handleResponse(Executor executor, ResponseListener listener, MadokaMessage mm)\n+            throws MadokaParsingException {\n+        try {\n+            powerState = Integer.valueOf(mm.getValues().get(0x20).getRawValue()[0]) == 1;\n+\n+            logger.debug(\"PowerState: {}\", powerState);\n+\n+            setState(State.SUCCEEDED);\n+            executor.execute(() -> listener.receivedResponse(this));\n+\n+            return true;\n+        } catch (Exception e) {", "originalCommit": "f3e5557ead5d8b53513249e414070989ae8d2d02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQyNzAyMg==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r425427022", "bodyText": "Here is an example of how to deal with the null checker warnings.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (logger.isDebugEnabled() && mm.getRawMessage() != null) {\n          \n          \n            \n                        byte @NonNull [] msg = (byte @NonNull []) mm.getRawMessage();\n          \n          \n            \n                    byte[] msg = mm.getRawMessage();\n          \n          \n            \n                    if (logger.isDebugEnabled() && msg != null) {", "author": "cpmeister", "createdAt": "2020-05-14T20:59:41Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/SetPowerstateCommand.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n+\n+import java.util.concurrent.Executor;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaValue;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Benjamin Lafois\n+ *\n+ */\n+@NonNullByDefault\n+public class SetPowerstateCommand extends BRC1HCommand {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SetPowerstateCommand.class);\n+\n+    private OnOffType powerState;\n+\n+    public SetPowerstateCommand(OnOffType powerState) {\n+        this.powerState = powerState;\n+    }\n+\n+    @Override\n+    public byte[] getRequest() {\n+        MadokaValue mv = new MadokaValue(0x20, 1,\n+                new byte[] { (byte) (this.powerState == OnOffType.ON ? 0x01 : 0x00) });\n+\n+        return MadokaMessage.createRequest(this, mv);\n+    }\n+\n+    @Override\n+    public boolean handleResponse(Executor executor, ResponseListener listener, MadokaMessage mm) {\n+        if (logger.isDebugEnabled() && mm.getRawMessage() != null) {\n+            byte @NonNull [] msg = (byte @NonNull []) mm.getRawMessage();", "originalCommit": "f3e5557ead5d8b53513249e414070989ae8d2d02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQyNzM2NA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r425427364", "bodyText": "this.madokaSettings.getOperationMode() should be cached to a local variable so it can be reused.\nAlso make similar changes elsewhere.", "author": "cpmeister", "createdAt": "2020-05-14T21:00:18Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java", "diffHunk": "@@ -0,0 +1,762 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.handler;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.common.NamedThreadFactory;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDevice.ConnectionState;\n+import org.openhab.binding.bluetooth.ConnectedBluetoothHandler;\n+import org.openhab.binding.bluetooth.daikinmadoka.DaikinMadokaBindingConstants;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.BRC1HUartProcessor;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.DaikinMadokaConfiguration;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaParsingException;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.FanSpeed;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.OperationMode;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaSettings;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetIndoorOutoorTemperatures;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetSetpointCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetVersionCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetSetpointCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DaikinMadokaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Benjamin Lafois - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements ResponseListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DaikinMadokaHandler.class);\n+\n+    private @Nullable DaikinMadokaConfiguration config;\n+\n+    private @Nullable ExecutorService commandExecutor;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    // UART Processor is in charge of reassembling chunks\n+    private BRC1HUartProcessor uartProcessor = new BRC1HUartProcessor(this);\n+\n+    private volatile @Nullable BRC1HCommand currentCommand = null;\n+\n+    private MadokaSettings madokaSettings = new MadokaSettings();\n+\n+    public DaikinMadokaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"[{}] Start initializing!\", super.thing.getUID().getId());\n+\n+        // Load Configuration\n+        config = getConfigAs(DaikinMadokaConfiguration.class);\n+\n+        logger.debug(\"[{}] Parameter value [refreshInterval]: {}\", super.thing.getUID().getId(),\n+                config.refreshInterval);\n+        logger.debug(\"[{}] Parameter value [commandTimeout]: {}\", super.thing.getUID().getId(), config.commandTimeout);\n+\n+        if (getBridge() == null) {\n+            logger.debug(\"[{}] Bridge is null. Exiting.\", super.thing.getUID().getId());\n+            return;\n+        }\n+\n+        this.commandExecutor = Executors\n+                .newSingleThreadExecutor(new NamedThreadFactory(thing.getUID().getAsString(), true));\n+\n+        this.refreshJob = scheduler.scheduleWithFixedDelay(() -> {\n+            // It is useless to refresh version all the time ! Just once.\n+            if (this.madokaSettings.getCommunicationControllerVersion() == null\n+                    || this.madokaSettings.getRemoteControllerVersion() == null) {\n+                submitCommand(new GetVersionCommand());\n+            }\n+            submitCommand(new GetIndoorOutoorTemperatures());\n+            submitCommand(new GetOperationmodeCommand());\n+            submitCommand(new GetPowerstateCommand()); // always keep the \"GetPowerState\" aftern the \"GetOperationMode\"\n+            submitCommand(new GetSetpointCommand());\n+            submitCommand(new GetFanspeedCommand());\n+        }, 10, this.config.refreshInterval, TimeUnit.SECONDS);\n+\n+    }\n+\n+    @Override\n+    public void dispose() {\n+\n+        logger.debug(\"[{}] dispose()\", super.thing.getUID().getId());\n+\n+        dispose(refreshJob);\n+        dispose(commandExecutor);\n+        dispose(currentCommand);\n+\n+        // Unsubscribe to characteristic notifications\n+        if (this.device != null) {\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                @NonNull\n+                BluetoothCharacteristic c = charNotif;\n+                this.device.disableNotifications(c);\n+            }\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private static void dispose(@Nullable ExecutorService executor) {\n+        if (executor != null) {\n+            executor.shutdownNow();\n+        }\n+    }\n+\n+    private static void dispose(@Nullable ScheduledFuture<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private static void dispose(@Nullable BRC1HCommand command) {\n+        if (command != null) {\n+            // even if it already completed it doesn't really matter.\n+            // on the off chance that the commandExecutor is waiting on the command, we can wake it up and cause it to\n+            // terminate\n+            command.setState(BRC1HCommand.State.FAILED);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"[{}] Channel: {}, Command: {}\", super.thing.getUID().getId(), channelUID, command);\n+\n+        if (command instanceof RefreshType) {\n+            // The refresh commands are not supported in query mode.\n+            // The binding will notify updates on channels\n+            return;\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_SETPOINT:\n+                try {\n+                    QuantityType setpoint = (QuantityType) command;\n+                    DecimalType dt = new DecimalType(setpoint.intValue());\n+                    submitCommand(new SetSetpointCommand(dt, dt));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid temperature\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_ONOFF_STATUS:\n+                try {\n+                    OnOffType oot = (OnOffType) command;\n+                    submitCommand(new SetPowerstateCommand(oot));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid on/off status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_FAN_SPEED:\n+                try {\n+                    DecimalType fanSpeed = (DecimalType) command;\n+                    FanSpeed fs = FanSpeed.valueOf(fanSpeed.intValue());\n+                    submitCommand(new SetFanspeedCommand(fs, fs));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid FanSpeed status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_OPERATION_MODE:\n+                try {\n+                    StringType operationMode = (StringType) command;\n+                    OperationMode m = OperationMode.valueOf(operationMode.toFullString());\n+\n+                    submitCommand(new SetOperationmodeCommand(m));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid OPERATION MODE\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE:\n+                try {\n+                    StringType homekitOperationMode = (StringType) command;\n+\n+                    switch (homekitOperationMode.toString()) {\n+                        case \"Off\":\n+                            submitCommand(new SetPowerstateCommand(OnOffType.OFF));\n+                            break;\n+                        case \"CoolOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.COOL));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"HeatOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.HEAT));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"Auto\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.AUTO));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+\n+                } catch (Exception e) {\n+                    logger.info(\"Error while setting mode through HomeKIt received Mode\");\n+                }\n+            default:\n+                break;\n+\n+        }\n+\n+    }\n+\n+    @Override\n+    public void onCharacteristicUpdate(BluetoothCharacteristic characteristic) {\n+        super.onCharacteristicUpdate(characteristic);\n+\n+        // Check that arguments are valid.\n+        if (characteristic.getUuid() == null) {\n+            return;\n+        }\n+\n+        // We are only interested in the Notify Characteristic of UART service\n+        if (!characteristic.getUuid().equals(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID)) {\n+            return;\n+        }\n+\n+        // A message cannot be null or have a 0-byte length\n+        if (characteristic.getByteValue() == null || characteristic.getByteValue().length == 0) {\n+            return;\n+        }\n+\n+        this.uartProcessor.chunkReceived(characteristic.getByteValue());\n+\n+    }\n+\n+    private void submitCommand(BRC1HCommand command) {\n+        Executor executor = commandExecutor;\n+\n+        if (executor != null) {\n+            executor.execute(() -> processCommand(command));\n+        }\n+    }\n+\n+    private void processCommand(BRC1HCommand command) {\n+        logger.debug(\"[{}] ProcessCommand {}\", super.thing.getUID().getId(), command.getClass().getSimpleName());\n+\n+        try {\n+            currentCommand = command;\n+            uartProcessor.abandon();\n+\n+            if (command.getRequest() == null) {\n+                logger.debug(\"Unable to send command {} to device {}: Request NULL.\",\n+                        command.getClass().getSimpleName(), device.getAddress());\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            if (device == null || device.getConnectionState() != ConnectionState.CONNECTED) {\n+                logger.debug(\"Unable to send command {} to device {}: not connected\",\n+                        command.getClass().getSimpleName(), address);\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            if (!resolved) {\n+                logger.debug(\"Unable to send command {} to device {}: services not resolved\",\n+                        command.getClass().getSimpleName(), device.getAddress());\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            BluetoothCharacteristic charWrite = device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_WRITE_WITHOUT_RESPONSE_UUID);\n+            if (charWrite == null) {\n+                logger.warn(\"Unable to execute {}. Characteristic '{}' could not be found.\",\n+                        command.getClass().getSimpleName(),\n+                        DaikinMadokaBindingConstants.CHAR_WRITE_WITHOUT_RESPONSE_UUID);\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                device.enableNotifications(charNotif);\n+            }\n+\n+            charWrite.setValue(command.getRequest());\n+            command.setState(BRC1HCommand.State.ENQUEUED);\n+            device.writeCharacteristic(charWrite);\n+\n+            if (!command.awaitStateChange(this.config.commandTimeout, TimeUnit.MILLISECONDS,\n+                    BRC1HCommand.State.SUCCEEDED, BRC1HCommand.State.FAILED)) {\n+                logger.debug(\"Command {} to device {} timed out\", command, device.getAddress());\n+                command.setState(BRC1HCommand.State.FAILED);\n+            }\n+\n+        } catch (Exception e) {\n+            logger.debug(\"Error\", e);\n+        } finally {\n+            logger.debug(\"Command final state: {}\", command.getState());\n+            currentCommand = null;\n+        }\n+\n+        try {\n+            Thread.sleep(200);\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+        }\n+    }\n+\n+    @Override\n+    public void onCharacteristicWriteComplete(BluetoothCharacteristic characteristic,\n+            BluetoothCompletionStatus status) {\n+\n+        super.onCharacteristicWriteComplete(characteristic, status);\n+\n+        byte[] request = characteristic.getByteValue();\n+\n+        BRC1HCommand command = currentCommand;\n+\n+        if (command != null) {\n+            if (!Arrays.equals(request, command.getRequest())) {\n+                logger.debug(\"Write completed for unknown command\");\n+                return;\n+            }\n+            switch (status) {\n+                case SUCCESS:\n+                    command.setState(BRC1HCommand.State.SENT);\n+                    break;\n+                case ERROR:\n+                    command.setState(BRC1HCommand.State.FAILED);\n+                    break;\n+            }\n+        } else {\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"No command found that matches request {}\", HexUtils.bytesToHex(request));\n+            }\n+        }\n+\n+    }\n+\n+    /**\n+     * When the method is triggered, it means that all message chunks have been received, re-assembled in the right\n+     * order and that the payload is ready to be processed.\n+     */\n+    @Override\n+    public void receivedResponse(byte[] response) {\n+        logger.debug(\"Received Response\");\n+        BRC1HCommand command = currentCommand;\n+\n+        if (command == null) {\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"No command present to handle response {}\", HexUtils.bytesToHex(response));\n+            }\n+        } else {\n+            try {\n+                if ((!command.handleResponse(scheduler, this, MadokaMessage.parse(response)))) {\n+                    logger.debug(\"Command {} could not handle response {}\", command.getClass().getSimpleName(),\n+                            HexUtils.bytesToHex(response));\n+                }\n+            } catch (MadokaParsingException e) {\n+                logger.debug(\"Response message could not be parsed correctly ({}): {}\",\n+                        command.getClass().getSimpleName(), HexUtils.bytesToHex(response));\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetVersionCommand command) {\n+        String commCtrlVers = command.getCommunicationControllerVersion();\n+        if (commCtrlVers != null) {\n+            this.madokaSettings.setCommunicationControllerVersion(commCtrlVers);\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(),\n+                            DaikinMadokaBindingConstants.CHANNEL_ID_COMMUNICATION_CONTROLLER_VERSION),\n+                    new StringType(commCtrlVers));\n+        }\n+\n+        String remoteCtrlVers = command.getRemoteControllerVersion();\n+        if (remoteCtrlVers != null) {\n+            this.madokaSettings.setRemoteControllerVersion(remoteCtrlVers);\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(),\n+                            DaikinMadokaBindingConstants.CHANNEL_ID_REMOTE_CONTROLLER_VERSION),\n+                    new StringType(remoteCtrlVers));\n+        }\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetFanspeedCommand command) {\n+\n+        if (command.getCoolingFanSpeed() == null || command.getHeatingFanSpeed() == null) {\n+            return;\n+        }\n+\n+        // We need the current operation mode to determine which Fan Speed we use (cooling or heating)\n+        if (this.madokaSettings.getOperationMode() == null) {\n+            return;\n+        }\n+\n+        FanSpeed fs = null;\n+\n+        switch (this.madokaSettings.getOperationMode()) {\n+            case AUTO:\n+                // TODO confirm it works in all conditions\n+                logger.debug(\"In AutoMode, CoolingFanSpeed = {}, HeatingFanSpeed = {}\", command.getCoolingFanSpeed(),\n+                        command.getHeatingFanSpeed());\n+                fs = command.getHeatingFanSpeed();\n+                break;\n+            case HEAT:\n+                fs = command.getHeatingFanSpeed();\n+                break;\n+            case COOL:\n+                fs = command.getCoolingFanSpeed();\n+                break;\n+            default:\n+                return;\n+        }\n+\n+        // No need to re-set if it is the same value\n+        if (fs.equals(this.madokaSettings.getFanspeed())) {\n+            return;\n+        }\n+\n+        this.madokaSettings.setFanspeed(fs);\n+        updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_FAN_SPEED),\n+                new DecimalType(fs.value()));\n+\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetSetpointCommand command) {\n+        if (command.getCoolingSetpoint() == null || command.getHeatingSetpoint() == null) {\n+            return;\n+        }\n+\n+        // We need the current operation mode to determine which Fan Speed we use (cooling or heating)\n+        if (this.madokaSettings.getOperationMode() == null) {\n+            return;\n+        }\n+\n+        DecimalType sp = null;\n+\n+        switch (this.madokaSettings.getOperationMode()) {\n+            case AUTO:\n+                // TODO confirm it works in all conditions\n+                logger.debug(\"In AutoMode, CoolingSetpoint = {}, HeatingSetpoint = {}\", command.getCoolingSetpoint(),\n+                        command.getHeatingSetpoint());\n+                sp = command.getHeatingSetpoint();\n+                break;\n+            case HEAT:\n+                sp = command.getHeatingSetpoint();\n+                break;\n+            case COOL:\n+                sp = command.getCoolingSetpoint();\n+                break;\n+            default:\n+                return;\n+        }\n+\n+        // No need to re-set if it is the same value\n+        if (sp.equals(this.madokaSettings.getSetpoint())) {\n+            return;\n+        }\n+\n+        this.madokaSettings.setSetpoint(sp);\n+\n+        DecimalType dt = this.madokaSettings.getSetpoint();\n+        if (dt != null) {\n+            updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_SETPOINT),\n+                    dt);\n+        }\n+\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetOperationmodeCommand command) {\n+        if (command.getOperationMode() == null) {\n+            return;\n+        }\n+\n+        OperationMode newMode = command.getOperationMode();\n+        // If the mode has not changed - no need to refresh everything\n+        if (newMode.equals(this.madokaSettings.getOperationMode())) {\n+            return;\n+        }\n+\n+        this.madokaSettings.setOperationMode(newMode);\n+\n+        updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_OPERATION_MODE),\n+                new StringType(newMode.name()));\n+\n+        // For HomeKit channel, we need to map it to HomeKit supported strings\n+        switch (newMode) {\n+            case COOL:\n+                updateStateIfLinked(\n+                        new ChannelUID(getThing().getUID(),\n+                                DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                        new StringType(\"Cooling\"));\n+                break;\n+            case HEAT:\n+                updateStateIfLinked(\n+                        new ChannelUID(getThing().getUID(),\n+                                DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                        new StringType(\"Heating\"));\n+                break;\n+            default:\n+                break;\n+        }\n+\n+        // If this is the first channel update - then we set target = current mode\n+        if (this.madokaSettings.getHomekitTargetMode() == null) {\n+            String newHomekitTargetStatus = null;\n+\n+            // For HomeKit channel, we need to map it to HomeKit supported strings\n+            switch (newMode) {\n+                case COOL:\n+                    newHomekitTargetStatus = \"CoolOn\";\n+                    break;\n+                case HEAT:\n+                    newHomekitTargetStatus = \"HeatOn\";\n+                    break;\n+                default:\n+                    return;\n+            }\n+            this.madokaSettings.setHomekitTargetMode(newHomekitTargetStatus);\n+\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(),\n+                            DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE),\n+                    new StringType(newHomekitTargetStatus));\n+        }\n+\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetPowerstateCommand command) {\n+        if (command.isPowerState() == null) {\n+            return;\n+        }\n+\n+        OnOffType oot = command.isPowerState() ? OnOffType.ON : OnOffType.OFF;\n+\n+        if (oot.equals(this.madokaSettings.getOnOffState())) {\n+            return;\n+        }\n+\n+        this.madokaSettings.setOnOffState(oot);\n+\n+        updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_ONOFF_STATUS),\n+                oot);\n+\n+        if (oot.equals(OnOffType.OFF)) {\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(),\n+                            DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                    new StringType(\"Off\"));\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(),\n+                            DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE),\n+                    new StringType(\"Off\"));\n+        }\n+\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetIndoorOutoorTemperatures command) {\n+\n+        DecimalType newIndoorTemp = command.getIndoorTemperature();\n+        if (newIndoorTemp != null) {\n+            if (!newIndoorTemp.equals(this.madokaSettings.getIndoorTemperature())) {\n+                this.madokaSettings.setIndoorTemperature(newIndoorTemp);\n+                updateStateIfLinked(\n+                        new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_INDOOR_TEMPERATURE),\n+                        newIndoorTemp);\n+            }\n+        }\n+\n+        DecimalType newOutdoorTemp = command.getOutdoorTemperature();\n+        if (newOutdoorTemp == null) {\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_OUTDOOR_TEMPERATURE),\n+                    UnDefType.UNDEF);\n+        } else if (!newOutdoorTemp.equals(this.madokaSettings.getOutdoorTemperature())) {\n+            this.madokaSettings.setOutdoorTemperature(newOutdoorTemp);\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_OUTDOOR_TEMPERATURE),\n+                    newOutdoorTemp);\n+        }\n+\n+    }\n+\n+    @Override\n+    public void receivedResponse(SetPowerstateCommand command) {\n+\n+        updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_ONOFF_STATUS),\n+                command.getPowerState());\n+\n+        madokaSettings.setOnOffState(command.getPowerState());\n+\n+        if (command.getPowerState() == OnOffType.ON) {\n+            // Depending on the state\n+            if (madokaSettings.getOperationMode() == null) {\n+                return;\n+            }\n+\n+            switch (madokaSettings.getOperationMode()) {\n+                case AUTO:\n+                    updateStateIfLinked(\n+                            new ChannelUID(getThing().getUID(),\n+                                    DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                            new StringType(\"Auto\"));\n+                    break;\n+                case HEAT:\n+                    updateStateIfLinked(\n+                            new ChannelUID(getThing().getUID(),\n+                                    DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                            new StringType(\"Heating\"));\n+                    break;\n+                case COOL:\n+                    updateStateIfLinked(\n+                            new ChannelUID(getThing().getUID(),\n+                                    DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                            new StringType(\"Cooling\"));\n+                    break;\n+                default: // Other Modes are not [yet] supported\n+                    break;\n+            }\n+        } else {\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(),\n+                            DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                    new StringType(\"Off\"));\n+\n+        }\n+    }\n+\n+    @Override\n+    public void receivedResponse(SetSetpointCommand command) {\n+\n+        // The update depends on the mode - so if not set - skip\n+        if (this.madokaSettings.getOperationMode() == null) {", "originalCommit": "f3e5557ead5d8b53513249e414070989ae8d2d02", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2488fba2b9710b12f8a92976ce1aff9dceebcdd6", "url": "https://github.com/openhab/openhab-addons/commit/2488fba2b9710b12f8a92976ce1aff9dceebcdd6", "message": "Multiple fixes following PR review (+ removed all warnings)\n\nSigned-off-by: Benjamin Lafois <benjamin@lafois.com>", "committedDate": "2020-05-16T16:11:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5MjQ0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r426192443", "bodyText": "This should address any null checker warnings here\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (rawValue != null) {\n          \n          \n            \n                        byte[] v = rawValue;\n          \n          \n            \n                    byte[] v = rawValue;\n          \n          \n            \n                    if (v != null) {", "author": "cpmeister", "createdAt": "2020-05-16T21:23:27Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaValue.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import java.nio.ByteBuffer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ *\n+ * @author Benjamin Lafois\n+ */\n+@NonNullByDefault\n+public class MadokaValue {\n+\n+    private int id;\n+    private int size;\n+    private byte @Nullable [] rawValue;\n+\n+    public MadokaValue(int id, int size, byte[] rawValue) {\n+        this.id = id;\n+        this.size = size;\n+        this.rawValue = rawValue;\n+    }\n+\n+    public MadokaValue() {\n+    }\n+\n+    public int getId() {\n+        return id;\n+    }\n+\n+    public void setId(int id) {\n+        this.id = id;\n+    }\n+\n+    public int getSize() {\n+        return size;\n+    }\n+\n+    public void setSize(int size) {\n+        this.size = size;\n+    }\n+\n+    public byte @Nullable [] getRawValue() {\n+        return rawValue;\n+    }\n+\n+    public void setRawValue(byte[] rawValue) {\n+        this.rawValue = rawValue;\n+    }\n+\n+    public long getComputedValue() {\n+        if (rawValue != null) {\n+            byte[] v = rawValue;", "originalCommit": "2488fba2b9710b12f8a92976ce1aff9dceebcdd6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5Mjc3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r426192776", "bodyText": "This should be the same right?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            new byte[] { heatingSetpointBytes[0], heatingSetpointBytes[1] });\n          \n          \n            \n                            heatingSetpointBytes);", "author": "cpmeister", "createdAt": "2020-05-16T21:28:03Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/SetSetpointCommand.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.Executor;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaValue;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Benjamin Lafois\n+ *\n+ */\n+@NonNullByDefault\n+public class SetSetpointCommand extends BRC1HCommand {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SetSetpointCommand.class);\n+\n+    private DecimalType coolingSetpoint;\n+    private DecimalType heatingSetpoint;\n+\n+    public SetSetpointCommand(DecimalType coolingSetpoint, DecimalType heatingSetpoint) {\n+        this.coolingSetpoint = coolingSetpoint;\n+        this.heatingSetpoint = heatingSetpoint;\n+    }\n+\n+    @Override\n+    public byte[] getRequest() {\n+        byte[] heatingSetpointBytes = ByteBuffer.allocate(2).putShort((short) (128. * heatingSetpoint.shortValue()))\n+                .array();\n+        byte[] coolingSetpointBytes = ByteBuffer.allocate(2).putShort((short) (128. * coolingSetpoint.shortValue()))\n+                .array();\n+\n+        MadokaValue mvHeatingSetpoint = new MadokaValue(0x21, 2,\n+                new byte[] { heatingSetpointBytes[0], heatingSetpointBytes[1] });", "originalCommit": "2488fba2b9710b12f8a92976ce1aff9dceebcdd6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5Mjc5MA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r426192790", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            new byte[] { coolingSetpointBytes[0], coolingSetpointBytes[1] });\n          \n          \n            \n                            coolingSetpointBytes);", "author": "cpmeister", "createdAt": "2020-05-16T21:28:13Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/SetSetpointCommand.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.Executor;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaValue;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Benjamin Lafois\n+ *\n+ */\n+@NonNullByDefault\n+public class SetSetpointCommand extends BRC1HCommand {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SetSetpointCommand.class);\n+\n+    private DecimalType coolingSetpoint;\n+    private DecimalType heatingSetpoint;\n+\n+    public SetSetpointCommand(DecimalType coolingSetpoint, DecimalType heatingSetpoint) {\n+        this.coolingSetpoint = coolingSetpoint;\n+        this.heatingSetpoint = heatingSetpoint;\n+    }\n+\n+    @Override\n+    public byte[] getRequest() {\n+        byte[] heatingSetpointBytes = ByteBuffer.allocate(2).putShort((short) (128. * heatingSetpoint.shortValue()))\n+                .array();\n+        byte[] coolingSetpointBytes = ByteBuffer.allocate(2).putShort((short) (128. * coolingSetpoint.shortValue()))\n+                .array();\n+\n+        MadokaValue mvHeatingSetpoint = new MadokaValue(0x21, 2,\n+                new byte[] { heatingSetpointBytes[0], heatingSetpointBytes[1] });\n+\n+        MadokaValue mvCoolingSetpoint = new MadokaValue(0x20, 2,\n+                new byte[] { coolingSetpointBytes[0], coolingSetpointBytes[1] });", "originalCommit": "2488fba2b9710b12f8a92976ce1aff9dceebcdd6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5Mjg3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r426192873", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (logger.isDebugEnabled() && mm.getRawMessage() != null) {\n          \n          \n            \n                        byte @NonNull [] msg = (byte @NonNull []) mm.getRawMessage();\n          \n          \n            \n                    byte[] msg = mm.getRawMessage();\n          \n          \n            \n                    if (logger.isDebugEnabled() && msg != null) {", "author": "cpmeister", "createdAt": "2020-05-16T21:29:44Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/SetSetpointCommand.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.Executor;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaValue;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Benjamin Lafois\n+ *\n+ */\n+@NonNullByDefault\n+public class SetSetpointCommand extends BRC1HCommand {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SetSetpointCommand.class);\n+\n+    private DecimalType coolingSetpoint;\n+    private DecimalType heatingSetpoint;\n+\n+    public SetSetpointCommand(DecimalType coolingSetpoint, DecimalType heatingSetpoint) {\n+        this.coolingSetpoint = coolingSetpoint;\n+        this.heatingSetpoint = heatingSetpoint;\n+    }\n+\n+    @Override\n+    public byte[] getRequest() {\n+        byte[] heatingSetpointBytes = ByteBuffer.allocate(2).putShort((short) (128. * heatingSetpoint.shortValue()))\n+                .array();\n+        byte[] coolingSetpointBytes = ByteBuffer.allocate(2).putShort((short) (128. * coolingSetpoint.shortValue()))\n+                .array();\n+\n+        MadokaValue mvHeatingSetpoint = new MadokaValue(0x21, 2,\n+                new byte[] { heatingSetpointBytes[0], heatingSetpointBytes[1] });\n+\n+        MadokaValue mvCoolingSetpoint = new MadokaValue(0x20, 2,\n+                new byte[] { coolingSetpointBytes[0], coolingSetpointBytes[1] });\n+\n+        return MadokaMessage.createRequest(this, mvCoolingSetpoint, mvHeatingSetpoint);\n+    }\n+\n+    @Override\n+    public void handleResponse(Executor executor, ResponseListener listener, MadokaMessage mm) {\n+        if (logger.isDebugEnabled() && mm.getRawMessage() != null) {\n+            byte @NonNull [] msg = (byte @NonNull []) mm.getRawMessage();", "originalCommit": "2488fba2b9710b12f8a92976ce1aff9dceebcdd6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5MjkzMw==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r426192933", "bodyText": "do same change here", "author": "cpmeister", "createdAt": "2020-05-16T21:30:38Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/SetOperationmodeCommand.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n+\n+import java.util.concurrent.Executor;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.OperationMode;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaValue;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Benjamin Lafois\n+ *\n+ */\n+@NonNullByDefault\n+public class SetOperationmodeCommand extends BRC1HCommand {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SetOperationmodeCommand.class);\n+\n+    private OperationMode operationMode;\n+\n+    public SetOperationmodeCommand(OperationMode operationMode) {\n+        this.operationMode = operationMode;\n+    }\n+\n+    @Override\n+    public byte[] getRequest() {\n+        MadokaValue mv = new MadokaValue(0x20, 1, new byte[] { (byte) this.operationMode.value() });\n+        return MadokaMessage.createRequest(this, mv);\n+    }\n+\n+    @Override\n+    public void handleResponse(Executor executor, ResponseListener listener, MadokaMessage mm) {\n+        if (logger.isDebugEnabled() && mm.getRawMessage() != null) {\n+            byte @NonNull [] msg = (byte @NonNull []) mm.getRawMessage();", "originalCommit": "2488fba2b9710b12f8a92976ce1aff9dceebcdd6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5Mjk4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r426192981", "bodyText": "just do it everywhere else as well", "author": "cpmeister", "createdAt": "2020-05-16T21:31:06Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/commands/SetFanspeedCommand.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands;\n+\n+import java.util.concurrent.Executor;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.FanSpeed;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaValue;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Benjamin Lafois\n+ *\n+ */\n+@NonNullByDefault\n+public class SetFanspeedCommand extends BRC1HCommand {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SetFanspeedCommand.class);\n+\n+    private FanSpeed coolingFanSpeed;\n+    private FanSpeed heatingFanSpeed;\n+\n+    public SetFanspeedCommand(FanSpeed coolingFanSpeed, FanSpeed heatingFanSpeed) {\n+        this.coolingFanSpeed = coolingFanSpeed;\n+        this.heatingFanSpeed = heatingFanSpeed;\n+    }\n+\n+    @Override\n+    public byte[] getRequest() {\n+        MadokaValue paramCoolingFanSpeed = new MadokaValue(0x20, 1, new byte[] { (byte) coolingFanSpeed.value() });\n+        MadokaValue paramHeatingFanSpeed = new MadokaValue(0x21, 1, new byte[] { (byte) heatingFanSpeed.value() });\n+\n+        return MadokaMessage.createRequest(this, paramCoolingFanSpeed, paramHeatingFanSpeed);\n+    }\n+\n+    @Override\n+    public void handleResponse(Executor executor, ResponseListener listener, MadokaMessage mm) {\n+        if (logger.isDebugEnabled() && mm.getRawMessage() != null) {\n+            byte @NonNull [] msg = (byte @NonNull []) mm.getRawMessage();", "originalCommit": "2488fba2b9710b12f8a92976ce1aff9dceebcdd6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5MzMzMw==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r426193333", "bodyText": "This should cleanup the code a little bit\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void updateStateIfLinked(ChannelUID channelUID, State state) {\n          \n          \n            \n                    if (isLinked(channelUID)) {\n          \n          \n            \n                private void updateStateIfLinked(String channelId, State state) {\n          \n          \n            \n                    ChannelUID channelUID = new ChannelUID(getThing().getUID(),channelId);\n          \n          \n            \n                    if (isLinked(channelUID)) {", "author": "cpmeister", "createdAt": "2020-05-16T21:37:21Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java", "diffHunk": "@@ -0,0 +1,772 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.handler;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.common.NamedThreadFactory;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDevice.ConnectionState;\n+import org.openhab.binding.bluetooth.ConnectedBluetoothHandler;\n+import org.openhab.binding.bluetooth.daikinmadoka.DaikinMadokaBindingConstants;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.BRC1HUartProcessor;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.DaikinMadokaConfiguration;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaParsingException;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.FanSpeed;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.OperationMode;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaSettings;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetIndoorOutoorTemperatures;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetSetpointCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetVersionCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetSetpointCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DaikinMadokaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Benjamin Lafois - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements ResponseListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DaikinMadokaHandler.class);\n+\n+    private @Nullable DaikinMadokaConfiguration config;\n+\n+    private @Nullable ExecutorService commandExecutor;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    // UART Processor is in charge of reassembling chunks\n+    private BRC1HUartProcessor uartProcessor = new BRC1HUartProcessor(this);\n+\n+    private volatile @Nullable BRC1HCommand currentCommand = null;\n+\n+    private MadokaSettings madokaSettings = new MadokaSettings();\n+\n+    public DaikinMadokaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"[{}] Start initializing!\", super.thing.getUID().getId());\n+\n+        // Load Configuration\n+        config = getConfigAs(DaikinMadokaConfiguration.class);\n+        DaikinMadokaConfiguration c = config;\n+\n+        logger.debug(\"[{}] Parameter value [refreshInterval]: {}\", super.thing.getUID().getId(), c.refreshInterval);\n+        logger.debug(\"[{}] Parameter value [commandTimeout]: {}\", super.thing.getUID().getId(), c.commandTimeout);\n+\n+        if (getBridge() == null) {\n+            logger.debug(\"[{}] Bridge is null. Exiting.\", super.thing.getUID().getId());\n+            return;\n+        }\n+\n+        this.commandExecutor = Executors\n+                .newSingleThreadExecutor(new NamedThreadFactory(thing.getUID().getAsString(), true));\n+\n+        this.refreshJob = scheduler.scheduleWithFixedDelay(() -> {\n+            // It is useless to refresh version all the time ! Just once.\n+            if (this.madokaSettings.getCommunicationControllerVersion() == null\n+                    || this.madokaSettings.getRemoteControllerVersion() == null) {\n+                submitCommand(new GetVersionCommand());\n+            }\n+            submitCommand(new GetIndoorOutoorTemperatures());\n+            submitCommand(new GetOperationmodeCommand());\n+            submitCommand(new GetPowerstateCommand()); // always keep the \"GetPowerState\" aftern the \"GetOperationMode\"\n+            submitCommand(new GetSetpointCommand());\n+            submitCommand(new GetFanspeedCommand());\n+        }, 10, c.refreshInterval, TimeUnit.SECONDS);\n+\n+    }\n+\n+    @Override\n+    public void dispose() {\n+\n+        logger.debug(\"[{}] dispose()\", super.thing.getUID().getId());\n+\n+        dispose(refreshJob);\n+        dispose(commandExecutor);\n+        dispose(currentCommand);\n+\n+        // Unsubscribe to characteristic notifications\n+        if (this.device != null) {\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                @NonNull\n+                BluetoothCharacteristic c = charNotif;\n+                this.device.disableNotifications(c);\n+            }\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private static void dispose(@Nullable ExecutorService executor) {\n+        if (executor != null) {\n+            executor.shutdownNow();\n+        }\n+    }\n+\n+    private static void dispose(@Nullable ScheduledFuture<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private static void dispose(@Nullable BRC1HCommand command) {\n+        if (command != null) {\n+            // even if it already completed it doesn't really matter.\n+            // on the off chance that the commandExecutor is waiting on the command, we can wake it up and cause it to\n+            // terminate\n+            command.setState(BRC1HCommand.State.FAILED);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"[{}] Channel: {}, Command: {}\", super.thing.getUID().getId(), channelUID, command);\n+\n+        if (command instanceof RefreshType) {\n+            // The refresh commands are not supported in query mode.\n+            // The binding will notify updates on channels\n+            return;\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_SETPOINT:\n+                try {\n+                    QuantityType<?> setpoint = (QuantityType<?>) command;\n+                    DecimalType dt = new DecimalType(setpoint.intValue());\n+                    submitCommand(new SetSetpointCommand(dt, dt));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid temperature\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_ONOFF_STATUS:\n+                try {\n+                    OnOffType oot = (OnOffType) command;\n+                    submitCommand(new SetPowerstateCommand(oot));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid on/off status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_FAN_SPEED:\n+                try {\n+                    DecimalType fanSpeed = (DecimalType) command;\n+                    FanSpeed fs = FanSpeed.valueOf(fanSpeed.intValue());\n+                    submitCommand(new SetFanspeedCommand(fs, fs));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid FanSpeed status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_OPERATION_MODE:\n+                try {\n+                    StringType operationMode = (StringType) command;\n+                    OperationMode m = OperationMode.valueOf(operationMode.toFullString());\n+\n+                    submitCommand(new SetOperationmodeCommand(m));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid OPERATION MODE\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE:\n+                try {\n+                    StringType homekitOperationMode = (StringType) command;\n+\n+                    switch (homekitOperationMode.toString()) {\n+                        case \"Off\":\n+                            submitCommand(new SetPowerstateCommand(OnOffType.OFF));\n+                            break;\n+                        case \"CoolOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.COOL));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"HeatOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.HEAT));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"Auto\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.AUTO));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+\n+                } catch (Exception e) {\n+                    logger.info(\"Error while setting mode through HomeKIt received Mode\");\n+                }\n+            default:\n+                break;\n+\n+        }\n+\n+    }\n+\n+    @Override\n+    public void onCharacteristicUpdate(BluetoothCharacteristic characteristic) {\n+        super.onCharacteristicUpdate(characteristic);\n+\n+        // Check that arguments are valid.\n+        if (characteristic.getUuid() == null) {\n+            return;\n+        }\n+\n+        // We are only interested in the Notify Characteristic of UART service\n+        if (!characteristic.getUuid().equals(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID)) {\n+            return;\n+        }\n+\n+        // A message cannot be null or have a 0-byte length\n+        if (characteristic.getByteValue() == null || characteristic.getByteValue().length == 0) {\n+            return;\n+        }\n+\n+        this.uartProcessor.chunkReceived(characteristic.getByteValue());\n+\n+    }\n+\n+    private void submitCommand(BRC1HCommand command) {\n+        Executor executor = commandExecutor;\n+\n+        if (executor != null) {\n+            executor.execute(() -> processCommand(command));\n+        }\n+    }\n+\n+    private void processCommand(BRC1HCommand command) {\n+        logger.debug(\"[{}] ProcessCommand {}\", super.thing.getUID().getId(), command.getClass().getSimpleName());\n+\n+        try {\n+            currentCommand = command;\n+            uartProcessor.abandon();\n+\n+            if (device == null || device.getConnectionState() != ConnectionState.CONNECTED) {\n+                logger.debug(\"Unable to send command {} to device {}: not connected\",\n+                        command.getClass().getSimpleName(), address);\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            if (!resolved) {\n+                logger.debug(\"Unable to send command {} to device {}: services not resolved\",\n+                        command.getClass().getSimpleName(), device.getAddress());\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            BluetoothCharacteristic charWrite = device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_WRITE_WITHOUT_RESPONSE_UUID);\n+            if (charWrite == null) {\n+                logger.warn(\"Unable to execute {}. Characteristic '{}' could not be found.\",\n+                        command.getClass().getSimpleName(),\n+                        DaikinMadokaBindingConstants.CHAR_WRITE_WITHOUT_RESPONSE_UUID);\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                device.enableNotifications(charNotif);\n+            }\n+\n+            charWrite.setValue(command.getRequest());\n+            command.setState(BRC1HCommand.State.ENQUEUED);\n+            device.writeCharacteristic(charWrite);\n+\n+            if (this.config != null) {\n+                if (!command.awaitStateChange(this.config.commandTimeout, TimeUnit.MILLISECONDS,\n+                        BRC1HCommand.State.SUCCEEDED, BRC1HCommand.State.FAILED)) {\n+                    logger.debug(\"Command {} to device {} timed out\", command, device.getAddress());\n+                    command.setState(BRC1HCommand.State.FAILED);\n+                }\n+            }\n+\n+        } catch (Exception e) {\n+            logger.debug(\"Error\", e);\n+        } finally {\n+            logger.debug(\"Command final state: {}\", command.getState());\n+            currentCommand = null;\n+        }\n+\n+        try {\n+            Thread.sleep(200);\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+        }\n+    }\n+\n+    @Override\n+    public void onCharacteristicWriteComplete(BluetoothCharacteristic characteristic,\n+            BluetoothCompletionStatus status) {\n+\n+        super.onCharacteristicWriteComplete(characteristic, status);\n+\n+        byte[] request = characteristic.getByteValue();\n+\n+        BRC1HCommand command = currentCommand;\n+\n+        if (command != null) {\n+            if (!Arrays.equals(request, command.getRequest())) {\n+                logger.debug(\"Write completed for unknown command\");\n+                return;\n+            }\n+            switch (status) {\n+                case SUCCESS:\n+                    command.setState(BRC1HCommand.State.SENT);\n+                    break;\n+                case ERROR:\n+                    command.setState(BRC1HCommand.State.FAILED);\n+                    break;\n+            }\n+        } else {\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"No command found that matches request {}\", HexUtils.bytesToHex(request));\n+            }\n+        }\n+\n+    }\n+\n+    /**\n+     * When the method is triggered, it means that all message chunks have been received, re-assembled in the right\n+     * order and that the payload is ready to be processed.\n+     */\n+    @Override\n+    public void receivedResponse(byte[] response) {\n+        logger.debug(\"Received Response\");\n+        BRC1HCommand command = currentCommand;\n+\n+        if (command == null) {\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"No command present to handle response {}\", HexUtils.bytesToHex(response));\n+            }\n+        } else {\n+            try {\n+                command.handleResponse(scheduler, this, MadokaMessage.parse(response));\n+            } catch (MadokaParsingException e) {\n+                logger.debug(\"Response message could not be parsed correctly ({}): {}\",\n+                        command.getClass().getSimpleName(), HexUtils.bytesToHex(response));\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetVersionCommand command) {\n+        String commCtrlVers = command.getCommunicationControllerVersion();\n+        if (commCtrlVers != null) {\n+            this.madokaSettings.setCommunicationControllerVersion(commCtrlVers);\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(),\n+                            DaikinMadokaBindingConstants.CHANNEL_ID_COMMUNICATION_CONTROLLER_VERSION),\n+                    new StringType(commCtrlVers));\n+        }\n+\n+        String remoteCtrlVers = command.getRemoteControllerVersion();\n+        if (remoteCtrlVers != null) {\n+            this.madokaSettings.setRemoteControllerVersion(remoteCtrlVers);\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(),\n+                            DaikinMadokaBindingConstants.CHANNEL_ID_REMOTE_CONTROLLER_VERSION),\n+                    new StringType(remoteCtrlVers));\n+        }\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetFanspeedCommand command) {\n+\n+        if (command.getCoolingFanSpeed() == null || command.getHeatingFanSpeed() == null) {\n+            return;\n+        }\n+\n+        // We need the current operation mode to determine which Fan Speed we use (cooling or heating)\n+        OperationMode operationMode = this.madokaSettings.getOperationMode();\n+        if (operationMode == null) {\n+            return;\n+        }\n+\n+        FanSpeed fs;\n+\n+        switch (operationMode) {\n+            case AUTO:\n+                // TODO confirm it works in all conditions\n+                logger.debug(\"In AutoMode, CoolingFanSpeed = {}, HeatingFanSpeed = {}\", command.getCoolingFanSpeed(),\n+                        command.getHeatingFanSpeed());\n+                fs = command.getHeatingFanSpeed();\n+                break;\n+            case HEAT:\n+                fs = command.getHeatingFanSpeed();\n+                break;\n+            case COOL:\n+                fs = command.getCoolingFanSpeed();\n+                break;\n+            default:\n+                return;\n+        }\n+\n+        if (fs == null) {\n+            return;\n+        }\n+\n+        // No need to re-set if it is the same value\n+        if (fs.equals(this.madokaSettings.getFanspeed())) {\n+            return;\n+        }\n+\n+        this.madokaSettings.setFanspeed(fs);\n+        updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_FAN_SPEED),\n+                new DecimalType(fs.value()));\n+\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetSetpointCommand command) {\n+        if (command.getCoolingSetpoint() == null || command.getHeatingSetpoint() == null) {\n+            return;\n+        }\n+\n+        // We need the current operation mode to determine which Fan Speed we use (cooling or heating)\n+        OperationMode operationMode = this.madokaSettings.getOperationMode();\n+        if (operationMode == null) {\n+            return;\n+        }\n+\n+        DecimalType sp;\n+\n+        switch (operationMode) {\n+            case AUTO:\n+                // TODO confirm it works in all conditions\n+                logger.debug(\"In AutoMode, CoolingSetpoint = {}, HeatingSetpoint = {}\", command.getCoolingSetpoint(),\n+                        command.getHeatingSetpoint());\n+                sp = command.getHeatingSetpoint();\n+                break;\n+            case HEAT:\n+                sp = command.getHeatingSetpoint();\n+                break;\n+            case COOL:\n+                sp = command.getCoolingSetpoint();\n+                break;\n+            default:\n+                return;\n+        }\n+\n+        if (sp == null) {\n+            return;\n+        }\n+\n+        // No need to re-set if it is the same value\n+        if (sp.equals(this.madokaSettings.getSetpoint())) {\n+            return;\n+        }\n+\n+        this.madokaSettings.setSetpoint(sp);\n+\n+        DecimalType dt = this.madokaSettings.getSetpoint();\n+        if (dt != null) {\n+            updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_SETPOINT),\n+                    dt);\n+        }\n+\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetOperationmodeCommand command) {\n+        if (command.getOperationMode() == null) {\n+            return;\n+        }\n+\n+        OperationMode newMode = command.getOperationMode();\n+        // If the mode has not changed - no need to refresh everything\n+        if (newMode == null || newMode.equals(this.madokaSettings.getOperationMode())) {\n+            return;\n+        }\n+\n+        this.madokaSettings.setOperationMode(newMode);\n+\n+        updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_OPERATION_MODE),\n+                new StringType(newMode.name()));\n+\n+        // For HomeKit channel, we need to map it to HomeKit supported strings\n+        switch (newMode) {\n+            case COOL:\n+                updateStateIfLinked(\n+                        new ChannelUID(getThing().getUID(),\n+                                DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                        new StringType(\"Cooling\"));\n+                break;\n+            case HEAT:\n+                updateStateIfLinked(\n+                        new ChannelUID(getThing().getUID(),\n+                                DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                        new StringType(\"Heating\"));\n+                break;\n+            default:\n+                break;\n+        }\n+\n+        // If this is the first channel update - then we set target = current mode\n+        if (this.madokaSettings.getHomekitTargetMode() == null) {\n+            String newHomekitTargetStatus = null;\n+\n+            // For HomeKit channel, we need to map it to HomeKit supported strings\n+            switch (newMode) {\n+                case COOL:\n+                    newHomekitTargetStatus = \"CoolOn\";\n+                    break;\n+                case HEAT:\n+                    newHomekitTargetStatus = \"HeatOn\";\n+                    break;\n+                default:\n+                    return;\n+            }\n+            this.madokaSettings.setHomekitTargetMode(newHomekitTargetStatus);\n+\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(),\n+                            DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE),\n+                    new StringType(newHomekitTargetStatus));\n+        }\n+\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetPowerstateCommand command) {\n+        if (command.isPowerState() == null) {\n+            return;\n+        }\n+\n+        OnOffType oot = command.isPowerState() ? OnOffType.ON : OnOffType.OFF;\n+\n+        if (oot.equals(this.madokaSettings.getOnOffState())) {\n+            return;\n+        }\n+\n+        this.madokaSettings.setOnOffState(oot);\n+\n+        updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_ONOFF_STATUS),\n+                oot);\n+\n+        if (oot.equals(OnOffType.OFF)) {\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(),\n+                            DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                    new StringType(\"Off\"));\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(),\n+                            DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE),\n+                    new StringType(\"Off\"));\n+        }\n+\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetIndoorOutoorTemperatures command) {\n+\n+        DecimalType newIndoorTemp = command.getIndoorTemperature();\n+        if (newIndoorTemp != null) {\n+            if (!newIndoorTemp.equals(this.madokaSettings.getIndoorTemperature())) {\n+                this.madokaSettings.setIndoorTemperature(newIndoorTemp);\n+                updateStateIfLinked(\n+                        new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_INDOOR_TEMPERATURE),\n+                        newIndoorTemp);\n+            }\n+        }\n+\n+        DecimalType newOutdoorTemp = command.getOutdoorTemperature();\n+        if (newOutdoorTemp == null) {\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_OUTDOOR_TEMPERATURE),\n+                    UnDefType.UNDEF);\n+        } else if (!newOutdoorTemp.equals(this.madokaSettings.getOutdoorTemperature())) {\n+            this.madokaSettings.setOutdoorTemperature(newOutdoorTemp);\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_OUTDOOR_TEMPERATURE),\n+                    newOutdoorTemp);\n+        }\n+\n+    }\n+\n+    @Override\n+    public void receivedResponse(SetPowerstateCommand command) {\n+\n+        updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_ONOFF_STATUS),\n+                command.getPowerState());\n+\n+        madokaSettings.setOnOffState(command.getPowerState());\n+\n+        if (command.getPowerState() == OnOffType.ON) {\n+            // Depending on the state\n+\n+            OperationMode operationMode = madokaSettings.getOperationMode();\n+            if (operationMode == null) {\n+                return;\n+            }\n+\n+            switch (operationMode) {\n+                case AUTO:\n+                    updateStateIfLinked(\n+                            new ChannelUID(getThing().getUID(),\n+                                    DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                            new StringType(\"Auto\"));\n+                    break;\n+                case HEAT:\n+                    updateStateIfLinked(\n+                            new ChannelUID(getThing().getUID(),\n+                                    DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                            new StringType(\"Heating\"));\n+                    break;\n+                case COOL:\n+                    updateStateIfLinked(\n+                            new ChannelUID(getThing().getUID(),\n+                                    DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                            new StringType(\"Cooling\"));\n+                    break;\n+                default: // Other Modes are not [yet] supported\n+                    break;\n+            }\n+        } else {\n+            updateStateIfLinked(\n+                    new ChannelUID(getThing().getUID(),\n+                            DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE),\n+                    new StringType(\"Off\"));\n+\n+        }\n+    }\n+\n+    @Override\n+    public void receivedResponse(SetSetpointCommand command) {\n+\n+        // The update depends on the mode - so if not set - skip\n+        OperationMode operationMode = this.madokaSettings.getOperationMode();\n+        if (operationMode == null) {\n+            return;\n+        }\n+\n+        switch (operationMode) {\n+            case HEAT:\n+                this.madokaSettings.setSetpoint(command.getHeatingSetpoint());\n+                break;\n+            case COOL:\n+                this.madokaSettings.setSetpoint(command.getCoolingSetpoint());\n+                break;\n+            case AUTO:\n+                // Here we don't really care if we are taking cooling or heating...\n+                this.madokaSettings.setSetpoint(command.getCoolingSetpoint());\n+                break;\n+            default:\n+                return;\n+        }\n+\n+        DecimalType dt = madokaSettings.getSetpoint();\n+        if (dt != null) {\n+            updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_SETPOINT),\n+                    dt);\n+        }\n+    }\n+\n+    /**\n+     * Received response to \"SetOperationmodeCommand\" command\n+     */\n+    @Override\n+    public void receivedResponse(SetOperationmodeCommand command) {\n+        this.madokaSettings.setOperationMode(command.getOperationMode());\n+        updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_OPERATION_MODE),\n+                new StringType(command.getOperationMode().toString()));\n+    }\n+\n+    /**\n+     * Received response to \"SetFanSpeed\" command\n+     */\n+    @Override\n+    public void receivedResponse(SetFanspeedCommand command) {\n+\n+        // The update depends on the mode - so if not set - skip\n+        OperationMode operationMode = this.madokaSettings.getOperationMode();\n+        if (operationMode == null) {\n+            return;\n+        }\n+\n+        FanSpeed fanSpeed;\n+        switch (operationMode) {\n+            case HEAT:\n+                fanSpeed = command.getHeatingFanSpeed();\n+                this.madokaSettings.setFanspeed(fanSpeed);\n+                break;\n+            case COOL:\n+                fanSpeed = command.getCoolingFanSpeed();\n+                this.madokaSettings.setFanspeed(fanSpeed);\n+                break;\n+            case AUTO:\n+                fanSpeed = command.getCoolingFanSpeed(); // Arbitrary cooling or heating... They are the same!\n+                this.madokaSettings.setFanspeed(fanSpeed);\n+                break;\n+            default:\n+                return;\n+        }\n+\n+        updateStateIfLinked(new ChannelUID(getThing().getUID(), DaikinMadokaBindingConstants.CHANNEL_ID_FAN_SPEED),\n+                new DecimalType(fanSpeed.value()));\n+    }\n+\n+    private void updateStateIfLinked(ChannelUID channelUID, State state) {\n+        if (isLinked(channelUID)) {", "originalCommit": "2488fba2b9710b12f8a92976ce1aff9dceebcdd6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5MzQ1NA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r426193454", "bodyText": "remove blank line", "author": "cpmeister", "createdAt": "2020-05-16T21:38:59Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java", "diffHunk": "@@ -0,0 +1,772 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.handler;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.common.NamedThreadFactory;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDevice.ConnectionState;\n+import org.openhab.binding.bluetooth.ConnectedBluetoothHandler;\n+import org.openhab.binding.bluetooth.daikinmadoka.DaikinMadokaBindingConstants;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.BRC1HUartProcessor;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.DaikinMadokaConfiguration;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaParsingException;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.FanSpeed;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.OperationMode;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaSettings;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetIndoorOutoorTemperatures;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetSetpointCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetVersionCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetSetpointCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DaikinMadokaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Benjamin Lafois - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements ResponseListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DaikinMadokaHandler.class);\n+\n+    private @Nullable DaikinMadokaConfiguration config;\n+\n+    private @Nullable ExecutorService commandExecutor;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    // UART Processor is in charge of reassembling chunks\n+    private BRC1HUartProcessor uartProcessor = new BRC1HUartProcessor(this);\n+\n+    private volatile @Nullable BRC1HCommand currentCommand = null;\n+\n+    private MadokaSettings madokaSettings = new MadokaSettings();\n+\n+    public DaikinMadokaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"[{}] Start initializing!\", super.thing.getUID().getId());\n+\n+        // Load Configuration\n+        config = getConfigAs(DaikinMadokaConfiguration.class);\n+        DaikinMadokaConfiguration c = config;\n+\n+        logger.debug(\"[{}] Parameter value [refreshInterval]: {}\", super.thing.getUID().getId(), c.refreshInterval);\n+        logger.debug(\"[{}] Parameter value [commandTimeout]: {}\", super.thing.getUID().getId(), c.commandTimeout);\n+\n+        if (getBridge() == null) {\n+            logger.debug(\"[{}] Bridge is null. Exiting.\", super.thing.getUID().getId());\n+            return;\n+        }\n+\n+        this.commandExecutor = Executors\n+                .newSingleThreadExecutor(new NamedThreadFactory(thing.getUID().getAsString(), true));\n+\n+        this.refreshJob = scheduler.scheduleWithFixedDelay(() -> {\n+            // It is useless to refresh version all the time ! Just once.\n+            if (this.madokaSettings.getCommunicationControllerVersion() == null\n+                    || this.madokaSettings.getRemoteControllerVersion() == null) {\n+                submitCommand(new GetVersionCommand());\n+            }\n+            submitCommand(new GetIndoorOutoorTemperatures());\n+            submitCommand(new GetOperationmodeCommand());\n+            submitCommand(new GetPowerstateCommand()); // always keep the \"GetPowerState\" aftern the \"GetOperationMode\"\n+            submitCommand(new GetSetpointCommand());\n+            submitCommand(new GetFanspeedCommand());\n+        }, 10, c.refreshInterval, TimeUnit.SECONDS);\n+\n+    }\n+\n+    @Override\n+    public void dispose() {\n+\n+        logger.debug(\"[{}] dispose()\", super.thing.getUID().getId());\n+\n+        dispose(refreshJob);\n+        dispose(commandExecutor);\n+        dispose(currentCommand);\n+\n+        // Unsubscribe to characteristic notifications\n+        if (this.device != null) {\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                @NonNull\n+                BluetoothCharacteristic c = charNotif;\n+                this.device.disableNotifications(c);\n+            }\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private static void dispose(@Nullable ExecutorService executor) {\n+        if (executor != null) {\n+            executor.shutdownNow();\n+        }\n+    }\n+\n+    private static void dispose(@Nullable ScheduledFuture<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private static void dispose(@Nullable BRC1HCommand command) {\n+        if (command != null) {\n+            // even if it already completed it doesn't really matter.\n+            // on the off chance that the commandExecutor is waiting on the command, we can wake it up and cause it to\n+            // terminate\n+            command.setState(BRC1HCommand.State.FAILED);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"[{}] Channel: {}, Command: {}\", super.thing.getUID().getId(), channelUID, command);\n+\n+        if (command instanceof RefreshType) {\n+            // The refresh commands are not supported in query mode.\n+            // The binding will notify updates on channels\n+            return;\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_SETPOINT:\n+                try {\n+                    QuantityType<?> setpoint = (QuantityType<?>) command;\n+                    DecimalType dt = new DecimalType(setpoint.intValue());\n+                    submitCommand(new SetSetpointCommand(dt, dt));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid temperature\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_ONOFF_STATUS:\n+                try {\n+                    OnOffType oot = (OnOffType) command;\n+                    submitCommand(new SetPowerstateCommand(oot));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid on/off status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_FAN_SPEED:\n+                try {\n+                    DecimalType fanSpeed = (DecimalType) command;\n+                    FanSpeed fs = FanSpeed.valueOf(fanSpeed.intValue());\n+                    submitCommand(new SetFanspeedCommand(fs, fs));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid FanSpeed status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_OPERATION_MODE:\n+                try {\n+                    StringType operationMode = (StringType) command;\n+                    OperationMode m = OperationMode.valueOf(operationMode.toFullString());\n+\n+                    submitCommand(new SetOperationmodeCommand(m));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid OPERATION MODE\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE:\n+                try {\n+                    StringType homekitOperationMode = (StringType) command;\n+\n+                    switch (homekitOperationMode.toString()) {\n+                        case \"Off\":\n+                            submitCommand(new SetPowerstateCommand(OnOffType.OFF));\n+                            break;\n+                        case \"CoolOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.COOL));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"HeatOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.HEAT));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"Auto\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.AUTO));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+\n+                } catch (Exception e) {\n+                    logger.info(\"Error while setting mode through HomeKIt received Mode\");\n+                }\n+            default:\n+                break;\n+\n+        }\n+", "originalCommit": "2488fba2b9710b12f8a92976ce1aff9dceebcdd6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjE5MzQ2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r426193462", "bodyText": "remove blank line", "author": "cpmeister", "createdAt": "2020-05-16T21:39:04Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java", "diffHunk": "@@ -0,0 +1,772 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.handler;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.common.NamedThreadFactory;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDevice.ConnectionState;\n+import org.openhab.binding.bluetooth.ConnectedBluetoothHandler;\n+import org.openhab.binding.bluetooth.daikinmadoka.DaikinMadokaBindingConstants;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.BRC1HUartProcessor;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.DaikinMadokaConfiguration;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaParsingException;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.FanSpeed;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.OperationMode;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaSettings;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetIndoorOutoorTemperatures;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetSetpointCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetVersionCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetSetpointCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DaikinMadokaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Benjamin Lafois - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements ResponseListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DaikinMadokaHandler.class);\n+\n+    private @Nullable DaikinMadokaConfiguration config;\n+\n+    private @Nullable ExecutorService commandExecutor;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    // UART Processor is in charge of reassembling chunks\n+    private BRC1HUartProcessor uartProcessor = new BRC1HUartProcessor(this);\n+\n+    private volatile @Nullable BRC1HCommand currentCommand = null;\n+\n+    private MadokaSettings madokaSettings = new MadokaSettings();\n+\n+    public DaikinMadokaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"[{}] Start initializing!\", super.thing.getUID().getId());\n+\n+        // Load Configuration\n+        config = getConfigAs(DaikinMadokaConfiguration.class);\n+        DaikinMadokaConfiguration c = config;\n+\n+        logger.debug(\"[{}] Parameter value [refreshInterval]: {}\", super.thing.getUID().getId(), c.refreshInterval);\n+        logger.debug(\"[{}] Parameter value [commandTimeout]: {}\", super.thing.getUID().getId(), c.commandTimeout);\n+\n+        if (getBridge() == null) {\n+            logger.debug(\"[{}] Bridge is null. Exiting.\", super.thing.getUID().getId());\n+            return;\n+        }\n+\n+        this.commandExecutor = Executors\n+                .newSingleThreadExecutor(new NamedThreadFactory(thing.getUID().getAsString(), true));\n+\n+        this.refreshJob = scheduler.scheduleWithFixedDelay(() -> {\n+            // It is useless to refresh version all the time ! Just once.\n+            if (this.madokaSettings.getCommunicationControllerVersion() == null\n+                    || this.madokaSettings.getRemoteControllerVersion() == null) {\n+                submitCommand(new GetVersionCommand());\n+            }\n+            submitCommand(new GetIndoorOutoorTemperatures());\n+            submitCommand(new GetOperationmodeCommand());\n+            submitCommand(new GetPowerstateCommand()); // always keep the \"GetPowerState\" aftern the \"GetOperationMode\"\n+            submitCommand(new GetSetpointCommand());\n+            submitCommand(new GetFanspeedCommand());\n+        }, 10, c.refreshInterval, TimeUnit.SECONDS);\n+\n+    }\n+\n+    @Override\n+    public void dispose() {\n+\n+        logger.debug(\"[{}] dispose()\", super.thing.getUID().getId());\n+\n+        dispose(refreshJob);\n+        dispose(commandExecutor);\n+        dispose(currentCommand);\n+\n+        // Unsubscribe to characteristic notifications\n+        if (this.device != null) {\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                @NonNull\n+                BluetoothCharacteristic c = charNotif;\n+                this.device.disableNotifications(c);\n+            }\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private static void dispose(@Nullable ExecutorService executor) {\n+        if (executor != null) {\n+            executor.shutdownNow();\n+        }\n+    }\n+\n+    private static void dispose(@Nullable ScheduledFuture<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private static void dispose(@Nullable BRC1HCommand command) {\n+        if (command != null) {\n+            // even if it already completed it doesn't really matter.\n+            // on the off chance that the commandExecutor is waiting on the command, we can wake it up and cause it to\n+            // terminate\n+            command.setState(BRC1HCommand.State.FAILED);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"[{}] Channel: {}, Command: {}\", super.thing.getUID().getId(), channelUID, command);\n+\n+        if (command instanceof RefreshType) {\n+            // The refresh commands are not supported in query mode.\n+            // The binding will notify updates on channels\n+            return;\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_SETPOINT:\n+                try {\n+                    QuantityType<?> setpoint = (QuantityType<?>) command;\n+                    DecimalType dt = new DecimalType(setpoint.intValue());\n+                    submitCommand(new SetSetpointCommand(dt, dt));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid temperature\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_ONOFF_STATUS:\n+                try {\n+                    OnOffType oot = (OnOffType) command;\n+                    submitCommand(new SetPowerstateCommand(oot));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid on/off status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_FAN_SPEED:\n+                try {\n+                    DecimalType fanSpeed = (DecimalType) command;\n+                    FanSpeed fs = FanSpeed.valueOf(fanSpeed.intValue());\n+                    submitCommand(new SetFanspeedCommand(fs, fs));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid FanSpeed status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_OPERATION_MODE:\n+                try {\n+                    StringType operationMode = (StringType) command;\n+                    OperationMode m = OperationMode.valueOf(operationMode.toFullString());\n+\n+                    submitCommand(new SetOperationmodeCommand(m));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid OPERATION MODE\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE:\n+                try {\n+                    StringType homekitOperationMode = (StringType) command;\n+\n+                    switch (homekitOperationMode.toString()) {\n+                        case \"Off\":\n+                            submitCommand(new SetPowerstateCommand(OnOffType.OFF));\n+                            break;\n+                        case \"CoolOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.COOL));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"HeatOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.HEAT));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"Auto\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.AUTO));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+\n+                } catch (Exception e) {\n+                    logger.info(\"Error while setting mode through HomeKIt received Mode\");\n+                }\n+            default:\n+                break;\n+", "originalCommit": "2488fba2b9710b12f8a92976ce1aff9dceebcdd6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "751974e914ddfb27b12027f4fdc7777f3a8efbae", "url": "https://github.com/openhab/openhab-addons/commit/751974e914ddfb27b12027f4fdc7777f3a8efbae", "message": "last round of PR fixes\n\nSigned-off-by: Benjamin Lafois <benjamin@lafois.com>", "committedDate": "2020-05-17T10:53:01Z", "type": "commit"}, {"oid": "d503ff1f49727c564ca7304ebe78d0f6ec7954d3", "url": "https://github.com/openhab/openhab-addons/commit/d503ff1f49727c564ca7304ebe78d0f6ec7954d3", "message": "Updated to 2.5.6\n\nSigned-off-by: Benjamin Lafois <benjamin@lafois.com>", "committedDate": "2020-05-19T13:05:13Z", "type": "commit"}, {"oid": "1e67d8672db35c5212cf6b37071645642047a1b8", "url": "https://github.com/openhab/openhab-addons/commit/1e67d8672db35c5212cf6b37071645642047a1b8", "message": "Fix OOB issue\n\nSigned-off-by: Benjamin Lafois <benjamin@lafois.com>", "committedDate": "2020-05-19T14:07:19Z", "type": "commit"}, {"oid": "9d1b0c4dcf46a82a80804d48a5d4127e15f7a398", "url": "https://github.com/openhab/openhab-addons/commit/9d1b0c4dcf46a82a80804d48a5d4127e15f7a398", "message": "fix parsing issues\n\nSigned-off-by: Benjamin Lafois <benjamin@lafois.com>", "committedDate": "2020-05-19T17:29:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY3MTc4OA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r427671788", "bodyText": "Please cache characteristic.getByteValue() in a local variable for reuse.", "author": "cpmeister", "createdAt": "2020-05-20T00:16:51Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java", "diffHunk": "@@ -0,0 +1,720 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.handler;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.common.NamedThreadFactory;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDevice.ConnectionState;\n+import org.openhab.binding.bluetooth.ConnectedBluetoothHandler;\n+import org.openhab.binding.bluetooth.daikinmadoka.DaikinMadokaBindingConstants;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.BRC1HUartProcessor;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.DaikinMadokaConfiguration;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaParsingException;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.FanSpeed;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.OperationMode;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaSettings;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetIndoorOutoorTemperatures;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetSetpointCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetVersionCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetSetpointCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DaikinMadokaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Benjamin Lafois - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements ResponseListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DaikinMadokaHandler.class);\n+\n+    private @Nullable DaikinMadokaConfiguration config;\n+\n+    private @Nullable ExecutorService commandExecutor;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    // UART Processor is in charge of reassembling chunks\n+    private BRC1HUartProcessor uartProcessor = new BRC1HUartProcessor(this);\n+\n+    private volatile @Nullable BRC1HCommand currentCommand = null;\n+\n+    private MadokaSettings madokaSettings = new MadokaSettings();\n+\n+    public DaikinMadokaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"[{}] Start initializing!\", super.thing.getUID().getId());\n+\n+        // Load Configuration\n+        config = getConfigAs(DaikinMadokaConfiguration.class);\n+        DaikinMadokaConfiguration c = config;\n+\n+        logger.debug(\"[{}] Parameter value [refreshInterval]: {}\", super.thing.getUID().getId(), c.refreshInterval);\n+        logger.debug(\"[{}] Parameter value [commandTimeout]: {}\", super.thing.getUID().getId(), c.commandTimeout);\n+\n+        if (getBridge() == null) {\n+            logger.debug(\"[{}] Bridge is null. Exiting.\", super.thing.getUID().getId());\n+            return;\n+        }\n+\n+        this.commandExecutor = Executors\n+                .newSingleThreadExecutor(new NamedThreadFactory(thing.getUID().getAsString(), true));\n+\n+        this.refreshJob = scheduler.scheduleWithFixedDelay(() -> {\n+            // It is useless to refresh version all the time ! Just once.\n+            if (this.madokaSettings.getCommunicationControllerVersion() == null\n+                    || this.madokaSettings.getRemoteControllerVersion() == null) {\n+                submitCommand(new GetVersionCommand());\n+            }\n+            submitCommand(new GetIndoorOutoorTemperatures());\n+            submitCommand(new GetOperationmodeCommand());\n+            submitCommand(new GetPowerstateCommand()); // always keep the \"GetPowerState\" aftern the \"GetOperationMode\"\n+            submitCommand(new GetSetpointCommand());\n+            submitCommand(new GetFanspeedCommand());\n+        }, 10, c.refreshInterval, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"[{}] dispose()\", super.thing.getUID().getId());\n+\n+        dispose(refreshJob);\n+        dispose(commandExecutor);\n+        dispose(currentCommand);\n+\n+        // Unsubscribe to characteristic notifications\n+        if (this.device != null) {\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                @NonNull\n+                BluetoothCharacteristic c = charNotif;\n+                this.device.disableNotifications(c);\n+            }\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private static void dispose(@Nullable ExecutorService executor) {\n+        if (executor != null) {\n+            executor.shutdownNow();\n+        }\n+    }\n+\n+    private static void dispose(@Nullable ScheduledFuture<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private static void dispose(@Nullable BRC1HCommand command) {\n+        if (command != null) {\n+            // even if it already completed it doesn't really matter.\n+            // on the off chance that the commandExecutor is waiting on the command, we can wake it up and cause it to\n+            // terminate\n+            command.setState(BRC1HCommand.State.FAILED);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"[{}] Channel: {}, Command: {}\", super.thing.getUID().getId(), channelUID, command);\n+\n+        if (command instanceof RefreshType) {\n+            // The refresh commands are not supported in query mode.\n+            // The binding will notify updates on channels\n+            return;\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_SETPOINT:\n+                try {\n+                    QuantityType<?> setpoint = (QuantityType<?>) command;\n+                    DecimalType dt = new DecimalType(setpoint.intValue());\n+                    submitCommand(new SetSetpointCommand(dt, dt));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid temperature\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_ONOFF_STATUS:\n+                try {\n+                    OnOffType oot = (OnOffType) command;\n+                    submitCommand(new SetPowerstateCommand(oot));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid on/off status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_FAN_SPEED:\n+                try {\n+                    DecimalType fanSpeed = (DecimalType) command;\n+                    FanSpeed fs = FanSpeed.valueOf(fanSpeed.intValue());\n+                    submitCommand(new SetFanspeedCommand(fs, fs));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid FanSpeed status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_OPERATION_MODE:\n+                try {\n+                    StringType operationMode = (StringType) command;\n+                    OperationMode m = OperationMode.valueOf(operationMode.toFullString());\n+\n+                    submitCommand(new SetOperationmodeCommand(m));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid OPERATION MODE\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE:\n+                try {\n+                    StringType homekitOperationMode = (StringType) command;\n+\n+                    switch (homekitOperationMode.toString()) {\n+                        case \"Off\":\n+                            submitCommand(new SetPowerstateCommand(OnOffType.OFF));\n+                            break;\n+                        case \"CoolOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.COOL));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"HeatOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.HEAT));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"Auto\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.AUTO));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+                } catch (Exception e) {\n+                    logger.info(\"Error while setting mode through HomeKIt received Mode\");\n+                }\n+            default:\n+                break;\n+        }\n+\n+    }\n+\n+    @Override\n+    public void onCharacteristicUpdate(BluetoothCharacteristic characteristic) {\n+        super.onCharacteristicUpdate(characteristic);\n+\n+        // Check that arguments are valid.\n+        if (characteristic.getUuid() == null) {\n+            return;\n+        }\n+\n+        // We are only interested in the Notify Characteristic of UART service\n+        if (!characteristic.getUuid().equals(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID)) {\n+            return;\n+        }\n+\n+        // A message cannot be null or have a 0-byte length\n+        if (characteristic.getByteValue() == null || characteristic.getByteValue().length == 0) {", "originalCommit": "9d1b0c4dcf46a82a80804d48a5d4127e15f7a398", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "81f8776065edef784fc706e09bf78129f1dc78b0", "url": "https://github.com/openhab/openhab-addons/commit/81f8776065edef784fc706e09bf78129f1dc78b0", "message": "Add HomeBridge support\n\nSigned-off-by: Benjamin Lafois <benjamin@lafois.com>", "committedDate": "2020-05-20T13:21:49Z", "type": "commit"}, {"oid": "7afcf800754f801051f6d5d9dc4e269d7e82cc4c", "url": "https://github.com/openhab/openhab-addons/commit/7afcf800754f801051f6d5d9dc4e269d7e82cc4c", "message": "Last changes following PR comments\n\nSigned-off-by: Benjamin Lafois <benjamin@lafois.com>", "committedDate": "2020-05-26T10:45:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2MzUyNA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r434163524", "bodyText": "remove empty line", "author": "kaikreuzer", "createdAt": "2020-06-02T20:42:20Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java", "diffHunk": "@@ -0,0 +1,782 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.handler;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.common.NamedThreadFactory;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDevice.ConnectionState;\n+import org.openhab.binding.bluetooth.ConnectedBluetoothHandler;\n+import org.openhab.binding.bluetooth.daikinmadoka.DaikinMadokaBindingConstants;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.BRC1HUartProcessor;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.DaikinMadokaConfiguration;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaParsingException;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.FanSpeed;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.OperationMode;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaSettings;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetIndoorOutoorTemperatures;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetSetpointCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetVersionCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetSetpointCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DaikinMadokaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Benjamin Lafois - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements ResponseListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DaikinMadokaHandler.class);\n+\n+    private @Nullable DaikinMadokaConfiguration config;\n+\n+    private @Nullable ExecutorService commandExecutor;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    // UART Processor is in charge of reassembling chunks\n+    private BRC1HUartProcessor uartProcessor = new BRC1HUartProcessor(this);\n+\n+    private volatile @Nullable BRC1HCommand currentCommand = null;\n+\n+    private MadokaSettings madokaSettings = new MadokaSettings();\n+\n+    public DaikinMadokaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"[{}] Start initializing!\", super.thing.getUID().getId());\n+\n+        // Load Configuration\n+        config = getConfigAs(DaikinMadokaConfiguration.class);\n+        DaikinMadokaConfiguration c = config;\n+\n+        logger.debug(\"[{}] Parameter value [refreshInterval]: {}\", super.thing.getUID().getId(), c.refreshInterval);\n+        logger.debug(\"[{}] Parameter value [commandTimeout]: {}\", super.thing.getUID().getId(), c.commandTimeout);\n+\n+        if (getBridge() == null) {\n+            logger.debug(\"[{}] Bridge is null. Exiting.\", super.thing.getUID().getId());\n+            return;\n+        }\n+\n+        this.commandExecutor = Executors\n+                .newSingleThreadExecutor(new NamedThreadFactory(thing.getUID().getAsString(), true));\n+\n+        this.refreshJob = scheduler.scheduleWithFixedDelay(() -> {\n+            // It is useless to refresh version all the time ! Just once.\n+            if (this.madokaSettings.getCommunicationControllerVersion() == null\n+                    || this.madokaSettings.getRemoteControllerVersion() == null) {\n+                submitCommand(new GetVersionCommand());\n+            }\n+            submitCommand(new GetIndoorOutoorTemperatures());\n+            submitCommand(new GetOperationmodeCommand());\n+            submitCommand(new GetPowerstateCommand()); // always keep the \"GetPowerState\" aftern the \"GetOperationMode\"\n+            submitCommand(new GetSetpointCommand());\n+            submitCommand(new GetFanspeedCommand());\n+        }, 10, c.refreshInterval, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"[{}] dispose()\", super.thing.getUID().getId());\n+\n+        dispose(refreshJob);\n+        dispose(commandExecutor);\n+        dispose(currentCommand);\n+\n+        // Unsubscribe to characteristic notifications\n+        if (this.device != null) {\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                @NonNull\n+                BluetoothCharacteristic c = charNotif;\n+                this.device.disableNotifications(c);\n+            }\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private static void dispose(@Nullable ExecutorService executor) {\n+        if (executor != null) {\n+            executor.shutdownNow();\n+        }\n+    }\n+\n+    private static void dispose(@Nullable ScheduledFuture<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private static void dispose(@Nullable BRC1HCommand command) {\n+        if (command != null) {\n+            // even if it already completed it doesn't really matter.\n+            // on the off chance that the commandExecutor is waiting on the command, we can wake it up and cause it to\n+            // terminate\n+            command.setState(BRC1HCommand.State.FAILED);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"[{}] Channel: {}, Command: {}\", super.thing.getUID().getId(), channelUID, command);\n+\n+        if (command instanceof RefreshType) {\n+            // The refresh commands are not supported in query mode.\n+            // The binding will notify updates on channels\n+            return;\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_SETPOINT:\n+                try {\n+                    QuantityType<?> setpoint = (QuantityType<?>) command;\n+                    DecimalType dt = new DecimalType(setpoint.intValue());\n+                    submitCommand(new SetSetpointCommand(dt, dt));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid temperature\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_ONOFF_STATUS:\n+                try {\n+                    OnOffType oot = (OnOffType) command;\n+                    submitCommand(new SetPowerstateCommand(oot));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid on/off status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_FAN_SPEED:\n+                try {\n+                    DecimalType fanSpeed = (DecimalType) command;\n+                    FanSpeed fs = FanSpeed.valueOf(fanSpeed.intValue());\n+                    submitCommand(new SetFanspeedCommand(fs, fs));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid FanSpeed status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_OPERATION_MODE:\n+                try {\n+                    StringType operationMode = (StringType) command;\n+                    OperationMode m = OperationMode.valueOf(operationMode.toFullString());\n+\n+                    submitCommand(new SetOperationmodeCommand(m));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid OPERATION MODE\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_HOMEBRIDGE_MODE:\n+                try {\n+                    // Homebridge are discrete value different from Daikin\n+                    // 0 - Off\n+                    // 1 - Heating\n+                    // 2 - Cooling\n+                    // 3 - Auto\n+                    DecimalType homebridgeMode = (DecimalType) command;\n+                    switch (homebridgeMode.intValue()) {\n+                        case 0: // Off\n+                            submitCommand(new SetPowerstateCommand(OnOffType.OFF));\n+                            break;\n+                        case 1: // Heating\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.HEAT));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case 2: // Cooling\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.COOL));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case 3: // Auto\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.AUTO));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        default: // Invalid Value\n+                            logger.info(\"Invalid value received for channel {}. Ignoring.\", channelUID);\n+                            break;\n+                    }\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid HOMEBRIDGE OPERATION MODE\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE:\n+                try {\n+                    StringType homekitOperationMode = (StringType) command;\n+\n+                    switch (homekitOperationMode.toString()) {\n+                        case \"Off\":\n+                            submitCommand(new SetPowerstateCommand(OnOffType.OFF));\n+                            break;\n+                        case \"CoolOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.COOL));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"HeatOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.HEAT));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"Auto\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.AUTO));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+                } catch (Exception e) {\n+                    logger.info(\"Error while setting mode through HomeKIt received Mode\");\n+                }\n+            default:\n+                break;\n+        }\n+\n+    }\n+\n+    @Override\n+    public void onCharacteristicUpdate(BluetoothCharacteristic characteristic) {\n+        super.onCharacteristicUpdate(characteristic);\n+\n+        // Check that arguments are valid.\n+        if (characteristic.getUuid() == null) {\n+            return;\n+        }\n+\n+        // We are only interested in the Notify Characteristic of UART service\n+        if (!characteristic.getUuid().equals(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID)) {\n+            return;\n+        }\n+\n+        // A message cannot be null or have a 0-byte length\n+        byte[] msgBytes = characteristic.getByteValue();\n+        if (msgBytes == null || msgBytes.length == 0) {\n+            return;\n+        }\n+\n+        this.uartProcessor.chunkReceived(msgBytes);\n+    }\n+\n+    private void submitCommand(BRC1HCommand command) {\n+        Executor executor = commandExecutor;\n+\n+        if (executor != null) {\n+            executor.execute(() -> processCommand(command));\n+        }\n+    }\n+\n+    private void processCommand(BRC1HCommand command) {\n+        logger.debug(\"[{}] ProcessCommand {}\", super.thing.getUID().getId(), command.getClass().getSimpleName());\n+\n+        try {\n+            currentCommand = command;\n+            uartProcessor.abandon();\n+\n+            if (device == null || device.getConnectionState() != ConnectionState.CONNECTED) {\n+                logger.debug(\"Unable to send command {} to device {}: not connected\",\n+                        command.getClass().getSimpleName(), address);\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            if (!resolved) {\n+                logger.debug(\"Unable to send command {} to device {}: services not resolved\",\n+                        command.getClass().getSimpleName(), device.getAddress());\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            BluetoothCharacteristic charWrite = device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_WRITE_WITHOUT_RESPONSE_UUID);\n+            if (charWrite == null) {\n+                logger.warn(\"Unable to execute {}. Characteristic '{}' could not be found.\",\n+                        command.getClass().getSimpleName(),\n+                        DaikinMadokaBindingConstants.CHAR_WRITE_WITHOUT_RESPONSE_UUID);\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                device.enableNotifications(charNotif);\n+            }\n+\n+            charWrite.setValue(command.getRequest());\n+            command.setState(BRC1HCommand.State.ENQUEUED);\n+            device.writeCharacteristic(charWrite);\n+\n+            if (this.config != null) {\n+                if (!command.awaitStateChange(this.config.commandTimeout, TimeUnit.MILLISECONDS,\n+                        BRC1HCommand.State.SUCCEEDED, BRC1HCommand.State.FAILED)) {\n+                    logger.debug(\"Command {} to device {} timed out\", command, device.getAddress());\n+                    command.setState(BRC1HCommand.State.FAILED);\n+                }\n+            }\n+", "originalCommit": "7afcf800754f801051f6d5d9dc4e269d7e82cc4c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NDUwOA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r434164508", "bodyText": "Can you be more specific here?\nNormally, you should not do such a \"catch all\", but rather let exceptions that are unexpected bubble up the stack.", "author": "kaikreuzer", "createdAt": "2020-06-02T20:44:19Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java", "diffHunk": "@@ -0,0 +1,782 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.handler;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.common.NamedThreadFactory;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDevice.ConnectionState;\n+import org.openhab.binding.bluetooth.ConnectedBluetoothHandler;\n+import org.openhab.binding.bluetooth.daikinmadoka.DaikinMadokaBindingConstants;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.BRC1HUartProcessor;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.DaikinMadokaConfiguration;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaParsingException;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.FanSpeed;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.OperationMode;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaSettings;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetIndoorOutoorTemperatures;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetSetpointCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetVersionCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetSetpointCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DaikinMadokaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Benjamin Lafois - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements ResponseListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DaikinMadokaHandler.class);\n+\n+    private @Nullable DaikinMadokaConfiguration config;\n+\n+    private @Nullable ExecutorService commandExecutor;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    // UART Processor is in charge of reassembling chunks\n+    private BRC1HUartProcessor uartProcessor = new BRC1HUartProcessor(this);\n+\n+    private volatile @Nullable BRC1HCommand currentCommand = null;\n+\n+    private MadokaSettings madokaSettings = new MadokaSettings();\n+\n+    public DaikinMadokaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"[{}] Start initializing!\", super.thing.getUID().getId());\n+\n+        // Load Configuration\n+        config = getConfigAs(DaikinMadokaConfiguration.class);\n+        DaikinMadokaConfiguration c = config;\n+\n+        logger.debug(\"[{}] Parameter value [refreshInterval]: {}\", super.thing.getUID().getId(), c.refreshInterval);\n+        logger.debug(\"[{}] Parameter value [commandTimeout]: {}\", super.thing.getUID().getId(), c.commandTimeout);\n+\n+        if (getBridge() == null) {\n+            logger.debug(\"[{}] Bridge is null. Exiting.\", super.thing.getUID().getId());\n+            return;\n+        }\n+\n+        this.commandExecutor = Executors\n+                .newSingleThreadExecutor(new NamedThreadFactory(thing.getUID().getAsString(), true));\n+\n+        this.refreshJob = scheduler.scheduleWithFixedDelay(() -> {\n+            // It is useless to refresh version all the time ! Just once.\n+            if (this.madokaSettings.getCommunicationControllerVersion() == null\n+                    || this.madokaSettings.getRemoteControllerVersion() == null) {\n+                submitCommand(new GetVersionCommand());\n+            }\n+            submitCommand(new GetIndoorOutoorTemperatures());\n+            submitCommand(new GetOperationmodeCommand());\n+            submitCommand(new GetPowerstateCommand()); // always keep the \"GetPowerState\" aftern the \"GetOperationMode\"\n+            submitCommand(new GetSetpointCommand());\n+            submitCommand(new GetFanspeedCommand());\n+        }, 10, c.refreshInterval, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"[{}] dispose()\", super.thing.getUID().getId());\n+\n+        dispose(refreshJob);\n+        dispose(commandExecutor);\n+        dispose(currentCommand);\n+\n+        // Unsubscribe to characteristic notifications\n+        if (this.device != null) {\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                @NonNull\n+                BluetoothCharacteristic c = charNotif;\n+                this.device.disableNotifications(c);\n+            }\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private static void dispose(@Nullable ExecutorService executor) {\n+        if (executor != null) {\n+            executor.shutdownNow();\n+        }\n+    }\n+\n+    private static void dispose(@Nullable ScheduledFuture<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private static void dispose(@Nullable BRC1HCommand command) {\n+        if (command != null) {\n+            // even if it already completed it doesn't really matter.\n+            // on the off chance that the commandExecutor is waiting on the command, we can wake it up and cause it to\n+            // terminate\n+            command.setState(BRC1HCommand.State.FAILED);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"[{}] Channel: {}, Command: {}\", super.thing.getUID().getId(), channelUID, command);\n+\n+        if (command instanceof RefreshType) {\n+            // The refresh commands are not supported in query mode.\n+            // The binding will notify updates on channels\n+            return;\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_SETPOINT:\n+                try {\n+                    QuantityType<?> setpoint = (QuantityType<?>) command;\n+                    DecimalType dt = new DecimalType(setpoint.intValue());\n+                    submitCommand(new SetSetpointCommand(dt, dt));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid temperature\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_ONOFF_STATUS:\n+                try {\n+                    OnOffType oot = (OnOffType) command;\n+                    submitCommand(new SetPowerstateCommand(oot));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid on/off status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_FAN_SPEED:\n+                try {\n+                    DecimalType fanSpeed = (DecimalType) command;\n+                    FanSpeed fs = FanSpeed.valueOf(fanSpeed.intValue());\n+                    submitCommand(new SetFanspeedCommand(fs, fs));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid FanSpeed status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_OPERATION_MODE:\n+                try {\n+                    StringType operationMode = (StringType) command;\n+                    OperationMode m = OperationMode.valueOf(operationMode.toFullString());\n+\n+                    submitCommand(new SetOperationmodeCommand(m));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid OPERATION MODE\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_HOMEBRIDGE_MODE:\n+                try {\n+                    // Homebridge are discrete value different from Daikin\n+                    // 0 - Off\n+                    // 1 - Heating\n+                    // 2 - Cooling\n+                    // 3 - Auto\n+                    DecimalType homebridgeMode = (DecimalType) command;\n+                    switch (homebridgeMode.intValue()) {\n+                        case 0: // Off\n+                            submitCommand(new SetPowerstateCommand(OnOffType.OFF));\n+                            break;\n+                        case 1: // Heating\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.HEAT));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case 2: // Cooling\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.COOL));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case 3: // Auto\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.AUTO));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        default: // Invalid Value\n+                            logger.info(\"Invalid value received for channel {}. Ignoring.\", channelUID);\n+                            break;\n+                    }\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid HOMEBRIDGE OPERATION MODE\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE:\n+                try {\n+                    StringType homekitOperationMode = (StringType) command;\n+\n+                    switch (homekitOperationMode.toString()) {\n+                        case \"Off\":\n+                            submitCommand(new SetPowerstateCommand(OnOffType.OFF));\n+                            break;\n+                        case \"CoolOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.COOL));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"HeatOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.HEAT));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"Auto\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.AUTO));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+                } catch (Exception e) {\n+                    logger.info(\"Error while setting mode through HomeKIt received Mode\");\n+                }\n+            default:\n+                break;\n+        }\n+\n+    }\n+\n+    @Override\n+    public void onCharacteristicUpdate(BluetoothCharacteristic characteristic) {\n+        super.onCharacteristicUpdate(characteristic);\n+\n+        // Check that arguments are valid.\n+        if (characteristic.getUuid() == null) {\n+            return;\n+        }\n+\n+        // We are only interested in the Notify Characteristic of UART service\n+        if (!characteristic.getUuid().equals(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID)) {\n+            return;\n+        }\n+\n+        // A message cannot be null or have a 0-byte length\n+        byte[] msgBytes = characteristic.getByteValue();\n+        if (msgBytes == null || msgBytes.length == 0) {\n+            return;\n+        }\n+\n+        this.uartProcessor.chunkReceived(msgBytes);\n+    }\n+\n+    private void submitCommand(BRC1HCommand command) {\n+        Executor executor = commandExecutor;\n+\n+        if (executor != null) {\n+            executor.execute(() -> processCommand(command));\n+        }\n+    }\n+\n+    private void processCommand(BRC1HCommand command) {\n+        logger.debug(\"[{}] ProcessCommand {}\", super.thing.getUID().getId(), command.getClass().getSimpleName());\n+\n+        try {\n+            currentCommand = command;\n+            uartProcessor.abandon();\n+\n+            if (device == null || device.getConnectionState() != ConnectionState.CONNECTED) {\n+                logger.debug(\"Unable to send command {} to device {}: not connected\",\n+                        command.getClass().getSimpleName(), address);\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            if (!resolved) {\n+                logger.debug(\"Unable to send command {} to device {}: services not resolved\",\n+                        command.getClass().getSimpleName(), device.getAddress());\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            BluetoothCharacteristic charWrite = device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_WRITE_WITHOUT_RESPONSE_UUID);\n+            if (charWrite == null) {\n+                logger.warn(\"Unable to execute {}. Characteristic '{}' could not be found.\",\n+                        command.getClass().getSimpleName(),\n+                        DaikinMadokaBindingConstants.CHAR_WRITE_WITHOUT_RESPONSE_UUID);\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                device.enableNotifications(charNotif);\n+            }\n+\n+            charWrite.setValue(command.getRequest());\n+            command.setState(BRC1HCommand.State.ENQUEUED);\n+            device.writeCharacteristic(charWrite);\n+\n+            if (this.config != null) {\n+                if (!command.awaitStateChange(this.config.commandTimeout, TimeUnit.MILLISECONDS,\n+                        BRC1HCommand.State.SUCCEEDED, BRC1HCommand.State.FAILED)) {\n+                    logger.debug(\"Command {} to device {} timed out\", command, device.getAddress());\n+                    command.setState(BRC1HCommand.State.FAILED);\n+                }\n+            }\n+\n+        } catch (Exception e) {", "originalCommit": "7afcf800754f801051f6d5d9dc4e269d7e82cc4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc5NDYwMA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r434794600", "bodyText": "The idea here is I need to make the command terminate (execute the finally block), whatever happens. Any suggestion to achieve this goal ?", "author": "blafois", "createdAt": "2020-06-03T19:13:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NDUwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgzMzcwMA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r434833700", "bodyText": "The finally does not look that important to me.\nLooking at it, I would rather suggest to not have currentCommand as a field in the class. Its only purpose seems to be to have a handle for interrupting it in case of a dispose call. But for this it would be cleaner to simply shut down the executor and tell it to interrupt existing jobs - so you could cancel the currentCommand within the InterruptedException catch clause.", "author": "kaikreuzer", "createdAt": "2020-06-03T20:27:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NDUwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc0NDExMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r442744111", "bodyText": "I still need the \"currentCommand\" to track it somewhere else, so I implemented a trick to let the exception bubble up.", "author": "blafois", "createdAt": "2020-06-19T09:51:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NDUwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NTA1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r434165056", "bodyText": "still a todo?", "author": "kaikreuzer", "createdAt": "2020-06-02T20:45:25Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java", "diffHunk": "@@ -0,0 +1,782 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.handler;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.common.NamedThreadFactory;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDevice.ConnectionState;\n+import org.openhab.binding.bluetooth.ConnectedBluetoothHandler;\n+import org.openhab.binding.bluetooth.daikinmadoka.DaikinMadokaBindingConstants;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.BRC1HUartProcessor;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.DaikinMadokaConfiguration;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaParsingException;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.FanSpeed;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.OperationMode;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaSettings;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetIndoorOutoorTemperatures;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetSetpointCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetVersionCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetSetpointCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DaikinMadokaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Benjamin Lafois - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements ResponseListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DaikinMadokaHandler.class);\n+\n+    private @Nullable DaikinMadokaConfiguration config;\n+\n+    private @Nullable ExecutorService commandExecutor;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    // UART Processor is in charge of reassembling chunks\n+    private BRC1HUartProcessor uartProcessor = new BRC1HUartProcessor(this);\n+\n+    private volatile @Nullable BRC1HCommand currentCommand = null;\n+\n+    private MadokaSettings madokaSettings = new MadokaSettings();\n+\n+    public DaikinMadokaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"[{}] Start initializing!\", super.thing.getUID().getId());\n+\n+        // Load Configuration\n+        config = getConfigAs(DaikinMadokaConfiguration.class);\n+        DaikinMadokaConfiguration c = config;\n+\n+        logger.debug(\"[{}] Parameter value [refreshInterval]: {}\", super.thing.getUID().getId(), c.refreshInterval);\n+        logger.debug(\"[{}] Parameter value [commandTimeout]: {}\", super.thing.getUID().getId(), c.commandTimeout);\n+\n+        if (getBridge() == null) {\n+            logger.debug(\"[{}] Bridge is null. Exiting.\", super.thing.getUID().getId());\n+            return;\n+        }\n+\n+        this.commandExecutor = Executors\n+                .newSingleThreadExecutor(new NamedThreadFactory(thing.getUID().getAsString(), true));\n+\n+        this.refreshJob = scheduler.scheduleWithFixedDelay(() -> {\n+            // It is useless to refresh version all the time ! Just once.\n+            if (this.madokaSettings.getCommunicationControllerVersion() == null\n+                    || this.madokaSettings.getRemoteControllerVersion() == null) {\n+                submitCommand(new GetVersionCommand());\n+            }\n+            submitCommand(new GetIndoorOutoorTemperatures());\n+            submitCommand(new GetOperationmodeCommand());\n+            submitCommand(new GetPowerstateCommand()); // always keep the \"GetPowerState\" aftern the \"GetOperationMode\"\n+            submitCommand(new GetSetpointCommand());\n+            submitCommand(new GetFanspeedCommand());\n+        }, 10, c.refreshInterval, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"[{}] dispose()\", super.thing.getUID().getId());\n+\n+        dispose(refreshJob);\n+        dispose(commandExecutor);\n+        dispose(currentCommand);\n+\n+        // Unsubscribe to characteristic notifications\n+        if (this.device != null) {\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                @NonNull\n+                BluetoothCharacteristic c = charNotif;\n+                this.device.disableNotifications(c);\n+            }\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private static void dispose(@Nullable ExecutorService executor) {\n+        if (executor != null) {\n+            executor.shutdownNow();\n+        }\n+    }\n+\n+    private static void dispose(@Nullable ScheduledFuture<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private static void dispose(@Nullable BRC1HCommand command) {\n+        if (command != null) {\n+            // even if it already completed it doesn't really matter.\n+            // on the off chance that the commandExecutor is waiting on the command, we can wake it up and cause it to\n+            // terminate\n+            command.setState(BRC1HCommand.State.FAILED);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"[{}] Channel: {}, Command: {}\", super.thing.getUID().getId(), channelUID, command);\n+\n+        if (command instanceof RefreshType) {\n+            // The refresh commands are not supported in query mode.\n+            // The binding will notify updates on channels\n+            return;\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_SETPOINT:\n+                try {\n+                    QuantityType<?> setpoint = (QuantityType<?>) command;\n+                    DecimalType dt = new DecimalType(setpoint.intValue());\n+                    submitCommand(new SetSetpointCommand(dt, dt));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid temperature\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_ONOFF_STATUS:\n+                try {\n+                    OnOffType oot = (OnOffType) command;\n+                    submitCommand(new SetPowerstateCommand(oot));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid on/off status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_FAN_SPEED:\n+                try {\n+                    DecimalType fanSpeed = (DecimalType) command;\n+                    FanSpeed fs = FanSpeed.valueOf(fanSpeed.intValue());\n+                    submitCommand(new SetFanspeedCommand(fs, fs));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid FanSpeed status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_OPERATION_MODE:\n+                try {\n+                    StringType operationMode = (StringType) command;\n+                    OperationMode m = OperationMode.valueOf(operationMode.toFullString());\n+\n+                    submitCommand(new SetOperationmodeCommand(m));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid OPERATION MODE\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_HOMEBRIDGE_MODE:\n+                try {\n+                    // Homebridge are discrete value different from Daikin\n+                    // 0 - Off\n+                    // 1 - Heating\n+                    // 2 - Cooling\n+                    // 3 - Auto\n+                    DecimalType homebridgeMode = (DecimalType) command;\n+                    switch (homebridgeMode.intValue()) {\n+                        case 0: // Off\n+                            submitCommand(new SetPowerstateCommand(OnOffType.OFF));\n+                            break;\n+                        case 1: // Heating\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.HEAT));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case 2: // Cooling\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.COOL));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case 3: // Auto\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.AUTO));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        default: // Invalid Value\n+                            logger.info(\"Invalid value received for channel {}. Ignoring.\", channelUID);\n+                            break;\n+                    }\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid HOMEBRIDGE OPERATION MODE\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE:\n+                try {\n+                    StringType homekitOperationMode = (StringType) command;\n+\n+                    switch (homekitOperationMode.toString()) {\n+                        case \"Off\":\n+                            submitCommand(new SetPowerstateCommand(OnOffType.OFF));\n+                            break;\n+                        case \"CoolOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.COOL));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"HeatOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.HEAT));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"Auto\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.AUTO));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+                } catch (Exception e) {\n+                    logger.info(\"Error while setting mode through HomeKIt received Mode\");\n+                }\n+            default:\n+                break;\n+        }\n+\n+    }\n+\n+    @Override\n+    public void onCharacteristicUpdate(BluetoothCharacteristic characteristic) {\n+        super.onCharacteristicUpdate(characteristic);\n+\n+        // Check that arguments are valid.\n+        if (characteristic.getUuid() == null) {\n+            return;\n+        }\n+\n+        // We are only interested in the Notify Characteristic of UART service\n+        if (!characteristic.getUuid().equals(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID)) {\n+            return;\n+        }\n+\n+        // A message cannot be null or have a 0-byte length\n+        byte[] msgBytes = characteristic.getByteValue();\n+        if (msgBytes == null || msgBytes.length == 0) {\n+            return;\n+        }\n+\n+        this.uartProcessor.chunkReceived(msgBytes);\n+    }\n+\n+    private void submitCommand(BRC1HCommand command) {\n+        Executor executor = commandExecutor;\n+\n+        if (executor != null) {\n+            executor.execute(() -> processCommand(command));\n+        }\n+    }\n+\n+    private void processCommand(BRC1HCommand command) {\n+        logger.debug(\"[{}] ProcessCommand {}\", super.thing.getUID().getId(), command.getClass().getSimpleName());\n+\n+        try {\n+            currentCommand = command;\n+            uartProcessor.abandon();\n+\n+            if (device == null || device.getConnectionState() != ConnectionState.CONNECTED) {\n+                logger.debug(\"Unable to send command {} to device {}: not connected\",\n+                        command.getClass().getSimpleName(), address);\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            if (!resolved) {\n+                logger.debug(\"Unable to send command {} to device {}: services not resolved\",\n+                        command.getClass().getSimpleName(), device.getAddress());\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            BluetoothCharacteristic charWrite = device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_WRITE_WITHOUT_RESPONSE_UUID);\n+            if (charWrite == null) {\n+                logger.warn(\"Unable to execute {}. Characteristic '{}' could not be found.\",\n+                        command.getClass().getSimpleName(),\n+                        DaikinMadokaBindingConstants.CHAR_WRITE_WITHOUT_RESPONSE_UUID);\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                device.enableNotifications(charNotif);\n+            }\n+\n+            charWrite.setValue(command.getRequest());\n+            command.setState(BRC1HCommand.State.ENQUEUED);\n+            device.writeCharacteristic(charWrite);\n+\n+            if (this.config != null) {\n+                if (!command.awaitStateChange(this.config.commandTimeout, TimeUnit.MILLISECONDS,\n+                        BRC1HCommand.State.SUCCEEDED, BRC1HCommand.State.FAILED)) {\n+                    logger.debug(\"Command {} to device {} timed out\", command, device.getAddress());\n+                    command.setState(BRC1HCommand.State.FAILED);\n+                }\n+            }\n+\n+        } catch (Exception e) {\n+            logger.debug(\"Error\", e);\n+        } finally {\n+            logger.debug(\"Command final state: {}\", command.getState());\n+            currentCommand = null;\n+        }\n+\n+        try {\n+            Thread.sleep(200);\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+        }\n+    }\n+\n+    @Override\n+    public void onCharacteristicWriteComplete(BluetoothCharacteristic characteristic,\n+            BluetoothCompletionStatus status) {\n+        super.onCharacteristicWriteComplete(characteristic, status);\n+\n+        byte[] request = characteristic.getByteValue();\n+        BRC1HCommand command = currentCommand;\n+\n+        if (command != null) {\n+            if (!Arrays.equals(request, command.getRequest())) {\n+                logger.debug(\"Write completed for unknown command\");\n+                return;\n+            }\n+            switch (status) {\n+                case SUCCESS:\n+                    command.setState(BRC1HCommand.State.SENT);\n+                    break;\n+                case ERROR:\n+                    command.setState(BRC1HCommand.State.FAILED);\n+                    break;\n+            }\n+        } else {\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"No command found that matches request {}\", HexUtils.bytesToHex(request));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * When the method is triggered, it means that all message chunks have been received, re-assembled in the right\n+     * order and that the payload is ready to be processed.\n+     */\n+    @Override\n+    public void receivedResponse(byte[] response) {\n+        logger.debug(\"Received Response\");\n+        BRC1HCommand command = currentCommand;\n+\n+        if (command == null) {\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"No command present to handle response {}\", HexUtils.bytesToHex(response));\n+            }\n+        } else {\n+            try {\n+                command.handleResponse(scheduler, this, MadokaMessage.parse(response));\n+            } catch (MadokaParsingException e) {\n+                logger.debug(\"Response message could not be parsed correctly ({}): {}. Reason: {}\",\n+                        command.getClass().getSimpleName(), HexUtils.bytesToHex(response), e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetVersionCommand command) {\n+        String commCtrlVers = command.getCommunicationControllerVersion();\n+        if (commCtrlVers != null) {\n+            this.madokaSettings.setCommunicationControllerVersion(commCtrlVers);\n+            updateStateIfLinked(DaikinMadokaBindingConstants.CHANNEL_ID_COMMUNICATION_CONTROLLER_VERSION,\n+                    new StringType(commCtrlVers));\n+        }\n+\n+        String remoteCtrlVers = command.getRemoteControllerVersion();\n+        if (remoteCtrlVers != null) {\n+            this.madokaSettings.setRemoteControllerVersion(remoteCtrlVers);\n+            updateStateIfLinked(DaikinMadokaBindingConstants.CHANNEL_ID_REMOTE_CONTROLLER_VERSION,\n+                    new StringType(remoteCtrlVers));\n+        }\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetFanspeedCommand command) {\n+        if (command.getCoolingFanSpeed() == null || command.getHeatingFanSpeed() == null) {\n+            return;\n+        }\n+\n+        // We need the current operation mode to determine which Fan Speed we use (cooling or heating)\n+        OperationMode operationMode = this.madokaSettings.getOperationMode();\n+        if (operationMode == null) {\n+            return;\n+        }\n+\n+        FanSpeed fs;\n+\n+        switch (operationMode) {\n+            case AUTO:\n+                // TODO confirm it works in all conditions", "originalCommit": "7afcf800754f801051f6d5d9dc4e269d7e82cc4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc5NTA1NA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r434795054", "bodyText": "It is just because at time of writing, i was using my AC in heating mode, not auto - now in auto ! :-)", "author": "blafois", "createdAt": "2020-06-03T19:14:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NTA1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NTIyOA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r434165228", "bodyText": "still a todo?", "author": "kaikreuzer", "createdAt": "2020-06-02T20:45:44Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java", "diffHunk": "@@ -0,0 +1,782 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.handler;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.common.NamedThreadFactory;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDevice.ConnectionState;\n+import org.openhab.binding.bluetooth.ConnectedBluetoothHandler;\n+import org.openhab.binding.bluetooth.daikinmadoka.DaikinMadokaBindingConstants;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.BRC1HUartProcessor;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.DaikinMadokaConfiguration;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaParsingException;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.FanSpeed;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.OperationMode;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaSettings;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetIndoorOutoorTemperatures;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetSetpointCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetVersionCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetSetpointCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DaikinMadokaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Benjamin Lafois - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements ResponseListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DaikinMadokaHandler.class);\n+\n+    private @Nullable DaikinMadokaConfiguration config;\n+\n+    private @Nullable ExecutorService commandExecutor;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    // UART Processor is in charge of reassembling chunks\n+    private BRC1HUartProcessor uartProcessor = new BRC1HUartProcessor(this);\n+\n+    private volatile @Nullable BRC1HCommand currentCommand = null;\n+\n+    private MadokaSettings madokaSettings = new MadokaSettings();\n+\n+    public DaikinMadokaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"[{}] Start initializing!\", super.thing.getUID().getId());\n+\n+        // Load Configuration\n+        config = getConfigAs(DaikinMadokaConfiguration.class);\n+        DaikinMadokaConfiguration c = config;\n+\n+        logger.debug(\"[{}] Parameter value [refreshInterval]: {}\", super.thing.getUID().getId(), c.refreshInterval);\n+        logger.debug(\"[{}] Parameter value [commandTimeout]: {}\", super.thing.getUID().getId(), c.commandTimeout);\n+\n+        if (getBridge() == null) {\n+            logger.debug(\"[{}] Bridge is null. Exiting.\", super.thing.getUID().getId());\n+            return;\n+        }\n+\n+        this.commandExecutor = Executors\n+                .newSingleThreadExecutor(new NamedThreadFactory(thing.getUID().getAsString(), true));\n+\n+        this.refreshJob = scheduler.scheduleWithFixedDelay(() -> {\n+            // It is useless to refresh version all the time ! Just once.\n+            if (this.madokaSettings.getCommunicationControllerVersion() == null\n+                    || this.madokaSettings.getRemoteControllerVersion() == null) {\n+                submitCommand(new GetVersionCommand());\n+            }\n+            submitCommand(new GetIndoorOutoorTemperatures());\n+            submitCommand(new GetOperationmodeCommand());\n+            submitCommand(new GetPowerstateCommand()); // always keep the \"GetPowerState\" aftern the \"GetOperationMode\"\n+            submitCommand(new GetSetpointCommand());\n+            submitCommand(new GetFanspeedCommand());\n+        }, 10, c.refreshInterval, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"[{}] dispose()\", super.thing.getUID().getId());\n+\n+        dispose(refreshJob);\n+        dispose(commandExecutor);\n+        dispose(currentCommand);\n+\n+        // Unsubscribe to characteristic notifications\n+        if (this.device != null) {\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                @NonNull\n+                BluetoothCharacteristic c = charNotif;\n+                this.device.disableNotifications(c);\n+            }\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private static void dispose(@Nullable ExecutorService executor) {\n+        if (executor != null) {\n+            executor.shutdownNow();\n+        }\n+    }\n+\n+    private static void dispose(@Nullable ScheduledFuture<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private static void dispose(@Nullable BRC1HCommand command) {\n+        if (command != null) {\n+            // even if it already completed it doesn't really matter.\n+            // on the off chance that the commandExecutor is waiting on the command, we can wake it up and cause it to\n+            // terminate\n+            command.setState(BRC1HCommand.State.FAILED);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"[{}] Channel: {}, Command: {}\", super.thing.getUID().getId(), channelUID, command);\n+\n+        if (command instanceof RefreshType) {\n+            // The refresh commands are not supported in query mode.\n+            // The binding will notify updates on channels\n+            return;\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_SETPOINT:\n+                try {\n+                    QuantityType<?> setpoint = (QuantityType<?>) command;\n+                    DecimalType dt = new DecimalType(setpoint.intValue());\n+                    submitCommand(new SetSetpointCommand(dt, dt));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid temperature\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_ONOFF_STATUS:\n+                try {\n+                    OnOffType oot = (OnOffType) command;\n+                    submitCommand(new SetPowerstateCommand(oot));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid on/off status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_FAN_SPEED:\n+                try {\n+                    DecimalType fanSpeed = (DecimalType) command;\n+                    FanSpeed fs = FanSpeed.valueOf(fanSpeed.intValue());\n+                    submitCommand(new SetFanspeedCommand(fs, fs));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid FanSpeed status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_OPERATION_MODE:\n+                try {\n+                    StringType operationMode = (StringType) command;\n+                    OperationMode m = OperationMode.valueOf(operationMode.toFullString());\n+\n+                    submitCommand(new SetOperationmodeCommand(m));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid OPERATION MODE\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_HOMEBRIDGE_MODE:\n+                try {\n+                    // Homebridge are discrete value different from Daikin\n+                    // 0 - Off\n+                    // 1 - Heating\n+                    // 2 - Cooling\n+                    // 3 - Auto\n+                    DecimalType homebridgeMode = (DecimalType) command;\n+                    switch (homebridgeMode.intValue()) {\n+                        case 0: // Off\n+                            submitCommand(new SetPowerstateCommand(OnOffType.OFF));\n+                            break;\n+                        case 1: // Heating\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.HEAT));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case 2: // Cooling\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.COOL));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case 3: // Auto\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.AUTO));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        default: // Invalid Value\n+                            logger.info(\"Invalid value received for channel {}. Ignoring.\", channelUID);\n+                            break;\n+                    }\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid HOMEBRIDGE OPERATION MODE\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE:\n+                try {\n+                    StringType homekitOperationMode = (StringType) command;\n+\n+                    switch (homekitOperationMode.toString()) {\n+                        case \"Off\":\n+                            submitCommand(new SetPowerstateCommand(OnOffType.OFF));\n+                            break;\n+                        case \"CoolOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.COOL));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"HeatOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.HEAT));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"Auto\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.AUTO));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+                } catch (Exception e) {\n+                    logger.info(\"Error while setting mode through HomeKIt received Mode\");\n+                }\n+            default:\n+                break;\n+        }\n+\n+    }\n+\n+    @Override\n+    public void onCharacteristicUpdate(BluetoothCharacteristic characteristic) {\n+        super.onCharacteristicUpdate(characteristic);\n+\n+        // Check that arguments are valid.\n+        if (characteristic.getUuid() == null) {\n+            return;\n+        }\n+\n+        // We are only interested in the Notify Characteristic of UART service\n+        if (!characteristic.getUuid().equals(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID)) {\n+            return;\n+        }\n+\n+        // A message cannot be null or have a 0-byte length\n+        byte[] msgBytes = characteristic.getByteValue();\n+        if (msgBytes == null || msgBytes.length == 0) {\n+            return;\n+        }\n+\n+        this.uartProcessor.chunkReceived(msgBytes);\n+    }\n+\n+    private void submitCommand(BRC1HCommand command) {\n+        Executor executor = commandExecutor;\n+\n+        if (executor != null) {\n+            executor.execute(() -> processCommand(command));\n+        }\n+    }\n+\n+    private void processCommand(BRC1HCommand command) {\n+        logger.debug(\"[{}] ProcessCommand {}\", super.thing.getUID().getId(), command.getClass().getSimpleName());\n+\n+        try {\n+            currentCommand = command;\n+            uartProcessor.abandon();\n+\n+            if (device == null || device.getConnectionState() != ConnectionState.CONNECTED) {\n+                logger.debug(\"Unable to send command {} to device {}: not connected\",\n+                        command.getClass().getSimpleName(), address);\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            if (!resolved) {\n+                logger.debug(\"Unable to send command {} to device {}: services not resolved\",\n+                        command.getClass().getSimpleName(), device.getAddress());\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            BluetoothCharacteristic charWrite = device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_WRITE_WITHOUT_RESPONSE_UUID);\n+            if (charWrite == null) {\n+                logger.warn(\"Unable to execute {}. Characteristic '{}' could not be found.\",\n+                        command.getClass().getSimpleName(),\n+                        DaikinMadokaBindingConstants.CHAR_WRITE_WITHOUT_RESPONSE_UUID);\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                device.enableNotifications(charNotif);\n+            }\n+\n+            charWrite.setValue(command.getRequest());\n+            command.setState(BRC1HCommand.State.ENQUEUED);\n+            device.writeCharacteristic(charWrite);\n+\n+            if (this.config != null) {\n+                if (!command.awaitStateChange(this.config.commandTimeout, TimeUnit.MILLISECONDS,\n+                        BRC1HCommand.State.SUCCEEDED, BRC1HCommand.State.FAILED)) {\n+                    logger.debug(\"Command {} to device {} timed out\", command, device.getAddress());\n+                    command.setState(BRC1HCommand.State.FAILED);\n+                }\n+            }\n+\n+        } catch (Exception e) {\n+            logger.debug(\"Error\", e);\n+        } finally {\n+            logger.debug(\"Command final state: {}\", command.getState());\n+            currentCommand = null;\n+        }\n+\n+        try {\n+            Thread.sleep(200);\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+        }\n+    }\n+\n+    @Override\n+    public void onCharacteristicWriteComplete(BluetoothCharacteristic characteristic,\n+            BluetoothCompletionStatus status) {\n+        super.onCharacteristicWriteComplete(characteristic, status);\n+\n+        byte[] request = characteristic.getByteValue();\n+        BRC1HCommand command = currentCommand;\n+\n+        if (command != null) {\n+            if (!Arrays.equals(request, command.getRequest())) {\n+                logger.debug(\"Write completed for unknown command\");\n+                return;\n+            }\n+            switch (status) {\n+                case SUCCESS:\n+                    command.setState(BRC1HCommand.State.SENT);\n+                    break;\n+                case ERROR:\n+                    command.setState(BRC1HCommand.State.FAILED);\n+                    break;\n+            }\n+        } else {\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"No command found that matches request {}\", HexUtils.bytesToHex(request));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * When the method is triggered, it means that all message chunks have been received, re-assembled in the right\n+     * order and that the payload is ready to be processed.\n+     */\n+    @Override\n+    public void receivedResponse(byte[] response) {\n+        logger.debug(\"Received Response\");\n+        BRC1HCommand command = currentCommand;\n+\n+        if (command == null) {\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"No command present to handle response {}\", HexUtils.bytesToHex(response));\n+            }\n+        } else {\n+            try {\n+                command.handleResponse(scheduler, this, MadokaMessage.parse(response));\n+            } catch (MadokaParsingException e) {\n+                logger.debug(\"Response message could not be parsed correctly ({}): {}. Reason: {}\",\n+                        command.getClass().getSimpleName(), HexUtils.bytesToHex(response), e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetVersionCommand command) {\n+        String commCtrlVers = command.getCommunicationControllerVersion();\n+        if (commCtrlVers != null) {\n+            this.madokaSettings.setCommunicationControllerVersion(commCtrlVers);\n+            updateStateIfLinked(DaikinMadokaBindingConstants.CHANNEL_ID_COMMUNICATION_CONTROLLER_VERSION,\n+                    new StringType(commCtrlVers));\n+        }\n+\n+        String remoteCtrlVers = command.getRemoteControllerVersion();\n+        if (remoteCtrlVers != null) {\n+            this.madokaSettings.setRemoteControllerVersion(remoteCtrlVers);\n+            updateStateIfLinked(DaikinMadokaBindingConstants.CHANNEL_ID_REMOTE_CONTROLLER_VERSION,\n+                    new StringType(remoteCtrlVers));\n+        }\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetFanspeedCommand command) {\n+        if (command.getCoolingFanSpeed() == null || command.getHeatingFanSpeed() == null) {\n+            return;\n+        }\n+\n+        // We need the current operation mode to determine which Fan Speed we use (cooling or heating)\n+        OperationMode operationMode = this.madokaSettings.getOperationMode();\n+        if (operationMode == null) {\n+            return;\n+        }\n+\n+        FanSpeed fs;\n+\n+        switch (operationMode) {\n+            case AUTO:\n+                // TODO confirm it works in all conditions\n+                logger.debug(\"In AutoMode, CoolingFanSpeed = {}, HeatingFanSpeed = {}\", command.getCoolingFanSpeed(),\n+                        command.getHeatingFanSpeed());\n+                fs = command.getHeatingFanSpeed();\n+                break;\n+            case HEAT:\n+                fs = command.getHeatingFanSpeed();\n+                break;\n+            case COOL:\n+                fs = command.getCoolingFanSpeed();\n+                break;\n+            default:\n+                return;\n+        }\n+\n+        if (fs == null) {\n+            return;\n+        }\n+\n+        // No need to re-set if it is the same value\n+        if (fs.equals(this.madokaSettings.getFanspeed())) {\n+            return;\n+        }\n+\n+        this.madokaSettings.setFanspeed(fs);\n+        updateStateIfLinked(DaikinMadokaBindingConstants.CHANNEL_ID_FAN_SPEED, new DecimalType(fs.value()));\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetSetpointCommand command) {\n+        if (command.getCoolingSetpoint() == null || command.getHeatingSetpoint() == null) {\n+            return;\n+        }\n+\n+        // We need the current operation mode to determine which Fan Speed we use (cooling or heating)\n+        OperationMode operationMode = this.madokaSettings.getOperationMode();\n+        if (operationMode == null) {\n+            return;\n+        }\n+\n+        DecimalType sp;\n+\n+        switch (operationMode) {\n+            case AUTO:\n+                // TODO confirm it works in all conditions", "originalCommit": "7afcf800754f801051f6d5d9dc4e269d7e82cc4c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NTUzMw==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r434165533", "bodyText": "remove empty line", "author": "kaikreuzer", "createdAt": "2020-06-02T20:46:22Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java", "diffHunk": "@@ -0,0 +1,782 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.handler;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.common.NamedThreadFactory;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDevice.ConnectionState;\n+import org.openhab.binding.bluetooth.ConnectedBluetoothHandler;\n+import org.openhab.binding.bluetooth.daikinmadoka.DaikinMadokaBindingConstants;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.BRC1HUartProcessor;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.DaikinMadokaConfiguration;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaParsingException;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.FanSpeed;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.OperationMode;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaSettings;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetIndoorOutoorTemperatures;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetSetpointCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetVersionCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetSetpointCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DaikinMadokaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Benjamin Lafois - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements ResponseListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DaikinMadokaHandler.class);\n+\n+    private @Nullable DaikinMadokaConfiguration config;\n+\n+    private @Nullable ExecutorService commandExecutor;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    // UART Processor is in charge of reassembling chunks\n+    private BRC1HUartProcessor uartProcessor = new BRC1HUartProcessor(this);\n+\n+    private volatile @Nullable BRC1HCommand currentCommand = null;\n+\n+    private MadokaSettings madokaSettings = new MadokaSettings();\n+\n+    public DaikinMadokaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"[{}] Start initializing!\", super.thing.getUID().getId());\n+\n+        // Load Configuration\n+        config = getConfigAs(DaikinMadokaConfiguration.class);\n+        DaikinMadokaConfiguration c = config;\n+\n+        logger.debug(\"[{}] Parameter value [refreshInterval]: {}\", super.thing.getUID().getId(), c.refreshInterval);\n+        logger.debug(\"[{}] Parameter value [commandTimeout]: {}\", super.thing.getUID().getId(), c.commandTimeout);\n+\n+        if (getBridge() == null) {\n+            logger.debug(\"[{}] Bridge is null. Exiting.\", super.thing.getUID().getId());\n+            return;\n+        }\n+\n+        this.commandExecutor = Executors\n+                .newSingleThreadExecutor(new NamedThreadFactory(thing.getUID().getAsString(), true));\n+\n+        this.refreshJob = scheduler.scheduleWithFixedDelay(() -> {\n+            // It is useless to refresh version all the time ! Just once.\n+            if (this.madokaSettings.getCommunicationControllerVersion() == null\n+                    || this.madokaSettings.getRemoteControllerVersion() == null) {\n+                submitCommand(new GetVersionCommand());\n+            }\n+            submitCommand(new GetIndoorOutoorTemperatures());\n+            submitCommand(new GetOperationmodeCommand());\n+            submitCommand(new GetPowerstateCommand()); // always keep the \"GetPowerState\" aftern the \"GetOperationMode\"\n+            submitCommand(new GetSetpointCommand());\n+            submitCommand(new GetFanspeedCommand());\n+        }, 10, c.refreshInterval, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"[{}] dispose()\", super.thing.getUID().getId());\n+\n+        dispose(refreshJob);\n+        dispose(commandExecutor);\n+        dispose(currentCommand);\n+\n+        // Unsubscribe to characteristic notifications\n+        if (this.device != null) {\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                @NonNull\n+                BluetoothCharacteristic c = charNotif;\n+                this.device.disableNotifications(c);\n+            }\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private static void dispose(@Nullable ExecutorService executor) {\n+        if (executor != null) {\n+            executor.shutdownNow();\n+        }\n+    }\n+\n+    private static void dispose(@Nullable ScheduledFuture<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private static void dispose(@Nullable BRC1HCommand command) {\n+        if (command != null) {\n+            // even if it already completed it doesn't really matter.\n+            // on the off chance that the commandExecutor is waiting on the command, we can wake it up and cause it to\n+            // terminate\n+            command.setState(BRC1HCommand.State.FAILED);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"[{}] Channel: {}, Command: {}\", super.thing.getUID().getId(), channelUID, command);\n+\n+        if (command instanceof RefreshType) {\n+            // The refresh commands are not supported in query mode.\n+            // The binding will notify updates on channels\n+            return;\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_SETPOINT:\n+                try {\n+                    QuantityType<?> setpoint = (QuantityType<?>) command;\n+                    DecimalType dt = new DecimalType(setpoint.intValue());\n+                    submitCommand(new SetSetpointCommand(dt, dt));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid temperature\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_ONOFF_STATUS:\n+                try {\n+                    OnOffType oot = (OnOffType) command;\n+                    submitCommand(new SetPowerstateCommand(oot));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid on/off status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_FAN_SPEED:\n+                try {\n+                    DecimalType fanSpeed = (DecimalType) command;\n+                    FanSpeed fs = FanSpeed.valueOf(fanSpeed.intValue());\n+                    submitCommand(new SetFanspeedCommand(fs, fs));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid FanSpeed status\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_OPERATION_MODE:\n+                try {\n+                    StringType operationMode = (StringType) command;\n+                    OperationMode m = OperationMode.valueOf(operationMode.toFullString());\n+\n+                    submitCommand(new SetOperationmodeCommand(m));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid OPERATION MODE\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_HOMEBRIDGE_MODE:\n+                try {\n+                    // Homebridge are discrete value different from Daikin\n+                    // 0 - Off\n+                    // 1 - Heating\n+                    // 2 - Cooling\n+                    // 3 - Auto\n+                    DecimalType homebridgeMode = (DecimalType) command;\n+                    switch (homebridgeMode.intValue()) {\n+                        case 0: // Off\n+                            submitCommand(new SetPowerstateCommand(OnOffType.OFF));\n+                            break;\n+                        case 1: // Heating\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.HEAT));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case 2: // Cooling\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.COOL));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case 3: // Auto\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.AUTO));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        default: // Invalid Value\n+                            logger.info(\"Invalid value received for channel {}. Ignoring.\", channelUID);\n+                            break;\n+                    }\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid HOMEBRIDGE OPERATION MODE\", e);\n+                }\n+                break;\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE:\n+                try {\n+                    StringType homekitOperationMode = (StringType) command;\n+\n+                    switch (homekitOperationMode.toString()) {\n+                        case \"Off\":\n+                            submitCommand(new SetPowerstateCommand(OnOffType.OFF));\n+                            break;\n+                        case \"CoolOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.COOL));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"HeatOn\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.HEAT));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        case \"Auto\":\n+                            submitCommand(new SetOperationmodeCommand(OperationMode.AUTO));\n+                            if (madokaSettings.getOnOffState() == OnOffType.OFF) {\n+                                submitCommand(new SetPowerstateCommand(OnOffType.ON));\n+                            }\n+                            break;\n+                        default:\n+                            break;\n+                    }\n+                } catch (Exception e) {\n+                    logger.info(\"Error while setting mode through HomeKIt received Mode\");\n+                }\n+            default:\n+                break;\n+        }\n+\n+    }\n+\n+    @Override\n+    public void onCharacteristicUpdate(BluetoothCharacteristic characteristic) {\n+        super.onCharacteristicUpdate(characteristic);\n+\n+        // Check that arguments are valid.\n+        if (characteristic.getUuid() == null) {\n+            return;\n+        }\n+\n+        // We are only interested in the Notify Characteristic of UART service\n+        if (!characteristic.getUuid().equals(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID)) {\n+            return;\n+        }\n+\n+        // A message cannot be null or have a 0-byte length\n+        byte[] msgBytes = characteristic.getByteValue();\n+        if (msgBytes == null || msgBytes.length == 0) {\n+            return;\n+        }\n+\n+        this.uartProcessor.chunkReceived(msgBytes);\n+    }\n+\n+    private void submitCommand(BRC1HCommand command) {\n+        Executor executor = commandExecutor;\n+\n+        if (executor != null) {\n+            executor.execute(() -> processCommand(command));\n+        }\n+    }\n+\n+    private void processCommand(BRC1HCommand command) {\n+        logger.debug(\"[{}] ProcessCommand {}\", super.thing.getUID().getId(), command.getClass().getSimpleName());\n+\n+        try {\n+            currentCommand = command;\n+            uartProcessor.abandon();\n+\n+            if (device == null || device.getConnectionState() != ConnectionState.CONNECTED) {\n+                logger.debug(\"Unable to send command {} to device {}: not connected\",\n+                        command.getClass().getSimpleName(), address);\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            if (!resolved) {\n+                logger.debug(\"Unable to send command {} to device {}: services not resolved\",\n+                        command.getClass().getSimpleName(), device.getAddress());\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            BluetoothCharacteristic charWrite = device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_WRITE_WITHOUT_RESPONSE_UUID);\n+            if (charWrite == null) {\n+                logger.warn(\"Unable to execute {}. Characteristic '{}' could not be found.\",\n+                        command.getClass().getSimpleName(),\n+                        DaikinMadokaBindingConstants.CHAR_WRITE_WITHOUT_RESPONSE_UUID);\n+                command.setState(BRC1HCommand.State.FAILED);\n+                return;\n+            }\n+\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                device.enableNotifications(charNotif);\n+            }\n+\n+            charWrite.setValue(command.getRequest());\n+            command.setState(BRC1HCommand.State.ENQUEUED);\n+            device.writeCharacteristic(charWrite);\n+\n+            if (this.config != null) {\n+                if (!command.awaitStateChange(this.config.commandTimeout, TimeUnit.MILLISECONDS,\n+                        BRC1HCommand.State.SUCCEEDED, BRC1HCommand.State.FAILED)) {\n+                    logger.debug(\"Command {} to device {} timed out\", command, device.getAddress());\n+                    command.setState(BRC1HCommand.State.FAILED);\n+                }\n+            }\n+\n+        } catch (Exception e) {\n+            logger.debug(\"Error\", e);\n+        } finally {\n+            logger.debug(\"Command final state: {}\", command.getState());\n+            currentCommand = null;\n+        }\n+\n+        try {\n+            Thread.sleep(200);\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+        }\n+    }\n+\n+    @Override\n+    public void onCharacteristicWriteComplete(BluetoothCharacteristic characteristic,\n+            BluetoothCompletionStatus status) {\n+        super.onCharacteristicWriteComplete(characteristic, status);\n+\n+        byte[] request = characteristic.getByteValue();\n+        BRC1HCommand command = currentCommand;\n+\n+        if (command != null) {\n+            if (!Arrays.equals(request, command.getRequest())) {\n+                logger.debug(\"Write completed for unknown command\");\n+                return;\n+            }\n+            switch (status) {\n+                case SUCCESS:\n+                    command.setState(BRC1HCommand.State.SENT);\n+                    break;\n+                case ERROR:\n+                    command.setState(BRC1HCommand.State.FAILED);\n+                    break;\n+            }\n+        } else {\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"No command found that matches request {}\", HexUtils.bytesToHex(request));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * When the method is triggered, it means that all message chunks have been received, re-assembled in the right\n+     * order and that the payload is ready to be processed.\n+     */\n+    @Override\n+    public void receivedResponse(byte[] response) {\n+        logger.debug(\"Received Response\");\n+        BRC1HCommand command = currentCommand;\n+\n+        if (command == null) {\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"No command present to handle response {}\", HexUtils.bytesToHex(response));\n+            }\n+        } else {\n+            try {\n+                command.handleResponse(scheduler, this, MadokaMessage.parse(response));\n+            } catch (MadokaParsingException e) {\n+                logger.debug(\"Response message could not be parsed correctly ({}): {}. Reason: {}\",\n+                        command.getClass().getSimpleName(), HexUtils.bytesToHex(response), e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetVersionCommand command) {\n+        String commCtrlVers = command.getCommunicationControllerVersion();\n+        if (commCtrlVers != null) {\n+            this.madokaSettings.setCommunicationControllerVersion(commCtrlVers);\n+            updateStateIfLinked(DaikinMadokaBindingConstants.CHANNEL_ID_COMMUNICATION_CONTROLLER_VERSION,\n+                    new StringType(commCtrlVers));\n+        }\n+\n+        String remoteCtrlVers = command.getRemoteControllerVersion();\n+        if (remoteCtrlVers != null) {\n+            this.madokaSettings.setRemoteControllerVersion(remoteCtrlVers);\n+            updateStateIfLinked(DaikinMadokaBindingConstants.CHANNEL_ID_REMOTE_CONTROLLER_VERSION,\n+                    new StringType(remoteCtrlVers));\n+        }\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetFanspeedCommand command) {\n+        if (command.getCoolingFanSpeed() == null || command.getHeatingFanSpeed() == null) {\n+            return;\n+        }\n+\n+        // We need the current operation mode to determine which Fan Speed we use (cooling or heating)\n+        OperationMode operationMode = this.madokaSettings.getOperationMode();\n+        if (operationMode == null) {\n+            return;\n+        }\n+\n+        FanSpeed fs;\n+\n+        switch (operationMode) {\n+            case AUTO:\n+                // TODO confirm it works in all conditions\n+                logger.debug(\"In AutoMode, CoolingFanSpeed = {}, HeatingFanSpeed = {}\", command.getCoolingFanSpeed(),\n+                        command.getHeatingFanSpeed());\n+                fs = command.getHeatingFanSpeed();\n+                break;\n+            case HEAT:\n+                fs = command.getHeatingFanSpeed();\n+                break;\n+            case COOL:\n+                fs = command.getCoolingFanSpeed();\n+                break;\n+            default:\n+                return;\n+        }\n+\n+        if (fs == null) {\n+            return;\n+        }\n+\n+        // No need to re-set if it is the same value\n+        if (fs.equals(this.madokaSettings.getFanspeed())) {\n+            return;\n+        }\n+\n+        this.madokaSettings.setFanspeed(fs);\n+        updateStateIfLinked(DaikinMadokaBindingConstants.CHANNEL_ID_FAN_SPEED, new DecimalType(fs.value()));\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetSetpointCommand command) {\n+        if (command.getCoolingSetpoint() == null || command.getHeatingSetpoint() == null) {\n+            return;\n+        }\n+\n+        // We need the current operation mode to determine which Fan Speed we use (cooling or heating)\n+        OperationMode operationMode = this.madokaSettings.getOperationMode();\n+        if (operationMode == null) {\n+            return;\n+        }\n+\n+        DecimalType sp;\n+\n+        switch (operationMode) {\n+            case AUTO:\n+                // TODO confirm it works in all conditions\n+                logger.debug(\"In AutoMode, CoolingSetpoint = {}, HeatingSetpoint = {}\", command.getCoolingSetpoint(),\n+                        command.getHeatingSetpoint());\n+                sp = command.getHeatingSetpoint();\n+                break;\n+            case HEAT:\n+                sp = command.getHeatingSetpoint();\n+                break;\n+            case COOL:\n+                sp = command.getCoolingSetpoint();\n+                break;\n+            default:\n+                return;\n+        }\n+\n+        if (sp == null) {\n+            return;\n+        }\n+\n+        // No need to re-set if it is the same value\n+        if (sp.equals(this.madokaSettings.getSetpoint())) {\n+            return;\n+        }\n+\n+        this.madokaSettings.setSetpoint(sp);\n+\n+        DecimalType dt = this.madokaSettings.getSetpoint();\n+        if (dt != null) {\n+            updateStateIfLinked(DaikinMadokaBindingConstants.CHANNEL_ID_SETPOINT, dt);\n+        }\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetOperationmodeCommand command) {\n+        if (command.getOperationMode() == null) {\n+            return;\n+        }\n+\n+        OperationMode newMode = command.getOperationMode();\n+        // If the mode has not changed - no need to refresh everything\n+        if (newMode == null || newMode.equals(this.madokaSettings.getOperationMode())) {\n+            return;\n+        }\n+\n+        this.madokaSettings.setOperationMode(newMode);\n+\n+        updateStateIfLinked(DaikinMadokaBindingConstants.CHANNEL_ID_OPERATION_MODE, new StringType(newMode.name()));\n+\n+        // For HomeKit channel, we need to map it to HomeKit supported strings\n+        OnOffType ooStatus = madokaSettings.getOnOffState();\n+\n+        if (ooStatus != null && ooStatus == OnOffType.ON) {\n+            switch (newMode) {\n+                case COOL:\n+                    updateStateIfLinked(DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE,\n+                            new StringType(\"Cooling\"));\n+                    updateStateIfLinked(DaikinMadokaBindingConstants.CHANNEL_ID_HOMEBRIDGE_MODE, new DecimalType(2));\n+                    break;\n+                case HEAT:\n+                    updateStateIfLinked(DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE,\n+                            new StringType(\"Heating\"));\n+                    updateStateIfLinked(DaikinMadokaBindingConstants.CHANNEL_ID_HOMEBRIDGE_MODE, new DecimalType(1));\n+                    break;\n+                case AUTO:\n+                    updateStateIfLinked(DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE,\n+                            new StringType(\"Auto\"));\n+                    updateStateIfLinked(DaikinMadokaBindingConstants.CHANNEL_ID_HOMEBRIDGE_MODE, new DecimalType(3));\n+                default:\n+                    break;\n+            }\n+        }\n+\n+        // If this is the first channel update - then we set target = current mode\n+        if (this.madokaSettings.getHomekitTargetMode() == null) {\n+            String newHomekitTargetStatus = null;\n+\n+            // For HomeKit channel, we need to map it to HomeKit supported strings\n+            switch (newMode) {\n+                case COOL:\n+                    newHomekitTargetStatus = \"CoolOn\";\n+                    break;\n+                case HEAT:\n+                    newHomekitTargetStatus = \"HeatOn\";\n+                    break;\n+                default:\n+                    return;\n+            }\n+\n+            if (ooStatus != null && ooStatus == OnOffType.ON) {\n+                this.madokaSettings.setHomekitTargetMode(newHomekitTargetStatus);\n+                updateStateIfLinked(DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE,\n+                        new StringType(newHomekitTargetStatus));\n+            } else if (ooStatus != null && ooStatus == OnOffType.OFF) {\n+                newHomekitTargetStatus = \"Off\";\n+                this.madokaSettings.setHomekitTargetMode(newHomekitTargetStatus);\n+                updateStateIfLinked(DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE,\n+                        new StringType(newHomekitTargetStatus));\n+            }\n+\n+        }\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetPowerstateCommand command) {\n+        if (command.isPowerState() == null) {\n+            return;\n+        }\n+\n+        OnOffType oot = command.isPowerState() ? OnOffType.ON : OnOffType.OFF;\n+\n+        if (oot.equals(this.madokaSettings.getOnOffState())) {\n+            return;\n+        }\n+\n+        this.madokaSettings.setOnOffState(oot);\n+\n+        updateStateIfLinked(DaikinMadokaBindingConstants.CHANNEL_ID_ONOFF_STATUS, oot);\n+\n+        if (oot.equals(OnOffType.OFF)) {\n+            updateStateIfLinked(DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_CURRENT_HEATING_COOLING_MODE,\n+                    new StringType(\"Off\"));\n+            updateStateIfLinked(DaikinMadokaBindingConstants.CHANNEL_ID_HOMEKIT_TARGET_HEATING_COOLING_MODE,\n+                    new StringType(\"Off\"));\n+            updateStateIfLinked(DaikinMadokaBindingConstants.CHANNEL_ID_HOMEBRIDGE_MODE, new DecimalType(0));\n+        }\n+    }\n+\n+    @Override\n+    public void receivedResponse(GetIndoorOutoorTemperatures command) {\n+", "originalCommit": "7afcf800754f801051f6d5d9dc4e269d7e82cc4c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NTg2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r434165861", "bodyText": "please add \"- Initial contribution\"", "author": "kaikreuzer", "createdAt": "2020-06-02T20:47:06Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.util.Comparator;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+\n+/**\n+ *\n+ * @author Benjamin Lafois", "originalCommit": "7afcf800754f801051f6d5d9dc4e269d7e82cc4c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NTk3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r434165973", "bodyText": "add a short description", "author": "kaikreuzer", "createdAt": "2020-06-02T20:47:19Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.util.Comparator;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+\n+/**", "originalCommit": "7afcf800754f801051f6d5d9dc4e269d7e82cc4c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NjA4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r434166083", "bodyText": "remove or add content", "author": "kaikreuzer", "createdAt": "2020-06-02T20:47:34Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/BRC1HUartProcessor.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.util.Comparator;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+\n+/**\n+ *\n+ * @author Benjamin Lafois\n+ *\n+ */\n+@NonNullByDefault\n+public class BRC1HUartProcessor {\n+\n+    /**\n+     * Maximum number of bytes per message chunk, including headers\n+     */\n+    public static final int MAX_CHUNK_SIZE = 20;\n+\n+    /**\n+     * In the unlikely event of messages arrive in wrong order, this comparator will sort the queue\n+     */\n+    private Comparator<byte[]> chunkSorter = (byte[] m1, byte[] m2) -> m1[0] - m2[0];\n+\n+    private ConcurrentSkipListSet<byte[]> uartMessages = new ConcurrentSkipListSet<>(chunkSorter);\n+\n+    private ResponseListener responseListener;\n+\n+    public BRC1HUartProcessor(ResponseListener responseListener) {\n+        this.responseListener = responseListener;\n+    }\n+\n+    /**", "originalCommit": "7afcf800754f801051f6d5d9dc4e269d7e82cc4c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NjMxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r434166315", "bodyText": "add description", "author": "kaikreuzer", "createdAt": "2020-06-02T20:48:02Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**", "originalCommit": "7afcf800754f801051f6d5d9dc4e269d7e82cc4c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NjQwOA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r434166408", "bodyText": "add \"- Initial contribution\"", "author": "kaikreuzer", "createdAt": "2020-06-02T20:48:12Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaMessage.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ * @author Benjamin Lafois", "originalCommit": "7afcf800754f801051f6d5d9dc4e269d7e82cc4c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NjYyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r434166625", "bodyText": "dito", "author": "kaikreuzer", "createdAt": "2020-06-02T20:48:39Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaParsingException.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**", "originalCommit": "7afcf800754f801051f6d5d9dc4e269d7e82cc4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgzODYyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r434838621", "bodyText": "\"dito\" meaning: Please add a short description on the javadoc of ALL classes - I see you have only updated the author tag so far.", "author": "kaikreuzer", "createdAt": "2020-06-03T20:37:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NjYyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc1MDQzMA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r442750430", "bodyText": "Done.", "author": "blafois", "createdAt": "2020-06-19T10:04:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NjYyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NjY4NA==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r434166684", "bodyText": "dito", "author": "kaikreuzer", "createdAt": "2020-06-02T20:48:47Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaProperties.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**", "originalCommit": "7afcf800754f801051f6d5d9dc4e269d7e82cc4c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NjgzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r434166831", "bodyText": "and the same for all classes :-)", "author": "kaikreuzer", "createdAt": "2020-06-02T20:49:06Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/internal/model/MadokaSettings.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.internal.model;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.FanSpeed;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.OperationMode;\n+\n+/**", "originalCommit": "7afcf800754f801051f6d5d9dc4e269d7e82cc4c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8bcaa5077daa9290ef027c07284162095ce73028", "url": "https://github.com/openhab/openhab-addons/commit/8bcaa5077daa9290ef027c07284162095ce73028", "message": "Fixes following PR review comments\n\nSigned-off-by: Benjamin Lafois <benjamin@lafois.com>", "committedDate": "2020-06-03T19:59:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgzNjc5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r434836791", "bodyText": "btw, all those info loggings look a bit fishy to me. You are again doing a \"catch all\" here, but then claim that the issue is due to invalid data. If you are certain of that, you should imho be able to catch a more specific exception.\nIn case of an exception here: Can the situation be considered to be a bug that should be reported as an issue? I guess so. I would then even suggest to log it as a warning or even error, so that the user is clearly notified that something isn't working as expected and he needs to ask for help.", "author": "kaikreuzer", "createdAt": "2020-06-03T20:33:12Z", "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/java/org/openhab/binding/bluetooth/daikinmadoka/handler/DaikinMadokaHandler.java", "diffHunk": "@@ -0,0 +1,782 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.daikinmadoka.handler;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.common.NamedThreadFactory;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDevice.ConnectionState;\n+import org.openhab.binding.bluetooth.ConnectedBluetoothHandler;\n+import org.openhab.binding.bluetooth.daikinmadoka.DaikinMadokaBindingConstants;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.BRC1HUartProcessor;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.DaikinMadokaConfiguration;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaMessage;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaParsingException;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.FanSpeed;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaProperties.OperationMode;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.MadokaSettings;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.BRC1HCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetIndoorOutoorTemperatures;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetSetpointCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.GetVersionCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.ResponseListener;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetFanspeedCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetOperationmodeCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetPowerstateCommand;\n+import org.openhab.binding.bluetooth.daikinmadoka.internal.model.commands.SetSetpointCommand;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link DaikinMadokaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Benjamin Lafois - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DaikinMadokaHandler extends ConnectedBluetoothHandler implements ResponseListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DaikinMadokaHandler.class);\n+\n+    private @Nullable DaikinMadokaConfiguration config;\n+\n+    private @Nullable ExecutorService commandExecutor;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+\n+    // UART Processor is in charge of reassembling chunks\n+    private BRC1HUartProcessor uartProcessor = new BRC1HUartProcessor(this);\n+\n+    private volatile @Nullable BRC1HCommand currentCommand = null;\n+\n+    private MadokaSettings madokaSettings = new MadokaSettings();\n+\n+    public DaikinMadokaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        logger.debug(\"[{}] Start initializing!\", super.thing.getUID().getId());\n+\n+        // Load Configuration\n+        config = getConfigAs(DaikinMadokaConfiguration.class);\n+        DaikinMadokaConfiguration c = config;\n+\n+        logger.debug(\"[{}] Parameter value [refreshInterval]: {}\", super.thing.getUID().getId(), c.refreshInterval);\n+        logger.debug(\"[{}] Parameter value [commandTimeout]: {}\", super.thing.getUID().getId(), c.commandTimeout);\n+\n+        if (getBridge() == null) {\n+            logger.debug(\"[{}] Bridge is null. Exiting.\", super.thing.getUID().getId());\n+            return;\n+        }\n+\n+        this.commandExecutor = Executors\n+                .newSingleThreadExecutor(new NamedThreadFactory(thing.getUID().getAsString(), true));\n+\n+        this.refreshJob = scheduler.scheduleWithFixedDelay(() -> {\n+            // It is useless to refresh version all the time ! Just once.\n+            if (this.madokaSettings.getCommunicationControllerVersion() == null\n+                    || this.madokaSettings.getRemoteControllerVersion() == null) {\n+                submitCommand(new GetVersionCommand());\n+            }\n+            submitCommand(new GetIndoorOutoorTemperatures());\n+            submitCommand(new GetOperationmodeCommand());\n+            submitCommand(new GetPowerstateCommand()); // always keep the \"GetPowerState\" aftern the \"GetOperationMode\"\n+            submitCommand(new GetSetpointCommand());\n+            submitCommand(new GetFanspeedCommand());\n+        }, 10, c.refreshInterval, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"[{}] dispose()\", super.thing.getUID().getId());\n+\n+        dispose(refreshJob);\n+        dispose(commandExecutor);\n+        dispose(currentCommand);\n+\n+        // Unsubscribe to characteristic notifications\n+        if (this.device != null) {\n+            BluetoothCharacteristic charNotif = this.device\n+                    .getCharacteristic(DaikinMadokaBindingConstants.CHAR_NOTIF_UUID);\n+\n+            if (charNotif != null) {\n+                @NonNull\n+                BluetoothCharacteristic c = charNotif;\n+                this.device.disableNotifications(c);\n+            }\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private static void dispose(@Nullable ExecutorService executor) {\n+        if (executor != null) {\n+            executor.shutdownNow();\n+        }\n+    }\n+\n+    private static void dispose(@Nullable ScheduledFuture<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private static void dispose(@Nullable BRC1HCommand command) {\n+        if (command != null) {\n+            // even if it already completed it doesn't really matter.\n+            // on the off chance that the commandExecutor is waiting on the command, we can wake it up and cause it to\n+            // terminate\n+            command.setState(BRC1HCommand.State.FAILED);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"[{}] Channel: {}, Command: {}\", super.thing.getUID().getId(), channelUID, command);\n+\n+        if (command instanceof RefreshType) {\n+            // The refresh commands are not supported in query mode.\n+            // The binding will notify updates on channels\n+            return;\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case DaikinMadokaBindingConstants.CHANNEL_ID_SETPOINT:\n+                try {\n+                    QuantityType<?> setpoint = (QuantityType<?>) command;\n+                    DecimalType dt = new DecimalType(setpoint.intValue());\n+                    submitCommand(new SetSetpointCommand(dt, dt));\n+                } catch (Exception e) {\n+                    logger.info(\"Data received is not a valid temperature\", e);", "originalCommit": "7afcf800754f801051f6d5d9dc4e269d7e82cc4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc0MDU1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7434#discussion_r442740552", "bodyText": "I have updated with WARN level instead of debug. The point is - if the FW gets updated - I'm not sure the way values are encoded might change or not - so I prefer catching it.", "author": "blafois", "createdAt": "2020-06-19T09:44:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgzNjc5MQ=="}], "type": "inlineReview"}, {"oid": "adf117d7c49dd2f597602205db94be5dbba5d71f", "url": "https://github.com/openhab/openhab-addons/commit/adf117d7c49dd2f597602205db94be5dbba5d71f", "message": "Another round of review fixes\n\nSigned-off-by: Benjamin Lafois <benjamin@lafois.com>", "committedDate": "2020-06-19T10:04:39Z", "type": "commit"}, {"oid": "38e6b567b865ab3a2fb3d20b9a6bee586a409367", "url": "https://github.com/openhab/openhab-addons/commit/38e6b567b865ab3a2fb3d20b9a6bee586a409367", "message": "Bug fixes for channel Home Bridge\n\nSigned-off-by: Benjamin Lafois <benjamin@lafois.com>", "committedDate": "2020-06-23T16:53:48Z", "type": "commit"}, {"oid": "5b4a7bd2671a8d7bc322e8ddd5e161eb407cbfb9", "url": "https://github.com/openhab/openhab-addons/commit/5b4a7bd2671a8d7bc322e8ddd5e161eb407cbfb9", "message": "minor indent fixes and update to 2.5.7\n\nSigned-off-by: Benjamin Lafois <benjamin@lafois.com>", "committedDate": "2020-06-29T07:19:20Z", "type": "commit"}, {"oid": "be8e52197640d8563e38609d1d0cecdf9e1e1e70", "url": "https://github.com/openhab/openhab-addons/commit/be8e52197640d8563e38609d1d0cecdf9e1e1e70", "message": "Merge branch '2.5.x' into add-daikinmadoka-binding", "committedDate": "2020-06-29T07:28:49Z", "type": "commit"}, {"oid": "7360b4987790cd916c4370ff86bd8de12d15f3da", "url": "https://github.com/openhab/openhab-addons/commit/7360b4987790cd916c4370ff86bd8de12d15f3da", "message": "last cosmetic change and upgrade to 2.5.7\n\nSigned-off-by: Benjamin Lafois <benjamin@lafois.com>", "committedDate": "2020-06-29T07:33:15Z", "type": "commit"}]}