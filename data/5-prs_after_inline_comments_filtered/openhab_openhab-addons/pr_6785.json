{"pr_number": 6785, "pr_title": "[openthermgateway] Initial contribution", "pr_createdAt": "2020-01-07T14:10:17Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/6785", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM2MDE1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367360152", "bodyText": "This is generally designed as a Set because that's more efficient in lookup. The list is used to check if a value is present.", "author": "Hilbrand", "createdAt": "2020-01-16T11:10:51Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/OpenThermGatewayBindingConstants.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link OpenThermGatewayBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayBindingConstants {\n+\n+    private static final String BINDING_ID = \"openthermgateway\";\n+\n+    // List of all Thing Type UID's\n+    public static final ThingTypeUID MAIN_THING_TYPE = new ThingTypeUID(BINDING_ID, \"otgw\");\n+\n+    // List of all Channel id's\n+    public static final String CHANNEL_SEND_COMMAND = \"sendcommand\";\n+\n+    public static final String CHANNEL_OVERRIDE_SETPOINT_TEMPORARY = \"temperaturetemporary\";\n+    public static final String CHANNEL_OVERRIDE_SETPOINT_CONSTANT = \"temperatureconstant\";\n+    public static final String CHANNEL_OVERRIDE_DHW_SETPOINT = \"overridedhwsetpoint\";\n+    public static final String CHANNEL_ROOM_TEMPERATURE = \"roomtemp\";\n+    public static final String CHANNEL_ROOM_SETPOINT = \"roomsetpoint\";\n+    public static final String CHANNEL_FLOW_TEMPERATURE = \"flowtemp\";\n+    public static final String CHANNEL_RETURN_TEMPERATURE = \"returntemp\";\n+    public static final String CHANNEL_OUTSIDE_TEMPERATURE = \"outsidetemp\";\n+    public static final String CHANNEL_CENTRAL_HEATING_WATER_SETPOINT = \"controlsetpoint\";\n+    public static final String CHANNEL_CENTRAL_HEATING_WATER_PRESSURE = \"waterpressure\";\n+    public static final String CHANNEL_CENTRAL_HEATING_ENABLED = \"ch_enable\";\n+    public static final String CHANNEL_CENTRAL_HEATING_MODE = \"ch_mode\";\n+    public static final String CHANNEL_DOMESTIC_HOT_WATER_TEMPERATURE = \"dhwtemp\";\n+    public static final String CHANNEL_DOMESTIC_HOT_WATER_ENABLED = \"dhw_enable\";\n+    public static final String CHANNEL_DOMESTIC_HOT_WATER_MODE = \"dhw_mode\";\n+    public static final String CHANNEL_DOMESTIC_HOT_WATER_SETPOINT = \"tdhwset\";\n+    public static final String CHANNEL_FLAME = \"flame\";\n+    public static final String CHANNEL_RELATIVE_MODULATION_LEVEL = \"modulevel\";\n+    public static final String CHANNEL_MAXIMUM_MODULATION_LEVEL = \"maxrelmdulevel\";\n+    public static final String CHANNEL_FAULT = \"fault\";\n+    public static final String CHANNEL_SERVICEREQUEST = \"servicerequest\";\n+    public static final String CHANNEL_REMOTE_RESET = \"lockout-reset\";\n+    public static final String CHANNEL_LOW_WATER_PRESSURE = \"lowwaterpress\";\n+    public static final String CHANNEL_GAS_FLAME_FAULT = \"gasflamefault\";\n+    public static final String CHANNEL_AIR_PRESSURE_FAULT = \"airpressfault\";\n+    public static final String CHANNEL_WATER_OVER_TEMP = \"waterovtemp\";\n+    public static final String CHANNEL_OEM_FAULTCODE = \"oemfaultcode\";\n+\n+    public static final List<String> SUPPORTED_CHANNEL_IDS = Arrays.asList(CHANNEL_ROOM_TEMPERATURE,", "originalCommit": "7628cabf0067eac62ce763d8a3457d57685f7766", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU4OTk1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367589952", "bodyText": "Adjusted", "author": "ArjenKorevaar", "createdAt": "2020-01-16T18:51:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM2MDE1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM2MzgyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367363829", "bodyText": "Enum convention should all be upper case, and/or use underscore:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Flags,\n          \n          \n            \n                FLAGS,", "author": "Hilbrand", "createdAt": "2020-01-16T11:20:05Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/DataType.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+public enum DataType {\n+    Flags,", "originalCommit": "7628cabf0067eac62ce763d8a3457d57685f7766", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU4MjAwNA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367582004", "bodyText": "Adjusted", "author": "ArjenKorevaar", "createdAt": "2020-01-16T18:34:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM2MzgyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM2NjM2NA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367366364", "bodyText": "Use Java 8 notation:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            scheduler.schedule(new Runnable() {\n          \n          \n            \n            \n          \n          \n            \n                                @Override\n          \n          \n            \n                                public void run() {\n          \n          \n            \n                            scheduler.schedule(() -> {", "author": "Hilbrand", "createdAt": "2020-01-16T11:26:13Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.LogLevel;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    @Nullable\n+    private OpenThermGatewayConfiguration config;\n+\n+    @Nullable\n+    private OpenThermGatewayConnector connector;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+\n+        config = getConfigAs(OpenThermGatewayConfiguration.class);\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Received channel: {}, command: {}\", channelUID, command);\n+\n+        try {\n+            if (command.toFullString() != \"REFRESH\") {\n+                String channel = channelUID.getId();\n+                String code = getGatewayCodeFromChannel(channel);\n+\n+                GatewayCommand gatewayCommand;\n+                if (command instanceof QuantityType) {\n+                    gatewayCommand = GatewayCommand.parse(code,\n+                            Double.toString(((QuantityType) command).doubleValue()));\n+                } else {\n+                    gatewayCommand = GatewayCommand.parse(code, command.toFullString());\n+                }\n+\n+                if (gatewayCommand != null && checkConnection()) {\n+                    connector.sendCommand(gatewayCommand);\n+                }\n+            }\n+        } catch (Exception ex) {\n+            logger.error(\"error\", ex);\n+        }\n+    }\n+\n+    boolean connecting = false;\n+\n+    @Override\n+    public void connecting() {\n+        connecting = true;\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void connected() {\n+        connecting = false;\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void disconnected() {\n+        connecting = false;\n+\n+        try {\n+            updateStatus(ThingStatus.OFFLINE);\n+\n+            // retry connection if disconnect is not explicitly requested\n+            if (!explicitDisconnect && config.connectionRetryInterval > 0) {\n+                scheduler.schedule(new Runnable() {\n+\n+                    @Override\n+                    public void run() {", "originalCommit": "7628cabf0067eac62ce763d8a3457d57685f7766", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU5NjQxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367596415", "bodyText": "Adjusted", "author": "ArjenKorevaar", "createdAt": "2020-01-16T19:05:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM2NjM2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM2NjU3MA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367366570", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            }, config.connectionRetryInterval * 1000, TimeUnit.MILLISECONDS);\n          \n          \n            \n                            }, config.connectionRetryInterval, TimeUnit.SECONDS);", "author": "Hilbrand", "createdAt": "2020-01-16T11:26:45Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.LogLevel;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    @Nullable\n+    private OpenThermGatewayConfiguration config;\n+\n+    @Nullable\n+    private OpenThermGatewayConnector connector;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+\n+        config = getConfigAs(OpenThermGatewayConfiguration.class);\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Received channel: {}, command: {}\", channelUID, command);\n+\n+        try {\n+            if (command.toFullString() != \"REFRESH\") {\n+                String channel = channelUID.getId();\n+                String code = getGatewayCodeFromChannel(channel);\n+\n+                GatewayCommand gatewayCommand;\n+                if (command instanceof QuantityType) {\n+                    gatewayCommand = GatewayCommand.parse(code,\n+                            Double.toString(((QuantityType) command).doubleValue()));\n+                } else {\n+                    gatewayCommand = GatewayCommand.parse(code, command.toFullString());\n+                }\n+\n+                if (gatewayCommand != null && checkConnection()) {\n+                    connector.sendCommand(gatewayCommand);\n+                }\n+            }\n+        } catch (Exception ex) {\n+            logger.error(\"error\", ex);\n+        }\n+    }\n+\n+    boolean connecting = false;\n+\n+    @Override\n+    public void connecting() {\n+        connecting = true;\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void connected() {\n+        connecting = false;\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void disconnected() {\n+        connecting = false;\n+\n+        try {\n+            updateStatus(ThingStatus.OFFLINE);\n+\n+            // retry connection if disconnect is not explicitly requested\n+            if (!explicitDisconnect && config.connectionRetryInterval > 0) {\n+                scheduler.schedule(new Runnable() {\n+\n+                    @Override\n+                    public void run() {\n+                        if (connector != null && !connecting && !connector.isConnected()) {\n+                            connect();\n+                        }\n+                    }\n+                }, config.connectionRetryInterval * 1000, TimeUnit.MILLISECONDS);", "originalCommit": "7628cabf0067eac62ce763d8a3457d57685f7766", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU4MjE0MA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367582140", "bodyText": "Adjusted", "author": "ArjenKorevaar", "createdAt": "2020-01-16T18:34:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM2NjU3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM3OTAzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367379031", "bodyText": "Only catch the specific Exception.", "author": "Hilbrand", "createdAt": "2020-01-16T11:58:04Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.LogLevel;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    @Nullable\n+    private OpenThermGatewayConfiguration config;\n+\n+    @Nullable\n+    private OpenThermGatewayConnector connector;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+\n+        config = getConfigAs(OpenThermGatewayConfiguration.class);\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Received channel: {}, command: {}\", channelUID, command);\n+\n+        try {\n+            if (command.toFullString() != \"REFRESH\") {\n+                String channel = channelUID.getId();\n+                String code = getGatewayCodeFromChannel(channel);\n+\n+                GatewayCommand gatewayCommand;\n+                if (command instanceof QuantityType) {\n+                    gatewayCommand = GatewayCommand.parse(code,\n+                            Double.toString(((QuantityType) command).doubleValue()));\n+                } else {\n+                    gatewayCommand = GatewayCommand.parse(code, command.toFullString());\n+                }\n+\n+                if (gatewayCommand != null && checkConnection()) {\n+                    connector.sendCommand(gatewayCommand);\n+                }\n+            }\n+        } catch (Exception ex) {\n+            logger.error(\"error\", ex);\n+        }\n+    }\n+\n+    boolean connecting = false;\n+\n+    @Override\n+    public void connecting() {\n+        connecting = true;\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void connected() {\n+        connecting = false;\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void disconnected() {\n+        connecting = false;\n+\n+        try {\n+            updateStatus(ThingStatus.OFFLINE);\n+\n+            // retry connection if disconnect is not explicitly requested\n+            if (!explicitDisconnect && config.connectionRetryInterval > 0) {\n+                scheduler.schedule(new Runnable() {\n+\n+                    @Override\n+                    public void run() {\n+                        if (connector != null && !connecting && !connector.isConnected()) {\n+                            connect();\n+                        }\n+                    }\n+                }, config.connectionRetryInterval * 1000, TimeUnit.MILLISECONDS);\n+            }\n+        } catch (IllegalStateException ex) {\n+        }\n+    }\n+\n+    @Override\n+    public void receiveMessage(Message message) {\n+        if (DataItemGroup.dataItemGroups.containsKey(message.getID())) {\n+            DataItem[] dataItems = DataItemGroup.dataItemGroups.get(message.getID());\n+\n+            for (int i = 0; i < dataItems.length; i++) {\n+                DataItem dataItem = dataItems[i];\n+\n+                String channelId = dataItem.getSubject();\n+\n+                if (!OpenThermGatewayBindingConstants.SUPPORTED_CHANNEL_IDS.contains(channelId)) {\n+                    continue;\n+                }\n+\n+                State state = null;\n+\n+                switch (dataItem.getDataType()) {\n+                    case Flags:\n+                        state = TypeConverter.toOnOffType(message.getBit(dataItem.getByteType(), dataItem.getBitPos()));\n+                        break;\n+                    case Uint8:\n+                    case Uint16:\n+                        state = TypeConverter.toDecimalType(message.getUInt(dataItem.getByteType()));\n+                        break;\n+                    case Int8:\n+                    case Int16:\n+                        state = TypeConverter.toDecimalType(message.getInt(dataItem.getByteType()));\n+                        break;\n+                    case Float:\n+                        state = TypeConverter.toDecimalType(message.getFloat());\n+                        break;\n+                    case DoWToD:\n+                        break;\n+                }\n+\n+                if (state != null) {\n+                    logger.debug(\"Received update for channel '{}': {}\", channelId, state.toFullString());\n+                    try {\n+                        updateState(channelId, state);\n+                    } catch (IllegalStateException e) {\n+                        // Missing callback, possibly due to incorrect initialization. how to handle correctly ?\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void log(LogLevel loglevel, String format, String arg) {\n+        String message = String.format(format, arg);\n+        log(loglevel, message);\n+    }\n+\n+    @Override\n+    public void log(LogLevel loglevel, String message, Throwable t) {\n+        switch (loglevel) {\n+            case Trace:\n+                logger.trace(\"{}\", message, t);\n+                break;\n+            case Debug:\n+                logger.debug(\"{}\", message, t);\n+                break;\n+            case Info:\n+                logger.info(\"{}\", message, t);\n+                break;\n+            case Warning:\n+                logger.warn(\"{}\", message, t);\n+                break;\n+            case Error:\n+                logger.error(\"{}\", message, t);\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    @Override\n+    public void log(LogLevel loglevel, String message) {\n+        switch (loglevel) {\n+            case Trace:\n+                logger.trace(\"{}\", message);\n+                break;\n+            case Debug:\n+                logger.debug(\"{}\", message);\n+                break;\n+            case Info:\n+                logger.info(\"{}\", message);\n+                break;\n+            case Warning:\n+                logger.warn(\"{}\", message);\n+                break;\n+            case Error:\n+                logger.error(\"{}\", message);\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    @Override\n+    public void handleRemoval() {\n+        logger.debug(\"Removing OpenTherm Gateway handler\");\n+        disconnect();\n+        super.handleRemoval();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        disconnect();\n+        super.dispose();\n+    }\n+\n+    private boolean checkConnection() {\n+        if (connector != null && connector.isConnected()) {\n+            return true;\n+        }\n+\n+        return connect();\n+    }\n+\n+    private synchronized boolean connect() {\n+        try {\n+            disconnect();\n+\n+            logger.info(\"Starting OpenTherm Gateway connector\");\n+\n+            explicitDisconnect = false;\n+\n+            connector = new OpenThermGatewaySocketConnector(this, config.ipaddress, config.port);\n+            new Thread(connector).start();\n+\n+            logger.info(\"OpenTherm Gateway connector started\");\n+\n+            return true;\n+        } catch (Exception ex) {", "originalCommit": "7628cabf0067eac62ce763d8a3457d57685f7766", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI4NzA4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r368287087", "bodyText": "Removed catching generic exceptions", "author": "ArjenKorevaar", "createdAt": "2020-01-19T11:36:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM3OTAzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM3OTU2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367379566", "bodyText": "Only log to error if it's a bug. If this exception happens you probably also want to inform the user by setting the thing offline with the exception message.", "author": "Hilbrand", "createdAt": "2020-01-16T11:59:16Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.LogLevel;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    @Nullable\n+    private OpenThermGatewayConfiguration config;\n+\n+    @Nullable\n+    private OpenThermGatewayConnector connector;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+\n+        config = getConfigAs(OpenThermGatewayConfiguration.class);\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Received channel: {}, command: {}\", channelUID, command);\n+\n+        try {\n+            if (command.toFullString() != \"REFRESH\") {\n+                String channel = channelUID.getId();\n+                String code = getGatewayCodeFromChannel(channel);\n+\n+                GatewayCommand gatewayCommand;\n+                if (command instanceof QuantityType) {\n+                    gatewayCommand = GatewayCommand.parse(code,\n+                            Double.toString(((QuantityType) command).doubleValue()));\n+                } else {\n+                    gatewayCommand = GatewayCommand.parse(code, command.toFullString());\n+                }\n+\n+                if (gatewayCommand != null && checkConnection()) {\n+                    connector.sendCommand(gatewayCommand);\n+                }\n+            }\n+        } catch (Exception ex) {\n+            logger.error(\"error\", ex);\n+        }\n+    }\n+\n+    boolean connecting = false;\n+\n+    @Override\n+    public void connecting() {\n+        connecting = true;\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void connected() {\n+        connecting = false;\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void disconnected() {\n+        connecting = false;\n+\n+        try {\n+            updateStatus(ThingStatus.OFFLINE);\n+\n+            // retry connection if disconnect is not explicitly requested\n+            if (!explicitDisconnect && config.connectionRetryInterval > 0) {\n+                scheduler.schedule(new Runnable() {\n+\n+                    @Override\n+                    public void run() {\n+                        if (connector != null && !connecting && !connector.isConnected()) {\n+                            connect();\n+                        }\n+                    }\n+                }, config.connectionRetryInterval * 1000, TimeUnit.MILLISECONDS);\n+            }\n+        } catch (IllegalStateException ex) {\n+        }\n+    }\n+\n+    @Override\n+    public void receiveMessage(Message message) {\n+        if (DataItemGroup.dataItemGroups.containsKey(message.getID())) {\n+            DataItem[] dataItems = DataItemGroup.dataItemGroups.get(message.getID());\n+\n+            for (int i = 0; i < dataItems.length; i++) {\n+                DataItem dataItem = dataItems[i];\n+\n+                String channelId = dataItem.getSubject();\n+\n+                if (!OpenThermGatewayBindingConstants.SUPPORTED_CHANNEL_IDS.contains(channelId)) {\n+                    continue;\n+                }\n+\n+                State state = null;\n+\n+                switch (dataItem.getDataType()) {\n+                    case Flags:\n+                        state = TypeConverter.toOnOffType(message.getBit(dataItem.getByteType(), dataItem.getBitPos()));\n+                        break;\n+                    case Uint8:\n+                    case Uint16:\n+                        state = TypeConverter.toDecimalType(message.getUInt(dataItem.getByteType()));\n+                        break;\n+                    case Int8:\n+                    case Int16:\n+                        state = TypeConverter.toDecimalType(message.getInt(dataItem.getByteType()));\n+                        break;\n+                    case Float:\n+                        state = TypeConverter.toDecimalType(message.getFloat());\n+                        break;\n+                    case DoWToD:\n+                        break;\n+                }\n+\n+                if (state != null) {\n+                    logger.debug(\"Received update for channel '{}': {}\", channelId, state.toFullString());\n+                    try {\n+                        updateState(channelId, state);\n+                    } catch (IllegalStateException e) {\n+                        // Missing callback, possibly due to incorrect initialization. how to handle correctly ?\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void log(LogLevel loglevel, String format, String arg) {\n+        String message = String.format(format, arg);\n+        log(loglevel, message);\n+    }\n+\n+    @Override\n+    public void log(LogLevel loglevel, String message, Throwable t) {\n+        switch (loglevel) {\n+            case Trace:\n+                logger.trace(\"{}\", message, t);\n+                break;\n+            case Debug:\n+                logger.debug(\"{}\", message, t);\n+                break;\n+            case Info:\n+                logger.info(\"{}\", message, t);\n+                break;\n+            case Warning:\n+                logger.warn(\"{}\", message, t);\n+                break;\n+            case Error:\n+                logger.error(\"{}\", message, t);\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    @Override\n+    public void log(LogLevel loglevel, String message) {\n+        switch (loglevel) {\n+            case Trace:\n+                logger.trace(\"{}\", message);\n+                break;\n+            case Debug:\n+                logger.debug(\"{}\", message);\n+                break;\n+            case Info:\n+                logger.info(\"{}\", message);\n+                break;\n+            case Warning:\n+                logger.warn(\"{}\", message);\n+                break;\n+            case Error:\n+                logger.error(\"{}\", message);\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    @Override\n+    public void handleRemoval() {\n+        logger.debug(\"Removing OpenTherm Gateway handler\");\n+        disconnect();\n+        super.handleRemoval();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        disconnect();\n+        super.dispose();\n+    }\n+\n+    private boolean checkConnection() {\n+        if (connector != null && connector.isConnected()) {\n+            return true;\n+        }\n+\n+        return connect();\n+    }\n+\n+    private synchronized boolean connect() {\n+        try {\n+            disconnect();\n+\n+            logger.info(\"Starting OpenTherm Gateway connector\");\n+\n+            explicitDisconnect = false;\n+\n+            connector = new OpenThermGatewaySocketConnector(this, config.ipaddress, config.port);\n+            new Thread(connector).start();\n+\n+            logger.info(\"OpenTherm Gateway connector started\");\n+\n+            return true;\n+        } catch (Exception ex) {\n+            logger.error(\"error\", ex);", "originalCommit": "7628cabf0067eac62ce763d8a3457d57685f7766", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI4NzEyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r368287121", "bodyText": "Adjusted to debug level", "author": "ArjenKorevaar", "createdAt": "2020-01-19T11:37:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM3OTU2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4MDM3NA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367380374", "bodyText": "Always log catched exceptions! Do you really need to catch the exception here? I've not seen it in other places, so you should probably remove the catch here.", "author": "Hilbrand", "createdAt": "2020-01-16T12:01:30Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.LogLevel;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    @Nullable\n+    private OpenThermGatewayConfiguration config;\n+\n+    @Nullable\n+    private OpenThermGatewayConnector connector;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+\n+        config = getConfigAs(OpenThermGatewayConfiguration.class);\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Received channel: {}, command: {}\", channelUID, command);\n+\n+        try {\n+            if (command.toFullString() != \"REFRESH\") {\n+                String channel = channelUID.getId();\n+                String code = getGatewayCodeFromChannel(channel);\n+\n+                GatewayCommand gatewayCommand;\n+                if (command instanceof QuantityType) {\n+                    gatewayCommand = GatewayCommand.parse(code,\n+                            Double.toString(((QuantityType) command).doubleValue()));\n+                } else {\n+                    gatewayCommand = GatewayCommand.parse(code, command.toFullString());\n+                }\n+\n+                if (gatewayCommand != null && checkConnection()) {\n+                    connector.sendCommand(gatewayCommand);\n+                }\n+            }\n+        } catch (Exception ex) {\n+            logger.error(\"error\", ex);\n+        }\n+    }\n+\n+    boolean connecting = false;\n+\n+    @Override\n+    public void connecting() {\n+        connecting = true;\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void connected() {\n+        connecting = false;\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void disconnected() {\n+        connecting = false;\n+\n+        try {\n+            updateStatus(ThingStatus.OFFLINE);\n+\n+            // retry connection if disconnect is not explicitly requested\n+            if (!explicitDisconnect && config.connectionRetryInterval > 0) {\n+                scheduler.schedule(new Runnable() {\n+\n+                    @Override\n+                    public void run() {\n+                        if (connector != null && !connecting && !connector.isConnected()) {\n+                            connect();\n+                        }\n+                    }\n+                }, config.connectionRetryInterval * 1000, TimeUnit.MILLISECONDS);\n+            }\n+        } catch (IllegalStateException ex) {\n+        }\n+    }\n+\n+    @Override\n+    public void receiveMessage(Message message) {\n+        if (DataItemGroup.dataItemGroups.containsKey(message.getID())) {\n+            DataItem[] dataItems = DataItemGroup.dataItemGroups.get(message.getID());\n+\n+            for (int i = 0; i < dataItems.length; i++) {\n+                DataItem dataItem = dataItems[i];\n+\n+                String channelId = dataItem.getSubject();\n+\n+                if (!OpenThermGatewayBindingConstants.SUPPORTED_CHANNEL_IDS.contains(channelId)) {\n+                    continue;\n+                }\n+\n+                State state = null;\n+\n+                switch (dataItem.getDataType()) {\n+                    case Flags:\n+                        state = TypeConverter.toOnOffType(message.getBit(dataItem.getByteType(), dataItem.getBitPos()));\n+                        break;\n+                    case Uint8:\n+                    case Uint16:\n+                        state = TypeConverter.toDecimalType(message.getUInt(dataItem.getByteType()));\n+                        break;\n+                    case Int8:\n+                    case Int16:\n+                        state = TypeConverter.toDecimalType(message.getInt(dataItem.getByteType()));\n+                        break;\n+                    case Float:\n+                        state = TypeConverter.toDecimalType(message.getFloat());\n+                        break;\n+                    case DoWToD:\n+                        break;\n+                }\n+\n+                if (state != null) {\n+                    logger.debug(\"Received update for channel '{}': {}\", channelId, state.toFullString());\n+                    try {\n+                        updateState(channelId, state);\n+                    } catch (IllegalStateException e) {\n+                        // Missing callback, possibly due to incorrect initialization. how to handle correctly ?", "originalCommit": "7628cabf0067eac62ce763d8a3457d57685f7766", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc5MjI1NA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367792254", "bodyText": "Removed", "author": "ArjenKorevaar", "createdAt": "2020-01-17T06:57:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4MDM3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4MDkxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367380911", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        for (int i = 0; i < dataItems.length; i++) {\n          \n          \n            \n                        for (DataItem dataItem: dataItems) {", "author": "Hilbrand", "createdAt": "2020-01-16T12:02:53Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.LogLevel;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    @Nullable\n+    private OpenThermGatewayConfiguration config;\n+\n+    @Nullable\n+    private OpenThermGatewayConnector connector;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+\n+        config = getConfigAs(OpenThermGatewayConfiguration.class);\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Received channel: {}, command: {}\", channelUID, command);\n+\n+        try {\n+            if (command.toFullString() != \"REFRESH\") {\n+                String channel = channelUID.getId();\n+                String code = getGatewayCodeFromChannel(channel);\n+\n+                GatewayCommand gatewayCommand;\n+                if (command instanceof QuantityType) {\n+                    gatewayCommand = GatewayCommand.parse(code,\n+                            Double.toString(((QuantityType) command).doubleValue()));\n+                } else {\n+                    gatewayCommand = GatewayCommand.parse(code, command.toFullString());\n+                }\n+\n+                if (gatewayCommand != null && checkConnection()) {\n+                    connector.sendCommand(gatewayCommand);\n+                }\n+            }\n+        } catch (Exception ex) {\n+            logger.error(\"error\", ex);\n+        }\n+    }\n+\n+    boolean connecting = false;\n+\n+    @Override\n+    public void connecting() {\n+        connecting = true;\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void connected() {\n+        connecting = false;\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void disconnected() {\n+        connecting = false;\n+\n+        try {\n+            updateStatus(ThingStatus.OFFLINE);\n+\n+            // retry connection if disconnect is not explicitly requested\n+            if (!explicitDisconnect && config.connectionRetryInterval > 0) {\n+                scheduler.schedule(new Runnable() {\n+\n+                    @Override\n+                    public void run() {\n+                        if (connector != null && !connecting && !connector.isConnected()) {\n+                            connect();\n+                        }\n+                    }\n+                }, config.connectionRetryInterval * 1000, TimeUnit.MILLISECONDS);\n+            }\n+        } catch (IllegalStateException ex) {\n+        }\n+    }\n+\n+    @Override\n+    public void receiveMessage(Message message) {\n+        if (DataItemGroup.dataItemGroups.containsKey(message.getID())) {\n+            DataItem[] dataItems = DataItemGroup.dataItemGroups.get(message.getID());\n+\n+            for (int i = 0; i < dataItems.length; i++) {", "originalCommit": "7628cabf0067eac62ce763d8a3457d57685f7766", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU4MjQyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367582425", "bodyText": "Adjusted", "author": "ArjenKorevaar", "createdAt": "2020-01-16T18:35:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4MDkxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4MTU2NA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367381564", "bodyText": "Remove this catch", "author": "Hilbrand", "createdAt": "2020-01-16T12:04:20Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.LogLevel;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    @Nullable\n+    private OpenThermGatewayConfiguration config;\n+\n+    @Nullable\n+    private OpenThermGatewayConnector connector;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+\n+        config = getConfigAs(OpenThermGatewayConfiguration.class);\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Received channel: {}, command: {}\", channelUID, command);\n+\n+        try {\n+            if (command.toFullString() != \"REFRESH\") {\n+                String channel = channelUID.getId();\n+                String code = getGatewayCodeFromChannel(channel);\n+\n+                GatewayCommand gatewayCommand;\n+                if (command instanceof QuantityType) {\n+                    gatewayCommand = GatewayCommand.parse(code,\n+                            Double.toString(((QuantityType) command).doubleValue()));\n+                } else {\n+                    gatewayCommand = GatewayCommand.parse(code, command.toFullString());\n+                }\n+\n+                if (gatewayCommand != null && checkConnection()) {\n+                    connector.sendCommand(gatewayCommand);\n+                }\n+            }\n+        } catch (Exception ex) {\n+            logger.error(\"error\", ex);\n+        }\n+    }\n+\n+    boolean connecting = false;\n+\n+    @Override\n+    public void connecting() {\n+        connecting = true;\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void connected() {\n+        connecting = false;\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void disconnected() {\n+        connecting = false;\n+\n+        try {\n+            updateStatus(ThingStatus.OFFLINE);\n+\n+            // retry connection if disconnect is not explicitly requested\n+            if (!explicitDisconnect && config.connectionRetryInterval > 0) {\n+                scheduler.schedule(new Runnable() {\n+\n+                    @Override\n+                    public void run() {\n+                        if (connector != null && !connecting && !connector.isConnected()) {\n+                            connect();\n+                        }\n+                    }\n+                }, config.connectionRetryInterval * 1000, TimeUnit.MILLISECONDS);\n+            }\n+        } catch (IllegalStateException ex) {", "originalCommit": "7628cabf0067eac62ce763d8a3457d57685f7766", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc5MjY3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367792675", "bodyText": "Removed", "author": "ArjenKorevaar", "createdAt": "2020-01-17T06:59:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4MTU2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4MTcxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367381715", "bodyText": "Is this catch needed?", "author": "Hilbrand", "createdAt": "2020-01-16T12:04:41Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.LogLevel;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    @Nullable\n+    private OpenThermGatewayConfiguration config;\n+\n+    @Nullable\n+    private OpenThermGatewayConnector connector;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+\n+        config = getConfigAs(OpenThermGatewayConfiguration.class);\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Received channel: {}, command: {}\", channelUID, command);\n+\n+        try {\n+            if (command.toFullString() != \"REFRESH\") {\n+                String channel = channelUID.getId();\n+                String code = getGatewayCodeFromChannel(channel);\n+\n+                GatewayCommand gatewayCommand;\n+                if (command instanceof QuantityType) {\n+                    gatewayCommand = GatewayCommand.parse(code,\n+                            Double.toString(((QuantityType) command).doubleValue()));\n+                } else {\n+                    gatewayCommand = GatewayCommand.parse(code, command.toFullString());\n+                }\n+\n+                if (gatewayCommand != null && checkConnection()) {\n+                    connector.sendCommand(gatewayCommand);\n+                }\n+            }\n+        } catch (Exception ex) {", "originalCommit": "7628cabf0067eac62ce763d8a3457d57685f7766", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc5Mjc0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367792749", "bodyText": "Removed", "author": "ArjenKorevaar", "createdAt": "2020-01-17T06:59:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4MTcxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4MjQ2NA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367382464", "bodyText": "Don't compare string with !=. But you should check here on instanceof\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (command.toFullString() != \"REFRESH\") {\n          \n          \n            \n                        if (!command instanceof RefreshType) {\n          \n      \n    \n    \n  \n\nYou do need to handle the RefreshType command  by updating the channel with the known (or unknown) value.", "author": "Hilbrand", "createdAt": "2020-01-16T12:06:34Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.LogLevel;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    @Nullable\n+    private OpenThermGatewayConfiguration config;\n+\n+    @Nullable\n+    private OpenThermGatewayConnector connector;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+\n+        config = getConfigAs(OpenThermGatewayConfiguration.class);\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Received channel: {}, command: {}\", channelUID, command);\n+\n+        try {\n+            if (command.toFullString() != \"REFRESH\") {", "originalCommit": "7628cabf0067eac62ce763d8a3457d57685f7766", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIzOTk3NA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r368239974", "bodyText": "Changed comparison. Not sure how to respond to refreshtype commands. The binding doesn't keep track of the values, nor can it read the values from the OTGW device. The device reports the values continuously to the socket and the binding maps the incoming values to the channels.", "author": "ArjenKorevaar", "createdAt": "2020-01-18T18:02:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4MjQ2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY4OTIwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r421689205", "bodyText": "Hi @Hilbrand, could you please review this PR and this comment in particular ?", "author": "ArjenKorevaar", "createdAt": "2020-05-07T17:57:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4MjQ2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4Mjk2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367382966", "bodyText": "Uppercase enum values:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Read,\n          \n          \n            \n                READ,", "author": "Hilbrand", "createdAt": "2020-01-16T12:08:03Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/Msg.java", "diffHunk": "@@ -0,0 +1,22 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+public enum Msg {\n+    Read,", "originalCommit": "7628cabf0067eac62ce763d8a3457d57685f7766", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU4MjY0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367582641", "bodyText": "Adjusted", "author": "ArjenKorevaar", "createdAt": "2020-01-16T18:35:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4Mjk2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4MzA3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367383075", "bodyText": "Remove, see other comment.", "author": "Hilbrand", "createdAt": "2020-01-16T12:08:22Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewayCallback.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public interface OpenThermGatewayCallback {\n+    public void connecting();\n+\n+    public void connected();\n+\n+    public void disconnected();\n+\n+    public void receiveMessage(Message message);\n+\n+    public void log(LogLevel loglevel, String message);\n+\n+    public void log(LogLevel loglevel, String format, String arg);\n+\n+    public void log(LogLevel loglevel, String format, Throwable t);", "originalCommit": "7628cabf0067eac62ce763d8a3457d57685f7766", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc5OTc3MA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367799770", "bodyText": "I'd like to resolve this comment to keep a clean overview of work to be done, please see my other comment on logging from the thread. Once I get to test that, I will remove the logging callback methods alltogether.", "author": "ArjenKorevaar", "createdAt": "2020-01-17T07:29:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4MzA3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4MzMxMw==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367383313", "bodyText": "Remove public on interface methods. It's not needed as interface methods are public by convention.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void connecting();\n          \n          \n            \n                void connecting();", "author": "Hilbrand", "createdAt": "2020-01-16T12:09:02Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewayCallback.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public interface OpenThermGatewayCallback {\n+    public void connecting();", "originalCommit": "7628cabf0067eac62ce763d8a3457d57685f7766", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU4MjczNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367582735", "bodyText": "Adjusted", "author": "ArjenKorevaar", "createdAt": "2020-01-16T18:36:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4MzMxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4MzUxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367383511", "bodyText": "Remove public, see other comment.", "author": "Hilbrand", "createdAt": "2020-01-16T12:09:32Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewayConnector.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public interface OpenThermGatewayConnector extends Runnable {\n+    public void sendCommand(GatewayCommand command);", "originalCommit": "7628cabf0067eac62ce763d8a3457d57685f7766", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU4MjgxOA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367582818", "bodyText": "Adjusted", "author": "ArjenKorevaar", "createdAt": "2020-01-16T18:36:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4MzUxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4Mzc1NA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367383754", "bodyText": "Remove immediate we don't set it on binding components.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Component(service = ThingHandlerFactory.class, immediate = true, configurationPid = \"binding.openthermgateway\")\n          \n          \n            \n            @Component(service = ThingHandlerFactory.class, configurationPid = \"binding.openthermgateway\")", "author": "Hilbrand", "createdAt": "2020-01-16T12:10:15Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewayHandlerFactory.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.handler.OpenThermGatewayHandler;\n+import org.osgi.service.component.annotations.Component;\n+\n+/**\n+ * The {@link OpenThermGatewayHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@Component(service = ThingHandlerFactory.class, immediate = true, configurationPid = \"binding.openthermgateway\")", "originalCommit": "7628cabf0067eac62ce763d8a3457d57685f7766", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU4Mjk3NA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367582974", "bodyText": "Adjusted", "author": "ArjenKorevaar", "createdAt": "2020-01-16T18:36:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4Mzc1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4NDI5OA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367384298", "bodyText": "Use the timeunit in the variable name so it's easy to see what the unit is:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final int COMMAND_RESPONSE_TIME = 100;\n          \n          \n            \n                private static final int COMMAND_RESPONSE_TIME_MILLISECONDS = 100;\n          \n      \n    \n    \n  \n\nSame for COMMAND_TIMEOUT", "author": "Hilbrand", "createdAt": "2020-01-16T12:11:34Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewaySocketConnector.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.AbstractMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.handler.TypeConverter;\n+\n+/**\n+ * The {@link OpenThermGatewaySocketConnector} is responsible for handling the socket connection\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ * @author Arjan Mels - Improved robustness by re-sending commands, handling all message types (not only Boiler)\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewaySocketConnector implements OpenThermGatewayConnector {\n+    private static final int COMMAND_RESPONSE_TIME = 100;", "originalCommit": "7628cabf0067eac62ce763d8a3457d57685f7766", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU4MzA2MA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367583060", "bodyText": "Adjusted", "author": "ArjenKorevaar", "createdAt": "2020-01-16T18:36:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4NDI5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4NjU1NA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367386554", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        for (int i = 0; i < dataItems.length; i++) {\n          \n          \n            \n                        for (DataItem dataItem: dataItems) {", "author": "Hilbrand", "createdAt": "2020-01-16T12:17:06Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewaySocketConnector.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.AbstractMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.handler.TypeConverter;\n+\n+/**\n+ * The {@link OpenThermGatewaySocketConnector} is responsible for handling the socket connection\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ * @author Arjan Mels - Improved robustness by re-sending commands, handling all message types (not only Boiler)\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewaySocketConnector implements OpenThermGatewayConnector {\n+    private static final int COMMAND_RESPONSE_TIME = 100;\n+    private static final int COMMAND_TIMEOUT = 5000;\n+\n+    private OpenThermGatewayCallback callback;\n+    private String ipaddress;\n+    private int port;\n+\n+    private @Nullable Socket socket;\n+    private @Nullable BufferedReader reader;\n+    private @Nullable PrintWriter writer;\n+\n+    private volatile boolean stopping;\n+    private boolean connected;\n+\n+    public OpenThermGatewaySocketConnector(OpenThermGatewayCallback callback, String ipaddress, int port) {\n+        this.callback = callback;\n+        this.ipaddress = ipaddress;\n+        this.port = port;\n+    }\n+\n+    @Override\n+    public void run() {\n+        stopping = false;\n+        connected = false;\n+\n+        try {\n+            callback.log(LogLevel.Info,\n+                    String.format(\"Connecting OpenThermGatewaySocketConnector to %s:%s\", this.ipaddress, this.port));\n+\n+            callback.connecting();\n+\n+            socket = new Socket();\n+            socket.connect(new InetSocketAddress(this.ipaddress, this.port), COMMAND_TIMEOUT);\n+            socket.setSoTimeout(COMMAND_TIMEOUT);\n+            writer = new PrintWriter(socket.getOutputStream(), true);\n+            reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+\n+            connected = true;\n+\n+            callback.connected();\n+\n+            callback.log(LogLevel.Debug, \"OpenThermGatewaySocketConnector connected\");\n+\n+            sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintReport, \"A\"));\n+            // Set the OTGW to report every message it receives and transmits\n+            sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintSummary, \"0\"));\n+\n+            while (!stopping && !Thread.currentThread().isInterrupted()) {\n+                @Nullable\n+                String message = reader.readLine();\n+\n+                if (message != null) {\n+                    handleMessage(message);\n+                } else {\n+                    callback.log(LogLevel.Info, \"Connection closed by OpenTherm Gateway\");\n+                    break;\n+                }\n+            }\n+\n+            callback.log(LogLevel.Debug, \"Stopping OpenThermGatewaySocketConnector\");\n+\n+        } catch (Exception e) {\n+            callback.log(LogLevel.Error, \"An error occured in OpenThermGatewaySocketConnector: %s\", e.getMessage());\n+        } finally {\n+\n+            if (writer != null) {\n+                writer.flush();\n+                writer.close();\n+            }\n+\n+            close(reader);\n+            close(writer);\n+\n+            connected = false;\n+\n+            callback.log(LogLevel.Debug, \"OpenThermGatewaySocketConnector disconnected\");\n+            callback.disconnected();\n+        }\n+    }\n+\n+    @Override\n+    public synchronized void stop() {\n+        callback.log(LogLevel.Debug, \"Stopping OpenThermGatewaySocketConnector\");\n+\n+        stopping = true;\n+\n+        close(socket);\n+    }\n+\n+    @Override\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    Map<String, Entry<Long, GatewayCommand>> pendingCommands = new HashMap<>();\n+\n+    @Override\n+    public void sendCommand(GatewayCommand command) {\n+        String msg = command.toFullString();\n+\n+        pendingCommands.put(command.getCode(),\n+                new AbstractMap.SimpleImmutableEntry<>(System.currentTimeMillis(), command));\n+\n+        if (connected) {\n+            callback.log(LogLevel.Debug, \"Sending message: %s\", msg);\n+            writer.printf(\"%s\\r\\n\", msg);\n+        } else {\n+            callback.log(LogLevel.Debug,\n+                    \"Unable to send message: %s. OpenThermGatewaySocketConnector is not connected.\", msg);\n+        }\n+    }\n+\n+    private void handleMessage(String message) {\n+        if (message.length() > 2 && message.charAt(2) == ':') {\n+            String code = message.substring(0, 2);\n+            String value = message.substring(3);\n+            callback.log(LogLevel.Debug, String.format(\"Received command confirmation: %s: %s\", code, value));\n+            pendingCommands.remove(code);\n+            return;\n+        }\n+\n+        for (Entry<Long, GatewayCommand> timeAndCommand : pendingCommands.values()) {\n+            if (System.currentTimeMillis() > timeAndCommand.getKey() + COMMAND_RESPONSE_TIME) {\n+                callback.log(LogLevel.Debug,\n+                        String.format(\"Resending command: %s\", timeAndCommand.getValue().toFullString()));\n+                sendCommand(timeAndCommand.getValue());\n+            } else if (System.currentTimeMillis() > timeAndCommand.getKey() + COMMAND_TIMEOUT) {\n+                pendingCommands.remove(timeAndCommand.getValue().getCode());\n+            }\n+        }\n+\n+        Message msg = Message.parse(message);\n+\n+        if (msg == null) {\n+            callback.log(LogLevel.Debug, \"Received message: %s, (unknown)\", message);\n+            return;\n+        } else {\n+            callback.log(LogLevel.Debug, String.format(\"Received message: %s, %d %s %s\", message, msg.getID(),\n+                    msg.getCode(), msg.getMessageType().toString()));\n+        }\n+\n+        if (DataItemGroup.dataItemGroups.containsKey(msg.getID())) {\n+            DataItem[] dataItems = DataItemGroup.dataItemGroups.get(msg.getID());\n+\n+            for (int i = 0; i < dataItems.length; i++) {", "originalCommit": "7628cabf0067eac62ce763d8a3457d57685f7766", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU4MzEyMA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367583120", "bodyText": "Adjusted", "author": "ArjenKorevaar", "createdAt": "2020-01-16T18:36:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4NjU1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4ODI0NA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367388244", "bodyText": "Uppercase enums:", "author": "Hilbrand", "createdAt": "2020-01-16T12:21:21Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/MessageType.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+public enum MessageType {\n+    ReadData, // 000", "originalCommit": "7628cabf0067eac62ce763d8a3457d57685f7766", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU4MzE3OA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367583178", "bodyText": "Adjusted", "author": "ArjenKorevaar", "createdAt": "2020-01-16T18:36:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4ODI0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4OTA2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367389067", "bodyText": "Don't compare strings with ==:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (other != null && this.getID() == other.getID() && (this.getCode() == \"R\" || this.getCode() == \"A\")) {\n          \n          \n            \n                    return other != null && this.getID() == other.getID() && (\"R\".equals(this.getCode()) || \"A\".equals(this.getCode()));\n          \n      \n    \n    \n  \n\nAnd just return the condition.", "author": "Hilbrand", "createdAt": "2020-01-16T12:23:28Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/Message.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Message {\n+    /*\n+     * The code field is not part of OpenTherm specification, but added by OpenTherm Gateway.\n+     * It can be any of the following:\n+     *\n+     * T: Message received from the thermostat\n+     * B: Message received from the boiler\n+     * R: Request sent to the boiler\n+     * A: Response returned to the thermostat\n+     * E: Parity or stop bit error\n+     */\n+\n+    private String code;\n+    private MessageType messageType;\n+    private int id;\n+    private String data;\n+\n+    public String getCode() {\n+        return this.code;\n+    }\n+\n+    public MessageType getMessageType() {\n+        return messageType;\n+    }\n+\n+    public int getID() {\n+        return id;\n+    }\n+\n+    public @Nullable String getData(ByteType byteType) {\n+        if (this.data.length() == 4) {\n+            switch (byteType) {\n+                case HighByte:\n+                    return this.data.substring(0, 2);\n+                case LowByte:\n+                    return this.data.substring(2, 4);\n+                case Both:\n+                    return this.data;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    public boolean getBit(ByteType byteType, int pos) {\n+        @Nullable\n+        String data = getData(byteType);\n+\n+        if (data != null) {\n+            // First parse the hex value to an integer\n+            int parsed = Integer.parseInt(data, 16);\n+\n+            // Then right shift it pos positions so that the required bit is at the front\n+            // and then apply a bitmask of 00000001 (1)\n+            return ((parsed >> pos) & 1) == 1;\n+        }\n+\n+        return false;\n+    }\n+\n+    public int getUInt(ByteType byteType) {\n+        @Nullable\n+        String data = getData(byteType);\n+\n+        if (data != null) {\n+            return Integer.parseInt(data, 16);\n+        }\n+\n+        return 0;\n+    }\n+\n+    public int getInt(ByteType byteType) {\n+        @Nullable\n+        String data = getData(byteType);\n+\n+        if (data != null) {\n+            return parseSignedInteger(data);\n+        }\n+\n+        return 0;\n+    }\n+\n+    public float getFloat() {\n+        // f8.8, two's complement\n+        @Nullable\n+        String data = getData(ByteType.Both);\n+\n+        if (data != null) {\n+            long value = Long.parseLong(data, 16);\n+\n+            // left padded with zeros\n+            String binary = String.format(\"%16s\", Long.toBinaryString(value)).replace(' ', '0');\n+\n+            if (binary.charAt(0) == '1') {\n+                // negative value\n+\n+                String inverted = invertBinary(binary);\n+\n+                value = Long.parseLong(inverted, 2);\n+                value = value + 1;\n+                value = value * -1;\n+            }\n+\n+            // divide by 2^8 = 256\n+            return (float) value / 256;\n+        }\n+\n+        return 0;\n+    }\n+\n+    public boolean overrides(@Nullable Message other) {\n+        // If the message is a Request sent to the boiler or an Answer returned to the\n+        // thermostat, and it's ID is equal to the previous message, then this is an\n+        // override sent by the OpenTherm Gateway\n+        if (other != null && this.getID() == other.getID() && (this.getCode() == \"R\" || this.getCode() == \"A\")) {", "originalCommit": "7628cabf0067eac62ce763d8a3457d57685f7766", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU4MzI3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367583271", "bodyText": "Adjusted", "author": "ArjenKorevaar", "createdAt": "2020-01-16T18:37:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4OTA2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4OTU4MA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367389580", "bodyText": "Remove TODO.", "author": "Hilbrand", "createdAt": "2020-01-16T12:24:49Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/Message.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Message {\n+    /*\n+     * The code field is not part of OpenTherm specification, but added by OpenTherm Gateway.\n+     * It can be any of the following:\n+     *\n+     * T: Message received from the thermostat\n+     * B: Message received from the boiler\n+     * R: Request sent to the boiler\n+     * A: Response returned to the thermostat\n+     * E: Parity or stop bit error\n+     */\n+\n+    private String code;\n+    private MessageType messageType;\n+    private int id;\n+    private String data;\n+\n+    public String getCode() {\n+        return this.code;\n+    }\n+\n+    public MessageType getMessageType() {\n+        return messageType;\n+    }\n+\n+    public int getID() {\n+        return id;\n+    }\n+\n+    public @Nullable String getData(ByteType byteType) {\n+        if (this.data.length() == 4) {\n+            switch (byteType) {\n+                case HighByte:\n+                    return this.data.substring(0, 2);\n+                case LowByte:\n+                    return this.data.substring(2, 4);\n+                case Both:\n+                    return this.data;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    public boolean getBit(ByteType byteType, int pos) {\n+        @Nullable\n+        String data = getData(byteType);\n+\n+        if (data != null) {\n+            // First parse the hex value to an integer\n+            int parsed = Integer.parseInt(data, 16);\n+\n+            // Then right shift it pos positions so that the required bit is at the front\n+            // and then apply a bitmask of 00000001 (1)\n+            return ((parsed >> pos) & 1) == 1;\n+        }\n+\n+        return false;\n+    }\n+\n+    public int getUInt(ByteType byteType) {\n+        @Nullable\n+        String data = getData(byteType);\n+\n+        if (data != null) {\n+            return Integer.parseInt(data, 16);\n+        }\n+\n+        return 0;\n+    }\n+\n+    public int getInt(ByteType byteType) {\n+        @Nullable\n+        String data = getData(byteType);\n+\n+        if (data != null) {\n+            return parseSignedInteger(data);\n+        }\n+\n+        return 0;\n+    }\n+\n+    public float getFloat() {\n+        // f8.8, two's complement\n+        @Nullable\n+        String data = getData(ByteType.Both);\n+\n+        if (data != null) {\n+            long value = Long.parseLong(data, 16);\n+\n+            // left padded with zeros\n+            String binary = String.format(\"%16s\", Long.toBinaryString(value)).replace(' ', '0');\n+\n+            if (binary.charAt(0) == '1') {\n+                // negative value\n+\n+                String inverted = invertBinary(binary);\n+\n+                value = Long.parseLong(inverted, 2);\n+                value = value + 1;\n+                value = value * -1;\n+            }\n+\n+            // divide by 2^8 = 256\n+            return (float) value / 256;\n+        }\n+\n+        return 0;\n+    }\n+\n+    public boolean overrides(@Nullable Message other) {\n+        // If the message is a Request sent to the boiler or an Answer returned to the\n+        // thermostat, and it's ID is equal to the previous message, then this is an\n+        // override sent by the OpenTherm Gateway\n+        if (other != null && this.getID() == other.getID() && (this.getCode() == \"R\" || this.getCode() == \"A\")) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"%s - %s - %s\", this.code, this.id, this.data);\n+    }\n+\n+    public Message(String code, MessageType messageType, int id, String data) {\n+        this.code = code;\n+        this.messageType = messageType;\n+        this.id = id;\n+        this.data = data;\n+    }\n+\n+    public static @Nullable Message parse(String message) {\n+        if (message.matches(\"[TBRA]{1}[A-F0-9]{8}\")) {\n+\n+            // For now, only parse TBRA codes\n+            String code = message.substring(0, 1);\n+            MessageType messageType = getMessageType(message.substring(1, 3));\n+            int id = Integer.valueOf(message.substring(3, 5), 16);\n+            String data = message.substring(5);\n+\n+            return new Message(code, messageType, id, data);\n+        }\n+\n+        return null;\n+    }\n+\n+    private static MessageType getMessageType(String value) {\n+        // First parse the hex value to an integer\n+        int integer = Integer.parseInt(value, 16);\n+\n+        // Then right shift it 4 bits so that the message type bits are at the front\n+        int shifted = integer >> 4;\n+\n+        // Then mask it with 00000111 (7), so that we only get the first 3 bits,\n+        // effectively cutting off the parity bit.\n+        int cutoff = shifted & 7;\n+\n+        switch (cutoff) {\n+            case 0: // 000\n+                return MessageType.ReadData;\n+            case 1: // 001\n+                return MessageType.WriteData;\n+            case 2: // 010\n+                return MessageType.InvalidData;\n+            case 3: // 011\n+                return MessageType.Reserved;\n+            case 4: // 100\n+                return MessageType.ReadAck;\n+            case 5: // 101\n+                return MessageType.WriteAck;\n+            case 6: // 110\n+                return MessageType.DataInvalid;\n+            case 7: // 111\n+            default:\n+                return MessageType.UnknownDataId;\n+        }\n+    }\n+\n+    private int parseSignedInteger(String data) {\n+        // First parse the hex value to an unsigned integer value\n+        int result = Integer.parseInt(data, 16);\n+\n+        // TODO: more elegant way of determining the bitmask based on the parsed integer", "originalCommit": "7628cabf0067eac62ce763d8a3457d57685f7766", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU4MzM3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367583372", "bodyText": "Removed", "author": "ArjenKorevaar", "createdAt": "2020-01-16T18:37:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4OTU4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4OTc4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367389786", "bodyText": "Remove this enum see other comment about logging.", "author": "Hilbrand", "createdAt": "2020-01-16T12:25:22Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/LogLevel.java", "diffHunk": "@@ -0,0 +1,24 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+public enum LogLevel {", "originalCommit": "7628cabf0067eac62ce763d8a3457d57685f7766", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI4NDA1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r368284051", "bodyText": "Removed, see other comment about removing logging callback", "author": "ArjenKorevaar", "createdAt": "2020-01-19T10:44:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM4OTc4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5MDEwNw==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367390107", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if ((code == null || code == \"\") && message.length() > 2 && message.charAt(2) == '=') {\n          \n          \n            \n                    if ((code == null || code.isEmpty()) && message.length() > 2 && message.charAt(2) == '=') {", "author": "Hilbrand", "createdAt": "2020-01-16T12:26:10Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/GatewayCommand.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.util.HashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class GatewayCommand {\n+    private String code;\n+    private String validationSet;\n+    private String message;\n+\n+    public String getCode() {\n+        return code;\n+    }\n+\n+    public String getMessage() {\n+        return this.message;\n+    }\n+\n+    public String getValidationSet() {\n+        return validationSet;\n+    }\n+\n+    public String toFullString() {\n+        return this.code + \"=\" + this.message;\n+    }\n+\n+    private GatewayCommand(String code, String message, String validationSet) throws Exception {\n+        this.code = code;\n+        this.message = message;\n+        this.validationSet = validationSet;\n+\n+        if (!validate()) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"Invalid value '%s' for code '%s'\", this.message, this.code));\n+        }\n+    }\n+\n+    private boolean validate() {\n+        if (this.validationSet == null || this.validationSet == \"\") {\n+            return true;\n+        }\n+\n+        String[] validations = this.validationSet.split(\",\");\n+\n+        for (int i = 0; i < validations.length; i++) {\n+            if (this.message.equals(validations[i])) {\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    public static GatewayCommand parse(String code, String message) throws Exception {\n+        if ((code == null || code == \"\") && message.length() > 2 && message.charAt(2) == '=') {", "originalCommit": "7628cabf0067eac62ce763d8a3457d57685f7766", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU4MzQ3OA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367583478", "bodyText": "Adjusted", "author": "ArjenKorevaar", "createdAt": "2020-01-16T18:37:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5MDEwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5MDM3OA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367390378", "bodyText": "Can you make the thrown exception more specific or does a method actual throw Exception?", "author": "Hilbrand", "createdAt": "2020-01-16T12:26:50Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/GatewayCommand.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.util.HashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class GatewayCommand {\n+    private String code;\n+    private String validationSet;\n+    private String message;\n+\n+    public String getCode() {\n+        return code;\n+    }\n+\n+    public String getMessage() {\n+        return this.message;\n+    }\n+\n+    public String getValidationSet() {\n+        return validationSet;\n+    }\n+\n+    public String toFullString() {\n+        return this.code + \"=\" + this.message;\n+    }\n+\n+    private GatewayCommand(String code, String message, String validationSet) throws Exception {\n+        this.code = code;\n+        this.message = message;\n+        this.validationSet = validationSet;\n+\n+        if (!validate()) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"Invalid value '%s' for code '%s'\", this.message, this.code));\n+        }\n+    }\n+\n+    private boolean validate() {\n+        if (this.validationSet == null || this.validationSet == \"\") {\n+            return true;\n+        }\n+\n+        String[] validations = this.validationSet.split(\",\");\n+\n+        for (int i = 0; i < validations.length; i++) {\n+            if (this.message.equals(validations[i])) {\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    public static GatewayCommand parse(String code, String message) throws Exception {", "originalCommit": "7628cabf0067eac62ce763d8a3457d57685f7766", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgwMDMxMA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367800310", "bodyText": "Changed to IllegalArgumentException, and with that, also the try/catch in calling code", "author": "ArjenKorevaar", "createdAt": "2020-01-17T07:31:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5MDM3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5MDU3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367390576", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (int i = 0; i < validations.length; i++) {\n          \n          \n            \n                    for (String validation: validations) {", "author": "Hilbrand", "createdAt": "2020-01-16T12:27:21Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/GatewayCommand.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.util.HashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class GatewayCommand {\n+    private String code;\n+    private String validationSet;\n+    private String message;\n+\n+    public String getCode() {\n+        return code;\n+    }\n+\n+    public String getMessage() {\n+        return this.message;\n+    }\n+\n+    public String getValidationSet() {\n+        return validationSet;\n+    }\n+\n+    public String toFullString() {\n+        return this.code + \"=\" + this.message;\n+    }\n+\n+    private GatewayCommand(String code, String message, String validationSet) throws Exception {\n+        this.code = code;\n+        this.message = message;\n+        this.validationSet = validationSet;\n+\n+        if (!validate()) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"Invalid value '%s' for code '%s'\", this.message, this.code));\n+        }\n+    }\n+\n+    private boolean validate() {\n+        if (this.validationSet == null || this.validationSet == \"\") {\n+            return true;\n+        }\n+\n+        String[] validations = this.validationSet.split(\",\");\n+\n+        for (int i = 0; i < validations.length; i++) {", "originalCommit": "7628cabf0067eac62ce763d8a3457d57685f7766", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU4MzU3MA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367583570", "bodyText": "Adjusted", "author": "ArjenKorevaar", "createdAt": "2020-01-16T18:38:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5MDU3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5MDcwMA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367390700", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (this.validationSet == null || this.validationSet == \"\") {\n          \n          \n            \n                    if (this.validationSet == null || this.validationSet.isEmpty()) {", "author": "Hilbrand", "createdAt": "2020-01-16T12:27:38Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/GatewayCommand.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.util.HashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class GatewayCommand {\n+    private String code;\n+    private String validationSet;\n+    private String message;\n+\n+    public String getCode() {\n+        return code;\n+    }\n+\n+    public String getMessage() {\n+        return this.message;\n+    }\n+\n+    public String getValidationSet() {\n+        return validationSet;\n+    }\n+\n+    public String toFullString() {\n+        return this.code + \"=\" + this.message;\n+    }\n+\n+    private GatewayCommand(String code, String message, String validationSet) throws Exception {\n+        this.code = code;\n+        this.message = message;\n+        this.validationSet = validationSet;\n+\n+        if (!validate()) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"Invalid value '%s' for code '%s'\", this.message, this.code));\n+        }\n+    }\n+\n+    private boolean validate() {\n+        if (this.validationSet == null || this.validationSet == \"\") {", "originalCommit": "7628cabf0067eac62ce763d8a3457d57685f7766", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU4MzY2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367583669", "bodyText": "Adjusted", "author": "ArjenKorevaar", "createdAt": "2020-01-16T18:38:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5MDcwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5MDk5OA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367390998", "bodyText": "It looks like the fields and methods in the class are not used?", "author": "Hilbrand", "createdAt": "2020-01-16T12:28:25Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/DataItemGroup.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.util.HashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DataItemGroup {\n+    private int id;\n+    private DataItem[] dataItems;\n+\n+    public int getID() {\n+        return id;\n+    }\n+\n+    public void setID(int id) {\n+        this.id = id;\n+    }\n+\n+    public DataItem[] getDataItems() {\n+        return dataItems;\n+    }\n+\n+    public void setDataItem(DataItem[] dataItems) {", "originalCommit": "7628cabf0067eac62ce763d8a3457d57685f7766", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgwMjMxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367802319", "bodyText": "It's a datastructure that represents the OpenTherm protocol specifications of data-id's, types and mapping of payload bytes. I created it to have a complete dataset of all the possible messages, but (after some refactoring) ended up not using everything.. Then again, it's very nice to be able to lookup the individual message types and relate them to the data-id's from the OT specification..", "author": "ArjenKorevaar", "createdAt": "2020-01-17T07:39:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5MDk5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM5NjE2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r368396162", "bodyText": "After taking another look.. there were indeed some attribute on DataItemGroup that were now nolonger needed. I also removed some setters from DataItem, since it's intention is to be a reference list of OpenTherm commands, and therefor not to be modified once created.", "author": "ArjenKorevaar", "createdAt": "2020-01-20T07:15:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5MDk5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5MTI2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367391269", "bodyText": "Uppercase enum, see other comment.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                HighByte,\n          \n          \n            \n                HIGH_BYTE,", "author": "Hilbrand", "createdAt": "2020-01-16T12:29:08Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/ByteType.java", "diffHunk": "@@ -0,0 +1,22 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+public enum ByteType {\n+    HighByte,", "originalCommit": "7628cabf0067eac62ce763d8a3457d57685f7766", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU4Mzc4NA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367583784", "bodyText": "Adjusted", "author": "ArjenKorevaar", "createdAt": "2020-01-16T18:38:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5MTI2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5MTY5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367391692", "bodyText": "This class doesn't seem to add much value. I suggest to remove it. OnOffType can be used as  OnOffType.from(value)", "author": "Hilbrand", "createdAt": "2020-01-16T12:30:19Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/TypeConverter.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+\n+/**\n+ * The {@link TypeConverter} is used to convert simple values to SmartHome types\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TypeConverter {", "originalCommit": "7628cabf0067eac62ce763d8a3457d57685f7766", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU4MzkxNw==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367583917", "bodyText": "Removed", "author": "ArjenKorevaar", "createdAt": "2020-01-16T18:38:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5MTY5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5MjE5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367392196", "bodyText": "Please remove this. Don't add custom logging features.", "author": "Hilbrand", "createdAt": "2020-01-16T12:31:40Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.LogLevel;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    @Nullable\n+    private OpenThermGatewayConfiguration config;\n+\n+    @Nullable\n+    private OpenThermGatewayConnector connector;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+\n+        config = getConfigAs(OpenThermGatewayConfiguration.class);\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Received channel: {}, command: {}\", channelUID, command);\n+\n+        try {\n+            if (command.toFullString() != \"REFRESH\") {\n+                String channel = channelUID.getId();\n+                String code = getGatewayCodeFromChannel(channel);\n+\n+                GatewayCommand gatewayCommand;\n+                if (command instanceof QuantityType) {\n+                    gatewayCommand = GatewayCommand.parse(code,\n+                            Double.toString(((QuantityType) command).doubleValue()));\n+                } else {\n+                    gatewayCommand = GatewayCommand.parse(code, command.toFullString());\n+                }\n+\n+                if (gatewayCommand != null && checkConnection()) {\n+                    connector.sendCommand(gatewayCommand);\n+                }\n+            }\n+        } catch (Exception ex) {\n+            logger.error(\"error\", ex);\n+        }\n+    }\n+\n+    boolean connecting = false;\n+\n+    @Override\n+    public void connecting() {\n+        connecting = true;\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void connected() {\n+        connecting = false;\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void disconnected() {\n+        connecting = false;\n+\n+        try {\n+            updateStatus(ThingStatus.OFFLINE);\n+\n+            // retry connection if disconnect is not explicitly requested\n+            if (!explicitDisconnect && config.connectionRetryInterval > 0) {\n+                scheduler.schedule(new Runnable() {\n+\n+                    @Override\n+                    public void run() {\n+                        if (connector != null && !connecting && !connector.isConnected()) {\n+                            connect();\n+                        }\n+                    }\n+                }, config.connectionRetryInterval * 1000, TimeUnit.MILLISECONDS);\n+            }\n+        } catch (IllegalStateException ex) {\n+        }\n+    }\n+\n+    @Override\n+    public void receiveMessage(Message message) {\n+        if (DataItemGroup.dataItemGroups.containsKey(message.getID())) {\n+            DataItem[] dataItems = DataItemGroup.dataItemGroups.get(message.getID());\n+\n+            for (int i = 0; i < dataItems.length; i++) {\n+                DataItem dataItem = dataItems[i];\n+\n+                String channelId = dataItem.getSubject();\n+\n+                if (!OpenThermGatewayBindingConstants.SUPPORTED_CHANNEL_IDS.contains(channelId)) {\n+                    continue;\n+                }\n+\n+                State state = null;\n+\n+                switch (dataItem.getDataType()) {\n+                    case Flags:\n+                        state = TypeConverter.toOnOffType(message.getBit(dataItem.getByteType(), dataItem.getBitPos()));\n+                        break;\n+                    case Uint8:\n+                    case Uint16:\n+                        state = TypeConverter.toDecimalType(message.getUInt(dataItem.getByteType()));\n+                        break;\n+                    case Int8:\n+                    case Int16:\n+                        state = TypeConverter.toDecimalType(message.getInt(dataItem.getByteType()));\n+                        break;\n+                    case Float:\n+                        state = TypeConverter.toDecimalType(message.getFloat());\n+                        break;\n+                    case DoWToD:\n+                        break;\n+                }\n+\n+                if (state != null) {\n+                    logger.debug(\"Received update for channel '{}': {}\", channelId, state.toFullString());\n+                    try {\n+                        updateState(channelId, state);\n+                    } catch (IllegalStateException e) {\n+                        // Missing callback, possibly due to incorrect initialization. how to handle correctly ?\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void log(LogLevel loglevel, String format, String arg) {\n+        String message = String.format(format, arg);\n+        log(loglevel, message);\n+    }\n+\n+    @Override\n+    public void log(LogLevel loglevel, String message, Throwable t) {\n+        switch (loglevel) {\n+            case Trace:\n+                logger.trace(\"{}\", message, t);\n+                break;\n+            case Debug:\n+                logger.debug(\"{}\", message, t);\n+                break;\n+            case Info:\n+                logger.info(\"{}\", message, t);\n+                break;\n+            case Warning:\n+                logger.warn(\"{}\", message, t);\n+                break;\n+            case Error:\n+                logger.error(\"{}\", message, t);\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    @Override\n+    public void log(LogLevel loglevel, String message) {\n+        switch (loglevel) {\n+            case Trace:\n+                logger.trace(\"{}\", message);\n+                break;\n+            case Debug:\n+                logger.debug(\"{}\", message);\n+                break;\n+            case Info:\n+                logger.info(\"{}\", message);\n+                break;\n+            case Warning:\n+                logger.warn(\"{}\", message);\n+                break;\n+            case Error:\n+                logger.error(\"{}\", message);\n+                break;\n+            default:\n+                break;\n+        }\n+    }", "originalCommit": "7628cabf0067eac62ce763d8a3457d57685f7766", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc5MDA3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367790073", "bodyText": "The thought behind this was that the connector running in a separate thread didn't have access to the logging framework. Therefor a mechanism was added that logs via a callback to the thinghandler, which in turns logs to logging framework. Will test to see if I can log from the thread, then this part of the callback interface can be removed.", "author": "ArjenKorevaar", "createdAt": "2020-01-17T06:48:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5MjE5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI4NDAxMg==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r368284012", "bodyText": "After running some tests, removed logging callback and let connector log directly to logging framework", "author": "ArjenKorevaar", "createdAt": "2020-01-19T10:43:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5MjE5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5Mjc4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367392787", "bodyText": "Put @nullable annotations inline on fields:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private OpenThermGatewayConfiguration config;\n          \n          \n            \n                private @Nullable OpenThermGatewayConfiguration config;", "author": "Hilbrand", "createdAt": "2020-01-16T12:33:20Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.LogLevel;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    @Nullable\n+    private OpenThermGatewayConfiguration config;", "originalCommit": "7628cabf0067eac62ce763d8a3457d57685f7766", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU4NDEyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367584121", "bodyText": "Removed newline after @nullable's", "author": "ArjenKorevaar", "createdAt": "2020-01-16T18:39:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5Mjc4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5NDE5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367394195", "bodyText": "Currently there are no channels that have a QuantityType so this check is not needed. However I would suggest to make some of the channels with unit UoM (see my other comment). In that case you can do this check. However you need to pass the correct unit to get the value of the command otherwise you might end up with a different unit you expect. For example if it's a temperature unit, but the command contains Fahrenheit you need to get the Celsius value probably. So you need to pass Celcius to get the double value.", "author": "Hilbrand", "createdAt": "2020-01-16T12:36:47Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.LogLevel;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    @Nullable\n+    private OpenThermGatewayConfiguration config;\n+\n+    @Nullable\n+    private OpenThermGatewayConnector connector;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+\n+        config = getConfigAs(OpenThermGatewayConfiguration.class);\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Received channel: {}, command: {}\", channelUID, command);\n+\n+        try {\n+            if (command.toFullString() != \"REFRESH\") {\n+                String channel = channelUID.getId();\n+                String code = getGatewayCodeFromChannel(channel);\n+\n+                GatewayCommand gatewayCommand;\n+                if (command instanceof QuantityType) {", "originalCommit": "7628cabf0067eac62ce763d8a3457d57685f7766", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI3MzY2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r368273662", "bodyText": "Changed the temperature channels to UoM back and forth", "author": "ArjenKorevaar", "createdAt": "2020-01-19T07:59:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5NDE5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5NTczNA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367395734", "bodyText": "Can you catch the specific exception here or add RuntimException\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } catch (Exception e) {\n          \n          \n            \n                    } catch (Exception e) {", "author": "Hilbrand", "createdAt": "2020-01-16T12:40:51Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewaySocketConnector.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.AbstractMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.handler.TypeConverter;\n+\n+/**\n+ * The {@link OpenThermGatewaySocketConnector} is responsible for handling the socket connection\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ * @author Arjan Mels - Improved robustness by re-sending commands, handling all message types (not only Boiler)\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewaySocketConnector implements OpenThermGatewayConnector {\n+    private static final int COMMAND_RESPONSE_TIME = 100;\n+    private static final int COMMAND_TIMEOUT = 5000;\n+\n+    private OpenThermGatewayCallback callback;\n+    private String ipaddress;\n+    private int port;\n+\n+    private @Nullable Socket socket;\n+    private @Nullable BufferedReader reader;\n+    private @Nullable PrintWriter writer;\n+\n+    private volatile boolean stopping;\n+    private boolean connected;\n+\n+    public OpenThermGatewaySocketConnector(OpenThermGatewayCallback callback, String ipaddress, int port) {\n+        this.callback = callback;\n+        this.ipaddress = ipaddress;\n+        this.port = port;\n+    }\n+\n+    @Override\n+    public void run() {\n+        stopping = false;\n+        connected = false;\n+\n+        try {\n+            callback.log(LogLevel.Info,\n+                    String.format(\"Connecting OpenThermGatewaySocketConnector to %s:%s\", this.ipaddress, this.port));\n+\n+            callback.connecting();\n+\n+            socket = new Socket();\n+            socket.connect(new InetSocketAddress(this.ipaddress, this.port), COMMAND_TIMEOUT);\n+            socket.setSoTimeout(COMMAND_TIMEOUT);\n+            writer = new PrintWriter(socket.getOutputStream(), true);\n+            reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+\n+            connected = true;\n+\n+            callback.connected();\n+\n+            callback.log(LogLevel.Debug, \"OpenThermGatewaySocketConnector connected\");\n+\n+            sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintReport, \"A\"));\n+            // Set the OTGW to report every message it receives and transmits\n+            sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintSummary, \"0\"));\n+\n+            while (!stopping && !Thread.currentThread().isInterrupted()) {\n+                @Nullable\n+                String message = reader.readLine();\n+\n+                if (message != null) {\n+                    handleMessage(message);\n+                } else {\n+                    callback.log(LogLevel.Info, \"Connection closed by OpenTherm Gateway\");\n+                    break;\n+                }\n+            }\n+\n+            callback.log(LogLevel.Debug, \"Stopping OpenThermGatewaySocketConnector\");\n+\n+        } catch (Exception e) {", "originalCommit": "7628cabf0067eac62ce763d8a3457d57685f7766", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI4NzA1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r368287051", "bodyText": "Removed catching generic exceptions", "author": "ArjenKorevaar", "createdAt": "2020-01-19T11:36:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5NTczNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5NjYyOA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367396628", "bodyText": "Use try-with-resources:\ntry (writer = new PrintWriter(socket.getOutputStream(), true);\n            reader = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {\n\nThen you don't have to call close.", "author": "Hilbrand", "createdAt": "2020-01-16T12:43:12Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewaySocketConnector.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.AbstractMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.handler.TypeConverter;\n+\n+/**\n+ * The {@link OpenThermGatewaySocketConnector} is responsible for handling the socket connection\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ * @author Arjan Mels - Improved robustness by re-sending commands, handling all message types (not only Boiler)\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewaySocketConnector implements OpenThermGatewayConnector {\n+    private static final int COMMAND_RESPONSE_TIME = 100;\n+    private static final int COMMAND_TIMEOUT = 5000;\n+\n+    private OpenThermGatewayCallback callback;\n+    private String ipaddress;\n+    private int port;\n+\n+    private @Nullable Socket socket;\n+    private @Nullable BufferedReader reader;\n+    private @Nullable PrintWriter writer;\n+\n+    private volatile boolean stopping;\n+    private boolean connected;\n+\n+    public OpenThermGatewaySocketConnector(OpenThermGatewayCallback callback, String ipaddress, int port) {\n+        this.callback = callback;\n+        this.ipaddress = ipaddress;\n+        this.port = port;\n+    }\n+\n+    @Override\n+    public void run() {\n+        stopping = false;\n+        connected = false;\n+\n+        try {\n+            callback.log(LogLevel.Info,\n+                    String.format(\"Connecting OpenThermGatewaySocketConnector to %s:%s\", this.ipaddress, this.port));\n+\n+            callback.connecting();\n+\n+            socket = new Socket();\n+            socket.connect(new InetSocketAddress(this.ipaddress, this.port), COMMAND_TIMEOUT);\n+            socket.setSoTimeout(COMMAND_TIMEOUT);\n+            writer = new PrintWriter(socket.getOutputStream(), true);\n+            reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));", "originalCommit": "7628cabf0067eac62ce763d8a3457d57685f7766", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgwMjg0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r367802843", "bodyText": "Like the using statement from c#, didn't know Java had such a thing. Anyway, causes compiler errors on my machine, so need to look into this..", "author": "ArjenKorevaar", "createdAt": "2020-01-17T07:41:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5NjYyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI4NzAwNw==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r368287007", "bodyText": "Fixed compiler error with updating java, implemeted try-with-resources", "author": "ArjenKorevaar", "createdAt": "2020-01-19T11:35:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5NjYyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA5MTcxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r389091715", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable private OpenThermGatewayConfiguration config;\n          \n          \n            \n                 private @Nullable OpenThermGatewayConfiguration config;", "author": "cpmeister", "createdAt": "2020-03-06T19:15:49Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    @Nullable private OpenThermGatewayConfiguration config;", "originalCommit": "0c36fa6da3feb3c234f3e175c5e4698ed64b335a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI0ODc0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r389248749", "bodyText": "Adjusted", "author": "ArjenKorevaar", "createdAt": "2020-03-07T11:39:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA5MTcxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA5MTkxMg==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r389091912", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable private OpenThermGatewayConnector connector;\n          \n          \n            \n                private @Nullable OpenThermGatewayConnector connector;", "author": "cpmeister", "createdAt": "2020-03-06T19:16:13Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    @Nullable private OpenThermGatewayConfiguration config;\n+\n+    @Nullable private OpenThermGatewayConnector connector;", "originalCommit": "0c36fa6da3feb3c234f3e175c5e4698ed64b335a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI0ODczMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r389248731", "bodyText": "Adjusted", "author": "ArjenKorevaar", "createdAt": "2020-03-07T11:39:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA5MTkxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA5MjgyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r389092825", "bodyText": "I would suggest add a description to your OFFLINE status updates so that users know what is going on", "author": "cpmeister", "createdAt": "2020-03-06T19:17:58Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    @Nullable private OpenThermGatewayConfiguration config;\n+\n+    @Nullable private OpenThermGatewayConnector connector;\n+\n+    private boolean connecting = false;\n+\n+    private boolean explicitDisconnect = false;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+\n+        config = getConfigAs(OpenThermGatewayConfiguration.class);\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Received channel: {}, command: {}\", channelUID, command);\n+\n+        if (!(command instanceof RefreshType)) {\n+            String channel = channelUID.getId();\n+            String code = getGatewayCodeFromChannel(channel);\n+\n+            GatewayCommand gatewayCommand;\n+\n+            if (command instanceof QuantityType<?>) {\n+                double value  = ((QuantityType<?>) command).toUnit(SIUnits.CELSIUS).doubleValue();\n+                gatewayCommand = GatewayCommand.parse(code, Double.toString(value));\n+            } else {\n+                gatewayCommand = GatewayCommand.parse(code, command.toFullString());\n+            }\n+\n+            if (gatewayCommand != null && checkConnection()) {\n+                connector.sendCommand(gatewayCommand);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void connecting() {\n+        connecting = true;\n+        updateStatus(ThingStatus.OFFLINE);", "originalCommit": "0c36fa6da3feb3c234f3e175c5e4698ed64b335a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI0ODcyMA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r389248720", "bodyText": "Added a description", "author": "ArjenKorevaar", "createdAt": "2020-03-07T11:39:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA5MjgyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA5ODg4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r389098889", "bodyText": "Don't create unmanaged threads\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    new Thread(connector).start();\n          \n          \n            \n                    scheduler.execute(connector);", "author": "cpmeister", "createdAt": "2020-03-06T19:30:59Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    @Nullable private OpenThermGatewayConfiguration config;\n+\n+    @Nullable private OpenThermGatewayConnector connector;\n+\n+    private boolean connecting = false;\n+\n+    private boolean explicitDisconnect = false;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+\n+        config = getConfigAs(OpenThermGatewayConfiguration.class);\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Received channel: {}, command: {}\", channelUID, command);\n+\n+        if (!(command instanceof RefreshType)) {\n+            String channel = channelUID.getId();\n+            String code = getGatewayCodeFromChannel(channel);\n+\n+            GatewayCommand gatewayCommand;\n+\n+            if (command instanceof QuantityType<?>) {\n+                double value  = ((QuantityType<?>) command).toUnit(SIUnits.CELSIUS).doubleValue();\n+                gatewayCommand = GatewayCommand.parse(code, Double.toString(value));\n+            } else {\n+                gatewayCommand = GatewayCommand.parse(code, command.toFullString());\n+            }\n+\n+            if (gatewayCommand != null && checkConnection()) {\n+                connector.sendCommand(gatewayCommand);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void connecting() {\n+        connecting = true;\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void connected() {\n+        connecting = false;\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void disconnected() {\n+        connecting = false;\n+        \n+        updateStatus(ThingStatus.OFFLINE);\n+\n+        // retry connection if disconnect is not explicitly requested\n+        if (!explicitDisconnect && config.connectionRetryInterval > 0) {\n+            scheduler.schedule(() -> {\n+                if (connector != null && !connecting && !connector.isConnected()) {\n+                    connect();\n+                }\n+            }, config.connectionRetryInterval, TimeUnit.SECONDS);\n+        }    \n+    }\n+\n+    @Override\n+    public void receiveMessage(Message message) {\n+        if (DataItemGroup.dataItemGroups.containsKey(message.getID())) {\n+            DataItem[] dataItems = DataItemGroup.dataItemGroups.get(message.getID());\n+\n+            for (DataItem dataItem: dataItems) {\n+                String channelId = dataItem.getSubject();\n+\n+                if (!OpenThermGatewayBindingConstants.SUPPORTED_CHANNEL_IDS.contains(channelId)) {\n+                    continue;\n+                }\n+\n+                State state = null;\n+\n+                switch (dataItem.getDataType()) {\n+                    case FLAGS:\n+                        state = OnOffType.from(message.getBit(dataItem.getByteType(), dataItem.getBitPos()));\n+                        break;\n+                    case UINT8:\n+                    case UINT16:\n+                        state = new DecimalType(message.getUInt(dataItem.getByteType()));\n+                        break;\n+                    case INT8:\n+                    case INT16:\n+                        state = new DecimalType(message.getInt(dataItem.getByteType()));\n+                        break;\n+                    case FLOAT:\n+                        float value = message.getFloat();\n+                        @Nullable Unit<?> unit = dataItem.getUnit();\n+                        state = (unit == null) ? new DecimalType(value) : new QuantityType<>(value, unit);\n+                        break;\n+                    case DOWTOD:\n+                        break;\n+                }\n+          \n+                if (state != null) {\n+                    logger.debug(\"Received update for channel '{}': {}\", channelId, state.toFullString());\n+                    updateState(channelId, state);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleRemoval() {\n+        logger.debug(\"Removing OpenTherm Gateway handler\");\n+        disconnect();\n+        super.handleRemoval();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        disconnect();\n+        super.dispose();\n+    }\n+\n+    private boolean checkConnection() {\n+        if (connector != null && connector.isConnected()) {\n+            return true;\n+        }\n+\n+        return connect();\n+    }\n+\n+    private synchronized boolean connect() {\n+        disconnect();\n+\n+        logger.info(\"Starting OpenTherm Gateway connector\");\n+\n+        explicitDisconnect = false;\n+\n+        connector = new OpenThermGatewaySocketConnector(this, config.ipaddress, config.port);\n+        new Thread(connector).start();", "originalCommit": "0c36fa6da3feb3c234f3e175c5e4698ed64b335a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI0ODY1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r389248659", "bodyText": "From what I understand, the scheduler is used to execute a particular task at a given time, optionally recurring at an interval. This would work perfectly for, let say, reading data from some REST API. This thread however is used to have a constant loop listening for incoming data on the TCP socket, for which (again from what I understand) the Scheduler would not be suitable.\nI have asked questions about this on the forum, but didn't get a helpful answer. I also looked at at implementations from other bindings that have a similar character (ie. the constant loop) and there a separate thread is also used. Also, previous reviews from Hilbrand and J-N-K (amongst others) have so far not commented on using a thread in this particular situation.\nAnyway, if you feel that this should really be solved using a Scheduler, I will try to find some time to furter investigate the options.", "author": "ArjenKorevaar", "createdAt": "2020-03-07T11:38:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA5ODg4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkxODYxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r389918615", "bodyText": "Alright I see your point. Then at the very least you need to make sure that the created thread is named and is daemon. Make sure the thread name includes the name of the binding and its purpose.", "author": "cpmeister", "createdAt": "2020-03-09T19:41:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA5ODg4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3ODExMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r390378111", "bodyText": "Thanks again! Added the name and made the thread daemon", "author": "ArjenKorevaar", "createdAt": "2020-03-10T14:58:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA5ODg4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA5OTYyOA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r389099628", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    }     \n          \n          \n            \n                    catch (IOException ex) {\n          \n          \n            \n                    } catch (IOException ex) {", "author": "cpmeister", "createdAt": "2020-03-06T19:32:39Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewaySocketConnector.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.AbstractMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewaySocketConnector} is responsible for handling the socket connection\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ * @author Arjan Mels - Improved robustness by re-sending commands, handling all message types (not only Boiler)\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewaySocketConnector implements OpenThermGatewayConnector {\n+    private static final int COMMAND_RESPONSE_TIME_MILLISECONDS = 100;\n+    private static final int COMMAND_TIMEOUT_MILLISECONDS = 5000;\n+\n+    private OpenThermGatewayCallback callback;\n+    private String ipaddress;\n+    private int port;\n+\n+    private @Nullable PrintWriter writer;\n+\n+    private volatile boolean stopping;\n+    private boolean connected;\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewaySocketConnector.class);\n+\n+    public OpenThermGatewaySocketConnector(OpenThermGatewayCallback callback, String ipaddress, int port) {\n+        this.callback = callback;\n+        this.ipaddress = ipaddress;\n+        this.port = port;\n+    }\n+\n+    @Override\n+    public void run() {\n+        stopping = false;\n+        connected = false;\n+        \n+        logger.info(\"Connecting OpenThermGatewaySocketConnector to {}:{}\", this.ipaddress, this.port);\n+\n+        callback.connecting();\n+        \n+        try (Socket socket = new Socket()) {            \n+            socket.connect(new InetSocketAddress(this.ipaddress, this.port), COMMAND_TIMEOUT_MILLISECONDS);\n+            socket.setSoTimeout(COMMAND_TIMEOUT_MILLISECONDS);\n+    \n+            connected = true;\n+    \n+            callback.connected();\n+    \n+            logger.info(\"OpenThermGatewaySocketConnector connected\");\n+    \n+            try (BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                PrintWriter wrt = new PrintWriter(socket.getOutputStream(), true)) {\n+                    // Make writer accessible on class level\n+                    writer = wrt;\n+    \n+                    sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintReport, \"A\"));\n+                    // Set the OTGW to report every message it receives and transmits\n+                    sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintSummary, \"0\"));\n+        \n+                    while (!stopping && !Thread.currentThread().isInterrupted()) {\n+                        @Nullable String message = reader.readLine();\n+        \n+                        if (message != null) {\n+                            handleMessage(message);\n+                        } else {\n+                            logger.info(\"Connection closed by OpenTherm Gateway\");\n+                            break;\n+                        }\n+                    }\n+        \n+                    logger.info(\"Stopping OpenThermGatewaySocketConnector\");\n+            }\n+            finally {\n+                connected = false;\n+    \n+                logger.info(\"OpenThermGatewaySocketConnector disconnected\");\n+                callback.disconnected();\n+            }\n+        }     \n+        catch (IOException ex) {", "originalCommit": "0c36fa6da3feb3c234f3e175c5e4698ed64b335a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI0ODIzNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r389248235", "bodyText": "Adjusted", "author": "ArjenKorevaar", "createdAt": "2020-03-07T11:30:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA5OTYyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTExMDQ3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r389110477", "bodyText": "please put all fields at the top of the class, also make it private if possible", "author": "cpmeister", "createdAt": "2020-03-06T19:48:26Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewaySocketConnector.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.AbstractMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewaySocketConnector} is responsible for handling the socket connection\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ * @author Arjan Mels - Improved robustness by re-sending commands, handling all message types (not only Boiler)\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewaySocketConnector implements OpenThermGatewayConnector {\n+    private static final int COMMAND_RESPONSE_TIME_MILLISECONDS = 100;\n+    private static final int COMMAND_TIMEOUT_MILLISECONDS = 5000;\n+\n+    private OpenThermGatewayCallback callback;\n+    private String ipaddress;\n+    private int port;\n+\n+    private @Nullable PrintWriter writer;\n+\n+    private volatile boolean stopping;\n+    private boolean connected;\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewaySocketConnector.class);\n+\n+    public OpenThermGatewaySocketConnector(OpenThermGatewayCallback callback, String ipaddress, int port) {\n+        this.callback = callback;\n+        this.ipaddress = ipaddress;\n+        this.port = port;\n+    }\n+\n+    @Override\n+    public void run() {\n+        stopping = false;\n+        connected = false;\n+        \n+        logger.info(\"Connecting OpenThermGatewaySocketConnector to {}:{}\", this.ipaddress, this.port);\n+\n+        callback.connecting();\n+        \n+        try (Socket socket = new Socket()) {            \n+            socket.connect(new InetSocketAddress(this.ipaddress, this.port), COMMAND_TIMEOUT_MILLISECONDS);\n+            socket.setSoTimeout(COMMAND_TIMEOUT_MILLISECONDS);\n+    \n+            connected = true;\n+    \n+            callback.connected();\n+    \n+            logger.info(\"OpenThermGatewaySocketConnector connected\");\n+    \n+            try (BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                PrintWriter wrt = new PrintWriter(socket.getOutputStream(), true)) {\n+                    // Make writer accessible on class level\n+                    writer = wrt;\n+    \n+                    sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintReport, \"A\"));\n+                    // Set the OTGW to report every message it receives and transmits\n+                    sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintSummary, \"0\"));\n+        \n+                    while (!stopping && !Thread.currentThread().isInterrupted()) {\n+                        @Nullable String message = reader.readLine();\n+        \n+                        if (message != null) {\n+                            handleMessage(message);\n+                        } else {\n+                            logger.info(\"Connection closed by OpenTherm Gateway\");\n+                            break;\n+                        }\n+                    }\n+        \n+                    logger.info(\"Stopping OpenThermGatewaySocketConnector\");\n+            }\n+            finally {\n+                connected = false;\n+    \n+                logger.info(\"OpenThermGatewaySocketConnector disconnected\");\n+                callback.disconnected();\n+            }\n+        }     \n+        catch (IOException ex) {\n+            logger.warn(\"Unable to connect to the OpenTherm Gateway.\" , ex);\n+        }        \n+    }\n+\n+    @Override\n+    public synchronized void stop() {\n+        logger.info(\"Stopping OpenThermGatewaySocketConnector\");\n+        stopping = true;\n+    }\n+\n+    @Override\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    Map<String, Entry<Long, GatewayCommand>> pendingCommands = new HashMap<>();", "originalCommit": "0c36fa6da3feb3c234f3e175c5e4698ed64b335a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI0ODAxOA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r389248018", "bodyText": "Adjusted", "author": "ArjenKorevaar", "createdAt": "2020-03-07T11:27:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTExMDQ3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTExMzQ1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r389113459", "bodyText": "I would also flush the writer here to make sure the data gets sent", "author": "cpmeister", "createdAt": "2020-03-06T19:55:03Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewaySocketConnector.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.AbstractMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewaySocketConnector} is responsible for handling the socket connection\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ * @author Arjan Mels - Improved robustness by re-sending commands, handling all message types (not only Boiler)\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewaySocketConnector implements OpenThermGatewayConnector {\n+    private static final int COMMAND_RESPONSE_TIME_MILLISECONDS = 100;\n+    private static final int COMMAND_TIMEOUT_MILLISECONDS = 5000;\n+\n+    private OpenThermGatewayCallback callback;\n+    private String ipaddress;\n+    private int port;\n+\n+    private @Nullable PrintWriter writer;\n+\n+    private volatile boolean stopping;\n+    private boolean connected;\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewaySocketConnector.class);\n+\n+    public OpenThermGatewaySocketConnector(OpenThermGatewayCallback callback, String ipaddress, int port) {\n+        this.callback = callback;\n+        this.ipaddress = ipaddress;\n+        this.port = port;\n+    }\n+\n+    @Override\n+    public void run() {\n+        stopping = false;\n+        connected = false;\n+        \n+        logger.info(\"Connecting OpenThermGatewaySocketConnector to {}:{}\", this.ipaddress, this.port);\n+\n+        callback.connecting();\n+        \n+        try (Socket socket = new Socket()) {            \n+            socket.connect(new InetSocketAddress(this.ipaddress, this.port), COMMAND_TIMEOUT_MILLISECONDS);\n+            socket.setSoTimeout(COMMAND_TIMEOUT_MILLISECONDS);\n+    \n+            connected = true;\n+    \n+            callback.connected();\n+    \n+            logger.info(\"OpenThermGatewaySocketConnector connected\");\n+    \n+            try (BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                PrintWriter wrt = new PrintWriter(socket.getOutputStream(), true)) {\n+                    // Make writer accessible on class level\n+                    writer = wrt;\n+    \n+                    sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintReport, \"A\"));\n+                    // Set the OTGW to report every message it receives and transmits\n+                    sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintSummary, \"0\"));\n+        \n+                    while (!stopping && !Thread.currentThread().isInterrupted()) {\n+                        @Nullable String message = reader.readLine();\n+        \n+                        if (message != null) {\n+                            handleMessage(message);\n+                        } else {\n+                            logger.info(\"Connection closed by OpenTherm Gateway\");\n+                            break;\n+                        }\n+                    }\n+        \n+                    logger.info(\"Stopping OpenThermGatewaySocketConnector\");\n+            }\n+            finally {\n+                connected = false;\n+    \n+                logger.info(\"OpenThermGatewaySocketConnector disconnected\");\n+                callback.disconnected();\n+            }\n+        }     \n+        catch (IOException ex) {\n+            logger.warn(\"Unable to connect to the OpenTherm Gateway.\" , ex);\n+        }        \n+    }\n+\n+    @Override\n+    public synchronized void stop() {\n+        logger.info(\"Stopping OpenThermGatewaySocketConnector\");\n+        stopping = true;\n+    }\n+\n+    @Override\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    Map<String, Entry<Long, GatewayCommand>> pendingCommands = new HashMap<>();\n+\n+    @Override\n+    public void sendCommand(GatewayCommand command) {\n+        String msg = command.toFullString();\n+\n+        pendingCommands.put(command.getCode(), new AbstractMap.SimpleImmutableEntry<>(System.currentTimeMillis(), command));\n+\n+        if (connected) {\n+            logger.debug(\"Sending message: {}\", msg);\n+            writer.printf(\"%s\\r\\n\", msg);", "originalCommit": "0c36fa6da3feb3c234f3e175c5e4698ed64b335a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI0ODAzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r389248031", "bodyText": "Adjusted", "author": "ArjenKorevaar", "createdAt": "2020-03-07T11:27:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTExMzQ1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTExNzE3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r389117172", "bodyText": "So all this code is just for trace logging? If this code is only for logging then separate it out into its own method.", "author": "cpmeister", "createdAt": "2020-03-06T20:03:26Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewaySocketConnector.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.AbstractMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewaySocketConnector} is responsible for handling the socket connection\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ * @author Arjan Mels - Improved robustness by re-sending commands, handling all message types (not only Boiler)\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewaySocketConnector implements OpenThermGatewayConnector {\n+    private static final int COMMAND_RESPONSE_TIME_MILLISECONDS = 100;\n+    private static final int COMMAND_TIMEOUT_MILLISECONDS = 5000;\n+\n+    private OpenThermGatewayCallback callback;\n+    private String ipaddress;\n+    private int port;\n+\n+    private @Nullable PrintWriter writer;\n+\n+    private volatile boolean stopping;\n+    private boolean connected;\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewaySocketConnector.class);\n+\n+    public OpenThermGatewaySocketConnector(OpenThermGatewayCallback callback, String ipaddress, int port) {\n+        this.callback = callback;\n+        this.ipaddress = ipaddress;\n+        this.port = port;\n+    }\n+\n+    @Override\n+    public void run() {\n+        stopping = false;\n+        connected = false;\n+        \n+        logger.info(\"Connecting OpenThermGatewaySocketConnector to {}:{}\", this.ipaddress, this.port);\n+\n+        callback.connecting();\n+        \n+        try (Socket socket = new Socket()) {            \n+            socket.connect(new InetSocketAddress(this.ipaddress, this.port), COMMAND_TIMEOUT_MILLISECONDS);\n+            socket.setSoTimeout(COMMAND_TIMEOUT_MILLISECONDS);\n+    \n+            connected = true;\n+    \n+            callback.connected();\n+    \n+            logger.info(\"OpenThermGatewaySocketConnector connected\");\n+    \n+            try (BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                PrintWriter wrt = new PrintWriter(socket.getOutputStream(), true)) {\n+                    // Make writer accessible on class level\n+                    writer = wrt;\n+    \n+                    sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintReport, \"A\"));\n+                    // Set the OTGW to report every message it receives and transmits\n+                    sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintSummary, \"0\"));\n+        \n+                    while (!stopping && !Thread.currentThread().isInterrupted()) {\n+                        @Nullable String message = reader.readLine();\n+        \n+                        if (message != null) {\n+                            handleMessage(message);\n+                        } else {\n+                            logger.info(\"Connection closed by OpenTherm Gateway\");\n+                            break;\n+                        }\n+                    }\n+        \n+                    logger.info(\"Stopping OpenThermGatewaySocketConnector\");\n+            }\n+            finally {\n+                connected = false;\n+    \n+                logger.info(\"OpenThermGatewaySocketConnector disconnected\");\n+                callback.disconnected();\n+            }\n+        }     \n+        catch (IOException ex) {\n+            logger.warn(\"Unable to connect to the OpenTherm Gateway.\" , ex);\n+        }        \n+    }\n+\n+    @Override\n+    public synchronized void stop() {\n+        logger.info(\"Stopping OpenThermGatewaySocketConnector\");\n+        stopping = true;\n+    }\n+\n+    @Override\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    Map<String, Entry<Long, GatewayCommand>> pendingCommands = new HashMap<>();\n+\n+    @Override\n+    public void sendCommand(GatewayCommand command) {\n+        String msg = command.toFullString();\n+\n+        pendingCommands.put(command.getCode(), new AbstractMap.SimpleImmutableEntry<>(System.currentTimeMillis(), command));\n+\n+        if (connected) {\n+            logger.debug(\"Sending message: {}\", msg);\n+            writer.printf(\"%s\\r\\n\", msg);\n+        } else {\n+            logger.debug(\"Unable to send message: {}. OpenThermGatewaySocketConnector is not connected.\", msg);\n+        }\n+    }\n+\n+    private void handleMessage(String message) {\n+        if (message.length() > 2 && message.charAt(2) == ':') {\n+            String code = message.substring(0, 2);\n+            String value = message.substring(3);\n+\n+            logger.debug(\"Received command confirmation: {}: {}\", code, value);\n+            pendingCommands.remove(code);\n+            return;\n+        }\n+\n+        for (Entry<Long, GatewayCommand> timeAndCommand : pendingCommands.values()) {\n+            if (System.currentTimeMillis() > timeAndCommand.getKey() + COMMAND_RESPONSE_TIME_MILLISECONDS) {\n+                logger.debug(\"Resending command: {}\", timeAndCommand.getValue().toFullString());\n+                sendCommand(timeAndCommand.getValue());\n+            } else if (System.currentTimeMillis() > timeAndCommand.getKey() + COMMAND_TIMEOUT_MILLISECONDS) {\n+                pendingCommands.remove(timeAndCommand.getValue().getCode());\n+            }\n+        }\n+\n+        Message msg = Message.parse(message);\n+\n+        if (msg == null) {\n+            logger.trace(\"Received message: {}, (unknown)\", message);\n+            return;\n+        } else {\n+            logger.trace(\"Received message: {}, {} {} {}\", message, msg.getID(), msg.getCode(), msg.getMessageType().toString());\n+        }\n+\n+        if (DataItemGroup.dataItemGroups.containsKey(msg.getID())) {\n+            DataItem[] dataItems = DataItemGroup.dataItemGroups.get(msg.getID());\n+\n+            for (DataItem dataItem : dataItems) {\n+                State state = null;\n+\n+                switch (dataItem.getDataType()) {\n+                    case FLAGS:\n+                        state = OnOffType.from(msg.getBit(dataItem.getByteType(), dataItem.getBitPos()));\n+                        break;\n+                    case UINT8:\n+                    case UINT16:\n+                        state = new DecimalType(msg.getUInt(dataItem.getByteType()));\n+                        break;\n+                    case INT8:\n+                    case INT16:\n+                        state = new DecimalType(msg.getInt(dataItem.getByteType()));\n+                        break;\n+                    case FLOAT:\n+                        state = new DecimalType(msg.getFloat());\n+                        break;\n+                    case DOWTOD:\n+                        break;\n+                }\n+\n+                logger.trace(\"  Data: {} {} {} {}\", dataItem.getID(), dataItem.getSubject(),\n+                    dataItem.getDataType().toString(), state == null ? \"\" : state.toString());\n+            }\n+        }", "originalCommit": "0c36fa6da3feb3c234f3e175c5e4698ed64b335a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI0ODE5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r389248196", "bodyText": "This code is used to convert the incoming message, based on it's derived datatype, to a SmartHome type (State variable). The logging is just added for tracing information", "author": "ArjenKorevaar", "createdAt": "2020-03-07T11:30:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTExNzE3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQ4OTE5NA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r392489194", "bodyText": "I'm pretty sure that a handler is disposed before it is removed. So I don't think this code is needed.", "author": "cpmeister", "createdAt": "2020-03-13T21:26:51Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    private @Nullable OpenThermGatewayConfiguration config;\n+\n+    private @Nullable OpenThermGatewayConnector connector;\n+\n+    private boolean connecting = false;\n+\n+    private boolean explicitDisconnect = false;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Initializing\");\n+\n+        config = getConfigAs(OpenThermGatewayConfiguration.class);\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Received channel: {}, command: {}\", channelUID, command);\n+\n+        if (!(command instanceof RefreshType)) {\n+            String channel = channelUID.getId();\n+            String code = getGatewayCodeFromChannel(channel);\n+\n+            GatewayCommand gatewayCommand;\n+\n+            if (command instanceof QuantityType<?>) {\n+                double value  = ((QuantityType<?>) command).toUnit(SIUnits.CELSIUS).doubleValue();\n+                gatewayCommand = GatewayCommand.parse(code, Double.toString(value));\n+            } else {\n+                gatewayCommand = GatewayCommand.parse(code, command.toFullString());\n+            }\n+\n+            if (gatewayCommand != null && checkConnection()) {\n+                connector.sendCommand(gatewayCommand);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void connecting() {\n+        connecting = true;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+    }\n+\n+    @Override\n+    public void connected() {\n+        connecting = false;\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void disconnected() {\n+        connecting = false;\n+        \n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Disconnected\");\n+\n+        // retry connection if disconnect is not explicitly requested\n+        if (!explicitDisconnect && config.connectionRetryInterval > 0) {\n+            scheduler.schedule(() -> {\n+                if (connector != null && !connecting && !connector.isConnected()) {\n+                    connect();\n+                }\n+            }, config.connectionRetryInterval, TimeUnit.SECONDS);\n+        }    \n+    }\n+\n+    @Override\n+    public void receiveMessage(Message message) {\n+        if (DataItemGroup.dataItemGroups.containsKey(message.getID())) {\n+            DataItem[] dataItems = DataItemGroup.dataItemGroups.get(message.getID());\n+\n+            for (DataItem dataItem: dataItems) {\n+                String channelId = dataItem.getSubject();\n+\n+                if (!OpenThermGatewayBindingConstants.SUPPORTED_CHANNEL_IDS.contains(channelId)) {\n+                    continue;\n+                }\n+\n+                State state = null;\n+\n+                switch (dataItem.getDataType()) {\n+                    case FLAGS:\n+                        state = OnOffType.from(message.getBit(dataItem.getByteType(), dataItem.getBitPos()));\n+                        break;\n+                    case UINT8:\n+                    case UINT16:\n+                        state = new DecimalType(message.getUInt(dataItem.getByteType()));\n+                        break;\n+                    case INT8:\n+                    case INT16:\n+                        state = new DecimalType(message.getInt(dataItem.getByteType()));\n+                        break;\n+                    case FLOAT:\n+                        float value = message.getFloat();\n+                        @Nullable Unit<?> unit = dataItem.getUnit();\n+                        state = (unit == null) ? new DecimalType(value) : new QuantityType<>(value, unit);\n+                        break;\n+                    case DOWTOD:\n+                        break;\n+                }\n+          \n+                if (state != null) {\n+                    logger.debug(\"Received update for channel '{}': {}\", channelId, state.toFullString());\n+                    updateState(channelId, state);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleRemoval() {\n+        logger.debug(\"Removing OpenTherm Gateway handler\");\n+        disconnect();\n+        super.handleRemoval();\n+    }", "originalCommit": "d33464a4cd21f907708e5483463e3497bf2f3c3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDMyMjg3MA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r394322870", "bodyText": "I'm not worried about the handler itself, I'm calling disconnect() on the background thread when it happens.", "author": "ArjenKorevaar", "createdAt": "2020-03-18T12:53:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQ4OTE5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQ5MDc5MA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r392490790", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.info(\"OpenTherm Gateway connector started\");\n          \n          \n            \n                    logger.debug(\"OpenTherm Gateway connector started\");", "author": "cpmeister", "createdAt": "2020-03-13T21:29:39Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    private @Nullable OpenThermGatewayConfiguration config;\n+\n+    private @Nullable OpenThermGatewayConnector connector;\n+\n+    private boolean connecting = false;\n+\n+    private boolean explicitDisconnect = false;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Initializing\");\n+\n+        config = getConfigAs(OpenThermGatewayConfiguration.class);\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Received channel: {}, command: {}\", channelUID, command);\n+\n+        if (!(command instanceof RefreshType)) {\n+            String channel = channelUID.getId();\n+            String code = getGatewayCodeFromChannel(channel);\n+\n+            GatewayCommand gatewayCommand;\n+\n+            if (command instanceof QuantityType<?>) {\n+                double value  = ((QuantityType<?>) command).toUnit(SIUnits.CELSIUS).doubleValue();\n+                gatewayCommand = GatewayCommand.parse(code, Double.toString(value));\n+            } else {\n+                gatewayCommand = GatewayCommand.parse(code, command.toFullString());\n+            }\n+\n+            if (gatewayCommand != null && checkConnection()) {\n+                connector.sendCommand(gatewayCommand);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void connecting() {\n+        connecting = true;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+    }\n+\n+    @Override\n+    public void connected() {\n+        connecting = false;\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void disconnected() {\n+        connecting = false;\n+        \n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Disconnected\");\n+\n+        // retry connection if disconnect is not explicitly requested\n+        if (!explicitDisconnect && config.connectionRetryInterval > 0) {\n+            scheduler.schedule(() -> {\n+                if (connector != null && !connecting && !connector.isConnected()) {\n+                    connect();\n+                }\n+            }, config.connectionRetryInterval, TimeUnit.SECONDS);\n+        }    \n+    }\n+\n+    @Override\n+    public void receiveMessage(Message message) {\n+        if (DataItemGroup.dataItemGroups.containsKey(message.getID())) {\n+            DataItem[] dataItems = DataItemGroup.dataItemGroups.get(message.getID());\n+\n+            for (DataItem dataItem: dataItems) {\n+                String channelId = dataItem.getSubject();\n+\n+                if (!OpenThermGatewayBindingConstants.SUPPORTED_CHANNEL_IDS.contains(channelId)) {\n+                    continue;\n+                }\n+\n+                State state = null;\n+\n+                switch (dataItem.getDataType()) {\n+                    case FLAGS:\n+                        state = OnOffType.from(message.getBit(dataItem.getByteType(), dataItem.getBitPos()));\n+                        break;\n+                    case UINT8:\n+                    case UINT16:\n+                        state = new DecimalType(message.getUInt(dataItem.getByteType()));\n+                        break;\n+                    case INT8:\n+                    case INT16:\n+                        state = new DecimalType(message.getInt(dataItem.getByteType()));\n+                        break;\n+                    case FLOAT:\n+                        float value = message.getFloat();\n+                        @Nullable Unit<?> unit = dataItem.getUnit();\n+                        state = (unit == null) ? new DecimalType(value) : new QuantityType<>(value, unit);\n+                        break;\n+                    case DOWTOD:\n+                        break;\n+                }\n+          \n+                if (state != null) {\n+                    logger.debug(\"Received update for channel '{}': {}\", channelId, state.toFullString());\n+                    updateState(channelId, state);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleRemoval() {\n+        logger.debug(\"Removing OpenTherm Gateway handler\");\n+        disconnect();\n+        super.handleRemoval();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        disconnect();\n+        super.dispose();\n+    }\n+\n+    private boolean checkConnection() {\n+        if (connector != null && connector.isConnected()) {\n+            return true;\n+        }\n+\n+        return connect();\n+    }\n+\n+    private synchronized boolean connect() {\n+        disconnect();\n+\n+        logger.info(\"Starting OpenTherm Gateway connector\");\n+\n+        explicitDisconnect = false;\n+\n+        connector = new OpenThermGatewaySocketConnector(this, config.ipaddress, config.port);\n+\n+        Thread thread = new Thread(connector, \"OpenTherm Gateway Binding - socket listener thread\");\n+        thread.setDaemon(true);\n+        thread.start();\n+\n+        logger.info(\"OpenTherm Gateway connector started\");", "originalCommit": "d33464a4cd21f907708e5483463e3497bf2f3c3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDMyNzIwMg==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r394327202", "bodyText": "changed info to debug", "author": "ArjenKorevaar", "createdAt": "2020-03-18T13:00:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQ5MDc5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQ5MTA4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r392491086", "bodyText": "Please try to follow the openHab coding guidlines. Info level logging should generally not be touched by bindings, instead you should use debug or trace. Please go through the other parts of your code and change the logging levels accordingly.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.info(\"Starting OpenTherm Gateway connector\");\n          \n          \n            \n                    logger.debug(\"Starting OpenTherm Gateway connector\");", "author": "cpmeister", "createdAt": "2020-03-13T21:30:11Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    private @Nullable OpenThermGatewayConfiguration config;\n+\n+    private @Nullable OpenThermGatewayConnector connector;\n+\n+    private boolean connecting = false;\n+\n+    private boolean explicitDisconnect = false;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Initializing\");\n+\n+        config = getConfigAs(OpenThermGatewayConfiguration.class);\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Received channel: {}, command: {}\", channelUID, command);\n+\n+        if (!(command instanceof RefreshType)) {\n+            String channel = channelUID.getId();\n+            String code = getGatewayCodeFromChannel(channel);\n+\n+            GatewayCommand gatewayCommand;\n+\n+            if (command instanceof QuantityType<?>) {\n+                double value  = ((QuantityType<?>) command).toUnit(SIUnits.CELSIUS).doubleValue();\n+                gatewayCommand = GatewayCommand.parse(code, Double.toString(value));\n+            } else {\n+                gatewayCommand = GatewayCommand.parse(code, command.toFullString());\n+            }\n+\n+            if (gatewayCommand != null && checkConnection()) {\n+                connector.sendCommand(gatewayCommand);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void connecting() {\n+        connecting = true;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+    }\n+\n+    @Override\n+    public void connected() {\n+        connecting = false;\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void disconnected() {\n+        connecting = false;\n+        \n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Disconnected\");\n+\n+        // retry connection if disconnect is not explicitly requested\n+        if (!explicitDisconnect && config.connectionRetryInterval > 0) {\n+            scheduler.schedule(() -> {\n+                if (connector != null && !connecting && !connector.isConnected()) {\n+                    connect();\n+                }\n+            }, config.connectionRetryInterval, TimeUnit.SECONDS);\n+        }    \n+    }\n+\n+    @Override\n+    public void receiveMessage(Message message) {\n+        if (DataItemGroup.dataItemGroups.containsKey(message.getID())) {\n+            DataItem[] dataItems = DataItemGroup.dataItemGroups.get(message.getID());\n+\n+            for (DataItem dataItem: dataItems) {\n+                String channelId = dataItem.getSubject();\n+\n+                if (!OpenThermGatewayBindingConstants.SUPPORTED_CHANNEL_IDS.contains(channelId)) {\n+                    continue;\n+                }\n+\n+                State state = null;\n+\n+                switch (dataItem.getDataType()) {\n+                    case FLAGS:\n+                        state = OnOffType.from(message.getBit(dataItem.getByteType(), dataItem.getBitPos()));\n+                        break;\n+                    case UINT8:\n+                    case UINT16:\n+                        state = new DecimalType(message.getUInt(dataItem.getByteType()));\n+                        break;\n+                    case INT8:\n+                    case INT16:\n+                        state = new DecimalType(message.getInt(dataItem.getByteType()));\n+                        break;\n+                    case FLOAT:\n+                        float value = message.getFloat();\n+                        @Nullable Unit<?> unit = dataItem.getUnit();\n+                        state = (unit == null) ? new DecimalType(value) : new QuantityType<>(value, unit);\n+                        break;\n+                    case DOWTOD:\n+                        break;\n+                }\n+          \n+                if (state != null) {\n+                    logger.debug(\"Received update for channel '{}': {}\", channelId, state.toFullString());\n+                    updateState(channelId, state);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleRemoval() {\n+        logger.debug(\"Removing OpenTherm Gateway handler\");\n+        disconnect();\n+        super.handleRemoval();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        disconnect();\n+        super.dispose();\n+    }\n+\n+    private boolean checkConnection() {\n+        if (connector != null && connector.isConnected()) {\n+            return true;\n+        }\n+\n+        return connect();\n+    }\n+\n+    private synchronized boolean connect() {\n+        disconnect();\n+\n+        logger.info(\"Starting OpenTherm Gateway connector\");", "originalCommit": "d33464a4cd21f907708e5483463e3497bf2f3c3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDMyNzA1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r394327053", "bodyText": "Changed all logger.info to logger.debug", "author": "ArjenKorevaar", "createdAt": "2020-03-18T13:00:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQ5MTA4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQ5NTk4OA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r392495988", "bodyText": "why is this synchronized?", "author": "cpmeister", "createdAt": "2020-03-13T21:38:41Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewaySocketConnector.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.AbstractMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewaySocketConnector} is responsible for handling the socket connection\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ * @author Arjan Mels - Improved robustness by re-sending commands, handling all message types (not only Boiler)\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewaySocketConnector implements OpenThermGatewayConnector {\n+    private static final int COMMAND_RESPONSE_TIME_MILLISECONDS = 100;\n+    private static final int COMMAND_TIMEOUT_MILLISECONDS = 5000;\n+\n+    private OpenThermGatewayCallback callback;\n+    private String ipaddress;\n+    private int port;\n+\n+    private @Nullable PrintWriter writer;\n+\n+    private volatile boolean stopping;\n+    private boolean connected;\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewaySocketConnector.class);\n+\n+    private Map<String, Entry<Long, GatewayCommand>> pendingCommands = new HashMap<>();\n+\n+    public OpenThermGatewaySocketConnector(OpenThermGatewayCallback callback, String ipaddress, int port) {\n+        this.callback = callback;\n+        this.ipaddress = ipaddress;\n+        this.port = port;\n+    }\n+\n+    @Override\n+    public void run() {\n+        stopping = false;\n+        connected = false;\n+        \n+        logger.info(\"Connecting OpenThermGatewaySocketConnector to {}:{}\", this.ipaddress, this.port);\n+\n+        callback.connecting();\n+        \n+        try (Socket socket = new Socket()) {            \n+            socket.connect(new InetSocketAddress(this.ipaddress, this.port), COMMAND_TIMEOUT_MILLISECONDS);\n+            socket.setSoTimeout(COMMAND_TIMEOUT_MILLISECONDS);\n+    \n+            connected = true;\n+    \n+            callback.connected();\n+    \n+            logger.info(\"OpenThermGatewaySocketConnector connected\");\n+    \n+            try (BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                PrintWriter wrt = new PrintWriter(socket.getOutputStream(), true)) {\n+                    // Make writer accessible on class level\n+                    writer = wrt;\n+    \n+                    sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintReport, \"A\"));\n+                    // Set the OTGW to report every message it receives and transmits\n+                    sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintSummary, \"0\"));\n+        \n+                    while (!stopping && !Thread.currentThread().isInterrupted()) {\n+                        @Nullable String message = reader.readLine();\n+        \n+                        if (message != null) {\n+                            handleMessage(message);\n+                        } else {\n+                            logger.info(\"Connection closed by OpenTherm Gateway\");\n+                            break;\n+                        }\n+                    }\n+        \n+                    logger.info(\"Stopping OpenThermGatewaySocketConnector\");\n+            }\n+            finally {\n+                connected = false;\n+    \n+                logger.info(\"OpenThermGatewaySocketConnector disconnected\");\n+                callback.disconnected();\n+            }\n+        } catch (IOException ex) {\n+            logger.warn(\"Unable to connect to the OpenTherm Gateway.\" , ex);\n+        }        \n+    }\n+\n+    @Override\n+    public synchronized void stop() {", "originalCommit": "d33464a4cd21f907708e5483463e3497bf2f3c3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDMzMDIwNA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r394330204", "bodyText": "Since i'm using callback methods and afaik dont have resources shared between threads.. it seems that synchronized isnt neccesary at all. Removed all occurences.", "author": "ArjenKorevaar", "createdAt": "2020-03-18T13:05:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQ5NTk4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQ5Nzg4MA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r392497880", "bodyText": "How would callback be null here? Isn't callback a non-null field?", "author": "cpmeister", "createdAt": "2020-03-13T21:42:06Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewaySocketConnector.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.AbstractMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewaySocketConnector} is responsible for handling the socket connection\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ * @author Arjan Mels - Improved robustness by re-sending commands, handling all message types (not only Boiler)\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewaySocketConnector implements OpenThermGatewayConnector {\n+    private static final int COMMAND_RESPONSE_TIME_MILLISECONDS = 100;\n+    private static final int COMMAND_TIMEOUT_MILLISECONDS = 5000;\n+\n+    private OpenThermGatewayCallback callback;\n+    private String ipaddress;\n+    private int port;\n+\n+    private @Nullable PrintWriter writer;\n+\n+    private volatile boolean stopping;\n+    private boolean connected;\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewaySocketConnector.class);\n+\n+    private Map<String, Entry<Long, GatewayCommand>> pendingCommands = new HashMap<>();\n+\n+    public OpenThermGatewaySocketConnector(OpenThermGatewayCallback callback, String ipaddress, int port) {\n+        this.callback = callback;\n+        this.ipaddress = ipaddress;\n+        this.port = port;\n+    }\n+\n+    @Override\n+    public void run() {\n+        stopping = false;\n+        connected = false;\n+        \n+        logger.info(\"Connecting OpenThermGatewaySocketConnector to {}:{}\", this.ipaddress, this.port);\n+\n+        callback.connecting();\n+        \n+        try (Socket socket = new Socket()) {            \n+            socket.connect(new InetSocketAddress(this.ipaddress, this.port), COMMAND_TIMEOUT_MILLISECONDS);\n+            socket.setSoTimeout(COMMAND_TIMEOUT_MILLISECONDS);\n+    \n+            connected = true;\n+    \n+            callback.connected();\n+    \n+            logger.info(\"OpenThermGatewaySocketConnector connected\");\n+    \n+            try (BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                PrintWriter wrt = new PrintWriter(socket.getOutputStream(), true)) {\n+                    // Make writer accessible on class level\n+                    writer = wrt;\n+    \n+                    sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintReport, \"A\"));\n+                    // Set the OTGW to report every message it receives and transmits\n+                    sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintSummary, \"0\"));\n+        \n+                    while (!stopping && !Thread.currentThread().isInterrupted()) {\n+                        @Nullable String message = reader.readLine();\n+        \n+                        if (message != null) {\n+                            handleMessage(message);\n+                        } else {\n+                            logger.info(\"Connection closed by OpenTherm Gateway\");\n+                            break;\n+                        }\n+                    }\n+        \n+                    logger.info(\"Stopping OpenThermGatewaySocketConnector\");\n+            }\n+            finally {\n+                connected = false;\n+    \n+                logger.info(\"OpenThermGatewaySocketConnector disconnected\");\n+                callback.disconnected();\n+            }\n+        } catch (IOException ex) {\n+            logger.warn(\"Unable to connect to the OpenTherm Gateway.\" , ex);\n+        }        \n+    }\n+\n+    @Override\n+    public synchronized void stop() {\n+        logger.info(\"Stopping OpenThermGatewaySocketConnector\");\n+        stopping = true;\n+    }\n+\n+    @Override\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    @Override\n+    public void sendCommand(GatewayCommand command) {\n+        String msg = command.toFullString();\n+\n+        pendingCommands.put(command.getCode(), new AbstractMap.SimpleImmutableEntry<>(System.currentTimeMillis(), command));\n+\n+        if (connected) {\n+            logger.debug(\"Sending message: {}\", msg);\n+            writer.printf(\"%s\\r\\n\", msg);\n+            writer.flush();\n+        } else {\n+            logger.debug(\"Unable to send message: {}. OpenThermGatewaySocketConnector is not connected.\", msg);\n+        }\n+    }\n+\n+    private void handleMessage(String message) {\n+        if (message.length() > 2 && message.charAt(2) == ':') {\n+            String code = message.substring(0, 2);\n+            String value = message.substring(3);\n+\n+            logger.debug(\"Received command confirmation: {}: {}\", code, value);\n+            pendingCommands.remove(code);\n+            return;\n+        }\n+\n+        for (Entry<Long, GatewayCommand> timeAndCommand : pendingCommands.values()) {\n+            if (System.currentTimeMillis() > timeAndCommand.getKey() + COMMAND_RESPONSE_TIME_MILLISECONDS) {\n+                logger.debug(\"Resending command: {}\", timeAndCommand.getValue().toFullString());\n+                sendCommand(timeAndCommand.getValue());\n+            } else if (System.currentTimeMillis() > timeAndCommand.getKey() + COMMAND_TIMEOUT_MILLISECONDS) {\n+                pendingCommands.remove(timeAndCommand.getValue().getCode());\n+            }\n+        }\n+\n+        Message msg = Message.parse(message);\n+\n+        if (msg == null) {\n+            logger.trace(\"Received message: {}, (unknown)\", message);\n+            return;\n+        } else {\n+            logger.trace(\"Received message: {}, {} {} {}\", message, msg.getID(), msg.getCode(), msg.getMessageType().toString());\n+        }\n+\n+        if (DataItemGroup.dataItemGroups.containsKey(msg.getID())) {\n+            DataItem[] dataItems = DataItemGroup.dataItemGroups.get(msg.getID());\n+\n+            for (DataItem dataItem : dataItems) {\n+                State state = null;\n+\n+                switch (dataItem.getDataType()) {\n+                    case FLAGS:\n+                        state = OnOffType.from(msg.getBit(dataItem.getByteType(), dataItem.getBitPos()));\n+                        break;\n+                    case UINT8:\n+                    case UINT16:\n+                        state = new DecimalType(msg.getUInt(dataItem.getByteType()));\n+                        break;\n+                    case INT8:\n+                    case INT16:\n+                        state = new DecimalType(msg.getInt(dataItem.getByteType()));\n+                        break;\n+                    case FLOAT:\n+                        state = new DecimalType(msg.getFloat());\n+                        break;\n+                    case DOWTOD:\n+                        break;\n+                }\n+\n+                logger.trace(\"  Data: {} {} {} {}\", dataItem.getID(), dataItem.getSubject(),\n+                    dataItem.getDataType().toString(), state == null ? \"\" : state.toString());\n+            }\n+        }\n+\n+        if (msg.getMessageType() == MessageType.READACK || msg.getMessageType() == MessageType.WRITEDATA) {\n+            receiveMessage(msg);\n+        }\n+    }\n+\n+    private void receiveMessage(Message message) {\n+        if (message != null && callback != null) {", "originalCommit": "d33464a4cd21f907708e5483463e3497bf2f3c3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDMyNjM0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r394326341", "bodyText": "Leftover from before adding @NonNullByDefault. Removed.", "author": "ArjenKorevaar", "createdAt": "2020-03-18T12:58:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQ5Nzg4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE3NTczOA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r415175738", "bodyText": "Please move final fields above the non-final ones.", "author": "cpmeister", "createdAt": "2020-04-26T00:25:30Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewaySocketConnector.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.AbstractMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewaySocketConnector} is responsible for handling the socket connection\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ * @author Arjan Mels - Improved robustness by re-sending commands, handling all message types (not only Boiler)\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewaySocketConnector implements OpenThermGatewayConnector {\n+    private static final int COMMAND_RESPONSE_TIME_MILLISECONDS = 100;\n+    private static final int COMMAND_TIMEOUT_MILLISECONDS = 5000;\n+\n+    private OpenThermGatewayCallback callback;\n+    private String ipaddress;\n+    private int port;\n+\n+    private @Nullable PrintWriter writer;\n+\n+    private volatile boolean stopping;\n+    private boolean connected;\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewaySocketConnector.class);", "originalCommit": "b0e3aae47d72c05e1555409743adb681ba3cc485", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTIzNTU4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r415235587", "bodyText": "Adjusted", "author": "ArjenKorevaar", "createdAt": "2020-04-26T06:57:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE3NTczOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE3NTkwNg==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r415175906", "bodyText": "Can you make these final?", "author": "cpmeister", "createdAt": "2020-04-26T00:26:17Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewaySocketConnector.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.AbstractMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewaySocketConnector} is responsible for handling the socket connection\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ * @author Arjan Mels - Improved robustness by re-sending commands, handling all message types (not only Boiler)\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewaySocketConnector implements OpenThermGatewayConnector {\n+    private static final int COMMAND_RESPONSE_TIME_MILLISECONDS = 100;\n+    private static final int COMMAND_TIMEOUT_MILLISECONDS = 5000;\n+\n+    private OpenThermGatewayCallback callback;\n+    private String ipaddress;\n+    private int port;", "originalCommit": "b0e3aae47d72c05e1555409743adb681ba3cc485", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTIzNTU2NA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r415235564", "bodyText": "Adjusted", "author": "ArjenKorevaar", "createdAt": "2020-04-26T06:57:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE3NTkwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYyOTk0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r419629941", "bodyText": "Is \"\" a valid gateway code? If not maybe you should allow this method to return null instead.", "author": "cpmeister", "createdAt": "2020-05-04T18:12:42Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    private @Nullable OpenThermGatewayConfiguration config;\n+\n+    private @Nullable OpenThermGatewayConnector connector;\n+\n+    private boolean connecting = false;\n+\n+    private boolean explicitDisconnect = false;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Initializing\");\n+\n+        config = getConfigAs(OpenThermGatewayConfiguration.class);\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Received channel: {}, command: {}\", channelUID, command);\n+\n+        if (!(command instanceof RefreshType)) {\n+            String channel = channelUID.getId();\n+            String code = getGatewayCodeFromChannel(channel);\n+\n+            GatewayCommand gatewayCommand = null;\n+\n+            if (command instanceof QuantityType<?>) {\n+                QuantityType<?> quantityType = ((QuantityType<?>) command).toUnit(SIUnits.CELSIUS);\n+\n+                if (quantityType != null) {\n+                    double value = quantityType.doubleValue();\n+                    gatewayCommand = GatewayCommand.parse(code, Double.toString(value));\n+                }\n+            }\n+\n+            if (gatewayCommand == null) {\n+                gatewayCommand = GatewayCommand.parse(code, command.toFullString());\n+            }\n+\n+            if (checkConnection()) {\n+                @Nullable\n+                OpenThermGatewayConnector conn = connector;\n+\n+                if (conn != null) {\n+                    conn.sendCommand(gatewayCommand);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void connecting() {\n+        connecting = true;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+    }\n+\n+    @Override\n+    public void connected() {\n+        connecting = false;\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void disconnected() {\n+        @Nullable\n+        OpenThermGatewayConnector conn = connector;\n+\n+        @Nullable\n+        OpenThermGatewayConfiguration conf = config;\n+\n+        connecting = false;\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Disconnected\");\n+\n+        // retry connection if disconnect is not explicitly requested\n+        if (conf != null && !explicitDisconnect && conf.connectionRetryInterval > 0) {\n+            scheduler.schedule(() -> {\n+                if (conn != null && !connecting && !conn.isConnected()) {\n+                    connect();\n+                }\n+            }, conf.connectionRetryInterval, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void receiveMessage(Message message) {\n+        if (DataItemGroup.dataItemGroups.containsKey(message.getID())) {\n+            DataItem[] dataItems = DataItemGroup.dataItemGroups.get(message.getID());\n+\n+            for (DataItem dataItem : dataItems) {\n+                String channelId = dataItem.getSubject();\n+\n+                if (!OpenThermGatewayBindingConstants.SUPPORTED_CHANNEL_IDS.contains(channelId)) {\n+                    continue;\n+                }\n+\n+                State state = null;\n+\n+                switch (dataItem.getDataType()) {\n+                    case FLAGS:\n+                        state = OnOffType.from(message.getBit(dataItem.getByteType(), dataItem.getBitPos()));\n+                        break;\n+                    case UINT8:\n+                    case UINT16:\n+                        state = new DecimalType(message.getUInt(dataItem.getByteType()));\n+                        break;\n+                    case INT8:\n+                    case INT16:\n+                        state = new DecimalType(message.getInt(dataItem.getByteType()));\n+                        break;\n+                    case FLOAT:\n+                        float value = message.getFloat();\n+                        @Nullable\n+                        Unit<?> unit = dataItem.getUnit();\n+                        state = (unit == null) ? new DecimalType(value) : new QuantityType<>(value, unit);\n+                        break;\n+                    case DOWTOD:\n+                        break;\n+                }\n+\n+                if (state != null) {\n+                    logger.debug(\"Received update for channel '{}': {}\", channelId, state.toFullString());\n+                    updateState(channelId, state);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleRemoval() {\n+        logger.debug(\"Removing OpenTherm Gateway handler\");\n+        disconnect();\n+        super.handleRemoval();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        disconnect();\n+        super.dispose();\n+    }\n+\n+    private boolean checkConnection() {\n+        @Nullable\n+        OpenThermGatewayConnector conn = connector;\n+\n+        if (conn != null && conn.isConnected()) {\n+            return true;\n+        }\n+\n+        return connect();\n+    }\n+\n+    private boolean connect() {\n+        @Nullable\n+        OpenThermGatewayConfiguration conf = config;\n+\n+        disconnect();\n+\n+        if (conf != null) {\n+            logger.debug(\"Starting OpenTherm Gateway connector\");\n+\n+            explicitDisconnect = false;\n+\n+            connector = new OpenThermGatewaySocketConnector(this, conf.ipaddress, conf.port);\n+\n+            Thread thread = new Thread(connector, \"OpenTherm Gateway Binding - socket listener thread\");\n+            thread.setDaemon(true);\n+            thread.start();\n+\n+            logger.debug(\"OpenTherm Gateway connector started\");\n+\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    private void disconnect() {\n+        @Nullable\n+        OpenThermGatewayConnector conn = connector;\n+\n+        if (conn != null) {\n+            if (conn.isConnected()) {\n+                logger.debug(\"Stopping OpenTherm Gateway connector\");\n+\n+                explicitDisconnect = true;\n+                conn.stop();\n+            }\n+\n+            connector = null;\n+        }\n+    }\n+\n+    private String getGatewayCodeFromChannel(String channel) throws IllegalArgumentException {\n+        switch (channel) {\n+            case OpenThermGatewayBindingConstants.CHANNEL_OVERRIDE_SETPOINT_TEMPORARY:\n+                return GatewayCommandCode.TemperatureTemporary;\n+            case OpenThermGatewayBindingConstants.CHANNEL_OVERRIDE_SETPOINT_CONSTANT:\n+                return GatewayCommandCode.TemperatureConstant;\n+            case OpenThermGatewayBindingConstants.CHANNEL_OUTSIDE_TEMPERATURE:\n+                return GatewayCommandCode.TemperatureOutside;\n+            case OpenThermGatewayBindingConstants.CHANNEL_OVERRIDE_DHW_SETPOINT:\n+                return GatewayCommandCode.SetpointWater;\n+            case OpenThermGatewayBindingConstants.CHANNEL_SEND_COMMAND:\n+                return \"\";", "originalCommit": "72c5235f250106cb1957e92bf42fe74ec10b2e06", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDgwMTM3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r420801372", "bodyText": "Whether it's 'valid' is up to the code I guess.. it is possible to send raw commands instead of predefined commands. So either you send a predefined command based on a channel, in that case the channel is mapped to a particular command. Or you can send a raw command through the SendCommand channel, in which case you have to provide the command yourself.\nThe easiest way was to simple return \"\" so that it get's processed or concatenated as an empty string, followed by whatever the user had entered. The combination should produce a valid command, but that's up to the user. I changed it to null though, and added a check on the calling code.", "author": "ArjenKorevaar", "createdAt": "2020-05-06T13:44:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYyOTk0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYzMDgwMw==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r419630803", "bodyText": "Please put static fields at the top of the class", "author": "cpmeister", "createdAt": "2020-05-04T18:14:01Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/GatewayCommand.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.util.HashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class GatewayCommand {\n+    private String code;\n+    private String validationSet;\n+    private String message;\n+\n+    public String getCode() {\n+        return code;\n+    }\n+\n+    public String getMessage() {\n+        return this.message;\n+    }\n+\n+    public String getValidationSet() {\n+        return validationSet;\n+    }\n+\n+    public String toFullString() {\n+        return this.code + \"=\" + this.message;\n+    }\n+\n+    private GatewayCommand(String code, String message, String validationSet) throws IllegalArgumentException {\n+        this.code = code;\n+        this.message = message;\n+        this.validationSet = validationSet;\n+\n+        if (!validate()) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"Invalid value '%s' for code '%s'\", this.message, this.code));\n+        }\n+    }\n+\n+    private boolean validate() {\n+        if (this.validationSet.isEmpty()) {\n+            return true;\n+        }\n+\n+        String[] validations = this.validationSet.split(\",\");\n+\n+        for (String validation : validations) {\n+            if (this.message.equals(validation)) {\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    public static GatewayCommand parse(String code, String message) throws IllegalArgumentException {\n+        if (code.isEmpty() && message.length() > 2 && message.charAt(2) == '=') {\n+            return parse(message.substring(0, 2), message.substring(3));\n+        }\n+\n+        if (code.length() == 2) {\n+            String codeUpperCase = code.toUpperCase();\n+\n+            if (supportedCommands.containsKey(codeUpperCase)) {\n+                String validateSet = supportedCommands.get(codeUpperCase);\n+\n+                if (validateSet == null) {\n+                    validateSet = \"\";\n+                }\n+\n+                return new GatewayCommand(codeUpperCase, message, validateSet);\n+            } else {\n+                throw new IllegalArgumentException(String.format(\"Unsupported gateway code '%s'\", code.toUpperCase()));\n+            }\n+        }\n+\n+        throw new IllegalArgumentException(\n+                String.format(\"Unable to parse gateway command with code '%s' and message '%s'\", code, message));\n+    }\n+\n+    private static final HashMap<String, @Nullable String> supportedCommands = getSupportedCommands();", "originalCommit": "72c5235f250106cb1957e92bf42fe74ec10b2e06", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDc5NzUxMw==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r420797513", "bodyText": "Moved to the top", "author": "ArjenKorevaar", "createdAt": "2020-05-06T13:39:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYzMDgwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYzOTE3NA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r419639174", "bodyText": "This code will never get called because you compare the time against the smallest value first.", "author": "cpmeister", "createdAt": "2020-05-04T18:28:04Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewaySocketConnector.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.AbstractMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewaySocketConnector} is responsible for handling the socket connection\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ * @author Arjan Mels - Improved robustness by re-sending commands, handling all message types (not only Boiler)\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewaySocketConnector implements OpenThermGatewayConnector {\n+    private static final int COMMAND_RESPONSE_TIME_MILLISECONDS = 100;\n+    private static final int COMMAND_TIMEOUT_MILLISECONDS = 5000;\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewaySocketConnector.class);\n+\n+    private final OpenThermGatewayCallback callback;\n+    private final String ipaddress;\n+    private final int port;\n+\n+    private @Nullable PrintWriter writer;\n+\n+    private volatile boolean stopping;\n+    private boolean connected;\n+\n+    private Map<String, Entry<Long, GatewayCommand>> pendingCommands = new HashMap<>();\n+\n+    public OpenThermGatewaySocketConnector(OpenThermGatewayCallback callback, String ipaddress, int port) {\n+        this.callback = callback;\n+        this.ipaddress = ipaddress;\n+        this.port = port;\n+    }\n+\n+    @Override\n+    public void run() {\n+        stopping = false;\n+        connected = false;\n+\n+        logger.debug(\"Connecting OpenThermGatewaySocketConnector to {}:{}\", this.ipaddress, this.port);\n+\n+        callback.connecting();\n+\n+        try (Socket socket = new Socket()) {\n+            socket.connect(new InetSocketAddress(this.ipaddress, this.port), COMMAND_TIMEOUT_MILLISECONDS);\n+            socket.setSoTimeout(COMMAND_TIMEOUT_MILLISECONDS);\n+\n+            connected = true;\n+\n+            callback.connected();\n+\n+            logger.debug(\"OpenThermGatewaySocketConnector connected\");\n+\n+            try (BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                    PrintWriter wrt = new PrintWriter(socket.getOutputStream(), true)) {\n+                // Make writer accessible on class level\n+                writer = wrt;\n+\n+                sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintReport, \"A\"));\n+                // Set the OTGW to report every message it receives and transmits\n+                sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintSummary, \"0\"));\n+\n+                while (!stopping && !Thread.currentThread().isInterrupted()) {\n+                    @Nullable\n+                    String message = reader.readLine();\n+\n+                    if (message != null) {\n+                        handleMessage(message);\n+                    } else {\n+                        logger.debug(\"Connection closed by OpenTherm Gateway\");\n+                        break;\n+                    }\n+                }\n+\n+                logger.debug(\"Stopping OpenThermGatewaySocketConnector\");\n+            } finally {\n+                connected = false;\n+\n+                logger.debug(\"OpenThermGatewaySocketConnector disconnected\");\n+                callback.disconnected();\n+            }\n+        } catch (IOException ex) {\n+            logger.warn(\"Unable to connect to the OpenTherm Gateway.\", ex);\n+        }\n+    }\n+\n+    @Override\n+    public void stop() {\n+        logger.debug(\"Stopping OpenThermGatewaySocketConnector\");\n+        stopping = true;\n+    }\n+\n+    @Override\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    @Override\n+    public void sendCommand(GatewayCommand command) {\n+        @Nullable\n+        PrintWriter wrtr = writer;\n+\n+        String msg = command.toFullString();\n+\n+        pendingCommands.put(command.getCode(),\n+                new AbstractMap.SimpleImmutableEntry<>(System.currentTimeMillis(), command));\n+\n+        if (connected) {\n+            logger.debug(\"Sending message: {}\", msg);\n+            if (wrtr != null) {\n+                wrtr.printf(\"%s\\r\\n\", msg);\n+                wrtr.flush();\n+            }\n+        } else {\n+            logger.debug(\"Unable to send message: {}. OpenThermGatewaySocketConnector is not connected.\", msg);\n+        }\n+    }\n+\n+    private void handleMessage(String message) {\n+        if (message.length() > 2 && message.charAt(2) == ':') {\n+            String code = message.substring(0, 2);\n+            String value = message.substring(3);\n+\n+            logger.debug(\"Received command confirmation: {}: {}\", code, value);\n+            pendingCommands.remove(code);\n+            return;\n+        }\n+\n+        for (Entry<Long, GatewayCommand> timeAndCommand : pendingCommands.values()) {\n+            if (System.currentTimeMillis() > timeAndCommand.getKey() + COMMAND_RESPONSE_TIME_MILLISECONDS) {\n+                logger.debug(\"Resending command: {}\", timeAndCommand.getValue().toFullString());\n+                sendCommand(timeAndCommand.getValue());\n+            } else if (System.currentTimeMillis() > timeAndCommand.getKey() + COMMAND_TIMEOUT_MILLISECONDS) {\n+                pendingCommands.remove(timeAndCommand.getValue().getCode());\n+            }", "originalCommit": "72c5235f250106cb1957e92bf42fe74ec10b2e06", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDc5ODE1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r420798151", "bodyText": "Changed the check", "author": "ArjenKorevaar", "createdAt": "2020-05-06T13:39:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYzOTE3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0MjA1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r419642059", "bodyText": "This field will be used by multiple threads, so make it thread-safe.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Map<String, Entry<Long, GatewayCommand>> pendingCommands = new HashMap<>();\n          \n          \n            \n                private Map<String, Entry<Long, GatewayCommand>> pendingCommands = new ConcurrentHashMap<>();", "author": "cpmeister", "createdAt": "2020-05-04T18:32:45Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewaySocketConnector.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.AbstractMap;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewaySocketConnector} is responsible for handling the socket connection\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ * @author Arjan Mels - Improved robustness by re-sending commands, handling all message types (not only Boiler)\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewaySocketConnector implements OpenThermGatewayConnector {\n+    private static final int COMMAND_RESPONSE_TIME_MILLISECONDS = 100;\n+    private static final int COMMAND_TIMEOUT_MILLISECONDS = 5000;\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewaySocketConnector.class);\n+\n+    private final OpenThermGatewayCallback callback;\n+    private final String ipaddress;\n+    private final int port;\n+\n+    private @Nullable PrintWriter writer;\n+\n+    private volatile boolean stopping;\n+    private boolean connected;\n+\n+    private Map<String, Entry<Long, GatewayCommand>> pendingCommands = new HashMap<>();", "originalCommit": "72c5235f250106cb1957e92bf42fe74ec10b2e06", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDc5ODM3OA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r420798378", "bodyText": "Changed to ConcurrentHashMap", "author": "ArjenKorevaar", "createdAt": "2020-05-06T13:40:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY0MjA1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE2NTQ3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r421165477", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                msg.getMessageType().toString());\n          \n          \n            \n                                msg.getMessageType());", "author": "cpmeister", "createdAt": "2020-05-07T00:17:38Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewaySocketConnector.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.AbstractMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewaySocketConnector} is responsible for handling the socket connection\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ * @author Arjan Mels - Improved robustness by re-sending commands, handling all message types (not only Boiler)\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewaySocketConnector implements OpenThermGatewayConnector {\n+    private static final int COMMAND_RESPONSE_TIME_MILLISECONDS = 100;\n+    private static final int COMMAND_TIMEOUT_MILLISECONDS = 5000;\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewaySocketConnector.class);\n+\n+    private final OpenThermGatewayCallback callback;\n+    private final String ipaddress;\n+    private final int port;\n+\n+    private @Nullable PrintWriter writer;\n+\n+    private volatile boolean stopping;\n+    private boolean connected;\n+\n+    private Map<String, Entry<Long, GatewayCommand>> pendingCommands = new ConcurrentHashMap<>();\n+\n+    public OpenThermGatewaySocketConnector(OpenThermGatewayCallback callback, String ipaddress, int port) {\n+        this.callback = callback;\n+        this.ipaddress = ipaddress;\n+        this.port = port;\n+    }\n+\n+    @Override\n+    public void run() {\n+        stopping = false;\n+        connected = false;\n+\n+        logger.debug(\"Connecting OpenThermGatewaySocketConnector to {}:{}\", this.ipaddress, this.port);\n+\n+        callback.connecting();\n+\n+        try (Socket socket = new Socket()) {\n+            socket.connect(new InetSocketAddress(this.ipaddress, this.port), COMMAND_TIMEOUT_MILLISECONDS);\n+            socket.setSoTimeout(COMMAND_TIMEOUT_MILLISECONDS);\n+\n+            connected = true;\n+\n+            callback.connected();\n+\n+            logger.debug(\"OpenThermGatewaySocketConnector connected\");\n+\n+            try (BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                    PrintWriter wrt = new PrintWriter(socket.getOutputStream(), true)) {\n+                // Make writer accessible on class level\n+                writer = wrt;\n+\n+                sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintReport, \"A\"));\n+                // Set the OTGW to report every message it receives and transmits\n+                sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintSummary, \"0\"));\n+\n+                while (!stopping && !Thread.currentThread().isInterrupted()) {\n+                    @Nullable\n+                    String message = reader.readLine();\n+\n+                    if (message != null) {\n+                        handleMessage(message);\n+                    } else {\n+                        logger.debug(\"Connection closed by OpenTherm Gateway\");\n+                        break;\n+                    }\n+                }\n+\n+                logger.debug(\"Stopping OpenThermGatewaySocketConnector\");\n+            } finally {\n+                connected = false;\n+\n+                logger.debug(\"OpenThermGatewaySocketConnector disconnected\");\n+                callback.disconnected();\n+            }\n+        } catch (IOException ex) {\n+            logger.warn(\"Unable to connect to the OpenTherm Gateway.\", ex);\n+        }\n+    }\n+\n+    @Override\n+    public void stop() {\n+        logger.debug(\"Stopping OpenThermGatewaySocketConnector\");\n+        stopping = true;\n+    }\n+\n+    @Override\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    @Override\n+    public void sendCommand(GatewayCommand command) {\n+        @Nullable\n+        PrintWriter wrtr = writer;\n+\n+        String msg = command.toFullString();\n+\n+        pendingCommands.put(command.getCode(),\n+                new AbstractMap.SimpleImmutableEntry<>(System.currentTimeMillis(), command));\n+\n+        if (connected) {\n+            logger.debug(\"Sending message: {}\", msg);\n+            if (wrtr != null) {\n+                wrtr.printf(\"%s\\r\\n\", msg);\n+                wrtr.flush();\n+            }\n+        } else {\n+            logger.debug(\"Unable to send message: {}. OpenThermGatewaySocketConnector is not connected.\", msg);\n+        }\n+    }\n+\n+    private void handleMessage(String message) {\n+        if (message.length() > 2 && message.charAt(2) == ':') {\n+            String code = message.substring(0, 2);\n+            String value = message.substring(3);\n+\n+            logger.debug(\"Received command confirmation: {}: {}\", code, value);\n+            pendingCommands.remove(code);\n+            return;\n+        }\n+\n+        long currentTime = System.currentTimeMillis();\n+\n+        for (Entry<Long, GatewayCommand> timeAndCommand : pendingCommands.values()) {\n+            long responseTime = timeAndCommand.getKey() + COMMAND_RESPONSE_TIME_MILLISECONDS;\n+            long timeoutTime = timeAndCommand.getKey() + COMMAND_TIMEOUT_MILLISECONDS;\n+\n+            if (currentTime > responseTime && currentTime <= timeoutTime) {\n+                logger.debug(\"Resending command: {}\", timeAndCommand.getValue().toFullString());\n+                sendCommand(timeAndCommand.getValue());\n+            } else if (currentTime > timeoutTime) {\n+                pendingCommands.remove(timeAndCommand.getValue().getCode());\n+            }\n+        }\n+\n+        Message msg = Message.parse(message);\n+\n+        if (msg == null) {\n+            logger.trace(\"Received message: {}, (unknown)\", message);\n+            return;\n+        } else {\n+            logger.trace(\"Received message: {}, {} {} {}\", message, msg.getID(), msg.getCode(),\n+                    msg.getMessageType().toString());", "originalCommit": "a33f865e7aad7625f337fbb8f9f78f057f4d8180", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMxOTg0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r421319843", "bodyText": "Modified", "author": "ArjenKorevaar", "createdAt": "2020-05-07T08:12:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE2NTQ3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE2NTYyNg==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r421165626", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    dataItem.getDataType().toString(), state == null ? \"\" : state.toString());\n          \n          \n            \n                                    dataItem.getDataType(), state == null ? \"\" : state);", "author": "cpmeister", "createdAt": "2020-05-07T00:18:05Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewaySocketConnector.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.AbstractMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewaySocketConnector} is responsible for handling the socket connection\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ * @author Arjan Mels - Improved robustness by re-sending commands, handling all message types (not only Boiler)\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewaySocketConnector implements OpenThermGatewayConnector {\n+    private static final int COMMAND_RESPONSE_TIME_MILLISECONDS = 100;\n+    private static final int COMMAND_TIMEOUT_MILLISECONDS = 5000;\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewaySocketConnector.class);\n+\n+    private final OpenThermGatewayCallback callback;\n+    private final String ipaddress;\n+    private final int port;\n+\n+    private @Nullable PrintWriter writer;\n+\n+    private volatile boolean stopping;\n+    private boolean connected;\n+\n+    private Map<String, Entry<Long, GatewayCommand>> pendingCommands = new ConcurrentHashMap<>();\n+\n+    public OpenThermGatewaySocketConnector(OpenThermGatewayCallback callback, String ipaddress, int port) {\n+        this.callback = callback;\n+        this.ipaddress = ipaddress;\n+        this.port = port;\n+    }\n+\n+    @Override\n+    public void run() {\n+        stopping = false;\n+        connected = false;\n+\n+        logger.debug(\"Connecting OpenThermGatewaySocketConnector to {}:{}\", this.ipaddress, this.port);\n+\n+        callback.connecting();\n+\n+        try (Socket socket = new Socket()) {\n+            socket.connect(new InetSocketAddress(this.ipaddress, this.port), COMMAND_TIMEOUT_MILLISECONDS);\n+            socket.setSoTimeout(COMMAND_TIMEOUT_MILLISECONDS);\n+\n+            connected = true;\n+\n+            callback.connected();\n+\n+            logger.debug(\"OpenThermGatewaySocketConnector connected\");\n+\n+            try (BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                    PrintWriter wrt = new PrintWriter(socket.getOutputStream(), true)) {\n+                // Make writer accessible on class level\n+                writer = wrt;\n+\n+                sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintReport, \"A\"));\n+                // Set the OTGW to report every message it receives and transmits\n+                sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintSummary, \"0\"));\n+\n+                while (!stopping && !Thread.currentThread().isInterrupted()) {\n+                    @Nullable\n+                    String message = reader.readLine();\n+\n+                    if (message != null) {\n+                        handleMessage(message);\n+                    } else {\n+                        logger.debug(\"Connection closed by OpenTherm Gateway\");\n+                        break;\n+                    }\n+                }\n+\n+                logger.debug(\"Stopping OpenThermGatewaySocketConnector\");\n+            } finally {\n+                connected = false;\n+\n+                logger.debug(\"OpenThermGatewaySocketConnector disconnected\");\n+                callback.disconnected();\n+            }\n+        } catch (IOException ex) {\n+            logger.warn(\"Unable to connect to the OpenTherm Gateway.\", ex);\n+        }\n+    }\n+\n+    @Override\n+    public void stop() {\n+        logger.debug(\"Stopping OpenThermGatewaySocketConnector\");\n+        stopping = true;\n+    }\n+\n+    @Override\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    @Override\n+    public void sendCommand(GatewayCommand command) {\n+        @Nullable\n+        PrintWriter wrtr = writer;\n+\n+        String msg = command.toFullString();\n+\n+        pendingCommands.put(command.getCode(),\n+                new AbstractMap.SimpleImmutableEntry<>(System.currentTimeMillis(), command));\n+\n+        if (connected) {\n+            logger.debug(\"Sending message: {}\", msg);\n+            if (wrtr != null) {\n+                wrtr.printf(\"%s\\r\\n\", msg);\n+                wrtr.flush();\n+            }\n+        } else {\n+            logger.debug(\"Unable to send message: {}. OpenThermGatewaySocketConnector is not connected.\", msg);\n+        }\n+    }\n+\n+    private void handleMessage(String message) {\n+        if (message.length() > 2 && message.charAt(2) == ':') {\n+            String code = message.substring(0, 2);\n+            String value = message.substring(3);\n+\n+            logger.debug(\"Received command confirmation: {}: {}\", code, value);\n+            pendingCommands.remove(code);\n+            return;\n+        }\n+\n+        long currentTime = System.currentTimeMillis();\n+\n+        for (Entry<Long, GatewayCommand> timeAndCommand : pendingCommands.values()) {\n+            long responseTime = timeAndCommand.getKey() + COMMAND_RESPONSE_TIME_MILLISECONDS;\n+            long timeoutTime = timeAndCommand.getKey() + COMMAND_TIMEOUT_MILLISECONDS;\n+\n+            if (currentTime > responseTime && currentTime <= timeoutTime) {\n+                logger.debug(\"Resending command: {}\", timeAndCommand.getValue().toFullString());\n+                sendCommand(timeAndCommand.getValue());\n+            } else if (currentTime > timeoutTime) {\n+                pendingCommands.remove(timeAndCommand.getValue().getCode());\n+            }\n+        }\n+\n+        Message msg = Message.parse(message);\n+\n+        if (msg == null) {\n+            logger.trace(\"Received message: {}, (unknown)\", message);\n+            return;\n+        } else {\n+            logger.trace(\"Received message: {}, {} {} {}\", message, msg.getID(), msg.getCode(),\n+                    msg.getMessageType().toString());\n+        }\n+\n+        if (DataItemGroup.dataItemGroups.containsKey(msg.getID())) {\n+            DataItem[] dataItems = DataItemGroup.dataItemGroups.get(msg.getID());\n+\n+            for (DataItem dataItem : dataItems) {\n+                State state = null;\n+\n+                switch (dataItem.getDataType()) {\n+                    case FLAGS:\n+                        state = OnOffType.from(msg.getBit(dataItem.getByteType(), dataItem.getBitPos()));\n+                        break;\n+                    case UINT8:\n+                    case UINT16:\n+                        state = new DecimalType(msg.getUInt(dataItem.getByteType()));\n+                        break;\n+                    case INT8:\n+                    case INT16:\n+                        state = new DecimalType(msg.getInt(dataItem.getByteType()));\n+                        break;\n+                    case FLOAT:\n+                        state = new DecimalType(msg.getFloat());\n+                        break;\n+                    case DOWTOD:\n+                        break;\n+                }\n+\n+                logger.trace(\"  Data: {} {} {} {}\", dataItem.getID(), dataItem.getSubject(),\n+                        dataItem.getDataType().toString(), state == null ? \"\" : state.toString());", "originalCommit": "a33f865e7aad7625f337fbb8f9f78f057f4d8180", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMxOTkyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r421319921", "bodyText": "Modified", "author": "ArjenKorevaar", "createdAt": "2020-05-07T08:12:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE2NTYyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIyNzgyMg==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r421227822", "bodyText": "The writer is synchronized under the hood so you can't really split this up into two method calls. That said, you don't need to use printf for something this simple.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            wrtr.printf(\"%s\\r\\n\", msg);\n          \n          \n            \n                            wrtr.print(msg+\"\\r\\n\");", "author": "cpmeister", "createdAt": "2020-05-07T04:10:37Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewaySocketConnector.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.AbstractMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewaySocketConnector} is responsible for handling the socket connection\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ * @author Arjan Mels - Improved robustness by re-sending commands, handling all message types (not only Boiler)\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewaySocketConnector implements OpenThermGatewayConnector {\n+    private static final int COMMAND_RESPONSE_TIME_MILLISECONDS = 100;\n+    private static final int COMMAND_TIMEOUT_MILLISECONDS = 5000;\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewaySocketConnector.class);\n+\n+    private final OpenThermGatewayCallback callback;\n+    private final String ipaddress;\n+    private final int port;\n+\n+    private @Nullable PrintWriter writer;\n+\n+    private volatile boolean stopping;\n+    private boolean connected;\n+\n+    private Map<String, Entry<Long, GatewayCommand>> pendingCommands = new ConcurrentHashMap<>();\n+\n+    public OpenThermGatewaySocketConnector(OpenThermGatewayCallback callback, String ipaddress, int port) {\n+        this.callback = callback;\n+        this.ipaddress = ipaddress;\n+        this.port = port;\n+    }\n+\n+    @Override\n+    public void run() {\n+        stopping = false;\n+        connected = false;\n+\n+        logger.debug(\"Connecting OpenThermGatewaySocketConnector to {}:{}\", this.ipaddress, this.port);\n+\n+        callback.connecting();\n+\n+        try (Socket socket = new Socket()) {\n+            socket.connect(new InetSocketAddress(this.ipaddress, this.port), COMMAND_TIMEOUT_MILLISECONDS);\n+            socket.setSoTimeout(COMMAND_TIMEOUT_MILLISECONDS);\n+\n+            connected = true;\n+\n+            callback.connected();\n+\n+            logger.debug(\"OpenThermGatewaySocketConnector connected\");\n+\n+            try (BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                    PrintWriter wrt = new PrintWriter(socket.getOutputStream(), true)) {\n+                // Make writer accessible on class level\n+                writer = wrt;\n+\n+                sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintReport, \"A\"));\n+                // Set the OTGW to report every message it receives and transmits\n+                sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintSummary, \"0\"));\n+\n+                while (!stopping && !Thread.currentThread().isInterrupted()) {\n+                    @Nullable\n+                    String message = reader.readLine();\n+\n+                    if (message != null) {\n+                        handleMessage(message);\n+                    } else {\n+                        logger.debug(\"Connection closed by OpenTherm Gateway\");\n+                        break;\n+                    }\n+                }\n+\n+                logger.debug(\"Stopping OpenThermGatewaySocketConnector\");\n+            } finally {\n+                connected = false;\n+\n+                logger.debug(\"OpenThermGatewaySocketConnector disconnected\");\n+                callback.disconnected();\n+            }\n+        } catch (IOException ex) {\n+            logger.warn(\"Unable to connect to the OpenTherm Gateway.\", ex);\n+        }\n+    }\n+\n+    @Override\n+    public void stop() {\n+        logger.debug(\"Stopping OpenThermGatewaySocketConnector\");\n+        stopping = true;\n+    }\n+\n+    @Override\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    @Override\n+    public void sendCommand(GatewayCommand command) {\n+        @Nullable\n+        PrintWriter wrtr = writer;\n+\n+        String msg = command.toFullString();\n+\n+        pendingCommands.put(command.getCode(),\n+                new AbstractMap.SimpleImmutableEntry<>(System.currentTimeMillis(), command));\n+\n+        if (connected) {\n+            logger.debug(\"Sending message: {}\", msg);\n+            if (wrtr != null) {\n+                wrtr.printf(\"%s\\r\\n\", msg);", "originalCommit": "a33f865e7aad7625f337fbb8f9f78f057f4d8180", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyMDU2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r421320566", "bodyText": "Modified.. though I am not sure I understand your comment about splitting things up into two method calls.", "author": "ArjenKorevaar", "createdAt": "2020-05-07T08:13:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIyNzgyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY2Mzk3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r421663976", "bodyText": "Sorry about that, I was half mutter to myself while writing the suggested change.\nMy original suggestion that I changed before posting would be something like this:\nwrtr.print(msg);\nwrtr.print(\"\\r\\n\");\n\nBut I quickly realized that such a suggestion wouldn't be best since you could run into issues if that code was called by multiple threads at once. The PrintWriter will synchronize all method calls but that won't help you if you spread out your message across multiple method calls.\nThat is why I instead suggested doing the string concatenation before calling print.\nIt would have been better if I hadn't mentioned multiple method calls since it wasn't relevant to the suggestion so sorry for confusing you.", "author": "cpmeister", "createdAt": "2020-05-07T17:14:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIyNzgyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1ODc4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r422458781", "bodyText": "I personally would write this as kind of a pre-condition check so that the rest of the method does not need that much indentation:\nif (command instanceof RefreshType) {\n   return;\n}\n\n... rest of the code", "author": "martinvw", "createdAt": "2020-05-09T06:23:55Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    private @Nullable OpenThermGatewayConfiguration config;\n+\n+    private @Nullable OpenThermGatewayConnector connector;\n+\n+    private boolean connecting = false;\n+\n+    private boolean explicitDisconnect = false;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Initializing\");\n+\n+        config = getConfigAs(OpenThermGatewayConfiguration.class);\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Received channel: {}, command: {}\", channelUID, command);\n+\n+        if (!(command instanceof RefreshType)) {", "originalCommit": "fc1160aa6ed7da4ae9905179b3570f0e8ecc8103", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTAwMg==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r422459002", "bodyText": "Does connecting mean that is not connected? Or should it just be UKNOWN? The status which we talk about is the status of actual thing not of the connection.\nSo if you connected you know its ONLINE, if you fail to connect you can assume its OFFLINE or that there is some configuration error. But if you haven't tried you can nog know whether the thing is OFFLINE.", "author": "martinvw", "createdAt": "2020-05-09T06:26:46Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    private @Nullable OpenThermGatewayConfiguration config;\n+\n+    private @Nullable OpenThermGatewayConnector connector;\n+\n+    private boolean connecting = false;\n+\n+    private boolean explicitDisconnect = false;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Initializing\");\n+\n+        config = getConfigAs(OpenThermGatewayConfiguration.class);\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Received channel: {}, command: {}\", channelUID, command);\n+\n+        if (!(command instanceof RefreshType)) {\n+            String channel = channelUID.getId();\n+            String code = getGatewayCodeFromChannel(channel);\n+\n+            GatewayCommand gatewayCommand = null;\n+\n+            if (command instanceof QuantityType<?>) {\n+                QuantityType<?> quantityType = ((QuantityType<?>) command).toUnit(SIUnits.CELSIUS);\n+\n+                if (quantityType != null) {\n+                    double value = quantityType.doubleValue();\n+                    gatewayCommand = GatewayCommand.parse(code, Double.toString(value));\n+                }\n+            }\n+\n+            if (gatewayCommand == null) {\n+                gatewayCommand = GatewayCommand.parse(code, command.toFullString());\n+            }\n+\n+            if (checkConnection()) {\n+                @Nullable\n+                OpenThermGatewayConnector conn = connector;\n+\n+                if (conn != null) {\n+                    conn.sendCommand(gatewayCommand);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void connecting() {\n+        connecting = true;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");", "originalCommit": "fc1160aa6ed7da4ae9905179b3570f0e8ecc8103", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI0NDg2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r426244863", "bodyText": "For your reference see also: https://www.openhab.org/docs/concepts/things.html#thing-status", "author": "martinvw", "createdAt": "2020-05-17T10:35:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTAwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI1MDYzNw==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r426250637", "bodyText": "Changed", "author": "ArjenKorevaar", "createdAt": "2020-05-17T11:34:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTAwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTA1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r422459057", "bodyText": "See below", "author": "martinvw", "createdAt": "2020-05-09T06:27:41Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    private @Nullable OpenThermGatewayConfiguration config;\n+\n+    private @Nullable OpenThermGatewayConnector connector;\n+\n+    private boolean connecting = false;\n+\n+    private boolean explicitDisconnect = false;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Initializing\");", "originalCommit": "fc1160aa6ed7da4ae9905179b3570f0e8ecc8103", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTM1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r422459359", "bodyText": "Is the normal String enough? If so please just pass the state. Otherways you will also call the toFullString when debug-levels do not apply.", "author": "martinvw", "createdAt": "2020-05-09T06:31:26Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    private @Nullable OpenThermGatewayConfiguration config;\n+\n+    private @Nullable OpenThermGatewayConnector connector;\n+\n+    private boolean connecting = false;\n+\n+    private boolean explicitDisconnect = false;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Initializing\");\n+\n+        config = getConfigAs(OpenThermGatewayConfiguration.class);\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Received channel: {}, command: {}\", channelUID, command);\n+\n+        if (!(command instanceof RefreshType)) {\n+            String channel = channelUID.getId();\n+            String code = getGatewayCodeFromChannel(channel);\n+\n+            GatewayCommand gatewayCommand = null;\n+\n+            if (command instanceof QuantityType<?>) {\n+                QuantityType<?> quantityType = ((QuantityType<?>) command).toUnit(SIUnits.CELSIUS);\n+\n+                if (quantityType != null) {\n+                    double value = quantityType.doubleValue();\n+                    gatewayCommand = GatewayCommand.parse(code, Double.toString(value));\n+                }\n+            }\n+\n+            if (gatewayCommand == null) {\n+                gatewayCommand = GatewayCommand.parse(code, command.toFullString());\n+            }\n+\n+            if (checkConnection()) {\n+                @Nullable\n+                OpenThermGatewayConnector conn = connector;\n+\n+                if (conn != null) {\n+                    conn.sendCommand(gatewayCommand);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void connecting() {\n+        connecting = true;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+    }\n+\n+    @Override\n+    public void connected() {\n+        connecting = false;\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void disconnected() {\n+        @Nullable\n+        OpenThermGatewayConnector conn = connector;\n+\n+        @Nullable\n+        OpenThermGatewayConfiguration conf = config;\n+\n+        connecting = false;\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Disconnected\");\n+\n+        // retry connection if disconnect is not explicitly requested\n+        if (conf != null && !explicitDisconnect && conf.connectionRetryInterval > 0) {\n+            scheduler.schedule(() -> {\n+                if (conn != null && !connecting && !conn.isConnected()) {\n+                    connect();\n+                }\n+            }, conf.connectionRetryInterval, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void receiveMessage(Message message) {\n+        if (DataItemGroup.dataItemGroups.containsKey(message.getID())) {\n+            DataItem[] dataItems = DataItemGroup.dataItemGroups.get(message.getID());\n+\n+            for (DataItem dataItem : dataItems) {\n+                String channelId = dataItem.getSubject();\n+\n+                if (!OpenThermGatewayBindingConstants.SUPPORTED_CHANNEL_IDS.contains(channelId)) {\n+                    continue;\n+                }\n+\n+                State state = null;\n+\n+                switch (dataItem.getDataType()) {\n+                    case FLAGS:\n+                        state = OnOffType.from(message.getBit(dataItem.getByteType(), dataItem.getBitPos()));\n+                        break;\n+                    case UINT8:\n+                    case UINT16:\n+                        state = new DecimalType(message.getUInt(dataItem.getByteType()));\n+                        break;\n+                    case INT8:\n+                    case INT16:\n+                        state = new DecimalType(message.getInt(dataItem.getByteType()));\n+                        break;\n+                    case FLOAT:\n+                        float value = message.getFloat();\n+                        @Nullable\n+                        Unit<?> unit = dataItem.getUnit();\n+                        state = (unit == null) ? new DecimalType(value) : new QuantityType<>(value, unit);\n+                        break;\n+                    case DOWTOD:\n+                        break;\n+                }\n+\n+                if (state != null) {\n+                    logger.debug(\"Received update for channel '{}': {}\", channelId, state.toFullString());", "originalCommit": "fc1160aa6ed7da4ae9905179b3570f0e8ecc8103", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI1MDk3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r426250975", "bodyText": "Removed toFullString", "author": "ArjenKorevaar", "createdAt": "2020-05-17T11:38:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTM1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTUxNw==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r422459517", "bodyText": "It seems that a lot of these fields can be marked final I would always prefer to make class level fields explicitly final when possible.", "author": "martinvw", "createdAt": "2020-05-09T06:33:42Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/DataItem.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DataItem {\n+    private int id;", "originalCommit": "fc1160aa6ed7da4ae9905179b3570f0e8ecc8103", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI0MTA5OA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r426241098", "bodyText": "Prefer, or needed ?", "author": "ArjenKorevaar", "createdAt": "2020-05-17T09:55:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTUxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI0MzMyNw==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r426243327", "bodyText": "It will improve the code and ease future maintenance, it will thus benefit all of us. You will not find any maintainer who will object making fields final.", "author": "martinvw", "createdAt": "2020-05-17T10:18:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTUxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI0NzAxMg==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r426247012", "bodyText": "That's not really the question though.. it's about what is needed to get this code up to a level of standard set to approve the PR. I don't mind spending some of my valuable time to share this binding with others.. but with every reviewer, new considerations are brought in which are fine by itself but make this PR process a never ending story.\nAgain, if changes are required, based on set standards, I will be happy to put more time in.", "author": "ArjenKorevaar", "createdAt": "2020-05-17T10:57:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTUxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTU2MA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r422459560", "bodyText": "Please make sure that you document for all classes their purpose, see also https://www.openhab.org/docs/developer/guidelines.html#c-documentation", "author": "martinvw", "createdAt": "2020-05-09T06:34:25Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/DataItem.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution", "originalCommit": "fc1160aa6ed7da4ae9905179b3570f0e8ecc8103", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI0NTI2OA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r426245268", "bodyText": "Added documentation where needed", "author": "ArjenKorevaar", "createdAt": "2020-05-17T10:39:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTU2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTY3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r422459677", "bodyText": "Please use the interface instead of the actual implementation for declarations and return values.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final HashMap<Integer, DataItem[]> dataItemGroups = createDataItemGroups();\n          \n          \n            \n                public static final Map<Integer, DataItem[]> dataItemGroups = createDataItemGroups();", "author": "martinvw", "createdAt": "2020-05-09T06:35:46Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/DataItemGroup.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.util.HashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DataItemGroup {\n+\n+    public static final HashMap<Integer, DataItem[]> dataItemGroups = createDataItemGroups();", "originalCommit": "fc1160aa6ed7da4ae9905179b3570f0e8ecc8103", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI0Mjc4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r426242789", "bodyText": "Adjusted", "author": "ArjenKorevaar", "createdAt": "2020-05-17T10:12:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTY3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTcyMg==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r422459722", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static HashMap<Integer, DataItem[]> createDataItemGroups() {\n          \n          \n            \n                private static Map<Integer, DataItem[]> createDataItemGroups() {", "author": "martinvw", "createdAt": "2020-05-09T06:36:21Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/DataItemGroup.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.util.HashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DataItemGroup {\n+\n+    public static final HashMap<Integer, DataItem[]> dataItemGroups = createDataItemGroups();\n+\n+    private static HashMap<Integer, DataItem[]> createDataItemGroups() {", "originalCommit": "fc1160aa6ed7da4ae9905179b3570f0e8ecc8103", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI0Mjc5NA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r426242794", "bodyText": "Adjusted", "author": "ArjenKorevaar", "createdAt": "2020-05-17T10:12:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTcyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTczOA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r422459738", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    HashMap<Integer, DataItem[]> g = new HashMap<Integer, DataItem[]>();\n          \n          \n            \n                    Map<Integer, DataItem[]> g = new HashMap<>();", "author": "martinvw", "createdAt": "2020-05-09T06:36:35Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/DataItemGroup.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.util.HashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class DataItemGroup {\n+\n+    public static final HashMap<Integer, DataItem[]> dataItemGroups = createDataItemGroups();\n+\n+    private static HashMap<Integer, DataItem[]> createDataItemGroups() {\n+        HashMap<Integer, DataItem[]> g = new HashMap<Integer, DataItem[]>();", "originalCommit": "fc1160aa6ed7da4ae9905179b3570f0e8ecc8103", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTc3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r422459777", "bodyText": "Please use the diamond operator, ie replace the second occurrence of the same generic by <> please also check for other occurrences.", "author": "martinvw", "createdAt": "2020-05-09T06:37:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTczOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI0MjgxMw==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r426242813", "bodyText": "Adjusted", "author": "ArjenKorevaar", "createdAt": "2020-05-17T10:12:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTczOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTgxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r422459815", "bodyText": "Please check for other occurrences", "author": "martinvw", "createdAt": "2020-05-09T06:37:42Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/GatewayCommand.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.util.HashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class GatewayCommand {\n+    private static final HashMap<String, @Nullable String> supportedCommands = getSupportedCommands();", "originalCommit": "fc1160aa6ed7da4ae9905179b3570f0e8ecc8103", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI0MjgzMg==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r426242832", "bodyText": "Adjusted", "author": "ArjenKorevaar", "createdAt": "2020-05-17T10:12:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTgxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTg3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r422459875", "bodyText": "Consider marking these fields final", "author": "martinvw", "createdAt": "2020-05-09T06:38:28Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/GatewayCommand.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.util.HashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class GatewayCommand {\n+    private static final HashMap<String, @Nullable String> supportedCommands = getSupportedCommands();\n+\n+    private String code;", "originalCommit": "fc1160aa6ed7da4ae9905179b3570f0e8ecc8103", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTkwMg==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r422459902", "bodyText": "Please check others", "author": "martinvw", "createdAt": "2020-05-09T06:38:53Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/Message.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Message {\n+    /*\n+     * The code field is not part of OpenTherm specification, but added by OpenTherm Gateway.\n+     * It can be any of the following:\n+     *\n+     * T: Message received from the thermostat\n+     * B: Message received from the boiler\n+     * R: Request sent to the boiler\n+     * A: Response returned to the thermostat\n+     * E: Parity or stop bit error\n+     */\n+\n+    private String code;", "originalCommit": "fc1160aa6ed7da4ae9905179b3570f0e8ecc8103", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2MDAyMA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r422460020", "bodyText": "If this part of the code is used often it might make sense to compile a pattern once (and store as a static field) and re-use this every time, see also https://stackoverflow.com/a/2469275/3656774", "author": "martinvw", "createdAt": "2020-05-09T06:40:45Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/Message.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Message {\n+    /*\n+     * The code field is not part of OpenTherm specification, but added by OpenTherm Gateway.\n+     * It can be any of the following:\n+     *\n+     * T: Message received from the thermostat\n+     * B: Message received from the boiler\n+     * R: Request sent to the boiler\n+     * A: Response returned to the thermostat\n+     * E: Parity or stop bit error\n+     */\n+\n+    private String code;\n+    private MessageType messageType;\n+    private int id;\n+    private String data;\n+\n+    public String getCode() {\n+        return this.code;\n+    }\n+\n+    public MessageType getMessageType() {\n+        return messageType;\n+    }\n+\n+    public int getID() {\n+        return id;\n+    }\n+\n+    public @Nullable String getData(ByteType byteType) {\n+        if (this.data.length() == 4) {\n+            switch (byteType) {\n+                case HIGHBYTE:\n+                    return this.data.substring(0, 2);\n+                case LOWBYTE:\n+                    return this.data.substring(2, 4);\n+                case BOTH:\n+                    return this.data;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    public boolean getBit(ByteType byteType, int pos) {\n+        @Nullable String data = getData(byteType);\n+\n+        if (data != null) {\n+            // First parse the hex value to an integer\n+            int parsed = Integer.parseInt(data, 16);\n+\n+            // Then right shift it pos positions so that the required bit is at the front\n+            // and then apply a bitmask of 00000001 (1)\n+            return ((parsed >> pos) & 1) == 1;\n+        }\n+\n+        return false;\n+    }\n+\n+    public int getUInt(ByteType byteType) {\n+        @Nullable String data = getData(byteType);\n+\n+        if (data != null) {\n+            return Integer.parseInt(data, 16);\n+        }\n+\n+        return 0;\n+    }\n+\n+    public int getInt(ByteType byteType) {\n+        @Nullable String data = getData(byteType);\n+\n+        if (data != null) {\n+            return parseSignedInteger(data);\n+        }\n+\n+        return 0;\n+    }\n+\n+    public float getFloat() {\n+        // f8.8, two's complement\n+        @Nullable String data = getData(ByteType.BOTH);\n+\n+        if (data != null) {\n+            long value = Long.parseLong(data, 16);\n+\n+            // left padded with zeros\n+            String binary = String.format(\"%16s\", Long.toBinaryString(value)).replace(' ', '0');\n+\n+            if (binary.charAt(0) == '1') {\n+                // negative value\n+\n+                String inverted = invertBinary(binary);\n+\n+                value = Long.parseLong(inverted, 2);\n+                value = value + 1;\n+                value = value * -1;\n+            }\n+\n+            // divide by 2^8 = 256\n+            return (float) value / 256;\n+        }\n+\n+        return 0;\n+    }\n+\n+    public boolean overrides(@Nullable Message other) {\n+        // If the message is a Request sent to the boiler or an Answer returned to the\n+        // thermostat, and it's ID is equal to the previous message, then this is an\n+        // override sent by the OpenTherm Gateway\n+        return other != null && this.getID() == other.getID() && (\"R\".equals(this.getCode()) || \"A\".equals(this.getCode()));\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"%s - %s - %s\", this.code, this.id, this.data);\n+    }\n+\n+    public Message(String code, MessageType messageType, int id, String data) {\n+        this.code = code;\n+        this.messageType = messageType;\n+        this.id = id;\n+        this.data = data;\n+    }\n+\n+    public static @Nullable Message parse(String message) {\n+        if (message.matches(\"[TBRA]{1}[A-F0-9]{8}\")) {", "originalCommit": "fc1160aa6ed7da4ae9905179b3570f0e8ecc8103", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI0Mzc3NA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r426243774", "bodyText": "Adjusted", "author": "ArjenKorevaar", "createdAt": "2020-05-17T10:22:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2MDAyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2MDIzMw==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r422460233", "bodyText": "You could consider the following to make the second boundary more explicit.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final int COMMAND_TIMEOUT_MILLISECONDS = 5000;\n          \n          \n            \n                private static final int COMMAND_TIMEOUT_MILLISECONDS = 5_000;\n          \n      \n    \n    \n  \n\nOr even more explicit, however for such a small value both are optional.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final int COMMAND_TIMEOUT_MILLISECONDS = 5000;\n          \n          \n            \n                private static final int COMMAND_TIMEOUT_MILLISECONDS = TimeUnit.SECONDS.toMillis(5);", "author": "martinvw", "createdAt": "2020-05-09T06:43:49Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewaySocketConnector.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.AbstractMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewaySocketConnector} is responsible for handling the socket connection\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ * @author Arjan Mels - Improved robustness by re-sending commands, handling all message types (not only Boiler)\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewaySocketConnector implements OpenThermGatewayConnector {\n+    private static final int COMMAND_RESPONSE_TIME_MILLISECONDS = 100;\n+    private static final int COMMAND_TIMEOUT_MILLISECONDS = 5000;", "originalCommit": "fc1160aa6ed7da4ae9905179b3570f0e8ecc8103", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2MDM4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r422460386", "bodyText": "You don't have to call toString it will be called automatically, but only when the logging-level actually applies.", "author": "martinvw", "createdAt": "2020-05-09T06:46:00Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewaySocketConnector.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.AbstractMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewaySocketConnector} is responsible for handling the socket connection\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ * @author Arjan Mels - Improved robustness by re-sending commands, handling all message types (not only Boiler)\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewaySocketConnector implements OpenThermGatewayConnector {\n+    private static final int COMMAND_RESPONSE_TIME_MILLISECONDS = 100;\n+    private static final int COMMAND_TIMEOUT_MILLISECONDS = 5000;\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewaySocketConnector.class);\n+\n+    private final OpenThermGatewayCallback callback;\n+    private final String ipaddress;\n+    private final int port;\n+\n+    private @Nullable PrintWriter writer;\n+\n+    private volatile boolean stopping;\n+    private boolean connected;\n+\n+    private Map<String, Entry<Long, GatewayCommand>> pendingCommands = new ConcurrentHashMap<>();\n+\n+    public OpenThermGatewaySocketConnector(OpenThermGatewayCallback callback, String ipaddress, int port) {\n+        this.callback = callback;\n+        this.ipaddress = ipaddress;\n+        this.port = port;\n+    }\n+\n+    @Override\n+    public void run() {\n+        stopping = false;\n+        connected = false;\n+\n+        logger.debug(\"Connecting OpenThermGatewaySocketConnector to {}:{}\", this.ipaddress, this.port);\n+\n+        callback.connecting();\n+\n+        try (Socket socket = new Socket()) {\n+            socket.connect(new InetSocketAddress(this.ipaddress, this.port), COMMAND_TIMEOUT_MILLISECONDS);\n+            socket.setSoTimeout(COMMAND_TIMEOUT_MILLISECONDS);\n+\n+            connected = true;\n+\n+            callback.connected();\n+\n+            logger.debug(\"OpenThermGatewaySocketConnector connected\");\n+\n+            try (BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                    PrintWriter wrt = new PrintWriter(socket.getOutputStream(), true)) {\n+                // Make writer accessible on class level\n+                writer = wrt;\n+\n+                sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintReport, \"A\"));\n+                // Set the OTGW to report every message it receives and transmits\n+                sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintSummary, \"0\"));\n+\n+                while (!stopping && !Thread.currentThread().isInterrupted()) {\n+                    @Nullable\n+                    String message = reader.readLine();\n+\n+                    if (message != null) {\n+                        handleMessage(message);\n+                    } else {\n+                        logger.debug(\"Connection closed by OpenTherm Gateway\");\n+                        break;\n+                    }\n+                }\n+\n+                logger.debug(\"Stopping OpenThermGatewaySocketConnector\");\n+            } finally {\n+                connected = false;\n+\n+                logger.debug(\"OpenThermGatewaySocketConnector disconnected\");\n+                callback.disconnected();\n+            }\n+        } catch (IOException ex) {\n+            logger.warn(\"Unable to connect to the OpenTherm Gateway.\", ex);\n+        }\n+    }\n+\n+    @Override\n+    public void stop() {\n+        logger.debug(\"Stopping OpenThermGatewaySocketConnector\");\n+        stopping = true;\n+    }\n+\n+    @Override\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    @Override\n+    public void sendCommand(GatewayCommand command) {\n+        @Nullable\n+        PrintWriter wrtr = writer;\n+\n+        String msg = command.toFullString();\n+\n+        pendingCommands.put(command.getCode(),\n+                new AbstractMap.SimpleImmutableEntry<>(System.currentTimeMillis(), command));\n+\n+        if (connected) {\n+            logger.debug(\"Sending message: {}\", msg);\n+            if (wrtr != null) {\n+                wrtr.print(msg + \"\\r\\n\");\n+                wrtr.flush();\n+            }\n+        } else {\n+            logger.debug(\"Unable to send message: {}. OpenThermGatewaySocketConnector is not connected.\", msg);\n+        }\n+    }\n+\n+    private void handleMessage(String message) {\n+        if (message.length() > 2 && message.charAt(2) == ':') {\n+            String code = message.substring(0, 2);\n+            String value = message.substring(3);\n+\n+            logger.debug(\"Received command confirmation: {}: {}\", code, value);\n+            pendingCommands.remove(code);\n+            return;\n+        }\n+\n+        long currentTime = System.currentTimeMillis();\n+\n+        for (Entry<Long, GatewayCommand> timeAndCommand : pendingCommands.values()) {\n+            long responseTime = timeAndCommand.getKey() + COMMAND_RESPONSE_TIME_MILLISECONDS;\n+            long timeoutTime = timeAndCommand.getKey() + COMMAND_TIMEOUT_MILLISECONDS;\n+\n+            if (currentTime > responseTime && currentTime <= timeoutTime) {\n+                logger.debug(\"Resending command: {}\", timeAndCommand.getValue().toFullString());", "originalCommit": "fc1160aa6ed7da4ae9905179b3570f0e8ecc8103", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI0MDkwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r426240905", "bodyText": "I am not calling toString(), but toFullString() which takes care of formatting.", "author": "ArjenKorevaar", "createdAt": "2020-05-17T09:53:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2MDM4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI0Mjg4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r426242885", "bodyText": "Yes, but now that method will also be called while debugging is not enabled, the question is whether that is desirable. Leaving it out might make the formatting a little bit more ugly but it will not execute formatting of a String intended for debugging while the system is not being executed with debugging enabled.", "author": "martinvw", "createdAt": "2020-05-17T10:13:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2MDM4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI1MDk2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r426250963", "bodyText": "removed toFullString()", "author": "ArjenKorevaar", "createdAt": "2020-05-17T11:38:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2MDM4Ng=="}], "type": "inlineReview"}, {"oid": "3f4ff85ec82f7cd045cbc7afa5ad7d6c7dbceeb0", "url": "https://github.com/openhab/openhab-addons/commit/3f4ff85ec82f7cd045cbc7afa5ad7d6c7dbceeb0", "message": "Initial contribution\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>", "committedDate": "2020-05-17T11:44:43Z", "type": "commit"}, {"oid": "cbfa86beb01e2ed4acd7969cdbf0ea9d7d82f8ef", "url": "https://github.com/openhab/openhab-addons/commit/cbfa86beb01e2ed4acd7969cdbf0ea9d7d82f8ef", "message": "Update parent module version to 2.5.2-SNAPSHOT\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>", "committedDate": "2020-05-17T11:44:43Z", "type": "commit"}, {"oid": "0b1ede2a6450cf02d5e64592a847ca3662c3b53c", "url": "https://github.com/openhab/openhab-addons/commit/0b1ede2a6450cf02d5e64592a847ca3662c3b53c", "message": "Added openthermgateway\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>", "committedDate": "2020-05-17T11:44:43Z", "type": "commit"}, {"oid": "1f7cbc8efe2cbb8c78fd80474ef38769f8032a3d", "url": "https://github.com/openhab/openhab-addons/commit/1f7cbc8efe2cbb8c78fd80474ef38769f8032a3d", "message": "Review (#1)\n\n* Each sentence on a new line\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>\n\n* Removed newline added by code formatter\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>\n\n* Every word of label Uppercase\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>\n\n* Changed enums to uppercase\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>\n\n* Changed milliseconds to seconds\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>\n\n* Removed try catch on updating channel\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>\n\n* Changed for to foreach\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>\n\n* Removed public from interface methods\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>\n\n* Removed immediate\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>\n\n* Added MILLISECONDS to time interval statics\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>\n\n* Changed for to foreach\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>\n\n* Typo\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>\n\n* Changed == to equals on string comparison\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>\n\n* Removed TODO\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>\n\n* Changed == \"\" to isEmpty()\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>\n\n* Changed for to foreach\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>\n\n* Removed TypeConverter\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>\n\n* Removed newline after @Nullable\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>", "committedDate": "2020-05-17T11:44:43Z", "type": "commit"}, {"oid": "21ba1500b317c036d39b160ba29578d05848a715", "url": "https://github.com/openhab/openhab-addons/commit/21ba1500b317c036d39b160ba29578d05848a715", "message": "Changed List to Set\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>", "committedDate": "2020-05-17T11:44:43Z", "type": "commit"}, {"oid": "2dd2016c926678c7d6b858a4347265a7583b36c4", "url": "https://github.com/openhab/openhab-addons/commit/2dd2016c926678c7d6b858a4347265a7583b36c4", "message": "Changed notation to start runnable\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>", "committedDate": "2020-05-17T11:44:43Z", "type": "commit"}, {"oid": "bc6b9387555d10202eb34ced0cd35e25564946f2", "url": "https://github.com/openhab/openhab-addons/commit/bc6b9387555d10202eb34ced0cd35e25564946f2", "message": "Removed (some occurences of) catching generic exceptions\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>", "committedDate": "2020-05-17T11:44:43Z", "type": "commit"}, {"oid": "99dff96d2e1cf66082bd2067b209abec3cd7af06", "url": "https://github.com/openhab/openhab-addons/commit/99dff96d2e1cf66082bd2067b209abec3cd7af06", "message": "Removed some unused import statements\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>", "committedDate": "2020-05-17T11:44:43Z", "type": "commit"}, {"oid": "6003d49c7acd8b937eb8b642417a2512738b94ff", "url": "https://github.com/openhab/openhab-addons/commit/6003d49c7acd8b937eb8b642417a2512738b94ff", "message": "Removed newline from feature.xml\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>", "committedDate": "2020-05-17T11:44:44Z", "type": "commit"}, {"oid": "e2e66bb9838bfc21ac4acf458c3b99391651ce63", "url": "https://github.com/openhab/openhab-addons/commit/e2e66bb9838bfc21ac4acf458c3b99391651ce63", "message": "Applies UoM to temperature and pressure channels\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>", "committedDate": "2020-05-17T11:44:44Z", "type": "commit"}, {"oid": "5d15bc601f60337e8f81e11c965632495ef8490c", "url": "https://github.com/openhab/openhab-addons/commit/5d15bc601f60337e8f81e11c965632495ef8490c", "message": "Changes to UoM\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>", "committedDate": "2020-05-17T11:44:44Z", "type": "commit"}, {"oid": "d2e1c958545549a866caa688f123d1fbe5e63a96", "url": "https://github.com/openhab/openhab-addons/commit/d2e1c958545549a866caa688f123d1fbe5e63a96", "message": "Removed logging callback and let connector log directly\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>", "committedDate": "2020-05-17T11:44:44Z", "type": "commit"}, {"oid": "a3a9b8067d301665a627dddb447ceb4e440a1c44", "url": "https://github.com/openhab/openhab-addons/commit/a3a9b8067d301665a627dddb447ceb4e440a1c44", "message": "Added tr-with-resources and removed throwing and catching generic exceptions\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>", "committedDate": "2020-05-17T11:44:44Z", "type": "commit"}, {"oid": "7826ccfc22ab7175f0d30ae1df356b3960cf6fd4", "url": "https://github.com/openhab/openhab-addons/commit/7826ccfc22ab7175f0d30ae1df356b3960cf6fd4", "message": "Removed placeholder from logging string\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>", "committedDate": "2020-05-17T11:44:44Z", "type": "commit"}, {"oid": "32ed6f49d518d700239461712b3b32ed1b81c86d", "url": "https://github.com/openhab/openhab-addons/commit/32ed6f49d518d700239461712b3b32ed1b81c86d", "message": "Removed unused attributes and setters from DataItem and DataItemGroup\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>", "committedDate": "2020-05-17T11:44:44Z", "type": "commit"}, {"oid": "4a2f1cf990563ba11bb610e479f9cf8569116e56", "url": "https://github.com/openhab/openhab-addons/commit/4a2f1cf990563ba11bb610e479f9cf8569116e56", "message": "Formatting\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>", "committedDate": "2020-05-17T11:44:44Z", "type": "commit"}, {"oid": "40bcd2646c5e8bbd8da7bdfe228eecdc50630c0e", "url": "https://github.com/openhab/openhab-addons/commit/40bcd2646c5e8bbd8da7bdfe228eecdc50630c0e", "message": "Changed some log levels\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>", "committedDate": "2020-05-17T11:44:44Z", "type": "commit"}, {"oid": "0d25f0d72e398529efc062d193eaedceec95ed96", "url": "https://github.com/openhab/openhab-addons/commit/0d25f0d72e398529efc062d193eaedceec95ed96", "message": "Added explicit call to flush\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>", "committedDate": "2020-05-17T11:44:44Z", "type": "commit"}, {"oid": "535f5d1227450b96137c1ceed5d6bd4f373c7592", "url": "https://github.com/openhab/openhab-addons/commit/535f5d1227450b96137c1ceed5d6bd4f373c7592", "message": "Fixed some layout errors\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>", "committedDate": "2020-05-17T11:44:44Z", "type": "commit"}, {"oid": "f4d2bfd2fcb3b29dd05b246a2c84bbe1e9f216c8", "url": "https://github.com/openhab/openhab-addons/commit/f4d2bfd2fcb3b29dd05b246a2c84bbe1e9f216c8", "message": "Added description to ThingStatus offline\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>", "committedDate": "2020-05-17T11:44:44Z", "type": "commit"}, {"oid": "f27de9d0833f113c5bdae57c5e9e60d356c6120e", "url": "https://github.com/openhab/openhab-addons/commit/f27de9d0833f113c5bdae57c5e9e60d356c6120e", "message": "Moved pendingCommands field to top and made private\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>", "committedDate": "2020-05-17T11:44:44Z", "type": "commit"}, {"oid": "940c0985b939261f81c772f677ea829a4b41a83a", "url": "https://github.com/openhab/openhab-addons/commit/940c0985b939261f81c772f677ea829a4b41a83a", "message": "Updated pom to 2.5.3\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>", "committedDate": "2020-05-17T11:44:45Z", "type": "commit"}, {"oid": "7d314b59d0c6708fadfd0576aa20eca3cce2e105", "url": "https://github.com/openhab/openhab-addons/commit/7d314b59d0c6708fadfd0576aa20eca3cce2e105", "message": "Named socket listener thread and set to daemon mode\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>", "committedDate": "2020-05-17T11:44:45Z", "type": "commit"}, {"oid": "550abf0f6ac5feafd97aba9a916d036e4aa5ead5", "url": "https://github.com/openhab/openhab-addons/commit/550abf0f6ac5feafd97aba9a916d036e4aa5ead5", "message": "Changed info to debug logging, removed synchronized\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>", "committedDate": "2020-05-17T11:44:45Z", "type": "commit"}, {"oid": "244fdbfbfefc89cd95747c83c529acf7a1d216aa", "url": "https://github.com/openhab/openhab-addons/commit/244fdbfbfefc89cd95747c83c529acf7a1d216aa", "message": "Updated pom.xml to 2.5.5-SNAPSHOT\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>", "committedDate": "2020-05-17T11:44:45Z", "type": "commit"}, {"oid": "9303b87ad1b3fbf8d599a7133ade75cae35a04f0", "url": "https://github.com/openhab/openhab-addons/commit/9303b87ad1b3fbf8d599a7133ade75cae35a04f0", "message": "Made variables final and moved them above non-final\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>", "committedDate": "2020-05-17T11:44:45Z", "type": "commit"}, {"oid": "f7a9ef7fbfbb0b88ede6d3c8a464b084a66e65e6", "url": "https://github.com/openhab/openhab-addons/commit/f7a9ef7fbfbb0b88ede6d3c8a464b084a66e65e6", "message": "Fixed potential null warnings\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>", "committedDate": "2020-05-17T11:44:45Z", "type": "commit"}, {"oid": "37e483f0f41134d570904cf9b8da312f76faf2fb", "url": "https://github.com/openhab/openhab-addons/commit/37e483f0f41134d570904cf9b8da312f76faf2fb", "message": "Moved static field to top of the class\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>", "committedDate": "2020-05-17T11:44:45Z", "type": "commit"}, {"oid": "e84b7d1ec8a5b0a782b25f8c3101d85355823c3e", "url": "https://github.com/openhab/openhab-addons/commit/e84b7d1ec8a5b0a782b25f8c3101d85355823c3e", "message": "Return null instead of empty string\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>", "committedDate": "2020-05-17T11:44:45Z", "type": "commit"}, {"oid": "45441bad99587a2089460d5faca9a49686f5051c", "url": "https://github.com/openhab/openhab-addons/commit/45441bad99587a2089460d5faca9a49686f5051c", "message": "Changed check on resend and timeout commands\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>", "committedDate": "2020-05-17T11:44:46Z", "type": "commit"}, {"oid": "e493f47fd02a581b2acc5eb23bbb188eaecd196e", "url": "https://github.com/openhab/openhab-addons/commit/e493f47fd02a581b2acc5eb23bbb188eaecd196e", "message": "Made pendingCommands hashmap thread-safe\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>", "committedDate": "2020-05-17T11:44:46Z", "type": "commit"}, {"oid": "16a5c94678bf41760ea84ef9232f728c75fb2954", "url": "https://github.com/openhab/openhab-addons/commit/16a5c94678bf41760ea84ef9232f728c75fb2954", "message": "Removed explicit calls to toString()\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>", "committedDate": "2020-05-17T11:44:46Z", "type": "commit"}, {"oid": "d11097e996d6815e85de94ae28a50a7e61b53386", "url": "https://github.com/openhab/openhab-addons/commit/d11097e996d6815e85de94ae28a50a7e61b53386", "message": "Changed printf() to print()\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>", "committedDate": "2020-05-17T11:44:46Z", "type": "commit"}, {"oid": "aa2be59b68ac09304a41aa72882ca2ff15e28129", "url": "https://github.com/openhab/openhab-addons/commit/aa2be59b68ac09304a41aa72882ca2ff15e28129", "message": "Changed to use interface instead of implementation\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>", "committedDate": "2020-05-17T11:44:46Z", "type": "commit"}, {"oid": "76d785df55f12efb62d88d8c6971ab54bda4f57e", "url": "https://github.com/openhab/openhab-addons/commit/76d785df55f12efb62d88d8c6971ab54bda4f57e", "message": "Changed readme\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>", "committedDate": "2020-05-17T11:44:46Z", "type": "commit"}, {"oid": "36f8a910cccfa07c24bd2fe36fc529bde9432502", "url": "https://github.com/openhab/openhab-addons/commit/36f8a910cccfa07c24bd2fe36fc529bde9432502", "message": "Precompile matching pattern\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>", "committedDate": "2020-05-17T11:44:46Z", "type": "commit"}, {"oid": "f7f77d72c7cf2073b87d1122331c5e0ca97dad26", "url": "https://github.com/openhab/openhab-addons/commit/f7f77d72c7cf2073b87d1122331c5e0ca97dad26", "message": "Added JavaDoc\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>", "committedDate": "2020-05-17T11:44:46Z", "type": "commit"}, {"oid": "766a0e5159df21696dedf42c4c1f437fd19112e2", "url": "https://github.com/openhab/openhab-addons/commit/766a0e5159df21696dedf42c4c1f437fd19112e2", "message": "Changed OFFLINE to UNKNOWN status upon connecting\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>", "committedDate": "2020-05-17T11:44:46Z", "type": "commit"}, {"oid": "f2f002c5f4d5d6d717c8a9ba7ee71088663e4478", "url": "https://github.com/openhab/openhab-addons/commit/f2f002c5f4d5d6d717c8a9ba7ee71088663e4478", "message": "Removed toFullString() to prevent unnecessary calls depending on loglevel\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>", "committedDate": "2020-05-17T11:44:46Z", "type": "commit"}, {"oid": "b58f2ac460fdeade42b65b3858f15510c3bce7b1", "url": "https://github.com/openhab/openhab-addons/commit/b58f2ac460fdeade42b65b3858f15510c3bce7b1", "message": "Changed parent version to 2.5.6\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>", "committedDate": "2020-05-17T11:46:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI1MjEwOA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r426252108", "bodyText": "This status might not be correct, because it's about the binding status being disconnected instead of the thing being OFFLINE.\nAlso, it is indirectly called from the dispose which will also be called when updating configuration, so better leave this one out and replace it by some way to update status when IOException are caught.", "author": "martinvw", "createdAt": "2020-05-17T11:50:17Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    private @Nullable OpenThermGatewayConfiguration config;\n+\n+    private @Nullable OpenThermGatewayConnector connector;\n+\n+    private boolean connecting = false;\n+\n+    private boolean explicitDisconnect = false;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.NONE, \"Initializing\");\n+\n+        config = getConfigAs(OpenThermGatewayConfiguration.class);\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Received channel: {}, command: {}\", channelUID, command);\n+\n+        if (!(command instanceof RefreshType)) {\n+            String channel = channelUID.getId();\n+            String code = getGatewayCodeFromChannel(channel);\n+\n+            GatewayCommand gatewayCommand = null;\n+\n+            if (command instanceof QuantityType<?>) {\n+                QuantityType<?> quantityType = ((QuantityType<?>) command).toUnit(SIUnits.CELSIUS);\n+\n+                if (quantityType != null) {\n+                    double value = quantityType.doubleValue();\n+                    gatewayCommand = GatewayCommand.parse(code, Double.toString(value));\n+                }\n+            }\n+\n+            if (gatewayCommand == null) {\n+                gatewayCommand = GatewayCommand.parse(code, command.toFullString());\n+            }\n+\n+            if (checkConnection()) {\n+                @Nullable\n+                OpenThermGatewayConnector conn = connector;\n+\n+                if (conn != null) {\n+                    conn.sendCommand(gatewayCommand);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void connecting() {\n+        connecting = true;\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.NONE, \"Connecting\");\n+    }\n+\n+    @Override\n+    public void connected() {\n+        connecting = false;\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void disconnected() {\n+        @Nullable\n+        OpenThermGatewayConnector conn = connector;\n+\n+        @Nullable\n+        OpenThermGatewayConfiguration conf = config;\n+\n+        connecting = false;\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Disconnected\");", "originalCommit": "b58f2ac460fdeade42b65b3858f15510c3bce7b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3NDEzOA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r426274138", "bodyText": "Removed Thing status update, added it to the IOException catch.", "author": "ArjenKorevaar", "createdAt": "2020-05-17T15:31:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI1MjEwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI1MjQwMw==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r426252403", "bodyText": "This is location where can you be sure that the device is ONLINE, if you are unsure that the status is currently sufficiently synchronized this could be the location to mark the thing ONLINE.", "author": "martinvw", "createdAt": "2020-05-17T11:53:33Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/handler/OpenThermGatewayHandler.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.handler;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.openthermgateway.OpenThermGatewayBindingConstants;\n+import org.openhab.binding.openthermgateway.internal.DataItem;\n+import org.openhab.binding.openthermgateway.internal.DataItemGroup;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommand;\n+import org.openhab.binding.openthermgateway.internal.GatewayCommandCode;\n+import org.openhab.binding.openthermgateway.internal.Message;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayCallback;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConfiguration;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewayConnector;\n+import org.openhab.binding.openthermgateway.internal.OpenThermGatewaySocketConnector;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewayHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewayHandler extends BaseThingHandler implements OpenThermGatewayCallback {\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewayHandler.class);\n+\n+    private @Nullable OpenThermGatewayConfiguration config;\n+\n+    private @Nullable OpenThermGatewayConnector connector;\n+\n+    private boolean connecting = false;\n+\n+    private boolean explicitDisconnect = false;\n+\n+    public OpenThermGatewayHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing OpenTherm Gateway handler for uid '{}'\", getThing().getUID());\n+\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.NONE, \"Initializing\");\n+\n+        config = getConfigAs(OpenThermGatewayConfiguration.class);\n+\n+        connect();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Received channel: {}, command: {}\", channelUID, command);\n+\n+        if (!(command instanceof RefreshType)) {\n+            String channel = channelUID.getId();\n+            String code = getGatewayCodeFromChannel(channel);\n+\n+            GatewayCommand gatewayCommand = null;\n+\n+            if (command instanceof QuantityType<?>) {\n+                QuantityType<?> quantityType = ((QuantityType<?>) command).toUnit(SIUnits.CELSIUS);\n+\n+                if (quantityType != null) {\n+                    double value = quantityType.doubleValue();\n+                    gatewayCommand = GatewayCommand.parse(code, Double.toString(value));\n+                }\n+            }\n+\n+            if (gatewayCommand == null) {\n+                gatewayCommand = GatewayCommand.parse(code, command.toFullString());\n+            }\n+\n+            if (checkConnection()) {\n+                @Nullable\n+                OpenThermGatewayConnector conn = connector;\n+\n+                if (conn != null) {\n+                    conn.sendCommand(gatewayCommand);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void connecting() {\n+        connecting = true;\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.NONE, \"Connecting\");\n+    }\n+\n+    @Override\n+    public void connected() {\n+        connecting = false;\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public void disconnected() {\n+        @Nullable\n+        OpenThermGatewayConnector conn = connector;\n+\n+        @Nullable\n+        OpenThermGatewayConfiguration conf = config;\n+\n+        connecting = false;\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Disconnected\");\n+\n+        // retry connection if disconnect is not explicitly requested\n+        if (conf != null && !explicitDisconnect && conf.connectionRetryInterval > 0) {\n+            scheduler.schedule(() -> {\n+                if (conn != null && !connecting && !conn.isConnected()) {\n+                    connect();\n+                }\n+            }, conf.connectionRetryInterval, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void receiveMessage(Message message) {\n+        if (DataItemGroup.dataItemGroups.containsKey(message.getID())) {", "originalCommit": "b58f2ac460fdeade42b65b3858f15510c3bce7b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3NDAzMA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r426274030", "bodyText": "Not every incoming message causes the receiveMessage callback function to be called. But ok, if it does get called, the Thing is clearly online. Added a Thing status update.", "author": "ArjenKorevaar", "createdAt": "2020-05-17T15:30:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI1MjQwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI1Njk5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r426256995", "bodyText": "I would expect an update of status from this IOException because now disconnect is called but the proper details of the problem are lacking. See also: https://www.openhab.org/docs/developer/guidelines.html#f-logging\n\nIn general bindings should NOT log to error/warn if e.g. connections are dropped - this is considered to be an external problem and from a system perspective to be a normal and expected situation. The correct way to inform users about such events is to update the Thing status accordingl", "author": "martinvw", "createdAt": "2020-05-17T12:41:44Z", "path": "bundles/org.openhab.binding.openthermgateway/src/main/java/org/openhab/binding/openthermgateway/internal/OpenThermGatewaySocketConnector.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.openthermgateway.internal;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.AbstractMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link OpenThermGatewaySocketConnector} is responsible for handling the socket connection\n+ *\n+ * @author Arjen Korevaar - Initial contribution\n+ * @author Arjan Mels - Improved robustness by re-sending commands, handling all message types (not only Boiler)\n+ */\n+@NonNullByDefault\n+public class OpenThermGatewaySocketConnector implements OpenThermGatewayConnector {\n+    private static final int COMMAND_RESPONSE_TIME_MILLISECONDS = 100;\n+    private static final int COMMAND_TIMEOUT_MILLISECONDS = 5000;\n+\n+    private final Logger logger = LoggerFactory.getLogger(OpenThermGatewaySocketConnector.class);\n+\n+    private final OpenThermGatewayCallback callback;\n+    private final String ipaddress;\n+    private final int port;\n+\n+    private @Nullable PrintWriter writer;\n+\n+    private volatile boolean stopping;\n+    private boolean connected;\n+\n+    private Map<String, Entry<Long, GatewayCommand>> pendingCommands = new ConcurrentHashMap<>();\n+\n+    public OpenThermGatewaySocketConnector(OpenThermGatewayCallback callback, String ipaddress, int port) {\n+        this.callback = callback;\n+        this.ipaddress = ipaddress;\n+        this.port = port;\n+    }\n+\n+    @Override\n+    public void run() {\n+        stopping = false;\n+        connected = false;\n+\n+        logger.debug(\"Connecting OpenThermGatewaySocketConnector to {}:{}\", this.ipaddress, this.port);\n+\n+        callback.connecting();\n+\n+        try (Socket socket = new Socket()) {\n+            socket.connect(new InetSocketAddress(this.ipaddress, this.port), COMMAND_TIMEOUT_MILLISECONDS);\n+            socket.setSoTimeout(COMMAND_TIMEOUT_MILLISECONDS);\n+\n+            connected = true;\n+\n+            callback.connected();\n+\n+            logger.debug(\"OpenThermGatewaySocketConnector connected\");\n+\n+            try (BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                    PrintWriter wrt = new PrintWriter(socket.getOutputStream(), true)) {\n+                // Make writer accessible on class level\n+                writer = wrt;\n+\n+                sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintReport, \"A\"));\n+                // Set the OTGW to report every message it receives and transmits\n+                sendCommand(GatewayCommand.parse(GatewayCommandCode.PrintSummary, \"0\"));\n+\n+                while (!stopping && !Thread.currentThread().isInterrupted()) {\n+                    @Nullable\n+                    String message = reader.readLine();\n+\n+                    if (message != null) {\n+                        handleMessage(message);\n+                    } else {\n+                        logger.debug(\"Connection closed by OpenTherm Gateway\");\n+                        break;\n+                    }\n+                }\n+\n+                logger.debug(\"Stopping OpenThermGatewaySocketConnector\");\n+            } finally {\n+                connected = false;\n+\n+                logger.debug(\"OpenThermGatewaySocketConnector disconnected\");\n+                callback.disconnected();\n+            }\n+        } catch (IOException ex) {", "originalCommit": "b58f2ac460fdeade42b65b3858f15510c3bce7b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3NDA5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r426274091", "bodyText": "Added calling callback on IOException to update Thing status, and changed logging to debug.", "author": "ArjenKorevaar", "createdAt": "2020-05-17T15:31:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI1Njk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3NjQ5OA==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r426276498", "bodyText": "You removed the status update from the disconnected callback so the thing will not go OFFLINE when this exception is caught.\nAlso, there is no context/message provided to the user, it would make sense to have a dedicated handler which passes the exception so that the message can be include when setting the thing status OFFLINE with a COMMUNICATION_ERROR. These statuses are described in the documentation.\nI can also imagine that the host is completely wrong (empty?) or the configuration is wrong in other ways, bindings should set the status than to CONFIGURATION_ERROR. I suppose in the old code the binding would just set it to OFFLINE without context or warning for the user which is not that user-friendly. Given it seems to be the first time that we mention this it can be a follow-up PR whenever have you time.\nBTW: follow-up PR's of the original contributor do not require a second reviewer.", "author": "martinvw", "createdAt": "2020-05-17T15:57:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI1Njk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI4MjE0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r426282145", "bodyText": "Reverted last commit. I should probably redesign the Thing status code, though it's unclear as to what this status should represent. If it's about being able to communicate with the OpenTherm gateway device, then having a connection or not should be enough to indicate an online or offline status. Configuration errors are not that relevant, because the host is a required field and whether the host is valid or not is not something the binding would hardly be able to verify. It is either able to connect or not. The hostname itself can be anything, a simple hostname, an ip address, an fqdn.", "author": "ArjenKorevaar", "createdAt": "2020-05-17T16:56:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI1Njk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI4MjY3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6785#discussion_r426282677", "bodyText": "@ArjenKorevaar shall we keep the status handling for a separate PR?", "author": "martinvw", "createdAt": "2020-05-17T17:01:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI1Njk5NQ=="}], "type": "inlineReview"}, {"oid": "8822e46eb435f89bdd4f1b31fdf79d2a7227cb42", "url": "https://github.com/openhab/openhab-addons/commit/8822e46eb435f89bdd4f1b31fdf79d2a7227cb42", "message": "Changed Thing status updates\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>", "committedDate": "2020-05-17T15:28:49Z", "type": "commit"}, {"oid": "eb1bb1de0e9d893eb1c7a23660f3d56a9eec9849", "url": "https://github.com/openhab/openhab-addons/commit/eb1bb1de0e9d893eb1c7a23660f3d56a9eec9849", "message": "Revert \"Changed Thing status updates\"\n\nThis reverts commit 8822e46eb435f89bdd4f1b31fdf79d2a7227cb42.\n\nSigned-off-by: Arjen Korevaar <a.korevaar@mephix.com>", "committedDate": "2020-05-17T16:41:09Z", "type": "commit"}]}