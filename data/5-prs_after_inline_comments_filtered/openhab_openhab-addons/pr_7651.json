{"pr_number": 7651, "pr_title": "[nuvo] Nuvo Whole House Audio Binding - initial contribution", "pr_createdAt": "2020-05-15T20:43:07Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/7651", "timeline": [{"oid": "29400b516a30c2ef2c2cfab386cd5863b935cda0", "url": "https://github.com/openhab/openhab-addons/commit/29400b516a30c2ef2c2cfab386cd5863b935cda0", "message": "Merge pull request #1 from openhab/2.5.x\n\nupdate fork", "committedDate": "2020-04-13T19:56:53Z", "type": "commit"}, {"oid": "37d791e6a6a787b77a5c60383d1f6a88adc6c9cd", "url": "https://github.com/openhab/openhab-addons/commit/37d791e6a6a787b77a5c60383d1f6a88adc6c9cd", "message": "Merge pull request #2 from openhab/2.5.x\n\nupdate fork", "committedDate": "2020-04-19T18:41:08Z", "type": "commit"}, {"oid": "4d02d1e08b42f84d9ff96dc840579bfeabb7161e", "url": "https://github.com/openhab/openhab-addons/commit/4d02d1e08b42f84d9ff96dc840579bfeabb7161e", "message": "Nuvo Whole House Audio Binding - initial contribution\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-15T20:26:39Z", "type": "commit"}, {"oid": "b04718b97e2f5b5b78bb3f1bb1df7b745a1a458f", "url": "https://github.com/openhab/openhab-addons/commit/b04718b97e2f5b5b78bb3f1bb1df7b745a1a458f", "message": "update project build files\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-15T20:39:35Z", "type": "commit"}, {"oid": "81aaf2a0bfad3c3cbcdbadc34e63a70d0a496a9c", "url": "https://github.com/openhab/openhab-addons/commit/81aaf2a0bfad3c3cbcdbadc34e63a70d0a496a9c", "message": "Cleanup before review\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-22T16:39:09Z", "type": "commit"}, {"oid": "6697918affa396592b31a2e7ae0f4db1f08fc40e", "url": "https://github.com/openhab/openhab-addons/commit/6697918affa396592b31a2e7ae0f4db1f08fc40e", "message": "update pom version to 2.5.6\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-23T04:50:37Z", "type": "commit"}, {"oid": "82462cd7c0499460c54237c70b956459bd53d8b3", "url": "https://github.com/openhab/openhab-addons/commit/82462cd7c0499460c54237c70b956459bd53d8b3", "message": "Merge pull request #3 from openhab/2.5.x\n\nupdate fork", "committedDate": "2020-05-27T03:57:29Z", "type": "commit"}, {"oid": "0f288987457b8e0b8182c6802c20cb4d75d4dc2a", "url": "https://github.com/openhab/openhab-addons/commit/0f288987457b8e0b8182c6802c20cb4d75d4dc2a", "message": "Merge branch '2.5.x' into NuvoAudio", "committedDate": "2020-05-27T22:03:31Z", "type": "commit"}, {"oid": "c7d2101d57dfac68dfff6864b07719a82277152e", "url": "https://github.com/openhab/openhab-addons/commit/c7d2101d57dfac68dfff6864b07719a82277152e", "message": "spotless cleanup and label cleanup\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-27T22:44:31Z", "type": "commit"}, {"oid": "e2fb7d075aa303ce87b6d6064bcf75ee1007e7ed", "url": "https://github.com/openhab/openhab-addons/commit/e2fb7d075aa303ce87b6d6064bcf75ee1007e7ed", "message": "implement code review changes from other PR\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-01T17:59:13Z", "type": "commit"}, {"oid": "64101f3db2e8c2e1276378eed581e8409d1ba4b2", "url": "https://github.com/openhab/openhab-addons/commit/64101f3db2e8c2e1276378eed581e8409d1ba4b2", "message": "remove ZONE_MAP and SOURCE_MAP\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-01T18:46:41Z", "type": "commit"}, {"oid": "5d548ccb1f0c2dc140c006242aa61ed0b07b3d87", "url": "https://github.com/openhab/openhab-addons/commit/5d548ccb1f0c2dc140c006242aa61ed0b07b3d87", "message": "Merge pull request #4 from openhab/2.5.x\n\nupdate fork", "committedDate": "2020-06-04T21:19:29Z", "type": "commit"}, {"oid": "41709ef3f47b576df3eca355a6a0cc138bf36fd5", "url": "https://github.com/openhab/openhab-addons/commit/41709ef3f47b576df3eca355a6a0cc138bf36fd5", "message": "Merge pull request #5 from openhab/2.5.x\n\nupdate fork", "committedDate": "2020-06-24T13:47:17Z", "type": "commit"}, {"oid": "c338a04e048a175fa69fb7880163e0f43b12d7d5", "url": "https://github.com/openhab/openhab-addons/commit/c338a04e048a175fa69fb7880163e0f43b12d7d5", "message": "Merge branch '2.5.x' into NuvoAudio", "committedDate": "2020-06-26T13:42:34Z", "type": "commit"}, {"oid": "150d39be40a3df74ad3737b0ed8ee9b5b3646c67", "url": "https://github.com/openhab/openhab-addons/commit/150d39be40a3df74ad3737b0ed8ee9b5b3646c67", "message": "rollforward review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-26T19:11:51Z", "type": "commit"}, {"oid": "3301ea33fa77cf5d5579ac395fe9e94f94a58155", "url": "https://github.com/openhab/openhab-addons/commit/3301ea33fa77cf5d5579ac395fe9e94f94a58155", "message": "remove InterruptedIOException\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-26T21:33:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgzMzEzMg==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r451833132", "bodyText": "You could remove disabling the null annotations without any effect, since you injected them in the constructor.", "author": "fwolter", "createdAt": "2020-07-08T21:23:08Z", "path": "bundles/org.openhab.binding.nuvo/src/main/java/org/openhab/binding/nuvo/internal/NuvoHandlerFactory.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.nuvo.internal;\n+\n+import static org.openhab.binding.nuvo.internal.NuvoBindingConstants.*;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.nuvo.internal.handler.NuvoHandler;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link NuvoHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.nuvo\", service = ThingHandlerFactory.class)\n+public class NuvoHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_AMP);\n+\n+    private final @NonNullByDefault({}) SerialPortManager serialPortManager;\n+\n+    private final @NonNullByDefault({}) NuvoStateDescriptionOptionProvider stateDescriptionProvider;", "originalCommit": "3301ea33fa77cf5d5579ac395fe9e94f94a58155", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgzMzU1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r451833557", "bodyText": "handler could be null at this point.", "author": "fwolter", "createdAt": "2020-07-08T21:24:11Z", "path": "bundles/org.openhab.binding.nuvo/src/main/java/org/openhab/binding/nuvo/internal/NuvoThingActions.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.nuvo.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.binding.nuvo.internal.handler.NuvoHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Some automation actions to be used with a {@link NuvoThingActions}\n+ *\n+ * @author Michael Lobstein - initial contribution\n+ *\n+ */\n+@ThingActionsScope(name = \"nuvo\")\n+@NonNullByDefault\n+public class NuvoThingActions implements ThingActions {\n+\n+    private final Logger logger = LoggerFactory.getLogger(NuvoThingActions.class);\n+\n+    private @Nullable NuvoHandler handler;\n+\n+    @RuleAction(label = \"sendNuvoCommand\", description = \"Action that sends raw command to the amplifer\")\n+    public void sendNuvoCommand(@ActionInput(name = \"sendNuvoCommand\") @Nullable String rawCommand) {\n+        handler.handleRawCommand(rawCommand);", "originalCommit": "3301ea33fa77cf5d5579ac395fe9e94f94a58155", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgzNDkyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r451834921", "bodyText": "Do you mean 5000?\nIf yes:\nSince this is called very often (and concurrently), better schedule a job to not clog openHAB's thread pools.", "author": "fwolter", "createdAt": "2020-07-08T21:26:53Z", "path": "bundles/org.openhab.binding.nuvo/src/main/java/org/openhab/binding/nuvo/internal/communication/NuvoConnector.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.nuvo.internal.communication;\n+\n+import static org.openhab.binding.nuvo.internal.NuvoBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.nuvo.internal.NuvoException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the Nuvo device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the Nuvo binding\n+ */\n+@NonNullByDefault\n+public abstract class NuvoConnector {\n+    private static final String COMMAND_OK = \"#OK\";\n+    private static final String BEGIN_CMD = \"*\";\n+    private static final String END_CMD = \"\\r\";\n+    private static final String QUERY = \"?\";\n+    private static final String VER_STR = \"#VER\\\"NV-\";\n+    private static final String ALL_OFF = \"#ALLOFF\";\n+    private static final String MUTE = \"#MUTE\";\n+    private static final String PAGE = \"#PAGE\";\n+\n+    private static final byte[] WAKE_STR = \"\\r\".getBytes(StandardCharsets.US_ASCII);\n+\n+    private static final Pattern SRC_PATTERN = Pattern.compile(\"^#S(\\\\d{1})(.*)$\");\n+    private static final Pattern ZONE_PATTERN = Pattern.compile(\"^#Z(\\\\d{1,2}),(.*)$\");\n+    private static final Pattern ZONE_BUTTON_PATTERN = Pattern.compile(\"^#Z(\\\\d{1,2})(S\\\\d{1})(.*)$\");\n+    private static final Pattern ZONE_CFG_PATTERN = Pattern.compile(\"^#ZCFG(\\\\d{1,2}),(.*)$\");\n+\n+    private final Logger logger = LoggerFactory.getLogger(NuvoConnector.class);\n+\n+    protected static final String COMMAND_ERROR = \"#?\";\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<NuvoMessageEventListener> listeners = new ArrayList<>();\n+\n+    private boolean isEssentia = true;\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Tell the connector if the device is an Essentia G or not\n+     *\n+     * @param true if the device is an Essentia G\n+     */\n+    public void setEssentia(boolean isEssentia) {\n+        this.isEssentia = isEssentia;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the Nuvo device\n+     *\n+     * @throws NuvoException - In case of any problem\n+     */\n+    public abstract void open() throws NuvoException;\n+\n+    /**\n+     * Close the connection with the Nuvo device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut != null) {\n+            try {\n+                dataOut.close();\n+            } catch (IOException e) {\n+                logger.debug(\"Error closing dataOut: {}\", e.getMessage());\n+            }\n+            this.dataOut = null;\n+        }\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn != null) {\n+            try {\n+                dataIn.close();\n+            } catch (IOException e) {\n+                logger.debug(\"Error closing dataIn: {}\", e.getMessage());\n+            }\n+            this.dataIn = null;\n+        }\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join(3000);\n+            } catch (InterruptedException e) {\n+                logger.warn(\"Error joining readerThread: {}\", e.getMessage());\n+            }\n+            this.readerThread = null;\n+        }\n+    }\n+\n+    /**\n+     * Reads some number of bytes from the input stream and stores them into the buffer array b. The number of bytes\n+     * actually read is returned as an integer.\n+     *\n+     * @param dataBuffer the buffer into which the data is read.\n+     *\n+     * @return the total number of bytes read into the buffer, or -1 if there is no more data because the end of the\n+     *         stream has been reached.\n+     *\n+     * @throws NuvoException - If the input stream is null, if the first byte cannot be read for any reason\n+     *             other than the end of the file, if the input stream has been closed, or if some other I/O error\n+     *             occurs.\n+     */\n+    protected int readInput(byte[] dataBuffer) throws NuvoException {\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn == null) {\n+            throw new NuvoException(\"readInput failed: input stream is null\");\n+        }\n+        try {\n+            return dataIn.read(dataBuffer);\n+        } catch (IOException e) {\n+            throw new NuvoException(\"readInput failed: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    /**\n+     * Request the Nuvo controller to execute an inquiry command\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     *\n+     * @throws NuvoException - In case of any problem\n+     */\n+    public void sendQuery(NuvoEnum zone, NuvoCommand cmd) throws NuvoException {\n+        sendCommand(zone.getId() + cmd.getValue() + QUERY);\n+    }\n+\n+    /**\n+     * Request the Nuvo controller to execute a command for a zone that takes no arguments (ie power on, power off,\n+     * etc.)\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     *\n+     * @throws NuvoException - In case of any problem\n+     */\n+    public void sendCommand(NuvoEnum zone, NuvoCommand cmd) throws NuvoException {\n+        sendCommand(zone.getId() + cmd.getValue());\n+    }\n+\n+    /**\n+     * Request the Nuvo controller to execute a command for a zone and pass in a value\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     * @param value the string value to consider for volume, source, etc.\n+     *\n+     * @throws NuvoException - In case of any problem\n+     */\n+    public void sendCommand(NuvoEnum zone, NuvoCommand cmd, @Nullable String value) throws NuvoException {\n+        sendCommand(zone.getId() + cmd.getValue() + value);\n+    }\n+\n+    /**\n+     * Request the Nuvo controller to execute a configuration command for a zone and pass in a value\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     * @param value the string value to consider for bass, treble, balance, etc.\n+     *\n+     * @throws NuvoException - In case of any problem\n+     */\n+    public void sendCfgCommand(NuvoEnum zone, NuvoCommand cmd, @Nullable String value) throws NuvoException {\n+        sendCommand(zone.getConfigId() + cmd.getValue() + value);\n+    }\n+\n+    /**\n+     * Request the Nuvo controller to execute a system command the does not specify a zone or value\n+     *\n+     * @param cmd the command to execute\n+     *\n+     * @throws NuvoException - In case of any problem\n+     */\n+    public void sendCommand(NuvoCommand cmd) throws NuvoException {\n+        sendCommand(cmd.getValue());\n+    }\n+\n+    /**\n+     * Request the Nuvo controller to execute a raw command string\n+     *\n+     * @param command the command string to run\n+     *\n+     * @throws NuvoException - In case of any problem\n+     */\n+    public void sendCommand(String command) throws NuvoException {\n+        String messageStr = BEGIN_CMD + command + END_CMD;\n+\n+        logger.debug(\"sending command: {}\", messageStr);\n+\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut == null) {\n+            throw new NuvoException(\"Send command \\\"\" + messageStr + \"\\\" failed: output stream is null\");\n+        }\n+        try {\n+            // Essentia G needs time to wake up when in standby mode\n+            // I don't want to track that in the binding, so just do this always\n+            if (this.isEssentia) {\n+                dataOut.write(WAKE_STR);\n+                dataOut.flush();\n+                Thread.sleep(5);", "originalCommit": "3301ea33fa77cf5d5579ac395fe9e94f94a58155", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg3NjA4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r451876085", "bodyText": "This device's spec document explicitly mention 5ms for sleep wakeup and 50 milliseconds between commands. It this going to be a problem with the thread pools?", "author": "mlobstein", "createdAt": "2020-07-08T23:17:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgzNDkyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjAxNzAxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r452017019", "bodyText": "No, that won't be a problem. But values shorter than 100ms can be ignored by the JVM completely. To increase the probability for the JVM to respect the sleeps, you should set them to 100ms.", "author": "fwolter", "createdAt": "2020-07-09T07:26:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgzNDkyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ2MTUzNw==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r452461537", "bodyText": "Would it be better to do something with wait() instead of Thread.sleep()?", "author": "mlobstein", "createdAt": "2020-07-09T20:09:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgzNDkyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ2OTc3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r452469773", "bodyText": "No, that won't make things better. I would try if the sleeps are necessary at all. 5ms might be the overall system-to-system latency. Otherwise, it's ok to go with the 100ms delays.", "author": "fwolter", "createdAt": "2020-07-09T20:25:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgzNDkyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU4MjU2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r452582562", "bodyText": "I removed it and the device still wakes up properly.", "author": "mlobstein", "createdAt": "2020-07-10T02:01:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgzNDkyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgzODU5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r451838593", "bodyText": "Do these log messages make sense? If I see correctly, they are repeatedly logged when one message is received.", "author": "fwolter", "createdAt": "2020-07-08T21:34:56Z", "path": "bundles/org.openhab.binding.nuvo/src/main/java/org/openhab/binding/nuvo/internal/communication/NuvoConnector.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.nuvo.internal.communication;\n+\n+import static org.openhab.binding.nuvo.internal.NuvoBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.nuvo.internal.NuvoException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the Nuvo device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the Nuvo binding\n+ */\n+@NonNullByDefault\n+public abstract class NuvoConnector {\n+    private static final String COMMAND_OK = \"#OK\";\n+    private static final String BEGIN_CMD = \"*\";\n+    private static final String END_CMD = \"\\r\";\n+    private static final String QUERY = \"?\";\n+    private static final String VER_STR = \"#VER\\\"NV-\";\n+    private static final String ALL_OFF = \"#ALLOFF\";\n+    private static final String MUTE = \"#MUTE\";\n+    private static final String PAGE = \"#PAGE\";\n+\n+    private static final byte[] WAKE_STR = \"\\r\".getBytes(StandardCharsets.US_ASCII);\n+\n+    private static final Pattern SRC_PATTERN = Pattern.compile(\"^#S(\\\\d{1})(.*)$\");\n+    private static final Pattern ZONE_PATTERN = Pattern.compile(\"^#Z(\\\\d{1,2}),(.*)$\");\n+    private static final Pattern ZONE_BUTTON_PATTERN = Pattern.compile(\"^#Z(\\\\d{1,2})(S\\\\d{1})(.*)$\");\n+    private static final Pattern ZONE_CFG_PATTERN = Pattern.compile(\"^#ZCFG(\\\\d{1,2}),(.*)$\");\n+\n+    private final Logger logger = LoggerFactory.getLogger(NuvoConnector.class);\n+\n+    protected static final String COMMAND_ERROR = \"#?\";\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<NuvoMessageEventListener> listeners = new ArrayList<>();\n+\n+    private boolean isEssentia = true;\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Tell the connector if the device is an Essentia G or not\n+     *\n+     * @param true if the device is an Essentia G\n+     */\n+    public void setEssentia(boolean isEssentia) {\n+        this.isEssentia = isEssentia;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the Nuvo device\n+     *\n+     * @throws NuvoException - In case of any problem\n+     */\n+    public abstract void open() throws NuvoException;\n+\n+    /**\n+     * Close the connection with the Nuvo device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut != null) {\n+            try {\n+                dataOut.close();\n+            } catch (IOException e) {\n+                logger.debug(\"Error closing dataOut: {}\", e.getMessage());\n+            }\n+            this.dataOut = null;\n+        }\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn != null) {\n+            try {\n+                dataIn.close();\n+            } catch (IOException e) {\n+                logger.debug(\"Error closing dataIn: {}\", e.getMessage());\n+            }\n+            this.dataIn = null;\n+        }\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join(3000);\n+            } catch (InterruptedException e) {\n+                logger.warn(\"Error joining readerThread: {}\", e.getMessage());\n+            }\n+            this.readerThread = null;\n+        }\n+    }\n+\n+    /**\n+     * Reads some number of bytes from the input stream and stores them into the buffer array b. The number of bytes\n+     * actually read is returned as an integer.\n+     *\n+     * @param dataBuffer the buffer into which the data is read.\n+     *\n+     * @return the total number of bytes read into the buffer, or -1 if there is no more data because the end of the\n+     *         stream has been reached.\n+     *\n+     * @throws NuvoException - If the input stream is null, if the first byte cannot be read for any reason\n+     *             other than the end of the file, if the input stream has been closed, or if some other I/O error\n+     *             occurs.\n+     */\n+    protected int readInput(byte[] dataBuffer) throws NuvoException {\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn == null) {\n+            throw new NuvoException(\"readInput failed: input stream is null\");\n+        }\n+        try {\n+            return dataIn.read(dataBuffer);\n+        } catch (IOException e) {\n+            throw new NuvoException(\"readInput failed: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    /**\n+     * Request the Nuvo controller to execute an inquiry command\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     *\n+     * @throws NuvoException - In case of any problem\n+     */\n+    public void sendQuery(NuvoEnum zone, NuvoCommand cmd) throws NuvoException {\n+        sendCommand(zone.getId() + cmd.getValue() + QUERY);\n+    }\n+\n+    /**\n+     * Request the Nuvo controller to execute a command for a zone that takes no arguments (ie power on, power off,\n+     * etc.)\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     *\n+     * @throws NuvoException - In case of any problem\n+     */\n+    public void sendCommand(NuvoEnum zone, NuvoCommand cmd) throws NuvoException {\n+        sendCommand(zone.getId() + cmd.getValue());\n+    }\n+\n+    /**\n+     * Request the Nuvo controller to execute a command for a zone and pass in a value\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     * @param value the string value to consider for volume, source, etc.\n+     *\n+     * @throws NuvoException - In case of any problem\n+     */\n+    public void sendCommand(NuvoEnum zone, NuvoCommand cmd, @Nullable String value) throws NuvoException {\n+        sendCommand(zone.getId() + cmd.getValue() + value);\n+    }\n+\n+    /**\n+     * Request the Nuvo controller to execute a configuration command for a zone and pass in a value\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     * @param value the string value to consider for bass, treble, balance, etc.\n+     *\n+     * @throws NuvoException - In case of any problem\n+     */\n+    public void sendCfgCommand(NuvoEnum zone, NuvoCommand cmd, @Nullable String value) throws NuvoException {\n+        sendCommand(zone.getConfigId() + cmd.getValue() + value);\n+    }\n+\n+    /**\n+     * Request the Nuvo controller to execute a system command the does not specify a zone or value\n+     *\n+     * @param cmd the command to execute\n+     *\n+     * @throws NuvoException - In case of any problem\n+     */\n+    public void sendCommand(NuvoCommand cmd) throws NuvoException {\n+        sendCommand(cmd.getValue());\n+    }\n+\n+    /**\n+     * Request the Nuvo controller to execute a raw command string\n+     *\n+     * @param command the command string to run\n+     *\n+     * @throws NuvoException - In case of any problem\n+     */\n+    public void sendCommand(String command) throws NuvoException {\n+        String messageStr = BEGIN_CMD + command + END_CMD;\n+\n+        logger.debug(\"sending command: {}\", messageStr);\n+\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut == null) {\n+            throw new NuvoException(\"Send command \\\"\" + messageStr + \"\\\" failed: output stream is null\");\n+        }\n+        try {\n+            // Essentia G needs time to wake up when in standby mode\n+            // I don't want to track that in the binding, so just do this always\n+            if (this.isEssentia) {\n+                dataOut.write(WAKE_STR);\n+                dataOut.flush();\n+                Thread.sleep(5);\n+            }\n+            dataOut.write(messageStr.getBytes(StandardCharsets.US_ASCII));\n+            dataOut.flush();\n+        } catch (IOException | InterruptedException e) {\n+            throw new NuvoException(\"Send command \\\"\" + command + \"\\\" failed: \" + e.getMessage(), e);\n+        }\n+    }\n+\n+    /**\n+     * Add a listener to the list of listeners to be notified with events\n+     *\n+     * @param listener the listener\n+     */\n+    public void addEventListener(NuvoMessageEventListener listener) {\n+        listeners.add(listener);\n+    }\n+\n+    /**\n+     * Remove a listener from the list of listeners to be notified with events\n+     *\n+     * @param listener the listener\n+     */\n+    public void removeEventListener(NuvoMessageEventListener listener) {\n+        listeners.remove(listener);\n+    }\n+\n+    /**\n+     * Analyze an incoming message and dispatch corresponding (type, key, value) to the event listeners\n+     *\n+     * @param incomingMessage the received message\n+     */\n+    public void handleIncomingMessage(byte[] incomingMessage) {\n+        String message = new String(incomingMessage, StandardCharsets.US_ASCII).trim();\n+\n+        logger.debug(\"handleIncomingMessage: {}\", message);\n+\n+        if (COMMAND_ERROR.equals(message) || COMMAND_OK.equals(message)) {\n+            // ignore\n+            return;\n+        }\n+\n+        if (message.contains(VER_STR)) {\n+            // example: #VER\"NV-E6G FWv2.66 HWv0\"\n+            // split on \" and return the version number\n+            dispatchKeyValue(TYPE_VERSION, \"\", message.split(\"\\\"\")[1]);\n+            return;\n+        }\n+\n+        if (message.equals(ALL_OFF)) {\n+            dispatchKeyValue(TYPE_ALLOFF, BLANK, BLANK);\n+            return;\n+        }\n+\n+        if (message.contains(MUTE)) {\n+            dispatchKeyValue(TYPE_ALLMUTE, BLANK, message.substring(message.length() - 1));\n+            return;\n+        }\n+\n+        if (message.contains(PAGE)) {\n+            dispatchKeyValue(TYPE_PAGE, BLANK, message.substring(message.length() - 1));\n+            return;\n+        }\n+\n+        // Amp controller send a source update ie: #S2DISPINFO,DUR3380,POS3090,STATUS2\n+        // or #S2DISPLINE1,\"1 of 17\"\n+        Matcher matcher = SRC_PATTERN.matcher(message);\n+        if (matcher.find()) {\n+            // pull out the source id and the remainder of the message\n+            dispatchKeyValue(TYPE_SOURCE_UPDATE, matcher.group(1), matcher.group(2));\n+            return;\n+        } else {\n+            logger.debug(\"no match on message: {}\", message);", "originalCommit": "3301ea33fa77cf5d5579ac395fe9e94f94a58155", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg5OTk2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r451899962", "bodyText": "removed", "author": "mlobstein", "createdAt": "2020-07-09T00:40:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgzODU5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgzOTg2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r451839867", "bodyText": "There is a compiler null warning left.", "author": "fwolter", "createdAt": "2020-07-08T21:37:46Z", "path": "bundles/org.openhab.binding.nuvo/src/main/java/org/openhab/binding/nuvo/internal/communication/NuvoIpConnector.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.nuvo.internal.communication;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.Socket;\n+import java.net.SocketTimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.nuvo.internal.NuvoException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the Nuvo device through a serial over IP connection\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the Nuvo binding\n+ */\n+@NonNullByDefault\n+public class NuvoIpConnector extends NuvoConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(NuvoIpConnector.class);\n+\n+    private @Nullable String address;\n+    private int port;\n+\n+    private @Nullable Socket clientSocket;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param address the IP address of the serial over ip adapter\n+     * @param port the TCP port to be used\n+     */\n+    public NuvoIpConnector(@Nullable String address, @Nullable Integer port) {\n+        this.address = address;\n+        this.port = port;", "originalCommit": "3301ea33fa77cf5d5579ac395fe9e94f94a58155", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkwMDEwOA==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r451900108", "bodyText": "fixed all \ud83d\udc4d", "author": "mlobstein", "createdAt": "2020-07-09T00:40:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgzOTg2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg0MDcxMg==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r451840712", "bodyText": "Same for below.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return (L + Integer.toString(value * -1));\n          \n          \n            \n                        return (L + (value * -1));", "author": "fwolter", "createdAt": "2020-07-08T21:39:57Z", "path": "bundles/org.openhab.binding.nuvo/src/main/java/org/openhab/binding/nuvo/internal/communication/NuvoStatusCodes.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.nuvo.internal.communication;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Provides mapping of various Nuvo status codes to plain language meanings\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class NuvoStatusCodes {\n+    private static final String L = \"L\";\n+    private static final String C = \"C\";\n+    private static final String R = \"R\";\n+    private static final String DASH = \"-\";\n+    private static final String ZERO = \"0\";\n+\n+    // map to lookup play mode\n+    public static final Map<String, String> PLAY_MODE = new HashMap<>();\n+    static {\n+        PLAY_MODE.put(\"0\", \"Normal\");\n+        PLAY_MODE.put(\"1\", \"Idle\");\n+        PLAY_MODE.put(\"2\", \"Playing\");\n+        PLAY_MODE.put(\"3\", \"Paused\");\n+        PLAY_MODE.put(\"4\", \"Fast Forward\");\n+        PLAY_MODE.put(\"5\", \"Rewind\");\n+        PLAY_MODE.put(\"6\", \"Play Shuffle\");\n+        PLAY_MODE.put(\"7\", \"Play Repeat\");\n+        PLAY_MODE.put(\"8\", \"Play Shuffle Repeat\");\n+        PLAY_MODE.put(\"9\", \"unknown-9\");\n+        PLAY_MODE.put(\"10\", \"unknown-10\");\n+        PLAY_MODE.put(\"11\", \"Radio\"); // undocumented\n+        PLAY_MODE.put(\"12\", \"unknown-12\");\n+    }\n+\n+    /*\n+     * This looks broken because the controller is seriously broken...\n+     * On the keypad when adjusting the balance to \"Left 18\", the serial data reports R18 \u00af\\_(\u30c4)_/\u00af\n+     * So on top of the weird translation, the value needs to be reversed by the binding\n+     * to ensure that it will match what is displayed on the keypad.\n+     * For display purposes we want -18 to be full left, 0 = center, and +18 to be full right\n+     */\n+    public static String getBalanceFromStr(String value) {\n+        // example L2; return 2 | C; return 0 | R10; return -10\n+        if (value.substring(0, 1).equals(L)) {\n+            return (value.substring(1));\n+        } else if (value.equals(C)) {\n+            return ZERO;\n+        } else if (value.substring(0, 1).equals(R)) {\n+            return (DASH + value.substring(1));\n+        }\n+        return ZERO;\n+    }\n+\n+    // see above comment\n+    public static String getBalanceFromInt(Integer value) {\n+        if (value < 0) {\n+            return (L + Integer.toString(value * -1));", "originalCommit": "3301ea33fa77cf5d5579ac395fe9e94f94a58155", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg0MDk4MA==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r451840980", "bodyText": "It's good practice to append the unit to the field name e.g. TIMEOUT_SEC.", "author": "fwolter", "createdAt": "2020-07-08T21:40:35Z", "path": "bundles/org.openhab.binding.nuvo/src/main/java/org/openhab/binding/nuvo/internal/handler/NuvoHandler.java", "diffHunk": "@@ -0,0 +1,776 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.nuvo.internal.handler;\n+\n+import static org.openhab.binding.nuvo.internal.NuvoBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.nuvo.internal.NuvoException;\n+import org.openhab.binding.nuvo.internal.NuvoStateDescriptionOptionProvider;\n+import org.openhab.binding.nuvo.internal.NuvoThingActions;\n+import org.openhab.binding.nuvo.internal.communication.NuvoCommand;\n+import org.openhab.binding.nuvo.internal.communication.NuvoConnector;\n+import org.openhab.binding.nuvo.internal.communication.NuvoDefaultConnector;\n+import org.openhab.binding.nuvo.internal.communication.NuvoEnum;\n+import org.openhab.binding.nuvo.internal.communication.NuvoIpConnector;\n+import org.openhab.binding.nuvo.internal.communication.NuvoMessageEvent;\n+import org.openhab.binding.nuvo.internal.communication.NuvoMessageEventListener;\n+import org.openhab.binding.nuvo.internal.communication.NuvoSerialConnector;\n+import org.openhab.binding.nuvo.internal.communication.NuvoStatusCodes;\n+import org.openhab.binding.nuvo.internal.configuration.NuvoThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link NuvoHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class NuvoHandler extends BaseThingHandler implements NuvoMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = 60;", "originalCommit": "3301ea33fa77cf5d5579ac395fe9e94f94a58155", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkwMDg0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r451900846", "bodyText": "done for all.", "author": "mlobstein", "createdAt": "2020-07-09T00:43:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg0MDk4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg0MjE1NA==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r451842154", "bodyText": "After the thing status is set to unknown, the framework starts to work with this Thing: handleCommand() and dispose() can be invoked (concurrently). If dispose() is invoked before the jobs are scheduled, the jobs won't be cancelled.", "author": "fwolter", "createdAt": "2020-07-08T21:43:26Z", "path": "bundles/org.openhab.binding.nuvo/src/main/java/org/openhab/binding/nuvo/internal/handler/NuvoHandler.java", "diffHunk": "@@ -0,0 +1,776 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.nuvo.internal.handler;\n+\n+import static org.openhab.binding.nuvo.internal.NuvoBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.nuvo.internal.NuvoException;\n+import org.openhab.binding.nuvo.internal.NuvoStateDescriptionOptionProvider;\n+import org.openhab.binding.nuvo.internal.NuvoThingActions;\n+import org.openhab.binding.nuvo.internal.communication.NuvoCommand;\n+import org.openhab.binding.nuvo.internal.communication.NuvoConnector;\n+import org.openhab.binding.nuvo.internal.communication.NuvoDefaultConnector;\n+import org.openhab.binding.nuvo.internal.communication.NuvoEnum;\n+import org.openhab.binding.nuvo.internal.communication.NuvoIpConnector;\n+import org.openhab.binding.nuvo.internal.communication.NuvoMessageEvent;\n+import org.openhab.binding.nuvo.internal.communication.NuvoMessageEventListener;\n+import org.openhab.binding.nuvo.internal.communication.NuvoSerialConnector;\n+import org.openhab.binding.nuvo.internal.communication.NuvoStatusCodes;\n+import org.openhab.binding.nuvo.internal.configuration.NuvoThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link NuvoHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class NuvoHandler extends BaseThingHandler implements NuvoMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = 60;\n+    private static final long POLLING_INTERVAL = 30;\n+    private static final long CLOCK_SYNC_INTERVAL = 3600;\n+    private static final long INITIAL_POLLING_DELAY = 30;\n+    private static final long INITIAL_CLOCK_SYNC_DELAY = 10;\n+    // spec says wait 50ms, min is 100\n+    private static final long SLEEP_BETWEEN_CMD = 100;\n+    private static final Unit<Time> API_SECOND_UNIT = SmartHomeUnits.SECOND;\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String SOURCE = \"SOURCE\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String UNDEF = \"UNDEF\";\n+    private static final String GC_STR = \"NV-IG8\";\n+\n+    private static final int MAX_ZONES = 20;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 79;\n+    private static final int MIN_EQ = -18;\n+    private static final int MAX_EQ = 18;\n+\n+    private static final Pattern ZONE_PATTERN = Pattern\n+            .compile(\"^ON,SRC(\\\\d{1}),(MUTE|VOL\\\\d{1,2}),DND([0-1]),LOCK([0-1])$\");\n+    private static final Pattern DISP_PATTERN = Pattern.compile(\"^DISPLINE(\\\\d{1}),\\\"(.*)\\\"$\");\n+    private static final Pattern DISP_INFO_PATTERN = Pattern\n+            .compile(\"^DISPINFO,DUR(\\\\d{1,6}),POS(\\\\d{1,6}),STATUS(\\\\d{1,2})$\");\n+    private static final Pattern ZONE_CFG_PATTERN = Pattern.compile(\"^BASS(.*),TREB(.*),BAL(.*),LOUDCMP([0-1])$\");\n+\n+    private final Logger logger = LoggerFactory.getLogger(NuvoHandler.class);\n+    private final NuvoStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final SerialPortManager serialPortManager;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> clockSyncJob;\n+\n+    private NuvoConnector connector = new NuvoDefaultConnector();\n+    private long lastEventReceived = System.currentTimeMillis();\n+    private int numZones = 1;\n+    private String versionString = BLANK;\n+    private boolean isGConcerto = false;\n+    private Object sequenceLock = new Object();\n+\n+    Set<Integer> activeZones = new HashSet<Integer>(1);\n+\n+    // A state option list for the source labels\n+    List<StateOption> sourceLabels = new ArrayList<>();\n+\n+    /**\n+     * Constructor\n+     */\n+    public NuvoHandler(Thing thing, NuvoStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        NuvoThingConfiguration config = getConfigAs(NuvoThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+            return;\n+        }\n+\n+        if (config.serialPort != null) {\n+            String serialPort = config.serialPort;\n+            connector = new NuvoSerialConnector(serialPortManager, serialPort);\n+        } else {\n+            connector = new NuvoIpConnector(config.host, config.port);\n+        }\n+\n+        numZones = config.numZones;\n+        activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toSet());\n+\n+        // remove the channels for the zones we are not using\n+        if (numZones < MAX_ZONES) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+            List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                    .collect(Collectors.toList());\n+\n+            zonesToRemove.forEach(zone -> {\n+                channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())));\n+            });\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (config.clockSync) {\n+            scheduleClockSyncJob();\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);", "originalCommit": "3301ea33fa77cf5d5579ac395fe9e94f94a58155", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkwMDk1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r451900951", "bodyText": "fixed", "author": "mlobstein", "createdAt": "2020-07-09T00:44:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg0MjE1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg0MzczNA==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r451843734", "bodyText": "Is it worth to translate odd values to even values, instead of ignoring them?", "author": "fwolter", "createdAt": "2020-07-08T21:47:09Z", "path": "bundles/org.openhab.binding.nuvo/src/main/java/org/openhab/binding/nuvo/internal/handler/NuvoHandler.java", "diffHunk": "@@ -0,0 +1,776 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.nuvo.internal.handler;\n+\n+import static org.openhab.binding.nuvo.internal.NuvoBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.nuvo.internal.NuvoException;\n+import org.openhab.binding.nuvo.internal.NuvoStateDescriptionOptionProvider;\n+import org.openhab.binding.nuvo.internal.NuvoThingActions;\n+import org.openhab.binding.nuvo.internal.communication.NuvoCommand;\n+import org.openhab.binding.nuvo.internal.communication.NuvoConnector;\n+import org.openhab.binding.nuvo.internal.communication.NuvoDefaultConnector;\n+import org.openhab.binding.nuvo.internal.communication.NuvoEnum;\n+import org.openhab.binding.nuvo.internal.communication.NuvoIpConnector;\n+import org.openhab.binding.nuvo.internal.communication.NuvoMessageEvent;\n+import org.openhab.binding.nuvo.internal.communication.NuvoMessageEventListener;\n+import org.openhab.binding.nuvo.internal.communication.NuvoSerialConnector;\n+import org.openhab.binding.nuvo.internal.communication.NuvoStatusCodes;\n+import org.openhab.binding.nuvo.internal.configuration.NuvoThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link NuvoHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class NuvoHandler extends BaseThingHandler implements NuvoMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = 60;\n+    private static final long POLLING_INTERVAL = 30;\n+    private static final long CLOCK_SYNC_INTERVAL = 3600;\n+    private static final long INITIAL_POLLING_DELAY = 30;\n+    private static final long INITIAL_CLOCK_SYNC_DELAY = 10;\n+    // spec says wait 50ms, min is 100\n+    private static final long SLEEP_BETWEEN_CMD = 100;\n+    private static final Unit<Time> API_SECOND_UNIT = SmartHomeUnits.SECOND;\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String SOURCE = \"SOURCE\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String UNDEF = \"UNDEF\";\n+    private static final String GC_STR = \"NV-IG8\";\n+\n+    private static final int MAX_ZONES = 20;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 79;\n+    private static final int MIN_EQ = -18;\n+    private static final int MAX_EQ = 18;\n+\n+    private static final Pattern ZONE_PATTERN = Pattern\n+            .compile(\"^ON,SRC(\\\\d{1}),(MUTE|VOL\\\\d{1,2}),DND([0-1]),LOCK([0-1])$\");\n+    private static final Pattern DISP_PATTERN = Pattern.compile(\"^DISPLINE(\\\\d{1}),\\\"(.*)\\\"$\");\n+    private static final Pattern DISP_INFO_PATTERN = Pattern\n+            .compile(\"^DISPINFO,DUR(\\\\d{1,6}),POS(\\\\d{1,6}),STATUS(\\\\d{1,2})$\");\n+    private static final Pattern ZONE_CFG_PATTERN = Pattern.compile(\"^BASS(.*),TREB(.*),BAL(.*),LOUDCMP([0-1])$\");\n+\n+    private final Logger logger = LoggerFactory.getLogger(NuvoHandler.class);\n+    private final NuvoStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final SerialPortManager serialPortManager;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> clockSyncJob;\n+\n+    private NuvoConnector connector = new NuvoDefaultConnector();\n+    private long lastEventReceived = System.currentTimeMillis();\n+    private int numZones = 1;\n+    private String versionString = BLANK;\n+    private boolean isGConcerto = false;\n+    private Object sequenceLock = new Object();\n+\n+    Set<Integer> activeZones = new HashSet<Integer>(1);\n+\n+    // A state option list for the source labels\n+    List<StateOption> sourceLabels = new ArrayList<>();\n+\n+    /**\n+     * Constructor\n+     */\n+    public NuvoHandler(Thing thing, NuvoStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        NuvoThingConfiguration config = getConfigAs(NuvoThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+            return;\n+        }\n+\n+        if (config.serialPort != null) {\n+            String serialPort = config.serialPort;\n+            connector = new NuvoSerialConnector(serialPortManager, serialPort);\n+        } else {\n+            connector = new NuvoIpConnector(config.host, config.port);\n+        }\n+\n+        numZones = config.numZones;\n+        activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toSet());\n+\n+        // remove the channels for the zones we are not using\n+        if (numZones < MAX_ZONES) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+            List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                    .collect(Collectors.toList());\n+\n+            zonesToRemove.forEach(zone -> {\n+                channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())));\n+            });\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (config.clockSync) {\n+            scheduleClockSyncJob();\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduleReconnectJob();\n+        schedulePollingJob();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        cancelClockSyncJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(NuvoThingActions.class);\n+    }\n+\n+    public void handleRawCommand(@Nullable String command) {\n+        try {\n+            connector.sendCommand(command.toString());\n+        } catch (NuvoException e) {\n+            logger.warn(\"Nuvo Command: {} failed\", command);\n+        }\n+    }\n+\n+    /**\n+     * Handle a command the UI\n+     *\n+     * @param channelUID the channel sending the command\n+     * @param command the command received\n+     * \n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        NuvoEnum target = NuvoEnum.valueOf(channelSplit[0].toUpperCase());\n+\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.warn(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.warn(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(target, command == OnOffType.ON ? NuvoCommand.ON : NuvoCommand.OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= 1 && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, target);\n+                                connector.sendCommand(target, NuvoCommand.SOURCE, String.valueOf(value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (MAX_VOLUME\n+                                    - (int) Math.round(\n+                                            ((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME);\n+                            logger.debug(\"Got volume command {} zone {}\", value, target);\n+                            connector.sendCommand(target, NuvoCommand.VOLUME, String.valueOf(value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(target,\n+                                    command == OnOffType.ON ? NuvoCommand.MUTE_ON : NuvoCommand.MUTE_OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_EQ && value <= MAX_EQ && value % 2 == 0) {", "originalCommit": "3301ea33fa77cf5d5579ac395fe9e94f94a58155", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkwMzQ2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r451903466", "bodyText": "The device is weird in that it only accepts even values (from -18 to 18). So this was done to along with step=2 in the channel configuration to have the binding values match the device. I noted it in the readme also.", "author": "mlobstein", "createdAt": "2020-07-09T00:54:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg0MzczNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg5Njg0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r453896846", "bodyText": "I had something like this in mind:\nif(value % 2 == 1) value++;", "author": "fwolter", "createdAt": "2020-07-13T19:58:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg0MzczNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDA4MTYzOA==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r454081638", "bodyText": "good idea, it will automatically become a compatible value.", "author": "mlobstein", "createdAt": "2020-07-14T03:46:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg0MzczNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg0NDA0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r451844041", "bodyText": "Syntactical sugar. Same for below.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        connector.sendCommand(target, NuvoCommand.DISPLINE1, \"\\\"\" + command.toString() + \"\\\"\");\n          \n          \n            \n                                        connector.sendCommand(target, NuvoCommand.DISPLINE1, \"\\\"\" + command + \"\\\"\");", "author": "fwolter", "createdAt": "2020-07-08T21:47:53Z", "path": "bundles/org.openhab.binding.nuvo/src/main/java/org/openhab/binding/nuvo/internal/handler/NuvoHandler.java", "diffHunk": "@@ -0,0 +1,776 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.nuvo.internal.handler;\n+\n+import static org.openhab.binding.nuvo.internal.NuvoBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.nuvo.internal.NuvoException;\n+import org.openhab.binding.nuvo.internal.NuvoStateDescriptionOptionProvider;\n+import org.openhab.binding.nuvo.internal.NuvoThingActions;\n+import org.openhab.binding.nuvo.internal.communication.NuvoCommand;\n+import org.openhab.binding.nuvo.internal.communication.NuvoConnector;\n+import org.openhab.binding.nuvo.internal.communication.NuvoDefaultConnector;\n+import org.openhab.binding.nuvo.internal.communication.NuvoEnum;\n+import org.openhab.binding.nuvo.internal.communication.NuvoIpConnector;\n+import org.openhab.binding.nuvo.internal.communication.NuvoMessageEvent;\n+import org.openhab.binding.nuvo.internal.communication.NuvoMessageEventListener;\n+import org.openhab.binding.nuvo.internal.communication.NuvoSerialConnector;\n+import org.openhab.binding.nuvo.internal.communication.NuvoStatusCodes;\n+import org.openhab.binding.nuvo.internal.configuration.NuvoThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link NuvoHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class NuvoHandler extends BaseThingHandler implements NuvoMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = 60;\n+    private static final long POLLING_INTERVAL = 30;\n+    private static final long CLOCK_SYNC_INTERVAL = 3600;\n+    private static final long INITIAL_POLLING_DELAY = 30;\n+    private static final long INITIAL_CLOCK_SYNC_DELAY = 10;\n+    // spec says wait 50ms, min is 100\n+    private static final long SLEEP_BETWEEN_CMD = 100;\n+    private static final Unit<Time> API_SECOND_UNIT = SmartHomeUnits.SECOND;\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String SOURCE = \"SOURCE\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String UNDEF = \"UNDEF\";\n+    private static final String GC_STR = \"NV-IG8\";\n+\n+    private static final int MAX_ZONES = 20;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 79;\n+    private static final int MIN_EQ = -18;\n+    private static final int MAX_EQ = 18;\n+\n+    private static final Pattern ZONE_PATTERN = Pattern\n+            .compile(\"^ON,SRC(\\\\d{1}),(MUTE|VOL\\\\d{1,2}),DND([0-1]),LOCK([0-1])$\");\n+    private static final Pattern DISP_PATTERN = Pattern.compile(\"^DISPLINE(\\\\d{1}),\\\"(.*)\\\"$\");\n+    private static final Pattern DISP_INFO_PATTERN = Pattern\n+            .compile(\"^DISPINFO,DUR(\\\\d{1,6}),POS(\\\\d{1,6}),STATUS(\\\\d{1,2})$\");\n+    private static final Pattern ZONE_CFG_PATTERN = Pattern.compile(\"^BASS(.*),TREB(.*),BAL(.*),LOUDCMP([0-1])$\");\n+\n+    private final Logger logger = LoggerFactory.getLogger(NuvoHandler.class);\n+    private final NuvoStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final SerialPortManager serialPortManager;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> clockSyncJob;\n+\n+    private NuvoConnector connector = new NuvoDefaultConnector();\n+    private long lastEventReceived = System.currentTimeMillis();\n+    private int numZones = 1;\n+    private String versionString = BLANK;\n+    private boolean isGConcerto = false;\n+    private Object sequenceLock = new Object();\n+\n+    Set<Integer> activeZones = new HashSet<Integer>(1);\n+\n+    // A state option list for the source labels\n+    List<StateOption> sourceLabels = new ArrayList<>();\n+\n+    /**\n+     * Constructor\n+     */\n+    public NuvoHandler(Thing thing, NuvoStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        NuvoThingConfiguration config = getConfigAs(NuvoThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+            return;\n+        }\n+\n+        if (config.serialPort != null) {\n+            String serialPort = config.serialPort;\n+            connector = new NuvoSerialConnector(serialPortManager, serialPort);\n+        } else {\n+            connector = new NuvoIpConnector(config.host, config.port);\n+        }\n+\n+        numZones = config.numZones;\n+        activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toSet());\n+\n+        // remove the channels for the zones we are not using\n+        if (numZones < MAX_ZONES) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+            List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                    .collect(Collectors.toList());\n+\n+            zonesToRemove.forEach(zone -> {\n+                channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())));\n+            });\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (config.clockSync) {\n+            scheduleClockSyncJob();\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduleReconnectJob();\n+        schedulePollingJob();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        cancelClockSyncJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(NuvoThingActions.class);\n+    }\n+\n+    public void handleRawCommand(@Nullable String command) {\n+        try {\n+            connector.sendCommand(command.toString());\n+        } catch (NuvoException e) {\n+            logger.warn(\"Nuvo Command: {} failed\", command);\n+        }\n+    }\n+\n+    /**\n+     * Handle a command the UI\n+     *\n+     * @param channelUID the channel sending the command\n+     * @param command the command received\n+     * \n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        NuvoEnum target = NuvoEnum.valueOf(channelSplit[0].toUpperCase());\n+\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.warn(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.warn(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(target, command == OnOffType.ON ? NuvoCommand.ON : NuvoCommand.OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= 1 && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, target);\n+                                connector.sendCommand(target, NuvoCommand.SOURCE, String.valueOf(value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (MAX_VOLUME\n+                                    - (int) Math.round(\n+                                            ((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME);\n+                            logger.debug(\"Got volume command {} zone {}\", value, target);\n+                            connector.sendCommand(target, NuvoCommand.VOLUME, String.valueOf(value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(target,\n+                                    command == OnOffType.ON ? NuvoCommand.MUTE_ON : NuvoCommand.MUTE_OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_EQ && value <= MAX_EQ && value % 2 == 0) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, target);\n+                                connector.sendCfgCommand(target, NuvoCommand.TREBLE, String.valueOf(value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_EQ && value <= MAX_EQ && value % 2 == 0) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, target);\n+                                connector.sendCfgCommand(target, NuvoCommand.BASS, String.valueOf(value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_EQ && value <= MAX_EQ && value % 2 == 0) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, target);\n+                                connector.sendCfgCommand(target, NuvoCommand.BALANCE,\n+                                        NuvoStatusCodes.getBalanceFromInt(value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_LOUDNESS:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCfgCommand(target, NuvoCommand.LOUDNESS,\n+                                    command == OnOffType.ON ? ONE : ZERO);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_CONTROL:\n+                        handleControlCommand(target, command);\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(target,\n+                                    command == OnOffType.ON ? NuvoCommand.DND_ON : NuvoCommand.DND_OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_PARTY:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(target,\n+                                    command == OnOffType.ON ? NuvoCommand.PARTY_ON : NuvoCommand.PARTY_OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_DISPLAY_LINE1:\n+                        if (command instanceof StringType) {\n+                            connector.sendCommand(target, NuvoCommand.DISPLINE1, \"\\\"\" + command.toString() + \"\\\"\");", "originalCommit": "3301ea33fa77cf5d5579ac395fe9e94f94a58155", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkwMTYyOA==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r451901628", "bodyText": "I got rid of all of them. thanks.", "author": "mlobstein", "createdAt": "2020-07-09T00:46:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg0NDA0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg0NTAzMg==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r451845032", "bodyText": "Syntactical sugar. Same for below.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                updateChannelState(NuvoEnum.valueOf(ZONE + zoneNum.toString()), CHANNEL_TYPE_POWER, OFF);\n          \n          \n            \n                                updateChannelState(NuvoEnum.valueOf(ZONE + zoneNum), CHANNEL_TYPE_POWER, OFF);", "author": "fwolter", "createdAt": "2020-07-08T21:50:20Z", "path": "bundles/org.openhab.binding.nuvo/src/main/java/org/openhab/binding/nuvo/internal/handler/NuvoHandler.java", "diffHunk": "@@ -0,0 +1,776 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.nuvo.internal.handler;\n+\n+import static org.openhab.binding.nuvo.internal.NuvoBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.nuvo.internal.NuvoException;\n+import org.openhab.binding.nuvo.internal.NuvoStateDescriptionOptionProvider;\n+import org.openhab.binding.nuvo.internal.NuvoThingActions;\n+import org.openhab.binding.nuvo.internal.communication.NuvoCommand;\n+import org.openhab.binding.nuvo.internal.communication.NuvoConnector;\n+import org.openhab.binding.nuvo.internal.communication.NuvoDefaultConnector;\n+import org.openhab.binding.nuvo.internal.communication.NuvoEnum;\n+import org.openhab.binding.nuvo.internal.communication.NuvoIpConnector;\n+import org.openhab.binding.nuvo.internal.communication.NuvoMessageEvent;\n+import org.openhab.binding.nuvo.internal.communication.NuvoMessageEventListener;\n+import org.openhab.binding.nuvo.internal.communication.NuvoSerialConnector;\n+import org.openhab.binding.nuvo.internal.communication.NuvoStatusCodes;\n+import org.openhab.binding.nuvo.internal.configuration.NuvoThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link NuvoHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class NuvoHandler extends BaseThingHandler implements NuvoMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = 60;\n+    private static final long POLLING_INTERVAL = 30;\n+    private static final long CLOCK_SYNC_INTERVAL = 3600;\n+    private static final long INITIAL_POLLING_DELAY = 30;\n+    private static final long INITIAL_CLOCK_SYNC_DELAY = 10;\n+    // spec says wait 50ms, min is 100\n+    private static final long SLEEP_BETWEEN_CMD = 100;\n+    private static final Unit<Time> API_SECOND_UNIT = SmartHomeUnits.SECOND;\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String SOURCE = \"SOURCE\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String UNDEF = \"UNDEF\";\n+    private static final String GC_STR = \"NV-IG8\";\n+\n+    private static final int MAX_ZONES = 20;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 79;\n+    private static final int MIN_EQ = -18;\n+    private static final int MAX_EQ = 18;\n+\n+    private static final Pattern ZONE_PATTERN = Pattern\n+            .compile(\"^ON,SRC(\\\\d{1}),(MUTE|VOL\\\\d{1,2}),DND([0-1]),LOCK([0-1])$\");\n+    private static final Pattern DISP_PATTERN = Pattern.compile(\"^DISPLINE(\\\\d{1}),\\\"(.*)\\\"$\");\n+    private static final Pattern DISP_INFO_PATTERN = Pattern\n+            .compile(\"^DISPINFO,DUR(\\\\d{1,6}),POS(\\\\d{1,6}),STATUS(\\\\d{1,2})$\");\n+    private static final Pattern ZONE_CFG_PATTERN = Pattern.compile(\"^BASS(.*),TREB(.*),BAL(.*),LOUDCMP([0-1])$\");\n+\n+    private final Logger logger = LoggerFactory.getLogger(NuvoHandler.class);\n+    private final NuvoStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final SerialPortManager serialPortManager;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> clockSyncJob;\n+\n+    private NuvoConnector connector = new NuvoDefaultConnector();\n+    private long lastEventReceived = System.currentTimeMillis();\n+    private int numZones = 1;\n+    private String versionString = BLANK;\n+    private boolean isGConcerto = false;\n+    private Object sequenceLock = new Object();\n+\n+    Set<Integer> activeZones = new HashSet<Integer>(1);\n+\n+    // A state option list for the source labels\n+    List<StateOption> sourceLabels = new ArrayList<>();\n+\n+    /**\n+     * Constructor\n+     */\n+    public NuvoHandler(Thing thing, NuvoStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        NuvoThingConfiguration config = getConfigAs(NuvoThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+            return;\n+        }\n+\n+        if (config.serialPort != null) {\n+            String serialPort = config.serialPort;\n+            connector = new NuvoSerialConnector(serialPortManager, serialPort);\n+        } else {\n+            connector = new NuvoIpConnector(config.host, config.port);\n+        }\n+\n+        numZones = config.numZones;\n+        activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toSet());\n+\n+        // remove the channels for the zones we are not using\n+        if (numZones < MAX_ZONES) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+            List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                    .collect(Collectors.toList());\n+\n+            zonesToRemove.forEach(zone -> {\n+                channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())));\n+            });\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (config.clockSync) {\n+            scheduleClockSyncJob();\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduleReconnectJob();\n+        schedulePollingJob();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        cancelClockSyncJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(NuvoThingActions.class);\n+    }\n+\n+    public void handleRawCommand(@Nullable String command) {\n+        try {\n+            connector.sendCommand(command.toString());\n+        } catch (NuvoException e) {\n+            logger.warn(\"Nuvo Command: {} failed\", command);\n+        }\n+    }\n+\n+    /**\n+     * Handle a command the UI\n+     *\n+     * @param channelUID the channel sending the command\n+     * @param command the command received\n+     * \n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        NuvoEnum target = NuvoEnum.valueOf(channelSplit[0].toUpperCase());\n+\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.warn(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.warn(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(target, command == OnOffType.ON ? NuvoCommand.ON : NuvoCommand.OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= 1 && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, target);\n+                                connector.sendCommand(target, NuvoCommand.SOURCE, String.valueOf(value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (MAX_VOLUME\n+                                    - (int) Math.round(\n+                                            ((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME);\n+                            logger.debug(\"Got volume command {} zone {}\", value, target);\n+                            connector.sendCommand(target, NuvoCommand.VOLUME, String.valueOf(value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(target,\n+                                    command == OnOffType.ON ? NuvoCommand.MUTE_ON : NuvoCommand.MUTE_OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_EQ && value <= MAX_EQ && value % 2 == 0) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, target);\n+                                connector.sendCfgCommand(target, NuvoCommand.TREBLE, String.valueOf(value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_EQ && value <= MAX_EQ && value % 2 == 0) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, target);\n+                                connector.sendCfgCommand(target, NuvoCommand.BASS, String.valueOf(value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_EQ && value <= MAX_EQ && value % 2 == 0) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, target);\n+                                connector.sendCfgCommand(target, NuvoCommand.BALANCE,\n+                                        NuvoStatusCodes.getBalanceFromInt(value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_LOUDNESS:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCfgCommand(target, NuvoCommand.LOUDNESS,\n+                                    command == OnOffType.ON ? ONE : ZERO);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_CONTROL:\n+                        handleControlCommand(target, command);\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(target,\n+                                    command == OnOffType.ON ? NuvoCommand.DND_ON : NuvoCommand.DND_OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_PARTY:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(target,\n+                                    command == OnOffType.ON ? NuvoCommand.PARTY_ON : NuvoCommand.PARTY_OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_DISPLAY_LINE1:\n+                        if (command instanceof StringType) {\n+                            connector.sendCommand(target, NuvoCommand.DISPLINE1, \"\\\"\" + command.toString() + \"\\\"\");\n+                        }\n+                        break;\n+                    case CHANNEL_DISPLAY_LINE2:\n+                        if (command instanceof StringType) {\n+                            connector.sendCommand(target, NuvoCommand.DISPLINE2, \"\\\"\" + command.toString() + \"\\\"\");\n+                        }\n+                        break;\n+                    case CHANNEL_DISPLAY_LINE3:\n+                        if (command instanceof StringType) {\n+                            connector.sendCommand(target, NuvoCommand.DISPLINE3, \"\\\"\" + command.toString() + \"\\\"\");\n+                        }\n+                        break;\n+                    case CHANNEL_DISPLAY_LINE4:\n+                        if (command instanceof StringType) {\n+                            connector.sendCommand(target, NuvoCommand.DISPLINE4, \"\\\"\" + command.toString() + \"\\\"\");\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(NuvoCommand.ALLOFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(target,\n+                                    command == OnOffType.ON ? NuvoCommand.ALLMUTE_ON : NuvoCommand.ALLMUTE_OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_PAGE:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(target,\n+                                    command == OnOffType.ON ? NuvoCommand.PAGE_ON : NuvoCommand.PAGE_OFF);\n+                        }\n+                        break;\n+                }\n+            } catch (NuvoException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the Nuvo device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (NuvoException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the Nuvo device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    /**\n+     * Handle an event received from the Nuvo device\n+     *\n+     * @param event the event to process\n+     */\n+    @Override\n+    public void onNewMessageEvent(NuvoMessageEvent evt) {\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+        lastEventReceived = System.currentTimeMillis();\n+\n+        String type = evt.getType();\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (this.getThing().getStatus() == ThingStatus.OFFLINE) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, this.versionString);\n+        }\n+\n+        switch (type) {\n+            case TYPE_VERSION:\n+                this.versionString = updateData;\n+                // Determine if we are a Grand Concerto or not\n+                if (this.versionString.contains(GC_STR)) {\n+                    this.isGConcerto = true;\n+                    connector.setEssentia(false);\n+                }\n+                break;\n+            case TYPE_ALLOFF:\n+                activeZones.forEach(zoneNum -> {\n+                    updateChannelState(NuvoEnum.valueOf(ZONE + zoneNum.toString()), CHANNEL_TYPE_POWER, OFF);", "originalCommit": "3301ea33fa77cf5d5579ac395fe9e94f94a58155", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg1MDY1OA==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r451850658", "bodyText": "Did you try this with different system timezones and configuring the timezone in PaperUI? I saw an example retrieving a zoned datetime service or so via @Reference in an openHAB binding, but I can't find it again.", "author": "fwolter", "createdAt": "2020-07-08T22:04:18Z", "path": "bundles/org.openhab.binding.nuvo/src/main/java/org/openhab/binding/nuvo/internal/handler/NuvoHandler.java", "diffHunk": "@@ -0,0 +1,776 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.nuvo.internal.handler;\n+\n+import static org.openhab.binding.nuvo.internal.NuvoBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.nuvo.internal.NuvoException;\n+import org.openhab.binding.nuvo.internal.NuvoStateDescriptionOptionProvider;\n+import org.openhab.binding.nuvo.internal.NuvoThingActions;\n+import org.openhab.binding.nuvo.internal.communication.NuvoCommand;\n+import org.openhab.binding.nuvo.internal.communication.NuvoConnector;\n+import org.openhab.binding.nuvo.internal.communication.NuvoDefaultConnector;\n+import org.openhab.binding.nuvo.internal.communication.NuvoEnum;\n+import org.openhab.binding.nuvo.internal.communication.NuvoIpConnector;\n+import org.openhab.binding.nuvo.internal.communication.NuvoMessageEvent;\n+import org.openhab.binding.nuvo.internal.communication.NuvoMessageEventListener;\n+import org.openhab.binding.nuvo.internal.communication.NuvoSerialConnector;\n+import org.openhab.binding.nuvo.internal.communication.NuvoStatusCodes;\n+import org.openhab.binding.nuvo.internal.configuration.NuvoThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link NuvoHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class NuvoHandler extends BaseThingHandler implements NuvoMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = 60;\n+    private static final long POLLING_INTERVAL = 30;\n+    private static final long CLOCK_SYNC_INTERVAL = 3600;\n+    private static final long INITIAL_POLLING_DELAY = 30;\n+    private static final long INITIAL_CLOCK_SYNC_DELAY = 10;\n+    // spec says wait 50ms, min is 100\n+    private static final long SLEEP_BETWEEN_CMD = 100;\n+    private static final Unit<Time> API_SECOND_UNIT = SmartHomeUnits.SECOND;\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String SOURCE = \"SOURCE\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String UNDEF = \"UNDEF\";\n+    private static final String GC_STR = \"NV-IG8\";\n+\n+    private static final int MAX_ZONES = 20;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 79;\n+    private static final int MIN_EQ = -18;\n+    private static final int MAX_EQ = 18;\n+\n+    private static final Pattern ZONE_PATTERN = Pattern\n+            .compile(\"^ON,SRC(\\\\d{1}),(MUTE|VOL\\\\d{1,2}),DND([0-1]),LOCK([0-1])$\");\n+    private static final Pattern DISP_PATTERN = Pattern.compile(\"^DISPLINE(\\\\d{1}),\\\"(.*)\\\"$\");\n+    private static final Pattern DISP_INFO_PATTERN = Pattern\n+            .compile(\"^DISPINFO,DUR(\\\\d{1,6}),POS(\\\\d{1,6}),STATUS(\\\\d{1,2})$\");\n+    private static final Pattern ZONE_CFG_PATTERN = Pattern.compile(\"^BASS(.*),TREB(.*),BAL(.*),LOUDCMP([0-1])$\");\n+\n+    private final Logger logger = LoggerFactory.getLogger(NuvoHandler.class);\n+    private final NuvoStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final SerialPortManager serialPortManager;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> clockSyncJob;\n+\n+    private NuvoConnector connector = new NuvoDefaultConnector();\n+    private long lastEventReceived = System.currentTimeMillis();\n+    private int numZones = 1;\n+    private String versionString = BLANK;\n+    private boolean isGConcerto = false;\n+    private Object sequenceLock = new Object();\n+\n+    Set<Integer> activeZones = new HashSet<Integer>(1);\n+\n+    // A state option list for the source labels\n+    List<StateOption> sourceLabels = new ArrayList<>();\n+\n+    /**\n+     * Constructor\n+     */\n+    public NuvoHandler(Thing thing, NuvoStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        NuvoThingConfiguration config = getConfigAs(NuvoThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+            return;\n+        }\n+\n+        if (config.serialPort != null) {\n+            String serialPort = config.serialPort;\n+            connector = new NuvoSerialConnector(serialPortManager, serialPort);\n+        } else {\n+            connector = new NuvoIpConnector(config.host, config.port);\n+        }\n+\n+        numZones = config.numZones;\n+        activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toSet());\n+\n+        // remove the channels for the zones we are not using\n+        if (numZones < MAX_ZONES) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+            List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                    .collect(Collectors.toList());\n+\n+            zonesToRemove.forEach(zone -> {\n+                channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())));\n+            });\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (config.clockSync) {\n+            scheduleClockSyncJob();\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduleReconnectJob();\n+        schedulePollingJob();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        cancelClockSyncJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(NuvoThingActions.class);\n+    }\n+\n+    public void handleRawCommand(@Nullable String command) {\n+        try {\n+            connector.sendCommand(command.toString());\n+        } catch (NuvoException e) {\n+            logger.warn(\"Nuvo Command: {} failed\", command);\n+        }\n+    }\n+\n+    /**\n+     * Handle a command the UI\n+     *\n+     * @param channelUID the channel sending the command\n+     * @param command the command received\n+     * \n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        NuvoEnum target = NuvoEnum.valueOf(channelSplit[0].toUpperCase());\n+\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.warn(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.warn(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(target, command == OnOffType.ON ? NuvoCommand.ON : NuvoCommand.OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= 1 && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, target);\n+                                connector.sendCommand(target, NuvoCommand.SOURCE, String.valueOf(value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (MAX_VOLUME\n+                                    - (int) Math.round(\n+                                            ((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME);\n+                            logger.debug(\"Got volume command {} zone {}\", value, target);\n+                            connector.sendCommand(target, NuvoCommand.VOLUME, String.valueOf(value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(target,\n+                                    command == OnOffType.ON ? NuvoCommand.MUTE_ON : NuvoCommand.MUTE_OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_EQ && value <= MAX_EQ && value % 2 == 0) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, target);\n+                                connector.sendCfgCommand(target, NuvoCommand.TREBLE, String.valueOf(value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_EQ && value <= MAX_EQ && value % 2 == 0) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, target);\n+                                connector.sendCfgCommand(target, NuvoCommand.BASS, String.valueOf(value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_EQ && value <= MAX_EQ && value % 2 == 0) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, target);\n+                                connector.sendCfgCommand(target, NuvoCommand.BALANCE,\n+                                        NuvoStatusCodes.getBalanceFromInt(value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_LOUDNESS:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCfgCommand(target, NuvoCommand.LOUDNESS,\n+                                    command == OnOffType.ON ? ONE : ZERO);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_CONTROL:\n+                        handleControlCommand(target, command);\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(target,\n+                                    command == OnOffType.ON ? NuvoCommand.DND_ON : NuvoCommand.DND_OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_PARTY:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(target,\n+                                    command == OnOffType.ON ? NuvoCommand.PARTY_ON : NuvoCommand.PARTY_OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_DISPLAY_LINE1:\n+                        if (command instanceof StringType) {\n+                            connector.sendCommand(target, NuvoCommand.DISPLINE1, \"\\\"\" + command.toString() + \"\\\"\");\n+                        }\n+                        break;\n+                    case CHANNEL_DISPLAY_LINE2:\n+                        if (command instanceof StringType) {\n+                            connector.sendCommand(target, NuvoCommand.DISPLINE2, \"\\\"\" + command.toString() + \"\\\"\");\n+                        }\n+                        break;\n+                    case CHANNEL_DISPLAY_LINE3:\n+                        if (command instanceof StringType) {\n+                            connector.sendCommand(target, NuvoCommand.DISPLINE3, \"\\\"\" + command.toString() + \"\\\"\");\n+                        }\n+                        break;\n+                    case CHANNEL_DISPLAY_LINE4:\n+                        if (command instanceof StringType) {\n+                            connector.sendCommand(target, NuvoCommand.DISPLINE4, \"\\\"\" + command.toString() + \"\\\"\");\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(NuvoCommand.ALLOFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(target,\n+                                    command == OnOffType.ON ? NuvoCommand.ALLMUTE_ON : NuvoCommand.ALLMUTE_OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_PAGE:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(target,\n+                                    command == OnOffType.ON ? NuvoCommand.PAGE_ON : NuvoCommand.PAGE_OFF);\n+                        }\n+                        break;\n+                }\n+            } catch (NuvoException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the Nuvo device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (NuvoException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the Nuvo device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    /**\n+     * Handle an event received from the Nuvo device\n+     *\n+     * @param event the event to process\n+     */\n+    @Override\n+    public void onNewMessageEvent(NuvoMessageEvent evt) {\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+        lastEventReceived = System.currentTimeMillis();\n+\n+        String type = evt.getType();\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (this.getThing().getStatus() == ThingStatus.OFFLINE) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, this.versionString);\n+        }\n+\n+        switch (type) {\n+            case TYPE_VERSION:\n+                this.versionString = updateData;\n+                // Determine if we are a Grand Concerto or not\n+                if (this.versionString.contains(GC_STR)) {\n+                    this.isGConcerto = true;\n+                    connector.setEssentia(false);\n+                }\n+                break;\n+            case TYPE_ALLOFF:\n+                activeZones.forEach(zoneNum -> {\n+                    updateChannelState(NuvoEnum.valueOf(ZONE + zoneNum.toString()), CHANNEL_TYPE_POWER, OFF);\n+                });\n+                break;\n+            case TYPE_ALLMUTE:\n+                updateChannelState(NuvoEnum.SYSTEM, CHANNEL_TYPE_ALLMUTE, ONE.equals(updateData) ? ON : OFF);\n+                activeZones.forEach(zoneNum -> {\n+                    updateChannelState(NuvoEnum.valueOf(ZONE + zoneNum.toString()), CHANNEL_TYPE_MUTE,\n+                            ONE.equals(updateData) ? ON : OFF);\n+                });\n+                break;\n+            case TYPE_PAGE:\n+                updateChannelState(NuvoEnum.SYSTEM, CHANNEL_TYPE_PAGE, ONE.equals(updateData) ? ON : OFF);\n+                break;\n+            case TYPE_SOURCE_UPDATE:\n+                logger.debug(\"Source update: Source: {} - Value: {}\", key, updateData);\n+                NuvoEnum targetSource = NuvoEnum.valueOf(SOURCE + key);\n+\n+                if (updateData.contains(DISPLINE)) {\n+                    // example: DISPLINE2,\"Play My Song (Featuring Dee Ajayi)\"\n+                    Matcher matcher = DISP_PATTERN.matcher(updateData);\n+                    if (matcher.find()) {\n+                        updateChannelState(targetSource, CHANNEL_DISPLAY_LINE + matcher.group(1), matcher.group(2));\n+                    } else {\n+                        logger.debug(\"no match on message: {}\", updateData);\n+                    }\n+                } else if (updateData.contains(DISPINFO)) {\n+                    // example: DISPINFO,DUR0,POS70,STATUS2 (DUR and POS are expressed in tenths of a second)\n+                    // 6 places(tenths of a second)-> max 999,999 /10/60/60/24 = 1.15 days\n+                    Matcher matcher = DISP_INFO_PATTERN.matcher(updateData);\n+                    if (matcher.find()) {\n+                        updateChannelState(targetSource, CHANNEL_TRACK_LENGTH, matcher.group(1));\n+                        updateChannelState(targetSource, CHANNEL_TRACK_POSITION, matcher.group(2));\n+                        updateChannelState(targetSource, CHANNEL_PLAY_MODE, matcher.group(3));\n+                    } else {\n+                        logger.debug(\"no match on message: {}\", updateData);\n+                    }\n+                } else if (updateData.contains(NAME_QUOTE) && sourceLabels.size() <= MAX_SRC) {\n+                    // example: NAME\"Ipod\"\n+                    String name = updateData.split(\"\\\"\")[1];\n+                    sourceLabels.add(new StateOption(key, name));\n+                }\n+                break;\n+            case TYPE_ZONE_UPDATE:\n+                logger.debug(\"Zone update: Zone: {} - Value: {}\", key, updateData);\n+                // example : OFF\n+                // or: ON,SRC3,VOL63,DND0,LOCK0\n+                // or: ON,SRC3,MUTE,DND0,LOCK0\n+\n+                NuvoEnum targetZone = NuvoEnum.valueOf(ZONE + key);\n+\n+                if (OFF.equals(updateData)) {\n+                    updateChannelState(targetZone, CHANNEL_TYPE_POWER, OFF);\n+                    updateChannelState(targetZone, CHANNEL_TYPE_SOURCE, UNDEF);\n+                } else {\n+                    Matcher matcher = ZONE_PATTERN.matcher(updateData);\n+                    if (matcher.find()) {\n+                        updateChannelState(targetZone, CHANNEL_TYPE_POWER, ON);\n+                        updateChannelState(targetZone, CHANNEL_TYPE_SOURCE, matcher.group(1));\n+\n+                        if (MUTE.equals(matcher.group(2))) {\n+                            updateChannelState(targetZone, CHANNEL_TYPE_MUTE, ON);\n+                        } else {\n+                            updateChannelState(targetZone, CHANNEL_TYPE_MUTE, NuvoCommand.OFF.getValue());\n+                            updateChannelState(targetZone, CHANNEL_TYPE_VOLUME, matcher.group(2).replace(VOL, BLANK));\n+                        }\n+\n+                        updateChannelState(targetZone, CHANNEL_TYPE_DND, ONE.equals(matcher.group(3)) ? ON : OFF);\n+                        updateChannelState(targetZone, CHANNEL_TYPE_LOCK, ONE.equals(matcher.group(4)) ? ON : OFF);\n+                    } else {\n+                        logger.debug(\"no match on message: {}\", updateData);\n+                    }\n+                }\n+                break;\n+            case TYPE_ZONE_BUTTON:\n+                logger.debug(\"Zone Button pressed: Source: {} - Button: {}\", key, updateData);\n+                updateChannelState(NuvoEnum.valueOf(SOURCE + key), CHANNEL_BUTTON_PRESS, updateData);\n+                break;\n+            case TYPE_ZONE_CONFIG:\n+                logger.debug(\"Zone Configuration: Zone: {} - Value: {}\", key, updateData);\n+                // example: BASS1,TREB-2,BALR2,LOUDCMP1\n+                Matcher matcher = ZONE_CFG_PATTERN.matcher(updateData);\n+                if (matcher.find()) {\n+                    updateChannelState(NuvoEnum.valueOf(ZONE + key), CHANNEL_TYPE_BASS, matcher.group(1));\n+                    updateChannelState(NuvoEnum.valueOf(ZONE + key), CHANNEL_TYPE_TREBLE, matcher.group(2));\n+                    updateChannelState(NuvoEnum.valueOf(ZONE + key), CHANNEL_TYPE_BALANCE,\n+                            NuvoStatusCodes.getBalanceFromStr(matcher.group(3)));\n+                    updateChannelState(NuvoEnum.valueOf(ZONE + key), CHANNEL_TYPE_LOUDNESS,\n+                            ONE.equals(matcher.group(4)) ? ON : OFF);\n+                } else {\n+                    logger.debug(\"no match on message: {}\", updateData);\n+                }\n+                break;\n+            default:\n+                logger.debug(\"onNewMessageEvent: unhandled key {}\", key);\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Trying to reconnect...\");\n+                closeConnection();\n+                String error = null;\n+                if (openConnection()) {\n+                    synchronized (sequenceLock) {\n+                        try {\n+                            long prevUpdateTime = lastEventReceived;\n+\n+                            connector.sendCommand(NuvoCommand.GET_CONTROLLER_VERSION);\n+\n+                            NuvoEnum.VALID_SOURCES.forEach(source -> {\n+                                try {\n+                                    connector.sendQuery(NuvoEnum.valueOf(NuvoEnum.class, source), NuvoCommand.NAME);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    connector.sendQuery(NuvoEnum.valueOf(NuvoEnum.class, source), NuvoCommand.DISPINFO);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    connector.sendQuery(NuvoEnum.valueOf(NuvoEnum.class, source), NuvoCommand.DISPLINE);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (NuvoException | InterruptedException e) {\n+                                    logger.debug(\"Error Querying Source data: {}\", e.getMessage());\n+                                }\n+                            });\n+\n+                            // Query all active zones to get their current status and eq configuration\n+                            activeZones.forEach(zoneNum -> {\n+                                try {\n+                                    connector.sendQuery(NuvoEnum.valueOf(ZONE + zoneNum), NuvoCommand.STATUS);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    connector.sendCfgCommand(NuvoEnum.valueOf(ZONE + zoneNum), NuvoCommand.EQ_QUERY,\n+                                            BLANK);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (NuvoException | InterruptedException e) {\n+                                    logger.debug(\"Error Querying Zone data: {}\", e.getMessage());\n+                                }\n+                            });\n+\n+                            // prevUpdateTime should have changed if a zone update was received\n+                            if (prevUpdateTime == lastEventReceived) {\n+                                error = \"Controller not responding to status requests\";\n+                            } else {\n+                                // Put the source labels on all active zones\n+                                activeZones.forEach(zoneNum -> {\n+                                    stateDescriptionProvider.setStateOptions(\n+                                            new ChannelUID(getThing().getUID(), ZONE.toLowerCase() + zoneNum.toString()\n+                                                    + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE),\n+                                            sourceLabels);\n+                                });\n+                            }\n+                        } catch (NuvoException e) {\n+                            error = \"First command after connection failed\";\n+                            logger.debug(\"{}: {}\", error, e.getMessage());\n+                        }\n+                    }\n+                } else {\n+                    error = \"Reconnection failed\";\n+                }\n+                if (error != null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n+                    closeConnection();\n+                } else {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, this.versionString);\n+                }\n+            }\n+        }, 1, RECON_POLLING_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the reconnection job\n+     */\n+    private void cancelReconnectJob() {\n+        ScheduledFuture<?> reconnectJob = this.reconnectJob;\n+        if (reconnectJob != null) {\n+            reconnectJob.cancel(true);\n+            this.reconnectJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Schedule the polling job\n+     */\n+    private void schedulePollingJob() {\n+        logger.debug(\"Schedule polling job\");\n+        cancelPollingJob();\n+\n+        // when the Nuvo amp is off, this will keep the connection (esp Serial over IP) alive and detect if the\n+        // connection goes down\n+        pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (connector.isConnected()) {\n+                logger.debug(\"Polling the component for updated status...\");\n+\n+                synchronized (sequenceLock) {\n+                    try {\n+                        connector.sendCommand(NuvoCommand.GET_CONTROLLER_VERSION);\n+                    } catch (NuvoException e) {\n+                        logger.debug(\"Polling error: {}\", e.getMessage());\n+                    }\n+\n+                    // if the last event received was more than 1.25 intervals ago,\n+                    // the component is not responding even though the connection is still good\n+                    if ((System.currentTimeMillis() - lastEventReceived) > (POLLING_INTERVAL * 1.25 * 1000)) {\n+                        logger.debug(\"Component not responding to status requests\");\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Component not responding to status requests\");\n+                        closeConnection();\n+                        scheduleReconnectJob();\n+                    }\n+                }\n+            }\n+        }, INITIAL_POLLING_DELAY, POLLING_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the polling job\n+     */\n+    private void cancelPollingJob() {\n+        ScheduledFuture<?> pollingJob = this.pollingJob;\n+        if (pollingJob != null) {\n+            pollingJob.cancel(true);\n+            this.pollingJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Schedule the clock sync job\n+     */\n+    private void scheduleClockSyncJob() {\n+        logger.debug(\"Schedule clock sync job\");\n+        cancelClockSyncJob();\n+        clockSyncJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (this.isGConcerto) {\n+                try {\n+                    SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy,MM,dd,HH,mm\");\n+                    connector.sendCommand(NuvoCommand.CFGTIME.getValue() + simpleDateFormat.format(new Date()));", "originalCommit": "3301ea33fa77cf5d5579ac395fe9e94f94a58155", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkwNDY1MA==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r451904650", "bodyText": "I did not. It was just intended to use whatever the system time is regardless of time zone. I think this will be fine since most users set the host system to their local time.", "author": "mlobstein", "createdAt": "2020-07-09T00:58:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg1MDY1OA=="}], "type": "inlineReview"}, {"oid": "0843b56b6ab4d91f710ca958182ed427220beb29", "url": "https://github.com/openhab/openhab-addons/commit/0843b56b6ab4d91f710ca958182ed427220beb29", "message": "review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-07-09T01:07:40Z", "type": "commit"}, {"oid": "a805ed70cb69620f43aeff74e6538eabcbcaa1f3", "url": "https://github.com/openhab/openhab-addons/commit/a805ed70cb69620f43aeff74e6538eabcbcaa1f3", "message": "more review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-07-10T01:56:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzkwNDgxNg==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r453904816", "bodyText": "The workaround for the mentioned bug should be implemented in all bindings, since there will be no update within the OH2.5 branch. See #8116", "author": "fwolter", "createdAt": "2020-07-13T20:14:12Z", "path": "bundles/org.openhab.binding.nuvo/src/main/java/org/openhab/binding/nuvo/internal/NuvoThingActions.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.nuvo.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.binding.nuvo.internal.handler.NuvoHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Some automation actions to be used with a {@link NuvoThingActions}\n+ *\n+ * @author Michael Lobstein - initial contribution\n+ *\n+ */\n+@ThingActionsScope(name = \"nuvo\")\n+@NonNullByDefault\n+public class NuvoThingActions implements ThingActions {", "originalCommit": "a805ed70cb69620f43aeff74e6538eabcbcaa1f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDA4MTc0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r454081746", "bodyText": "I added the work around.", "author": "mlobstein", "createdAt": "2020-07-14T03:47:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzkwNDgxNg=="}], "type": "inlineReview"}, {"oid": "e8f60bf86d7348daf7582a76f276207f2ec675d6", "url": "https://github.com/openhab/openhab-addons/commit/e8f60bf86d7348daf7582a76f276207f2ec675d6", "message": "more review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-07-14T03:44:51Z", "type": "commit"}, {"oid": "b3285d67faf4f4c6261dd86e7bc1b3ce855a07b0", "url": "https://github.com/openhab/openhab-addons/commit/b3285d67faf4f4c6261dd86e7bc1b3ce855a07b0", "message": "Merge pull request #6 from openhab/2.5.x\n\nupdate fork", "committedDate": "2020-07-16T21:38:23Z", "type": "commit"}, {"oid": "f0d23a4e0ca88eb897516b11e0d2056c0396a594", "url": "https://github.com/openhab/openhab-addons/commit/f0d23a4e0ca88eb897516b11e0d2056c0396a594", "message": "[nuvo] fix issue with thing actions\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-07-16T23:11:57Z", "type": "commit"}, {"oid": "c1dc05926217c0a0e69c4b02509c9af54d98fba7", "url": "https://github.com/openhab/openhab-addons/commit/c1dc05926217c0a0e69c4b02509c9af54d98fba7", "message": "[nuvo] Workaround for thing actions bug\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-07-17T22:02:48Z", "type": "commit"}, {"oid": "9b579193ad576302dc462c6574b4890746be2025", "url": "https://github.com/openhab/openhab-addons/commit/9b579193ad576302dc462c6574b4890746be2025", "message": "Merge pull request #7 from openhab/2.5.x\n\nupdate fork", "committedDate": "2020-07-25T03:38:33Z", "type": "commit"}, {"oid": "78f69778930aba426a203feec98c17aee188a536", "url": "https://github.com/openhab/openhab-addons/commit/78f69778930aba426a203feec98c17aee188a536", "message": "Merge pull request #8 from openhab/2.5.x\n\nupdate fork", "committedDate": "2020-07-28T15:24:48Z", "type": "commit"}, {"oid": "dfc04f8ad4aa9f7cdb170bae154cf3bd4b290bb9", "url": "https://github.com/openhab/openhab-addons/commit/dfc04f8ad4aa9f7cdb170bae154cf3bd4b290bb9", "message": "Merge branch '2.5.x' into NuvoAudio", "committedDate": "2020-07-29T14:43:22Z", "type": "commit"}, {"oid": "0d33ea2cc313fb1512bbeab6802f5d89ae0eb751", "url": "https://github.com/openhab/openhab-addons/commit/0d33ea2cc313fb1512bbeab6802f5d89ae0eb751", "message": "update version and review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-07-29T14:47:56Z", "type": "commit"}, {"oid": "5117f7437ea6e07577cd8f3f3f0579dafb450a1f", "url": "https://github.com/openhab/openhab-addons/commit/5117f7437ea6e07577cd8f3f3f0579dafb450a1f", "message": "documentation fixes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-08-14T18:53:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTYyNDkxMA==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r461624910", "bodyText": "Either this comment is incorrect or the code: it states left is -, while in the code below left is handled as +.", "author": "Hilbrand", "createdAt": "2020-07-28T14:27:40Z", "path": "bundles/org.openhab.binding.nuvo/src/main/java/org/openhab/binding/nuvo/internal/communication/NuvoStatusCodes.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.nuvo.internal.communication;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Provides mapping of various Nuvo status codes to plain language meanings\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class NuvoStatusCodes {\n+    private static final String L = \"L\";\n+    private static final String C = \"C\";\n+    private static final String R = \"R\";\n+    private static final String DASH = \"-\";\n+    private static final String ZERO = \"0\";\n+\n+    // map to lookup play mode\n+    public static final Map<String, String> PLAY_MODE = new HashMap<>();\n+    static {\n+        PLAY_MODE.put(\"0\", \"Normal\");\n+        PLAY_MODE.put(\"1\", \"Idle\");\n+        PLAY_MODE.put(\"2\", \"Playing\");\n+        PLAY_MODE.put(\"3\", \"Paused\");\n+        PLAY_MODE.put(\"4\", \"Fast Forward\");\n+        PLAY_MODE.put(\"5\", \"Rewind\");\n+        PLAY_MODE.put(\"6\", \"Play Shuffle\");\n+        PLAY_MODE.put(\"7\", \"Play Repeat\");\n+        PLAY_MODE.put(\"8\", \"Play Shuffle Repeat\");\n+        PLAY_MODE.put(\"9\", \"unknown-9\");\n+        PLAY_MODE.put(\"10\", \"unknown-10\");\n+        PLAY_MODE.put(\"11\", \"Radio\"); // undocumented\n+        PLAY_MODE.put(\"12\", \"unknown-12\");\n+    }\n+\n+    /*\n+     * This looks broken because the controller is seriously broken...\n+     * On the keypad when adjusting the balance to \"Left 18\", the serial data reports R18 \u00af\\_(\u30c4)_/\u00af\n+     * So on top of the weird translation, the value needs to be reversed by the binding\n+     * to ensure that it will match what is displayed on the keypad.\n+     * For display purposes we want -18 to be full left, 0 = center, and +18 to be full right", "originalCommit": "c1dc05926217c0a0e69c4b02509c9af54d98fba7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTAxNjkyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r475016921", "bodyText": "Yes it is confusing, the controller takes (and reports) string values (L[2-18], C, or R[2-18]... So the goal here is to convert those string values into the integer range of -18 to 18 for openhab to use. To make it more confusing, the values reported in the serial api are backwards from what is displayed on the keypads, so everything had to be inverted. But I tested it thoroughly and it works well.", "author": "mlobstein", "createdAt": "2020-08-22T00:08:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTYyNDkxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTYyNjI4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r461626283", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return (L + (value * -1));\n          \n          \n            \n                        return (L + Math.abs(value));", "author": "Hilbrand", "createdAt": "2020-07-28T14:29:24Z", "path": "bundles/org.openhab.binding.nuvo/src/main/java/org/openhab/binding/nuvo/internal/communication/NuvoStatusCodes.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.nuvo.internal.communication;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Provides mapping of various Nuvo status codes to plain language meanings\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class NuvoStatusCodes {\n+    private static final String L = \"L\";\n+    private static final String C = \"C\";\n+    private static final String R = \"R\";\n+    private static final String DASH = \"-\";\n+    private static final String ZERO = \"0\";\n+\n+    // map to lookup play mode\n+    public static final Map<String, String> PLAY_MODE = new HashMap<>();\n+    static {\n+        PLAY_MODE.put(\"0\", \"Normal\");\n+        PLAY_MODE.put(\"1\", \"Idle\");\n+        PLAY_MODE.put(\"2\", \"Playing\");\n+        PLAY_MODE.put(\"3\", \"Paused\");\n+        PLAY_MODE.put(\"4\", \"Fast Forward\");\n+        PLAY_MODE.put(\"5\", \"Rewind\");\n+        PLAY_MODE.put(\"6\", \"Play Shuffle\");\n+        PLAY_MODE.put(\"7\", \"Play Repeat\");\n+        PLAY_MODE.put(\"8\", \"Play Shuffle Repeat\");\n+        PLAY_MODE.put(\"9\", \"unknown-9\");\n+        PLAY_MODE.put(\"10\", \"unknown-10\");\n+        PLAY_MODE.put(\"11\", \"Radio\"); // undocumented\n+        PLAY_MODE.put(\"12\", \"unknown-12\");\n+    }\n+\n+    /*\n+     * This looks broken because the controller is seriously broken...\n+     * On the keypad when adjusting the balance to \"Left 18\", the serial data reports R18 \u00af\\_(\u30c4)_/\u00af\n+     * So on top of the weird translation, the value needs to be reversed by the binding\n+     * to ensure that it will match what is displayed on the keypad.\n+     * For display purposes we want -18 to be full left, 0 = center, and +18 to be full right\n+     */\n+    public static String getBalanceFromStr(String value) {\n+        // example L2; return 2 | C; return 0 | R10; return -10\n+        if (value.substring(0, 1).equals(L)) {\n+            return (value.substring(1));\n+        } else if (value.equals(C)) {\n+            return ZERO;\n+        } else if (value.substring(0, 1).equals(R)) {\n+            return (DASH + value.substring(1));\n+        }\n+        return ZERO;\n+    }\n+\n+    // see above comment\n+    public static String getBalanceFromInt(Integer value) {\n+        if (value < 0) {\n+            return (L + (value * -1));", "originalCommit": "c1dc05926217c0a0e69c4b02509c9af54d98fba7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTYzNDE4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r461634186", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private String value;\n          \n          \n            \n                private final String value;", "author": "Hilbrand", "createdAt": "2020-07-28T14:39:04Z", "path": "bundles/org.openhab.binding.nuvo/src/main/java/org/openhab/binding/nuvo/internal/communication/NuvoCommand.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.nuvo.internal.communication;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Represents the different kinds of commands\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public enum NuvoCommand {\n+    GET_CONTROLLER_VERSION(\"VER\"),\n+    ALLMUTE_ON(\"MUTE1\"),\n+    ALLMUTE_OFF(\"MUTE0\"),\n+    ALLOFF(\"ALLOFF\"),\n+    PAGE_ON(\"PAGE1\"),\n+    PAGE_OFF(\"PAGE0\"),\n+    CFGTIME(\"CFGTIME\"),\n+    STATUS(\"STATUS\"),\n+    EQ_QUERY(\"EQ?\"),\n+    DISPINFO(\"DISPINFO\"),\n+    DISPLINE(\"DISPLINE\"),\n+    DISPLINE1(\"DISPLINE1\"),\n+    DISPLINE2(\"DISPLINE2\"),\n+    DISPLINE3(\"DISPLINE3\"),\n+    DISPLINE4(\"DISPLINE4\"),\n+    NAME(\"NAME\"),\n+    ON(\"ON\"),\n+    OFF(\"OFF\"),\n+    SOURCE(\"SRC\"),\n+    VOLUME(\"VOL\"),\n+    MUTE_ON(\"MUTEON\"),\n+    MUTE_OFF(\"MUTEOFF\"),\n+    TREBLE(\"TREB\"),\n+    BASS(\"BASS\"),\n+    BALANCE(\"BAL\"),\n+    LOUDNESS(\"LOUDCMP\"),\n+    PLAYPAUSE(\"PLAYPAUSE\"),\n+    PREV(\"PREV\"),\n+    NEXT(\"NEXT\"),\n+    DND_ON(\"DNDON\"),\n+    DND_OFF(\"DNDOFF\"),\n+    PARTY_ON(\"PARTY1\"),\n+    PARTY_OFF(\"PARTY0\");\n+\n+    private String value;", "originalCommit": "c1dc05926217c0a0e69c4b02509c9af54d98fba7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTYzNTc2NA==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r461635764", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private String id;\n          \n          \n            \n                private String cfgId;\n          \n          \n            \n                private final String id;\n          \n          \n            \n                private final String cfgId;", "author": "Hilbrand", "createdAt": "2020-07-28T14:40:58Z", "path": "bundles/org.openhab.binding.nuvo/src/main/java/org/openhab/binding/nuvo/internal/communication/NuvoEnum.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.nuvo.internal.communication;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Represents the different internal zone and source IDs of the Nuvo Whole House Amplifier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public enum NuvoEnum {\n+    SYSTEM(\"SYSTEM\", \"SYSTEM\"),\n+    ZONE1(\"Z1\", \"ZCFG1\"),\n+    ZONE2(\"Z2\", \"ZCFG2\"),\n+    ZONE3(\"Z3\", \"ZCFG3\"),\n+    ZONE4(\"Z4\", \"ZCFG4\"),\n+    ZONE5(\"Z5\", \"ZCFG5\"),\n+    ZONE6(\"Z6\", \"ZCFG6\"),\n+    ZONE7(\"Z7\", \"ZCFG7\"),\n+    ZONE8(\"Z8\", \"ZCFG8\"),\n+    ZONE9(\"Z9\", \"ZCFG9\"),\n+    ZONE10(\"Z10\", \"ZCFG10\"),\n+    ZONE11(\"Z11\", \"ZCFG11\"),\n+    ZONE12(\"Z12\", \"ZCFG12\"),\n+    ZONE13(\"Z13\", \"ZCFG13\"),\n+    ZONE14(\"Z14\", \"ZCFG14\"),\n+    ZONE15(\"Z15\", \"ZCFG15\"),\n+    ZONE16(\"Z16\", \"ZCFG16\"),\n+    ZONE17(\"Z17\", \"ZCFG17\"),\n+    ZONE18(\"Z18\", \"ZCFG18\"),\n+    ZONE19(\"Z19\", \"ZCFG19\"),\n+    ZONE20(\"Z20\", \"ZCFG20\"),\n+    SOURCE1(\"S1\", \"SCFG1\"),\n+    SOURCE2(\"S2\", \"SCFG2\"),\n+    SOURCE3(\"S3\", \"SCFG3\"),\n+    SOURCE4(\"S4\", \"SCFG4\"),\n+    SOURCE5(\"S5\", \"SCFG5\"),\n+    SOURCE6(\"S6\", \"SCFG6\");\n+\n+    private String id;\n+    private String cfgId;", "originalCommit": "c1dc05926217c0a0e69c4b02509c9af54d98fba7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTYzOTYxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r461639615", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final List<String> VALID_SOURCES = Arrays.stream(values()).filter(s -> s.name().contains(\"SOURCE\"))\n          \n          \n            \n                        .map(s -> s.name()).collect(Collectors.toList());\n          \n          \n            \n                public static final List<String> VALID_SOURCES = Arrays.stream(values()).map(NuvoEnum::name).filter(s -> s.contains(\"SOURCE\"))\n          \n          \n            \n                        .collect(Collectors.toList());", "author": "Hilbrand", "createdAt": "2020-07-28T14:45:35Z", "path": "bundles/org.openhab.binding.nuvo/src/main/java/org/openhab/binding/nuvo/internal/communication/NuvoEnum.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.nuvo.internal.communication;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Represents the different internal zone and source IDs of the Nuvo Whole House Amplifier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public enum NuvoEnum {\n+    SYSTEM(\"SYSTEM\", \"SYSTEM\"),\n+    ZONE1(\"Z1\", \"ZCFG1\"),\n+    ZONE2(\"Z2\", \"ZCFG2\"),\n+    ZONE3(\"Z3\", \"ZCFG3\"),\n+    ZONE4(\"Z4\", \"ZCFG4\"),\n+    ZONE5(\"Z5\", \"ZCFG5\"),\n+    ZONE6(\"Z6\", \"ZCFG6\"),\n+    ZONE7(\"Z7\", \"ZCFG7\"),\n+    ZONE8(\"Z8\", \"ZCFG8\"),\n+    ZONE9(\"Z9\", \"ZCFG9\"),\n+    ZONE10(\"Z10\", \"ZCFG10\"),\n+    ZONE11(\"Z11\", \"ZCFG11\"),\n+    ZONE12(\"Z12\", \"ZCFG12\"),\n+    ZONE13(\"Z13\", \"ZCFG13\"),\n+    ZONE14(\"Z14\", \"ZCFG14\"),\n+    ZONE15(\"Z15\", \"ZCFG15\"),\n+    ZONE16(\"Z16\", \"ZCFG16\"),\n+    ZONE17(\"Z17\", \"ZCFG17\"),\n+    ZONE18(\"Z18\", \"ZCFG18\"),\n+    ZONE19(\"Z19\", \"ZCFG19\"),\n+    ZONE20(\"Z20\", \"ZCFG20\"),\n+    SOURCE1(\"S1\", \"SCFG1\"),\n+    SOURCE2(\"S2\", \"SCFG2\"),\n+    SOURCE3(\"S3\", \"SCFG3\"),\n+    SOURCE4(\"S4\", \"SCFG4\"),\n+    SOURCE5(\"S5\", \"SCFG5\"),\n+    SOURCE6(\"S6\", \"SCFG6\");\n+\n+    private String id;\n+    private String cfgId;\n+\n+    // make a list of all valid source ids\n+    public static final List<String> VALID_SOURCES = Arrays.stream(values()).filter(s -> s.name().contains(\"SOURCE\"))\n+            .map(s -> s.name()).collect(Collectors.toList());", "originalCommit": "c1dc05926217c0a0e69c4b02509c9af54d98fba7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTY0MDg0NA==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r461640844", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private String type;\n          \n          \n            \n                private String key;\n          \n          \n            \n                private String value;\n          \n          \n            \n                private final String type;\n          \n          \n            \n                private final String key;\n          \n          \n            \n                private final String value;", "author": "Hilbrand", "createdAt": "2020-07-28T14:47:01Z", "path": "bundles/org.openhab.binding.nuvo/src/main/java/org/openhab/binding/nuvo/internal/communication/NuvoMessageEvent.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.nuvo.internal.communication;\n+\n+import java.util.EventObject;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * NuvoMessageEvent event used to notify changes coming from messages received from the Nuvo device\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class NuvoMessageEvent extends EventObject {\n+    private static final long serialVersionUID = 1L;\n+    private String type;\n+    private String key;\n+    private String value;", "originalCommit": "c1dc05926217c0a0e69c4b02509c9af54d98fba7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY1MzY1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r474653651", "bodyText": "This should probably be done before the join. Because if the join does wait and in between a new thread is set it will be set to null here. This might be theoretically now as that flow never can happen (I didn't check the flow), but if the code would change it might become possible in the future.", "author": "Hilbrand", "createdAt": "2020-08-21T12:03:11Z", "path": "bundles/org.openhab.binding.nuvo/src/main/java/org/openhab/binding/nuvo/internal/communication/NuvoConnector.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.nuvo.internal.communication;\n+\n+import static org.openhab.binding.nuvo.internal.NuvoBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.nuvo.internal.NuvoException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the Nuvo device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the Nuvo binding\n+ */\n+@NonNullByDefault\n+public abstract class NuvoConnector {\n+    private static final String COMMAND_OK = \"#OK\";\n+    private static final String BEGIN_CMD = \"*\";\n+    private static final String END_CMD = \"\\r\";\n+    private static final String QUERY = \"?\";\n+    private static final String VER_STR = \"#VER\\\"NV-\";\n+    private static final String ALL_OFF = \"#ALLOFF\";\n+    private static final String MUTE = \"#MUTE\";\n+    private static final String PAGE = \"#PAGE\";\n+\n+    private static final byte[] WAKE_STR = \"\\r\".getBytes(StandardCharsets.US_ASCII);\n+\n+    private static final Pattern SRC_PATTERN = Pattern.compile(\"^#S(\\\\d{1})(.*)$\");\n+    private static final Pattern ZONE_PATTERN = Pattern.compile(\"^#Z(\\\\d{1,2}),(.*)$\");\n+    private static final Pattern ZONE_BUTTON_PATTERN = Pattern.compile(\"^#Z(\\\\d{1,2})S(\\\\d{1})(.*)$\");\n+    private static final Pattern ZONE_CFG_PATTERN = Pattern.compile(\"^#ZCFG(\\\\d{1,2}),(.*)$\");\n+\n+    private final Logger logger = LoggerFactory.getLogger(NuvoConnector.class);\n+\n+    protected static final String COMMAND_ERROR = \"#?\";\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<NuvoMessageEventListener> listeners = new ArrayList<>();\n+\n+    private boolean isEssentia = true;\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Tell the connector if the device is an Essentia G or not\n+     *\n+     * @param true if the device is an Essentia G\n+     */\n+    public void setEssentia(boolean isEssentia) {\n+        this.isEssentia = isEssentia;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the Nuvo device\n+     *\n+     * @throws NuvoException - In case of any problem\n+     */\n+    public abstract void open() throws NuvoException;\n+\n+    /**\n+     * Close the connection with the Nuvo device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut != null) {\n+            try {\n+                dataOut.close();\n+            } catch (IOException e) {\n+                logger.debug(\"Error closing dataOut: {}\", e.getMessage());\n+            }\n+            this.dataOut = null;\n+        }\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn != null) {\n+            try {\n+                dataIn.close();\n+            } catch (IOException e) {\n+                logger.debug(\"Error closing dataIn: {}\", e.getMessage());\n+            }\n+            this.dataIn = null;\n+        }\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join(3000);\n+            } catch (InterruptedException e) {\n+                logger.warn(\"Error joining readerThread: {}\", e.getMessage());\n+            }\n+            this.readerThread = null;", "originalCommit": "5117f7437ea6e07577cd8f3f3f0579dafb450a1f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTAxODc4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r475018789", "bodyText": "fixed", "author": "mlobstein", "createdAt": "2020-08-22T00:15:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY1MzY1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY1NTUzOA==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r474655538", "bodyText": "Can you change this to:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    super(NuvoBindingConstants.BINDING_ID + \"-\" + uid);\n          \n          \n            \n                    super(\"OH-binding-\" + NuvoBindingConstants.BINDING_ID + \"-\" + uid);", "author": "Hilbrand", "createdAt": "2020-08-21T12:07:32Z", "path": "bundles/org.openhab.binding.nuvo/src/main/java/org/openhab/binding/nuvo/internal/communication/NuvoReaderThread.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.nuvo.internal.communication;\n+\n+import java.util.Arrays;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.nuvo.internal.NuvoBindingConstants;\n+import org.openhab.binding.nuvo.internal.NuvoException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A class that reads messages from the Nuvo device in a dedicated thread\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the Nuvo binding\n+ */\n+@NonNullByDefault\n+public class NuvoReaderThread extends Thread {\n+\n+    private final Logger logger = LoggerFactory.getLogger(NuvoReaderThread.class);\n+\n+    private static final int READ_BUFFER_SIZE = 16;\n+    private static final int SIZE = 256;\n+\n+    private static final char TERM_CHAR = '\\r';\n+\n+    private NuvoConnector connector;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param connector the object that should handle the received message\n+     */\n+    public NuvoReaderThread(NuvoConnector connector, String uid) {\n+        super(NuvoBindingConstants.BINDING_ID + \"-\" + uid);", "originalCommit": "5117f7437ea6e07577cd8f3f3f0579dafb450a1f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTAxODgyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r475018825", "bodyText": "done", "author": "mlobstein", "createdAt": "2020-08-22T00:15:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY1NTUzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY2Mjg0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r474662845", "bodyText": "simpleDateFormat can be a static final constant in the class?", "author": "Hilbrand", "createdAt": "2020-08-21T12:23:46Z", "path": "bundles/org.openhab.binding.nuvo/src/main/java/org/openhab/binding/nuvo/internal/handler/NuvoHandler.java", "diffHunk": "@@ -0,0 +1,793 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.nuvo.internal.handler;\n+\n+import static org.openhab.binding.nuvo.internal.NuvoBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.nuvo.internal.NuvoException;\n+import org.openhab.binding.nuvo.internal.NuvoStateDescriptionOptionProvider;\n+import org.openhab.binding.nuvo.internal.NuvoThingActions;\n+import org.openhab.binding.nuvo.internal.communication.NuvoCommand;\n+import org.openhab.binding.nuvo.internal.communication.NuvoConnector;\n+import org.openhab.binding.nuvo.internal.communication.NuvoDefaultConnector;\n+import org.openhab.binding.nuvo.internal.communication.NuvoEnum;\n+import org.openhab.binding.nuvo.internal.communication.NuvoIpConnector;\n+import org.openhab.binding.nuvo.internal.communication.NuvoMessageEvent;\n+import org.openhab.binding.nuvo.internal.communication.NuvoMessageEventListener;\n+import org.openhab.binding.nuvo.internal.communication.NuvoSerialConnector;\n+import org.openhab.binding.nuvo.internal.communication.NuvoStatusCodes;\n+import org.openhab.binding.nuvo.internal.configuration.NuvoThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link NuvoHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class NuvoHandler extends BaseThingHandler implements NuvoMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL_SEC = 60;\n+    private static final long POLLING_INTERVAL_SEC = 30;\n+    private static final long CLOCK_SYNC_INTERVAL_SEC = 3600;\n+    private static final long INITIAL_POLLING_DELAY_SEC = 30;\n+    private static final long INITIAL_CLOCK_SYNC_DELAY_SEC = 10;\n+    // spec says wait 50ms, min is 100\n+    private static final long SLEEP_BETWEEN_CMD_MS = 100;\n+    private static final Unit<Time> API_SECOND_UNIT = SmartHomeUnits.SECOND;\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String SOURCE = \"SOURCE\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String UNDEF = \"UNDEF\";\n+    private static final String GC_STR = \"NV-IG8\";\n+\n+    private static final int MAX_ZONES = 20;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 79;\n+    private static final int MIN_EQ = -18;\n+    private static final int MAX_EQ = 18;\n+\n+    private static final Pattern ZONE_PATTERN = Pattern\n+            .compile(\"^ON,SRC(\\\\d{1}),(MUTE|VOL\\\\d{1,2}),DND([0-1]),LOCK([0-1])$\");\n+    private static final Pattern DISP_PATTERN = Pattern.compile(\"^DISPLINE(\\\\d{1}),\\\"(.*)\\\"$\");\n+    private static final Pattern DISP_INFO_PATTERN = Pattern\n+            .compile(\"^DISPINFO,DUR(\\\\d{1,6}),POS(\\\\d{1,6}),STATUS(\\\\d{1,2})$\");\n+    private static final Pattern ZONE_CFG_PATTERN = Pattern.compile(\"^BASS(.*),TREB(.*),BAL(.*),LOUDCMP([0-1])$\");\n+\n+    private final Logger logger = LoggerFactory.getLogger(NuvoHandler.class);\n+    private final NuvoStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final SerialPortManager serialPortManager;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> clockSyncJob;\n+\n+    private NuvoConnector connector = new NuvoDefaultConnector();\n+    private long lastEventReceived = System.currentTimeMillis();\n+    private int numZones = 1;\n+    private String versionString = BLANK;\n+    private boolean isGConcerto = false;\n+    private Object sequenceLock = new Object();\n+\n+    Set<Integer> activeZones = new HashSet<>(1);\n+\n+    // A state option list for the source labels\n+    List<StateOption> sourceLabels = new ArrayList<>();\n+\n+    /**\n+     * Constructor\n+     */\n+    public NuvoHandler(Thing thing, NuvoStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        NuvoThingConfiguration config = getConfigAs(NuvoThingConfiguration.class);\n+        String serialPort = config.serialPort;\n+        String host = config.host;\n+        Integer port = config.port;\n+        Integer numZones = config.numZones;\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((serialPort == null || serialPort.isEmpty()) && (host == null || host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (serialPort != null && (host == null || host.isEmpty())) {\n+            if (serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+            return;\n+        }\n+\n+        if (serialPort != null) {\n+            connector = new NuvoSerialConnector(serialPortManager, serialPort);\n+        } else if (port != null) {\n+            connector = new NuvoIpConnector(host, port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Either Serial port or Host & Port must be specifed\");\n+            return;\n+        }\n+\n+        if (numZones != null) {\n+            this.numZones = numZones;\n+        }\n+\n+        activeZones = IntStream.range((1), (this.numZones + 1)).boxed().collect(Collectors.toSet());\n+\n+        // remove the channels for the zones we are not using\n+        if (this.numZones < MAX_ZONES) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+            List<Integer> zonesToRemove = IntStream.range((this.numZones + 1), (MAX_ZONES + 1)).boxed()\n+                    .collect(Collectors.toList());\n+\n+            zonesToRemove.forEach(zone -> {\n+                channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone)));\n+            });\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        if (config.clockSync) {\n+            scheduleClockSyncJob();\n+        }\n+\n+        scheduleReconnectJob();\n+        schedulePollingJob();\n+        updateStatus(ThingStatus.UNKNOWN);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        cancelClockSyncJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(NuvoThingActions.class);\n+    }\n+\n+    public void handleRawCommand(@Nullable String command) {\n+        synchronized (sequenceLock) {\n+            try {\n+                connector.sendCommand(command);\n+            } catch (NuvoException e) {\n+                logger.warn(\"Nuvo Command: {} failed\", command);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handle a command the UI\n+     *\n+     * @param channelUID the channel sending the command\n+     * @param command the command received\n+     * \n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        NuvoEnum target = NuvoEnum.valueOf(channelSplit[0].toUpperCase());\n+\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.warn(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(target, command == OnOffType.ON ? NuvoCommand.ON : NuvoCommand.OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= 1 && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, target);\n+                                connector.sendCommand(target, NuvoCommand.SOURCE, String.valueOf(value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (MAX_VOLUME\n+                                    - (int) Math.round(\n+                                            ((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME);\n+                            logger.debug(\"Got volume command {} zone {}\", value, target);\n+                            connector.sendCommand(target, NuvoCommand.VOLUME, String.valueOf(value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(target,\n+                                    command == OnOffType.ON ? NuvoCommand.MUTE_ON : NuvoCommand.MUTE_OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_EQ && value <= MAX_EQ) {\n+                                // device can only accept even values\n+                                if (value % 2 == 1)\n+                                    value++;\n+                                logger.debug(\"Got treble command {} zone {}\", value, target);\n+                                connector.sendCfgCommand(target, NuvoCommand.TREBLE, String.valueOf(value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_EQ && value <= MAX_EQ) {\n+                                if (value % 2 == 1)\n+                                    value++;\n+                                logger.debug(\"Got bass command {} zone {}\", value, target);\n+                                connector.sendCfgCommand(target, NuvoCommand.BASS, String.valueOf(value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_EQ && value <= MAX_EQ) {\n+                                if (value % 2 == 1)\n+                                    value++;\n+                                logger.debug(\"Got balance command {} zone {}\", value, target);\n+                                connector.sendCfgCommand(target, NuvoCommand.BALANCE,\n+                                        NuvoStatusCodes.getBalanceFromInt(value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_LOUDNESS:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCfgCommand(target, NuvoCommand.LOUDNESS,\n+                                    command == OnOffType.ON ? ONE : ZERO);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_CONTROL:\n+                        handleControlCommand(target, command);\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(target,\n+                                    command == OnOffType.ON ? NuvoCommand.DND_ON : NuvoCommand.DND_OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_PARTY:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(target,\n+                                    command == OnOffType.ON ? NuvoCommand.PARTY_ON : NuvoCommand.PARTY_OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_DISPLAY_LINE1:\n+                        if (command instanceof StringType) {\n+                            connector.sendCommand(target, NuvoCommand.DISPLINE1, \"\\\"\" + command + \"\\\"\");\n+                        }\n+                        break;\n+                    case CHANNEL_DISPLAY_LINE2:\n+                        if (command instanceof StringType) {\n+                            connector.sendCommand(target, NuvoCommand.DISPLINE2, \"\\\"\" + command + \"\\\"\");\n+                        }\n+                        break;\n+                    case CHANNEL_DISPLAY_LINE3:\n+                        if (command instanceof StringType) {\n+                            connector.sendCommand(target, NuvoCommand.DISPLINE3, \"\\\"\" + command + \"\\\"\");\n+                        }\n+                        break;\n+                    case CHANNEL_DISPLAY_LINE4:\n+                        if (command instanceof StringType) {\n+                            connector.sendCommand(target, NuvoCommand.DISPLINE4, \"\\\"\" + command + \"\\\"\");\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(NuvoCommand.ALLOFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(target,\n+                                    command == OnOffType.ON ? NuvoCommand.ALLMUTE_ON : NuvoCommand.ALLMUTE_OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_PAGE:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(target,\n+                                    command == OnOffType.ON ? NuvoCommand.PAGE_ON : NuvoCommand.PAGE_OFF);\n+                        }\n+                        break;\n+                }\n+            } catch (NuvoException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the Nuvo device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (NuvoException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the Nuvo device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    /**\n+     * Handle an event received from the Nuvo device\n+     *\n+     * @param event the event to process\n+     */\n+    @Override\n+    public void onNewMessageEvent(NuvoMessageEvent evt) {\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+        lastEventReceived = System.currentTimeMillis();\n+\n+        String type = evt.getType();\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (this.getThing().getStatus() == ThingStatus.OFFLINE) {\n+            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, this.versionString);\n+        }\n+\n+        switch (type) {\n+            case TYPE_VERSION:\n+                this.versionString = updateData;\n+                // Determine if we are a Grand Concerto or not\n+                if (this.versionString.contains(GC_STR)) {\n+                    this.isGConcerto = true;\n+                    connector.setEssentia(false);\n+                }\n+                break;\n+            case TYPE_ALLOFF:\n+                activeZones.forEach(zoneNum -> {\n+                    updateChannelState(NuvoEnum.valueOf(ZONE + zoneNum), CHANNEL_TYPE_POWER, OFF);\n+                });\n+                break;\n+            case TYPE_ALLMUTE:\n+                updateChannelState(NuvoEnum.SYSTEM, CHANNEL_TYPE_ALLMUTE, ONE.equals(updateData) ? ON : OFF);\n+                activeZones.forEach(zoneNum -> {\n+                    updateChannelState(NuvoEnum.valueOf(ZONE + zoneNum), CHANNEL_TYPE_MUTE,\n+                            ONE.equals(updateData) ? ON : OFF);\n+                });\n+                break;\n+            case TYPE_PAGE:\n+                updateChannelState(NuvoEnum.SYSTEM, CHANNEL_TYPE_PAGE, ONE.equals(updateData) ? ON : OFF);\n+                break;\n+            case TYPE_SOURCE_UPDATE:\n+                logger.debug(\"Source update: Source: {} - Value: {}\", key, updateData);\n+                NuvoEnum targetSource = NuvoEnum.valueOf(SOURCE + key);\n+\n+                if (updateData.contains(DISPLINE)) {\n+                    // example: DISPLINE2,\"Play My Song (Featuring Dee Ajayi)\"\n+                    Matcher matcher = DISP_PATTERN.matcher(updateData);\n+                    if (matcher.find()) {\n+                        updateChannelState(targetSource, CHANNEL_DISPLAY_LINE + matcher.group(1), matcher.group(2));\n+                    } else {\n+                        logger.debug(\"no match on message: {}\", updateData);\n+                    }\n+                } else if (updateData.contains(DISPINFO)) {\n+                    // example: DISPINFO,DUR0,POS70,STATUS2 (DUR and POS are expressed in tenths of a second)\n+                    // 6 places(tenths of a second)-> max 999,999 /10/60/60/24 = 1.15 days\n+                    Matcher matcher = DISP_INFO_PATTERN.matcher(updateData);\n+                    if (matcher.find()) {\n+                        updateChannelState(targetSource, CHANNEL_TRACK_LENGTH, matcher.group(1));\n+                        updateChannelState(targetSource, CHANNEL_TRACK_POSITION, matcher.group(2));\n+                        updateChannelState(targetSource, CHANNEL_PLAY_MODE, matcher.group(3));\n+                    } else {\n+                        logger.debug(\"no match on message: {}\", updateData);\n+                    }\n+                } else if (updateData.contains(NAME_QUOTE) && sourceLabels.size() <= MAX_SRC) {\n+                    // example: NAME\"Ipod\"\n+                    String name = updateData.split(\"\\\"\")[1];\n+                    sourceLabels.add(new StateOption(key, name));\n+                }\n+                break;\n+            case TYPE_ZONE_UPDATE:\n+                logger.debug(\"Zone update: Zone: {} - Value: {}\", key, updateData);\n+                // example : OFF\n+                // or: ON,SRC3,VOL63,DND0,LOCK0\n+                // or: ON,SRC3,MUTE,DND0,LOCK0\n+\n+                NuvoEnum targetZone = NuvoEnum.valueOf(ZONE + key);\n+\n+                if (OFF.equals(updateData)) {\n+                    updateChannelState(targetZone, CHANNEL_TYPE_POWER, OFF);\n+                    updateChannelState(targetZone, CHANNEL_TYPE_SOURCE, UNDEF);\n+                } else {\n+                    Matcher matcher = ZONE_PATTERN.matcher(updateData);\n+                    if (matcher.find()) {\n+                        updateChannelState(targetZone, CHANNEL_TYPE_POWER, ON);\n+                        updateChannelState(targetZone, CHANNEL_TYPE_SOURCE, matcher.group(1));\n+\n+                        if (MUTE.equals(matcher.group(2))) {\n+                            updateChannelState(targetZone, CHANNEL_TYPE_MUTE, ON);\n+                        } else {\n+                            updateChannelState(targetZone, CHANNEL_TYPE_MUTE, NuvoCommand.OFF.getValue());\n+                            updateChannelState(targetZone, CHANNEL_TYPE_VOLUME, matcher.group(2).replace(VOL, BLANK));\n+                        }\n+\n+                        updateChannelState(targetZone, CHANNEL_TYPE_DND, ONE.equals(matcher.group(3)) ? ON : OFF);\n+                        updateChannelState(targetZone, CHANNEL_TYPE_LOCK, ONE.equals(matcher.group(4)) ? ON : OFF);\n+                    } else {\n+                        logger.debug(\"no match on message: {}\", updateData);\n+                    }\n+                }\n+                break;\n+            case TYPE_ZONE_BUTTON:\n+                logger.debug(\"Zone Button pressed: Source: {} - Button: {}\", key, updateData);\n+                updateChannelState(NuvoEnum.valueOf(SOURCE + key), CHANNEL_BUTTON_PRESS, updateData);\n+                break;\n+            case TYPE_ZONE_CONFIG:\n+                logger.debug(\"Zone Configuration: Zone: {} - Value: {}\", key, updateData);\n+                // example: BASS1,TREB-2,BALR2,LOUDCMP1\n+                Matcher matcher = ZONE_CFG_PATTERN.matcher(updateData);\n+                if (matcher.find()) {\n+                    updateChannelState(NuvoEnum.valueOf(ZONE + key), CHANNEL_TYPE_BASS, matcher.group(1));\n+                    updateChannelState(NuvoEnum.valueOf(ZONE + key), CHANNEL_TYPE_TREBLE, matcher.group(2));\n+                    updateChannelState(NuvoEnum.valueOf(ZONE + key), CHANNEL_TYPE_BALANCE,\n+                            NuvoStatusCodes.getBalanceFromStr(matcher.group(3)));\n+                    updateChannelState(NuvoEnum.valueOf(ZONE + key), CHANNEL_TYPE_LOUDNESS,\n+                            ONE.equals(matcher.group(4)) ? ON : OFF);\n+                } else {\n+                    logger.debug(\"no match on message: {}\", updateData);\n+                }\n+                break;\n+            default:\n+                logger.debug(\"onNewMessageEvent: unhandled key {}\", key);\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Trying to reconnect...\");\n+                closeConnection();\n+                String error = null;\n+                if (openConnection()) {\n+                    synchronized (sequenceLock) {\n+                        try {\n+                            long prevUpdateTime = lastEventReceived;\n+\n+                            connector.sendCommand(NuvoCommand.GET_CONTROLLER_VERSION);\n+\n+                            NuvoEnum.VALID_SOURCES.forEach(source -> {\n+                                try {\n+                                    connector.sendQuery(NuvoEnum.valueOf(source), NuvoCommand.NAME);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD_MS);\n+                                    connector.sendQuery(NuvoEnum.valueOf(source), NuvoCommand.DISPINFO);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD_MS);\n+                                    connector.sendQuery(NuvoEnum.valueOf(source), NuvoCommand.DISPLINE);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD_MS);\n+                                } catch (NuvoException | InterruptedException e) {\n+                                    logger.debug(\"Error Querying Source data: {}\", e.getMessage());\n+                                }\n+                            });\n+\n+                            // Query all active zones to get their current status and eq configuration\n+                            activeZones.forEach(zoneNum -> {\n+                                try {\n+                                    connector.sendQuery(NuvoEnum.valueOf(ZONE + zoneNum), NuvoCommand.STATUS);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD_MS);\n+                                    connector.sendCfgCommand(NuvoEnum.valueOf(ZONE + zoneNum), NuvoCommand.EQ_QUERY,\n+                                            BLANK);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD_MS);\n+                                } catch (NuvoException | InterruptedException e) {\n+                                    logger.debug(\"Error Querying Zone data: {}\", e.getMessage());\n+                                }\n+                            });\n+\n+                            // prevUpdateTime should have changed if a zone update was received\n+                            if (prevUpdateTime == lastEventReceived) {\n+                                error = \"Controller not responding to status requests\";\n+                            } else {\n+                                // Put the source labels on all active zones\n+                                activeZones.forEach(zoneNum -> {\n+                                    stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                                            ZONE.toLowerCase() + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE),\n+                                            sourceLabels);\n+                                });\n+                            }\n+                        } catch (NuvoException e) {\n+                            error = \"First command after connection failed\";\n+                            logger.debug(\"{}: {}\", error, e.getMessage());\n+                        }\n+                    }\n+                } else {\n+                    error = \"Reconnection failed\";\n+                }\n+                if (error != null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n+                    closeConnection();\n+                } else {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, this.versionString);\n+                }\n+            }\n+        }, 1, RECON_POLLING_INTERVAL_SEC, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the reconnection job\n+     */\n+    private void cancelReconnectJob() {\n+        ScheduledFuture<?> reconnectJob = this.reconnectJob;\n+        if (reconnectJob != null) {\n+            reconnectJob.cancel(true);\n+            this.reconnectJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Schedule the polling job\n+     */\n+    private void schedulePollingJob() {\n+        logger.debug(\"Schedule polling job\");\n+        cancelPollingJob();\n+\n+        // when the Nuvo amp is off, this will keep the connection (esp Serial over IP) alive and detect if the\n+        // connection goes down\n+        pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (connector.isConnected()) {\n+                logger.debug(\"Polling the component for updated status...\");\n+\n+                synchronized (sequenceLock) {\n+                    try {\n+                        connector.sendCommand(NuvoCommand.GET_CONTROLLER_VERSION);\n+                    } catch (NuvoException e) {\n+                        logger.debug(\"Polling error: {}\", e.getMessage());\n+                    }\n+\n+                    // if the last event received was more than 1.25 intervals ago,\n+                    // the component is not responding even though the connection is still good\n+                    if ((System.currentTimeMillis() - lastEventReceived) > (POLLING_INTERVAL_SEC * 1.25 * 1000)) {\n+                        logger.debug(\"Component not responding to status requests\");\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Component not responding to status requests\");\n+                        closeConnection();\n+                        scheduleReconnectJob();\n+                    }\n+                }\n+            }\n+        }, INITIAL_POLLING_DELAY_SEC, POLLING_INTERVAL_SEC, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the polling job\n+     */\n+    private void cancelPollingJob() {\n+        ScheduledFuture<?> pollingJob = this.pollingJob;\n+        if (pollingJob != null) {\n+            pollingJob.cancel(true);\n+            this.pollingJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Schedule the clock sync job\n+     */\n+    private void scheduleClockSyncJob() {\n+        logger.debug(\"Schedule clock sync job\");\n+        cancelClockSyncJob();\n+        clockSyncJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (this.isGConcerto) {\n+                try {\n+                    SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy,MM,dd,HH,mm\");", "originalCommit": "5117f7437ea6e07577cd8f3f3f0579dafb450a1f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY2NDI0MA==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r474664240", "bodyText": "The openHAB serial port handler supports rfc2217? Is there a reason not to use it and instead of having implemented a separate ip connector and configuration options?", "author": "Hilbrand", "createdAt": "2020-08-21T12:26:29Z", "path": "bundles/org.openhab.binding.nuvo/src/main/java/org/openhab/binding/nuvo/internal/handler/NuvoHandler.java", "diffHunk": "@@ -0,0 +1,793 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.nuvo.internal.handler;\n+\n+import static org.openhab.binding.nuvo.internal.NuvoBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.nuvo.internal.NuvoException;\n+import org.openhab.binding.nuvo.internal.NuvoStateDescriptionOptionProvider;\n+import org.openhab.binding.nuvo.internal.NuvoThingActions;\n+import org.openhab.binding.nuvo.internal.communication.NuvoCommand;\n+import org.openhab.binding.nuvo.internal.communication.NuvoConnector;\n+import org.openhab.binding.nuvo.internal.communication.NuvoDefaultConnector;\n+import org.openhab.binding.nuvo.internal.communication.NuvoEnum;\n+import org.openhab.binding.nuvo.internal.communication.NuvoIpConnector;\n+import org.openhab.binding.nuvo.internal.communication.NuvoMessageEvent;\n+import org.openhab.binding.nuvo.internal.communication.NuvoMessageEventListener;\n+import org.openhab.binding.nuvo.internal.communication.NuvoSerialConnector;\n+import org.openhab.binding.nuvo.internal.communication.NuvoStatusCodes;\n+import org.openhab.binding.nuvo.internal.configuration.NuvoThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link NuvoHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class NuvoHandler extends BaseThingHandler implements NuvoMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL_SEC = 60;\n+    private static final long POLLING_INTERVAL_SEC = 30;\n+    private static final long CLOCK_SYNC_INTERVAL_SEC = 3600;\n+    private static final long INITIAL_POLLING_DELAY_SEC = 30;\n+    private static final long INITIAL_CLOCK_SYNC_DELAY_SEC = 10;\n+    // spec says wait 50ms, min is 100\n+    private static final long SLEEP_BETWEEN_CMD_MS = 100;\n+    private static final Unit<Time> API_SECOND_UNIT = SmartHomeUnits.SECOND;\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String SOURCE = \"SOURCE\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String UNDEF = \"UNDEF\";\n+    private static final String GC_STR = \"NV-IG8\";\n+\n+    private static final int MAX_ZONES = 20;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 79;\n+    private static final int MIN_EQ = -18;\n+    private static final int MAX_EQ = 18;\n+\n+    private static final Pattern ZONE_PATTERN = Pattern\n+            .compile(\"^ON,SRC(\\\\d{1}),(MUTE|VOL\\\\d{1,2}),DND([0-1]),LOCK([0-1])$\");\n+    private static final Pattern DISP_PATTERN = Pattern.compile(\"^DISPLINE(\\\\d{1}),\\\"(.*)\\\"$\");\n+    private static final Pattern DISP_INFO_PATTERN = Pattern\n+            .compile(\"^DISPINFO,DUR(\\\\d{1,6}),POS(\\\\d{1,6}),STATUS(\\\\d{1,2})$\");\n+    private static final Pattern ZONE_CFG_PATTERN = Pattern.compile(\"^BASS(.*),TREB(.*),BAL(.*),LOUDCMP([0-1])$\");\n+\n+    private final Logger logger = LoggerFactory.getLogger(NuvoHandler.class);\n+    private final NuvoStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final SerialPortManager serialPortManager;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> clockSyncJob;\n+\n+    private NuvoConnector connector = new NuvoDefaultConnector();\n+    private long lastEventReceived = System.currentTimeMillis();\n+    private int numZones = 1;\n+    private String versionString = BLANK;\n+    private boolean isGConcerto = false;\n+    private Object sequenceLock = new Object();\n+\n+    Set<Integer> activeZones = new HashSet<>(1);\n+\n+    // A state option list for the source labels\n+    List<StateOption> sourceLabels = new ArrayList<>();\n+\n+    /**\n+     * Constructor\n+     */\n+    public NuvoHandler(Thing thing, NuvoStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        NuvoThingConfiguration config = getConfigAs(NuvoThingConfiguration.class);\n+        String serialPort = config.serialPort;\n+        String host = config.host;\n+        Integer port = config.port;\n+        Integer numZones = config.numZones;\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((serialPort == null || serialPort.isEmpty()) && (host == null || host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (serialPort != null && (host == null || host.isEmpty())) {\n+            if (serialPort.toLowerCase().startsWith(\"rfc2217\")) {", "originalCommit": "5117f7437ea6e07577cd8f3f3f0579dafb450a1f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTAxOTkxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r475019919", "bodyText": "I am not sure as this was pulled in from the rotel binding. I seems like rfc2217 (Telnet Com Port) may be supported to some degree. But there were probably issues, so a distinct connector was defined instead and this check was put in place to prevent an unusable configuration. @lolodomo any ideas?", "author": "mlobstein", "createdAt": "2020-08-22T00:22:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY2NDI0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY3NzEwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r475677105", "bodyText": "RFC2217 through the openhab serial layer never worked in bindings I worked on.\nI am not sure of the reason but my hypothesis was it doesn't work if you need to read and write in parallel.\nBut you are welcome to try with any new binding. Maybe I was just not enough clever to make it work.", "author": "lolodomo", "createdAt": "2020-08-24T14:58:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY2NDI0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY4MDY2OA==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r475680668", "bodyText": "This is probably a problem in case you have a reader thread that always read data.", "author": "lolodomo", "createdAt": "2020-08-24T15:01:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY2NDI0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkyMTg2MA==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r475921860", "bodyText": "That makes sense. But I think I will just stick with what works.", "author": "mlobstein", "createdAt": "2020-08-24T22:08:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY2NDI0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM4MTkyOA==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r476381928", "bodyText": "@lolodomo Maybe it was related to the endless sleep 'fix' (that could be and was removed during the review process)? Did you ever test after that change?\n@mlobstein Did you test if it worked at all by using the rfc2217 version?", "author": "Hilbrand", "createdAt": "2020-08-25T11:39:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY2NDI0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQzMDMxOA==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r476430318", "bodyText": "@hillbrand: Honestly I don't remember. I even don't remember if I tested that with this binding in particular. But as I am using serial over IP, I could try again one day.", "author": "lolodomo", "createdAt": "2020-08-25T13:01:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY2NDI0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ5MjY2OA==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r476492668", "bodyText": "@lolodomo Maybe it was related to the endless sleep 'fix' (that could be and was removed during the review process)? Did you ever test after that change?\n@mlobstein Did you test if it worked at all by using the rfc2217 version?\nI did not test it with rfc2217", "author": "mlobstein", "createdAt": "2020-08-25T14:27:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY2NDI0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTYyOTM3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r479629376", "bodyText": "If it's not tested or not known if the rfc2217 configuration way doesn't work I would be in favor of removing the specific ip implementation here and allowing the rfcc2217 configuratiin option for serial. Its always possible to add features, but removing them is hard. This also reduces the amount of copy-pasting of specific code.", "author": "Hilbrand", "createdAt": "2020-08-29T09:14:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY2NDI0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDE5MjE1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r480192157", "bodyText": "A couple questions...\n\n\nI tried rfc2217 and it seemed to work connecting to a ser2net endpoint after a few changes to the serial connector. I had to conditionally bypass SerialPort.enableReceiveThreshold(), SerialPort.enableReceiveTimeout() & SerialPort.setFlowControlMode() as the calling those with rfc2217 throws an exception. I also had to catch an IllegalStateException that was being thrown if the remote connection was refused or otherwise failed to connect. That being said, are there any bindings that currently support rfc2217 explicitly (as a reference implementation)? I did a quick scan of the 2.5.x bindings and the only references to rfc2217 were in 6 other bindings that blocked its usage during initialization.\n\n\nIf rfc2217 is to be used, does the user need to make the choice to specify the rfc2217 url string in place of the serial port or can this be handled behind the scenes? There seems to be some controversy with setting limitToOptions=false for the serial port in the configuration. openhab/openhab-core#1029 Once this is set to false, the user can type the url string for the rfc2217 connection (rfc2217://:). I feel this is cumbersome and it would be much easier for the user to give them a place to specify IP and port # for the remote serial port and use those to construct the rfc2217 url in the absence of a physical serial port being selected from the drop down.\n@kaikreuzer", "author": "mlobstein", "createdAt": "2020-08-31T15:04:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY2NDI0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQ2NzY3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r482467671", "bodyText": "Thank you for extensive testing this. At least we know it works (besides the exception throwing. In know the dsmr binding does also works once the exceptions would be wrapped.). The openhab-core issue 1029 you mentioned was about the possibility to be able to add a network connection. It doesn't even address the usability of it, which is too bad. I also looked at the other bindings. It looks to me this has grown historically. In the past the gnu serial library was used directly, so no rfc2217 support was availble. So that earlier binding implemented their own version of it. Later versions seem to be made by the same person and he copied that implementation. The other bindings seem to add a bridge for ip configuration. I also noted we already approved your oppo binding that does the same.\nSo I'll guess it should be ok to leave it as is here. What I'm planning, is to see if I can get those quircks fixed in core so it behaves the same as other direct serial connections and than see if this makes it possible to remove the custom implementations for ip connections. For example here you could construct the rfc2217 connection fromt host-port input and then use the rfc2217 of core. The configurations can than still remain (with addition that rfc2217 configuration would be allowed on serialPort configuration). But that would not be available before openHAB 3.0.", "author": "Hilbrand", "createdAt": "2020-09-02T21:04:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY2NDI0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY2NDQ2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7651#discussion_r474664462", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        zonesToRemove.forEach(zone -> {\n          \n          \n            \n                            channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone)));\n          \n          \n            \n                        });\n          \n          \n            \n                        zonesToRemove.forEach(zone -> \n          \n          \n            \n                            channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone)))\n          \n          \n            \n                        );", "author": "Hilbrand", "createdAt": "2020-08-21T12:26:57Z", "path": "bundles/org.openhab.binding.nuvo/src/main/java/org/openhab/binding/nuvo/internal/handler/NuvoHandler.java", "diffHunk": "@@ -0,0 +1,793 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.nuvo.internal.handler;\n+\n+import static org.openhab.binding.nuvo.internal.NuvoBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.nuvo.internal.NuvoException;\n+import org.openhab.binding.nuvo.internal.NuvoStateDescriptionOptionProvider;\n+import org.openhab.binding.nuvo.internal.NuvoThingActions;\n+import org.openhab.binding.nuvo.internal.communication.NuvoCommand;\n+import org.openhab.binding.nuvo.internal.communication.NuvoConnector;\n+import org.openhab.binding.nuvo.internal.communication.NuvoDefaultConnector;\n+import org.openhab.binding.nuvo.internal.communication.NuvoEnum;\n+import org.openhab.binding.nuvo.internal.communication.NuvoIpConnector;\n+import org.openhab.binding.nuvo.internal.communication.NuvoMessageEvent;\n+import org.openhab.binding.nuvo.internal.communication.NuvoMessageEventListener;\n+import org.openhab.binding.nuvo.internal.communication.NuvoSerialConnector;\n+import org.openhab.binding.nuvo.internal.communication.NuvoStatusCodes;\n+import org.openhab.binding.nuvo.internal.configuration.NuvoThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link NuvoHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class NuvoHandler extends BaseThingHandler implements NuvoMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL_SEC = 60;\n+    private static final long POLLING_INTERVAL_SEC = 30;\n+    private static final long CLOCK_SYNC_INTERVAL_SEC = 3600;\n+    private static final long INITIAL_POLLING_DELAY_SEC = 30;\n+    private static final long INITIAL_CLOCK_SYNC_DELAY_SEC = 10;\n+    // spec says wait 50ms, min is 100\n+    private static final long SLEEP_BETWEEN_CMD_MS = 100;\n+    private static final Unit<Time> API_SECOND_UNIT = SmartHomeUnits.SECOND;\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String SOURCE = \"SOURCE\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String UNDEF = \"UNDEF\";\n+    private static final String GC_STR = \"NV-IG8\";\n+\n+    private static final int MAX_ZONES = 20;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 79;\n+    private static final int MIN_EQ = -18;\n+    private static final int MAX_EQ = 18;\n+\n+    private static final Pattern ZONE_PATTERN = Pattern\n+            .compile(\"^ON,SRC(\\\\d{1}),(MUTE|VOL\\\\d{1,2}),DND([0-1]),LOCK([0-1])$\");\n+    private static final Pattern DISP_PATTERN = Pattern.compile(\"^DISPLINE(\\\\d{1}),\\\"(.*)\\\"$\");\n+    private static final Pattern DISP_INFO_PATTERN = Pattern\n+            .compile(\"^DISPINFO,DUR(\\\\d{1,6}),POS(\\\\d{1,6}),STATUS(\\\\d{1,2})$\");\n+    private static final Pattern ZONE_CFG_PATTERN = Pattern.compile(\"^BASS(.*),TREB(.*),BAL(.*),LOUDCMP([0-1])$\");\n+\n+    private final Logger logger = LoggerFactory.getLogger(NuvoHandler.class);\n+    private final NuvoStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final SerialPortManager serialPortManager;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> clockSyncJob;\n+\n+    private NuvoConnector connector = new NuvoDefaultConnector();\n+    private long lastEventReceived = System.currentTimeMillis();\n+    private int numZones = 1;\n+    private String versionString = BLANK;\n+    private boolean isGConcerto = false;\n+    private Object sequenceLock = new Object();\n+\n+    Set<Integer> activeZones = new HashSet<>(1);\n+\n+    // A state option list for the source labels\n+    List<StateOption> sourceLabels = new ArrayList<>();\n+\n+    /**\n+     * Constructor\n+     */\n+    public NuvoHandler(Thing thing, NuvoStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        NuvoThingConfiguration config = getConfigAs(NuvoThingConfiguration.class);\n+        String serialPort = config.serialPort;\n+        String host = config.host;\n+        Integer port = config.port;\n+        Integer numZones = config.numZones;\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((serialPort == null || serialPort.isEmpty()) && (host == null || host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (serialPort != null && (host == null || host.isEmpty())) {\n+            if (serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+            return;\n+        }\n+\n+        if (serialPort != null) {\n+            connector = new NuvoSerialConnector(serialPortManager, serialPort);\n+        } else if (port != null) {\n+            connector = new NuvoIpConnector(host, port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Either Serial port or Host & Port must be specifed\");\n+            return;\n+        }\n+\n+        if (numZones != null) {\n+            this.numZones = numZones;\n+        }\n+\n+        activeZones = IntStream.range((1), (this.numZones + 1)).boxed().collect(Collectors.toSet());\n+\n+        // remove the channels for the zones we are not using\n+        if (this.numZones < MAX_ZONES) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+            List<Integer> zonesToRemove = IntStream.range((this.numZones + 1), (MAX_ZONES + 1)).boxed()\n+                    .collect(Collectors.toList());\n+\n+            zonesToRemove.forEach(zone -> {\n+                channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone)));\n+            });", "originalCommit": "5117f7437ea6e07577cd8f3f3f0579dafb450a1f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a64cd537c76ab41ca63f55465c3aebc319baf32d", "url": "https://github.com/openhab/openhab-addons/commit/a64cd537c76ab41ca63f55465c3aebc319baf32d", "message": "more review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-08-21T23:58:00Z", "type": "commit"}, {"oid": "f49106bbf897956459a88243323fc5d64a4b3223", "url": "https://github.com/openhab/openhab-addons/commit/f49106bbf897956459a88243323fc5d64a4b3223", "message": "Merge pull request #9 from openhab/2.5.x\n\nUpdate fork", "committedDate": "2020-08-22T01:32:17Z", "type": "commit"}, {"oid": "a017e6bddecd3ddd040080780f96409b9b93e68a", "url": "https://github.com/openhab/openhab-addons/commit/a017e6bddecd3ddd040080780f96409b9b93e68a", "message": "fix thread naming convention\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-08-26T13:20:32Z", "type": "commit"}, {"oid": "ce6b1b83511266993e7e74b54122b54654265a79", "url": "https://github.com/openhab/openhab-addons/commit/ce6b1b83511266993e7e74b54122b54654265a79", "message": "Merge branch '2.5.x' of https://github.com/openhab/openhab-addons into 2.5.x", "committedDate": "2020-08-26T15:39:12Z", "type": "commit"}, {"oid": "d79bd46216e06d6596ed9cd86f6001c84e41e5c2", "url": "https://github.com/openhab/openhab-addons/commit/d79bd46216e06d6596ed9cd86f6001c84e41e5c2", "message": "Merge branch '2.5.x' into NuvoAudio", "committedDate": "2020-08-26T16:56:01Z", "type": "commit"}, {"oid": "65b24299ab696163c5268501908c56b94ac9e4d6", "url": "https://github.com/openhab/openhab-addons/commit/65b24299ab696163c5268501908c56b94ac9e4d6", "message": "fix thread naming convention\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-08-26T16:56:53Z", "type": "commit"}, {"oid": "e1cab258b685ed0a38d58aef0c2bb76ce41a2c2e", "url": "https://github.com/openhab/openhab-addons/commit/e1cab258b685ed0a38d58aef0c2bb76ce41a2c2e", "message": "Update pom version to 2.5.9.", "committedDate": "2020-09-02T21:10:16Z", "type": "commit"}]}