{"pr_number": 8530, "pr_title": "[zoneminder] Replacement for ZoneMinder binding", "pr_createdAt": "2020-09-21T20:29:46Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/8530", "timeline": [{"oid": "25ca85923ac7af88c5bea87e9387a4e8d8df3982", "url": "https://github.com/openhab/openhab-addons/commit/25ca85923ac7af88c5bea87e9387a4e8d8df3982", "message": "Change owner\n\nSigned-off-by: Mark Hilbush <mark@hilbush.com>", "committedDate": "2020-09-22T14:09:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk4MTkyNg==", "url": "https://github.com/openhab/openhab-addons/pull/8530#discussion_r492981926", "bodyText": "Maybe this should be done as part of activate instead?", "author": "cpmeister", "createdAt": "2020-09-22T19:28:49Z", "path": "bundles/org.openhab.binding.zoneminder/src/main/java/org/openhab/binding/zoneminder/internal/discovery/MonitorDiscoveryService.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.zoneminder.internal.discovery;\n+\n+import static org.openhab.binding.zoneminder.internal.ZmBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.zoneminder.internal.handler.Monitor;\n+import org.openhab.binding.zoneminder.internal.handler.ZmBridgeHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonitorDiscoveryService} is responsible for discovering the Zoneminder monitors\n+ * associated with a Zoneminder server.\n+ *\n+ * @author Mark Hilbush - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonitorDiscoveryService extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonitorDiscoveryService.class);\n+\n+    private @Nullable ZmBridgeHandler bridgeHandler;\n+\n+    public MonitorDiscoveryService() {\n+        super(30);\n+    }\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler handler) {\n+        if (handler instanceof ZmBridgeHandler) {\n+            ((ZmBridgeHandler) handler).setDiscoveryService(this);", "originalCommit": "48db60bb58bef52a99bb3a444ddc4de9e7528ea7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzYyMzAxMw==", "url": "https://github.com/openhab/openhab-addons/pull/8530#discussion_r493623013", "bodyText": "I don't know. It's done this way in a number of other bindings. And, I don't think we know the bridge handler in activate.", "author": "mhilbush", "createdAt": "2020-09-23T14:08:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk4MTkyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk5MDUzMw==", "url": "https://github.com/openhab/openhab-addons/pull/8530#discussion_r492990533", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (auth != null && auth.exception == null && auth.exception == null && auth.accessToken != null) {\n          \n          \n            \n                        if (auth != null && auth.exception == null && auth.accessToken != null) {", "author": "cpmeister", "createdAt": "2020-09-22T19:45:16Z", "path": "bundles/org.openhab.binding.zoneminder/src/main/java/org/openhab/binding/zoneminder/internal/handler/ZmAuth.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.zoneminder.internal.handler;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.zoneminder.internal.dto.AuthResponseDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link ZmAuth} manages the authentication process when Zoneminder\n+ * authentication is enabled. This class requests access and refresh tokens based\n+ * on the expiration times provided by the Zoneminder server.\n+ *\n+ * @author Mark Hilbush - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ZmAuth {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ZmAuth.class);\n+\n+    private ZmBridgeHandler bridgeHandler;\n+    private String authContent;\n+\n+    private @Nullable String refreshToken;\n+    private long refreshTokenExpiresAt;\n+    private @Nullable String accessToken;\n+    private long accessTokenExpiresAt;\n+\n+    private boolean usingAuthorization;\n+    private boolean isAuthorized;\n+\n+    public ZmAuth(ZmBridgeHandler handler) {\n+        this(handler, null, null);\n+    }\n+\n+    public ZmAuth(ZmBridgeHandler handler, @Nullable String user, @Nullable String pass) {\n+        this.bridgeHandler = handler;\n+        if (user == null || pass == null) {\n+            logger.debug(\"ZmAuth: Authorization is disabled\");\n+            usingAuthorization = false;\n+            isAuthorized = true;\n+            authContent = \"\";\n+        } else {\n+            logger.debug(\"ZmAuth: Authorization is enabled\");\n+            usingAuthorization = true;\n+            isAuthorized = false;\n+            try {\n+                authContent = String.format(\"user=%s&pass=%s&stateful=1\",\n+                        URLEncoder.encode(user, StandardCharsets.UTF_8.name()),\n+                        URLEncoder.encode(pass, StandardCharsets.UTF_8.name()));\n+            } catch (UnsupportedEncodingException e) {\n+                logger.warn(\"ZmAuth: Unable to encode user name and password\");\n+                authContent = \"\";\n+            }\n+        }\n+    }\n+\n+    public String getAccessToken() {\n+        String localAccessToken = accessToken;\n+        return localAccessToken != null ? localAccessToken : \"\";\n+    }\n+\n+    public boolean usingAuthorization() {\n+        return usingAuthorization;\n+    }\n+\n+    public boolean isAuthorized() {\n+        if (usingAuthorization()) {\n+            checkTokens();\n+        }\n+        return isAuthorized;\n+    }\n+\n+    private void checkTokens() {\n+        if (isExpired(refreshTokenExpiresAt)) {\n+            getNewRefreshToken();\n+        } else if (isExpired(accessTokenExpiresAt)) {\n+            getNewAccessToken();\n+        }\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    private synchronized void getNewRefreshToken() {\n+        // First check to see if another thread has updated it\n+        if (!isExpired(refreshTokenExpiresAt)) {\n+            return;\n+        }\n+        String url = bridgeHandler.buildLoginUrl();\n+        logger.debug(\"ZmAuth: Update expired REFRESH token using url '{}'\", url);\n+        String response = bridgeHandler.executePost(url, authContent, \"application/x-www-form-urlencoded\");\n+        if (response != null) {\n+            Gson gson = bridgeHandler.getGson();\n+            AuthResponseDTO auth = gson.fromJson(response, AuthResponseDTO.class);\n+            if (auth != null && auth.exception == null && auth.refreshToken != null && auth.accessToken != null) {\n+                updateRefreshToken(auth);\n+                updateAccessToken(auth);\n+                isAuthorized = true;\n+                return;\n+            }\n+        }\n+        isAuthorized = false;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    private synchronized void getNewAccessToken() {\n+        // First check to see if another thread has updated it\n+        if (!isExpired(accessTokenExpiresAt)) {\n+            return;\n+        }\n+        String url = bridgeHandler.buildLoginUrl(String.format(\"?token=%s\", refreshToken));\n+        logger.debug(\"ZmAuth: Update expired ACCESS token using url '{}'\", url);\n+        String response = bridgeHandler.executeGet(url);\n+        if (response != null) {\n+            Gson gson = bridgeHandler.getGson();\n+            AuthResponseDTO auth = gson.fromJson(response, AuthResponseDTO.class);\n+            if (auth != null && auth.exception == null && auth.exception == null && auth.accessToken != null) {", "originalCommit": "48db60bb58bef52a99bb3a444ddc4de9e7528ea7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU5ODk5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8530#discussion_r493598996", "bodyText": "No, no. I need to really make sure it's null. lol\nFixed.", "author": "mhilbush", "createdAt": "2020-09-23T13:38:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk5MDUzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk5MjQ1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8530#discussion_r492992457", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private ZmBridgeHandler bridgeHandler;\n          \n          \n            \n                private String authContent;\n          \n          \n            \n                private final ZmBridgeHandler bridgeHandler;\n          \n          \n            \n                private final String authContent;", "author": "cpmeister", "createdAt": "2020-09-22T19:48:40Z", "path": "bundles/org.openhab.binding.zoneminder/src/main/java/org/openhab/binding/zoneminder/internal/handler/ZmAuth.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.zoneminder.internal.handler;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.zoneminder.internal.dto.AuthResponseDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link ZmAuth} manages the authentication process when Zoneminder\n+ * authentication is enabled. This class requests access and refresh tokens based\n+ * on the expiration times provided by the Zoneminder server.\n+ *\n+ * @author Mark Hilbush - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ZmAuth {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ZmAuth.class);\n+\n+    private ZmBridgeHandler bridgeHandler;\n+    private String authContent;", "originalCommit": "48db60bb58bef52a99bb3a444ddc4de9e7528ea7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzYwNzM2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8530#discussion_r493607362", "bodyText": "Done", "author": "mhilbush", "createdAt": "2020-09-23T13:49:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk5MjQ1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk5MzUxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8530#discussion_r492993519", "bodyText": "The default charset varies from system to system so it is better to specify it yourself instead of using the default.", "author": "cpmeister", "createdAt": "2020-09-22T19:50:38Z", "path": "bundles/org.openhab.binding.zoneminder/src/main/java/org/openhab/binding/zoneminder/internal/handler/ZmBridgeHandler.java", "diffHunk": "@@ -0,0 +1,635 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.zoneminder.internal.handler;\n+\n+import static org.openhab.binding.zoneminder.internal.ZmBindingConstants.*;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.zoneminder.internal.ZmStateDescriptionOptionsProvider;\n+import org.openhab.binding.zoneminder.internal.config.ZmBridgeConfig;\n+import org.openhab.binding.zoneminder.internal.discovery.MonitorDiscoveryService;\n+import org.openhab.binding.zoneminder.internal.dto.EventDTO;\n+import org.openhab.binding.zoneminder.internal.dto.EventsDTO;\n+import org.openhab.binding.zoneminder.internal.dto.MonitorDTO;\n+import org.openhab.binding.zoneminder.internal.dto.MonitorItemDTO;\n+import org.openhab.binding.zoneminder.internal.dto.MonitorStateDTO;\n+import org.openhab.binding.zoneminder.internal.dto.MonitorStatusDTO;\n+import org.openhab.binding.zoneminder.internal.dto.MonitorsDTO;\n+import org.openhab.binding.zoneminder.internal.dto.VersionDTO;\n+import org.openhab.core.io.net.http.HttpUtil;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The {@link ZmBridgeHandler} represents the Zoneminder server. It handles all communication\n+ * with the Zoneminder server.\n+ *\n+ * @author Mark Hilbush - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ZmBridgeHandler extends BaseBridgeHandler {\n+\n+    private static final int REFRESH_INTERVAL_SECONDS = 1;\n+    private static final int REFRESH_STARTUP_DELAY_SECONDS = 3;\n+\n+    private static final int MONITORS_INTERVAL_SECONDS = 5;\n+    private static final int MONITORS_INITIAL_DELAY_SECONDS = 3;\n+\n+    private static final int DISCOVERY_INTERVAL_SECONDS = 300;\n+    private static final int DISCOVERY_INITIAL_DELAY_SECONDS = 10;\n+\n+    private static final int API_TIMEOUT_MSEC = 10000;\n+\n+    private static final String LOGIN_PATH = \"/api/host/login.json\";\n+\n+    private static final String STREAM_IMAGE = \"single\";\n+    private static final String STREAM_VIDEO = \"jpeg\";\n+\n+    private static final List<String> EMPTY_LIST = Collections.emptyList();\n+\n+    private static final Gson GSON = new GsonBuilder().setDateFormat(\"yyyy-MM-dd HH:mm:ss\").create();\n+\n+    private final Logger logger = LoggerFactory.getLogger(ZmBridgeHandler.class);\n+\n+    private @Nullable Future<?> refreshMonitorsJob;\n+    private final AtomicInteger monitorsCounter = new AtomicInteger();\n+\n+    private @Nullable MonitorDiscoveryService discoveryService;\n+    private final AtomicInteger discoveryCounter = new AtomicInteger();\n+\n+    private List<Monitor> savedMonitors = new ArrayList<>();\n+\n+    private String host = \"\";\n+    private boolean useSSL;\n+    private @Nullable String portNumber;\n+    private @NonNullByDefault({}) Boolean useDefaultUrlPath;\n+    private @Nullable String urlPath;\n+    private int monitorsInterval;\n+    private int discoveryInterval;\n+    private boolean discoveryEnabled;\n+    private int defaultAlarmDuration;\n+    private @Nullable Integer defaultImageRefreshInterval;\n+\n+    private final HttpClient httpClient;\n+    private final ZmStateDescriptionOptionsProvider stateDescriptionProvider;\n+\n+    private ZmAuth zmAuth;\n+\n+    // Maintain mapping of handler and monitor id\n+    private final Map<String, ZmMonitorHandler> monitorHandlers = new ConcurrentHashMap<>();\n+\n+    public ZmBridgeHandler(Bridge thing, HttpClient httpClient,\n+            ZmStateDescriptionOptionsProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        // Default to use no authentication\n+        zmAuth = new ZmAuth(this);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        ZmBridgeConfig config = getConfigAs(ZmBridgeConfig.class);\n+\n+        Integer value;\n+        value = config.refreshInterval;\n+        monitorsInterval = value == null ? MONITORS_INTERVAL_SECONDS : value;\n+\n+        value = config.discoveryInterval;\n+        discoveryInterval = value == null ? DISCOVERY_INTERVAL_SECONDS : value;\n+\n+        value = config.defaultAlarmDuration;\n+        defaultAlarmDuration = value == null ? DEFAULT_ALARM_DURATION_SECONDS : value;\n+\n+        defaultImageRefreshInterval = config.defaultImageRefreshInterval;\n+\n+        discoveryEnabled = config.discoveryEnabled == null ? false : config.discoveryEnabled.booleanValue();\n+\n+        host = config.host;\n+        useSSL = config.useSSL.booleanValue();\n+        portNumber = config.portNumber != null ? Integer.toString(config.portNumber) : null;\n+\n+        // Allows the use of a customized path and/or port number\n+        useDefaultUrlPath = config.useDefaultUrlPath;\n+        urlPath = config.urlPath;\n+\n+        // If user and password are configured, then use Zoneminder authentication\n+        if (config.user != null && config.pass != null) {\n+            zmAuth = new ZmAuth(this, config.user, config.pass);\n+        }\n+        if (isHostValid()) {\n+            updateStatus(ThingStatus.ONLINE);\n+            scheduleRefreshJob();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelRefreshJob();\n+    }\n+\n+    @Override\n+    public void childHandlerInitialized(ThingHandler childHandler, Thing childThing) {\n+        String monitorId = (String) childThing.getConfiguration().get(CONFIG_MONITOR_ID);\n+        monitorHandlers.put(monitorId, (ZmMonitorHandler) childHandler);\n+        logger.debug(\"Bridge: Monitor handler was initialized for {} with id {}\", childThing.getUID(), monitorId);\n+    }\n+\n+    @Override\n+    public void childHandlerDisposed(ThingHandler childHandler, Thing childThing) {\n+        String monitorId = (String) childThing.getConfiguration().get(CONFIG_MONITOR_ID);\n+        monitorHandlers.remove(monitorId);\n+        logger.debug(\"Bridge: Monitor handler was disposed for {} with id {}\", childThing.getUID(), monitorId);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        switch (channelUID.getId()) {\n+            case CHANNEL_IMAGE_MONITOR_ID:\n+                handleMonitorIdCommand(command, CHANNEL_IMAGE_MONITOR_ID, CHANNEL_IMAGE_URL, STREAM_IMAGE);\n+                break;\n+            case CHANNEL_VIDEO_MONITOR_ID:\n+                handleMonitorIdCommand(command, CHANNEL_VIDEO_MONITOR_ID, CHANNEL_VIDEO_URL, STREAM_VIDEO);\n+                break;\n+        }\n+    }\n+\n+    private void handleMonitorIdCommand(Command command, String monitorIdChannelId, String urlChannelId, String type) {\n+        if (command instanceof RefreshType || command == OnOffType.OFF) {\n+            updateState(monitorIdChannelId, UnDefType.UNDEF);\n+            updateState(urlChannelId, UnDefType.UNDEF);\n+        } else if (command instanceof StringType) {\n+            String id = command.toString();\n+            if (isMonitorIdValid(id)) {\n+                updateState(urlChannelId, new StringType(buildStreamUrl(id, type)));\n+            } else {\n+                updateState(monitorIdChannelId, UnDefType.UNDEF);\n+                updateState(urlChannelId, UnDefType.UNDEF);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(MonitorDiscoveryService.class);\n+    }\n+\n+    public void setDiscoveryService(MonitorDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public boolean isDiscoveryEnabled() {\n+        return discoveryEnabled;\n+    }\n+\n+    public Integer getDefaultAlarmDuration() {\n+        return defaultAlarmDuration;\n+    }\n+\n+    public @Nullable Integer getDefaultImageRefreshInterval() {\n+        return defaultImageRefreshInterval;\n+    }\n+\n+    public List<Monitor> getSavedMonitors() {\n+        return savedMonitors;\n+    }\n+\n+    public Gson getGson() {\n+        return GSON;\n+    }\n+\n+    public void setFunction(String id, MonitorFunction function) {\n+        if (!zmAuth.isAuthorized()) {\n+            return;\n+        }\n+        logger.debug(\"Bridge: Setting monitor {} function to {}\", id, function);\n+        executePost(buildUrl(String.format(\"/api/monitors/%s.json\", id)),\n+                String.format(\"Monitor[Function]=%s\", function.toString()));\n+    }\n+\n+    public void setEnabled(String id, OnOffType enabled) {\n+        if (!zmAuth.isAuthorized()) {\n+            return;\n+        }\n+        logger.debug(\"Bridge: Setting monitor {} to {}\", id, enabled);\n+        executePost(buildUrl(String.format(\"/api/monitors/%s.json\", id)),\n+                String.format(\"Monitor[Enabled]=%s\", enabled == OnOffType.ON ? \"1\" : \"0\"));\n+    }\n+\n+    public void setAlarmOn(String id) {\n+        if (!zmAuth.isAuthorized()) {\n+            return;\n+        }\n+        logger.debug(\"Bridge: Turning alarm ON for monitor {}\", id);\n+        setAlarm(buildUrl(String.format(\"/api/monitors/alarm/id:%s/command:on.json\", id)));\n+    }\n+\n+    public void setAlarmOff(String id) {\n+        if (!zmAuth.isAuthorized()) {\n+            return;\n+        }\n+        logger.debug(\"Bridge: Turning alarm OFF for monitor {}\", id);\n+        setAlarm(buildUrl(String.format(\"/api/monitors/alarm/id:%s/command:off.json\", id)));\n+    }\n+\n+    public @Nullable RawType getImage(String id, @Nullable Integer imageRefreshIntervalSeconds) {\n+        Integer localRefreshInterval = imageRefreshIntervalSeconds;\n+        if (localRefreshInterval == null || localRefreshInterval.intValue() < 1 || !zmAuth.isAuthorized()) {\n+            return null;\n+        }\n+        // Call should timeout just before the refresh interval\n+        int timeout = Math.min((localRefreshInterval * 1000) - 500, API_TIMEOUT_MSEC);\n+        Request request = httpClient.newRequest(buildStreamUrl(id, STREAM_IMAGE));\n+        request.method(HttpMethod.GET);\n+        request.timeout(timeout, TimeUnit.MILLISECONDS);\n+\n+        String errorMsg;\n+        try {\n+            ContentResponse response = request.send();\n+            if (response.getStatus() == HttpStatus.OK_200) {\n+                RawType image = new RawType(response.getContent(), response.getHeaders().get(HttpHeader.CONTENT_TYPE));\n+                return image;\n+            } else {\n+                errorMsg = String.format(\"HTTP GET failed: %d, %s\", response.getStatus(), response.getReason());\n+            }\n+        } catch (TimeoutException e) {\n+            errorMsg = String.format(\"TimeoutException: Call to Zoneminder API timed out after {} msec\", timeout);\n+        } catch (ExecutionException e) {\n+            errorMsg = String.format(\"ExecutionException: %s\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            errorMsg = String.format(\"InterruptedException: %s\", e.getMessage());\n+            Thread.currentThread().interrupt();\n+        }\n+        logger.debug(\"{}\", errorMsg);\n+        return null;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    private synchronized List<Monitor> getMonitors() {\n+        List<Monitor> monitorList = new ArrayList<>();\n+        if (!zmAuth.isAuthorized()) {\n+            return monitorList;\n+        }\n+        try {\n+            String response = executeGet(buildUrl(\"/api/monitors.json\"));\n+            MonitorsDTO monitors = GSON.fromJson(response, MonitorsDTO.class);\n+            if (monitors != null && monitors.monitorItems != null) {\n+                List<StateOption> options = new ArrayList<>();\n+                for (MonitorItemDTO monitorItem : monitors.monitorItems) {\n+                    MonitorDTO m = monitorItem.monitor;\n+                    MonitorStatusDTO mStatus = monitorItem.monitorStatus;\n+                    if (m != null && mStatus != null) {\n+                        Monitor monitor = new Monitor(m.id, m.name, m.function, m.enabled, mStatus.status);\n+                        monitor.setHourEvents(m.hourEvents);\n+                        monitor.setDayEvents(m.dayEvents);\n+                        monitor.setWeekEvents(m.weekEvents);\n+                        monitor.setMonthEvents(m.monthEvents);\n+                        monitor.setTotalEvents(m.totalEvents);\n+                        monitor.setImageUrl(buildStreamUrl(m.id, STREAM_IMAGE));\n+                        monitor.setVideoUrl(buildStreamUrl(m.id, STREAM_VIDEO));\n+                        monitorList.add(monitor);\n+                        options.add(new StateOption(m.id, \"Monitor \" + m.id));\n+                    }\n+                    stateDescriptionProvider\n+                            .setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_IMAGE_MONITOR_ID), options);\n+                    stateDescriptionProvider\n+                            .setStateOptions(new ChannelUID(getThing().getUID(), CHANNEL_VIDEO_MONITOR_ID), options);\n+                }\n+                // Only update alarm and event info for monitors whose handlers are initialized\n+                Set<String> ids = monitorHandlers.keySet();\n+                for (Monitor m : monitorList) {\n+                    if (ids.contains(m.getId())) {\n+                        m.setState(getState(m.getId()));\n+                        m.setLastEvent(getLastEvent(m.getId()));\n+                    }\n+                }\n+            }\n+        } catch (JsonSyntaxException e) {\n+            logger.debug(\"Bridge: JsonSyntaxException: {}\", e.getMessage(), e);\n+        }\n+        return monitorList;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    private @Nullable Event getLastEvent(String id) {\n+        if (!zmAuth.isAuthorized()) {\n+            return null;\n+        }\n+        try {\n+            List<String> parameters = new ArrayList<>();\n+            parameters.add(\"sort=StartTime\");\n+            parameters.add(\"direction=desc\");\n+            parameters.add(\"limit=1\");\n+            String response = executeGet(\n+                    buildUrlWithParameters(String.format(\"/api/events/index/MonitorId:%s.json\", id), parameters));\n+            EventsDTO events = GSON.fromJson(response, EventsDTO.class);\n+            if (events != null && events.eventsList != null && events.eventsList.size() == 1) {\n+                EventDTO e = events.eventsList.get(0).event;\n+                Event event = new Event(e.eventId, e.name, e.cause, e.notes, e.startTime, e.endTime);\n+                event.setFrames(e.frames);\n+                event.setAlarmFrames(e.alarmFrames);\n+                event.setLength(e.length);\n+                return event;\n+            }\n+        } catch (JsonSyntaxException e) {\n+            logger.debug(\"Bridge: JsonSyntaxException: {}\", e.getMessage(), e);\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable VersionDTO getVersion() {\n+        if (!zmAuth.isAuthorized()) {\n+            return null;\n+        }\n+        VersionDTO version = null;\n+        try {\n+            String response = executeGet(buildUrl(\"/api/host/getVersion.json\"));\n+            version = GSON.fromJson(response, VersionDTO.class);\n+        } catch (JsonSyntaxException e) {\n+            logger.debug(\"Bridge: JsonSyntaxException: {}\", e.getMessage(), e);\n+        }\n+        return version;\n+    }\n+\n+    private void setAlarm(String url) {\n+        executeGet(url);\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    private MonitorState getState(String id) {\n+        if (!zmAuth.isAuthorized()) {\n+            return MonitorState.UNKNOWN;\n+        }\n+        try {\n+            String response = executeGet(buildUrl(String.format(\"/api/monitors/alarm/id:%s/command:status.json\", id)));\n+            MonitorStateDTO monitorState = GSON.fromJson(response, MonitorStateDTO.class);\n+            if (monitorState != null) {\n+                MonitorState state = monitorState.state;\n+                return state != null ? state : MonitorState.UNKNOWN;\n+            }\n+        } catch (JsonSyntaxException e) {\n+            logger.debug(\"Bridge: JsonSyntaxException: {}\", e.getMessage(), e);\n+        }\n+        return MonitorState.UNKNOWN;\n+    }\n+\n+    public @Nullable String executeGet(String url) {\n+        try {\n+            long startTime = System.currentTimeMillis();\n+            String response = HttpUtil.executeUrl(\"GET\", url, API_TIMEOUT_MSEC);\n+            logger.trace(\"Bridge: Http GET of '{}' returned '{}' in {} ms\", url, response,\n+                    System.currentTimeMillis() - startTime);\n+            return response;\n+        } catch (IOException e) {\n+            logger.debug(\"Bridge: IOException on GET request, url='{}': {}\", url, e.getMessage());\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable String executePost(String url, String content) {\n+        return executePost(url, content, \"application/x-www-form-urlencoded\");\n+    }\n+\n+    public @Nullable String executePost(String url, String content, String contentType) {\n+        try (ByteArrayInputStream inputStream = new ByteArrayInputStream(content.getBytes())) {", "originalCommit": "48db60bb58bef52a99bb3a444ddc4de9e7528ea7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY3NjMwNA==", "url": "https://github.com/openhab/openhab-addons/pull/8530#discussion_r493676304", "bodyText": "Agreed. Done.", "author": "mhilbush", "createdAt": "2020-09-23T15:14:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjk5MzUxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzAwMDk1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8530#discussion_r493000952", "bodyText": "refreshImage() is already called asynchronously, why does getImage() need to be asynchronous then?", "author": "cpmeister", "createdAt": "2020-09-22T20:04:43Z", "path": "bundles/org.openhab.binding.zoneminder/src/main/java/org/openhab/binding/zoneminder/internal/handler/ZmMonitorHandler.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.zoneminder.internal.handler;\n+\n+import static org.openhab.binding.zoneminder.internal.ZmBindingConstants.*;\n+\n+import java.time.ZonedDateTime;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.zoneminder.action.ZmActions;\n+import org.openhab.binding.zoneminder.internal.config.ZmMonitorConfig;\n+import org.openhab.core.i18n.TimeZoneProvider;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SmartHomeUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ZmMonitorHandler} represents a Zoneminder monitor. The monitor handler\n+ * interacts with the server bridge to communicate with the Zoneminder server.\n+ *\n+ * @author Mark Hilbush - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ZmMonitorHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ZmMonitorHandler.class);\n+\n+    private final TimeZoneProvider timeZoneProvider;\n+\n+    private @Nullable ZmBridgeHandler bridgeHandler;\n+\n+    private @NonNullByDefault({}) String monitorId;\n+    private @Nullable Integer imageRefreshIntervalSeconds;\n+    private Integer alarmDuration = DEFAULT_ALARM_DURATION_SECONDS;\n+\n+    private @Nullable ScheduledFuture<?> imageRefreshJob;\n+    private @Nullable ScheduledFuture<?> alarmOffJob;\n+\n+    private final Map<String, State> monitorStatusCache = Collections.synchronizedMap(new HashMap<>());\n+\n+    public ZmMonitorHandler(Thing thing, TimeZoneProvider timeZoneProvider) {\n+        super(thing);\n+        this.timeZoneProvider = timeZoneProvider;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        ZmMonitorConfig config = getConfigAs(ZmMonitorConfig.class);\n+        monitorId = config.monitorId;\n+        imageRefreshIntervalSeconds = config.imageRefreshInterval;\n+        Integer value = config.alarmDuration;\n+        alarmDuration = value != null ? value : DEFAULT_ALARM_DURATION_SECONDS;\n+        bridgeHandler = (ZmBridgeHandler) getBridge().getHandler();\n+        monitorStatusCache.clear();\n+        updateStatus(ThingStatus.ONLINE);\n+        startImageRefreshJob();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopAlarmOffJob();\n+        turnAlarmOff();\n+        stopImageRefreshJob();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State state = monitorStatusCache.get(channelUID.getId());\n+            if (state != null) {\n+                updateState(channelUID, state);\n+            }\n+            return;\n+        }\n+        logger.debug(\"Monitor {}: Received command '{}' for channel '{}'\", monitorId, command, channelUID.getId());\n+        ZmBridgeHandler localHandler = bridgeHandler;\n+        if (localHandler == null) {\n+            logger.info(\"Monitor {}: Can't execute command because bridge handler is null\", monitorId);\n+            return;\n+        }\n+        switch (channelUID.getId()) {\n+            case CHANNEL_FUNCTION:\n+                if (command instanceof StringType) {\n+                    try {\n+                        MonitorFunction function = MonitorFunction.forValue(command.toString());\n+                        localHandler.setFunction(monitorId, function);\n+                        logger.debug(\"Monitor {}: Set monitor state to {}\", monitorId, function);\n+                    } catch (IllegalArgumentException e) {\n+                        logger.debug(\"Monitor {}: Invalid function: {}\", monitorId, command);\n+                    }\n+                }\n+                break;\n+            case CHANNEL_ENABLE:\n+                if (command instanceof OnOffType) {\n+                    localHandler.setEnabled(monitorId, (OnOffType) command);\n+                    logger.debug(\"Monitor {}: Set monitor enable to {}\", monitorId, command);\n+                }\n+                break;\n+            case CHANNEL_TRIGGER_ALARM:\n+                if (command instanceof OnOffType) {\n+                    logger.debug(\"Monitor {}: Set monitor alarm to {}\", monitorId, command);\n+                    if (command == OnOffType.ON) {\n+                        localHandler.setAlarmOn(monitorId);\n+                        startAlarmOffJob(alarmDuration.intValue());\n+                    } else {\n+                        stopAlarmOffJob();\n+                        localHandler.setAlarmOff(monitorId);\n+                    }\n+                }\n+                break;\n+        }\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(ZmActions.class);\n+    }\n+\n+    public String getId() {\n+        return monitorId;\n+    }\n+\n+    public void actionTriggerAlarm(@Nullable Number duration) {\n+        if (duration == null) {\n+            return;\n+        }\n+        ZmBridgeHandler localHandler = bridgeHandler;\n+        if (localHandler != null) {\n+            logger.debug(\"Monitor {}: Action tell bridge to turn on alarm\", monitorId);\n+            localHandler.setAlarmOn(monitorId);\n+            startAlarmOffJob(duration.intValue());\n+        }\n+    }\n+\n+    public void actionTriggerAlarm() {\n+        actionTriggerAlarm(alarmDuration);\n+    }\n+\n+    public void actionCancelAlarm() {\n+        ZmBridgeHandler localHandler = bridgeHandler;\n+        if (localHandler != null) {\n+            logger.debug(\"Monitor {}: Action tell bridge to turn off alarm\", monitorId);\n+            stopAlarmOffJob();\n+            localHandler.setAlarmOff(monitorId);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public void updateStatus(Monitor m) {\n+        logger.debug(\"Monitor {}: Updating: {}\", m.getId(), m.toString());\n+        updateChannelState(CHANNEL_ID, new StringType(m.getId()));\n+        updateChannelState(CHANNEL_NAME, new StringType(m.getName()));\n+        updateChannelState(CHANNEL_FUNCTION, new StringType(m.getFunction()));\n+        updateChannelState(CHANNEL_ENABLE, m.isEnabled() ? OnOffType.ON : OnOffType.OFF);\n+        updateChannelState(CHANNEL_HOUR_EVENTS, new DecimalType(m.getHourEvents()));\n+        updateChannelState(CHANNEL_DAY_EVENTS, new DecimalType(m.getDayEvents()));\n+        updateChannelState(CHANNEL_WEEK_EVENTS, new DecimalType(m.getWeekEvents()));\n+        updateChannelState(CHANNEL_MONTH_EVENTS, new DecimalType(m.getMonthEvents()));\n+        updateChannelState(CHANNEL_TOTAL_EVENTS, new DecimalType(m.getTotalEvents()));\n+        updateChannelState(CHANNEL_IMAGE_URL, new StringType(m.getImageUrl()));\n+        updateChannelState(CHANNEL_VIDEO_URL, new StringType(m.getVideoUrl()));\n+        updateChannelState(CHANNEL_ALARM, m.isAlarm() ? OnOffType.ON : OnOffType.OFF);\n+        updateChannelState(CHANNEL_STATE, new StringType(m.getState().toString()));\n+        if (!m.isAlarm()) {\n+            updateChannelState(CHANNEL_TRIGGER_ALARM, m.isAlarm() ? OnOffType.ON : OnOffType.OFF);\n+        }\n+        Event event = m.getLastEvent();\n+        if (event == null) {\n+            clearEventChannels();\n+        } else if (event.getEnd() != null) {\n+            // If end is null, assume event hasn't completed yet\n+            logger.trace(\"Monitor {}: Id:{}, Frames:{}, AlarmFrames:{}, Length:{}\", m.getId(), event.getId(),\n+                    event.getFrames(), event.getAlarmFrames(), event.getLength());\n+            updateChannelState(CHANNEL_EVENT_ID, new StringType(event.getId()));\n+            updateChannelState(CHANNEL_EVENT_NAME, new StringType(event.getName()));\n+            updateChannelState(CHANNEL_EVENT_CAUSE, new StringType(event.getCause()));\n+            updateChannelState(CHANNEL_EVENT_NOTES, new StringType(event.getNotes()));\n+            updateChannelState(CHANNEL_EVENT_START, new DateTimeType(\n+                    ZonedDateTime.ofInstant(event.getStart().toInstant(), timeZoneProvider.getTimeZone())));\n+            updateChannelState(CHANNEL_EVENT_END, new DateTimeType(\n+                    ZonedDateTime.ofInstant(event.getEnd().toInstant(), timeZoneProvider.getTimeZone())));\n+            updateChannelState(CHANNEL_EVENT_FRAMES, new DecimalType(event.getFrames()));\n+            updateChannelState(CHANNEL_EVENT_ALARM_FRAMES, new DecimalType(event.getAlarmFrames()));\n+            updateChannelState(CHANNEL_EVENT_LENGTH, new QuantityType<Time>(event.getLength(), SmartHomeUnits.SECOND));\n+        }\n+    }\n+\n+    private void clearEventChannels() {\n+        updateChannelState(CHANNEL_EVENT_ID, UnDefType.NULL);\n+        updateChannelState(CHANNEL_EVENT_NAME, UnDefType.NULL);\n+        updateChannelState(CHANNEL_EVENT_CAUSE, UnDefType.NULL);\n+        updateChannelState(CHANNEL_EVENT_NOTES, UnDefType.NULL);\n+        updateChannelState(CHANNEL_EVENT_START, UnDefType.NULL);\n+        updateChannelState(CHANNEL_EVENT_END, UnDefType.NULL);\n+        updateChannelState(CHANNEL_EVENT_FRAMES, UnDefType.NULL);\n+        updateChannelState(CHANNEL_EVENT_ALARM_FRAMES, UnDefType.NULL);\n+        updateChannelState(CHANNEL_EVENT_LENGTH, UnDefType.NULL);\n+    }\n+\n+    private void refreshImage() {\n+        if (isLinked(CHANNEL_IMAGE)) {\n+            scheduler.execute(this::getImage);", "originalCommit": "48db60bb58bef52a99bb3a444ddc4de9e7528ea7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY1Nzg1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8530#discussion_r493657852", "bodyText": "My original thinking was that I didn't want refreshImage to block waiting for the image. But, I can't think of a reason why that would be necessary. I've removed it.", "author": "mhilbush", "createdAt": "2020-09-23T14:51:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzAwMDk1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzAwMjUwMg==", "url": "https://github.com/openhab/openhab-addons/pull/8530#discussion_r493002502", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final Map<String, State> monitorStatusCache = Collections.synchronizedMap(new HashMap<>());\n          \n          \n            \n                private final Map<String, State> monitorStatusCache = new ConcurrentHashMap<>();", "author": "cpmeister", "createdAt": "2020-09-22T20:07:46Z", "path": "bundles/org.openhab.binding.zoneminder/src/main/java/org/openhab/binding/zoneminder/internal/handler/ZmMonitorHandler.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.zoneminder.internal.handler;\n+\n+import static org.openhab.binding.zoneminder.internal.ZmBindingConstants.*;\n+\n+import java.time.ZonedDateTime;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.zoneminder.action.ZmActions;\n+import org.openhab.binding.zoneminder.internal.config.ZmMonitorConfig;\n+import org.openhab.core.i18n.TimeZoneProvider;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SmartHomeUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ZmMonitorHandler} represents a Zoneminder monitor. The monitor handler\n+ * interacts with the server bridge to communicate with the Zoneminder server.\n+ *\n+ * @author Mark Hilbush - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ZmMonitorHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ZmMonitorHandler.class);\n+\n+    private final TimeZoneProvider timeZoneProvider;\n+\n+    private @Nullable ZmBridgeHandler bridgeHandler;\n+\n+    private @NonNullByDefault({}) String monitorId;\n+    private @Nullable Integer imageRefreshIntervalSeconds;\n+    private Integer alarmDuration = DEFAULT_ALARM_DURATION_SECONDS;\n+\n+    private @Nullable ScheduledFuture<?> imageRefreshJob;\n+    private @Nullable ScheduledFuture<?> alarmOffJob;\n+\n+    private final Map<String, State> monitorStatusCache = Collections.synchronizedMap(new HashMap<>());", "originalCommit": "48db60bb58bef52a99bb3a444ddc4de9e7528ea7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzYwODM1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8530#discussion_r493608359", "bodyText": "Done", "author": "mhilbush", "createdAt": "2020-09-23T13:50:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzAwMjUwMg=="}], "type": "inlineReview"}, {"oid": "20d9a6d6d8c1b8ac6de1c167ffdf0de1af49b64d", "url": "https://github.com/openhab/openhab-addons/commit/20d9a6d6d8c1b8ac6de1c167ffdf0de1af49b64d", "message": "Replacement for zoneminder binding\n\nSigned-off-by: Mark Hilbush <mark@hilbush.com>", "committedDate": "2020-09-23T20:11:01Z", "type": "commit"}, {"oid": "8b80db5675027f963e824292ea6b878dd9cc4c3c", "url": "https://github.com/openhab/openhab-addons/commit/8b80db5675027f963e824292ea6b878dd9cc4c3c", "message": "Change owner\n\nSigned-off-by: Mark Hilbush <mark@hilbush.com>", "committedDate": "2020-09-23T20:12:17Z", "type": "commit"}, {"oid": "a5a2851830a2186246ec4a579bfc982029ac9f33", "url": "https://github.com/openhab/openhab-addons/commit/a5a2851830a2186246ec4a579bfc982029ac9f33", "message": "Fixes\n\nSigned-off-by: Mark Hilbush <mark@hilbush.com>", "committedDate": "2020-09-23T20:12:18Z", "type": "commit"}, {"oid": "c295c5514348fee55c7e920e03c763e53a87ba1e", "url": "https://github.com/openhab/openhab-addons/commit/c295c5514348fee55c7e920e03c763e53a87ba1e", "message": "Address review comments\n\nSigned-off-by: Mark Hilbush <mark@hilbush.com>", "committedDate": "2020-09-23T20:12:18Z", "type": "commit"}, {"oid": "f6288d2634efa87e7befa54c561683337391b337", "url": "https://github.com/openhab/openhab-addons/commit/f6288d2634efa87e7befa54c561683337391b337", "message": "Fix required parameters\n\nSigned-off-by: Mark Hilbush <mark@hilbush.com>", "committedDate": "2020-09-23T20:12:18Z", "type": "commit"}, {"oid": "669651fcc78e6068dfb618d8c5e9c2dd46609352", "url": "https://github.com/openhab/openhab-addons/commit/669651fcc78e6068dfb618d8c5e9c2dd46609352", "message": "Fix formatting issue to fix build\n\nSigned-off-by: Mark Hilbush <mark@hilbush.com>", "committedDate": "2020-09-23T20:12:18Z", "type": "commit"}, {"oid": "669651fcc78e6068dfb618d8c5e9c2dd46609352", "url": "https://github.com/openhab/openhab-addons/commit/669651fcc78e6068dfb618d8c5e9c2dd46609352", "message": "Fix formatting issue to fix build\n\nSigned-off-by: Mark Hilbush <mark@hilbush.com>", "committedDate": "2020-09-23T20:12:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkwNDg3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8530#discussion_r498904873", "bodyText": "I think the Proxy workaround for Actions isn't needed anymore for OH3. @cweitkamp Please correct me if I'm wrong.", "author": "fwolter", "createdAt": "2020-10-02T15:49:15Z", "path": "bundles/org.openhab.binding.zoneminder/src/main/java/org/openhab/binding/zoneminder/action/ZmActions.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.zoneminder.action;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.zoneminder.internal.handler.ZmMonitorHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingActionsScope;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ZmActions} defines the thing actions provided by this binding.\n+ *\n+ * <b>Note:</b>The static method <b>invokeMethodOf</b> handles the case where\n+ * the test <i>actions instanceof ZmActions</i> fails. This test can fail\n+ * due to an issue in openHAB core v2.5.0 where the {@link ZmActions} class\n+ * can be loaded by a different classloader than the <i>actions</i> instance.\n+ *\n+ * @author Mark Hilbush - Initial contribution\n+ */\n+@ThingActionsScope(name = \"zm\")\n+@NonNullByDefault\n+public class ZmActions implements ThingActions, IZmActions {\n+    private final Logger logger = LoggerFactory.getLogger(ZmActions.class);\n+\n+    private @Nullable ZmMonitorHandler handler;\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return this.handler;\n+    }\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler handler) {\n+        if (handler instanceof ZmMonitorHandler) {\n+            this.handler = (ZmMonitorHandler) handler;\n+        }\n+    }\n+\n+    private static IZmActions invokeMethodOf(@Nullable ThingActions actions) {\n+        if (actions == null) {\n+            throw new IllegalArgumentException(\"actions cannot be null\");\n+        }\n+        if (actions.getClass().getName().equals(ZmActions.class.getName())) {\n+            if (actions instanceof IZmActions) {\n+                return (IZmActions) actions;\n+            } else {\n+                return (IZmActions) Proxy.newProxyInstance(IZmActions.class.getClassLoader(),\n+                        new Class[] { IZmActions.class }, (Object proxy, Method method, Object[] args) -> {\n+                            Method m = actions.getClass().getDeclaredMethod(method.getName(),\n+                                    method.getParameterTypes());\n+                            return m.invoke(actions, args);\n+                        });\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Actions is not an instance of ZmActions\");\n+    }", "originalCommit": "669651fcc78e6068dfb618d8c5e9c2dd46609352", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDI4NTgyMA==", "url": "https://github.com/openhab/openhab-addons/pull/8530#discussion_r500285820", "bodyText": "Since DSL rules will still be supported in OH3, I don't recall seeing anything that fixes the root cause of the issue. And the issue in core is still open. But @cweitkamp would know for sure. Let wait for his reply.", "author": "mhilbush", "createdAt": "2020-10-06T13:39:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkwNDg3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDM5NTY5MA==", "url": "https://github.com/openhab/openhab-addons/pull/8530#discussion_r500395690", "bodyText": "Please correct me if I am wrong, I am not really up-to-date right now: IIRC there was no real confirmation for ThingActions to be working correctly in OH3 NGRE and we wanted to keep those workarounds and bulk remove them later.", "author": "cweitkamp", "createdAt": "2020-10-06T15:33:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkwNDg3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkwNTM0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8530#discussion_r498905347", "bodyText": "Logging to info should be used rarely. This could be debug or warn. Same for below.", "author": "fwolter", "createdAt": "2020-10-02T15:50:07Z", "path": "bundles/org.openhab.binding.zoneminder/src/main/java/org/openhab/binding/zoneminder/action/ZmActions.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.zoneminder.action;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.zoneminder.internal.handler.ZmMonitorHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingActionsScope;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ZmActions} defines the thing actions provided by this binding.\n+ *\n+ * <b>Note:</b>The static method <b>invokeMethodOf</b> handles the case where\n+ * the test <i>actions instanceof ZmActions</i> fails. This test can fail\n+ * due to an issue in openHAB core v2.5.0 where the {@link ZmActions} class\n+ * can be loaded by a different classloader than the <i>actions</i> instance.\n+ *\n+ * @author Mark Hilbush - Initial contribution\n+ */\n+@ThingActionsScope(name = \"zm\")\n+@NonNullByDefault\n+public class ZmActions implements ThingActions, IZmActions {\n+    private final Logger logger = LoggerFactory.getLogger(ZmActions.class);\n+\n+    private @Nullable ZmMonitorHandler handler;\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return this.handler;\n+    }\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler handler) {\n+        if (handler instanceof ZmMonitorHandler) {\n+            this.handler = (ZmMonitorHandler) handler;\n+        }\n+    }\n+\n+    private static IZmActions invokeMethodOf(@Nullable ThingActions actions) {\n+        if (actions == null) {\n+            throw new IllegalArgumentException(\"actions cannot be null\");\n+        }\n+        if (actions.getClass().getName().equals(ZmActions.class.getName())) {\n+            if (actions instanceof IZmActions) {\n+                return (IZmActions) actions;\n+            } else {\n+                return (IZmActions) Proxy.newProxyInstance(IZmActions.class.getClassLoader(),\n+                        new Class[] { IZmActions.class }, (Object proxy, Method method, Object[] args) -> {\n+                            Method m = actions.getClass().getDeclaredMethod(method.getName(),\n+                                    method.getParameterTypes());\n+                            return m.invoke(actions, args);\n+                        });\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Actions is not an instance of ZmActions\");\n+    }\n+\n+    /**\n+     * The Trigger Alarm function triggers an alarm that will run for the number of seconds\n+     * specified by the supplied parameter duration.\n+     */\n+    @Override\n+    @RuleAction(label = \"TriggerAlarm\", description = \"Trigger an alarm on the monitor.\")\n+    public void triggerAlarm(\n+            @ActionInput(name = \"duration\", description = \"The duration of the alarm in seconds.\") @Nullable Number duration) {\n+        logger.debug(\"ZmActions: Action 'TriggerAlarm' called\");\n+        ZmMonitorHandler localHandler = handler;\n+        if (localHandler == null) {\n+            logger.info(\"ZmActions: Action service ThingHandler is null!\");", "originalCommit": "669651fcc78e6068dfb618d8c5e9c2dd46609352", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDMwMzE2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8530#discussion_r500303167", "bodyText": "Some bindings use info, but most use warn. I'll make it warn.", "author": "mhilbush", "createdAt": "2020-10-06T13:57:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkwNTM0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxMjM1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8530#discussion_r498912352", "bodyText": "This could be debug or warn.", "author": "fwolter", "createdAt": "2020-10-02T16:03:21Z", "path": "bundles/org.openhab.binding.zoneminder/src/main/java/org/openhab/binding/zoneminder/internal/handler/ZmMonitorHandler.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.zoneminder.internal.handler;\n+\n+import static org.openhab.binding.zoneminder.internal.ZmBindingConstants.*;\n+\n+import java.time.ZonedDateTime;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Time;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.zoneminder.action.ZmActions;\n+import org.openhab.binding.zoneminder.internal.config.ZmMonitorConfig;\n+import org.openhab.core.i18n.TimeZoneProvider;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.library.unit.SmartHomeUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ZmMonitorHandler} represents a Zoneminder monitor. The monitor handler\n+ * interacts with the server bridge to communicate with the Zoneminder server.\n+ *\n+ * @author Mark Hilbush - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ZmMonitorHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ZmMonitorHandler.class);\n+\n+    private final TimeZoneProvider timeZoneProvider;\n+\n+    private @Nullable ZmBridgeHandler bridgeHandler;\n+\n+    private @NonNullByDefault({}) String monitorId;\n+    private @Nullable Integer imageRefreshIntervalSeconds;\n+    private Integer alarmDuration = DEFAULT_ALARM_DURATION_SECONDS;\n+\n+    private @Nullable ScheduledFuture<?> imageRefreshJob;\n+    private @Nullable ScheduledFuture<?> alarmOffJob;\n+\n+    private final Map<String, State> monitorStatusCache = new ConcurrentHashMap<>();\n+\n+    public ZmMonitorHandler(Thing thing, TimeZoneProvider timeZoneProvider) {\n+        super(thing);\n+        this.timeZoneProvider = timeZoneProvider;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        ZmMonitorConfig config = getConfigAs(ZmMonitorConfig.class);\n+        monitorId = config.monitorId;\n+        imageRefreshIntervalSeconds = config.imageRefreshInterval;\n+        Integer value = config.alarmDuration;\n+        alarmDuration = value != null ? value : DEFAULT_ALARM_DURATION_SECONDS;\n+        bridgeHandler = (ZmBridgeHandler) getBridge().getHandler();\n+        monitorStatusCache.clear();\n+        updateStatus(ThingStatus.ONLINE);\n+        startImageRefreshJob();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopAlarmOffJob();\n+        turnAlarmOff();\n+        stopImageRefreshJob();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State state = monitorStatusCache.get(channelUID.getId());\n+            if (state != null) {\n+                updateState(channelUID, state);\n+            }\n+            return;\n+        }\n+        logger.debug(\"Monitor {}: Received command '{}' for channel '{}'\", monitorId, command, channelUID.getId());\n+        ZmBridgeHandler localHandler = bridgeHandler;\n+        if (localHandler == null) {\n+            logger.info(\"Monitor {}: Can't execute command because bridge handler is null\", monitorId);", "originalCommit": "669651fcc78e6068dfb618d8c5e9c2dd46609352", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDMwMzI0MA==", "url": "https://github.com/openhab/openhab-addons/pull/8530#discussion_r500303240", "bodyText": "Probably should be warn.", "author": "mhilbush", "createdAt": "2020-10-06T13:57:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxMjM1Mg=="}], "type": "inlineReview"}, {"oid": "374a56eab817d0ec3c95beb91001f4c662cf1ad2", "url": "https://github.com/openhab/openhab-addons/commit/374a56eab817d0ec3c95beb91001f4c662cf1ad2", "message": "Address review feedback\n\nSigned-off-by: Mark Hilbush <mark@hilbush.com>", "committedDate": "2020-10-06T14:47:52Z", "type": "commit"}, {"oid": "0ec771ca07692f13e5915747f0c38d476062cb0f", "url": "https://github.com/openhab/openhab-addons/commit/0ec771ca07692f13e5915747f0c38d476062cb0f", "message": "Rework URL path config parameters\n\nSigned-off-by: Mark Hilbush <mark@hilbush.com>", "committedDate": "2020-10-06T17:04:38Z", "type": "commit"}, {"oid": "32fa39dea64bab5d98e415865312d02ca2d9db42", "url": "https://github.com/openhab/openhab-addons/commit/32fa39dea64bab5d98e415865312d02ca2d9db42", "message": "Fix documentation\n\nSigned-off-by: Mark Hilbush <mark@hilbush.com>", "committedDate": "2020-10-06T17:07:09Z", "type": "commit"}]}