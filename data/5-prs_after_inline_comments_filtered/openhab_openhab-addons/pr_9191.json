{"pr_number": 9191, "pr_title": "[Qbus] Initial contribution", "pr_createdAt": "2020-12-01T10:35:35Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/9191", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk3MDQzNw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r541970437", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final Set<ThingTypeUID> SCENE_THING_TYPES_UIDS = Collections\n          \n          \n            \n                        .unmodifiableSet(Stream.of(THING_TYPE_SCENE).collect(Collectors.toSet()));\n          \n          \n            \n                public static final Set<ThingTypeUID> SCENE_THING_TYPES_UIDS = Set.of(THING_TYPE_SCENE);", "author": "fwolter", "createdAt": "2020-12-13T17:42:15Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBindingConstants.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link QbusBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Koen Schockaert - Initial contribution\n+ */\n+@NonNullByDefault\n+public class QbusBindingConstants {\n+\n+    private static final String BINDING_ID = \"qbus\";\n+\n+    // bridge\n+    public static final ThingTypeUID BRIDGE_THING_TYPE = new ThingTypeUID(BINDING_ID, \"bridge\");\n+    public static final Set<ThingTypeUID> BRIDGE_THING_TYPES_UIDS = Collections.singleton(BRIDGE_THING_TYPE);\n+    // Bridge config properties\n+    public static final String CONFIG_HOST_NAME = \"addr\";\n+    public static final String CONFIG_PORT = \"port\";\n+    public static final String CONFIG_REFRESH = \"refresh\";\n+    public static final String CONFIG_SN = \"sn\";\n+\n+    // generic thing types\n+    public static final ThingTypeUID THING_TYPE_CO2 = new ThingTypeUID(BINDING_ID, \"co2\");\n+    public static final ThingTypeUID THING_TYPE_SCENE = new ThingTypeUID(BINDING_ID, \"scene\");\n+    public static final ThingTypeUID THING_TYPE_TIMER_LIGHT = new ThingTypeUID(BINDING_ID, \"onOff\");\n+    public static final ThingTypeUID THING_TYPE_ON_OFF_LIGHT = new ThingTypeUID(BINDING_ID, \"onOff\");\n+    public static final ThingTypeUID THING_TYPE_DIMMABLE_LIGHT = new ThingTypeUID(BINDING_ID, \"dimmer\");\n+    public static final ThingTypeUID THING_TYPE_ROLLERSHUTTER = new ThingTypeUID(BINDING_ID, \"rollershutter\");\n+    public static final ThingTypeUID THING_TYPE_ROLLERSHUTTER_SLATS = new ThingTypeUID(BINDING_ID,\n+            \"rollershutter_slats\");\n+    public static final ThingTypeUID THING_TYPE_THERMOSTAT = new ThingTypeUID(BINDING_ID, \"thermostat\");\n+    // List of all Thing Type UIDs\n+    public static final Set<ThingTypeUID> SCENE_THING_TYPES_UIDS = Collections\n+            .unmodifiableSet(Stream.of(THING_TYPE_SCENE).collect(Collectors.toSet()));", "originalCommit": "a4206928c61b76cec182bd1519a99802abb945d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk3MDUyMw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r541970523", "bodyText": "Can this message be replaced by using the debugger or by increasing the framework's log level? See point 4 https://www.openhab.org/docs/developer/guidelines.html#f-logging", "author": "fwolter", "createdAt": "2020-12-13T17:42:43Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private QbusCommunication qbusComm;\n+\n+    private ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // There is nothing to handle in the bridge handler\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"QBUS: initializing bridge handler\");", "originalCommit": "a4206928c61b76cec182bd1519a99802abb945d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk3MDU3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r541970573", "bodyText": "Can this message be replaced by using the debugger or by increasing the framework's log level? See point 4 https://www.openhab.org/docs/developer/guidelines.html#f-logging", "author": "fwolter", "createdAt": "2020-12-13T17:43:04Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private QbusCommunication qbusComm;\n+\n+    private ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // There is nothing to handle in the bridge handler\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"QBUS: initializing bridge handler\");\n+\n+        Configuration config = this.getConfig();\n+        InetAddress addr = getAddr();\n+        int port = getPort();\n+\n+        logger.debug(\"Qbus: bridge handler host {}, port {}\", addr, port);", "originalCommit": "a4206928c61b76cec182bd1519a99802abb945d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk3MDYyNg==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r541970626", "bodyText": "Isn't this rather a configuration error than a communication error?\n\"Qbus: \" is redundant here as the UI will show the message in context.", "author": "fwolter", "createdAt": "2020-12-13T17:43:32Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private QbusCommunication qbusComm;\n+\n+    private ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // There is nothing to handle in the bridge handler\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"QBUS: initializing bridge handler\");\n+\n+        Configuration config = this.getConfig();\n+        InetAddress addr = getAddr();\n+        int port = getPort();\n+\n+        logger.debug(\"Qbus: bridge handler host {}, port {}\", addr, port);\n+\n+        if (addr != null) {\n+            createCommunicationObject(addr, port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Qbus: cannot resolve bridge IP with hostname \" + config.get(CONFIG_HOST_NAME));", "originalCommit": "a4206928c61b76cec182bd1519a99802abb945d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk3MDk2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r541970967", "bodyText": "Primitive types should be used where possible.", "author": "fwolter", "createdAt": "2020-12-13T17:45:16Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private QbusCommunication qbusComm;\n+\n+    private ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // There is nothing to handle in the bridge handler\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"QBUS: initializing bridge handler\");\n+\n+        Configuration config = this.getConfig();\n+        InetAddress addr = getAddr();\n+        int port = getPort();\n+\n+        logger.debug(\"Qbus: bridge handler host {}, port {}\", addr, port);\n+\n+        if (addr != null) {\n+            createCommunicationObject(addr, port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Qbus: cannot resolve bridge IP with hostname \" + config.get(CONFIG_HOST_NAME));\n+        }\n+    }\n+\n+    /**\n+     * Create communication object to Qbus server and start communication.\n+     *\n+     * @param addr : IP address of Qbus server\n+     * @param port : Communication port of QbusServer\n+     * @param sn : Serial number of Controller\n+     */\n+    private void createCommunicationObject(InetAddress addr, int port) {\n+        Configuration config = this.getConfig();\n+        scheduler.submit(() -> {\n+            qbusComm = new QbusCommunication();\n+\n+            // Set callback from Qbus object to this bridge to be able to take bridge\n+            // offline when non-resolvable communication error occurs.\n+            setBridgeCallBack();\n+\n+            qbusComm.startCommunication();\n+            if (!qbusComm.communicationActive()) {\n+                qbusComm = null;\n+                bridgeOffline();\n+                return;\n+            }\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            Integer refreshInterval = ((Number) config.get(CONFIG_REFRESH)).intValue();", "originalCommit": "a4206928c61b76cec182bd1519a99802abb945d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk3MTA5OA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r541971098", "bodyText": "The binding's name will be included in the log messages. Please check all.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.debug(\"Qbus: Checking for Client communication every {} min\", refreshInterval);\n          \n          \n            \n                    logger.debug(\"Checking for Client communication every {} min\", refreshInterval);", "author": "fwolter", "createdAt": "2020-12-13T17:46:06Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private QbusCommunication qbusComm;\n+\n+    private ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // There is nothing to handle in the bridge handler\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"QBUS: initializing bridge handler\");\n+\n+        Configuration config = this.getConfig();\n+        InetAddress addr = getAddr();\n+        int port = getPort();\n+\n+        logger.debug(\"Qbus: bridge handler host {}, port {}\", addr, port);\n+\n+        if (addr != null) {\n+            createCommunicationObject(addr, port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Qbus: cannot resolve bridge IP with hostname \" + config.get(CONFIG_HOST_NAME));\n+        }\n+    }\n+\n+    /**\n+     * Create communication object to Qbus server and start communication.\n+     *\n+     * @param addr : IP address of Qbus server\n+     * @param port : Communication port of QbusServer\n+     * @param sn : Serial number of Controller\n+     */\n+    private void createCommunicationObject(InetAddress addr, int port) {\n+        Configuration config = this.getConfig();\n+        scheduler.submit(() -> {\n+            qbusComm = new QbusCommunication();\n+\n+            // Set callback from Qbus object to this bridge to be able to take bridge\n+            // offline when non-resolvable communication error occurs.\n+            setBridgeCallBack();\n+\n+            qbusComm.startCommunication();\n+            if (!qbusComm.communicationActive()) {\n+                qbusComm = null;\n+                bridgeOffline();\n+                return;\n+            }\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            Integer refreshInterval = ((Number) config.get(CONFIG_REFRESH)).intValue();\n+            setupRefreshTimer(refreshInterval);\n+\n+        });\n+    }\n+\n+    private void setBridgeCallBack() {\n+        this.qbusComm.setBridgeCallBack(this);\n+    }\n+\n+    /**\n+     * Schedule future communication refresh.\n+     *\n+     * @param interval_config Time before refresh in minutes.\n+     */\n+    private void setupRefreshTimer(Integer refreshInterval) {\n+        if (this.refreshTimer != null) {\n+            this.refreshTimer.cancel(true);\n+            this.refreshTimer = null;\n+        }\n+\n+        if ((refreshInterval == null) || (refreshInterval == 0)) {\n+            return;\n+        }\n+\n+        // This timer will restart the bridge connection periodically\n+        logger.debug(\"Qbus: Checking for Client communication every {} min\", refreshInterval);", "originalCommit": "a4206928c61b76cec182bd1519a99802abb945d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk3MTI1MA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r541971250", "bodyText": "Can you set the ThingStatusDetail and a message why this is offline? You could retrieve a message by letting communicationActive() throw an exception, instead of returning a boolean.", "author": "fwolter", "createdAt": "2020-12-13T17:47:07Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private QbusCommunication qbusComm;\n+\n+    private ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // There is nothing to handle in the bridge handler\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"QBUS: initializing bridge handler\");\n+\n+        Configuration config = this.getConfig();\n+        InetAddress addr = getAddr();\n+        int port = getPort();\n+\n+        logger.debug(\"Qbus: bridge handler host {}, port {}\", addr, port);\n+\n+        if (addr != null) {\n+            createCommunicationObject(addr, port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Qbus: cannot resolve bridge IP with hostname \" + config.get(CONFIG_HOST_NAME));\n+        }\n+    }\n+\n+    /**\n+     * Create communication object to Qbus server and start communication.\n+     *\n+     * @param addr : IP address of Qbus server\n+     * @param port : Communication port of QbusServer\n+     * @param sn : Serial number of Controller\n+     */\n+    private void createCommunicationObject(InetAddress addr, int port) {\n+        Configuration config = this.getConfig();\n+        scheduler.submit(() -> {\n+            qbusComm = new QbusCommunication();\n+\n+            // Set callback from Qbus object to this bridge to be able to take bridge\n+            // offline when non-resolvable communication error occurs.\n+            setBridgeCallBack();\n+\n+            qbusComm.startCommunication();\n+            if (!qbusComm.communicationActive()) {\n+                qbusComm = null;\n+                bridgeOffline();\n+                return;\n+            }\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            Integer refreshInterval = ((Number) config.get(CONFIG_REFRESH)).intValue();\n+            setupRefreshTimer(refreshInterval);\n+\n+        });\n+    }\n+\n+    private void setBridgeCallBack() {\n+        this.qbusComm.setBridgeCallBack(this);\n+    }\n+\n+    /**\n+     * Schedule future communication refresh.\n+     *\n+     * @param interval_config Time before refresh in minutes.\n+     */\n+    private void setupRefreshTimer(Integer refreshInterval) {\n+        if (this.refreshTimer != null) {\n+            this.refreshTimer.cancel(true);\n+            this.refreshTimer = null;\n+        }\n+\n+        if ((refreshInterval == null) || (refreshInterval == 0)) {\n+            return;\n+        }\n+\n+        // This timer will restart the bridge connection periodically\n+        logger.debug(\"Qbus: Checking for Client communication every {} min\", refreshInterval);\n+        this.refreshTimer = scheduler.scheduleWithFixedDelay(() -> {\n+            logger.debug(\"Qbus: check communication after timerinterval\");\n+\n+            if (!qbusComm.communicationActive()) {\n+                logger.debug(\"Qbus: Restarting communication\");\n+                qbusComm.restartCommunication();\n+\n+                if (!qbusComm.communicationActive()) {\n+                    qbusComm = null;\n+                    bridgeOffline();\n+                    updateStatus(ThingStatus.OFFLINE);", "originalCommit": "a4206928c61b76cec182bd1519a99802abb945d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk3MTQyMg==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r541971422", "bodyText": "Can this be removed?", "author": "fwolter", "createdAt": "2020-12-13T17:48:12Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private QbusCommunication qbusComm;\n+\n+    private ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // There is nothing to handle in the bridge handler\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"QBUS: initializing bridge handler\");\n+\n+        Configuration config = this.getConfig();\n+        InetAddress addr = getAddr();\n+        int port = getPort();\n+\n+        logger.debug(\"Qbus: bridge handler host {}, port {}\", addr, port);\n+\n+        if (addr != null) {\n+            createCommunicationObject(addr, port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Qbus: cannot resolve bridge IP with hostname \" + config.get(CONFIG_HOST_NAME));\n+        }\n+    }\n+\n+    /**\n+     * Create communication object to Qbus server and start communication.\n+     *\n+     * @param addr : IP address of Qbus server\n+     * @param port : Communication port of QbusServer\n+     * @param sn : Serial number of Controller\n+     */\n+    private void createCommunicationObject(InetAddress addr, int port) {\n+        Configuration config = this.getConfig();\n+        scheduler.submit(() -> {\n+            qbusComm = new QbusCommunication();\n+\n+            // Set callback from Qbus object to this bridge to be able to take bridge\n+            // offline when non-resolvable communication error occurs.\n+            setBridgeCallBack();\n+\n+            qbusComm.startCommunication();\n+            if (!qbusComm.communicationActive()) {\n+                qbusComm = null;\n+                bridgeOffline();\n+                return;\n+            }\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            Integer refreshInterval = ((Number) config.get(CONFIG_REFRESH)).intValue();\n+            setupRefreshTimer(refreshInterval);\n+\n+        });\n+    }\n+\n+    private void setBridgeCallBack() {\n+        this.qbusComm.setBridgeCallBack(this);\n+    }\n+\n+    /**\n+     * Schedule future communication refresh.\n+     *\n+     * @param interval_config Time before refresh in minutes.\n+     */\n+    private void setupRefreshTimer(Integer refreshInterval) {\n+        if (this.refreshTimer != null) {\n+            this.refreshTimer.cancel(true);\n+            this.refreshTimer = null;\n+        }\n+\n+        if ((refreshInterval == null) || (refreshInterval == 0)) {\n+            return;\n+        }\n+\n+        // This timer will restart the bridge connection periodically\n+        logger.debug(\"Qbus: Checking for Client communication every {} min\", refreshInterval);\n+        this.refreshTimer = scheduler.scheduleWithFixedDelay(() -> {\n+            logger.debug(\"Qbus: check communication after timerinterval\");\n+\n+            if (!qbusComm.communicationActive()) {\n+                logger.debug(\"Qbus: Restarting communication\");\n+                qbusComm.restartCommunication();\n+\n+                if (!qbusComm.communicationActive()) {\n+                    qbusComm = null;\n+                    bridgeOffline();\n+                    updateStatus(ThingStatus.OFFLINE);\n+                    return;\n+                }\n+\n+                // updateStatus(ThingStatus.ONLINE);", "originalCommit": "a4206928c61b76cec182bd1519a99802abb945d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk3MTQ0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r541971445", "bodyText": "Can this message be replaced by using the debugger or by increasing the framework's log level? See point 4 https://www.openhab.org/docs/developer/guidelines.html#f-logging\nPlease check all.", "author": "fwolter", "createdAt": "2020-12-13T17:48:26Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private QbusCommunication qbusComm;\n+\n+    private ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // There is nothing to handle in the bridge handler\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"QBUS: initializing bridge handler\");\n+\n+        Configuration config = this.getConfig();\n+        InetAddress addr = getAddr();\n+        int port = getPort();\n+\n+        logger.debug(\"Qbus: bridge handler host {}, port {}\", addr, port);\n+\n+        if (addr != null) {\n+            createCommunicationObject(addr, port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Qbus: cannot resolve bridge IP with hostname \" + config.get(CONFIG_HOST_NAME));\n+        }\n+    }\n+\n+    /**\n+     * Create communication object to Qbus server and start communication.\n+     *\n+     * @param addr : IP address of Qbus server\n+     * @param port : Communication port of QbusServer\n+     * @param sn : Serial number of Controller\n+     */\n+    private void createCommunicationObject(InetAddress addr, int port) {\n+        Configuration config = this.getConfig();\n+        scheduler.submit(() -> {\n+            qbusComm = new QbusCommunication();\n+\n+            // Set callback from Qbus object to this bridge to be able to take bridge\n+            // offline when non-resolvable communication error occurs.\n+            setBridgeCallBack();\n+\n+            qbusComm.startCommunication();\n+            if (!qbusComm.communicationActive()) {\n+                qbusComm = null;\n+                bridgeOffline();\n+                return;\n+            }\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            Integer refreshInterval = ((Number) config.get(CONFIG_REFRESH)).intValue();\n+            setupRefreshTimer(refreshInterval);\n+\n+        });\n+    }\n+\n+    private void setBridgeCallBack() {\n+        this.qbusComm.setBridgeCallBack(this);\n+    }\n+\n+    /**\n+     * Schedule future communication refresh.\n+     *\n+     * @param interval_config Time before refresh in minutes.\n+     */\n+    private void setupRefreshTimer(Integer refreshInterval) {\n+        if (this.refreshTimer != null) {\n+            this.refreshTimer.cancel(true);\n+            this.refreshTimer = null;\n+        }\n+\n+        if ((refreshInterval == null) || (refreshInterval == 0)) {\n+            return;\n+        }\n+\n+        // This timer will restart the bridge connection periodically\n+        logger.debug(\"Qbus: Checking for Client communication every {} min\", refreshInterval);\n+        this.refreshTimer = scheduler.scheduleWithFixedDelay(() -> {\n+            logger.debug(\"Qbus: check communication after timerinterval\");\n+\n+            if (!qbusComm.communicationActive()) {\n+                logger.debug(\"Qbus: Restarting communication\");\n+                qbusComm.restartCommunication();\n+\n+                if (!qbusComm.communicationActive()) {\n+                    qbusComm = null;\n+                    bridgeOffline();\n+                    updateStatus(ThingStatus.OFFLINE);\n+                    return;\n+                }\n+\n+                // updateStatus(ThingStatus.ONLINE);\n+                updateStatus(ThingStatus.ONLINE);\n+            } else {\n+                logger.debug(\"Qbus: Communication still active\");", "originalCommit": "a4206928c61b76cec182bd1519a99802abb945d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk3MTUxNA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r541971514", "bodyText": "What's the purpose of this?", "author": "fwolter", "createdAt": "2020-12-13T17:48:54Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private QbusCommunication qbusComm;\n+\n+    private ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // There is nothing to handle in the bridge handler\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"QBUS: initializing bridge handler\");\n+\n+        Configuration config = this.getConfig();\n+        InetAddress addr = getAddr();\n+        int port = getPort();\n+\n+        logger.debug(\"Qbus: bridge handler host {}, port {}\", addr, port);\n+\n+        if (addr != null) {\n+            createCommunicationObject(addr, port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Qbus: cannot resolve bridge IP with hostname \" + config.get(CONFIG_HOST_NAME));\n+        }\n+    }\n+\n+    /**\n+     * Create communication object to Qbus server and start communication.\n+     *\n+     * @param addr : IP address of Qbus server\n+     * @param port : Communication port of QbusServer\n+     * @param sn : Serial number of Controller\n+     */\n+    private void createCommunicationObject(InetAddress addr, int port) {\n+        Configuration config = this.getConfig();\n+        scheduler.submit(() -> {\n+            qbusComm = new QbusCommunication();\n+\n+            // Set callback from Qbus object to this bridge to be able to take bridge\n+            // offline when non-resolvable communication error occurs.\n+            setBridgeCallBack();\n+\n+            qbusComm.startCommunication();\n+            if (!qbusComm.communicationActive()) {\n+                qbusComm = null;\n+                bridgeOffline();\n+                return;\n+            }\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            Integer refreshInterval = ((Number) config.get(CONFIG_REFRESH)).intValue();\n+            setupRefreshTimer(refreshInterval);\n+\n+        });\n+    }\n+\n+    private void setBridgeCallBack() {\n+        this.qbusComm.setBridgeCallBack(this);\n+    }\n+\n+    /**\n+     * Schedule future communication refresh.\n+     *\n+     * @param interval_config Time before refresh in minutes.\n+     */\n+    private void setupRefreshTimer(Integer refreshInterval) {\n+        if (this.refreshTimer != null) {\n+            this.refreshTimer.cancel(true);\n+            this.refreshTimer = null;\n+        }\n+\n+        if ((refreshInterval == null) || (refreshInterval == 0)) {\n+            return;\n+        }\n+\n+        // This timer will restart the bridge connection periodically\n+        logger.debug(\"Qbus: Checking for Client communication every {} min\", refreshInterval);\n+        this.refreshTimer = scheduler.scheduleWithFixedDelay(() -> {\n+            logger.debug(\"Qbus: check communication after timerinterval\");\n+\n+            if (!qbusComm.communicationActive()) {\n+                logger.debug(\"Qbus: Restarting communication\");\n+                qbusComm.restartCommunication();\n+\n+                if (!qbusComm.communicationActive()) {\n+                    qbusComm = null;\n+                    bridgeOffline();\n+                    updateStatus(ThingStatus.OFFLINE);\n+                    return;\n+                }\n+\n+                // updateStatus(ThingStatus.ONLINE);\n+                updateStatus(ThingStatus.ONLINE);\n+            } else {\n+                logger.debug(\"Qbus: Communication still active\");\n+            }\n+\n+        }, refreshInterval, refreshInterval, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Take bridge offline when error in communication with Qbus server. This method can also be\n+     * called directly from {@link QbusCommunication} object.\n+     */\n+    public void bridgeOffline() {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                \"Qbus: error starting bridge connection\");\n+    }\n+\n+    /**\n+     * Put bridge online when error in communication resolved.\n+     */\n+    public void bridgeOnline() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public boolean isInitialized() {\n+        return true;\n+    }", "originalCommit": "a4206928c61b76cec182bd1519a99802abb945d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk3MTY2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r541971662", "bodyText": "Is this really necessary? initialize() is called when the configuration has changed.", "author": "fwolter", "createdAt": "2020-12-13T17:49:40Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private QbusCommunication qbusComm;\n+\n+    private ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // There is nothing to handle in the bridge handler\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"QBUS: initializing bridge handler\");\n+\n+        Configuration config = this.getConfig();\n+        InetAddress addr = getAddr();\n+        int port = getPort();\n+\n+        logger.debug(\"Qbus: bridge handler host {}, port {}\", addr, port);\n+\n+        if (addr != null) {\n+            createCommunicationObject(addr, port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Qbus: cannot resolve bridge IP with hostname \" + config.get(CONFIG_HOST_NAME));\n+        }\n+    }\n+\n+    /**\n+     * Create communication object to Qbus server and start communication.\n+     *\n+     * @param addr : IP address of Qbus server\n+     * @param port : Communication port of QbusServer\n+     * @param sn : Serial number of Controller\n+     */\n+    private void createCommunicationObject(InetAddress addr, int port) {\n+        Configuration config = this.getConfig();\n+        scheduler.submit(() -> {\n+            qbusComm = new QbusCommunication();\n+\n+            // Set callback from Qbus object to this bridge to be able to take bridge\n+            // offline when non-resolvable communication error occurs.\n+            setBridgeCallBack();\n+\n+            qbusComm.startCommunication();\n+            if (!qbusComm.communicationActive()) {\n+                qbusComm = null;\n+                bridgeOffline();\n+                return;\n+            }\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            Integer refreshInterval = ((Number) config.get(CONFIG_REFRESH)).intValue();\n+            setupRefreshTimer(refreshInterval);\n+\n+        });\n+    }\n+\n+    private void setBridgeCallBack() {\n+        this.qbusComm.setBridgeCallBack(this);\n+    }\n+\n+    /**\n+     * Schedule future communication refresh.\n+     *\n+     * @param interval_config Time before refresh in minutes.\n+     */\n+    private void setupRefreshTimer(Integer refreshInterval) {\n+        if (this.refreshTimer != null) {\n+            this.refreshTimer.cancel(true);\n+            this.refreshTimer = null;\n+        }\n+\n+        if ((refreshInterval == null) || (refreshInterval == 0)) {\n+            return;\n+        }\n+\n+        // This timer will restart the bridge connection periodically\n+        logger.debug(\"Qbus: Checking for Client communication every {} min\", refreshInterval);\n+        this.refreshTimer = scheduler.scheduleWithFixedDelay(() -> {\n+            logger.debug(\"Qbus: check communication after timerinterval\");\n+\n+            if (!qbusComm.communicationActive()) {\n+                logger.debug(\"Qbus: Restarting communication\");\n+                qbusComm.restartCommunication();\n+\n+                if (!qbusComm.communicationActive()) {\n+                    qbusComm = null;\n+                    bridgeOffline();\n+                    updateStatus(ThingStatus.OFFLINE);\n+                    return;\n+                }\n+\n+                // updateStatus(ThingStatus.ONLINE);\n+                updateStatus(ThingStatus.ONLINE);\n+            } else {\n+                logger.debug(\"Qbus: Communication still active\");\n+            }\n+\n+        }, refreshInterval, refreshInterval, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Take bridge offline when error in communication with Qbus server. This method can also be\n+     * called directly from {@link QbusCommunication} object.\n+     */\n+    public void bridgeOffline() {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                \"Qbus: error starting bridge connection\");\n+    }\n+\n+    /**\n+     * Put bridge online when error in communication resolved.\n+     */\n+    public void bridgeOnline() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public boolean isInitialized() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (this.refreshTimer != null) {\n+            this.refreshTimer.cancel(true);\n+        }\n+        this.refreshTimer = null;\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        Configuration configuration = editConfiguration();\n+        for (Entry<String, Object> configurationParmeter : configurationParameters.entrySet()) {\n+            configuration.put(configurationParmeter.getKey(), configurationParmeter.getValue());\n+        }\n+        updateConfiguration(configuration);\n+\n+        scheduler.submit(() -> {\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            Integer refreshInterval = ((Number) configuration.get(CONFIG_REFRESH)).intValue();\n+            setupRefreshTimer(refreshInterval);\n+        });\n+    }", "originalCommit": "a4206928c61b76cec182bd1519a99802abb945d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTk3MjI2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r541972261", "bodyText": "You could create a dedicated class with the configuration parameters and read them here by calling getConfigAs(). That makes the casting unnecessary.", "author": "fwolter", "createdAt": "2020-12-13T17:53:14Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private QbusCommunication qbusComm;\n+\n+    private ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // There is nothing to handle in the bridge handler\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"QBUS: initializing bridge handler\");\n+\n+        Configuration config = this.getConfig();", "originalCommit": "a4206928c61b76cec182bd1519a99802abb945d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDk5ODUwOA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r550998508", "bodyText": "Can this message be replaced by using the debugger or by increasing the framework's log level? See point 4 https://www.openhab.org/docs/developer/guidelines.html#f-logging Please check all.\nAlso logging to info should be used sparsely e.g. a newly started component or a user file that has been loaded.", "author": "fwolter", "createdAt": "2021-01-03T12:20:21Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private @Nullable QbusCommunication qbusComm;\n+\n+    protected @Nullable QbusConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    /**\n+     * Initialize the bridge\n+     */\n+    @Override\n+    public void initialize() {\n+        logger.info(\"Initializing bridge handler\");", "originalCommit": "36d0e279c0fdaf96983e8f52054ded07a0222397", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDk5ODY0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r550998642", "bodyText": "See above. Logging to info. Please check all.", "author": "fwolter", "createdAt": "2021-01-03T12:21:57Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private @Nullable QbusCommunication qbusComm;\n+\n+    protected @Nullable QbusConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    /**\n+     * Initialize the bridge\n+     */\n+    @Override\n+    public void initialize() {\n+        logger.info(\"Initializing bridge handler\");\n+\n+        setConfig();\n+        InetAddress addr = getAddr();\n+        int port = getPort();\n+\n+        if (addr != null) {\n+            createCommunicationObject(addr, port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Cannot connect to QbusServer with hostname \" + addr);\n+        }\n+        int refreshInterval = getRefresh();\n+        this.setupRefreshTimer(refreshInterval);\n+    }\n+\n+    /**\n+     * Sets the Bridge call back\n+     */\n+    private void setBridgeCallBack() {\n+        if (qbusComm != null) {\n+            qbusComm.setBridgeCallBack(this);\n+        }\n+    }\n+\n+    /**\n+     * Create communication object to Qbus server and start communication.\n+     *\n+     * @param addr : IP address of Qbus server\n+     * @param port : Communication port of QbusServer\n+     */\n+    private void createCommunicationObject(InetAddress addr, int port) {\n+        scheduler.submit(() -> {\n+\n+            qbusComm = new QbusCommunication();\n+\n+            setBridgeCallBack();\n+\n+            if (qbusComm != null) {\n+                qbusComm.startCommunication();\n+            }\n+\n+            if (qbusComm != null) {\n+                if (!qbusComm.communicationActive()) {\n+                    qbusComm = null;\n+                    bridgeOffline(\"No communication with Qbus Server\");\n+                    return;\n+                }\n+            }\n+\n+            if (qbusComm != null) {\n+                if (!qbusComm.clientConnected()) {\n+\n+                    qbusComm = null;\n+                    bridgeOffline(\"No communication with Qbus Client\");\n+                    return;\n+                }\n+            }\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+        });\n+    }\n+\n+    /**\n+     * Take bridge offline when error in communication with Qbus server. This method can also be\n+     * called directly from {@link QbusCommunication} object.\n+     */\n+    public void bridgeOffline(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, message);\n+    }\n+\n+    /**\n+     * Put bridge online when error in communication resolved.\n+     */\n+    public void bridgeOnline() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    /**\n+     * Schedule future communication refresh.\n+     *\n+     * @param interval_config Time before refresh in minutes.\n+     */\n+\n+    private void setupRefreshTimer(int refreshInterval) {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(true);\n+            refreshTimer = null;\n+        }\n+\n+        if (refreshInterval == 0) {\n+            return;\n+        }\n+\n+        // This timer will check connection with server and client periodically\n+        logger.info(\"Check communication with Server and Client every {} min\", refreshInterval);", "originalCommit": "36d0e279c0fdaf96983e8f52054ded07a0222397", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDk5ODcyMg==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r550998722", "bodyText": "Please remove the empty lines.", "author": "fwolter", "createdAt": "2021-01-03T12:22:50Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private @Nullable QbusCommunication qbusComm;\n+\n+    protected @Nullable QbusConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    /**\n+     * Initialize the bridge\n+     */\n+    @Override\n+    public void initialize() {\n+        logger.info(\"Initializing bridge handler\");\n+\n+        setConfig();\n+        InetAddress addr = getAddr();\n+        int port = getPort();\n+\n+        if (addr != null) {\n+            createCommunicationObject(addr, port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Cannot connect to QbusServer with hostname \" + addr);\n+        }\n+        int refreshInterval = getRefresh();\n+        this.setupRefreshTimer(refreshInterval);\n+    }\n+\n+    /**\n+     * Sets the Bridge call back\n+     */\n+    private void setBridgeCallBack() {\n+        if (qbusComm != null) {\n+            qbusComm.setBridgeCallBack(this);\n+        }\n+    }\n+\n+    /**\n+     * Create communication object to Qbus server and start communication.\n+     *\n+     * @param addr : IP address of Qbus server\n+     * @param port : Communication port of QbusServer\n+     */\n+    private void createCommunicationObject(InetAddress addr, int port) {\n+        scheduler.submit(() -> {\n+\n+            qbusComm = new QbusCommunication();\n+\n+            setBridgeCallBack();\n+\n+            if (qbusComm != null) {\n+                qbusComm.startCommunication();\n+            }\n+\n+            if (qbusComm != null) {\n+                if (!qbusComm.communicationActive()) {\n+                    qbusComm = null;\n+                    bridgeOffline(\"No communication with Qbus Server\");\n+                    return;\n+                }\n+            }\n+\n+            if (qbusComm != null) {\n+                if (!qbusComm.clientConnected()) {\n+\n+                    qbusComm = null;\n+                    bridgeOffline(\"No communication with Qbus Client\");\n+                    return;\n+                }\n+            }\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+        });\n+    }\n+\n+    /**\n+     * Take bridge offline when error in communication with Qbus server. This method can also be\n+     * called directly from {@link QbusCommunication} object.\n+     */\n+    public void bridgeOffline(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, message);\n+    }\n+\n+    /**\n+     * Put bridge online when error in communication resolved.\n+     */\n+    public void bridgeOnline() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    /**\n+     * Schedule future communication refresh.\n+     *\n+     * @param interval_config Time before refresh in minutes.\n+     */\n+\n+    private void setupRefreshTimer(int refreshInterval) {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(true);\n+            refreshTimer = null;\n+        }\n+\n+        if (refreshInterval == 0) {\n+            return;\n+        }\n+\n+        // This timer will check connection with server and client periodically\n+        logger.info(\"Check communication with Server and Client every {} min\", refreshInterval);\n+        refreshTimer = scheduler.scheduleWithFixedDelay(() -> {\n+            logger.info(\"Checking connection with Qbus Server & Client.\");\n+\n+            QbusCommunication comm = getCommunication();\n+\n+            if (comm != null) {\n+                if (!comm.communicationActive()) {\n+                    // Disconnected from Qbus Server, try to reconnect\n+                    logger.info(\"No connection with Qbus Server. Try to restart.\");\n+                    comm.restartCommunication();\n+                    if (!comm.communicationActive()) {\n+                        bridgeOffline(\"No connection with Qbus Server\");\n+                        return;\n+                    }\n+\n+                } else {\n+", "originalCommit": "36d0e279c0fdaf96983e8f52054ded07a0222397", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDk5ODg3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r550998875", "bodyText": "Please remove these kind of log messages. I strongly encourage you to use the debugger to check where your program runs. This saves a lot of headache.", "author": "fwolter", "createdAt": "2021-01-03T12:24:06Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private @Nullable QbusCommunication qbusComm;\n+\n+    protected @Nullable QbusConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    /**\n+     * Initialize the bridge\n+     */\n+    @Override\n+    public void initialize() {\n+        logger.info(\"Initializing bridge handler\");\n+\n+        setConfig();\n+        InetAddress addr = getAddr();\n+        int port = getPort();\n+\n+        if (addr != null) {\n+            createCommunicationObject(addr, port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Cannot connect to QbusServer with hostname \" + addr);\n+        }\n+        int refreshInterval = getRefresh();\n+        this.setupRefreshTimer(refreshInterval);\n+    }\n+\n+    /**\n+     * Sets the Bridge call back\n+     */\n+    private void setBridgeCallBack() {\n+        if (qbusComm != null) {\n+            qbusComm.setBridgeCallBack(this);\n+        }\n+    }\n+\n+    /**\n+     * Create communication object to Qbus server and start communication.\n+     *\n+     * @param addr : IP address of Qbus server\n+     * @param port : Communication port of QbusServer\n+     */\n+    private void createCommunicationObject(InetAddress addr, int port) {\n+        scheduler.submit(() -> {\n+\n+            qbusComm = new QbusCommunication();\n+\n+            setBridgeCallBack();\n+\n+            if (qbusComm != null) {\n+                qbusComm.startCommunication();\n+            }\n+\n+            if (qbusComm != null) {\n+                if (!qbusComm.communicationActive()) {\n+                    qbusComm = null;\n+                    bridgeOffline(\"No communication with Qbus Server\");\n+                    return;\n+                }\n+            }\n+\n+            if (qbusComm != null) {\n+                if (!qbusComm.clientConnected()) {\n+\n+                    qbusComm = null;\n+                    bridgeOffline(\"No communication with Qbus Client\");\n+                    return;\n+                }\n+            }\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+        });\n+    }\n+\n+    /**\n+     * Take bridge offline when error in communication with Qbus server. This method can also be\n+     * called directly from {@link QbusCommunication} object.\n+     */\n+    public void bridgeOffline(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, message);\n+    }\n+\n+    /**\n+     * Put bridge online when error in communication resolved.\n+     */\n+    public void bridgeOnline() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    /**\n+     * Schedule future communication refresh.\n+     *\n+     * @param interval_config Time before refresh in minutes.\n+     */\n+\n+    private void setupRefreshTimer(int refreshInterval) {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(true);\n+            refreshTimer = null;\n+        }\n+\n+        if (refreshInterval == 0) {\n+            return;\n+        }\n+\n+        // This timer will check connection with server and client periodically\n+        logger.info(\"Check communication with Server and Client every {} min\", refreshInterval);\n+        refreshTimer = scheduler.scheduleWithFixedDelay(() -> {\n+            logger.info(\"Checking connection with Qbus Server & Client.\");", "originalCommit": "36d0e279c0fdaf96983e8f52054ded07a0222397", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDk5ODk1MA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r550998950", "bodyText": "What's the purpose of this method?", "author": "fwolter", "createdAt": "2021-01-03T12:24:50Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private @Nullable QbusCommunication qbusComm;\n+\n+    protected @Nullable QbusConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    /**\n+     * Initialize the bridge\n+     */\n+    @Override\n+    public void initialize() {\n+        logger.info(\"Initializing bridge handler\");\n+\n+        setConfig();\n+        InetAddress addr = getAddr();\n+        int port = getPort();\n+\n+        if (addr != null) {\n+            createCommunicationObject(addr, port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Cannot connect to QbusServer with hostname \" + addr);\n+        }\n+        int refreshInterval = getRefresh();\n+        this.setupRefreshTimer(refreshInterval);\n+    }\n+\n+    /**\n+     * Sets the Bridge call back\n+     */\n+    private void setBridgeCallBack() {\n+        if (qbusComm != null) {\n+            qbusComm.setBridgeCallBack(this);\n+        }\n+    }\n+\n+    /**\n+     * Create communication object to Qbus server and start communication.\n+     *\n+     * @param addr : IP address of Qbus server\n+     * @param port : Communication port of QbusServer\n+     */\n+    private void createCommunicationObject(InetAddress addr, int port) {\n+        scheduler.submit(() -> {\n+\n+            qbusComm = new QbusCommunication();\n+\n+            setBridgeCallBack();\n+\n+            if (qbusComm != null) {\n+                qbusComm.startCommunication();\n+            }\n+\n+            if (qbusComm != null) {\n+                if (!qbusComm.communicationActive()) {\n+                    qbusComm = null;\n+                    bridgeOffline(\"No communication with Qbus Server\");\n+                    return;\n+                }\n+            }\n+\n+            if (qbusComm != null) {\n+                if (!qbusComm.clientConnected()) {\n+\n+                    qbusComm = null;\n+                    bridgeOffline(\"No communication with Qbus Client\");\n+                    return;\n+                }\n+            }\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+        });\n+    }\n+\n+    /**\n+     * Take bridge offline when error in communication with Qbus server. This method can also be\n+     * called directly from {@link QbusCommunication} object.\n+     */\n+    public void bridgeOffline(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, message);\n+    }\n+\n+    /**\n+     * Put bridge online when error in communication resolved.\n+     */\n+    public void bridgeOnline() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    /**\n+     * Schedule future communication refresh.\n+     *\n+     * @param interval_config Time before refresh in minutes.\n+     */\n+\n+    private void setupRefreshTimer(int refreshInterval) {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(true);\n+            refreshTimer = null;\n+        }\n+\n+        if (refreshInterval == 0) {\n+            return;\n+        }\n+\n+        // This timer will check connection with server and client periodically\n+        logger.info(\"Check communication with Server and Client every {} min\", refreshInterval);\n+        refreshTimer = scheduler.scheduleWithFixedDelay(() -> {\n+            logger.info(\"Checking connection with Qbus Server & Client.\");\n+\n+            QbusCommunication comm = getCommunication();\n+\n+            if (comm != null) {\n+                if (!comm.communicationActive()) {\n+                    // Disconnected from Qbus Server, try to reconnect\n+                    logger.info(\"No connection with Qbus Server. Try to restart.\");\n+                    comm.restartCommunication();\n+                    if (!comm.communicationActive()) {\n+                        bridgeOffline(\"No connection with Qbus Server\");\n+                        return;\n+                    }\n+\n+                } else {\n+\n+                    // Controller disconnected from Qbus client, try to reconnect controller\n+                    if (!comm.clientConnected()) {\n+                        logger.info(\"No connection with Qbus Client. Try to restart.\");\n+                        comm.restartCommunication();\n+                        if (!comm.clientConnected()) {\n+                            bridgeOffline(\"No connection with Qbus Client\");\n+                            return;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            logger.info(\"Connection with Qbus Server & Client is still active.\");\n+            updateStatus(ThingStatus.ONLINE);\n+\n+        }, refreshInterval, refreshInterval, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Disposes the Bridge and stops communication with the Qbus server\n+     */\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(true);\n+        }\n+\n+        refreshTimer = null;\n+\n+        QbusCommunication comm = getCommunication();\n+        if (comm != null) {\n+            comm.stopCommunication();\n+        }\n+\n+        comm = null;\n+    }\n+\n+    /**\n+     * Update the configuration parameters\n+     */\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        Configuration configuration = editConfiguration();\n+        for (Entry<String, Object> configurationParmeter : configurationParameters.entrySet()) {\n+            configuration.put(configurationParmeter.getKey(), configurationParmeter.getValue());\n+        }\n+        updateConfiguration(configuration);\n+        updateStatus(ThingStatus.ONLINE);\n+    }", "originalCommit": "36d0e279c0fdaf96983e8f52054ded07a0222397", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDk5ODk4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r550998986", "bodyText": "Is there any reason why this is synchronized?\nThe name setConfig() seems a bit misleading. Would readConfig() be better?", "author": "fwolter", "createdAt": "2021-01-03T12:25:05Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private @Nullable QbusCommunication qbusComm;\n+\n+    protected @Nullable QbusConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    /**\n+     * Initialize the bridge\n+     */\n+    @Override\n+    public void initialize() {\n+        logger.info(\"Initializing bridge handler\");\n+\n+        setConfig();\n+        InetAddress addr = getAddr();\n+        int port = getPort();\n+\n+        if (addr != null) {\n+            createCommunicationObject(addr, port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Cannot connect to QbusServer with hostname \" + addr);\n+        }\n+        int refreshInterval = getRefresh();\n+        this.setupRefreshTimer(refreshInterval);\n+    }\n+\n+    /**\n+     * Sets the Bridge call back\n+     */\n+    private void setBridgeCallBack() {\n+        if (qbusComm != null) {\n+            qbusComm.setBridgeCallBack(this);\n+        }\n+    }\n+\n+    /**\n+     * Create communication object to Qbus server and start communication.\n+     *\n+     * @param addr : IP address of Qbus server\n+     * @param port : Communication port of QbusServer\n+     */\n+    private void createCommunicationObject(InetAddress addr, int port) {\n+        scheduler.submit(() -> {\n+\n+            qbusComm = new QbusCommunication();\n+\n+            setBridgeCallBack();\n+\n+            if (qbusComm != null) {\n+                qbusComm.startCommunication();\n+            }\n+\n+            if (qbusComm != null) {\n+                if (!qbusComm.communicationActive()) {\n+                    qbusComm = null;\n+                    bridgeOffline(\"No communication with Qbus Server\");\n+                    return;\n+                }\n+            }\n+\n+            if (qbusComm != null) {\n+                if (!qbusComm.clientConnected()) {\n+\n+                    qbusComm = null;\n+                    bridgeOffline(\"No communication with Qbus Client\");\n+                    return;\n+                }\n+            }\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+        });\n+    }\n+\n+    /**\n+     * Take bridge offline when error in communication with Qbus server. This method can also be\n+     * called directly from {@link QbusCommunication} object.\n+     */\n+    public void bridgeOffline(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, message);\n+    }\n+\n+    /**\n+     * Put bridge online when error in communication resolved.\n+     */\n+    public void bridgeOnline() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    /**\n+     * Schedule future communication refresh.\n+     *\n+     * @param interval_config Time before refresh in minutes.\n+     */\n+\n+    private void setupRefreshTimer(int refreshInterval) {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(true);\n+            refreshTimer = null;\n+        }\n+\n+        if (refreshInterval == 0) {\n+            return;\n+        }\n+\n+        // This timer will check connection with server and client periodically\n+        logger.info(\"Check communication with Server and Client every {} min\", refreshInterval);\n+        refreshTimer = scheduler.scheduleWithFixedDelay(() -> {\n+            logger.info(\"Checking connection with Qbus Server & Client.\");\n+\n+            QbusCommunication comm = getCommunication();\n+\n+            if (comm != null) {\n+                if (!comm.communicationActive()) {\n+                    // Disconnected from Qbus Server, try to reconnect\n+                    logger.info(\"No connection with Qbus Server. Try to restart.\");\n+                    comm.restartCommunication();\n+                    if (!comm.communicationActive()) {\n+                        bridgeOffline(\"No connection with Qbus Server\");\n+                        return;\n+                    }\n+\n+                } else {\n+\n+                    // Controller disconnected from Qbus client, try to reconnect controller\n+                    if (!comm.clientConnected()) {\n+                        logger.info(\"No connection with Qbus Client. Try to restart.\");\n+                        comm.restartCommunication();\n+                        if (!comm.clientConnected()) {\n+                            bridgeOffline(\"No connection with Qbus Client\");\n+                            return;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            logger.info(\"Connection with Qbus Server & Client is still active.\");\n+            updateStatus(ThingStatus.ONLINE);\n+\n+        }, refreshInterval, refreshInterval, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Disposes the Bridge and stops communication with the Qbus server\n+     */\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(true);\n+        }\n+\n+        refreshTimer = null;\n+\n+        QbusCommunication comm = getCommunication();\n+        if (comm != null) {\n+            comm.stopCommunication();\n+        }\n+\n+        comm = null;\n+    }\n+\n+    /**\n+     * Update the configuration parameters\n+     */\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        Configuration configuration = editConfiguration();\n+        for (Entry<String, Object> configurationParmeter : configurationParameters.entrySet()) {\n+            configuration.put(configurationParmeter.getKey(), configurationParmeter.getValue());\n+        }\n+        updateConfiguration(configuration);\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    /**\n+     * Sets the configuration prameters\n+     */\n+    protected synchronized void setConfig() {", "originalCommit": "36d0e279c0fdaf96983e8f52054ded07a0222397", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDk5OTM3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r550999377", "bodyText": "You could throw the UnknownHostException and handle it in initialize(). That would make the null suppression unnecessary. In fact that would make the whole method unnecessary. It's better to throw an exception in case of an error instead of returning null. This way you have the error message in the calling method and can integrate it in the message the user gets presented.", "author": "fwolter", "createdAt": "2021-01-03T12:27:58Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private @Nullable QbusCommunication qbusComm;\n+\n+    protected @Nullable QbusConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    /**\n+     * Initialize the bridge\n+     */\n+    @Override\n+    public void initialize() {\n+        logger.info(\"Initializing bridge handler\");\n+\n+        setConfig();\n+        InetAddress addr = getAddr();\n+        int port = getPort();\n+\n+        if (addr != null) {\n+            createCommunicationObject(addr, port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Cannot connect to QbusServer with hostname \" + addr);\n+        }\n+        int refreshInterval = getRefresh();\n+        this.setupRefreshTimer(refreshInterval);\n+    }\n+\n+    /**\n+     * Sets the Bridge call back\n+     */\n+    private void setBridgeCallBack() {\n+        if (qbusComm != null) {\n+            qbusComm.setBridgeCallBack(this);\n+        }\n+    }\n+\n+    /**\n+     * Create communication object to Qbus server and start communication.\n+     *\n+     * @param addr : IP address of Qbus server\n+     * @param port : Communication port of QbusServer\n+     */\n+    private void createCommunicationObject(InetAddress addr, int port) {\n+        scheduler.submit(() -> {\n+\n+            qbusComm = new QbusCommunication();\n+\n+            setBridgeCallBack();\n+\n+            if (qbusComm != null) {\n+                qbusComm.startCommunication();\n+            }\n+\n+            if (qbusComm != null) {\n+                if (!qbusComm.communicationActive()) {\n+                    qbusComm = null;\n+                    bridgeOffline(\"No communication with Qbus Server\");\n+                    return;\n+                }\n+            }\n+\n+            if (qbusComm != null) {\n+                if (!qbusComm.clientConnected()) {\n+\n+                    qbusComm = null;\n+                    bridgeOffline(\"No communication with Qbus Client\");\n+                    return;\n+                }\n+            }\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+        });\n+    }\n+\n+    /**\n+     * Take bridge offline when error in communication with Qbus server. This method can also be\n+     * called directly from {@link QbusCommunication} object.\n+     */\n+    public void bridgeOffline(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, message);\n+    }\n+\n+    /**\n+     * Put bridge online when error in communication resolved.\n+     */\n+    public void bridgeOnline() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    /**\n+     * Schedule future communication refresh.\n+     *\n+     * @param interval_config Time before refresh in minutes.\n+     */\n+\n+    private void setupRefreshTimer(int refreshInterval) {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(true);\n+            refreshTimer = null;\n+        }\n+\n+        if (refreshInterval == 0) {\n+            return;\n+        }\n+\n+        // This timer will check connection with server and client periodically\n+        logger.info(\"Check communication with Server and Client every {} min\", refreshInterval);\n+        refreshTimer = scheduler.scheduleWithFixedDelay(() -> {\n+            logger.info(\"Checking connection with Qbus Server & Client.\");\n+\n+            QbusCommunication comm = getCommunication();\n+\n+            if (comm != null) {\n+                if (!comm.communicationActive()) {\n+                    // Disconnected from Qbus Server, try to reconnect\n+                    logger.info(\"No connection with Qbus Server. Try to restart.\");\n+                    comm.restartCommunication();\n+                    if (!comm.communicationActive()) {\n+                        bridgeOffline(\"No connection with Qbus Server\");\n+                        return;\n+                    }\n+\n+                } else {\n+\n+                    // Controller disconnected from Qbus client, try to reconnect controller\n+                    if (!comm.clientConnected()) {\n+                        logger.info(\"No connection with Qbus Client. Try to restart.\");\n+                        comm.restartCommunication();\n+                        if (!comm.clientConnected()) {\n+                            bridgeOffline(\"No connection with Qbus Client\");\n+                            return;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            logger.info(\"Connection with Qbus Server & Client is still active.\");\n+            updateStatus(ThingStatus.ONLINE);\n+\n+        }, refreshInterval, refreshInterval, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Disposes the Bridge and stops communication with the Qbus server\n+     */\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(true);\n+        }\n+\n+        refreshTimer = null;\n+\n+        QbusCommunication comm = getCommunication();\n+        if (comm != null) {\n+            comm.stopCommunication();\n+        }\n+\n+        comm = null;\n+    }\n+\n+    /**\n+     * Update the configuration parameters\n+     */\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        Configuration configuration = editConfiguration();\n+        for (Entry<String, Object> configurationParmeter : configurationParameters.entrySet()) {\n+            configuration.put(configurationParmeter.getKey(), configurationParmeter.getValue());\n+        }\n+        updateConfiguration(configuration);\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    /**\n+     * Sets the configuration prameters\n+     */\n+    protected synchronized void setConfig() {\n+        config = getConfig().as(QbusConfiguration.class);\n+    }\n+\n+    /**\n+     * Get the Qbus communication object.\n+     *\n+     * @return Qbus communication object\n+     */\n+    public @Nullable QbusCommunication getCommunication() {\n+        return this.qbusComm;\n+    }\n+\n+    /**\n+     * Get the IP-address of the Qbus server.\n+     *\n+     * @return the addr\n+     */\n+\n+    @SuppressWarnings(\"null\")\n+    public @Nullable InetAddress getAddr() {\n+        InetAddress addr = null;\n+        try {\n+            addr = InetAddress.getByName(config.addr);\n+        } catch (UnknownHostException e) {\n+            logger.debug(\"Cannot resolve hostname {} to IP adress\", config.addr);\n+        }\n+        return addr;\n+    }", "originalCommit": "36d0e279c0fdaf96983e8f52054ded07a0222397", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDk5OTQ4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r550999483", "bodyText": "The suppression annotation should be used only if the compiler warning is wrong.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @SuppressWarnings(\"null\")\n          \n          \n            \n                public int getPort() {\n          \n          \n            \n                    return config.port;\n          \n          \n            \n                }\n          \n          \n            \n                public @Nullable int getPort() {\n          \n          \n            \n                    return config.port;\n          \n          \n            \n                }", "author": "fwolter", "createdAt": "2021-01-03T12:28:47Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private @Nullable QbusCommunication qbusComm;\n+\n+    protected @Nullable QbusConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    /**\n+     * Initialize the bridge\n+     */\n+    @Override\n+    public void initialize() {\n+        logger.info(\"Initializing bridge handler\");\n+\n+        setConfig();\n+        InetAddress addr = getAddr();\n+        int port = getPort();\n+\n+        if (addr != null) {\n+            createCommunicationObject(addr, port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Cannot connect to QbusServer with hostname \" + addr);\n+        }\n+        int refreshInterval = getRefresh();\n+        this.setupRefreshTimer(refreshInterval);\n+    }\n+\n+    /**\n+     * Sets the Bridge call back\n+     */\n+    private void setBridgeCallBack() {\n+        if (qbusComm != null) {\n+            qbusComm.setBridgeCallBack(this);\n+        }\n+    }\n+\n+    /**\n+     * Create communication object to Qbus server and start communication.\n+     *\n+     * @param addr : IP address of Qbus server\n+     * @param port : Communication port of QbusServer\n+     */\n+    private void createCommunicationObject(InetAddress addr, int port) {\n+        scheduler.submit(() -> {\n+\n+            qbusComm = new QbusCommunication();\n+\n+            setBridgeCallBack();\n+\n+            if (qbusComm != null) {\n+                qbusComm.startCommunication();\n+            }\n+\n+            if (qbusComm != null) {\n+                if (!qbusComm.communicationActive()) {\n+                    qbusComm = null;\n+                    bridgeOffline(\"No communication with Qbus Server\");\n+                    return;\n+                }\n+            }\n+\n+            if (qbusComm != null) {\n+                if (!qbusComm.clientConnected()) {\n+\n+                    qbusComm = null;\n+                    bridgeOffline(\"No communication with Qbus Client\");\n+                    return;\n+                }\n+            }\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+        });\n+    }\n+\n+    /**\n+     * Take bridge offline when error in communication with Qbus server. This method can also be\n+     * called directly from {@link QbusCommunication} object.\n+     */\n+    public void bridgeOffline(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, message);\n+    }\n+\n+    /**\n+     * Put bridge online when error in communication resolved.\n+     */\n+    public void bridgeOnline() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    /**\n+     * Schedule future communication refresh.\n+     *\n+     * @param interval_config Time before refresh in minutes.\n+     */\n+\n+    private void setupRefreshTimer(int refreshInterval) {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(true);\n+            refreshTimer = null;\n+        }\n+\n+        if (refreshInterval == 0) {\n+            return;\n+        }\n+\n+        // This timer will check connection with server and client periodically\n+        logger.info(\"Check communication with Server and Client every {} min\", refreshInterval);\n+        refreshTimer = scheduler.scheduleWithFixedDelay(() -> {\n+            logger.info(\"Checking connection with Qbus Server & Client.\");\n+\n+            QbusCommunication comm = getCommunication();\n+\n+            if (comm != null) {\n+                if (!comm.communicationActive()) {\n+                    // Disconnected from Qbus Server, try to reconnect\n+                    logger.info(\"No connection with Qbus Server. Try to restart.\");\n+                    comm.restartCommunication();\n+                    if (!comm.communicationActive()) {\n+                        bridgeOffline(\"No connection with Qbus Server\");\n+                        return;\n+                    }\n+\n+                } else {\n+\n+                    // Controller disconnected from Qbus client, try to reconnect controller\n+                    if (!comm.clientConnected()) {\n+                        logger.info(\"No connection with Qbus Client. Try to restart.\");\n+                        comm.restartCommunication();\n+                        if (!comm.clientConnected()) {\n+                            bridgeOffline(\"No connection with Qbus Client\");\n+                            return;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            logger.info(\"Connection with Qbus Server & Client is still active.\");\n+            updateStatus(ThingStatus.ONLINE);\n+\n+        }, refreshInterval, refreshInterval, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Disposes the Bridge and stops communication with the Qbus server\n+     */\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(true);\n+        }\n+\n+        refreshTimer = null;\n+\n+        QbusCommunication comm = getCommunication();\n+        if (comm != null) {\n+            comm.stopCommunication();\n+        }\n+\n+        comm = null;\n+    }\n+\n+    /**\n+     * Update the configuration parameters\n+     */\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        Configuration configuration = editConfiguration();\n+        for (Entry<String, Object> configurationParmeter : configurationParameters.entrySet()) {\n+            configuration.put(configurationParmeter.getKey(), configurationParmeter.getValue());\n+        }\n+        updateConfiguration(configuration);\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    /**\n+     * Sets the configuration prameters\n+     */\n+    protected synchronized void setConfig() {\n+        config = getConfig().as(QbusConfiguration.class);\n+    }\n+\n+    /**\n+     * Get the Qbus communication object.\n+     *\n+     * @return Qbus communication object\n+     */\n+    public @Nullable QbusCommunication getCommunication() {\n+        return this.qbusComm;\n+    }\n+\n+    /**\n+     * Get the IP-address of the Qbus server.\n+     *\n+     * @return the addr\n+     */\n+\n+    @SuppressWarnings(\"null\")\n+    public @Nullable InetAddress getAddr() {\n+        InetAddress addr = null;\n+        try {\n+            addr = InetAddress.getByName(config.addr);\n+        } catch (UnknownHostException e) {\n+            logger.debug(\"Cannot resolve hostname {} to IP adress\", config.addr);\n+        }\n+        return addr;\n+    }\n+\n+    /**\n+     * Get the listening port of the Qbus server.\n+     *\n+     * @return the port\n+     */\n+    @SuppressWarnings(\"null\")\n+    public int getPort() {\n+        return config.port;\n+    }", "originalCommit": "36d0e279c0fdaf96983e8f52054ded07a0222397", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQyNjA1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r554426059", "bodyText": "If i follow your sollution, then i get:\nThe nullness annotation @nullable is not applicable for the primitive type int", "author": "QbusKoen", "createdAt": "2021-01-09T13:13:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDk5OTQ4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQyNjc1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r554426755", "bodyText": "config can be null here. You need to store config to a local variable and do a null check on that.", "author": "fwolter", "createdAt": "2021-01-09T13:20:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDk5OTQ4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDk5OTUyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r550999529", "bodyText": "Can this comment be removed?", "author": "fwolter", "createdAt": "2021-01-03T12:29:05Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private @Nullable QbusCommunication qbusComm;\n+\n+    protected @Nullable QbusConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    /**\n+     * Initialize the bridge\n+     */\n+    @Override\n+    public void initialize() {\n+        logger.info(\"Initializing bridge handler\");\n+\n+        setConfig();\n+        InetAddress addr = getAddr();\n+        int port = getPort();\n+\n+        if (addr != null) {\n+            createCommunicationObject(addr, port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Cannot connect to QbusServer with hostname \" + addr);\n+        }\n+        int refreshInterval = getRefresh();\n+        this.setupRefreshTimer(refreshInterval);\n+    }\n+\n+    /**\n+     * Sets the Bridge call back\n+     */\n+    private void setBridgeCallBack() {\n+        if (qbusComm != null) {\n+            qbusComm.setBridgeCallBack(this);\n+        }\n+    }\n+\n+    /**\n+     * Create communication object to Qbus server and start communication.\n+     *\n+     * @param addr : IP address of Qbus server\n+     * @param port : Communication port of QbusServer\n+     */\n+    private void createCommunicationObject(InetAddress addr, int port) {\n+        scheduler.submit(() -> {\n+\n+            qbusComm = new QbusCommunication();\n+\n+            setBridgeCallBack();\n+\n+            if (qbusComm != null) {\n+                qbusComm.startCommunication();\n+            }\n+\n+            if (qbusComm != null) {\n+                if (!qbusComm.communicationActive()) {\n+                    qbusComm = null;\n+                    bridgeOffline(\"No communication with Qbus Server\");\n+                    return;\n+                }\n+            }\n+\n+            if (qbusComm != null) {\n+                if (!qbusComm.clientConnected()) {\n+\n+                    qbusComm = null;\n+                    bridgeOffline(\"No communication with Qbus Client\");\n+                    return;\n+                }\n+            }\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+        });\n+    }\n+\n+    /**\n+     * Take bridge offline when error in communication with Qbus server. This method can also be\n+     * called directly from {@link QbusCommunication} object.\n+     */\n+    public void bridgeOffline(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, message);\n+    }\n+\n+    /**\n+     * Put bridge online when error in communication resolved.\n+     */\n+    public void bridgeOnline() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    /**\n+     * Schedule future communication refresh.\n+     *\n+     * @param interval_config Time before refresh in minutes.\n+     */\n+\n+    private void setupRefreshTimer(int refreshInterval) {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(true);\n+            refreshTimer = null;\n+        }\n+\n+        if (refreshInterval == 0) {\n+            return;\n+        }\n+\n+        // This timer will check connection with server and client periodically\n+        logger.info(\"Check communication with Server and Client every {} min\", refreshInterval);\n+        refreshTimer = scheduler.scheduleWithFixedDelay(() -> {\n+            logger.info(\"Checking connection with Qbus Server & Client.\");\n+\n+            QbusCommunication comm = getCommunication();\n+\n+            if (comm != null) {\n+                if (!comm.communicationActive()) {\n+                    // Disconnected from Qbus Server, try to reconnect\n+                    logger.info(\"No connection with Qbus Server. Try to restart.\");\n+                    comm.restartCommunication();\n+                    if (!comm.communicationActive()) {\n+                        bridgeOffline(\"No connection with Qbus Server\");\n+                        return;\n+                    }\n+\n+                } else {\n+\n+                    // Controller disconnected from Qbus client, try to reconnect controller\n+                    if (!comm.clientConnected()) {\n+                        logger.info(\"No connection with Qbus Client. Try to restart.\");\n+                        comm.restartCommunication();\n+                        if (!comm.clientConnected()) {\n+                            bridgeOffline(\"No connection with Qbus Client\");\n+                            return;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            logger.info(\"Connection with Qbus Server & Client is still active.\");\n+            updateStatus(ThingStatus.ONLINE);\n+\n+        }, refreshInterval, refreshInterval, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Disposes the Bridge and stops communication with the Qbus server\n+     */\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(true);\n+        }\n+\n+        refreshTimer = null;\n+\n+        QbusCommunication comm = getCommunication();\n+        if (comm != null) {\n+            comm.stopCommunication();\n+        }\n+\n+        comm = null;\n+    }\n+\n+    /**\n+     * Update the configuration parameters\n+     */\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        Configuration configuration = editConfiguration();\n+        for (Entry<String, Object> configurationParmeter : configurationParameters.entrySet()) {\n+            configuration.put(configurationParmeter.getKey(), configurationParmeter.getValue());\n+        }\n+        updateConfiguration(configuration);\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    /**\n+     * Sets the configuration prameters\n+     */\n+    protected synchronized void setConfig() {\n+        config = getConfig().as(QbusConfiguration.class);\n+    }\n+\n+    /**\n+     * Get the Qbus communication object.\n+     *\n+     * @return Qbus communication object\n+     */\n+    public @Nullable QbusCommunication getCommunication() {\n+        return this.qbusComm;\n+    }\n+\n+    /**\n+     * Get the IP-address of the Qbus server.\n+     *\n+     * @return the addr\n+     */\n+\n+    @SuppressWarnings(\"null\")\n+    public @Nullable InetAddress getAddr() {\n+        InetAddress addr = null;\n+        try {\n+            addr = InetAddress.getByName(config.addr);\n+        } catch (UnknownHostException e) {\n+            logger.debug(\"Cannot resolve hostname {} to IP adress\", config.addr);\n+        }\n+        return addr;\n+    }\n+\n+    /**\n+     * Get the listening port of the Qbus server.\n+     *\n+     * @return the port\n+     */\n+    @SuppressWarnings(\"null\")\n+    public int getPort() {\n+        return config.port;\n+    }\n+\n+    /**\n+     * Get the serial nr of the Qbus server.\n+     *\n+     * @return the serial nr of the controller\n+     */\n+    @SuppressWarnings(\"null\")\n+    public String getSn() {\n+        return config.sn;\n+    }\n+\n+    /**\n+     * Get the refresh interval.\n+     *\n+     * @return the refresh interval\n+     */\n+    @SuppressWarnings(\"null\")\n+    public int getRefresh() {\n+        return config.refresh;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // TODO Auto-generated method stub", "originalCommit": "36d0e279c0fdaf96983e8f52054ded07a0222397", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3970141614de42a3b250b1413315364617bc224a", "url": "https://github.com/openhab/openhab-addons/commit/3970141614de42a3b250b1413315364617bc224a", "message": "First commit\n\nSigned-off-by: Koen Schockaert <ks@qbus.be>\nSigned-off-by: QbusKoen <ks@qbus.be>", "committedDate": "2021-02-10T07:56:20Z", "type": "commit"}, {"oid": "f41c02e56b11a6c57711d28655c9aa425a8b4615", "url": "https://github.com/openhab/openhab-addons/commit/f41c02e56b11a6c57711d28655c9aa425a8b4615", "message": "Revert \"First commit\"\n\nThis reverts commit da86aae5e99beb06698150ded1d500529498b44f.\n\nSigned-off-by: QbusKoen <ks@qbus.be>", "committedDate": "2021-02-10T07:56:20Z", "type": "commit"}, {"oid": "8342d4e6ac94918bd2c498246ca3ddc155b98500", "url": "https://github.com/openhab/openhab-addons/commit/8342d4e6ac94918bd2c498246ca3ddc155b98500", "message": "First Commit\n\nSigned-off-by: QbusKoen <ks@qbus.be>", "committedDate": "2021-02-10T07:56:20Z", "type": "commit"}, {"oid": "9507c35f42ecc0a182e320ca9f4d4130462315a0", "url": "https://github.com/openhab/openhab-addons/commit/9507c35f42ecc0a182e320ca9f4d4130462315a0", "message": "Second commit\n\nHad some issues in first commit. Fixed the bugs.\n\nSigned-off-by: QbusKoen <ks@qbus.be>", "committedDate": "2021-02-10T07:56:20Z", "type": "commit"}, {"oid": "9de4acb05e3abed6d9cfe71d11378b535bebad3a", "url": "https://github.com/openhab/openhab-addons/commit/9de4acb05e3abed6d9cfe71d11378b535bebad3a", "message": "Solved issues\n\nSolved issues reported by fwolter and changed a lot of code, based on the comments.\n\nSigned-off-by: QbusKoen <ks@qbus.be>\n\n\tmodified:   CODEOWNERS\n\nSigned-off-by: QbusKoen <ks@qbus.be>", "committedDate": "2021-02-10T07:56:20Z", "type": "commit"}, {"oid": "ed74a2b0f8e8e17af297dd6c0baf76f329ac2746", "url": "https://github.com/openhab/openhab-addons/commit/ed74a2b0f8e8e17af297dd6c0baf76f329ac2746", "message": "Update README.md\n\nSigned-off-by: QbusKoen <ks@qbus.be>", "committedDate": "2021-02-10T07:56:20Z", "type": "commit"}, {"oid": "3551d12972df7f17ed5deafe023227f8175477b7", "url": "https://github.com/openhab/openhab-addons/commit/3551d12972df7f17ed5deafe023227f8175477b7", "message": "Updated requested changes\n\nSigned-off-by: QbusKoen <ks@qbus.be>", "committedDate": "2021-02-10T07:56:20Z", "type": "commit"}, {"oid": "ec2e2ac2cd4bb64719e74315439d37bfd7b4f524", "url": "https://github.com/openhab/openhab-addons/commit/ec2e2ac2cd4bb64719e74315439d37bfd7b4f524", "message": "Updated headers\n\nSigned-off-by: QbusKoen <ks@qbus.be>", "committedDate": "2021-02-10T07:56:20Z", "type": "commit"}, {"oid": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "url": "https://github.com/openhab/openhab-addons/commit/d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "message": "Code fixing\n\nUpdate code like requested by fwolter on 3/1/2021\n\nSigned-off-by: QbusKoen <ks@qbus.be>", "committedDate": "2021-02-10T07:56:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg0OTM2MA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573849360", "bodyText": "You could initilize this with an empty config to get rid of the null annotation.", "author": "fwolter", "createdAt": "2021-02-10T15:55:37Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private @Nullable QbusCommunication qbusComm;\n+\n+    protected @NonNullByDefault({}) QbusConfiguration config;", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg1MTU3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573851571", "bodyText": "See above. Initialize.", "author": "fwolter", "createdAt": "2021-02-10T15:57:59Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusBistabielHandler.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.CHANNEL_SWITCH;\n+import static org.openhab.core.types.RefreshType.REFRESH;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusBistabiel;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link QbusBistabielHandler} is responsible for handling the Bistable outputs of Qbus\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBistabielHandler extends QbusGlobalHandler {\n+\n+    public QbusBistabielHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    protected @NonNullByDefault({}) QbusThingsConfig config;", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg1MjE2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573852162", "bodyText": "The constructor should be below the fields.", "author": "fwolter", "createdAt": "2021-02-10T15:58:41Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusBistabielHandler.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.CHANNEL_SWITCH;\n+import static org.openhab.core.types.RefreshType.REFRESH;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusBistabiel;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link QbusBistabielHandler} is responsible for handling the Bistable outputs of Qbus\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBistabielHandler extends QbusGlobalHandler {\n+\n+    public QbusBistabielHandler(Thing thing) {\n+        super(thing);\n+    }", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg1MjM4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573852386", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                private String sn;\n          \n          \n            \n                private @Nullable String sn;", "author": "fwolter", "createdAt": "2021-02-10T15:58:58Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusBistabielHandler.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.CHANNEL_SWITCH;\n+import static org.openhab.core.types.RefreshType.REFRESH;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusBistabiel;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link QbusBistabielHandler} is responsible for handling the Bistable outputs of Qbus\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBistabielHandler extends QbusGlobalHandler {\n+\n+    public QbusBistabielHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    protected @NonNullByDefault({}) QbusThingsConfig config;\n+\n+    int bistabielId;\n+\n+    @Nullable\n+    private String sn;", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg1ODA0NA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573858044", "bodyText": "The compiler is more intelligent on local variables. Therefore, the Nullable could be removed. Please check all.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        @Nullable\n          \n          \n            \n                        String snr = getSN();\n          \n          \n            \n                        String snr = getSN();", "author": "fwolter", "createdAt": "2021-02-10T16:05:44Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusBistabielHandler.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.CHANNEL_SWITCH;\n+import static org.openhab.core.types.RefreshType.REFRESH;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusBistabiel;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link QbusBistabielHandler} is responsible for handling the Bistable outputs of Qbus\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBistabielHandler extends QbusGlobalHandler {\n+\n+    public QbusBistabielHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    protected @NonNullByDefault({}) QbusThingsConfig config;\n+\n+    int bistabielId;\n+\n+    @Nullable\n+    private String sn;\n+\n+    /**\n+     * Main initialization\n+     */\n+    @Override\n+    public void initialize() {\n+\n+        readConfig();\n+        bistabielId = getId();\n+\n+        QbusCommunication QComm = getCommunication(\"Bistabiel\", bistabielId);\n+        if (QComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+\n+        QbusBridgeHandler QBridgeHandler = getBridgeHandler(\"Bistabiel\", bistabielId);\n+        if (QBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+\n+        setSN();\n+\n+        Map<Integer, QbusBistabiel> bistabielComm = QComm.getBistabiel();\n+\n+        if (bistabielComm != null) {\n+            QbusBistabiel QBistabiel = bistabielComm.get(bistabielId);\n+            if (QBistabiel != null) {\n+                QBistabiel.setThingHandler(this);\n+                handleStateUpdate(QBistabiel);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Error while initializing the thing.\");\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Error while initializing the thing.\");\n+        }\n+    }\n+\n+    /**\n+     * Returns the serial number of the controller\n+     *\n+     * @return the serial nr\n+     */\n+    public @Nullable String getSN() {\n+        return this.sn;\n+    }\n+\n+    /**\n+     * Sets the serial number of the controller\n+     */\n+    public void setSN() {\n+        QbusBridgeHandler QBridgeHandler = getBridgeHandler(\"Bistabiel\", bistabielId);\n+        if (QBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        } else {\n+            this.sn = QBridgeHandler.getSn();\n+        }\n+    }\n+\n+    /**\n+     * Handle the status update from the thing\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        QbusCommunication QComm = getCommunication(\"Bistabiel\", bistabielId);\n+        if (QComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Bridge communication not initialized when trying to execute command for bistabiel \" + bistabielId);\n+            return;\n+        }\n+\n+        Map<Integer, QbusBistabiel> bistabielComm = QComm.getBistabiel();\n+\n+        if (bistabielComm != null) {\n+            QbusBistabiel QBistabiel = bistabielComm.get(bistabielId);\n+\n+            if (QBistabiel == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Bridge communication not initialized when trying to execute command for bistabiel \"\n+                                + bistabielId);\n+                return;\n+            } else {\n+                scheduler.submit(() -> {\n+                    if (!QComm.communicationActive()) {\n+                        restartCommunication(QComm, \"Bistabiel\", bistabielId);\n+                    }\n+\n+                    if (QComm.communicationActive()) {\n+\n+                        if (command == REFRESH) {\n+                            handleStateUpdate(QBistabiel);\n+                            return;\n+                        }\n+\n+                        handleSwitchCommand(QBistabiel, channelUID, command);\n+                    }\n+\n+                });\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Error while initializing the thing.\");\n+        }\n+    }\n+\n+    /**\n+     * Executes the switch command\n+     */\n+    private void handleSwitchCommand(QbusBistabiel QBistabiel, ChannelUID channelUID, Command command) {\n+        if (command instanceof OnOffType) {\n+            OnOffType s = (OnOffType) command;\n+            @Nullable\n+            String snr = getSN();", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg1ODgwOA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573858808", "bodyText": "See above. Constructor below fields and null annotation. Please check all.", "author": "fwolter", "createdAt": "2021-02-10T16:06:36Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusCO2Handler.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.CHANNEL_CO2;\n+import static org.openhab.core.types.RefreshType.REFRESH;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusCO2;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link QbusCO2Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusCO2Handler extends QbusGlobalHandler {\n+\n+    public QbusCO2Handler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    protected @NonNullByDefault({}) QbusThingsConfig config;", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg1OTIzNg==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573859236", "bodyText": "Can these be private?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                int co2Id = 0;\n          \n          \n            \n            \n          \n          \n            \n                @Nullable\n          \n          \n            \n                String sn;\n          \n          \n            \n                private int co2Id = 0;\n          \n          \n            \n            \n          \n          \n            \n                private @Nullable String sn;", "author": "fwolter", "createdAt": "2021-02-10T16:07:06Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusCO2Handler.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.CHANNEL_CO2;\n+import static org.openhab.core.types.RefreshType.REFRESH;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusCO2;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link QbusCO2Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusCO2Handler extends QbusGlobalHandler {\n+\n+    public QbusCO2Handler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    protected @NonNullByDefault({}) QbusThingsConfig config;\n+\n+    int co2Id = 0;\n+\n+    @Nullable\n+    String sn;", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg2MDIzMg==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573860232", "bodyText": "Do you set the Thing to online by intention?", "author": "fwolter", "createdAt": "2021-02-10T16:08:19Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusDimmerHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+import static org.openhab.core.types.RefreshType.REFRESH;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.binding.qbus.internal.protocol.QbusDimmer;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link QbusDimmerHandler} is responsible for handling the dimmable outputs of Qbus\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusDimmerHandler extends QbusGlobalHandler {\n+\n+    public QbusDimmerHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    protected @NonNullByDefault({}) QbusThingsConfig config;\n+\n+    int dimmerId;\n+\n+    @Nullable\n+    private String sn;\n+\n+    /**\n+     * Main initialization\n+     */\n+    @Override\n+    public void initialize() {\n+        setConfig();\n+        dimmerId = getId();\n+\n+        QbusCommunication QComm = getCommunication(\"Dimmer\", dimmerId);\n+        if (QComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+\n+        QbusBridgeHandler QBridgeHandler = getBridgeHandler(\"Dimmer\", dimmerId);\n+        if (QBridgeHandler == null) {\n+            return;\n+        }\n+\n+        setSN();\n+\n+        Map<Integer, QbusDimmer> dimmerComm = QComm.getDimmer();\n+        if (dimmerComm != null) {\n+            QbusDimmer QDimmer = dimmerComm.get(dimmerId);\n+            if (QDimmer != null) {\n+                QDimmer.setThingHandler(this);\n+                handleStateUpdate(QDimmer);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Error while initializing the thing.\");\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Error while initializing the thing.\");\n+        }\n+    }\n+\n+    /**\n+     * Returns the serial number of the controller\n+     *\n+     * @return the serial nr\n+     */\n+    public @Nullable String getSN() {\n+        return this.sn;\n+    }\n+\n+    /**\n+     * Sets the serial number of the controller\n+     */\n+    public void setSN() {\n+        QbusBridgeHandler QBridgeHandler = getBridgeHandler(\"Dimmer\", dimmerId);\n+        if (QBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+        this.sn = QBridgeHandler.getSn();\n+        ;\n+    }\n+\n+    /**\n+     * Handle the status update from the thing\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        QbusCommunication QComm = getCommunication(\"Dimmer\", dimmerId);\n+\n+        if (QComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Bridge communication not initialized when trying to execute command for dimmer \" + dimmerId);\n+            return;\n+        }\n+\n+        Map<Integer, QbusDimmer> dimmerComm = QComm.getDimmer();\n+        if (dimmerComm != null) {\n+            QbusDimmer QDimmer = dimmerComm.get(dimmerId);\n+\n+            if (QDimmer == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Bridge communication not initialized when trying to execute command for dimmer \" + dimmerId);\n+                return;\n+            } else {\n+\n+                scheduler.submit(() -> {\n+                    if (!QComm.communicationActive()) {\n+                        restartCommunication(QComm, \"Dimmer\", dimmerId);\n+                    }\n+\n+                    if (QComm.communicationActive()) {\n+\n+                        if (command == REFRESH) {\n+                            handleStateUpdate(QDimmer);\n+                            return;\n+                        }\n+\n+                        switch (channelUID.getId()) {\n+                            case CHANNEL_SWITCH:\n+                                handleSwitchCommand(QDimmer, command);\n+                                updateStatus(ThingStatus.ONLINE);", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg2MDg3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573860871", "bodyText": "It seems a bit unreasonable to set the Thing offline, when the user sent an invalid command to it. Same for the others.", "author": "fwolter", "createdAt": "2021-02-10T16:09:05Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusDimmerHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+import static org.openhab.core.types.RefreshType.REFRESH;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.binding.qbus.internal.protocol.QbusDimmer;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link QbusDimmerHandler} is responsible for handling the dimmable outputs of Qbus\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusDimmerHandler extends QbusGlobalHandler {\n+\n+    public QbusDimmerHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    protected @NonNullByDefault({}) QbusThingsConfig config;\n+\n+    int dimmerId;\n+\n+    @Nullable\n+    private String sn;\n+\n+    /**\n+     * Main initialization\n+     */\n+    @Override\n+    public void initialize() {\n+        setConfig();\n+        dimmerId = getId();\n+\n+        QbusCommunication QComm = getCommunication(\"Dimmer\", dimmerId);\n+        if (QComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+\n+        QbusBridgeHandler QBridgeHandler = getBridgeHandler(\"Dimmer\", dimmerId);\n+        if (QBridgeHandler == null) {\n+            return;\n+        }\n+\n+        setSN();\n+\n+        Map<Integer, QbusDimmer> dimmerComm = QComm.getDimmer();\n+        if (dimmerComm != null) {\n+            QbusDimmer QDimmer = dimmerComm.get(dimmerId);\n+            if (QDimmer != null) {\n+                QDimmer.setThingHandler(this);\n+                handleStateUpdate(QDimmer);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Error while initializing the thing.\");\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Error while initializing the thing.\");\n+        }\n+    }\n+\n+    /**\n+     * Returns the serial number of the controller\n+     *\n+     * @return the serial nr\n+     */\n+    public @Nullable String getSN() {\n+        return this.sn;\n+    }\n+\n+    /**\n+     * Sets the serial number of the controller\n+     */\n+    public void setSN() {\n+        QbusBridgeHandler QBridgeHandler = getBridgeHandler(\"Dimmer\", dimmerId);\n+        if (QBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+        this.sn = QBridgeHandler.getSn();\n+        ;\n+    }\n+\n+    /**\n+     * Handle the status update from the thing\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        QbusCommunication QComm = getCommunication(\"Dimmer\", dimmerId);\n+\n+        if (QComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Bridge communication not initialized when trying to execute command for dimmer \" + dimmerId);\n+            return;\n+        }\n+\n+        Map<Integer, QbusDimmer> dimmerComm = QComm.getDimmer();\n+        if (dimmerComm != null) {\n+            QbusDimmer QDimmer = dimmerComm.get(dimmerId);\n+\n+            if (QDimmer == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Bridge communication not initialized when trying to execute command for dimmer \" + dimmerId);\n+                return;\n+            } else {\n+\n+                scheduler.submit(() -> {\n+                    if (!QComm.communicationActive()) {\n+                        restartCommunication(QComm, \"Dimmer\", dimmerId);\n+                    }\n+\n+                    if (QComm.communicationActive()) {\n+\n+                        if (command == REFRESH) {\n+                            handleStateUpdate(QDimmer);\n+                            return;\n+                        }\n+\n+                        switch (channelUID.getId()) {\n+                            case CHANNEL_SWITCH:\n+                                handleSwitchCommand(QDimmer, command);\n+                                updateStatus(ThingStatus.ONLINE);\n+                                break;\n+\n+                            case CHANNEL_BRIGHTNESS:\n+                                handleBrightnessCommand(QDimmer, command);\n+                                updateStatus(ThingStatus.ONLINE);\n+                                break;\n+\n+                            default:\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                        \"Channel unknown \" + channelUID.getId());", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg2MzM5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573863393", "bodyText": "You could add the type to the imports. Same for below.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (command instanceof org.openhab.core.library.types.UpDownType) {\n          \n          \n            \n                    if (command instanceof UpDownType) {", "author": "fwolter", "createdAt": "2021-02-10T16:11:56Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusRolHandler.java", "diffHunk": "@@ -0,0 +1,357 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+import static org.openhab.core.types.RefreshType.REFRESH;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.binding.qbus.internal.protocol.QbusRol;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link QbusRolHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusRolHandler extends QbusGlobalHandler {\n+\n+    public QbusRolHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    protected @NonNullByDefault({}) QbusThingsConfig config;\n+\n+    int rolId;\n+\n+    @Nullable\n+    String sn;\n+\n+    /**\n+     * Main initialization\n+     */\n+    @Override\n+    public void initialize() {\n+\n+        setConfig();\n+        rolId = getId();\n+\n+        QbusCommunication QComm = getCommunication(\"Screen/Store\", rolId);\n+        if (QComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+\n+        QbusBridgeHandler QBridgeHandler = getBridgeHandler(\"Screen/Store\", rolId);\n+        if (QBridgeHandler == null) {\n+            return;\n+        }\n+\n+        setSN();\n+\n+        Map<Integer, QbusRol> rolComm = QComm.getRol();\n+\n+        if (rolComm != null) {\n+            QbusRol QRol = rolComm.get(rolId);\n+            if (QRol != null) {\n+                QRol.setThingHandler(this);\n+                handleStateUpdate(QRol);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Error while initializing the thing.\");\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Error while initializing the thing.\");\n+        }\n+    }\n+\n+    /**\n+     * Returns the serial number of the controller\n+     *\n+     * @return the serial nr\n+     */\n+    public @Nullable String getSN() {\n+        return this.sn;\n+    }\n+\n+    /**\n+     * Sets the serial number of the controller\n+     */\n+    public void setSN() {\n+        QbusBridgeHandler QBridgeHandler = getBridgeHandler(\"Screen/Store\", rolId);\n+        if (QBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+        this.sn = QBridgeHandler.getSn();\n+        ;\n+    }\n+\n+    /**\n+     * Handle the status update from the thing\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        QbusCommunication QComm = getCommunication(\"Screen/Store\", rolId);\n+\n+        if (QComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Bridge communication not initialized when trying to execute command for Screen/Store \" + rolId);\n+            return;\n+        }\n+\n+        Map<Integer, QbusRol> rolComm = QComm.getRol();\n+\n+        if (rolComm != null) {\n+            QbusRol QRol = rolComm.get(rolId);\n+            if (QRol == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Bridge communication not initialized when trying to execute command for ROL \" + rolId);\n+                return;\n+            } else {\n+                scheduler.submit(() -> {\n+                    if (!QComm.communicationActive()) {\n+                        restartCommunication(QComm, \"Screen/Store\", rolId);\n+                    }\n+\n+                    if (QComm.communicationActive()) {\n+\n+                        if (command == REFRESH) {\n+                            handleStateUpdate(QRol);\n+                            return;\n+                        }\n+\n+                        switch (channelUID.getId()) {\n+                            case CHANNEL_ROLLERSHUTTER:\n+                                handleScreenposCommand(QRol, command);\n+                                updateStatus(ThingStatus.ONLINE);\n+                                break;\n+\n+                            case CHANNEL_SLATS:\n+                                handleSlatsposCommand(QRol, command);\n+                                updateStatus(ThingStatus.ONLINE);\n+                                break;\n+\n+                            default:\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                        \"Channel unknown \" + channelUID.getId());\n+                        }\n+                    }\n+                });\n+            }\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param message\n+     */\n+    public void thingOffline(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, message);\n+    }\n+\n+    /**\n+     * Executes the command for screen up/down position\n+     */\n+    private void handleScreenposCommand(QbusRol QRol, Command command) {\n+        @Nullable\n+        String snr = getSN();\n+        if (command instanceof org.openhab.core.library.types.UpDownType) {", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg2Mzc1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573863751", "bodyText": "Please remove this empty line.", "author": "fwolter", "createdAt": "2021-02-10T16:12:22Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusRolHandler.java", "diffHunk": "@@ -0,0 +1,357 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+import static org.openhab.core.types.RefreshType.REFRESH;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.binding.qbus.internal.protocol.QbusRol;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link QbusRolHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusRolHandler extends QbusGlobalHandler {\n+\n+    public QbusRolHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    protected @NonNullByDefault({}) QbusThingsConfig config;\n+\n+    int rolId;\n+\n+    @Nullable\n+    String sn;\n+\n+    /**\n+     * Main initialization\n+     */\n+    @Override\n+    public void initialize() {\n+\n+        setConfig();\n+        rolId = getId();\n+\n+        QbusCommunication QComm = getCommunication(\"Screen/Store\", rolId);\n+        if (QComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+\n+        QbusBridgeHandler QBridgeHandler = getBridgeHandler(\"Screen/Store\", rolId);\n+        if (QBridgeHandler == null) {\n+            return;\n+        }\n+\n+        setSN();\n+\n+        Map<Integer, QbusRol> rolComm = QComm.getRol();\n+\n+        if (rolComm != null) {\n+            QbusRol QRol = rolComm.get(rolId);\n+            if (QRol != null) {\n+                QRol.setThingHandler(this);\n+                handleStateUpdate(QRol);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Error while initializing the thing.\");\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Error while initializing the thing.\");\n+        }\n+    }\n+\n+    /**\n+     * Returns the serial number of the controller\n+     *\n+     * @return the serial nr\n+     */\n+    public @Nullable String getSN() {\n+        return this.sn;\n+    }\n+\n+    /**\n+     * Sets the serial number of the controller\n+     */\n+    public void setSN() {\n+        QbusBridgeHandler QBridgeHandler = getBridgeHandler(\"Screen/Store\", rolId);\n+        if (QBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+        this.sn = QBridgeHandler.getSn();\n+        ;\n+    }\n+\n+    /**\n+     * Handle the status update from the thing\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        QbusCommunication QComm = getCommunication(\"Screen/Store\", rolId);\n+\n+        if (QComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Bridge communication not initialized when trying to execute command for Screen/Store \" + rolId);\n+            return;\n+        }\n+\n+        Map<Integer, QbusRol> rolComm = QComm.getRol();\n+\n+        if (rolComm != null) {\n+            QbusRol QRol = rolComm.get(rolId);\n+            if (QRol == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Bridge communication not initialized when trying to execute command for ROL \" + rolId);\n+                return;\n+            } else {\n+                scheduler.submit(() -> {\n+                    if (!QComm.communicationActive()) {\n+                        restartCommunication(QComm, \"Screen/Store\", rolId);\n+                    }\n+\n+                    if (QComm.communicationActive()) {\n+\n+                        if (command == REFRESH) {\n+                            handleStateUpdate(QRol);\n+                            return;\n+                        }\n+\n+                        switch (channelUID.getId()) {\n+                            case CHANNEL_ROLLERSHUTTER:\n+                                handleScreenposCommand(QRol, command);\n+                                updateStatus(ThingStatus.ONLINE);\n+                                break;\n+\n+                            case CHANNEL_SLATS:\n+                                handleSlatsposCommand(QRol, command);\n+                                updateStatus(ThingStatus.ONLINE);\n+                                break;\n+\n+                            default:\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                        \"Channel unknown \" + channelUID.getId());\n+                        }\n+                    }\n+                });\n+            }\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param message\n+     */\n+    public void thingOffline(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, message);\n+    }\n+\n+    /**\n+     * Executes the command for screen up/down position\n+     */\n+    private void handleScreenposCommand(QbusRol QRol, Command command) {\n+        @Nullable\n+        String snr = getSN();\n+        if (command instanceof org.openhab.core.library.types.UpDownType) {\n+            org.openhab.core.library.types.UpDownType s = (org.openhab.core.library.types.UpDownType) command;\n+            if (s == org.openhab.core.library.types.UpDownType.DOWN) {\n+                if (snr != null) {\n+                    QRol.execute(0, snr);\n+                } else {\n+                    thingOffline(\"No serial number configured for  \" + rolId);\n+                }\n+            } else {\n+                if (snr != null) {\n+                    QRol.execute(100, snr);\n+                } else {\n+                    thingOffline(\"No serial number configured for  \" + rolId);\n+                }\n+            }\n+        } else if (command instanceof IncreaseDecreaseType)\n+", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg2NTk1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573865951", "bodyText": "Please check all.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                private QbusCommunication QComm;\n          \n          \n            \n                private @Nullable QbusCommunication QComm;", "author": "fwolter", "createdAt": "2021-02-10T16:15:11Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusBistabiel.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.handler.QbusBistabielHandler;\n+\n+/**\n+ * The {@link QbusBistabiel} class represents the Qbus BISTABIEL output.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusBistabiel {\n+\n+    @Nullable\n+    private QbusCommunication QComm;", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg2Njc4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573866787", "bodyText": "Primitive types should be used where possible.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Boolean CTDConnected = false;\n          \n          \n            \n                private boolean CTDConnected = false;", "author": "fwolter", "createdAt": "2021-02-10T16:16:12Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,926 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    @Nullable\n+    private Socket qSocket;\n+    @Nullable\n+    private PrintWriter qOut;\n+    @Nullable\n+    private BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+    @Nullable\n+    private String CTD;\n+\n+    private Boolean CTDConnected = false;", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg2NzQzMw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573867433", "bodyText": "What's the purpose of this sleep?", "author": "fwolter", "createdAt": "2021-02-10T16:17:02Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,926 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    @Nullable\n+    private Socket qSocket;\n+    @Nullable\n+    private PrintWriter qOut;\n+    @Nullable\n+    private BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+    @Nullable\n+    private String CTD;\n+\n+    private Boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    @Nullable\n+    private QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     *\n+     */\n+\n+    public synchronized void startCommunication() {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+        try {\n+\n+            for (int i = 1; qEventsRunning && (i <= 5); i++) {\n+                Thread.sleep(1000);", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg2NzU5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573867591", "bodyText": "You could add this message to the IOException. Then, you only need one logging statement for all exceptions in the catch block.", "author": "fwolter", "createdAt": "2021-02-10T16:17:12Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,926 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    @Nullable\n+    private Socket qSocket;\n+    @Nullable\n+    private PrintWriter qOut;\n+    @Nullable\n+    private BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+    @Nullable\n+    private String CTD;\n+\n+    private Boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    @Nullable\n+    private QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     *\n+     */\n+\n+    public synchronized void startCommunication() {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+        try {\n+\n+            for (int i = 1; qEventsRunning && (i <= 5); i++) {\n+                Thread.sleep(1000);\n+            }\n+            if (qEventsRunning) {\n+                logger.error(\"Starting from thread {}, but previous connection still active after 5000ms\",\n+                        Thread.currentThread().getId());", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg2OTQ5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573869492", "bodyText": "You could add a message to give the user a clue what's wrong.", "author": "fwolter", "createdAt": "2021-02-10T16:19:15Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,926 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    @Nullable\n+    private Socket qSocket;\n+    @Nullable\n+    private PrintWriter qOut;\n+    @Nullable\n+    private BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+    @Nullable\n+    private String CTD;\n+\n+    private Boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    @Nullable\n+    private QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     *\n+     */\n+\n+    public synchronized void startCommunication() {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+        try {\n+\n+            for (int i = 1; qEventsRunning && (i <= 5); i++) {\n+                Thread.sleep(1000);\n+            }\n+            if (qEventsRunning) {\n+                logger.error(\"Starting from thread {}, but previous connection still active after 5000ms\",\n+                        Thread.currentThread().getId());\n+                throw new IOException();\n+            }\n+\n+            if (handler == null) {\n+                throw new IOException();", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg2OTc4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573869786", "bodyText": "Logging to info should be used sparsely e.g. a newly started component or a user file that has been loaded. This could be debug.", "author": "fwolter", "createdAt": "2021-02-10T16:19:36Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,926 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    @Nullable\n+    private Socket qSocket;\n+    @Nullable\n+    private PrintWriter qOut;\n+    @Nullable\n+    private BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+    @Nullable\n+    private String CTD;\n+\n+    private Boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    @Nullable\n+    private QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     *\n+     */\n+\n+    public synchronized void startCommunication() {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+        try {\n+\n+            for (int i = 1; qEventsRunning && (i <= 5); i++) {\n+                Thread.sleep(1000);\n+            }\n+            if (qEventsRunning) {\n+                logger.error(\"Starting from thread {}, but previous connection still active after 5000ms\",\n+                        Thread.currentThread().getId());\n+                throw new IOException();\n+            }\n+\n+            if (handler == null) {\n+                throw new IOException();\n+            }\n+\n+            InetAddress addr = InetAddress.getByName(handler.getAddress());\n+            Integer port = handler.getPort();\n+\n+            if (port != null) {\n+                Socket socket = new Socket(addr, port);\n+                qSocket = socket;\n+                qOut = new PrintWriter(socket.getOutputStream(), true);\n+                qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                logger.info(\"Connected via local port {} from thread {}\", socket.getLocalPort(),", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg3Mjk1MA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573872950", "bodyText": "Threads created by bindings should be named and set to daemon mode. You can achieve this by using NamedThreadFactory. Here are some examples: https://github.com/openhab/openhab-addons/search?q=namedthreadfactory", "author": "fwolter", "createdAt": "2021-02-10T16:23:27Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,926 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    @Nullable\n+    private Socket qSocket;\n+    @Nullable\n+    private PrintWriter qOut;\n+    @Nullable\n+    private BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+    @Nullable\n+    private String CTD;\n+\n+    private Boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    @Nullable\n+    private QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     *\n+     */\n+\n+    public synchronized void startCommunication() {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+        try {\n+\n+            for (int i = 1; qEventsRunning && (i <= 5); i++) {\n+                Thread.sleep(1000);\n+            }\n+            if (qEventsRunning) {\n+                logger.error(\"Starting from thread {}, but previous connection still active after 5000ms\",\n+                        Thread.currentThread().getId());\n+                throw new IOException();\n+            }\n+\n+            if (handler == null) {\n+                throw new IOException();\n+            }\n+\n+            InetAddress addr = InetAddress.getByName(handler.getAddress());\n+            Integer port = handler.getPort();\n+\n+            if (port != null) {\n+                Socket socket = new Socket(addr, port);\n+                qSocket = socket;\n+                qOut = new PrintWriter(socket.getOutputStream(), true);\n+                qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                logger.info(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                        Thread.currentThread().getId());\n+            } else {\n+                return;\n+            }\n+\n+            setSN();\n+            getSN();\n+\n+            // Connect to Qbus server\n+            Connect();\n+\n+            // If Qbus Client is connected then initialize, else put Bridge offline\n+            if (CTDConnected == true) {\n+                initialize();\n+                (new Thread(qEvents)).start();", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg3NDg3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573874872", "bodyText": "The InterruptedException is thrown when OH is shut-down. That means the current operation should be finished as fast as possible and no further operations should be done. You can achieve this by not catching the exception here but throw the InterruptedException and catch it at the highest level you can. As this is not an error, it shouldn't be logged, but only handled.", "author": "fwolter", "createdAt": "2021-02-10T16:25:45Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,926 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    @Nullable\n+    private Socket qSocket;\n+    @Nullable\n+    private PrintWriter qOut;\n+    @Nullable\n+    private BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+    @Nullable\n+    private String CTD;\n+\n+    private Boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    @Nullable\n+    private QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     *\n+     */\n+\n+    public synchronized void startCommunication() {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+        try {\n+\n+            for (int i = 1; qEventsRunning && (i <= 5); i++) {\n+                Thread.sleep(1000);\n+            }\n+            if (qEventsRunning) {\n+                logger.error(\"Starting from thread {}, but previous connection still active after 5000ms\",\n+                        Thread.currentThread().getId());\n+                throw new IOException();\n+            }\n+\n+            if (handler == null) {\n+                throw new IOException();\n+            }\n+\n+            InetAddress addr = InetAddress.getByName(handler.getAddress());\n+            Integer port = handler.getPort();\n+\n+            if (port != null) {\n+                Socket socket = new Socket(addr, port);\n+                qSocket = socket;\n+                qOut = new PrintWriter(socket.getOutputStream(), true);\n+                qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                logger.info(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                        Thread.currentThread().getId());\n+            } else {\n+                return;\n+            }\n+\n+            setSN();\n+            getSN();\n+\n+            // Connect to Qbus server\n+            Connect();\n+\n+            // If Qbus Client is connected then initialize, else put Bridge offline\n+            if (CTDConnected == true) {\n+                initialize();\n+                (new Thread(qEvents)).start();\n+            } else {\n+                handler.bridgeOffline(\"No communication with Qbus client\");\n+            }\n+        } catch (IOException | InterruptedException e) {", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg3NjE5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573876193", "bodyText": "You could make this a private method. Then, you can use it when creating the thread by this::myMethod.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Runnable qEvents = () -> {\n          \n          \n            \n                private void myMethod() {", "author": "fwolter", "createdAt": "2021-02-10T16:27:19Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,926 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    @Nullable\n+    private Socket qSocket;\n+    @Nullable\n+    private PrintWriter qOut;\n+    @Nullable\n+    private BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+    @Nullable\n+    private String CTD;\n+\n+    private Boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    @Nullable\n+    private QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     *\n+     */\n+\n+    public synchronized void startCommunication() {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+        try {\n+\n+            for (int i = 1; qEventsRunning && (i <= 5); i++) {\n+                Thread.sleep(1000);\n+            }\n+            if (qEventsRunning) {\n+                logger.error(\"Starting from thread {}, but previous connection still active after 5000ms\",\n+                        Thread.currentThread().getId());\n+                throw new IOException();\n+            }\n+\n+            if (handler == null) {\n+                throw new IOException();\n+            }\n+\n+            InetAddress addr = InetAddress.getByName(handler.getAddress());\n+            Integer port = handler.getPort();\n+\n+            if (port != null) {\n+                Socket socket = new Socket(addr, port);\n+                qSocket = socket;\n+                qOut = new PrintWriter(socket.getOutputStream(), true);\n+                qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                logger.info(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                        Thread.currentThread().getId());\n+            } else {\n+                return;\n+            }\n+\n+            setSN();\n+            getSN();\n+\n+            // Connect to Qbus server\n+            Connect();\n+\n+            // If Qbus Client is connected then initialize, else put Bridge offline\n+            if (CTDConnected == true) {\n+                initialize();\n+                (new Thread(qEvents)).start();\n+            } else {\n+                handler.bridgeOffline(\"No communication with Qbus client\");\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            logger.warn(\"Error initializing communication from thread {}\", Thread.currentThread().getId());\n+            // No connection with Qbus server, put Bridge offline\n+            stopCommunication();\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No communication with Qbus server\");\n+            }\n+\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        CTDConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     */\n+    public synchronized void restartCommunication() {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        startCommunication();\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return CTDConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     */\n+    private Runnable qEvents = () -> {", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg3NjM2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573876369", "bodyText": "Logging to info should be used sparsely e.g. a newly started component or a user file that has been loaded. This could be debug.\nPlease check all.", "author": "fwolter", "createdAt": "2021-02-10T16:27:30Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,926 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    @Nullable\n+    private Socket qSocket;\n+    @Nullable\n+    private PrintWriter qOut;\n+    @Nullable\n+    private BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+    @Nullable\n+    private String CTD;\n+\n+    private Boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    @Nullable\n+    private QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     *\n+     */\n+\n+    public synchronized void startCommunication() {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+        try {\n+\n+            for (int i = 1; qEventsRunning && (i <= 5); i++) {\n+                Thread.sleep(1000);\n+            }\n+            if (qEventsRunning) {\n+                logger.error(\"Starting from thread {}, but previous connection still active after 5000ms\",\n+                        Thread.currentThread().getId());\n+                throw new IOException();\n+            }\n+\n+            if (handler == null) {\n+                throw new IOException();\n+            }\n+\n+            InetAddress addr = InetAddress.getByName(handler.getAddress());\n+            Integer port = handler.getPort();\n+\n+            if (port != null) {\n+                Socket socket = new Socket(addr, port);\n+                qSocket = socket;\n+                qOut = new PrintWriter(socket.getOutputStream(), true);\n+                qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                logger.info(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                        Thread.currentThread().getId());\n+            } else {\n+                return;\n+            }\n+\n+            setSN();\n+            getSN();\n+\n+            // Connect to Qbus server\n+            Connect();\n+\n+            // If Qbus Client is connected then initialize, else put Bridge offline\n+            if (CTDConnected == true) {\n+                initialize();\n+                (new Thread(qEvents)).start();\n+            } else {\n+                handler.bridgeOffline(\"No communication with Qbus client\");\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            logger.warn(\"Error initializing communication from thread {}\", Thread.currentThread().getId());\n+            // No connection with Qbus server, put Bridge offline\n+            stopCommunication();\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No communication with Qbus server\");\n+            }\n+\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        CTDConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     */\n+    public synchronized void restartCommunication() {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        startCommunication();\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return CTDConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     */\n+    private Runnable qEvents = () -> {\n+        String qMessage;\n+\n+        logger.info(\"Listening for events on thread {}\", Thread.currentThread().getId());", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Njg4NjE3OA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r576886178", "bodyText": "Is it ok to use logge.trace here?", "author": "QbusKoen", "createdAt": "2021-02-16T14:57:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg3NjM2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Njg4OTE1OA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r576889158", "bodyText": "Yes.", "author": "fwolter", "createdAt": "2021-02-16T15:00:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg3NjM2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Njg5MDYxNg==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r576890616", "bodyText": ":-) THX!", "author": "QbusKoen", "createdAt": "2021-02-16T15:02:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg3NjM2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMyNzUzMw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581327533", "bodyText": "I still see info.", "author": "fwolter", "createdAt": "2021-02-23T19:29:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg3NjM2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjE1OTEyNA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r582159124", "bodyText": "Can you work on this?", "author": "fwolter", "createdAt": "2021-02-24T17:32:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg3NjM2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg3NjYyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573876629", "bodyText": "See above. Add a message. Please check all.", "author": "fwolter", "createdAt": "2021-02-10T16:27:48Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,926 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    @Nullable\n+    private Socket qSocket;\n+    @Nullable\n+    private PrintWriter qOut;\n+    @Nullable\n+    private BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+    @Nullable\n+    private String CTD;\n+\n+    private Boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    @Nullable\n+    private QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     *\n+     */\n+\n+    public synchronized void startCommunication() {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+        try {\n+\n+            for (int i = 1; qEventsRunning && (i <= 5); i++) {\n+                Thread.sleep(1000);\n+            }\n+            if (qEventsRunning) {\n+                logger.error(\"Starting from thread {}, but previous connection still active after 5000ms\",\n+                        Thread.currentThread().getId());\n+                throw new IOException();\n+            }\n+\n+            if (handler == null) {\n+                throw new IOException();\n+            }\n+\n+            InetAddress addr = InetAddress.getByName(handler.getAddress());\n+            Integer port = handler.getPort();\n+\n+            if (port != null) {\n+                Socket socket = new Socket(addr, port);\n+                qSocket = socket;\n+                qOut = new PrintWriter(socket.getOutputStream(), true);\n+                qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                logger.info(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                        Thread.currentThread().getId());\n+            } else {\n+                return;\n+            }\n+\n+            setSN();\n+            getSN();\n+\n+            // Connect to Qbus server\n+            Connect();\n+\n+            // If Qbus Client is connected then initialize, else put Bridge offline\n+            if (CTDConnected == true) {\n+                initialize();\n+                (new Thread(qEvents)).start();\n+            } else {\n+                handler.bridgeOffline(\"No communication with Qbus client\");\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            logger.warn(\"Error initializing communication from thread {}\", Thread.currentThread().getId());\n+            // No connection with Qbus server, put Bridge offline\n+            stopCommunication();\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No communication with Qbus server\");\n+            }\n+\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        CTDConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     */\n+    public synchronized void restartCommunication() {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        startCommunication();\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return CTDConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     */\n+    private Runnable qEvents = () -> {\n+        String qMessage;\n+\n+        logger.info(\"Listening for events on thread {}\", Thread.currentThread().getId());\n+        listenerStopped = false;\n+        qEventsRunning = true;\n+\n+        BufferedReader reader = qIn;\n+\n+        try {\n+            if (reader == null) {\n+                throw new IOException();", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg3ODcxOA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573878718", "bodyText": "You could use the built-in interrupted flag. The thread is interrupted when you call thread.interrupt().\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        while (!listenerStopped & ((qMessage = reader.readLine()) != null)) {\n          \n          \n            \n                        while (!Thread.currentThread().isInterrupted() & ((qMessage = reader.readLine()) != null)) {", "author": "fwolter", "createdAt": "2021-02-10T16:30:10Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,926 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    @Nullable\n+    private Socket qSocket;\n+    @Nullable\n+    private PrintWriter qOut;\n+    @Nullable\n+    private BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+    @Nullable\n+    private String CTD;\n+\n+    private Boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    @Nullable\n+    private QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     *\n+     */\n+\n+    public synchronized void startCommunication() {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+        try {\n+\n+            for (int i = 1; qEventsRunning && (i <= 5); i++) {\n+                Thread.sleep(1000);\n+            }\n+            if (qEventsRunning) {\n+                logger.error(\"Starting from thread {}, but previous connection still active after 5000ms\",\n+                        Thread.currentThread().getId());\n+                throw new IOException();\n+            }\n+\n+            if (handler == null) {\n+                throw new IOException();\n+            }\n+\n+            InetAddress addr = InetAddress.getByName(handler.getAddress());\n+            Integer port = handler.getPort();\n+\n+            if (port != null) {\n+                Socket socket = new Socket(addr, port);\n+                qSocket = socket;\n+                qOut = new PrintWriter(socket.getOutputStream(), true);\n+                qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                logger.info(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                        Thread.currentThread().getId());\n+            } else {\n+                return;\n+            }\n+\n+            setSN();\n+            getSN();\n+\n+            // Connect to Qbus server\n+            Connect();\n+\n+            // If Qbus Client is connected then initialize, else put Bridge offline\n+            if (CTDConnected == true) {\n+                initialize();\n+                (new Thread(qEvents)).start();\n+            } else {\n+                handler.bridgeOffline(\"No communication with Qbus client\");\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            logger.warn(\"Error initializing communication from thread {}\", Thread.currentThread().getId());\n+            // No connection with Qbus server, put Bridge offline\n+            stopCommunication();\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No communication with Qbus server\");\n+            }\n+\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        CTDConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     */\n+    public synchronized void restartCommunication() {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        startCommunication();\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return CTDConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     */\n+    private Runnable qEvents = () -> {\n+        String qMessage;\n+\n+        logger.info(\"Listening for events on thread {}\", Thread.currentThread().getId());\n+        listenerStopped = false;\n+        qEventsRunning = true;\n+\n+        BufferedReader reader = qIn;\n+\n+        try {\n+            if (reader == null) {\n+                throw new IOException();\n+            }\n+            while (!listenerStopped & ((qMessage = reader.readLine()) != null)) {", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg3OTUyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573879525", "bodyText": "Stopping a thread is a normal operation when OH is shut-down. You could make this debug or trace.", "author": "fwolter", "createdAt": "2021-02-10T16:31:08Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,926 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    @Nullable\n+    private Socket qSocket;\n+    @Nullable\n+    private PrintWriter qOut;\n+    @Nullable\n+    private BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+    @Nullable\n+    private String CTD;\n+\n+    private Boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    @Nullable\n+    private QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     *\n+     */\n+\n+    public synchronized void startCommunication() {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+        try {\n+\n+            for (int i = 1; qEventsRunning && (i <= 5); i++) {\n+                Thread.sleep(1000);\n+            }\n+            if (qEventsRunning) {\n+                logger.error(\"Starting from thread {}, but previous connection still active after 5000ms\",\n+                        Thread.currentThread().getId());\n+                throw new IOException();\n+            }\n+\n+            if (handler == null) {\n+                throw new IOException();\n+            }\n+\n+            InetAddress addr = InetAddress.getByName(handler.getAddress());\n+            Integer port = handler.getPort();\n+\n+            if (port != null) {\n+                Socket socket = new Socket(addr, port);\n+                qSocket = socket;\n+                qOut = new PrintWriter(socket.getOutputStream(), true);\n+                qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                logger.info(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                        Thread.currentThread().getId());\n+            } else {\n+                return;\n+            }\n+\n+            setSN();\n+            getSN();\n+\n+            // Connect to Qbus server\n+            Connect();\n+\n+            // If Qbus Client is connected then initialize, else put Bridge offline\n+            if (CTDConnected == true) {\n+                initialize();\n+                (new Thread(qEvents)).start();\n+            } else {\n+                handler.bridgeOffline(\"No communication with Qbus client\");\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            logger.warn(\"Error initializing communication from thread {}\", Thread.currentThread().getId());\n+            // No connection with Qbus server, put Bridge offline\n+            stopCommunication();\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No communication with Qbus server\");\n+            }\n+\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        CTDConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     */\n+    public synchronized void restartCommunication() {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        startCommunication();\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return CTDConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     */\n+    private Runnable qEvents = () -> {\n+        String qMessage;\n+\n+        logger.info(\"Listening for events on thread {}\", Thread.currentThread().getId());\n+        listenerStopped = false;\n+        qEventsRunning = true;\n+\n+        BufferedReader reader = qIn;\n+\n+        try {\n+            if (reader == null) {\n+                throw new IOException();\n+            }\n+            while (!listenerStopped & ((qMessage = reader.readLine()) != null)) {\n+                if (qMessage != null) {\n+                    readMessage(qMessage);\n+                }\n+            }\n+        } catch (IOException e) {\n+            if (!listenerStopped) {\n+                qEventsRunning = false;\n+                logger.warn(\"Qbus: IO error in listener on thread {}\", Thread.currentThread().getId());\n+\n+                QbusBridgeHandler handler = bridgeCallBack;\n+\n+                if (handler != null) {\n+                    CTDConnected = false;\n+                    handler.bridgeOffline(\"No communication with Qbus server\");\n+                }\n+\n+                return;\n+            }\n+        }\n+\n+        qEventsRunning = false;\n+\n+        logger.warn(\"Event listener thread stopped on thread {}\", Thread.currentThread().getId());", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg4MDEzNA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573880134", "bodyText": "See above. Throw InterruptedException.", "author": "fwolter", "createdAt": "2021-02-10T16:31:55Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,926 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    @Nullable\n+    private Socket qSocket;\n+    @Nullable\n+    private PrintWriter qOut;\n+    @Nullable\n+    private BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+    @Nullable\n+    private String CTD;\n+\n+    private Boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    @Nullable\n+    private QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     *\n+     */\n+\n+    public synchronized void startCommunication() {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+        try {\n+\n+            for (int i = 1; qEventsRunning && (i <= 5); i++) {\n+                Thread.sleep(1000);\n+            }\n+            if (qEventsRunning) {\n+                logger.error(\"Starting from thread {}, but previous connection still active after 5000ms\",\n+                        Thread.currentThread().getId());\n+                throw new IOException();\n+            }\n+\n+            if (handler == null) {\n+                throw new IOException();\n+            }\n+\n+            InetAddress addr = InetAddress.getByName(handler.getAddress());\n+            Integer port = handler.getPort();\n+\n+            if (port != null) {\n+                Socket socket = new Socket(addr, port);\n+                qSocket = socket;\n+                qOut = new PrintWriter(socket.getOutputStream(), true);\n+                qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                logger.info(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                        Thread.currentThread().getId());\n+            } else {\n+                return;\n+            }\n+\n+            setSN();\n+            getSN();\n+\n+            // Connect to Qbus server\n+            Connect();\n+\n+            // If Qbus Client is connected then initialize, else put Bridge offline\n+            if (CTDConnected == true) {\n+                initialize();\n+                (new Thread(qEvents)).start();\n+            } else {\n+                handler.bridgeOffline(\"No communication with Qbus client\");\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            logger.warn(\"Error initializing communication from thread {}\", Thread.currentThread().getId());\n+            // No connection with Qbus server, put Bridge offline\n+            stopCommunication();\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No communication with Qbus server\");\n+            }\n+\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        CTDConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     */\n+    public synchronized void restartCommunication() {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        startCommunication();\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return CTDConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     */\n+    private Runnable qEvents = () -> {\n+        String qMessage;\n+\n+        logger.info(\"Listening for events on thread {}\", Thread.currentThread().getId());\n+        listenerStopped = false;\n+        qEventsRunning = true;\n+\n+        BufferedReader reader = qIn;\n+\n+        try {\n+            if (reader == null) {\n+                throw new IOException();\n+            }\n+            while (!listenerStopped & ((qMessage = reader.readLine()) != null)) {\n+                if (qMessage != null) {\n+                    readMessage(qMessage);\n+                }\n+            }\n+        } catch (IOException e) {\n+            if (!listenerStopped) {\n+                qEventsRunning = false;\n+                logger.warn(\"Qbus: IO error in listener on thread {}\", Thread.currentThread().getId());\n+\n+                QbusBridgeHandler handler = bridgeCallBack;\n+\n+                if (handler != null) {\n+                    CTDConnected = false;\n+                    handler.bridgeOffline(\"No communication with Qbus server\");\n+                }\n+\n+                return;\n+            }\n+        }\n+\n+        qEventsRunning = false;\n+\n+        logger.warn(\"Event listener thread stopped on thread {}\", Thread.currentThread().getId());\n+\n+    };\n+\n+    /**\n+     * Called by other methods to send json data to Qbus.\n+     *\n+     * @param qMessage\n+     */\n+    synchronized void sendMessage(Object qMessage) {\n+        PrintWriter writer = qOut;\n+        String json = gsonOut.toJson(qMessage);\n+\n+        if (writer != null) {\n+            writer.println(json);\n+            // Delay after sending data to improve scene execution\n+            try {\n+                TimeUnit.MILLISECONDS.sleep(250);\n+            } catch (InterruptedException e) {", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjE1OTUzOA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r582159538", "bodyText": "Can you work on this?", "author": "fwolter", "createdAt": "2021-02-24T17:33:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg4MDEzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg4MTE0OA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573881148", "bodyText": "See above. Logging to error. Please check all.", "author": "fwolter", "createdAt": "2021-02-10T16:33:09Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,926 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    @Nullable\n+    private Socket qSocket;\n+    @Nullable\n+    private PrintWriter qOut;\n+    @Nullable\n+    private BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+    @Nullable\n+    private String CTD;\n+\n+    private Boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    @Nullable\n+    private QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     *\n+     */\n+\n+    public synchronized void startCommunication() {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+        try {\n+\n+            for (int i = 1; qEventsRunning && (i <= 5); i++) {\n+                Thread.sleep(1000);\n+            }\n+            if (qEventsRunning) {\n+                logger.error(\"Starting from thread {}, but previous connection still active after 5000ms\",\n+                        Thread.currentThread().getId());\n+                throw new IOException();\n+            }\n+\n+            if (handler == null) {\n+                throw new IOException();\n+            }\n+\n+            InetAddress addr = InetAddress.getByName(handler.getAddress());\n+            Integer port = handler.getPort();\n+\n+            if (port != null) {\n+                Socket socket = new Socket(addr, port);\n+                qSocket = socket;\n+                qOut = new PrintWriter(socket.getOutputStream(), true);\n+                qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                logger.info(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                        Thread.currentThread().getId());\n+            } else {\n+                return;\n+            }\n+\n+            setSN();\n+            getSN();\n+\n+            // Connect to Qbus server\n+            Connect();\n+\n+            // If Qbus Client is connected then initialize, else put Bridge offline\n+            if (CTDConnected == true) {\n+                initialize();\n+                (new Thread(qEvents)).start();\n+            } else {\n+                handler.bridgeOffline(\"No communication with Qbus client\");\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            logger.warn(\"Error initializing communication from thread {}\", Thread.currentThread().getId());\n+            // No connection with Qbus server, put Bridge offline\n+            stopCommunication();\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No communication with Qbus server\");\n+            }\n+\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        CTDConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     */\n+    public synchronized void restartCommunication() {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        startCommunication();\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return CTDConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     */\n+    private Runnable qEvents = () -> {\n+        String qMessage;\n+\n+        logger.info(\"Listening for events on thread {}\", Thread.currentThread().getId());\n+        listenerStopped = false;\n+        qEventsRunning = true;\n+\n+        BufferedReader reader = qIn;\n+\n+        try {\n+            if (reader == null) {\n+                throw new IOException();\n+            }\n+            while (!listenerStopped & ((qMessage = reader.readLine()) != null)) {\n+                if (qMessage != null) {\n+                    readMessage(qMessage);\n+                }\n+            }\n+        } catch (IOException e) {\n+            if (!listenerStopped) {\n+                qEventsRunning = false;\n+                logger.warn(\"Qbus: IO error in listener on thread {}\", Thread.currentThread().getId());\n+\n+                QbusBridgeHandler handler = bridgeCallBack;\n+\n+                if (handler != null) {\n+                    CTDConnected = false;\n+                    handler.bridgeOffline(\"No communication with Qbus server\");\n+                }\n+\n+                return;\n+            }\n+        }\n+\n+        qEventsRunning = false;\n+\n+        logger.warn(\"Event listener thread stopped on thread {}\", Thread.currentThread().getId());\n+\n+    };\n+\n+    /**\n+     * Called by other methods to send json data to Qbus.\n+     *\n+     * @param qMessage\n+     */\n+    synchronized void sendMessage(Object qMessage) {\n+        PrintWriter writer = qOut;\n+        String json = gsonOut.toJson(qMessage);\n+\n+        if (writer != null) {\n+            writer.println(json);\n+            // Delay after sending data to improve scene execution\n+            try {\n+                TimeUnit.MILLISECONDS.sleep(250);\n+            } catch (InterruptedException e) {\n+                // No reaction on error is required\n+            }\n+\n+        }\n+        if ((writer == null) || (writer.checkError())) {\n+            logger.warn(\"Error sending message, trying to restart communication\");\n+            restartCommunication();\n+            // retry sending after restart\n+            writer = qOut;\n+            if (writer != null) {\n+                writer.println(json);\n+            }\n+            if ((writer == null) || (writer.checkError())) {\n+                logger.warn(\"Error resending message\");\n+\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Called by other methods to Qbus server and read response\n+     */\n+    private void sendAndReadMessage(String command) throws IOException, InterruptedException {\n+        @Nullable\n+        String snr = getSN();\n+        if (snr != null) {\n+\n+            QbusMessageCmd qCmd = new QbusMessageCmd(snr, command);\n+\n+            sendMessage(qCmd);\n+\n+            BufferedReader reader = qIn;\n+            if (reader == null) {\n+                throw new IOException(\"Cannot read from socket, reader not connected.\");\n+            }\n+            readMessage(reader.readLine());\n+        } else {\n+            QbusBridgeHandler handler = bridgeCallBack;\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No serial nr defined\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method that interprets all feedback from Qbus Server application and calls appropriate handling methods.\n+     *\n+     * @param qMessage message read from Qbus.\n+     */\n+    private void readMessage(String qMessage) {\n+        String cmd = \"\";\n+        String CTD = \"\";\n+        String sn = null;\n+        QbusMessageBase qMessageGson;\n+\n+        qMessageGson = gsonIn.fromJson(qMessage, QbusMessageBase.class);\n+        if (qMessageGson != null) {\n+            CTD = qMessageGson.getSn();\n+            cmd = qMessageGson.getCmd();\n+        }\n+\n+        if (bridgeCallBack != null) {\n+            sn = bridgeCallBack.getSn();\n+        }\n+\n+        if (sn != null && CTD != null) {\n+            try {\n+\n+                if (Integer.parseInt(sn) == Integer.parseInt(CTD) && qMessageGson != null) {\n+                    // Get the compatible outputs from the Qbus server\n+                    if (\"returnBistabiel\".equals(cmd)) {\n+                        cmdListBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"returnDimmer\".equals(cmd)) {\n+                        cmdListDimmers(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnThermostat\").equals(cmd)) {\n+                        cmdListThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnScene\").equals(cmd)) {\n+                        cmdlistscenes(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnCo2\").equals(cmd)) {\n+                        cmdlistco2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnRol02p\").equals(cmd)) {\n+                        cmdlistrol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnSlat\").equals(cmd)) {\n+                        cmdlistrolslats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incoming commands from Qbus Client to openHAB (event)\n+                    else if (\"updateBistabiel\".equals(cmd)) {\n+                        updateBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateDimmer\".equals(cmd)) {\n+                        updateDimmers(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateThermostat\".equals(cmd)) {\n+                        updateThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateCo2\".equals(cmd)) {\n+                        updateCO2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02p\".equals(cmd)) {\n+                        updateRol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02pSlat\".equals(cmd)) {\n+                        updateRolslats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incomming commands from Qbus server to verify the client connection\n+                    else if (\"disconnect\".equals(cmd)) {\n+                        eventDisconnect();\n+                    } else if (\"notConnected\".equals(cmd)) {\n+                        noConnection();\n+                    } else if (\"connected\".equals(cmd)) {\n+                        connection();\n+                    }\n+                }\n+\n+            } catch (JsonParseException e) {\n+                logger.warn(\"Not acted on unsupported json {}\", qMessage);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * After setting up the communication with the Qbus Server, send all initialization messages.\n+     * <p>\n+     * First send connect to connect with the Qbus Server application\n+     * Get request for Bistabiel/Timers/Intervals/Mono outputs\n+     * Get request for the Scenes\n+     * Get request for Dimmers 1T and 2T\n+     * Get request for Shutters\n+     * Get request for Thermostats\n+     * Get request for CO2\n+     *\n+     *\n+     * @throws IOException\n+     * @throws InterruptedException\n+     */\n+\n+    private void initialize() throws IOException, InterruptedException {\n+\n+        if (bridgeCallBack != null) {\n+            if (CTDConnected) {\n+                sendAndReadMessage(\"getBistabiel\");\n+                sendAndReadMessage(\"getScene\");\n+                sendAndReadMessage(\"getDimmer\");\n+                sendAndReadMessage(\"getRol02p\");\n+                sendAndReadMessage(\"getRol02pSlat\");\n+                sendAndReadMessage(\"getThermostat\");\n+                sendAndReadMessage(\"getCo2\");\n+            } else {\n+                CTDConnected = false;\n+\n+                QbusBridgeHandler handler = bridgeCallBack;\n+\n+                if (handler != null) {\n+                    handler.bridgeOffline(\"No communication with Qbus client\");\n+                }\n+\n+                return;\n+            }\n+        } else {\n+            logger.error(\"Initialization error\");", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg4MjAwNg==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573882006", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void cmdlistscenes(@Nullable List<Map<String, String>> outputs) {\n          \n          \n            \n                private void cmdListScenes(@Nullable List<Map<String, String>> outputs) {", "author": "fwolter", "createdAt": "2021-02-10T16:34:04Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,926 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    @Nullable\n+    private Socket qSocket;\n+    @Nullable\n+    private PrintWriter qOut;\n+    @Nullable\n+    private BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+    @Nullable\n+    private String CTD;\n+\n+    private Boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    @Nullable\n+    private QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     *\n+     */\n+\n+    public synchronized void startCommunication() {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+        try {\n+\n+            for (int i = 1; qEventsRunning && (i <= 5); i++) {\n+                Thread.sleep(1000);\n+            }\n+            if (qEventsRunning) {\n+                logger.error(\"Starting from thread {}, but previous connection still active after 5000ms\",\n+                        Thread.currentThread().getId());\n+                throw new IOException();\n+            }\n+\n+            if (handler == null) {\n+                throw new IOException();\n+            }\n+\n+            InetAddress addr = InetAddress.getByName(handler.getAddress());\n+            Integer port = handler.getPort();\n+\n+            if (port != null) {\n+                Socket socket = new Socket(addr, port);\n+                qSocket = socket;\n+                qOut = new PrintWriter(socket.getOutputStream(), true);\n+                qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                logger.info(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                        Thread.currentThread().getId());\n+            } else {\n+                return;\n+            }\n+\n+            setSN();\n+            getSN();\n+\n+            // Connect to Qbus server\n+            Connect();\n+\n+            // If Qbus Client is connected then initialize, else put Bridge offline\n+            if (CTDConnected == true) {\n+                initialize();\n+                (new Thread(qEvents)).start();\n+            } else {\n+                handler.bridgeOffline(\"No communication with Qbus client\");\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            logger.warn(\"Error initializing communication from thread {}\", Thread.currentThread().getId());\n+            // No connection with Qbus server, put Bridge offline\n+            stopCommunication();\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No communication with Qbus server\");\n+            }\n+\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        CTDConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     */\n+    public synchronized void restartCommunication() {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        startCommunication();\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return CTDConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     */\n+    private Runnable qEvents = () -> {\n+        String qMessage;\n+\n+        logger.info(\"Listening for events on thread {}\", Thread.currentThread().getId());\n+        listenerStopped = false;\n+        qEventsRunning = true;\n+\n+        BufferedReader reader = qIn;\n+\n+        try {\n+            if (reader == null) {\n+                throw new IOException();\n+            }\n+            while (!listenerStopped & ((qMessage = reader.readLine()) != null)) {\n+                if (qMessage != null) {\n+                    readMessage(qMessage);\n+                }\n+            }\n+        } catch (IOException e) {\n+            if (!listenerStopped) {\n+                qEventsRunning = false;\n+                logger.warn(\"Qbus: IO error in listener on thread {}\", Thread.currentThread().getId());\n+\n+                QbusBridgeHandler handler = bridgeCallBack;\n+\n+                if (handler != null) {\n+                    CTDConnected = false;\n+                    handler.bridgeOffline(\"No communication with Qbus server\");\n+                }\n+\n+                return;\n+            }\n+        }\n+\n+        qEventsRunning = false;\n+\n+        logger.warn(\"Event listener thread stopped on thread {}\", Thread.currentThread().getId());\n+\n+    };\n+\n+    /**\n+     * Called by other methods to send json data to Qbus.\n+     *\n+     * @param qMessage\n+     */\n+    synchronized void sendMessage(Object qMessage) {\n+        PrintWriter writer = qOut;\n+        String json = gsonOut.toJson(qMessage);\n+\n+        if (writer != null) {\n+            writer.println(json);\n+            // Delay after sending data to improve scene execution\n+            try {\n+                TimeUnit.MILLISECONDS.sleep(250);\n+            } catch (InterruptedException e) {\n+                // No reaction on error is required\n+            }\n+\n+        }\n+        if ((writer == null) || (writer.checkError())) {\n+            logger.warn(\"Error sending message, trying to restart communication\");\n+            restartCommunication();\n+            // retry sending after restart\n+            writer = qOut;\n+            if (writer != null) {\n+                writer.println(json);\n+            }\n+            if ((writer == null) || (writer.checkError())) {\n+                logger.warn(\"Error resending message\");\n+\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Called by other methods to Qbus server and read response\n+     */\n+    private void sendAndReadMessage(String command) throws IOException, InterruptedException {\n+        @Nullable\n+        String snr = getSN();\n+        if (snr != null) {\n+\n+            QbusMessageCmd qCmd = new QbusMessageCmd(snr, command);\n+\n+            sendMessage(qCmd);\n+\n+            BufferedReader reader = qIn;\n+            if (reader == null) {\n+                throw new IOException(\"Cannot read from socket, reader not connected.\");\n+            }\n+            readMessage(reader.readLine());\n+        } else {\n+            QbusBridgeHandler handler = bridgeCallBack;\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No serial nr defined\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method that interprets all feedback from Qbus Server application and calls appropriate handling methods.\n+     *\n+     * @param qMessage message read from Qbus.\n+     */\n+    private void readMessage(String qMessage) {\n+        String cmd = \"\";\n+        String CTD = \"\";\n+        String sn = null;\n+        QbusMessageBase qMessageGson;\n+\n+        qMessageGson = gsonIn.fromJson(qMessage, QbusMessageBase.class);\n+        if (qMessageGson != null) {\n+            CTD = qMessageGson.getSn();\n+            cmd = qMessageGson.getCmd();\n+        }\n+\n+        if (bridgeCallBack != null) {\n+            sn = bridgeCallBack.getSn();\n+        }\n+\n+        if (sn != null && CTD != null) {\n+            try {\n+\n+                if (Integer.parseInt(sn) == Integer.parseInt(CTD) && qMessageGson != null) {\n+                    // Get the compatible outputs from the Qbus server\n+                    if (\"returnBistabiel\".equals(cmd)) {\n+                        cmdListBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"returnDimmer\".equals(cmd)) {\n+                        cmdListDimmers(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnThermostat\").equals(cmd)) {\n+                        cmdListThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnScene\").equals(cmd)) {\n+                        cmdlistscenes(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnCo2\").equals(cmd)) {\n+                        cmdlistco2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnRol02p\").equals(cmd)) {\n+                        cmdlistrol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnSlat\").equals(cmd)) {\n+                        cmdlistrolslats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incoming commands from Qbus Client to openHAB (event)\n+                    else if (\"updateBistabiel\".equals(cmd)) {\n+                        updateBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateDimmer\".equals(cmd)) {\n+                        updateDimmers(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateThermostat\".equals(cmd)) {\n+                        updateThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateCo2\".equals(cmd)) {\n+                        updateCO2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02p\".equals(cmd)) {\n+                        updateRol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02pSlat\".equals(cmd)) {\n+                        updateRolslats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incomming commands from Qbus server to verify the client connection\n+                    else if (\"disconnect\".equals(cmd)) {\n+                        eventDisconnect();\n+                    } else if (\"notConnected\".equals(cmd)) {\n+                        noConnection();\n+                    } else if (\"connected\".equals(cmd)) {\n+                        connection();\n+                    }\n+                }\n+\n+            } catch (JsonParseException e) {\n+                logger.warn(\"Not acted on unsupported json {}\", qMessage);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * After setting up the communication with the Qbus Server, send all initialization messages.\n+     * <p>\n+     * First send connect to connect with the Qbus Server application\n+     * Get request for Bistabiel/Timers/Intervals/Mono outputs\n+     * Get request for the Scenes\n+     * Get request for Dimmers 1T and 2T\n+     * Get request for Shutters\n+     * Get request for Thermostats\n+     * Get request for CO2\n+     *\n+     *\n+     * @throws IOException\n+     * @throws InterruptedException\n+     */\n+\n+    private void initialize() throws IOException, InterruptedException {\n+\n+        if (bridgeCallBack != null) {\n+            if (CTDConnected) {\n+                sendAndReadMessage(\"getBistabiel\");\n+                sendAndReadMessage(\"getScene\");\n+                sendAndReadMessage(\"getDimmer\");\n+                sendAndReadMessage(\"getRol02p\");\n+                sendAndReadMessage(\"getRol02pSlat\");\n+                sendAndReadMessage(\"getThermostat\");\n+                sendAndReadMessage(\"getCo2\");\n+            } else {\n+                CTDConnected = false;\n+\n+                QbusBridgeHandler handler = bridgeCallBack;\n+\n+                if (handler != null) {\n+                    handler.bridgeOffline(\"No communication with Qbus client\");\n+                }\n+\n+                return;\n+            }\n+        } else {\n+            logger.error(\"Initialization error\");\n+        }\n+    }\n+\n+    public @Nullable String getSN() {\n+        return this.CTD;\n+    }\n+\n+    public void setSN() {\n+        QbusBridgeHandler QBridgeHandler = bridgeCallBack;\n+        if (QBridgeHandler != null) {\n+            this.CTD = QBridgeHandler.getSn();\n+        }\n+    }\n+\n+    /**\n+     * Initial connection to Qbus Server to open a communication channel\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    private void Connect() throws InterruptedException, IOException {\n+        @Nullable\n+        String snr = getSN();\n+\n+        if (snr != null) {\n+            QbusMessageCmd QCmd = new QbusMessageCmd(snr, \"openHAB\");\n+\n+            sendMessage(QCmd);\n+            BufferedReader reader = qIn;\n+\n+            if (reader == null) {\n+                throw new IOException(\"Cannot read from socket, reader not connected.\");\n+            }\n+            readMessage(reader.readLine());\n+        } else {\n+            QbusBridgeHandler handler = bridgeCallBack;\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No serial nr defined\");\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+    /**\n+     * Get all the Bistabiel/Timer/Mono/Interval outputs from the Qbus client\n+     *\n+     * @param data\n+     */\n+    private void cmdListBistabiel(@Nullable List<Map<String, String>> outputs) {\n+        if (outputs != null) {\n+            for (Map<String, String> bistabiel : outputs) {\n+                String idStr = bistabiel.get(\"id\");\n+                String stateStr = bistabiel.get(\"state\");\n+                if (idStr != null && stateStr != null) {\n+                    int id = Integer.parseInt(idStr);\n+                    Integer state = Integer.parseInt(stateStr);\n+                    QbusBistabiel qBistabiel = new QbusBistabiel(idStr);\n+                    if (!this.bistabiel.containsKey(id)) {\n+                        qBistabiel.setState(state);\n+                        qBistabiel.setQComm(this);\n+                        this.bistabiel.put(id, qBistabiel);\n+                        qBistabiel.setState(state);\n+                    } else {\n+                        qBistabiel.setState(state);\n+                    }\n+                } else {\n+                    logger.error(\"Error in json for BistabBistabiel/Timers/Monos/Intervals\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get all the scenes from the Qbus server\n+     *\n+     * @param outputs\n+     */\n+    private void cmdlistscenes(@Nullable List<Map<String, String>> outputs) {", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg4NTI2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573885266", "bodyText": "It's bad practice to catch ClassCastExceptions. You could check the type beforehand with instanceof.", "author": "fwolter", "createdAt": "2021-02-10T16:37:57Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusMessageDeserializer.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonDeserializationContext;\n+import com.google.gson.JsonDeserializer;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * Class {@link QbusMessageDeserializer} deserializes all json messages from Qbus. Various json\n+ * message formats are supported. The format is selected based on the content of the cmd and event json objects.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ *\n+ */\n+\n+@NonNullByDefault\n+class QbusMessageDeserializer implements JsonDeserializer<QbusMessageBase> {\n+\n+    @Override\n+    public @Nullable QbusMessageBase deserialize(final JsonElement json, final Type typeOfT,\n+            final JsonDeserializationContext context) throws JsonParseException {\n+        final JsonObject jsonObject = json.getAsJsonObject();\n+\n+        try {\n+\n+            String cmd = null;\n+            String CTD = null;\n+\n+            if (jsonObject.has(\"cmd\")) {\n+                cmd = jsonObject.get(\"cmd\").getAsString();\n+            }\n+\n+            if (jsonObject.has(\"CTD\")) {\n+                CTD = jsonObject.get(\"CTD\").getAsString();\n+            }\n+\n+            JsonElement jsonOutputs = null;\n+\n+            if (jsonObject.has(\"outputs\")) {\n+                jsonOutputs = jsonObject.get(\"outputs\");\n+            }\n+\n+            QbusMessageBase message = null;\n+\n+            if (jsonOutputs != null) {\n+                if (jsonOutputs.isJsonObject()) {\n+                    message = new QbusMessageMap();\n+\n+                    Map<String, String> outputs = new HashMap<>();\n+                    for (Entry<String, JsonElement> entry : jsonOutputs.getAsJsonObject().entrySet()) {\n+                        outputs.put(entry.getKey(), entry.getValue().getAsString());\n+                    }\n+                    ((QbusMessageMap) message).setOutputs(outputs);\n+\n+                } else if (jsonOutputs.isJsonArray()) {\n+                    JsonArray jsonOutputsArray = jsonOutputs.getAsJsonArray();\n+\n+                    message = new QbusMessageListMap();\n+\n+                    List<Map<String, String>> outputsList = new ArrayList<>();\n+                    for (int i = 0; i < jsonOutputsArray.size(); i++) {\n+                        JsonObject jsonOutputsObject = jsonOutputsArray.get(i).getAsJsonObject();\n+\n+                        Map<String, String> outputs = new HashMap<>();\n+                        for (Entry<String, JsonElement> entry : jsonOutputsObject.entrySet()) {\n+                            outputs.put(entry.getKey(), entry.getValue().getAsString());\n+                        }\n+                        outputsList.add(outputs);\n+                    }\n+                    ((QbusMessageListMap) message).setOutputs(outputsList);\n+                }\n+            }\n+\n+            if (message != null && cmd != null && CTD != null) {\n+                message.setCmd(cmd);\n+                message.setSn(CTD);\n+            } else {\n+                throw new JsonParseException(\"Unexpected Json type\");\n+            }\n+\n+            return message;\n+\n+        } catch (IllegalStateException | ClassCastException e) {", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzg4NjAxNg==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r573886016", "bodyText": "Primitive types should be used where possible.", "author": "fwolter", "createdAt": "2021-02-10T16:38:33Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusThermostat.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.handler.QbusThermostatHandler;\n+\n+/**\n+ * The {@link QbusThermostat} class represents the thermostat Qbus communication object. It contains all\n+ * fields representing a Qbus thermostat and has methods to set the thermostat mode and setpoint in Qbus and\n+ * receive thermostat updates.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusThermostat {\n+\n+    @Nullable\n+    private QbusCommunication qComm;\n+\n+    private String id;\n+    private Double measured = 0.0;\n+    private Double setpoint = 0.0;\n+    private Integer mode = 0;", "originalCommit": "d681e87c89ebf6d681fc68fe5ed6a10f8ba22735", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "96d8d832f392965564c7f72dabb9f00f0685afca", "url": "https://github.com/openhab/openhab-addons/commit/96d8d832f392965564c7f72dabb9f00f0685afca", "message": "Updated requested changes\n\nUpdated requested changes by fwolter on 10/02/2021\n\nSigned-off-by: Koen Schockaert <ks@qbus.be>\nSigned-off-by: QbusKoen <ks@qbus.be>", "committedDate": "2021-02-23T08:56:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMxNzkzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581317939", "bodyText": "It seems these can all be handled in the same if.", "author": "fwolter", "createdAt": "2021-02-23T19:15:27Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private @Nullable QbusCommunication qbusComm;\n+\n+    protected @Nullable QbusConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    /**\n+     * Initialize the bridge\n+     */\n+    @Override\n+    public void initialize() {\n+        readConfig();\n+\n+        InetAddress addr;\n+        Integer port = getPort();\n+        Integer refresh = getRefresh();\n+\n+        if (port == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No port defined for Qbus Server\");\n+            return;\n+        }\n+\n+        try {\n+            addr = InetAddress.getByName(getAddress());\n+            if (addr == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"No ip address defined for Qbus Server\");\n+                return;\n+            } else {\n+                createCommunicationObject(addr, port);\n+            }\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Incorrect ip address set for Qbus Server\");\n+        }\n+\n+        if (refresh != null) {\n+            this.setupRefreshTimer(refresh);\n+        }\n+    }\n+\n+    /**\n+     * Sets the Bridge call back\n+     */\n+    private void setBridgeCallBack() {\n+        if (qbusComm != null) {\n+            qbusComm.setBridgeCallBack(this);\n+        }\n+    }\n+\n+    /**\n+     * Create communication object to Qbus server and start communication.\n+     *\n+     * @param addr : IP address of Qbus server\n+     * @param port : Communication port of QbusServer\n+     */\n+    private void createCommunicationObject(InetAddress addr, int port) {\n+        scheduler.submit(() -> {\n+\n+            qbusComm = new QbusCommunication();\n+\n+            setBridgeCallBack();\n+\n+            if (qbusComm != null) {\n+                try {\n+                    qbusComm.startCommunication();\n+                } catch (InterruptedException | IOException e) {\n+                    logger.warn(\"Error on restaring communication.\");\n+                }\n+            }\n+\n+            if (qbusComm != null) {\n+                if (!qbusComm.communicationActive()) {\n+                    qbusComm = null;\n+                    bridgeOffline(\"No communication with Qbus Server\");\n+                    return;\n+                }\n+            }\n+\n+            if (qbusComm != null) {\n+                if (!qbusComm.clientConnected()) {\n+\n+                    qbusComm = null;\n+                    bridgeOffline(\"No communication with Qbus Client\");\n+                    return;\n+                }\n+            }", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMxODM1MA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581318350", "bodyText": "It's good practice to append the exception's message to the log message. Should the Thing set to OFFLINE here?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                logger.warn(\"Error on restaring communication.\");\n          \n          \n            \n                                logger.warn(\"Error on restaring communication: {}\", e.getMessage());", "author": "fwolter", "createdAt": "2021-02-23T19:15:56Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private @Nullable QbusCommunication qbusComm;\n+\n+    protected @Nullable QbusConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    /**\n+     * Initialize the bridge\n+     */\n+    @Override\n+    public void initialize() {\n+        readConfig();\n+\n+        InetAddress addr;\n+        Integer port = getPort();\n+        Integer refresh = getRefresh();\n+\n+        if (port == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No port defined for Qbus Server\");\n+            return;\n+        }\n+\n+        try {\n+            addr = InetAddress.getByName(getAddress());\n+            if (addr == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"No ip address defined for Qbus Server\");\n+                return;\n+            } else {\n+                createCommunicationObject(addr, port);\n+            }\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Incorrect ip address set for Qbus Server\");\n+        }\n+\n+        if (refresh != null) {\n+            this.setupRefreshTimer(refresh);\n+        }\n+    }\n+\n+    /**\n+     * Sets the Bridge call back\n+     */\n+    private void setBridgeCallBack() {\n+        if (qbusComm != null) {\n+            qbusComm.setBridgeCallBack(this);\n+        }\n+    }\n+\n+    /**\n+     * Create communication object to Qbus server and start communication.\n+     *\n+     * @param addr : IP address of Qbus server\n+     * @param port : Communication port of QbusServer\n+     */\n+    private void createCommunicationObject(InetAddress addr, int port) {\n+        scheduler.submit(() -> {\n+\n+            qbusComm = new QbusCommunication();\n+\n+            setBridgeCallBack();\n+\n+            if (qbusComm != null) {\n+                try {\n+                    qbusComm.startCommunication();\n+                } catch (InterruptedException | IOException e) {\n+                    logger.warn(\"Error on restaring communication.\");", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMxOTI3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581319277", "bodyText": "Please remove this empty line.", "author": "fwolter", "createdAt": "2021-02-23T19:17:24Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusHandlerFactory.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.handler.QbusBistabielHandler;\n+import org.openhab.binding.qbus.internal.handler.QbusCO2Handler;\n+import org.openhab.binding.qbus.internal.handler.QbusDimmerHandler;\n+import org.openhab.binding.qbus.internal.handler.QbusRolHandler;\n+import org.openhab.binding.qbus.internal.handler.QbusSceneHandler;\n+import org.openhab.binding.qbus.internal.handler.QbusThermostatHandler;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.service.component.annotations.Component;\n+\n+/**\n+ * The {@link qbusHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@Component(service = ThingHandlerFactory.class, configurationPid = \"binding.qbus\")\n+", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMyMDYyMg==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581320622", "bodyText": "Please remove this colon.", "author": "fwolter", "createdAt": "2021-02-23T19:19:17Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusDimmerHandler.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+import static org.openhab.core.types.RefreshType.REFRESH;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.binding.qbus.internal.protocol.QbusDimmer;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link QbusDimmerHandler} is responsible for handling the dimmable outputs of Qbus\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusDimmerHandler extends QbusGlobalHandler {\n+\n+    protected @Nullable QbusThingsConfig config;\n+\n+    private int dimmerId;\n+\n+    private @Nullable String sn;\n+\n+    public QbusDimmerHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /**\n+     * Main initialization\n+     */\n+    @Override\n+    public void initialize() {\n+        setConfig();\n+        dimmerId = getId();\n+\n+        QbusCommunication QComm = getCommunication(\"Dimmer\", dimmerId);\n+        if (QComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+\n+        QbusBridgeHandler QBridgeHandler = getBridgeHandler(\"Dimmer\", dimmerId);\n+        if (QBridgeHandler == null) {\n+            return;\n+        }\n+\n+        setSN();\n+\n+        Map<Integer, QbusDimmer> dimmerComm = QComm.getDimmer();\n+        if (dimmerComm != null) {\n+            QbusDimmer QDimmer = dimmerComm.get(dimmerId);\n+            if (QDimmer != null) {\n+                QDimmer.setThingHandler(this);\n+                handleStateUpdate(QDimmer);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Error while initializing the thing.\");\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Error while initializing the thing.\");\n+        }\n+    }\n+\n+    /**\n+     * Returns the serial number of the controller\n+     *\n+     * @return the serial nr\n+     */\n+    public @Nullable String getSN() {\n+        return this.sn;\n+    }\n+\n+    /**\n+     * Sets the serial number of the controller\n+     */\n+    public void setSN() {\n+        QbusBridgeHandler QBridgeHandler = getBridgeHandler(\"Dimmer\", dimmerId);\n+        if (QBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+        this.sn = QBridgeHandler.getSn();\n+        ;", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMyMTM0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581321346", "bodyText": "You could directly check for the type. Same for below.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (command instanceof OnOffType) {\n          \n          \n            \n                        OnOffType s = (OnOffType) command;\n          \n          \n            \n                        String snr = getSN();\n          \n          \n            \n            \n          \n          \n            \n                        if (s == OnOffType.OFF) {\n          \n          \n            \n                        String snr = getSN();\n          \n          \n            \n            \n          \n          \n            \n                        if (command == OnOffType.OFF) {", "author": "fwolter", "createdAt": "2021-02-23T19:20:17Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusDimmerHandler.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+import static org.openhab.core.types.RefreshType.REFRESH;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.binding.qbus.internal.protocol.QbusDimmer;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link QbusDimmerHandler} is responsible for handling the dimmable outputs of Qbus\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusDimmerHandler extends QbusGlobalHandler {\n+\n+    protected @Nullable QbusThingsConfig config;\n+\n+    private int dimmerId;\n+\n+    private @Nullable String sn;\n+\n+    public QbusDimmerHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /**\n+     * Main initialization\n+     */\n+    @Override\n+    public void initialize() {\n+        setConfig();\n+        dimmerId = getId();\n+\n+        QbusCommunication QComm = getCommunication(\"Dimmer\", dimmerId);\n+        if (QComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+\n+        QbusBridgeHandler QBridgeHandler = getBridgeHandler(\"Dimmer\", dimmerId);\n+        if (QBridgeHandler == null) {\n+            return;\n+        }\n+\n+        setSN();\n+\n+        Map<Integer, QbusDimmer> dimmerComm = QComm.getDimmer();\n+        if (dimmerComm != null) {\n+            QbusDimmer QDimmer = dimmerComm.get(dimmerId);\n+            if (QDimmer != null) {\n+                QDimmer.setThingHandler(this);\n+                handleStateUpdate(QDimmer);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Error while initializing the thing.\");\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Error while initializing the thing.\");\n+        }\n+    }\n+\n+    /**\n+     * Returns the serial number of the controller\n+     *\n+     * @return the serial nr\n+     */\n+    public @Nullable String getSN() {\n+        return this.sn;\n+    }\n+\n+    /**\n+     * Sets the serial number of the controller\n+     */\n+    public void setSN() {\n+        QbusBridgeHandler QBridgeHandler = getBridgeHandler(\"Dimmer\", dimmerId);\n+        if (QBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+        this.sn = QBridgeHandler.getSn();\n+        ;\n+    }\n+\n+    /**\n+     * Handle the status update from the thing\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        QbusCommunication QComm = getCommunication(\"Dimmer\", dimmerId);\n+\n+        if (QComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Bridge communication not initialized when trying to execute command for dimmer \" + dimmerId);\n+            return;\n+        }\n+\n+        Map<Integer, QbusDimmer> dimmerComm = QComm.getDimmer();\n+        if (dimmerComm != null) {\n+            QbusDimmer QDimmer = dimmerComm.get(dimmerId);\n+\n+            if (QDimmer == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Bridge communication not initialized when trying to execute command for dimmer \" + dimmerId);\n+                return;\n+            } else {\n+                scheduler.submit(() -> {\n+                    if (!QComm.communicationActive()) {\n+                        restartCommunication(QComm, \"Dimmer\", dimmerId);\n+                    }\n+\n+                    if (QComm.communicationActive()) {\n+                        if (command == REFRESH) {\n+                            handleStateUpdate(QDimmer);\n+                            return;\n+                        }\n+\n+                        switch (channelUID.getId()) {\n+                            case CHANNEL_SWITCH:\n+                                handleSwitchCommand(QDimmer, command);\n+                                break;\n+\n+                            case CHANNEL_BRIGHTNESS:\n+                                handleBrightnessCommand(QDimmer, command);\n+                                break;\n+                        }\n+                    }\n+                });\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Error while initializing the thing.\");\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param message\n+     */\n+    public void thingOffline(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, message);\n+    }\n+\n+    /**\n+     * Executes the switch command\n+     */\n+    private void handleSwitchCommand(QbusDimmer QDimmer, Command command) {\n+        if (command instanceof OnOffType) {\n+            OnOffType s = (OnOffType) command;\n+            String snr = getSN();\n+\n+            if (s == OnOffType.OFF) {", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMyMjA3NA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581322074", "bodyText": "Please remove.", "author": "fwolter", "createdAt": "2021-02-23T19:21:25Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusRolHandler.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+import static org.openhab.core.library.types.UpDownType.DOWN;\n+import static org.openhab.core.types.RefreshType.REFRESH;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.binding.qbus.internal.protocol.QbusRol;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.UpDownType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link QbusRolHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusRolHandler extends QbusGlobalHandler {\n+\n+    protected @Nullable QbusThingsConfig config;\n+\n+    private int rolId;\n+\n+    private @Nullable String sn;\n+\n+    public QbusRolHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /**\n+     * Main initialization\n+     */\n+    @Override\n+    public void initialize() {\n+\n+        setConfig();\n+        rolId = getId();\n+\n+        QbusCommunication QComm = getCommunication(\"Screen/Store\", rolId);\n+        if (QComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+\n+        QbusBridgeHandler QBridgeHandler = getBridgeHandler(\"Screen/Store\", rolId);\n+        if (QBridgeHandler == null) {\n+            return;\n+        }\n+\n+        setSN();\n+\n+        Map<Integer, QbusRol> rolComm = QComm.getRol();\n+\n+        if (rolComm != null) {\n+            QbusRol QRol = rolComm.get(rolId);\n+            if (QRol != null) {\n+                QRol.setThingHandler(this);\n+                handleStateUpdate(QRol);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Error while initializing the thing.\");\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Error while initializing the thing.\");\n+        }\n+    }\n+\n+    /**\n+     * Returns the serial number of the controller\n+     *\n+     * @return the serial nr\n+     */\n+    public @Nullable String getSN() {\n+        return this.sn;\n+    }\n+\n+    /**\n+     * Sets the serial number of the controller\n+     */\n+    public void setSN() {\n+        QbusBridgeHandler QBridgeHandler = getBridgeHandler(\"Screen/Store\", rolId);\n+        if (QBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+        this.sn = QBridgeHandler.getSn();\n+        ;", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMyMzIwMw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581323203", "bodyText": "Please check all.", "author": "fwolter", "createdAt": "2021-02-23T19:22:58Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusSceneHandler.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.CHANNEL_SCENE;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.binding.qbus.internal.protocol.QbusScene;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link QbusSceneHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusSceneHandler extends QbusGlobalHandler {\n+\n+    protected @Nullable QbusThingsConfig config;\n+\n+    private int sceneId;\n+\n+    private @Nullable String sn;\n+\n+    public QbusSceneHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /**\n+     * Main initialization\n+     */\n+    @Override\n+    public void initialize() {\n+\n+        setConfig();\n+        sceneId = getId();\n+\n+        QbusCommunication QComm = getCommunication(\"Scene\", sceneId);\n+        if (QComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+\n+        QbusBridgeHandler QBridgeHandler = getBridgeHandler(\"Scene\", sceneId);\n+        if (QBridgeHandler == null) {\n+            return;\n+        }\n+\n+        setSN();\n+\n+        Map<Integer, QbusScene> sceneComm = QComm.getScene();\n+\n+        if (sceneComm != null) {\n+            QbusScene QScene = sceneComm.get(sceneId);\n+            if (QScene != null) {\n+                QScene.setThingHandler(this);\n+                updateStatus(ThingStatus.ONLINE);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Error while initializing the thing.\");\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Error while initializing the thing.\");\n+        }\n+    }\n+\n+    /**\n+     * Returns the serial number of the controller\n+     *\n+     * @return the serial nr\n+     */\n+    public @Nullable String getSN() {\n+        return this.sn;\n+    }\n+\n+    /**\n+     * Sets the serial number of the controller\n+     */\n+    public void setSN() {\n+        QbusBridgeHandler QBridgeHandler = getBridgeHandler(\"Scene\", sceneId);\n+        if (QBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+        this.sn = QBridgeHandler.getSn();\n+        ;", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMyNDQxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581324419", "bodyText": "You need to convert the temperature value you expect. If the user has configured Fahrenheit, s.doubleValue() would return the Fahrenheit value. You can call c.toUnit() for the conversion.", "author": "fwolter", "createdAt": "2021-02-23T19:24:47Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusThermostatHandler.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.types.RefreshType.REFRESH;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.binding.qbus.internal.protocol.QbusThermostat;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link QbusThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusThermostatHandler extends QbusGlobalHandler {\n+\n+    protected @Nullable QbusThingsConfig config;\n+\n+    private int thermostatId;\n+\n+    private @Nullable String sn;\n+\n+    public QbusThermostatHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /**\n+     * Main initialization\n+     */\n+    @Override\n+    public void initialize() {\n+        setConfig();\n+        thermostatId = getId();\n+\n+        QbusCommunication QComm = getCommunication(\"Thermostat\", thermostatId);\n+        if (QComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+\n+        QbusBridgeHandler QBridgeHandler = getBridgeHandler(\"Thermostat\", thermostatId);\n+        if (QBridgeHandler == null) {\n+            return;\n+        }\n+\n+        setSN();\n+\n+        Map<Integer, QbusThermostat> thermostatComm = QComm.getThermostat();\n+\n+        if (thermostatComm != null) {\n+            QbusThermostat QThermostat = thermostatComm.get(thermostatId);\n+            if (QThermostat != null) {\n+                QThermostat.setThingHandler(this);\n+                handleStateUpdate(QThermostat);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Error while initializing the thing.\");\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Error while initializing the thing.\");\n+        }\n+    }\n+\n+    /**\n+     * Returns the serial number of the controller\n+     *\n+     * @return the serial nr\n+     */\n+    public @Nullable String getSN() {\n+        return this.sn;\n+    }\n+\n+    /**\n+     * Sets the serial number of the controller\n+     */\n+    public void setSN() {\n+        QbusBridgeHandler QBridgeHandler = getBridgeHandler(\"Thermostat\", thermostatId);\n+        if (QBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        } else {\n+            this.sn = QBridgeHandler.getSn();\n+        }\n+    }\n+\n+    /**\n+     * Handle the status update from the thing\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        QbusCommunication QComm = getCommunication(\"Thermostat\", thermostatId);\n+\n+        if (QComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Bridge communication not initialized when trying to execute command for thermostat \"\n+                            + thermostatId);\n+            return;\n+        }\n+\n+        Map<Integer, QbusThermostat> thermostatComm = QComm.getThermostat();\n+\n+        if (thermostatComm != null) {\n+\n+            QbusThermostat QThermostat = thermostatComm.get(thermostatId);\n+\n+            if (QThermostat == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Bridge communication not initialized when trying to execute command for Scene \"\n+                                + thermostatId);\n+                return;\n+            } else {\n+                scheduler.submit(() -> {\n+                    if (!QComm.communicationActive()) {\n+                        restartCommunication(QComm, \"Thermostat\", thermostatId);\n+                    }\n+\n+                    if (QComm.communicationActive()) {\n+                        if (command == REFRESH) {\n+                            handleStateUpdate(QThermostat);\n+                            return;\n+                        }\n+\n+                        switch (channelUID.getId()) {\n+                            case CHANNEL_MODE:\n+                                handleModeCommand(QThermostat, command);\n+                                break;\n+\n+                            case CHANNEL_SETPOINT:\n+                                handleSetpointCommand(QThermostat, command);\n+                                break;\n+\n+                        }\n+                    }\n+                });\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Puts thing offline\n+     *\n+     * @param message\n+     */\n+    public void thingOffline(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, message);\n+    }\n+\n+    /**\n+     * Executes the Mode command\n+     */\n+    private void handleModeCommand(QbusThermostat QThermostat, Command command) {\n+        String snr = getSN();\n+        if (command instanceof DecimalType) {\n+            int mode = ((DecimalType) command).intValue();\n+            if (snr != null) {\n+                QThermostat.executeMode(mode, snr);\n+            } else {\n+                thingOffline(\"No serial number configured for  \" + thermostatId);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Executes the Setpoint command\n+     */\n+    private void handleSetpointCommand(QbusThermostat QThermostat, Command command) {\n+        String snr = getSN();\n+        if (command instanceof QuantityType<?>) {\n+            QuantityType<?> s = (QuantityType<?>) command;\n+            double sp = s.doubleValue();", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMyNjQ2OA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581326468", "bodyText": "The Thread's name should include the Thing UID. You could use NamedThreadFactory to retrieve a correctly configured Thread. Here are some examples: https://github.com/openhab/openhab-addons/search?q=NamedThreadFactory", "author": "fwolter", "createdAt": "2021-02-23T19:27:41Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,913 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+\n+    private @Nullable String CTD;\n+\n+    private boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    private @Nullable QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     * @throws InterruptedException\n+     * @throws IOException\n+     *\n+     */\n+\n+    public synchronized void startCommunication() throws IOException, InterruptedException {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+\n+        if (qEventsRunning) {\n+            throw new IOException(\"Previous listening thread is still active.\");\n+        }\n+\n+        if (handler == null) {\n+            throw new IOException(\"No Bridge handler initialised.\");\n+        }\n+\n+        InetAddress addr = InetAddress.getByName(handler.getAddress());\n+        Integer port = handler.getPort();\n+\n+        if (port != null) {\n+            Socket socket = new Socket(addr, port);\n+            qSocket = socket;\n+            qOut = new PrintWriter(socket.getOutputStream(), true);\n+            qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            logger.debug(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                    Thread.currentThread().getId());\n+        } else {\n+            return;\n+        }\n+\n+        setSN();\n+        getSN();\n+\n+        // Connect to Qbus server\n+        Connect();\n+\n+        // If Qbus Client is connected then initialize and start listening for incoming commands, else put Bridge\n+        // offline\n+        if (CTDConnected == true) {\n+            initialize();\n+            Thread thread = new Thread(this::qEvents);\n+            thread.setName(\"OH-binding\");\n+            thread.setDaemon(true);\n+            thread.start();", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMyNzA0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581327049", "bodyText": "The readers and writers need to be closed here.", "author": "fwolter", "createdAt": "2021-02-23T19:28:27Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,913 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+\n+    private @Nullable String CTD;\n+\n+    private boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    private @Nullable QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     * @throws InterruptedException\n+     * @throws IOException\n+     *\n+     */\n+\n+    public synchronized void startCommunication() throws IOException, InterruptedException {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+\n+        if (qEventsRunning) {\n+            throw new IOException(\"Previous listening thread is still active.\");\n+        }\n+\n+        if (handler == null) {\n+            throw new IOException(\"No Bridge handler initialised.\");\n+        }\n+\n+        InetAddress addr = InetAddress.getByName(handler.getAddress());\n+        Integer port = handler.getPort();\n+\n+        if (port != null) {\n+            Socket socket = new Socket(addr, port);\n+            qSocket = socket;\n+            qOut = new PrintWriter(socket.getOutputStream(), true);\n+            qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            logger.debug(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                    Thread.currentThread().getId());\n+        } else {\n+            return;\n+        }\n+\n+        setSN();\n+        getSN();\n+\n+        // Connect to Qbus server\n+        Connect();\n+\n+        // If Qbus Client is connected then initialize and start listening for incoming commands, else put Bridge\n+        // offline\n+        if (CTDConnected == true) {\n+            initialize();\n+            Thread thread = new Thread(this::qEvents);\n+            thread.setName(\"OH-binding\");\n+            thread.setDaemon(true);\n+            thread.start();\n+        } else {\n+            handler.bridgeOffline(\"No communication with Qbus client\");\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMyNzczMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581327731", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        while (!Thread.currentThread().isInterrupted() & ((qMessage = reader.readLine()) != null)) {\n          \n          \n            \n                        while (!Thread.currentThread().isInterrupted() && ((qMessage = reader.readLine()) != null)) {", "author": "fwolter", "createdAt": "2021-02-23T19:29:24Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,913 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+\n+    private @Nullable String CTD;\n+\n+    private boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    private @Nullable QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     * @throws InterruptedException\n+     * @throws IOException\n+     *\n+     */\n+\n+    public synchronized void startCommunication() throws IOException, InterruptedException {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+\n+        if (qEventsRunning) {\n+            throw new IOException(\"Previous listening thread is still active.\");\n+        }\n+\n+        if (handler == null) {\n+            throw new IOException(\"No Bridge handler initialised.\");\n+        }\n+\n+        InetAddress addr = InetAddress.getByName(handler.getAddress());\n+        Integer port = handler.getPort();\n+\n+        if (port != null) {\n+            Socket socket = new Socket(addr, port);\n+            qSocket = socket;\n+            qOut = new PrintWriter(socket.getOutputStream(), true);\n+            qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            logger.debug(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                    Thread.currentThread().getId());\n+        } else {\n+            return;\n+        }\n+\n+        setSN();\n+        getSN();\n+\n+        // Connect to Qbus server\n+        Connect();\n+\n+        // If Qbus Client is connected then initialize and start listening for incoming commands, else put Bridge\n+        // offline\n+        if (CTDConnected == true) {\n+            initialize();\n+            Thread thread = new Thread(this::qEvents);\n+            thread.setName(\"OH-binding\");\n+            thread.setDaemon(true);\n+            thread.start();\n+        } else {\n+            handler.bridgeOffline(\"No communication with Qbus client\");\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        CTDConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     *\n+     * @throws InterruptedException\n+     */\n+    public synchronized void restartCommunication() {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        try {\n+            startCommunication();\n+        } catch (InterruptedException | IOException e) {\n+            logger.warn(\"Error on restaring communication.\");\n+        }\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return CTDConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     * @return\n+     *\n+     */\n+    private void qEvents() {\n+        String qMessage;\n+\n+        logger.info(\"Listening for events on thread {}\", Thread.currentThread().getId());\n+        listenerStopped = false;\n+        qEventsRunning = true;\n+\n+        BufferedReader reader = qIn;\n+\n+        try {\n+            if (reader == null) {\n+                throw new IOException(\"Bufferreader for incomming messages not initialized.\");\n+            }\n+            while (!Thread.currentThread().isInterrupted() & ((qMessage = reader.readLine()) != null)) {", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMyNzkxOA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581327918", "bodyText": "Bindings should only log to error if something severe happened, like the detection of a bug in your code. This could be debug. See this link for a description of the log levels: https://www.openhab.org/docs/developer/guidelines.html#f-logging", "author": "fwolter", "createdAt": "2021-02-23T19:29:39Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,913 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+\n+    private @Nullable String CTD;\n+\n+    private boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    private @Nullable QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     * @throws InterruptedException\n+     * @throws IOException\n+     *\n+     */\n+\n+    public synchronized void startCommunication() throws IOException, InterruptedException {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+\n+        if (qEventsRunning) {\n+            throw new IOException(\"Previous listening thread is still active.\");\n+        }\n+\n+        if (handler == null) {\n+            throw new IOException(\"No Bridge handler initialised.\");\n+        }\n+\n+        InetAddress addr = InetAddress.getByName(handler.getAddress());\n+        Integer port = handler.getPort();\n+\n+        if (port != null) {\n+            Socket socket = new Socket(addr, port);\n+            qSocket = socket;\n+            qOut = new PrintWriter(socket.getOutputStream(), true);\n+            qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            logger.debug(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                    Thread.currentThread().getId());\n+        } else {\n+            return;\n+        }\n+\n+        setSN();\n+        getSN();\n+\n+        // Connect to Qbus server\n+        Connect();\n+\n+        // If Qbus Client is connected then initialize and start listening for incoming commands, else put Bridge\n+        // offline\n+        if (CTDConnected == true) {\n+            initialize();\n+            Thread thread = new Thread(this::qEvents);\n+            thread.setName(\"OH-binding\");\n+            thread.setDaemon(true);\n+            thread.start();\n+        } else {\n+            handler.bridgeOffline(\"No communication with Qbus client\");\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        CTDConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     *\n+     * @throws InterruptedException\n+     */\n+    public synchronized void restartCommunication() {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        try {\n+            startCommunication();\n+        } catch (InterruptedException | IOException e) {\n+            logger.warn(\"Error on restaring communication.\");\n+        }\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return CTDConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     * @return\n+     *\n+     */\n+    private void qEvents() {\n+        String qMessage;\n+\n+        logger.info(\"Listening for events on thread {}\", Thread.currentThread().getId());\n+        listenerStopped = false;\n+        qEventsRunning = true;\n+\n+        BufferedReader reader = qIn;\n+\n+        try {\n+            if (reader == null) {\n+                throw new IOException(\"Bufferreader for incomming messages not initialized.\");\n+            }\n+            while (!Thread.currentThread().isInterrupted() & ((qMessage = reader.readLine()) != null)) {\n+                if (qMessage != null) {\n+                    readMessage(qMessage);\n+                }\n+            }\n+        } catch (IOException e) {\n+            if (!listenerStopped) {\n+                qEventsRunning = false;\n+                logger.error(\"Qbus: IO error in listener on thread {}\", Thread.currentThread().getId());", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMyODQ2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581328465", "bodyText": "You can simply remove the try/catch clause to throw the exception.", "author": "fwolter", "createdAt": "2021-02-23T19:30:15Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,913 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+\n+    private @Nullable String CTD;\n+\n+    private boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    private @Nullable QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     * @throws InterruptedException\n+     * @throws IOException\n+     *\n+     */\n+\n+    public synchronized void startCommunication() throws IOException, InterruptedException {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+\n+        if (qEventsRunning) {\n+            throw new IOException(\"Previous listening thread is still active.\");\n+        }\n+\n+        if (handler == null) {\n+            throw new IOException(\"No Bridge handler initialised.\");\n+        }\n+\n+        InetAddress addr = InetAddress.getByName(handler.getAddress());\n+        Integer port = handler.getPort();\n+\n+        if (port != null) {\n+            Socket socket = new Socket(addr, port);\n+            qSocket = socket;\n+            qOut = new PrintWriter(socket.getOutputStream(), true);\n+            qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            logger.debug(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                    Thread.currentThread().getId());\n+        } else {\n+            return;\n+        }\n+\n+        setSN();\n+        getSN();\n+\n+        // Connect to Qbus server\n+        Connect();\n+\n+        // If Qbus Client is connected then initialize and start listening for incoming commands, else put Bridge\n+        // offline\n+        if (CTDConnected == true) {\n+            initialize();\n+            Thread thread = new Thread(this::qEvents);\n+            thread.setName(\"OH-binding\");\n+            thread.setDaemon(true);\n+            thread.start();\n+        } else {\n+            handler.bridgeOffline(\"No communication with Qbus client\");\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        CTDConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     *\n+     * @throws InterruptedException\n+     */\n+    public synchronized void restartCommunication() {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        try {\n+            startCommunication();\n+        } catch (InterruptedException | IOException e) {\n+            logger.warn(\"Error on restaring communication.\");\n+        }\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return CTDConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     * @return\n+     *\n+     */\n+    private void qEvents() {\n+        String qMessage;\n+\n+        logger.info(\"Listening for events on thread {}\", Thread.currentThread().getId());\n+        listenerStopped = false;\n+        qEventsRunning = true;\n+\n+        BufferedReader reader = qIn;\n+\n+        try {\n+            if (reader == null) {\n+                throw new IOException(\"Bufferreader for incomming messages not initialized.\");\n+            }\n+            while (!Thread.currentThread().isInterrupted() & ((qMessage = reader.readLine()) != null)) {\n+                if (qMessage != null) {\n+                    readMessage(qMessage);\n+                }\n+            }\n+        } catch (IOException e) {\n+            if (!listenerStopped) {\n+                qEventsRunning = false;\n+                logger.error(\"Qbus: IO error in listener on thread {}\", Thread.currentThread().getId());\n+\n+                QbusBridgeHandler handler = bridgeCallBack;\n+\n+                if (handler != null) {\n+                    CTDConnected = false;\n+                    handler.bridgeOffline(\"No communication with Qbus server\");\n+                }\n+            }\n+        }\n+\n+        qEventsRunning = false;\n+        logger.trace(\"Event listener thread stopped on thread {}\", Thread.currentThread().getId());\n+    };\n+\n+    /**\n+     * Called by other methods to send json data to Qbus.\n+     *\n+     * @param qMessage\n+     * @throws InterruptedException\n+     */\n+    synchronized void sendMessage(Object qMessage) throws InterruptedException {\n+        PrintWriter writer = qOut;\n+        String json = gsonOut.toJson(qMessage);\n+\n+        if (writer != null) {\n+            writer.println(json);\n+            // Delay after sending data to improve scene execution\n+            try {\n+                TimeUnit.MILLISECONDS.sleep(250);\n+            } catch (InterruptedException e) {\n+                throw new InterruptedException(e.toString());\n+            }", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMzMDE0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581330145", "bodyText": "The InterruptedException is thrown when OH is shut-down. That means the current operation should be finished as fast as possible and no further operations should be done. You can achieve this by not catching the exception here but throw the InterruptedException and catch it at the highest level you can. As this is not an error, it shouldn't be logged, but only handled.", "author": "fwolter", "createdAt": "2021-02-23T19:32:40Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,913 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+\n+    private @Nullable String CTD;\n+\n+    private boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    private @Nullable QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     * @throws InterruptedException\n+     * @throws IOException\n+     *\n+     */\n+\n+    public synchronized void startCommunication() throws IOException, InterruptedException {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+\n+        if (qEventsRunning) {\n+            throw new IOException(\"Previous listening thread is still active.\");\n+        }\n+\n+        if (handler == null) {\n+            throw new IOException(\"No Bridge handler initialised.\");\n+        }\n+\n+        InetAddress addr = InetAddress.getByName(handler.getAddress());\n+        Integer port = handler.getPort();\n+\n+        if (port != null) {\n+            Socket socket = new Socket(addr, port);\n+            qSocket = socket;\n+            qOut = new PrintWriter(socket.getOutputStream(), true);\n+            qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            logger.debug(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                    Thread.currentThread().getId());\n+        } else {\n+            return;\n+        }\n+\n+        setSN();\n+        getSN();\n+\n+        // Connect to Qbus server\n+        Connect();\n+\n+        // If Qbus Client is connected then initialize and start listening for incoming commands, else put Bridge\n+        // offline\n+        if (CTDConnected == true) {\n+            initialize();\n+            Thread thread = new Thread(this::qEvents);\n+            thread.setName(\"OH-binding\");\n+            thread.setDaemon(true);\n+            thread.start();\n+        } else {\n+            handler.bridgeOffline(\"No communication with Qbus client\");\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        CTDConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     *\n+     * @throws InterruptedException\n+     */\n+    public synchronized void restartCommunication() {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        try {\n+            startCommunication();\n+        } catch (InterruptedException | IOException e) {", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mjk3Njk3OA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r582976978", "bodyText": "You need to remove the InterruptedException from the catch clause to let it be thrown.", "author": "fwolter", "createdAt": "2021-02-25T16:26:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMzMDE0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTkwMDEyMw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r585900123", "bodyText": "Can you work on this?", "author": "fwolter", "createdAt": "2021-03-02T20:51:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMzMDE0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMzMDU1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581330556", "bodyText": "The compiler is more intelligent on local variables. Therefore, the Nullable could be removed.", "author": "fwolter", "createdAt": "2021-02-23T19:33:15Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,913 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+\n+    private @Nullable String CTD;\n+\n+    private boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    private @Nullable QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     * @throws InterruptedException\n+     * @throws IOException\n+     *\n+     */\n+\n+    public synchronized void startCommunication() throws IOException, InterruptedException {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+\n+        if (qEventsRunning) {\n+            throw new IOException(\"Previous listening thread is still active.\");\n+        }\n+\n+        if (handler == null) {\n+            throw new IOException(\"No Bridge handler initialised.\");\n+        }\n+\n+        InetAddress addr = InetAddress.getByName(handler.getAddress());\n+        Integer port = handler.getPort();\n+\n+        if (port != null) {\n+            Socket socket = new Socket(addr, port);\n+            qSocket = socket;\n+            qOut = new PrintWriter(socket.getOutputStream(), true);\n+            qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            logger.debug(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                    Thread.currentThread().getId());\n+        } else {\n+            return;\n+        }\n+\n+        setSN();\n+        getSN();\n+\n+        // Connect to Qbus server\n+        Connect();\n+\n+        // If Qbus Client is connected then initialize and start listening for incoming commands, else put Bridge\n+        // offline\n+        if (CTDConnected == true) {\n+            initialize();\n+            Thread thread = new Thread(this::qEvents);\n+            thread.setName(\"OH-binding\");\n+            thread.setDaemon(true);\n+            thread.start();\n+        } else {\n+            handler.bridgeOffline(\"No communication with Qbus client\");\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        CTDConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     *\n+     * @throws InterruptedException\n+     */\n+    public synchronized void restartCommunication() {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        try {\n+            startCommunication();\n+        } catch (InterruptedException | IOException e) {\n+            logger.warn(\"Error on restaring communication.\");\n+        }\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return CTDConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     * @return\n+     *\n+     */\n+    private void qEvents() {\n+        String qMessage;\n+\n+        logger.info(\"Listening for events on thread {}\", Thread.currentThread().getId());\n+        listenerStopped = false;\n+        qEventsRunning = true;\n+\n+        BufferedReader reader = qIn;\n+\n+        try {\n+            if (reader == null) {\n+                throw new IOException(\"Bufferreader for incomming messages not initialized.\");\n+            }\n+            while (!Thread.currentThread().isInterrupted() & ((qMessage = reader.readLine()) != null)) {\n+                if (qMessage != null) {\n+                    readMessage(qMessage);\n+                }\n+            }\n+        } catch (IOException e) {\n+            if (!listenerStopped) {\n+                qEventsRunning = false;\n+                logger.error(\"Qbus: IO error in listener on thread {}\", Thread.currentThread().getId());\n+\n+                QbusBridgeHandler handler = bridgeCallBack;\n+\n+                if (handler != null) {\n+                    CTDConnected = false;\n+                    handler.bridgeOffline(\"No communication with Qbus server\");\n+                }\n+            }\n+        }\n+\n+        qEventsRunning = false;\n+        logger.trace(\"Event listener thread stopped on thread {}\", Thread.currentThread().getId());\n+    };\n+\n+    /**\n+     * Called by other methods to send json data to Qbus.\n+     *\n+     * @param qMessage\n+     * @throws InterruptedException\n+     */\n+    synchronized void sendMessage(Object qMessage) throws InterruptedException {\n+        PrintWriter writer = qOut;\n+        String json = gsonOut.toJson(qMessage);\n+\n+        if (writer != null) {\n+            writer.println(json);\n+            // Delay after sending data to improve scene execution\n+            try {\n+                TimeUnit.MILLISECONDS.sleep(250);\n+            } catch (InterruptedException e) {\n+                throw new InterruptedException(e.toString());\n+            }\n+\n+        }\n+        if ((writer == null) || (writer.checkError())) {\n+            logger.warn(\"Error sending message, trying to restart communication\");\n+            restartCommunication();\n+            // retry sending after restart\n+            writer = qOut;\n+            if (writer != null) {\n+                writer.println(json);\n+            }\n+            if ((writer == null) || (writer.checkError())) {\n+                logger.warn(\"Error resending message\");\n+\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Called by other methods to Qbus server and read response\n+     */\n+    private void sendAndReadMessage(String command) throws IOException, InterruptedException {\n+        @Nullable", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMzMDk3OA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581330978", "bodyText": "See above. Can be removed. Please check all.", "author": "fwolter", "createdAt": "2021-02-23T19:33:54Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,913 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+\n+    private @Nullable String CTD;\n+\n+    private boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    private @Nullable QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     * @throws InterruptedException\n+     * @throws IOException\n+     *\n+     */\n+\n+    public synchronized void startCommunication() throws IOException, InterruptedException {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+\n+        if (qEventsRunning) {\n+            throw new IOException(\"Previous listening thread is still active.\");\n+        }\n+\n+        if (handler == null) {\n+            throw new IOException(\"No Bridge handler initialised.\");\n+        }\n+\n+        InetAddress addr = InetAddress.getByName(handler.getAddress());\n+        Integer port = handler.getPort();\n+\n+        if (port != null) {\n+            Socket socket = new Socket(addr, port);\n+            qSocket = socket;\n+            qOut = new PrintWriter(socket.getOutputStream(), true);\n+            qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            logger.debug(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                    Thread.currentThread().getId());\n+        } else {\n+            return;\n+        }\n+\n+        setSN();\n+        getSN();\n+\n+        // Connect to Qbus server\n+        Connect();\n+\n+        // If Qbus Client is connected then initialize and start listening for incoming commands, else put Bridge\n+        // offline\n+        if (CTDConnected == true) {\n+            initialize();\n+            Thread thread = new Thread(this::qEvents);\n+            thread.setName(\"OH-binding\");\n+            thread.setDaemon(true);\n+            thread.start();\n+        } else {\n+            handler.bridgeOffline(\"No communication with Qbus client\");\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        CTDConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     *\n+     * @throws InterruptedException\n+     */\n+    public synchronized void restartCommunication() {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        try {\n+            startCommunication();\n+        } catch (InterruptedException | IOException e) {\n+            logger.warn(\"Error on restaring communication.\");\n+        }\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return CTDConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     * @return\n+     *\n+     */\n+    private void qEvents() {\n+        String qMessage;\n+\n+        logger.info(\"Listening for events on thread {}\", Thread.currentThread().getId());\n+        listenerStopped = false;\n+        qEventsRunning = true;\n+\n+        BufferedReader reader = qIn;\n+\n+        try {\n+            if (reader == null) {\n+                throw new IOException(\"Bufferreader for incomming messages not initialized.\");\n+            }\n+            while (!Thread.currentThread().isInterrupted() & ((qMessage = reader.readLine()) != null)) {\n+                if (qMessage != null) {\n+                    readMessage(qMessage);\n+                }\n+            }\n+        } catch (IOException e) {\n+            if (!listenerStopped) {\n+                qEventsRunning = false;\n+                logger.error(\"Qbus: IO error in listener on thread {}\", Thread.currentThread().getId());\n+\n+                QbusBridgeHandler handler = bridgeCallBack;\n+\n+                if (handler != null) {\n+                    CTDConnected = false;\n+                    handler.bridgeOffline(\"No communication with Qbus server\");\n+                }\n+            }\n+        }\n+\n+        qEventsRunning = false;\n+        logger.trace(\"Event listener thread stopped on thread {}\", Thread.currentThread().getId());\n+    };\n+\n+    /**\n+     * Called by other methods to send json data to Qbus.\n+     *\n+     * @param qMessage\n+     * @throws InterruptedException\n+     */\n+    synchronized void sendMessage(Object qMessage) throws InterruptedException {\n+        PrintWriter writer = qOut;\n+        String json = gsonOut.toJson(qMessage);\n+\n+        if (writer != null) {\n+            writer.println(json);\n+            // Delay after sending data to improve scene execution\n+            try {\n+                TimeUnit.MILLISECONDS.sleep(250);\n+            } catch (InterruptedException e) {\n+                throw new InterruptedException(e.toString());\n+            }\n+\n+        }\n+        if ((writer == null) || (writer.checkError())) {\n+            logger.warn(\"Error sending message, trying to restart communication\");\n+            restartCommunication();\n+            // retry sending after restart\n+            writer = qOut;\n+            if (writer != null) {\n+                writer.println(json);\n+            }\n+            if ((writer == null) || (writer.checkError())) {\n+                logger.warn(\"Error resending message\");\n+\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Called by other methods to Qbus server and read response\n+     */\n+    private void sendAndReadMessage(String command) throws IOException, InterruptedException {\n+        @Nullable\n+        String snr = getSN();\n+        if (snr != null) {\n+            QbusMessageCmd qCmd = new QbusMessageCmd(snr, command);\n+\n+            sendMessage(qCmd);\n+\n+            BufferedReader reader = qIn;\n+            if (reader == null) {\n+                throw new IOException(\"Cannot read from socket, reader not connected.\");\n+            }\n+            readMessage(reader.readLine());\n+        } else {\n+            QbusBridgeHandler handler = bridgeCallBack;\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No serial nr defined\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method that interprets all feedback from Qbus Server application and calls appropriate handling methods.\n+     *\n+     * @param qMessage message read from Qbus.\n+     */\n+    private void readMessage(String qMessage) {\n+        String cmd = \"\";\n+        String CTD = \"\";\n+        String sn = null;\n+        QbusMessageBase qMessageGson;\n+\n+        qMessageGson = gsonIn.fromJson(qMessage, QbusMessageBase.class);\n+        if (qMessageGson != null) {\n+            CTD = qMessageGson.getSn();\n+            cmd = qMessageGson.getCmd();\n+        }\n+\n+        if (bridgeCallBack != null) {\n+            sn = bridgeCallBack.getSn();\n+        }\n+\n+        if (sn != null && CTD != null) {\n+            try {\n+                if (Integer.parseInt(sn) == Integer.parseInt(CTD) && qMessageGson != null) {\n+                    // Get the compatible outputs from the Qbus server\n+                    if (\"returnBistabiel\".equals(cmd)) {\n+                        cmdListBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"returnDimmer\".equals(cmd)) {\n+                        cmdListDimmers(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnThermostat\").equals(cmd)) {\n+                        cmdListThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnScene\").equals(cmd)) {\n+                        cmdListscenes(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnCo2\").equals(cmd)) {\n+                        cmdlistco2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnRol02p\").equals(cmd)) {\n+                        cmdlistrol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnSlat\").equals(cmd)) {\n+                        cmdlistrolslats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incoming commands from Qbus Client to openHAB (event)\n+                    else if (\"updateBistabiel\".equals(cmd)) {\n+                        updateBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateDimmer\".equals(cmd)) {\n+                        updateDimmers(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateThermostat\".equals(cmd)) {\n+                        updateThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateCo2\".equals(cmd)) {\n+                        updateCO2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02p\".equals(cmd)) {\n+                        updateRol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02pSlat\".equals(cmd)) {\n+                        updateRolslats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incomming commands from Qbus server to verify the client connection\n+                    else if (\"disconnect\".equals(cmd)) {\n+                        eventDisconnect();\n+                    } else if (\"notConnected\".equals(cmd)) {\n+                        noConnection();\n+                    } else if (\"connected\".equals(cmd)) {\n+                        connection();\n+                    }\n+                }\n+\n+            } catch (JsonParseException e) {\n+                logger.warn(\"Not acted on unsupported json {}\", qMessage);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * After setting up the communication with the Qbus Server, send all initialization messages.\n+     * <p>\n+     * First send connect to connect with the Qbus Server application\n+     * Get request for Bistabiel/Timers/Intervals/Mono outputs\n+     * Get request for the Scenes\n+     * Get request for Dimmers 1T and 2T\n+     * Get request for Shutters\n+     * Get request for Thermostats\n+     * Get request for CO2\n+     *\n+     *\n+     * @throws IOException\n+     * @throws InterruptedException\n+     */\n+\n+    private void initialize() throws IOException, InterruptedException {\n+        if (bridgeCallBack != null) {\n+            if (CTDConnected) {\n+                sendAndReadMessage(\"getBistabiel\");\n+                sendAndReadMessage(\"getScene\");\n+                sendAndReadMessage(\"getDimmer\");\n+                sendAndReadMessage(\"getRol02p\");\n+                sendAndReadMessage(\"getRol02pSlat\");\n+                sendAndReadMessage(\"getThermostat\");\n+                sendAndReadMessage(\"getCo2\");\n+            } else {\n+                CTDConnected = false;\n+\n+                QbusBridgeHandler handler = bridgeCallBack;\n+\n+                if (handler != null) {\n+                    handler.bridgeOffline(\"No communication with Qbus client\");\n+                }\n+\n+                return;\n+            }\n+        } else {\n+            logger.trace(\"Initialization error\");\n+        }\n+    }\n+\n+    public @Nullable String getSN() {\n+        return this.CTD;\n+    }\n+\n+    public void setSN() {\n+        QbusBridgeHandler QBridgeHandler = bridgeCallBack;\n+        if (QBridgeHandler != null) {\n+            this.CTD = QBridgeHandler.getSn();\n+        }\n+    }\n+\n+    /**\n+     * Initial connection to Qbus Server to open a communication channel\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    private void Connect() throws InterruptedException, IOException {\n+        @Nullable", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMzMTA4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581331089", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void Connect() throws InterruptedException, IOException {\n          \n          \n            \n                private void connect() throws InterruptedException, IOException {", "author": "fwolter", "createdAt": "2021-02-23T19:34:04Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,913 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+\n+    private @Nullable String CTD;\n+\n+    private boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    private @Nullable QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     * @throws InterruptedException\n+     * @throws IOException\n+     *\n+     */\n+\n+    public synchronized void startCommunication() throws IOException, InterruptedException {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+\n+        if (qEventsRunning) {\n+            throw new IOException(\"Previous listening thread is still active.\");\n+        }\n+\n+        if (handler == null) {\n+            throw new IOException(\"No Bridge handler initialised.\");\n+        }\n+\n+        InetAddress addr = InetAddress.getByName(handler.getAddress());\n+        Integer port = handler.getPort();\n+\n+        if (port != null) {\n+            Socket socket = new Socket(addr, port);\n+            qSocket = socket;\n+            qOut = new PrintWriter(socket.getOutputStream(), true);\n+            qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            logger.debug(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                    Thread.currentThread().getId());\n+        } else {\n+            return;\n+        }\n+\n+        setSN();\n+        getSN();\n+\n+        // Connect to Qbus server\n+        Connect();\n+\n+        // If Qbus Client is connected then initialize and start listening for incoming commands, else put Bridge\n+        // offline\n+        if (CTDConnected == true) {\n+            initialize();\n+            Thread thread = new Thread(this::qEvents);\n+            thread.setName(\"OH-binding\");\n+            thread.setDaemon(true);\n+            thread.start();\n+        } else {\n+            handler.bridgeOffline(\"No communication with Qbus client\");\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        CTDConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     *\n+     * @throws InterruptedException\n+     */\n+    public synchronized void restartCommunication() {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        try {\n+            startCommunication();\n+        } catch (InterruptedException | IOException e) {\n+            logger.warn(\"Error on restaring communication.\");\n+        }\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return CTDConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     * @return\n+     *\n+     */\n+    private void qEvents() {\n+        String qMessage;\n+\n+        logger.info(\"Listening for events on thread {}\", Thread.currentThread().getId());\n+        listenerStopped = false;\n+        qEventsRunning = true;\n+\n+        BufferedReader reader = qIn;\n+\n+        try {\n+            if (reader == null) {\n+                throw new IOException(\"Bufferreader for incomming messages not initialized.\");\n+            }\n+            while (!Thread.currentThread().isInterrupted() & ((qMessage = reader.readLine()) != null)) {\n+                if (qMessage != null) {\n+                    readMessage(qMessage);\n+                }\n+            }\n+        } catch (IOException e) {\n+            if (!listenerStopped) {\n+                qEventsRunning = false;\n+                logger.error(\"Qbus: IO error in listener on thread {}\", Thread.currentThread().getId());\n+\n+                QbusBridgeHandler handler = bridgeCallBack;\n+\n+                if (handler != null) {\n+                    CTDConnected = false;\n+                    handler.bridgeOffline(\"No communication with Qbus server\");\n+                }\n+            }\n+        }\n+\n+        qEventsRunning = false;\n+        logger.trace(\"Event listener thread stopped on thread {}\", Thread.currentThread().getId());\n+    };\n+\n+    /**\n+     * Called by other methods to send json data to Qbus.\n+     *\n+     * @param qMessage\n+     * @throws InterruptedException\n+     */\n+    synchronized void sendMessage(Object qMessage) throws InterruptedException {\n+        PrintWriter writer = qOut;\n+        String json = gsonOut.toJson(qMessage);\n+\n+        if (writer != null) {\n+            writer.println(json);\n+            // Delay after sending data to improve scene execution\n+            try {\n+                TimeUnit.MILLISECONDS.sleep(250);\n+            } catch (InterruptedException e) {\n+                throw new InterruptedException(e.toString());\n+            }\n+\n+        }\n+        if ((writer == null) || (writer.checkError())) {\n+            logger.warn(\"Error sending message, trying to restart communication\");\n+            restartCommunication();\n+            // retry sending after restart\n+            writer = qOut;\n+            if (writer != null) {\n+                writer.println(json);\n+            }\n+            if ((writer == null) || (writer.checkError())) {\n+                logger.warn(\"Error resending message\");\n+\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Called by other methods to Qbus server and read response\n+     */\n+    private void sendAndReadMessage(String command) throws IOException, InterruptedException {\n+        @Nullable\n+        String snr = getSN();\n+        if (snr != null) {\n+            QbusMessageCmd qCmd = new QbusMessageCmd(snr, command);\n+\n+            sendMessage(qCmd);\n+\n+            BufferedReader reader = qIn;\n+            if (reader == null) {\n+                throw new IOException(\"Cannot read from socket, reader not connected.\");\n+            }\n+            readMessage(reader.readLine());\n+        } else {\n+            QbusBridgeHandler handler = bridgeCallBack;\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No serial nr defined\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method that interprets all feedback from Qbus Server application and calls appropriate handling methods.\n+     *\n+     * @param qMessage message read from Qbus.\n+     */\n+    private void readMessage(String qMessage) {\n+        String cmd = \"\";\n+        String CTD = \"\";\n+        String sn = null;\n+        QbusMessageBase qMessageGson;\n+\n+        qMessageGson = gsonIn.fromJson(qMessage, QbusMessageBase.class);\n+        if (qMessageGson != null) {\n+            CTD = qMessageGson.getSn();\n+            cmd = qMessageGson.getCmd();\n+        }\n+\n+        if (bridgeCallBack != null) {\n+            sn = bridgeCallBack.getSn();\n+        }\n+\n+        if (sn != null && CTD != null) {\n+            try {\n+                if (Integer.parseInt(sn) == Integer.parseInt(CTD) && qMessageGson != null) {\n+                    // Get the compatible outputs from the Qbus server\n+                    if (\"returnBistabiel\".equals(cmd)) {\n+                        cmdListBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"returnDimmer\".equals(cmd)) {\n+                        cmdListDimmers(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnThermostat\").equals(cmd)) {\n+                        cmdListThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnScene\").equals(cmd)) {\n+                        cmdListscenes(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnCo2\").equals(cmd)) {\n+                        cmdlistco2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnRol02p\").equals(cmd)) {\n+                        cmdlistrol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnSlat\").equals(cmd)) {\n+                        cmdlistrolslats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incoming commands from Qbus Client to openHAB (event)\n+                    else if (\"updateBistabiel\".equals(cmd)) {\n+                        updateBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateDimmer\".equals(cmd)) {\n+                        updateDimmers(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateThermostat\".equals(cmd)) {\n+                        updateThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateCo2\".equals(cmd)) {\n+                        updateCO2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02p\".equals(cmd)) {\n+                        updateRol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02pSlat\".equals(cmd)) {\n+                        updateRolslats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incomming commands from Qbus server to verify the client connection\n+                    else if (\"disconnect\".equals(cmd)) {\n+                        eventDisconnect();\n+                    } else if (\"notConnected\".equals(cmd)) {\n+                        noConnection();\n+                    } else if (\"connected\".equals(cmd)) {\n+                        connection();\n+                    }\n+                }\n+\n+            } catch (JsonParseException e) {\n+                logger.warn(\"Not acted on unsupported json {}\", qMessage);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * After setting up the communication with the Qbus Server, send all initialization messages.\n+     * <p>\n+     * First send connect to connect with the Qbus Server application\n+     * Get request for Bistabiel/Timers/Intervals/Mono outputs\n+     * Get request for the Scenes\n+     * Get request for Dimmers 1T and 2T\n+     * Get request for Shutters\n+     * Get request for Thermostats\n+     * Get request for CO2\n+     *\n+     *\n+     * @throws IOException\n+     * @throws InterruptedException\n+     */\n+\n+    private void initialize() throws IOException, InterruptedException {\n+        if (bridgeCallBack != null) {\n+            if (CTDConnected) {\n+                sendAndReadMessage(\"getBistabiel\");\n+                sendAndReadMessage(\"getScene\");\n+                sendAndReadMessage(\"getDimmer\");\n+                sendAndReadMessage(\"getRol02p\");\n+                sendAndReadMessage(\"getRol02pSlat\");\n+                sendAndReadMessage(\"getThermostat\");\n+                sendAndReadMessage(\"getCo2\");\n+            } else {\n+                CTDConnected = false;\n+\n+                QbusBridgeHandler handler = bridgeCallBack;\n+\n+                if (handler != null) {\n+                    handler.bridgeOffline(\"No communication with Qbus client\");\n+                }\n+\n+                return;\n+            }\n+        } else {\n+            logger.trace(\"Initialization error\");\n+        }\n+    }\n+\n+    public @Nullable String getSN() {\n+        return this.CTD;\n+    }\n+\n+    public void setSN() {\n+        QbusBridgeHandler QBridgeHandler = bridgeCallBack;\n+        if (QBridgeHandler != null) {\n+            this.CTD = QBridgeHandler.getSn();\n+        }\n+    }\n+\n+    /**\n+     * Initial connection to Qbus Server to open a communication channel\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    private void Connect() throws InterruptedException, IOException {", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMzMTM0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581331341", "bodyText": "See above. Logging to error. Please check all.", "author": "fwolter", "createdAt": "2021-02-23T19:34:24Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,913 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+\n+    private @Nullable String CTD;\n+\n+    private boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    private @Nullable QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     * @throws InterruptedException\n+     * @throws IOException\n+     *\n+     */\n+\n+    public synchronized void startCommunication() throws IOException, InterruptedException {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+\n+        if (qEventsRunning) {\n+            throw new IOException(\"Previous listening thread is still active.\");\n+        }\n+\n+        if (handler == null) {\n+            throw new IOException(\"No Bridge handler initialised.\");\n+        }\n+\n+        InetAddress addr = InetAddress.getByName(handler.getAddress());\n+        Integer port = handler.getPort();\n+\n+        if (port != null) {\n+            Socket socket = new Socket(addr, port);\n+            qSocket = socket;\n+            qOut = new PrintWriter(socket.getOutputStream(), true);\n+            qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            logger.debug(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                    Thread.currentThread().getId());\n+        } else {\n+            return;\n+        }\n+\n+        setSN();\n+        getSN();\n+\n+        // Connect to Qbus server\n+        Connect();\n+\n+        // If Qbus Client is connected then initialize and start listening for incoming commands, else put Bridge\n+        // offline\n+        if (CTDConnected == true) {\n+            initialize();\n+            Thread thread = new Thread(this::qEvents);\n+            thread.setName(\"OH-binding\");\n+            thread.setDaemon(true);\n+            thread.start();\n+        } else {\n+            handler.bridgeOffline(\"No communication with Qbus client\");\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        CTDConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     *\n+     * @throws InterruptedException\n+     */\n+    public synchronized void restartCommunication() {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        try {\n+            startCommunication();\n+        } catch (InterruptedException | IOException e) {\n+            logger.warn(\"Error on restaring communication.\");\n+        }\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return CTDConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     * @return\n+     *\n+     */\n+    private void qEvents() {\n+        String qMessage;\n+\n+        logger.info(\"Listening for events on thread {}\", Thread.currentThread().getId());\n+        listenerStopped = false;\n+        qEventsRunning = true;\n+\n+        BufferedReader reader = qIn;\n+\n+        try {\n+            if (reader == null) {\n+                throw new IOException(\"Bufferreader for incomming messages not initialized.\");\n+            }\n+            while (!Thread.currentThread().isInterrupted() & ((qMessage = reader.readLine()) != null)) {\n+                if (qMessage != null) {\n+                    readMessage(qMessage);\n+                }\n+            }\n+        } catch (IOException e) {\n+            if (!listenerStopped) {\n+                qEventsRunning = false;\n+                logger.error(\"Qbus: IO error in listener on thread {}\", Thread.currentThread().getId());\n+\n+                QbusBridgeHandler handler = bridgeCallBack;\n+\n+                if (handler != null) {\n+                    CTDConnected = false;\n+                    handler.bridgeOffline(\"No communication with Qbus server\");\n+                }\n+            }\n+        }\n+\n+        qEventsRunning = false;\n+        logger.trace(\"Event listener thread stopped on thread {}\", Thread.currentThread().getId());\n+    };\n+\n+    /**\n+     * Called by other methods to send json data to Qbus.\n+     *\n+     * @param qMessage\n+     * @throws InterruptedException\n+     */\n+    synchronized void sendMessage(Object qMessage) throws InterruptedException {\n+        PrintWriter writer = qOut;\n+        String json = gsonOut.toJson(qMessage);\n+\n+        if (writer != null) {\n+            writer.println(json);\n+            // Delay after sending data to improve scene execution\n+            try {\n+                TimeUnit.MILLISECONDS.sleep(250);\n+            } catch (InterruptedException e) {\n+                throw new InterruptedException(e.toString());\n+            }\n+\n+        }\n+        if ((writer == null) || (writer.checkError())) {\n+            logger.warn(\"Error sending message, trying to restart communication\");\n+            restartCommunication();\n+            // retry sending after restart\n+            writer = qOut;\n+            if (writer != null) {\n+                writer.println(json);\n+            }\n+            if ((writer == null) || (writer.checkError())) {\n+                logger.warn(\"Error resending message\");\n+\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Called by other methods to Qbus server and read response\n+     */\n+    private void sendAndReadMessage(String command) throws IOException, InterruptedException {\n+        @Nullable\n+        String snr = getSN();\n+        if (snr != null) {\n+            QbusMessageCmd qCmd = new QbusMessageCmd(snr, command);\n+\n+            sendMessage(qCmd);\n+\n+            BufferedReader reader = qIn;\n+            if (reader == null) {\n+                throw new IOException(\"Cannot read from socket, reader not connected.\");\n+            }\n+            readMessage(reader.readLine());\n+        } else {\n+            QbusBridgeHandler handler = bridgeCallBack;\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No serial nr defined\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method that interprets all feedback from Qbus Server application and calls appropriate handling methods.\n+     *\n+     * @param qMessage message read from Qbus.\n+     */\n+    private void readMessage(String qMessage) {\n+        String cmd = \"\";\n+        String CTD = \"\";\n+        String sn = null;\n+        QbusMessageBase qMessageGson;\n+\n+        qMessageGson = gsonIn.fromJson(qMessage, QbusMessageBase.class);\n+        if (qMessageGson != null) {\n+            CTD = qMessageGson.getSn();\n+            cmd = qMessageGson.getCmd();\n+        }\n+\n+        if (bridgeCallBack != null) {\n+            sn = bridgeCallBack.getSn();\n+        }\n+\n+        if (sn != null && CTD != null) {\n+            try {\n+                if (Integer.parseInt(sn) == Integer.parseInt(CTD) && qMessageGson != null) {\n+                    // Get the compatible outputs from the Qbus server\n+                    if (\"returnBistabiel\".equals(cmd)) {\n+                        cmdListBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"returnDimmer\".equals(cmd)) {\n+                        cmdListDimmers(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnThermostat\").equals(cmd)) {\n+                        cmdListThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnScene\").equals(cmd)) {\n+                        cmdListscenes(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnCo2\").equals(cmd)) {\n+                        cmdlistco2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnRol02p\").equals(cmd)) {\n+                        cmdlistrol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnSlat\").equals(cmd)) {\n+                        cmdlistrolslats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incoming commands from Qbus Client to openHAB (event)\n+                    else if (\"updateBistabiel\".equals(cmd)) {\n+                        updateBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateDimmer\".equals(cmd)) {\n+                        updateDimmers(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateThermostat\".equals(cmd)) {\n+                        updateThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateCo2\".equals(cmd)) {\n+                        updateCO2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02p\".equals(cmd)) {\n+                        updateRol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02pSlat\".equals(cmd)) {\n+                        updateRolslats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incomming commands from Qbus server to verify the client connection\n+                    else if (\"disconnect\".equals(cmd)) {\n+                        eventDisconnect();\n+                    } else if (\"notConnected\".equals(cmd)) {\n+                        noConnection();\n+                    } else if (\"connected\".equals(cmd)) {\n+                        connection();\n+                    }\n+                }\n+\n+            } catch (JsonParseException e) {\n+                logger.warn(\"Not acted on unsupported json {}\", qMessage);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * After setting up the communication with the Qbus Server, send all initialization messages.\n+     * <p>\n+     * First send connect to connect with the Qbus Server application\n+     * Get request for Bistabiel/Timers/Intervals/Mono outputs\n+     * Get request for the Scenes\n+     * Get request for Dimmers 1T and 2T\n+     * Get request for Shutters\n+     * Get request for Thermostats\n+     * Get request for CO2\n+     *\n+     *\n+     * @throws IOException\n+     * @throws InterruptedException\n+     */\n+\n+    private void initialize() throws IOException, InterruptedException {\n+        if (bridgeCallBack != null) {\n+            if (CTDConnected) {\n+                sendAndReadMessage(\"getBistabiel\");\n+                sendAndReadMessage(\"getScene\");\n+                sendAndReadMessage(\"getDimmer\");\n+                sendAndReadMessage(\"getRol02p\");\n+                sendAndReadMessage(\"getRol02pSlat\");\n+                sendAndReadMessage(\"getThermostat\");\n+                sendAndReadMessage(\"getCo2\");\n+            } else {\n+                CTDConnected = false;\n+\n+                QbusBridgeHandler handler = bridgeCallBack;\n+\n+                if (handler != null) {\n+                    handler.bridgeOffline(\"No communication with Qbus client\");\n+                }\n+\n+                return;\n+            }\n+        } else {\n+            logger.trace(\"Initialization error\");\n+        }\n+    }\n+\n+    public @Nullable String getSN() {\n+        return this.CTD;\n+    }\n+\n+    public void setSN() {\n+        QbusBridgeHandler QBridgeHandler = bridgeCallBack;\n+        if (QBridgeHandler != null) {\n+            this.CTD = QBridgeHandler.getSn();\n+        }\n+    }\n+\n+    /**\n+     * Initial connection to Qbus Server to open a communication channel\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    private void Connect() throws InterruptedException, IOException {\n+        @Nullable\n+        String snr = getSN();\n+\n+        if (snr != null) {\n+            QbusMessageCmd QCmd = new QbusMessageCmd(snr, \"openHAB\");\n+\n+            sendMessage(QCmd);\n+            BufferedReader reader = qIn;\n+\n+            if (reader == null) {\n+                throw new IOException(\"Cannot read from socket, reader not connected.\");\n+            }\n+            readMessage(reader.readLine());\n+        } else {\n+            QbusBridgeHandler handler = bridgeCallBack;\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No serial nr defined\");\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+    /**\n+     * Get all the Bistabiel/Timer/Mono/Interval outputs from the Qbus client\n+     *\n+     * @param data\n+     */\n+    private void cmdListBistabiel(@Nullable List<Map<String, String>> outputs) {\n+        if (outputs != null) {\n+            for (Map<String, String> bistabiel : outputs) {\n+                String idStr = bistabiel.get(\"id\");\n+                String stateStr = bistabiel.get(\"state\");\n+                if (idStr != null && stateStr != null) {\n+                    int id = Integer.parseInt(idStr);\n+                    Integer state = Integer.parseInt(stateStr);\n+                    QbusBistabiel qBistabiel = new QbusBistabiel(idStr);\n+                    if (!this.bistabiel.containsKey(id)) {\n+                        qBistabiel.setState(state);\n+                        qBistabiel.setQComm(this);\n+                        this.bistabiel.put(id, qBistabiel);\n+                        qBistabiel.setState(state);\n+                    } else {\n+                        qBistabiel.setState(state);\n+                    }\n+                } else {\n+                    logger.error(\"Error in json for BistabBistabiel/Timers/Monos/Intervals\");", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMzMTczMA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581331730", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void cmdListscenes(@Nullable List<Map<String, String>> outputs) {\n          \n          \n            \n                private void cmdListScenes(@Nullable List<Map<String, String>> outputs) {", "author": "fwolter", "createdAt": "2021-02-23T19:35:00Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,913 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+\n+    private @Nullable String CTD;\n+\n+    private boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    private @Nullable QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     * @throws InterruptedException\n+     * @throws IOException\n+     *\n+     */\n+\n+    public synchronized void startCommunication() throws IOException, InterruptedException {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+\n+        if (qEventsRunning) {\n+            throw new IOException(\"Previous listening thread is still active.\");\n+        }\n+\n+        if (handler == null) {\n+            throw new IOException(\"No Bridge handler initialised.\");\n+        }\n+\n+        InetAddress addr = InetAddress.getByName(handler.getAddress());\n+        Integer port = handler.getPort();\n+\n+        if (port != null) {\n+            Socket socket = new Socket(addr, port);\n+            qSocket = socket;\n+            qOut = new PrintWriter(socket.getOutputStream(), true);\n+            qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            logger.debug(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                    Thread.currentThread().getId());\n+        } else {\n+            return;\n+        }\n+\n+        setSN();\n+        getSN();\n+\n+        // Connect to Qbus server\n+        Connect();\n+\n+        // If Qbus Client is connected then initialize and start listening for incoming commands, else put Bridge\n+        // offline\n+        if (CTDConnected == true) {\n+            initialize();\n+            Thread thread = new Thread(this::qEvents);\n+            thread.setName(\"OH-binding\");\n+            thread.setDaemon(true);\n+            thread.start();\n+        } else {\n+            handler.bridgeOffline(\"No communication with Qbus client\");\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        CTDConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     *\n+     * @throws InterruptedException\n+     */\n+    public synchronized void restartCommunication() {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        try {\n+            startCommunication();\n+        } catch (InterruptedException | IOException e) {\n+            logger.warn(\"Error on restaring communication.\");\n+        }\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return CTDConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     * @return\n+     *\n+     */\n+    private void qEvents() {\n+        String qMessage;\n+\n+        logger.info(\"Listening for events on thread {}\", Thread.currentThread().getId());\n+        listenerStopped = false;\n+        qEventsRunning = true;\n+\n+        BufferedReader reader = qIn;\n+\n+        try {\n+            if (reader == null) {\n+                throw new IOException(\"Bufferreader for incomming messages not initialized.\");\n+            }\n+            while (!Thread.currentThread().isInterrupted() & ((qMessage = reader.readLine()) != null)) {\n+                if (qMessage != null) {\n+                    readMessage(qMessage);\n+                }\n+            }\n+        } catch (IOException e) {\n+            if (!listenerStopped) {\n+                qEventsRunning = false;\n+                logger.error(\"Qbus: IO error in listener on thread {}\", Thread.currentThread().getId());\n+\n+                QbusBridgeHandler handler = bridgeCallBack;\n+\n+                if (handler != null) {\n+                    CTDConnected = false;\n+                    handler.bridgeOffline(\"No communication with Qbus server\");\n+                }\n+            }\n+        }\n+\n+        qEventsRunning = false;\n+        logger.trace(\"Event listener thread stopped on thread {}\", Thread.currentThread().getId());\n+    };\n+\n+    /**\n+     * Called by other methods to send json data to Qbus.\n+     *\n+     * @param qMessage\n+     * @throws InterruptedException\n+     */\n+    synchronized void sendMessage(Object qMessage) throws InterruptedException {\n+        PrintWriter writer = qOut;\n+        String json = gsonOut.toJson(qMessage);\n+\n+        if (writer != null) {\n+            writer.println(json);\n+            // Delay after sending data to improve scene execution\n+            try {\n+                TimeUnit.MILLISECONDS.sleep(250);\n+            } catch (InterruptedException e) {\n+                throw new InterruptedException(e.toString());\n+            }\n+\n+        }\n+        if ((writer == null) || (writer.checkError())) {\n+            logger.warn(\"Error sending message, trying to restart communication\");\n+            restartCommunication();\n+            // retry sending after restart\n+            writer = qOut;\n+            if (writer != null) {\n+                writer.println(json);\n+            }\n+            if ((writer == null) || (writer.checkError())) {\n+                logger.warn(\"Error resending message\");\n+\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Called by other methods to Qbus server and read response\n+     */\n+    private void sendAndReadMessage(String command) throws IOException, InterruptedException {\n+        @Nullable\n+        String snr = getSN();\n+        if (snr != null) {\n+            QbusMessageCmd qCmd = new QbusMessageCmd(snr, command);\n+\n+            sendMessage(qCmd);\n+\n+            BufferedReader reader = qIn;\n+            if (reader == null) {\n+                throw new IOException(\"Cannot read from socket, reader not connected.\");\n+            }\n+            readMessage(reader.readLine());\n+        } else {\n+            QbusBridgeHandler handler = bridgeCallBack;\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No serial nr defined\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method that interprets all feedback from Qbus Server application and calls appropriate handling methods.\n+     *\n+     * @param qMessage message read from Qbus.\n+     */\n+    private void readMessage(String qMessage) {\n+        String cmd = \"\";\n+        String CTD = \"\";\n+        String sn = null;\n+        QbusMessageBase qMessageGson;\n+\n+        qMessageGson = gsonIn.fromJson(qMessage, QbusMessageBase.class);\n+        if (qMessageGson != null) {\n+            CTD = qMessageGson.getSn();\n+            cmd = qMessageGson.getCmd();\n+        }\n+\n+        if (bridgeCallBack != null) {\n+            sn = bridgeCallBack.getSn();\n+        }\n+\n+        if (sn != null && CTD != null) {\n+            try {\n+                if (Integer.parseInt(sn) == Integer.parseInt(CTD) && qMessageGson != null) {\n+                    // Get the compatible outputs from the Qbus server\n+                    if (\"returnBistabiel\".equals(cmd)) {\n+                        cmdListBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"returnDimmer\".equals(cmd)) {\n+                        cmdListDimmers(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnThermostat\").equals(cmd)) {\n+                        cmdListThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnScene\").equals(cmd)) {\n+                        cmdListscenes(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnCo2\").equals(cmd)) {\n+                        cmdlistco2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnRol02p\").equals(cmd)) {\n+                        cmdlistrol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnSlat\").equals(cmd)) {\n+                        cmdlistrolslats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incoming commands from Qbus Client to openHAB (event)\n+                    else if (\"updateBistabiel\".equals(cmd)) {\n+                        updateBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateDimmer\".equals(cmd)) {\n+                        updateDimmers(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateThermostat\".equals(cmd)) {\n+                        updateThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateCo2\".equals(cmd)) {\n+                        updateCO2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02p\".equals(cmd)) {\n+                        updateRol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02pSlat\".equals(cmd)) {\n+                        updateRolslats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incomming commands from Qbus server to verify the client connection\n+                    else if (\"disconnect\".equals(cmd)) {\n+                        eventDisconnect();\n+                    } else if (\"notConnected\".equals(cmd)) {\n+                        noConnection();\n+                    } else if (\"connected\".equals(cmd)) {\n+                        connection();\n+                    }\n+                }\n+\n+            } catch (JsonParseException e) {\n+                logger.warn(\"Not acted on unsupported json {}\", qMessage);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * After setting up the communication with the Qbus Server, send all initialization messages.\n+     * <p>\n+     * First send connect to connect with the Qbus Server application\n+     * Get request for Bistabiel/Timers/Intervals/Mono outputs\n+     * Get request for the Scenes\n+     * Get request for Dimmers 1T and 2T\n+     * Get request for Shutters\n+     * Get request for Thermostats\n+     * Get request for CO2\n+     *\n+     *\n+     * @throws IOException\n+     * @throws InterruptedException\n+     */\n+\n+    private void initialize() throws IOException, InterruptedException {\n+        if (bridgeCallBack != null) {\n+            if (CTDConnected) {\n+                sendAndReadMessage(\"getBistabiel\");\n+                sendAndReadMessage(\"getScene\");\n+                sendAndReadMessage(\"getDimmer\");\n+                sendAndReadMessage(\"getRol02p\");\n+                sendAndReadMessage(\"getRol02pSlat\");\n+                sendAndReadMessage(\"getThermostat\");\n+                sendAndReadMessage(\"getCo2\");\n+            } else {\n+                CTDConnected = false;\n+\n+                QbusBridgeHandler handler = bridgeCallBack;\n+\n+                if (handler != null) {\n+                    handler.bridgeOffline(\"No communication with Qbus client\");\n+                }\n+\n+                return;\n+            }\n+        } else {\n+            logger.trace(\"Initialization error\");\n+        }\n+    }\n+\n+    public @Nullable String getSN() {\n+        return this.CTD;\n+    }\n+\n+    public void setSN() {\n+        QbusBridgeHandler QBridgeHandler = bridgeCallBack;\n+        if (QBridgeHandler != null) {\n+            this.CTD = QBridgeHandler.getSn();\n+        }\n+    }\n+\n+    /**\n+     * Initial connection to Qbus Server to open a communication channel\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    private void Connect() throws InterruptedException, IOException {\n+        @Nullable\n+        String snr = getSN();\n+\n+        if (snr != null) {\n+            QbusMessageCmd QCmd = new QbusMessageCmd(snr, \"openHAB\");\n+\n+            sendMessage(QCmd);\n+            BufferedReader reader = qIn;\n+\n+            if (reader == null) {\n+                throw new IOException(\"Cannot read from socket, reader not connected.\");\n+            }\n+            readMessage(reader.readLine());\n+        } else {\n+            QbusBridgeHandler handler = bridgeCallBack;\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No serial nr defined\");\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+    /**\n+     * Get all the Bistabiel/Timer/Mono/Interval outputs from the Qbus client\n+     *\n+     * @param data\n+     */\n+    private void cmdListBistabiel(@Nullable List<Map<String, String>> outputs) {\n+        if (outputs != null) {\n+            for (Map<String, String> bistabiel : outputs) {\n+                String idStr = bistabiel.get(\"id\");\n+                String stateStr = bistabiel.get(\"state\");\n+                if (idStr != null && stateStr != null) {\n+                    int id = Integer.parseInt(idStr);\n+                    Integer state = Integer.parseInt(stateStr);\n+                    QbusBistabiel qBistabiel = new QbusBistabiel(idStr);\n+                    if (!this.bistabiel.containsKey(id)) {\n+                        qBistabiel.setState(state);\n+                        qBistabiel.setQComm(this);\n+                        this.bistabiel.put(id, qBistabiel);\n+                        qBistabiel.setState(state);\n+                    } else {\n+                        qBistabiel.setState(state);\n+                    }\n+                } else {\n+                    logger.error(\"Error in json for BistabBistabiel/Timers/Monos/Intervals\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get all the scenes from the Qbus server\n+     *\n+     * @param outputs\n+     */\n+    private void cmdListscenes(@Nullable List<Map<String, String>> outputs) {", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMzMTkyOA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581331928", "bodyText": "Please check all.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void cmdlistrol(@Nullable List<Map<String, String>> outputs) {\n          \n          \n            \n                private void cmdListRol(@Nullable List<Map<String, String>> outputs) {", "author": "fwolter", "createdAt": "2021-02-23T19:35:17Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,913 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+\n+    private @Nullable String CTD;\n+\n+    private boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    private @Nullable QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     * @throws InterruptedException\n+     * @throws IOException\n+     *\n+     */\n+\n+    public synchronized void startCommunication() throws IOException, InterruptedException {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+\n+        if (qEventsRunning) {\n+            throw new IOException(\"Previous listening thread is still active.\");\n+        }\n+\n+        if (handler == null) {\n+            throw new IOException(\"No Bridge handler initialised.\");\n+        }\n+\n+        InetAddress addr = InetAddress.getByName(handler.getAddress());\n+        Integer port = handler.getPort();\n+\n+        if (port != null) {\n+            Socket socket = new Socket(addr, port);\n+            qSocket = socket;\n+            qOut = new PrintWriter(socket.getOutputStream(), true);\n+            qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            logger.debug(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                    Thread.currentThread().getId());\n+        } else {\n+            return;\n+        }\n+\n+        setSN();\n+        getSN();\n+\n+        // Connect to Qbus server\n+        Connect();\n+\n+        // If Qbus Client is connected then initialize and start listening for incoming commands, else put Bridge\n+        // offline\n+        if (CTDConnected == true) {\n+            initialize();\n+            Thread thread = new Thread(this::qEvents);\n+            thread.setName(\"OH-binding\");\n+            thread.setDaemon(true);\n+            thread.start();\n+        } else {\n+            handler.bridgeOffline(\"No communication with Qbus client\");\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        CTDConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     *\n+     * @throws InterruptedException\n+     */\n+    public synchronized void restartCommunication() {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        try {\n+            startCommunication();\n+        } catch (InterruptedException | IOException e) {\n+            logger.warn(\"Error on restaring communication.\");\n+        }\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return CTDConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     * @return\n+     *\n+     */\n+    private void qEvents() {\n+        String qMessage;\n+\n+        logger.info(\"Listening for events on thread {}\", Thread.currentThread().getId());\n+        listenerStopped = false;\n+        qEventsRunning = true;\n+\n+        BufferedReader reader = qIn;\n+\n+        try {\n+            if (reader == null) {\n+                throw new IOException(\"Bufferreader for incomming messages not initialized.\");\n+            }\n+            while (!Thread.currentThread().isInterrupted() & ((qMessage = reader.readLine()) != null)) {\n+                if (qMessage != null) {\n+                    readMessage(qMessage);\n+                }\n+            }\n+        } catch (IOException e) {\n+            if (!listenerStopped) {\n+                qEventsRunning = false;\n+                logger.error(\"Qbus: IO error in listener on thread {}\", Thread.currentThread().getId());\n+\n+                QbusBridgeHandler handler = bridgeCallBack;\n+\n+                if (handler != null) {\n+                    CTDConnected = false;\n+                    handler.bridgeOffline(\"No communication with Qbus server\");\n+                }\n+            }\n+        }\n+\n+        qEventsRunning = false;\n+        logger.trace(\"Event listener thread stopped on thread {}\", Thread.currentThread().getId());\n+    };\n+\n+    /**\n+     * Called by other methods to send json data to Qbus.\n+     *\n+     * @param qMessage\n+     * @throws InterruptedException\n+     */\n+    synchronized void sendMessage(Object qMessage) throws InterruptedException {\n+        PrintWriter writer = qOut;\n+        String json = gsonOut.toJson(qMessage);\n+\n+        if (writer != null) {\n+            writer.println(json);\n+            // Delay after sending data to improve scene execution\n+            try {\n+                TimeUnit.MILLISECONDS.sleep(250);\n+            } catch (InterruptedException e) {\n+                throw new InterruptedException(e.toString());\n+            }\n+\n+        }\n+        if ((writer == null) || (writer.checkError())) {\n+            logger.warn(\"Error sending message, trying to restart communication\");\n+            restartCommunication();\n+            // retry sending after restart\n+            writer = qOut;\n+            if (writer != null) {\n+                writer.println(json);\n+            }\n+            if ((writer == null) || (writer.checkError())) {\n+                logger.warn(\"Error resending message\");\n+\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Called by other methods to Qbus server and read response\n+     */\n+    private void sendAndReadMessage(String command) throws IOException, InterruptedException {\n+        @Nullable\n+        String snr = getSN();\n+        if (snr != null) {\n+            QbusMessageCmd qCmd = new QbusMessageCmd(snr, command);\n+\n+            sendMessage(qCmd);\n+\n+            BufferedReader reader = qIn;\n+            if (reader == null) {\n+                throw new IOException(\"Cannot read from socket, reader not connected.\");\n+            }\n+            readMessage(reader.readLine());\n+        } else {\n+            QbusBridgeHandler handler = bridgeCallBack;\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No serial nr defined\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method that interprets all feedback from Qbus Server application and calls appropriate handling methods.\n+     *\n+     * @param qMessage message read from Qbus.\n+     */\n+    private void readMessage(String qMessage) {\n+        String cmd = \"\";\n+        String CTD = \"\";\n+        String sn = null;\n+        QbusMessageBase qMessageGson;\n+\n+        qMessageGson = gsonIn.fromJson(qMessage, QbusMessageBase.class);\n+        if (qMessageGson != null) {\n+            CTD = qMessageGson.getSn();\n+            cmd = qMessageGson.getCmd();\n+        }\n+\n+        if (bridgeCallBack != null) {\n+            sn = bridgeCallBack.getSn();\n+        }\n+\n+        if (sn != null && CTD != null) {\n+            try {\n+                if (Integer.parseInt(sn) == Integer.parseInt(CTD) && qMessageGson != null) {\n+                    // Get the compatible outputs from the Qbus server\n+                    if (\"returnBistabiel\".equals(cmd)) {\n+                        cmdListBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"returnDimmer\".equals(cmd)) {\n+                        cmdListDimmers(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnThermostat\").equals(cmd)) {\n+                        cmdListThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnScene\").equals(cmd)) {\n+                        cmdListscenes(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnCo2\").equals(cmd)) {\n+                        cmdlistco2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnRol02p\").equals(cmd)) {\n+                        cmdlistrol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnSlat\").equals(cmd)) {\n+                        cmdlistrolslats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incoming commands from Qbus Client to openHAB (event)\n+                    else if (\"updateBistabiel\".equals(cmd)) {\n+                        updateBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateDimmer\".equals(cmd)) {\n+                        updateDimmers(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateThermostat\".equals(cmd)) {\n+                        updateThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateCo2\".equals(cmd)) {\n+                        updateCO2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02p\".equals(cmd)) {\n+                        updateRol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02pSlat\".equals(cmd)) {\n+                        updateRolslats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incomming commands from Qbus server to verify the client connection\n+                    else if (\"disconnect\".equals(cmd)) {\n+                        eventDisconnect();\n+                    } else if (\"notConnected\".equals(cmd)) {\n+                        noConnection();\n+                    } else if (\"connected\".equals(cmd)) {\n+                        connection();\n+                    }\n+                }\n+\n+            } catch (JsonParseException e) {\n+                logger.warn(\"Not acted on unsupported json {}\", qMessage);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * After setting up the communication with the Qbus Server, send all initialization messages.\n+     * <p>\n+     * First send connect to connect with the Qbus Server application\n+     * Get request for Bistabiel/Timers/Intervals/Mono outputs\n+     * Get request for the Scenes\n+     * Get request for Dimmers 1T and 2T\n+     * Get request for Shutters\n+     * Get request for Thermostats\n+     * Get request for CO2\n+     *\n+     *\n+     * @throws IOException\n+     * @throws InterruptedException\n+     */\n+\n+    private void initialize() throws IOException, InterruptedException {\n+        if (bridgeCallBack != null) {\n+            if (CTDConnected) {\n+                sendAndReadMessage(\"getBistabiel\");\n+                sendAndReadMessage(\"getScene\");\n+                sendAndReadMessage(\"getDimmer\");\n+                sendAndReadMessage(\"getRol02p\");\n+                sendAndReadMessage(\"getRol02pSlat\");\n+                sendAndReadMessage(\"getThermostat\");\n+                sendAndReadMessage(\"getCo2\");\n+            } else {\n+                CTDConnected = false;\n+\n+                QbusBridgeHandler handler = bridgeCallBack;\n+\n+                if (handler != null) {\n+                    handler.bridgeOffline(\"No communication with Qbus client\");\n+                }\n+\n+                return;\n+            }\n+        } else {\n+            logger.trace(\"Initialization error\");\n+        }\n+    }\n+\n+    public @Nullable String getSN() {\n+        return this.CTD;\n+    }\n+\n+    public void setSN() {\n+        QbusBridgeHandler QBridgeHandler = bridgeCallBack;\n+        if (QBridgeHandler != null) {\n+            this.CTD = QBridgeHandler.getSn();\n+        }\n+    }\n+\n+    /**\n+     * Initial connection to Qbus Server to open a communication channel\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    private void Connect() throws InterruptedException, IOException {\n+        @Nullable\n+        String snr = getSN();\n+\n+        if (snr != null) {\n+            QbusMessageCmd QCmd = new QbusMessageCmd(snr, \"openHAB\");\n+\n+            sendMessage(QCmd);\n+            BufferedReader reader = qIn;\n+\n+            if (reader == null) {\n+                throw new IOException(\"Cannot read from socket, reader not connected.\");\n+            }\n+            readMessage(reader.readLine());\n+        } else {\n+            QbusBridgeHandler handler = bridgeCallBack;\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No serial nr defined\");\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+    /**\n+     * Get all the Bistabiel/Timer/Mono/Interval outputs from the Qbus client\n+     *\n+     * @param data\n+     */\n+    private void cmdListBistabiel(@Nullable List<Map<String, String>> outputs) {\n+        if (outputs != null) {\n+            for (Map<String, String> bistabiel : outputs) {\n+                String idStr = bistabiel.get(\"id\");\n+                String stateStr = bistabiel.get(\"state\");\n+                if (idStr != null && stateStr != null) {\n+                    int id = Integer.parseInt(idStr);\n+                    Integer state = Integer.parseInt(stateStr);\n+                    QbusBistabiel qBistabiel = new QbusBistabiel(idStr);\n+                    if (!this.bistabiel.containsKey(id)) {\n+                        qBistabiel.setState(state);\n+                        qBistabiel.setQComm(this);\n+                        this.bistabiel.put(id, qBistabiel);\n+                        qBistabiel.setState(state);\n+                    } else {\n+                        qBistabiel.setState(state);\n+                    }\n+                } else {\n+                    logger.error(\"Error in json for BistabBistabiel/Timers/Monos/Intervals\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get all the scenes from the Qbus server\n+     *\n+     * @param outputs\n+     */\n+    private void cmdListscenes(@Nullable List<Map<String, String>> outputs) {\n+        if (outputs != null) {\n+            for (Map<String, String> scene : outputs) {\n+                String idStr = scene.get(\"id\");\n+                if (idStr != null) {\n+                    int id = Integer.parseInt(idStr);\n+                    QbusScene Scene = new QbusScene(idStr);\n+                    Scene.setQComm(this);\n+                    this.scene.put(id, Scene);\n+                } else {\n+                    logger.error(\"Error in json for Scenes\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get all the Dimmer outputs from the Qbus client\n+     *\n+     * @param outputs\n+     */\n+    private void cmdListDimmers(@Nullable List<Map<String, String>> outputs) {\n+        if (outputs != null) {\n+            for (Map<String, String> dimmer : outputs) {\n+                String idStr = dimmer.get(\"id\");\n+                String stateStr = dimmer.get(\"state\");\n+                if (idStr != null && stateStr != null) {\n+                    int id = Integer.parseInt(idStr);\n+                    Integer state = Integer.parseInt(stateStr);\n+                    QbusDimmer qDimmer = new QbusDimmer(idStr);\n+                    if (!this.dimmer.containsKey(id)) {\n+                        qDimmer.setQComm(this);\n+                        this.dimmer.put(id, qDimmer);\n+                        qDimmer.updateState(state);\n+                    } else {\n+                        qDimmer.updateState(state);\n+                    }\n+                } else {\n+                    logger.error(\"Error in json for Dimmer\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get all the screens with slat control outputs from the Qbus client\n+     *\n+     * @param data\n+     */\n+    private void cmdlistrol(@Nullable List<Map<String, String>> outputs) {", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMzMjM3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581332377", "bodyText": "Logging to info should be used sparsely e.g. a newly started component or a user file that has been loaded. This could be debug.", "author": "fwolter", "createdAt": "2021-02-23T19:35:53Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,913 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+\n+    private @Nullable String CTD;\n+\n+    private boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    private @Nullable QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     * @throws InterruptedException\n+     * @throws IOException\n+     *\n+     */\n+\n+    public synchronized void startCommunication() throws IOException, InterruptedException {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+\n+        if (qEventsRunning) {\n+            throw new IOException(\"Previous listening thread is still active.\");\n+        }\n+\n+        if (handler == null) {\n+            throw new IOException(\"No Bridge handler initialised.\");\n+        }\n+\n+        InetAddress addr = InetAddress.getByName(handler.getAddress());\n+        Integer port = handler.getPort();\n+\n+        if (port != null) {\n+            Socket socket = new Socket(addr, port);\n+            qSocket = socket;\n+            qOut = new PrintWriter(socket.getOutputStream(), true);\n+            qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            logger.debug(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                    Thread.currentThread().getId());\n+        } else {\n+            return;\n+        }\n+\n+        setSN();\n+        getSN();\n+\n+        // Connect to Qbus server\n+        Connect();\n+\n+        // If Qbus Client is connected then initialize and start listening for incoming commands, else put Bridge\n+        // offline\n+        if (CTDConnected == true) {\n+            initialize();\n+            Thread thread = new Thread(this::qEvents);\n+            thread.setName(\"OH-binding\");\n+            thread.setDaemon(true);\n+            thread.start();\n+        } else {\n+            handler.bridgeOffline(\"No communication with Qbus client\");\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        CTDConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     *\n+     * @throws InterruptedException\n+     */\n+    public synchronized void restartCommunication() {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        try {\n+            startCommunication();\n+        } catch (InterruptedException | IOException e) {\n+            logger.warn(\"Error on restaring communication.\");\n+        }\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return CTDConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     * @return\n+     *\n+     */\n+    private void qEvents() {\n+        String qMessage;\n+\n+        logger.info(\"Listening for events on thread {}\", Thread.currentThread().getId());\n+        listenerStopped = false;\n+        qEventsRunning = true;\n+\n+        BufferedReader reader = qIn;\n+\n+        try {\n+            if (reader == null) {\n+                throw new IOException(\"Bufferreader for incomming messages not initialized.\");\n+            }\n+            while (!Thread.currentThread().isInterrupted() & ((qMessage = reader.readLine()) != null)) {\n+                if (qMessage != null) {\n+                    readMessage(qMessage);\n+                }\n+            }\n+        } catch (IOException e) {\n+            if (!listenerStopped) {\n+                qEventsRunning = false;\n+                logger.error(\"Qbus: IO error in listener on thread {}\", Thread.currentThread().getId());\n+\n+                QbusBridgeHandler handler = bridgeCallBack;\n+\n+                if (handler != null) {\n+                    CTDConnected = false;\n+                    handler.bridgeOffline(\"No communication with Qbus server\");\n+                }\n+            }\n+        }\n+\n+        qEventsRunning = false;\n+        logger.trace(\"Event listener thread stopped on thread {}\", Thread.currentThread().getId());\n+    };\n+\n+    /**\n+     * Called by other methods to send json data to Qbus.\n+     *\n+     * @param qMessage\n+     * @throws InterruptedException\n+     */\n+    synchronized void sendMessage(Object qMessage) throws InterruptedException {\n+        PrintWriter writer = qOut;\n+        String json = gsonOut.toJson(qMessage);\n+\n+        if (writer != null) {\n+            writer.println(json);\n+            // Delay after sending data to improve scene execution\n+            try {\n+                TimeUnit.MILLISECONDS.sleep(250);\n+            } catch (InterruptedException e) {\n+                throw new InterruptedException(e.toString());\n+            }\n+\n+        }\n+        if ((writer == null) || (writer.checkError())) {\n+            logger.warn(\"Error sending message, trying to restart communication\");\n+            restartCommunication();\n+            // retry sending after restart\n+            writer = qOut;\n+            if (writer != null) {\n+                writer.println(json);\n+            }\n+            if ((writer == null) || (writer.checkError())) {\n+                logger.warn(\"Error resending message\");\n+\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Called by other methods to Qbus server and read response\n+     */\n+    private void sendAndReadMessage(String command) throws IOException, InterruptedException {\n+        @Nullable\n+        String snr = getSN();\n+        if (snr != null) {\n+            QbusMessageCmd qCmd = new QbusMessageCmd(snr, command);\n+\n+            sendMessage(qCmd);\n+\n+            BufferedReader reader = qIn;\n+            if (reader == null) {\n+                throw new IOException(\"Cannot read from socket, reader not connected.\");\n+            }\n+            readMessage(reader.readLine());\n+        } else {\n+            QbusBridgeHandler handler = bridgeCallBack;\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No serial nr defined\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method that interprets all feedback from Qbus Server application and calls appropriate handling methods.\n+     *\n+     * @param qMessage message read from Qbus.\n+     */\n+    private void readMessage(String qMessage) {\n+        String cmd = \"\";\n+        String CTD = \"\";\n+        String sn = null;\n+        QbusMessageBase qMessageGson;\n+\n+        qMessageGson = gsonIn.fromJson(qMessage, QbusMessageBase.class);\n+        if (qMessageGson != null) {\n+            CTD = qMessageGson.getSn();\n+            cmd = qMessageGson.getCmd();\n+        }\n+\n+        if (bridgeCallBack != null) {\n+            sn = bridgeCallBack.getSn();\n+        }\n+\n+        if (sn != null && CTD != null) {\n+            try {\n+                if (Integer.parseInt(sn) == Integer.parseInt(CTD) && qMessageGson != null) {\n+                    // Get the compatible outputs from the Qbus server\n+                    if (\"returnBistabiel\".equals(cmd)) {\n+                        cmdListBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"returnDimmer\".equals(cmd)) {\n+                        cmdListDimmers(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnThermostat\").equals(cmd)) {\n+                        cmdListThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnScene\").equals(cmd)) {\n+                        cmdListscenes(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnCo2\").equals(cmd)) {\n+                        cmdlistco2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnRol02p\").equals(cmd)) {\n+                        cmdlistrol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnSlat\").equals(cmd)) {\n+                        cmdlistrolslats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incoming commands from Qbus Client to openHAB (event)\n+                    else if (\"updateBistabiel\".equals(cmd)) {\n+                        updateBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateDimmer\".equals(cmd)) {\n+                        updateDimmers(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateThermostat\".equals(cmd)) {\n+                        updateThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateCo2\".equals(cmd)) {\n+                        updateCO2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02p\".equals(cmd)) {\n+                        updateRol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02pSlat\".equals(cmd)) {\n+                        updateRolslats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incomming commands from Qbus server to verify the client connection\n+                    else if (\"disconnect\".equals(cmd)) {\n+                        eventDisconnect();\n+                    } else if (\"notConnected\".equals(cmd)) {\n+                        noConnection();\n+                    } else if (\"connected\".equals(cmd)) {\n+                        connection();\n+                    }\n+                }\n+\n+            } catch (JsonParseException e) {\n+                logger.warn(\"Not acted on unsupported json {}\", qMessage);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * After setting up the communication with the Qbus Server, send all initialization messages.\n+     * <p>\n+     * First send connect to connect with the Qbus Server application\n+     * Get request for Bistabiel/Timers/Intervals/Mono outputs\n+     * Get request for the Scenes\n+     * Get request for Dimmers 1T and 2T\n+     * Get request for Shutters\n+     * Get request for Thermostats\n+     * Get request for CO2\n+     *\n+     *\n+     * @throws IOException\n+     * @throws InterruptedException\n+     */\n+\n+    private void initialize() throws IOException, InterruptedException {\n+        if (bridgeCallBack != null) {\n+            if (CTDConnected) {\n+                sendAndReadMessage(\"getBistabiel\");\n+                sendAndReadMessage(\"getScene\");\n+                sendAndReadMessage(\"getDimmer\");\n+                sendAndReadMessage(\"getRol02p\");\n+                sendAndReadMessage(\"getRol02pSlat\");\n+                sendAndReadMessage(\"getThermostat\");\n+                sendAndReadMessage(\"getCo2\");\n+            } else {\n+                CTDConnected = false;\n+\n+                QbusBridgeHandler handler = bridgeCallBack;\n+\n+                if (handler != null) {\n+                    handler.bridgeOffline(\"No communication with Qbus client\");\n+                }\n+\n+                return;\n+            }\n+        } else {\n+            logger.trace(\"Initialization error\");\n+        }\n+    }\n+\n+    public @Nullable String getSN() {\n+        return this.CTD;\n+    }\n+\n+    public void setSN() {\n+        QbusBridgeHandler QBridgeHandler = bridgeCallBack;\n+        if (QBridgeHandler != null) {\n+            this.CTD = QBridgeHandler.getSn();\n+        }\n+    }\n+\n+    /**\n+     * Initial connection to Qbus Server to open a communication channel\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    private void Connect() throws InterruptedException, IOException {\n+        @Nullable\n+        String snr = getSN();\n+\n+        if (snr != null) {\n+            QbusMessageCmd QCmd = new QbusMessageCmd(snr, \"openHAB\");\n+\n+            sendMessage(QCmd);\n+            BufferedReader reader = qIn;\n+\n+            if (reader == null) {\n+                throw new IOException(\"Cannot read from socket, reader not connected.\");\n+            }\n+            readMessage(reader.readLine());\n+        } else {\n+            QbusBridgeHandler handler = bridgeCallBack;\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No serial nr defined\");\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+    /**\n+     * Get all the Bistabiel/Timer/Mono/Interval outputs from the Qbus client\n+     *\n+     * @param data\n+     */\n+    private void cmdListBistabiel(@Nullable List<Map<String, String>> outputs) {\n+        if (outputs != null) {\n+            for (Map<String, String> bistabiel : outputs) {\n+                String idStr = bistabiel.get(\"id\");\n+                String stateStr = bistabiel.get(\"state\");\n+                if (idStr != null && stateStr != null) {\n+                    int id = Integer.parseInt(idStr);\n+                    Integer state = Integer.parseInt(stateStr);\n+                    QbusBistabiel qBistabiel = new QbusBistabiel(idStr);\n+                    if (!this.bistabiel.containsKey(id)) {\n+                        qBistabiel.setState(state);\n+                        qBistabiel.setQComm(this);\n+                        this.bistabiel.put(id, qBistabiel);\n+                        qBistabiel.setState(state);\n+                    } else {\n+                        qBistabiel.setState(state);\n+                    }\n+                } else {\n+                    logger.error(\"Error in json for BistabBistabiel/Timers/Monos/Intervals\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get all the scenes from the Qbus server\n+     *\n+     * @param outputs\n+     */\n+    private void cmdListscenes(@Nullable List<Map<String, String>> outputs) {\n+        if (outputs != null) {\n+            for (Map<String, String> scene : outputs) {\n+                String idStr = scene.get(\"id\");\n+                if (idStr != null) {\n+                    int id = Integer.parseInt(idStr);\n+                    QbusScene Scene = new QbusScene(idStr);\n+                    Scene.setQComm(this);\n+                    this.scene.put(id, Scene);\n+                } else {\n+                    logger.error(\"Error in json for Scenes\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get all the Dimmer outputs from the Qbus client\n+     *\n+     * @param outputs\n+     */\n+    private void cmdListDimmers(@Nullable List<Map<String, String>> outputs) {\n+        if (outputs != null) {\n+            for (Map<String, String> dimmer : outputs) {\n+                String idStr = dimmer.get(\"id\");\n+                String stateStr = dimmer.get(\"state\");\n+                if (idStr != null && stateStr != null) {\n+                    int id = Integer.parseInt(idStr);\n+                    Integer state = Integer.parseInt(stateStr);\n+                    QbusDimmer qDimmer = new QbusDimmer(idStr);\n+                    if (!this.dimmer.containsKey(id)) {\n+                        qDimmer.setQComm(this);\n+                        this.dimmer.put(id, qDimmer);\n+                        qDimmer.updateState(state);\n+                    } else {\n+                        qDimmer.updateState(state);\n+                    }\n+                } else {\n+                    logger.error(\"Error in json for Dimmer\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get all the screens with slat control outputs from the Qbus client\n+     *\n+     * @param data\n+     */\n+    private void cmdlistrol(@Nullable List<Map<String, String>> outputs) {\n+        if (outputs != null) {\n+            for (Map<String, String> rol : outputs) {\n+                String idStr = rol.get(\"id\");\n+                String stateStr = rol.get(\"state\");\n+                if (idStr != null && stateStr != null) {\n+                    int id = Integer.parseInt(idStr);\n+                    Integer rolpos = Integer.valueOf(stateStr);\n+                    QbusRol Qrol = new QbusRol(idStr);\n+                    if (!this.rol.containsKey(id)) {\n+                        Qrol.setQComm(this);\n+                        this.rol.put(id, Qrol);\n+                        Qrol.setState(rolpos);\n+                    } else {\n+                        Qrol.setState(rolpos);\n+                    }\n+                } else {\n+                    logger.error(\"Error in json for ROL02P\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get all the screen outputs from the Qbus client\n+     *\n+     * @param data\n+     */\n+    private void cmdlistrolslats(@Nullable List<Map<String, String>> outputs) {\n+        if (outputs != null) {\n+            for (Map<String, String> rol : outputs) {\n+                String idStr = rol.get(\"id\");\n+                String rolPos = rol.get(\"rolPos\");\n+                String slatPos = rol.get(\"slatPos\");\n+                if (idStr != null && rolPos != null && slatPos != null) {\n+                    int id = Integer.parseInt(idStr);\n+                    Integer rolpos = Integer.parseInt(rolPos);\n+                    Integer rolposslats = Integer.parseInt(slatPos);\n+                    QbusRol Qrol = new QbusRol(idStr);\n+                    if (!this.rol.containsKey(id)) {\n+                        Qrol.setQComm(this);\n+                        this.rol.put(id, Qrol);\n+                        Qrol.setState(rolpos);\n+                        Qrol.setSlats(rolposslats);\n+                    } else {\n+                        Qrol.setState(rolpos);\n+                        Qrol.setSlats(rolposslats);\n+                    }\n+                } else {\n+                    logger.error(\"Error in json for ROL02P_Slats\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get all the CO2 outputs from the Qbus client\n+     *\n+     * @param data\n+     */\n+    private void cmdlistco2(@Nullable List<Map<String, String>> outputs) {\n+        if (outputs != null) {\n+            for (Map<String, String> co2 : outputs) {\n+                String idStr = co2.get(\"id\");\n+                String stateStr = co2.get(\"state\");\n+                if (idStr != null && stateStr != null) {\n+                    int id = Integer.parseInt(idStr);\n+                    int state = Integer.parseInt(stateStr);\n+                    QbusCO2 CO2 = new QbusCO2();\n+                    if (!this.co2.containsKey(id)) {\n+                        this.co2.put(id, CO2);\n+                        CO2.setState(state);\n+                    } else {\n+                        CO2.setState(state);\n+                    }\n+                } else {\n+                    logger.error(\"Error in json for CO2\");\n+                }\n+\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get all the Thermostat outputs from the Qbus client\n+     *\n+     * @param data\n+     */\n+    private void cmdListThermostat(@Nullable List<Map<String, String>> outputs) {\n+        if (outputs != null) {\n+            for (Map<String, String> thermostat : outputs) {\n+                String idStr = thermostat.get(\"id\");\n+                String measuredStr = thermostat.get(\"measured\");\n+                String setpointStr = thermostat.get(\"SetPoint\");\n+                String modeStr = thermostat.get(\"Mode\");\n+                if (idStr != null && measuredStr != null && setpointStr != null && modeStr != null) {\n+                    int id = Integer.parseInt(idStr);\n+                    Double measured = Double.valueOf(measuredStr);\n+                    Double setpoint = Double.valueOf(setpointStr);\n+                    Integer mode = Integer.valueOf(modeStr);\n+                    QbusThermostat qThermostat = new QbusThermostat(idStr);\n+                    if (!this.thermostat.containsKey(id)) {\n+                        qThermostat.updateState(measured, setpoint, mode);\n+                        qThermostat.setQComm(this);\n+                        this.thermostat.put(id, qThermostat);\n+                    } else {\n+                        qThermostat.updateState(measured, setpoint, mode);\n+                    }\n+                } else {\n+                    logger.error(\"Error in json for Thermostats\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Event on incoming Bistabiel/Timer/Mono/Interval updates\n+     *\n+     * @param data\n+     */\n+    private void updateBistabiel(List<Map<String, String>> output) {\n+        for (Map<String, String> bistabiel : output) {\n+            String idStr = bistabiel.get(\"id\");\n+            String stateStr = bistabiel.get(\"state\");\n+            if (idStr != null && stateStr != null) {\n+                int id = Integer.parseInt(idStr);\n+                int value1 = Integer.parseInt(stateStr);\n+                QbusBistabiel Bistabiel = this.bistabiel.get(id);\n+                if (Bistabiel != null) {\n+                    if (!this.bistabiel.containsKey(id)) {\n+                        logger.warn(\"Bistabiel in controller not known {}\", id);\n+                        return;\n+                    }\n+                    logger.info(\"Event execute bistabiel {} with state {}\", id, value1);", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMzMjUxMw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581332513", "bodyText": "See above. Logging to info. Please check all.", "author": "fwolter", "createdAt": "2021-02-23T19:36:07Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,913 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+\n+    private @Nullable String CTD;\n+\n+    private boolean CTDConnected = false;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    private @Nullable QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     * @throws InterruptedException\n+     * @throws IOException\n+     *\n+     */\n+\n+    public synchronized void startCommunication() throws IOException, InterruptedException {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        CTDConnected = false;\n+\n+        if (qEventsRunning) {\n+            throw new IOException(\"Previous listening thread is still active.\");\n+        }\n+\n+        if (handler == null) {\n+            throw new IOException(\"No Bridge handler initialised.\");\n+        }\n+\n+        InetAddress addr = InetAddress.getByName(handler.getAddress());\n+        Integer port = handler.getPort();\n+\n+        if (port != null) {\n+            Socket socket = new Socket(addr, port);\n+            qSocket = socket;\n+            qOut = new PrintWriter(socket.getOutputStream(), true);\n+            qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            logger.debug(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                    Thread.currentThread().getId());\n+        } else {\n+            return;\n+        }\n+\n+        setSN();\n+        getSN();\n+\n+        // Connect to Qbus server\n+        Connect();\n+\n+        // If Qbus Client is connected then initialize and start listening for incoming commands, else put Bridge\n+        // offline\n+        if (CTDConnected == true) {\n+            initialize();\n+            Thread thread = new Thread(this::qEvents);\n+            thread.setName(\"OH-binding\");\n+            thread.setDaemon(true);\n+            thread.start();\n+        } else {\n+            handler.bridgeOffline(\"No communication with Qbus client\");\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        CTDConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     *\n+     * @throws InterruptedException\n+     */\n+    public synchronized void restartCommunication() {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        try {\n+            startCommunication();\n+        } catch (InterruptedException | IOException e) {\n+            logger.warn(\"Error on restaring communication.\");\n+        }\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return CTDConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     * @return\n+     *\n+     */\n+    private void qEvents() {\n+        String qMessage;\n+\n+        logger.info(\"Listening for events on thread {}\", Thread.currentThread().getId());\n+        listenerStopped = false;\n+        qEventsRunning = true;\n+\n+        BufferedReader reader = qIn;\n+\n+        try {\n+            if (reader == null) {\n+                throw new IOException(\"Bufferreader for incomming messages not initialized.\");\n+            }\n+            while (!Thread.currentThread().isInterrupted() & ((qMessage = reader.readLine()) != null)) {\n+                if (qMessage != null) {\n+                    readMessage(qMessage);\n+                }\n+            }\n+        } catch (IOException e) {\n+            if (!listenerStopped) {\n+                qEventsRunning = false;\n+                logger.error(\"Qbus: IO error in listener on thread {}\", Thread.currentThread().getId());\n+\n+                QbusBridgeHandler handler = bridgeCallBack;\n+\n+                if (handler != null) {\n+                    CTDConnected = false;\n+                    handler.bridgeOffline(\"No communication with Qbus server\");\n+                }\n+            }\n+        }\n+\n+        qEventsRunning = false;\n+        logger.trace(\"Event listener thread stopped on thread {}\", Thread.currentThread().getId());\n+    };\n+\n+    /**\n+     * Called by other methods to send json data to Qbus.\n+     *\n+     * @param qMessage\n+     * @throws InterruptedException\n+     */\n+    synchronized void sendMessage(Object qMessage) throws InterruptedException {\n+        PrintWriter writer = qOut;\n+        String json = gsonOut.toJson(qMessage);\n+\n+        if (writer != null) {\n+            writer.println(json);\n+            // Delay after sending data to improve scene execution\n+            try {\n+                TimeUnit.MILLISECONDS.sleep(250);\n+            } catch (InterruptedException e) {\n+                throw new InterruptedException(e.toString());\n+            }\n+\n+        }\n+        if ((writer == null) || (writer.checkError())) {\n+            logger.warn(\"Error sending message, trying to restart communication\");\n+            restartCommunication();\n+            // retry sending after restart\n+            writer = qOut;\n+            if (writer != null) {\n+                writer.println(json);\n+            }\n+            if ((writer == null) || (writer.checkError())) {\n+                logger.warn(\"Error resending message\");\n+\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Called by other methods to Qbus server and read response\n+     */\n+    private void sendAndReadMessage(String command) throws IOException, InterruptedException {\n+        @Nullable\n+        String snr = getSN();\n+        if (snr != null) {\n+            QbusMessageCmd qCmd = new QbusMessageCmd(snr, command);\n+\n+            sendMessage(qCmd);\n+\n+            BufferedReader reader = qIn;\n+            if (reader == null) {\n+                throw new IOException(\"Cannot read from socket, reader not connected.\");\n+            }\n+            readMessage(reader.readLine());\n+        } else {\n+            QbusBridgeHandler handler = bridgeCallBack;\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No serial nr defined\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method that interprets all feedback from Qbus Server application and calls appropriate handling methods.\n+     *\n+     * @param qMessage message read from Qbus.\n+     */\n+    private void readMessage(String qMessage) {\n+        String cmd = \"\";\n+        String CTD = \"\";\n+        String sn = null;\n+        QbusMessageBase qMessageGson;\n+\n+        qMessageGson = gsonIn.fromJson(qMessage, QbusMessageBase.class);\n+        if (qMessageGson != null) {\n+            CTD = qMessageGson.getSn();\n+            cmd = qMessageGson.getCmd();\n+        }\n+\n+        if (bridgeCallBack != null) {\n+            sn = bridgeCallBack.getSn();\n+        }\n+\n+        if (sn != null && CTD != null) {\n+            try {\n+                if (Integer.parseInt(sn) == Integer.parseInt(CTD) && qMessageGson != null) {\n+                    // Get the compatible outputs from the Qbus server\n+                    if (\"returnBistabiel\".equals(cmd)) {\n+                        cmdListBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"returnDimmer\".equals(cmd)) {\n+                        cmdListDimmers(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnThermostat\").equals(cmd)) {\n+                        cmdListThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnScene\").equals(cmd)) {\n+                        cmdListscenes(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnCo2\").equals(cmd)) {\n+                        cmdlistco2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnRol02p\").equals(cmd)) {\n+                        cmdlistrol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnSlat\").equals(cmd)) {\n+                        cmdlistrolslats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incoming commands from Qbus Client to openHAB (event)\n+                    else if (\"updateBistabiel\".equals(cmd)) {\n+                        updateBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateDimmer\".equals(cmd)) {\n+                        updateDimmers(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateThermostat\".equals(cmd)) {\n+                        updateThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateCo2\".equals(cmd)) {\n+                        updateCO2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02p\".equals(cmd)) {\n+                        updateRol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02pSlat\".equals(cmd)) {\n+                        updateRolslats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incomming commands from Qbus server to verify the client connection\n+                    else if (\"disconnect\".equals(cmd)) {\n+                        eventDisconnect();\n+                    } else if (\"notConnected\".equals(cmd)) {\n+                        noConnection();\n+                    } else if (\"connected\".equals(cmd)) {\n+                        connection();\n+                    }\n+                }\n+\n+            } catch (JsonParseException e) {\n+                logger.warn(\"Not acted on unsupported json {}\", qMessage);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * After setting up the communication with the Qbus Server, send all initialization messages.\n+     * <p>\n+     * First send connect to connect with the Qbus Server application\n+     * Get request for Bistabiel/Timers/Intervals/Mono outputs\n+     * Get request for the Scenes\n+     * Get request for Dimmers 1T and 2T\n+     * Get request for Shutters\n+     * Get request for Thermostats\n+     * Get request for CO2\n+     *\n+     *\n+     * @throws IOException\n+     * @throws InterruptedException\n+     */\n+\n+    private void initialize() throws IOException, InterruptedException {\n+        if (bridgeCallBack != null) {\n+            if (CTDConnected) {\n+                sendAndReadMessage(\"getBistabiel\");\n+                sendAndReadMessage(\"getScene\");\n+                sendAndReadMessage(\"getDimmer\");\n+                sendAndReadMessage(\"getRol02p\");\n+                sendAndReadMessage(\"getRol02pSlat\");\n+                sendAndReadMessage(\"getThermostat\");\n+                sendAndReadMessage(\"getCo2\");\n+            } else {\n+                CTDConnected = false;\n+\n+                QbusBridgeHandler handler = bridgeCallBack;\n+\n+                if (handler != null) {\n+                    handler.bridgeOffline(\"No communication with Qbus client\");\n+                }\n+\n+                return;\n+            }\n+        } else {\n+            logger.trace(\"Initialization error\");\n+        }\n+    }\n+\n+    public @Nullable String getSN() {\n+        return this.CTD;\n+    }\n+\n+    public void setSN() {\n+        QbusBridgeHandler QBridgeHandler = bridgeCallBack;\n+        if (QBridgeHandler != null) {\n+            this.CTD = QBridgeHandler.getSn();\n+        }\n+    }\n+\n+    /**\n+     * Initial connection to Qbus Server to open a communication channel\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    private void Connect() throws InterruptedException, IOException {\n+        @Nullable\n+        String snr = getSN();\n+\n+        if (snr != null) {\n+            QbusMessageCmd QCmd = new QbusMessageCmd(snr, \"openHAB\");\n+\n+            sendMessage(QCmd);\n+            BufferedReader reader = qIn;\n+\n+            if (reader == null) {\n+                throw new IOException(\"Cannot read from socket, reader not connected.\");\n+            }\n+            readMessage(reader.readLine());\n+        } else {\n+            QbusBridgeHandler handler = bridgeCallBack;\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No serial nr defined\");\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+    /**\n+     * Get all the Bistabiel/Timer/Mono/Interval outputs from the Qbus client\n+     *\n+     * @param data\n+     */\n+    private void cmdListBistabiel(@Nullable List<Map<String, String>> outputs) {\n+        if (outputs != null) {\n+            for (Map<String, String> bistabiel : outputs) {\n+                String idStr = bistabiel.get(\"id\");\n+                String stateStr = bistabiel.get(\"state\");\n+                if (idStr != null && stateStr != null) {\n+                    int id = Integer.parseInt(idStr);\n+                    Integer state = Integer.parseInt(stateStr);\n+                    QbusBistabiel qBistabiel = new QbusBistabiel(idStr);\n+                    if (!this.bistabiel.containsKey(id)) {\n+                        qBistabiel.setState(state);\n+                        qBistabiel.setQComm(this);\n+                        this.bistabiel.put(id, qBistabiel);\n+                        qBistabiel.setState(state);\n+                    } else {\n+                        qBistabiel.setState(state);\n+                    }\n+                } else {\n+                    logger.error(\"Error in json for BistabBistabiel/Timers/Monos/Intervals\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get all the scenes from the Qbus server\n+     *\n+     * @param outputs\n+     */\n+    private void cmdListscenes(@Nullable List<Map<String, String>> outputs) {\n+        if (outputs != null) {\n+            for (Map<String, String> scene : outputs) {\n+                String idStr = scene.get(\"id\");\n+                if (idStr != null) {\n+                    int id = Integer.parseInt(idStr);\n+                    QbusScene Scene = new QbusScene(idStr);\n+                    Scene.setQComm(this);\n+                    this.scene.put(id, Scene);\n+                } else {\n+                    logger.error(\"Error in json for Scenes\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get all the Dimmer outputs from the Qbus client\n+     *\n+     * @param outputs\n+     */\n+    private void cmdListDimmers(@Nullable List<Map<String, String>> outputs) {\n+        if (outputs != null) {\n+            for (Map<String, String> dimmer : outputs) {\n+                String idStr = dimmer.get(\"id\");\n+                String stateStr = dimmer.get(\"state\");\n+                if (idStr != null && stateStr != null) {\n+                    int id = Integer.parseInt(idStr);\n+                    Integer state = Integer.parseInt(stateStr);\n+                    QbusDimmer qDimmer = new QbusDimmer(idStr);\n+                    if (!this.dimmer.containsKey(id)) {\n+                        qDimmer.setQComm(this);\n+                        this.dimmer.put(id, qDimmer);\n+                        qDimmer.updateState(state);\n+                    } else {\n+                        qDimmer.updateState(state);\n+                    }\n+                } else {\n+                    logger.error(\"Error in json for Dimmer\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get all the screens with slat control outputs from the Qbus client\n+     *\n+     * @param data\n+     */\n+    private void cmdlistrol(@Nullable List<Map<String, String>> outputs) {\n+        if (outputs != null) {\n+            for (Map<String, String> rol : outputs) {\n+                String idStr = rol.get(\"id\");\n+                String stateStr = rol.get(\"state\");\n+                if (idStr != null && stateStr != null) {\n+                    int id = Integer.parseInt(idStr);\n+                    Integer rolpos = Integer.valueOf(stateStr);\n+                    QbusRol Qrol = new QbusRol(idStr);\n+                    if (!this.rol.containsKey(id)) {\n+                        Qrol.setQComm(this);\n+                        this.rol.put(id, Qrol);\n+                        Qrol.setState(rolpos);\n+                    } else {\n+                        Qrol.setState(rolpos);\n+                    }\n+                } else {\n+                    logger.error(\"Error in json for ROL02P\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get all the screen outputs from the Qbus client\n+     *\n+     * @param data\n+     */\n+    private void cmdlistrolslats(@Nullable List<Map<String, String>> outputs) {\n+        if (outputs != null) {\n+            for (Map<String, String> rol : outputs) {\n+                String idStr = rol.get(\"id\");\n+                String rolPos = rol.get(\"rolPos\");\n+                String slatPos = rol.get(\"slatPos\");\n+                if (idStr != null && rolPos != null && slatPos != null) {\n+                    int id = Integer.parseInt(idStr);\n+                    Integer rolpos = Integer.parseInt(rolPos);\n+                    Integer rolposslats = Integer.parseInt(slatPos);\n+                    QbusRol Qrol = new QbusRol(idStr);\n+                    if (!this.rol.containsKey(id)) {\n+                        Qrol.setQComm(this);\n+                        this.rol.put(id, Qrol);\n+                        Qrol.setState(rolpos);\n+                        Qrol.setSlats(rolposslats);\n+                    } else {\n+                        Qrol.setState(rolpos);\n+                        Qrol.setSlats(rolposslats);\n+                    }\n+                } else {\n+                    logger.error(\"Error in json for ROL02P_Slats\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get all the CO2 outputs from the Qbus client\n+     *\n+     * @param data\n+     */\n+    private void cmdlistco2(@Nullable List<Map<String, String>> outputs) {\n+        if (outputs != null) {\n+            for (Map<String, String> co2 : outputs) {\n+                String idStr = co2.get(\"id\");\n+                String stateStr = co2.get(\"state\");\n+                if (idStr != null && stateStr != null) {\n+                    int id = Integer.parseInt(idStr);\n+                    int state = Integer.parseInt(stateStr);\n+                    QbusCO2 CO2 = new QbusCO2();\n+                    if (!this.co2.containsKey(id)) {\n+                        this.co2.put(id, CO2);\n+                        CO2.setState(state);\n+                    } else {\n+                        CO2.setState(state);\n+                    }\n+                } else {\n+                    logger.error(\"Error in json for CO2\");\n+                }\n+\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get all the Thermostat outputs from the Qbus client\n+     *\n+     * @param data\n+     */\n+    private void cmdListThermostat(@Nullable List<Map<String, String>> outputs) {\n+        if (outputs != null) {\n+            for (Map<String, String> thermostat : outputs) {\n+                String idStr = thermostat.get(\"id\");\n+                String measuredStr = thermostat.get(\"measured\");\n+                String setpointStr = thermostat.get(\"SetPoint\");\n+                String modeStr = thermostat.get(\"Mode\");\n+                if (idStr != null && measuredStr != null && setpointStr != null && modeStr != null) {\n+                    int id = Integer.parseInt(idStr);\n+                    Double measured = Double.valueOf(measuredStr);\n+                    Double setpoint = Double.valueOf(setpointStr);\n+                    Integer mode = Integer.valueOf(modeStr);\n+                    QbusThermostat qThermostat = new QbusThermostat(idStr);\n+                    if (!this.thermostat.containsKey(id)) {\n+                        qThermostat.updateState(measured, setpoint, mode);\n+                        qThermostat.setQComm(this);\n+                        this.thermostat.put(id, qThermostat);\n+                    } else {\n+                        qThermostat.updateState(measured, setpoint, mode);\n+                    }\n+                } else {\n+                    logger.error(\"Error in json for Thermostats\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Event on incoming Bistabiel/Timer/Mono/Interval updates\n+     *\n+     * @param data\n+     */\n+    private void updateBistabiel(List<Map<String, String>> output) {\n+        for (Map<String, String> bistabiel : output) {\n+            String idStr = bistabiel.get(\"id\");\n+            String stateStr = bistabiel.get(\"state\");\n+            if (idStr != null && stateStr != null) {\n+                int id = Integer.parseInt(idStr);\n+                int value1 = Integer.parseInt(stateStr);\n+                QbusBistabiel Bistabiel = this.bistabiel.get(id);\n+                if (Bistabiel != null) {\n+                    if (!this.bistabiel.containsKey(id)) {\n+                        logger.warn(\"Bistabiel in controller not known {}\", id);\n+                        return;\n+                    }\n+                    logger.info(\"Event execute bistabiel {} with state {}\", id, value1);\n+                    Bistabiel.setState(value1);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Event on incoming Dimmer updates\n+     *\n+     * @param data\n+     */\n+    private void updateDimmers(List<Map<String, String>> data) {\n+        for (Map<String, String> dimmer : data) {\n+            String idStr = dimmer.get(\"id\");\n+            String stateStr = dimmer.get(\"state\");\n+            if (idStr != null && stateStr != null) {\n+                int id = Integer.valueOf(idStr);\n+                int value = Integer.valueOf(stateStr);\n+                QbusDimmer Qdimmer = this.dimmer.get(id);\n+                if (!this.dimmer.containsKey(id)) {\n+                    logger.warn(\"Dimmer in controller not known {}\", id);\n+                    return;\n+                }\n+                if (Qdimmer != null) {\n+                    logger.info(\"Event execute dimmer {} with state {}\", id, value);", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMzMzE3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581333171", "bodyText": "See above. Handle InterruptedException correctly. Please check all.", "author": "fwolter", "createdAt": "2021-02-23T19:37:00Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusDimmer.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.handler.QbusDimmerHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link QbusDimmer} class represents the action Qbus Dimmer output.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusDimmer {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusDimmer.class);\n+\n+    private @Nullable QbusCommunication QComm;\n+\n+    private String id;\n+\n+    private @Nullable Integer state;\n+\n+    private @Nullable QbusDimmerHandler thingHandler;\n+\n+    QbusDimmer(String id) {\n+        this.id = id;\n+    }\n+\n+    /**\n+     * Update all values of the dimmer\n+     *\n+     * @param state\n+     */\n+    public void updateState(Integer state) {\n+        setState(state);\n+\n+        QbusDimmerHandler handler = thingHandler;\n+        if (handler != null) {\n+            handler.handleStateUpdate(this);\n+        }\n+    }\n+\n+    /**\n+     * This method should be called if the ThingHandler for the thing corresponding to this dimmer is initialized.\n+     * It keeps a record of the thing handler in this object so the thing can be updated when\n+     * the dimmer receives an update from the Qbus IP-interface.\n+     *\n+     * @param handler\n+     */\n+    public void setThingHandler(QbusDimmerHandler handler) {\n+        this.thingHandler = handler;\n+    }\n+\n+    /**\n+     * This method sets a pointer to the QComm Dimmer of class {@link QbusCommuncation}.\n+     * This is then used to be able to call back the sendCommand method in this class to send a command to the\n+     * Qbus IP-interface when..\n+     *\n+     * @param QComm\n+     */\n+    public void setQComm(QbusCommunication QComm) {\n+        this.QComm = QComm;\n+    }\n+\n+    /**\n+     * Get state of dimmer.\n+     *\n+     * @return dimmer state\n+     */\n+    public @Nullable Integer getState() {\n+        if (this.state != null) {\n+            return this.state;\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Sets state of Dimmer.\n+     *\n+     * @param dimmer state\n+     */\n+    void setState(int state) {\n+        this.state = state;\n+        QbusDimmerHandler handler = thingHandler;\n+        if (handler != null) {\n+            handler.handleStateUpdate(this);\n+        }\n+    }\n+\n+    /**\n+     * Sends Dimmer state to Qbus.\n+     */\n+    public void execute(int percent, String sn) {\n+        QbusMessageCmd QCmd = new QbusMessageCmd(sn, \"executeDimmer\").withId(this.id).withState(percent);\n+        QbusCommunication comm = QComm;\n+        if (comm != null) {\n+            try {\n+                comm.sendMessage(QCmd);\n+            } catch (InterruptedException e) {\n+                logger.warn(\"Could not send command for dimmer {}\", this.id);", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTMzNDE4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r581334185", "bodyText": "It's good practice to include the cause in the exception. What throws a IllegalStateException anyway?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new JsonParseException(\"Unexpected Json type\");\n          \n          \n            \n                        throw new JsonParseException(\"Unexpected Json type\", e);", "author": "fwolter", "createdAt": "2021-02-23T19:38:35Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusMessageDeserializer.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonDeserializationContext;\n+import com.google.gson.JsonDeserializer;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * Class {@link QbusMessageDeserializer} deserializes all json messages from Qbus. Various json\n+ * message formats are supported. The format is selected based on the content of the cmd and event json objects.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ *\n+ */\n+\n+@NonNullByDefault\n+class QbusMessageDeserializer implements JsonDeserializer<QbusMessageBase> {\n+\n+    @Override\n+    public @Nullable QbusMessageBase deserialize(final JsonElement json, final Type typeOfT,\n+            final JsonDeserializationContext context) throws JsonParseException {\n+        final JsonObject jsonObject = json.getAsJsonObject();\n+\n+        try {\n+            String cmd = null;\n+            String CTD = null;\n+\n+            if (jsonObject.has(\"cmd\")) {\n+                cmd = jsonObject.get(\"cmd\").getAsString();\n+            }\n+\n+            if (jsonObject.has(\"CTD\")) {\n+                CTD = jsonObject.get(\"CTD\").getAsString();\n+            }\n+\n+            JsonElement jsonOutputs = null;\n+\n+            if (jsonObject.has(\"outputs\")) {\n+                jsonOutputs = jsonObject.get(\"outputs\");\n+            }\n+\n+            QbusMessageBase message = null;\n+\n+            if (jsonOutputs != null) {\n+                if (jsonOutputs.isJsonObject()) {\n+                    message = new QbusMessageMap();\n+\n+                    Map<String, String> outputs = new HashMap<>();\n+                    for (Entry<String, JsonElement> entry : jsonOutputs.getAsJsonObject().entrySet()) {\n+                        outputs.put(entry.getKey(), entry.getValue().getAsString());\n+                    }\n+                    ((QbusMessageMap) message).setOutputs(outputs);\n+\n+                } else if (jsonOutputs.isJsonArray()) {\n+                    JsonArray jsonOutputsArray = jsonOutputs.getAsJsonArray();\n+\n+                    message = new QbusMessageListMap();\n+\n+                    List<Map<String, String>> outputsList = new ArrayList<>();\n+                    for (int i = 0; i < jsonOutputsArray.size(); i++) {\n+                        JsonObject jsonOutputsObject = jsonOutputsArray.get(i).getAsJsonObject();\n+\n+                        Map<String, String> outputs = new HashMap<>();\n+                        for (Entry<String, JsonElement> entry : jsonOutputsObject.entrySet()) {\n+                            outputs.put(entry.getKey(), entry.getValue().getAsString());\n+                        }\n+                        outputsList.add(outputs);\n+                    }\n+                    ((QbusMessageListMap) message).setOutputs(outputsList);\n+                }\n+            }\n+\n+            if (message != null && cmd != null && CTD != null) {\n+                message.setCmd(cmd);\n+                message.setSn(CTD);\n+            } else {\n+                throw new JsonParseException(\"Unexpected Json type\");\n+            }\n+\n+            return message;\n+\n+        } catch (IllegalStateException e) {\n+            throw new JsonParseException(\"Unexpected Json type\");", "originalCommit": "96d8d832f392965564c7f72dabb9f00f0685afca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "10bbea6583b9022d0c7b65fa5d9b6b8200f54068", "url": "https://github.com/openhab/openhab-addons/commit/10bbea6583b9022d0c7b65fa5d9b6b8200f54068", "message": "Updated requested changes\n\nUpdated requested changes by fwolter on 10/02/2021\n\nSigned-off-by: Koen Schockaert <ks@qbus.be>\nSigned-off-by: QbusKoen <ks@qbus.be>", "committedDate": "2021-02-24T15:29:58Z", "type": "commit"}, {"oid": "35f160764de231acf7b9f3e92e3d51df37300a8f", "url": "https://github.com/openhab/openhab-addons/commit/35f160764de231acf7b9f3e92e3d51df37300a8f", "message": "Updated code\n\nUpdated code as requested by FWolter on 23/02/2021", "committedDate": "2021-02-24T15:31:04Z", "type": "commit"}, {"oid": "78b7addb909b45af597f0775893d65fa2494c2e5", "url": "https://github.com/openhab/openhab-addons/commit/78b7addb909b45af597f0775893d65fa2494c2e5", "message": "Merge branch 'main' of https://github.com/QbusKoen/openhab-addons into main\n\nSigned-off-by: Koen Schockaert <ks@qbus.be>", "committedDate": "2021-02-24T16:28:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjE0NDEwMg==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r582144102", "bodyText": "The log message could be removed, as the status update is already logged by the framework.\nThe state change originated by updateStatus() is logged to events.log. Including the status detail message.\nAlso, it's good practice to include the exception's message in the status detail message to display it in the UI.", "author": "fwolter", "createdAt": "2021-02-24T17:12:58Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,313 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private @Nullable QbusCommunication qbusComm;\n+\n+    protected @Nullable QbusConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    /**\n+     * Initialize the bridge\n+     */\n+    @Override\n+    public void initialize() {\n+        readConfig();\n+\n+        InetAddress addr;\n+        Integer port = getPort();\n+        Integer refresh = getRefresh();\n+\n+        if (port == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No port defined for Qbus Server\");\n+            return;\n+        }\n+\n+        try {\n+            addr = InetAddress.getByName(getAddress());\n+            if (addr == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"No ip address defined for Qbus Server\");\n+                return;\n+            } else {\n+                createCommunicationObject(addr, port);\n+            }\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Incorrect ip address set for Qbus Server\");\n+        }\n+\n+        if (refresh != null) {\n+            this.setupRefreshTimer(refresh);\n+        }\n+    }\n+\n+    /**\n+     * Sets the Bridge call back\n+     */\n+    private void setBridgeCallBack() {\n+        QbusCommunication qbusCommunication = getQbusCommunication();\n+        if (qbusCommunication != null) {\n+            qbusCommunication.setBridgeCallBack(this);\n+        }\n+    }\n+\n+    /**\n+     * Create communication object to Qbus server and start communication.\n+     *\n+     * @param addr : IP address of Qbus server\n+     * @param port : Communication port of QbusServer\n+     */\n+    private void createCommunicationObject(InetAddress addr, int port) {\n+        scheduler.submit(() -> {\n+\n+            setQbusCommunication(new QbusCommunication());\n+\n+            QbusCommunication qbusCommunication = getQbusCommunication();\n+\n+            setBridgeCallBack();\n+            if (qbusCommunication != null) {\n+                try {\n+                    qbusCommunication.startCommunication();\n+                } catch (InterruptedException | IOException e) {\n+                    logger.warn(\"Error on restaring communication: {}\", e.getMessage());\n+                    bridgeOffline(\"Communication could not be established\");", "originalCommit": "78b7addb909b45af597f0775893d65fa2494c2e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjE0NTYwMA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r582145600", "bodyText": "The command don't need to be cast.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        OnOffType s = (OnOffType) command;\n          \n          \n            \n                        String snr = getSN();\n          \n          \n            \n                        if (snr != null) {\n          \n          \n            \n                            if (s == OnOffType.OFF) {\n          \n          \n            \n                        String snr = getSN();\n          \n          \n            \n                        if (snr != null) {\n          \n          \n            \n                            if (command == OnOffType.OFF) {", "author": "fwolter", "createdAt": "2021-02-24T17:14:56Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusBistabielHandler.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.CHANNEL_SWITCH;\n+import static org.openhab.core.types.RefreshType.REFRESH;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusBistabiel;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link QbusBistabielHandler} is responsible for handling the Bistable outputs of Qbus\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBistabielHandler extends QbusGlobalHandler {\n+\n+    protected @Nullable QbusThingsConfig config;\n+\n+    private int bistabielId;\n+\n+    private @Nullable String sn;\n+\n+    public QbusBistabielHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /**\n+     * Main initialization\n+     */\n+    @Override\n+    public void initialize() {\n+        readConfig();\n+        bistabielId = getId();\n+\n+        QbusCommunication qComm = getCommunication(\"Bistabiel\", bistabielId);\n+        if (qComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+\n+        QbusBridgeHandler qBridgeHandler = getBridgeHandler(\"Bistabiel\", bistabielId);\n+        if (qBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+\n+        setSN();\n+\n+        Map<Integer, QbusBistabiel> bistabielComm = qComm.getBistabiel();\n+\n+        if (bistabielComm != null) {\n+            QbusBistabiel qBistabiel = bistabielComm.get(bistabielId);\n+            if (qBistabiel != null) {\n+                qBistabiel.setThingHandler(this);\n+                handleStateUpdate(qBistabiel);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Error while initializing the thing.\");\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Error while initializing the thing.\");\n+        }\n+    }\n+\n+    /**\n+     * Returns the serial number of the controller\n+     *\n+     * @return the serial nr\n+     */\n+    public @Nullable String getSN() {\n+        return this.sn;\n+    }\n+\n+    /**\n+     * Sets the serial number of the controller\n+     */\n+    public void setSN() {\n+        QbusBridgeHandler qBridgeHandler = getBridgeHandler(\"Bistabiel\", bistabielId);\n+        if (qBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+        this.sn = qBridgeHandler.getSn();\n+    }\n+\n+    /**\n+     * Handle the status update from the thing\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        QbusCommunication qComm = getCommunication(\"Bistabiel\", bistabielId);\n+        if (qComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Bridge communication not initialized when trying to execute command for bistabiel \" + bistabielId);\n+            return;\n+        }\n+\n+        Map<Integer, QbusBistabiel> bistabielComm = qComm.getBistabiel();\n+\n+        if (bistabielComm != null) {\n+            QbusBistabiel qBistabiel = bistabielComm.get(bistabielId);\n+\n+            if (qBistabiel == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"bridge communication not initialized when trying to execute command for bistabiel \"\n+                                + bistabielId);\n+                return;\n+            } else {\n+                scheduler.submit(() -> {\n+                    if (!qComm.communicationActive()) {\n+                        restartCommunication(qComm, \"Bistabiel\", bistabielId);\n+                    }\n+\n+                    if (qComm.communicationActive()) {\n+                        if (command == REFRESH) {\n+                            handleStateUpdate(qBistabiel);\n+                            return;\n+                        }\n+\n+                        handleSwitchCommand(qBistabiel, channelUID, command);\n+                    }\n+                });\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Error while initializing the thing.\");\n+        }\n+    }\n+\n+    /**\n+     * Executes the switch command\n+     *\n+     * @throws InterruptedException\n+     */\n+    private void handleSwitchCommand(QbusBistabiel qBistabiel, ChannelUID channelUID, Command command) {\n+        if (command instanceof OnOffType) {\n+            OnOffType s = (OnOffType) command;\n+            String snr = getSN();\n+            if (snr != null) {\n+                if (s == OnOffType.OFF) {", "originalCommit": "78b7addb909b45af597f0775893d65fa2494c2e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjE0ODE0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r582148147", "bodyText": "You could add the package to the imports.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (command instanceof org.openhab.core.library.types.UpDownType) {\n          \n          \n            \n                    if (command instanceof UpDownType) {", "author": "fwolter", "createdAt": "2021-02-24T17:18:05Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusRolHandler.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+import static org.openhab.core.library.types.UpDownType.DOWN;\n+import static org.openhab.core.types.RefreshType.REFRESH;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.binding.qbus.internal.protocol.QbusRol;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.UpDownType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link QbusRolHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusRolHandler extends QbusGlobalHandler {\n+\n+    protected @Nullable QbusThingsConfig config;\n+\n+    private int rolId;\n+\n+    private @Nullable String sn;\n+\n+    public QbusRolHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /**\n+     * Main initialization\n+     */\n+    @Override\n+    public void initialize() {\n+        setConfig();\n+        rolId = getId();\n+\n+        QbusCommunication qComm = getCommunication(\"Screen/Store\", rolId);\n+        if (qComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+\n+        QbusBridgeHandler qBridgeHandler = getBridgeHandler(\"Screen/Store\", rolId);\n+        if (qBridgeHandler == null) {\n+            return;\n+        }\n+\n+        setSN();\n+\n+        Map<Integer, QbusRol> rolComm = qComm.getRol();\n+\n+        if (rolComm != null) {\n+            QbusRol qRol = rolComm.get(rolId);\n+            if (qRol != null) {\n+                qRol.setThingHandler(this);\n+                handleStateUpdate(qRol);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Error while initializing the thing.\");\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Error while initializing the thing.\");\n+        }\n+    }\n+\n+    /**\n+     * Returns the serial number of the controller\n+     *\n+     * @return the serial nr\n+     */\n+    public @Nullable String getSN() {\n+        return this.sn;\n+    }\n+\n+    /**\n+     * Sets the serial number of the controller\n+     */\n+    public void setSN() {\n+        QbusBridgeHandler qBridgeHandler = getBridgeHandler(\"Screen/Store\", rolId);\n+        if (qBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+        this.sn = qBridgeHandler.getSn();\n+    }\n+\n+    /**\n+     * Handle the status update from the thing\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        QbusCommunication qComm = getCommunication(\"Screen/Store\", rolId);\n+\n+        if (qComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Bridge communication not initialized when trying to execute command for Screen/Store \" + rolId);\n+            return;\n+        }\n+\n+        Map<Integer, QbusRol> rolComm = qComm.getRol();\n+\n+        if (rolComm != null) {\n+            QbusRol qRol = rolComm.get(rolId);\n+            if (qRol == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Bridge communication not initialized when trying to execute command for ROL \" + rolId);\n+                return;\n+            } else {\n+                scheduler.submit(() -> {\n+                    if (!qComm.communicationActive()) {\n+                        restartCommunication(qComm, \"Screen/Store\", rolId);\n+                    }\n+\n+                    if (qComm.communicationActive()) {\n+                        if (command == REFRESH) {\n+                            handleStateUpdate(qRol);\n+                            return;\n+                        }\n+\n+                        switch (channelUID.getId()) {\n+                            case CHANNEL_ROLLERSHUTTER:\n+                                handleScreenposCommand(qRol, command);\n+                                break;\n+\n+                            case CHANNEL_SLATS:\n+                                handleSlatsposCommand(qRol, command);\n+                                break;\n+                        }\n+                    }\n+                });\n+            }\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param message\n+     */\n+    public void thingOffline(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, message);\n+    }\n+\n+    /**\n+     * Executes the command for screen up/down position\n+     */\n+    private void handleScreenposCommand(QbusRol qRol, Command command) {\n+        String snr = getSN();\n+        if (command instanceof UpDownType) {\n+            UpDownType upDown = (UpDownType) command;\n+            if (upDown == DOWN) {\n+                if (snr != null) {\n+                    qRol.execute(0, snr);\n+                } else {\n+                    thingOffline(\"No serial number configured for  \" + rolId);\n+                }\n+            } else {\n+                if (snr != null) {\n+                    qRol.execute(100, snr);\n+                } else {\n+                    thingOffline(\"No serial number configured for  \" + rolId);\n+                }\n+            }\n+        } else if (command instanceof IncreaseDecreaseType) {\n+            IncreaseDecreaseType inc = (IncreaseDecreaseType) command;\n+            int stepValue = ((Number) this.getConfig().get(CONFIG_STEP_VALUE)).intValue();\n+            Integer currentValue = qRol.getState();\n+            int newValue;\n+            int sendValue;\n+            if (currentValue != null) {\n+                if (inc == IncreaseDecreaseType.INCREASE) {\n+                    newValue = currentValue + stepValue;\n+                    // round down to step multiple\n+                    newValue = newValue - newValue % stepValue;\n+                    sendValue = newValue > 100 ? 100 : newValue;\n+                    if (snr != null) {\n+                        qRol.execute(sendValue, snr);\n+                    } else {\n+                        thingOffline(\"No serial number configured for  \" + rolId);\n+                    }\n+                } else {\n+                    newValue = currentValue - stepValue;\n+                    // round up to step multiple\n+                    newValue = newValue + newValue % stepValue;\n+                    sendValue = newValue > 100 ? 100 : newValue;\n+                    if (snr != null) {\n+                        qRol.execute(sendValue, snr);\n+                    } else {\n+                        thingOffline(\"No serial number configured for  \" + rolId);\n+                    }\n+                }\n+            }\n+        } else if (command instanceof PercentType) {\n+            PercentType p = (PercentType) command;\n+            int pp = p.intValue();\n+            if (p == PercentType.ZERO) {\n+                if (snr != null) {\n+                    qRol.execute(0, snr);\n+                } else {\n+                    thingOffline(\"No serial number configured for  \" + rolId);\n+                }\n+            } else {\n+                if (snr != null) {\n+                    qRol.execute(pp, snr);\n+                } else {\n+                    thingOffline(\"No serial number configured for  \" + rolId);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Executes the command for screen slats position\n+     */\n+    private void handleSlatsposCommand(QbusRol qRol, Command command) {\n+        String snr = getSN();\n+        if (command instanceof org.openhab.core.library.types.UpDownType) {", "originalCommit": "78b7addb909b45af597f0775893d65fa2494c2e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjE1MDA0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r582150049", "bodyText": "You need to use the return value of toUnit() for further processing. Keep in mind that it can return null if the value can't be converted.", "author": "fwolter", "createdAt": "2021-02-24T17:20:27Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusThermostatHandler.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.types.RefreshType.REFRESH;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.binding.qbus.internal.protocol.QbusThermostat;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link QbusThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusThermostatHandler extends QbusGlobalHandler {\n+\n+    protected @Nullable QbusThingsConfig config;\n+\n+    private int thermostatId;\n+\n+    private @Nullable String sn;\n+\n+    public QbusThermostatHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /**\n+     * Main initialization\n+     */\n+    @Override\n+    public void initialize() {\n+        setConfig();\n+        thermostatId = getId();\n+\n+        QbusCommunication qComm = getCommunication(\"Thermostat\", thermostatId);\n+        if (qComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+\n+        QbusBridgeHandler qBridgeHandler = getBridgeHandler(\"Thermostat\", thermostatId);\n+        if (qBridgeHandler == null) {\n+            return;\n+        }\n+\n+        setSN();\n+\n+        Map<Integer, QbusThermostat> thermostatComm = qComm.getThermostat();\n+\n+        if (thermostatComm != null) {\n+            QbusThermostat qThermostat = thermostatComm.get(thermostatId);\n+            if (qThermostat != null) {\n+                qThermostat.setThingHandler(this);\n+                handleStateUpdate(qThermostat);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Error while initializing the thing.\");\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Error while initializing the thing.\");\n+        }\n+    }\n+\n+    /**\n+     * Returns the serial number of the controller\n+     *\n+     * @return the serial nr\n+     */\n+    public @Nullable String getSN() {\n+        return this.sn;\n+    }\n+\n+    /**\n+     * Sets the serial number of the controller\n+     */\n+    public void setSN() {\n+        QbusBridgeHandler qBridgeHandler = getBridgeHandler(\"Thermostat\", thermostatId);\n+        if (qBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+        this.sn = qBridgeHandler.getSn();\n+    }\n+\n+    /**\n+     * Handle the status update from the thing\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        QbusCommunication qComm = getCommunication(\"Thermostat\", thermostatId);\n+\n+        if (qComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Bridge communication not initialized when trying to execute command for thermostat \"\n+                            + thermostatId);\n+            return;\n+        }\n+\n+        Map<Integer, QbusThermostat> thermostatComm = qComm.getThermostat();\n+\n+        if (thermostatComm != null) {\n+            QbusThermostat qThermostat = thermostatComm.get(thermostatId);\n+\n+            if (qThermostat == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Bridge communication not initialized when trying to execute command for Scene \"\n+                                + thermostatId);\n+                return;\n+            } else {\n+                scheduler.submit(() -> {\n+                    if (!qComm.communicationActive()) {\n+                        restartCommunication(qComm, \"Thermostat\", thermostatId);\n+                    }\n+\n+                    if (qComm.communicationActive()) {\n+                        if (command == REFRESH) {\n+                            handleStateUpdate(qThermostat);\n+                            return;\n+                        }\n+\n+                        switch (channelUID.getId()) {\n+                            case CHANNEL_MODE:\n+                                handleModeCommand(qThermostat, command);\n+                                break;\n+\n+                            case CHANNEL_SETPOINT:\n+                                handleSetpointCommand(qThermostat, command);\n+                                break;\n+\n+                        }\n+                    }\n+                });\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Puts thing offline\n+     *\n+     * @param message\n+     */\n+    public void thingOffline(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, message);\n+    }\n+\n+    /**\n+     * Executes the Mode command\n+     */\n+    private void handleModeCommand(QbusThermostat qThermostat, Command command) {\n+        String snr = getSN();\n+        if (command instanceof DecimalType) {\n+            int mode = ((DecimalType) command).intValue();\n+            if (snr != null) {\n+                qThermostat.executeMode(mode, snr);\n+            } else {\n+                thingOffline(\"No serial number configured for  \" + thermostatId);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Executes the Setpoint command\n+     */\n+    private void handleSetpointCommand(QbusThermostat qThermostat, Command command) {\n+        String snr = getSN();\n+        if (command instanceof QuantityType<?>) {\n+            QuantityType<?> s = (QuantityType<?>) command;\n+            double sp = s.doubleValue();\n+            s.toUnit(CELSIUS);", "originalCommit": "78b7addb909b45af597f0775893d65fa2494c2e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjE1NDI0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r582154241", "bodyText": "The ID should be the ThingUID. You could add it as an argument to the constructor of QbusCommunication.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final ExecutorService threadExecutor = Executors\n          \n          \n            \n                        .newSingleThreadExecutor(new NamedThreadFactory(\"org.openhab.binding.qbus\", true));\n          \n          \n            \n                private final ExecutorService threadExecutor = Executors\n          \n          \n            \n                        .newSingleThreadExecutor(new NamedThreadFactory(getThing().getUID().getAsString(), true));", "author": "fwolter", "createdAt": "2021-02-24T17:25:59Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,925 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.core.common.NamedThreadFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+\n+    private @Nullable String ctd;\n+    private boolean ctdConnected;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    private final ExecutorService threadExecutor = Executors\n+            .newSingleThreadExecutor(new NamedThreadFactory(\"org.openhab.binding.qbus\", true));", "originalCommit": "78b7addb909b45af597f0775893d65fa2494c2e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjE1ODgzNw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r582158837", "bodyText": "The InterruptedException shouldn't be cought here, but as high as possible in the program flow to exit the program as directly as possible. You can add throws InterruptedException to the method signature to do so.\nNevertheless, the IOException should be logged here.", "author": "fwolter", "createdAt": "2021-02-24T17:31:58Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,925 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.core.common.NamedThreadFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+\n+    private @Nullable String ctd;\n+    private boolean ctdConnected;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    private final ExecutorService threadExecutor = Executors\n+            .newSingleThreadExecutor(new NamedThreadFactory(\"org.openhab.binding.qbus\", true));\n+\n+    private @Nullable QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     * @throws InterruptedException\n+     * @throws IOException\n+     *\n+     */\n+\n+    public synchronized void startCommunication() throws IOException, InterruptedException {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        ctdConnected = false;\n+\n+        if (qEventsRunning) {\n+            throw new IOException(\"Previous listening thread is still active.\");\n+        }\n+\n+        if (handler == null) {\n+            throw new IOException(\"No Bridge handler initialised.\");\n+        }\n+\n+        InetAddress addr = InetAddress.getByName(handler.getAddress());\n+        Integer port = handler.getPort();\n+\n+        if (port != null) {\n+            Socket socket = new Socket(addr, port);\n+            qSocket = socket;\n+            qOut = new PrintWriter(socket.getOutputStream(), true);\n+            qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            logger.debug(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                    Thread.currentThread().getId());\n+        } else {\n+            return;\n+        }\n+\n+        setSN();\n+        getSN();\n+\n+        // Connect to Qbus server\n+        connect();\n+\n+        // If Qbus Client is connected then initialize and start listening for incoming commands, else put Bridge\n+        // offline\n+        if (ctdConnected) {\n+            initialize();\n+            threadExecutor.execute(() -> {\n+                try {\n+                    qEvents();\n+                } catch (IOException e) {\n+                    logger.debug(\"Could not start thread {} \", e.getMessage());\n+                }\n+            });\n+        } else {\n+            handler.bridgeOffline(\"No communication with Qbus client\");\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+        if (qOut != null) {\n+            qOut.close();\n+        }\n+\n+        try {\n+            if (qIn != null) {\n+                qIn.close();\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"Error on closing reader {} \", e.getMessage());\n+        }\n+        ctdConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     *\n+     * @throws InterruptedException\n+     */\n+    public synchronized void restartCommunication() {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        try {\n+            startCommunication();\n+        } catch (InterruptedException | IOException e) {\n+        }", "originalCommit": "78b7addb909b45af597f0775893d65fa2494c2e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjE1OTI4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r582159283", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new IOException(\"Bufferreader for incomming messages not initialized.\");\n          \n          \n            \n                        throw new IOException(\"Bufferreader for incoming messages not initialized.\");", "author": "fwolter", "createdAt": "2021-02-24T17:32:37Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,925 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.core.common.NamedThreadFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+\n+    private @Nullable String ctd;\n+    private boolean ctdConnected;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    private final ExecutorService threadExecutor = Executors\n+            .newSingleThreadExecutor(new NamedThreadFactory(\"org.openhab.binding.qbus\", true));\n+\n+    private @Nullable QbusBridgeHandler bridgeCallBack;\n+\n+    /**\n+     * Constructor for Qbus communication object, manages communication with\n+     * Qbus Server.\n+     *\n+     */\n+    public QbusCommunication() {\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    /**\n+     * Start communication with Qbus Server, run through initialization and start thread listening\n+     * to all messages coming from Qbus.\n+     *\n+     * @param addr : IP-address of Qbus Server\n+     * @param port : Communication port of Qbus server\n+     * @throws InterruptedException\n+     * @throws IOException\n+     *\n+     */\n+\n+    public synchronized void startCommunication() throws IOException, InterruptedException {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        ctdConnected = false;\n+\n+        if (qEventsRunning) {\n+            throw new IOException(\"Previous listening thread is still active.\");\n+        }\n+\n+        if (handler == null) {\n+            throw new IOException(\"No Bridge handler initialised.\");\n+        }\n+\n+        InetAddress addr = InetAddress.getByName(handler.getAddress());\n+        Integer port = handler.getPort();\n+\n+        if (port != null) {\n+            Socket socket = new Socket(addr, port);\n+            qSocket = socket;\n+            qOut = new PrintWriter(socket.getOutputStream(), true);\n+            qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            logger.debug(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                    Thread.currentThread().getId());\n+        } else {\n+            return;\n+        }\n+\n+        setSN();\n+        getSN();\n+\n+        // Connect to Qbus server\n+        connect();\n+\n+        // If Qbus Client is connected then initialize and start listening for incoming commands, else put Bridge\n+        // offline\n+        if (ctdConnected) {\n+            initialize();\n+            threadExecutor.execute(() -> {\n+                try {\n+                    qEvents();\n+                } catch (IOException e) {\n+                    logger.debug(\"Could not start thread {} \", e.getMessage());\n+                }\n+            });\n+        } else {\n+            handler.bridgeOffline(\"No communication with Qbus client\");\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+        if (qOut != null) {\n+            qOut.close();\n+        }\n+\n+        try {\n+            if (qIn != null) {\n+                qIn.close();\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"Error on closing reader {} \", e.getMessage());\n+        }\n+        ctdConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     *\n+     * @throws InterruptedException\n+     */\n+    public synchronized void restartCommunication() {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        try {\n+            startCommunication();\n+        } catch (InterruptedException | IOException e) {\n+        }\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return ctdConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     * @return\n+     * @throws IOException\n+     *\n+     */\n+    private void qEvents() throws IOException {\n+        String qMessage;\n+\n+        logger.info(\"Listening for events on thread {}\", Thread.currentThread().getId());\n+        listenerStopped = false;\n+        qEventsRunning = true;\n+\n+        BufferedReader reader = qIn;\n+\n+        if (reader == null) {\n+            throw new IOException(\"Bufferreader for incomming messages not initialized.\");", "originalCommit": "78b7addb909b45af597f0775893d65fa2494c2e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjE2NTQwNg==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r582165406", "bodyText": "The field can be null at this point, because it isn't inittialized in the constructor. So, you need to check if it is not null before accessing it: if (config != null). But this would result in a compiler warning, as it is a field and could theoretically be modified by another thread exactly between the null check and the access in the next line. To mitigate this, you can store the field to a local variable before checking it:\nFuture<?> localPollingJob = pollingJob;\nif (localPollingJob != null) {\n    localPollingJob.cancel(true);\n}\n\nThere are some more compiler warnings, which can be seen when calling mvn clean install.", "author": "fwolter", "createdAt": "2021-02-24T17:40:37Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,313 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    private @Nullable QbusCommunication qbusComm;\n+\n+    protected @Nullable QbusConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    /**\n+     * Initialize the bridge\n+     */\n+    @Override\n+    public void initialize() {\n+        readConfig();\n+\n+        InetAddress addr;\n+        Integer port = getPort();\n+        Integer refresh = getRefresh();\n+\n+        if (port == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No port defined for Qbus Server\");\n+            return;\n+        }\n+\n+        try {\n+            addr = InetAddress.getByName(getAddress());\n+            if (addr == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"No ip address defined for Qbus Server\");\n+                return;\n+            } else {\n+                createCommunicationObject(addr, port);\n+            }\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Incorrect ip address set for Qbus Server\");\n+        }\n+\n+        if (refresh != null) {\n+            this.setupRefreshTimer(refresh);\n+        }\n+    }\n+\n+    /**\n+     * Sets the Bridge call back\n+     */\n+    private void setBridgeCallBack() {\n+        QbusCommunication qbusCommunication = getQbusCommunication();\n+        if (qbusCommunication != null) {\n+            qbusCommunication.setBridgeCallBack(this);\n+        }\n+    }\n+\n+    /**\n+     * Create communication object to Qbus server and start communication.\n+     *\n+     * @param addr : IP address of Qbus server\n+     * @param port : Communication port of QbusServer\n+     */\n+    private void createCommunicationObject(InetAddress addr, int port) {\n+        scheduler.submit(() -> {\n+\n+            setQbusCommunication(new QbusCommunication());\n+\n+            QbusCommunication qbusCommunication = getQbusCommunication();\n+\n+            setBridgeCallBack();\n+            if (qbusCommunication != null) {\n+                try {\n+                    qbusCommunication.startCommunication();\n+                } catch (InterruptedException | IOException e) {\n+                    logger.warn(\"Error on restaring communication: {}\", e.getMessage());\n+                    bridgeOffline(\"Communication could not be established\");\n+                    return;\n+                }\n+\n+                if (!qbusCommunication.communicationActive()) {\n+                    bridgeOffline(\"No communication with Qbus Server\");\n+                    return;\n+                }\n+\n+                if (!qbusCommunication.clientConnected()) {\n+                    bridgeOffline(\"No communication with Qbus Client\");\n+                    return;\n+                }\n+            }\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+        });\n+    }\n+\n+    /**\n+     * Take bridge offline when error in communication with Qbus server. This method can also be\n+     * called directly from {@link QbusCommunication} object.\n+     */\n+    public void bridgeOffline(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, message);\n+    }\n+\n+    /**\n+     * Put bridge online when error in communication resolved.\n+     */\n+    public void bridgeOnline() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    /**\n+     * Schedule future communication refresh.\n+     *\n+     * @param interval_config Time before refresh in minutes.\n+     */\n+\n+    private void setupRefreshTimer(int refreshInterval) {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(true);\n+            refreshTimer = null;\n+        }\n+\n+        if (refreshInterval == 0) {\n+            return;\n+        }\n+\n+        // This timer will check connection with server and client periodically\n+        refreshTimer = scheduler.scheduleWithFixedDelay(() -> {\n+            QbusCommunication comm = getCommunication();\n+\n+            if (comm != null) {\n+                if (!comm.communicationActive()) {\n+                    // Disconnected from Qbus Server, try to reconnect\n+                    comm.restartCommunication();\n+                    if (!comm.communicationActive()) {\n+                        bridgeOffline(\"No connection with Qbus Server\");\n+                        return;\n+                    }\n+                } else {\n+                    // Controller disconnected from Qbus client, try to reconnect controller\n+                    if (!comm.clientConnected()) {\n+                        comm.restartCommunication();\n+                        if (!comm.clientConnected()) {\n+                            bridgeOffline(\"No connection with Qbus Client\");\n+                            return;\n+                        }\n+                    }\n+                }\n+            }\n+            updateStatus(ThingStatus.ONLINE);\n+\n+        }, refreshInterval, refreshInterval, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Disposes the Bridge and stops communication with the Qbus server\n+     */\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(true);\n+        }\n+\n+        refreshTimer = null;\n+\n+        QbusCommunication comm = getCommunication();\n+        if (comm != null) {\n+            comm.stopCommunication();\n+        }\n+\n+        comm = null;\n+    }\n+\n+    /**\n+     * Sets the configuration parameters\n+     */\n+    protected void readConfig() {\n+        this.config = getConfig().as(QbusConfiguration.class);\n+    }\n+\n+    /**\n+     * Get the Qbus communication object.\n+     *\n+     * @return Qbus communication object\n+     */\n+    public @Nullable QbusCommunication getCommunication() {\n+        return this.qbusComm;\n+    }\n+\n+    /**\n+     * Get the ip address of the Qbus server.\n+     *\n+     * @return the ip address\n+     */\n+    public @Nullable String getAddress() {\n+        if (this.config != null) {\n+            return this.config.addr;", "originalCommit": "78b7addb909b45af597f0775893d65fa2494c2e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f67dda391c2a8bdda78f96e956ffd920a925b4eb", "url": "https://github.com/openhab/openhab-addons/commit/f67dda391c2a8bdda78f96e956ffd920a925b4eb", "message": "Updated requested changes\n\nUpdated changes as requested by Fwolter on 24/02/2021\n\nSigned-off-by: Koen Schockaert <ks@qbus.be>", "committedDate": "2021-02-24T20:53:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mjk2ODM4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r582968389", "bodyText": "The curly brackets don't work with ordinary string concatenation.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                bridgeOffline(\"Communication could not be established {}\" + e.getMessage());\n          \n          \n            \n                                bridgeOffline(\"Communication could not be established: \" + e.getMessage());", "author": "fwolter", "createdAt": "2021-02-25T16:16:19Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,360 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private @Nullable QbusCommunication qbusComm;\n+\n+    protected @Nullable QbusConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    /**\n+     * Initialize the bridge\n+     */\n+    @Override\n+    public void initialize() {\n+        readConfig();\n+\n+        InetAddress addr;\n+        Integer port = getPort();\n+        Integer refresh = getRefresh();\n+\n+        if (port == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No port defined for Qbus Server\");\n+            return;\n+        }\n+\n+        try {\n+            addr = InetAddress.getByName(getAddress());\n+            if (addr == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"No ip address defined for Qbus Server\");\n+                return;\n+            } else {\n+                createCommunicationObject(addr, port);\n+            }\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Incorrect ip address set for Qbus Server\");\n+        }\n+\n+        if (refresh != null) {\n+            this.setupRefreshTimer(refresh);\n+        }\n+    }\n+\n+    /**\n+     * Sets the Bridge call back\n+     */\n+    private void setBridgeCallBack() {\n+        QbusCommunication qbusCommunication = getQbusCommunication();\n+        if (qbusCommunication != null) {\n+            qbusCommunication.setBridgeCallBack(this);\n+        }\n+    }\n+\n+    /**\n+     * Create communication object to Qbus server and start communication.\n+     *\n+     * @param addr : IP address of Qbus server\n+     * @param port : Communication port of QbusServer\n+     */\n+    private void createCommunicationObject(InetAddress addr, int port) {\n+        scheduler.submit(() -> {\n+\n+            setQbusCommunication(new QbusCommunication(thing));\n+\n+            QbusCommunication qbusCommunication = getQbusCommunication();\n+\n+            setBridgeCallBack();\n+            if (qbusCommunication != null) {\n+                try {\n+                    qbusCommunication.startCommunication();\n+                } catch (InterruptedException | IOException e) {\n+                    bridgeOffline(\"Communication could not be established {}\" + e.getMessage());", "originalCommit": "f67dda391c2a8bdda78f96e956ffd920a925b4eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mjk2ODg1OA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r582968858", "bodyText": "There needs to be a space. Please check all.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    bridgeOffline(\"No connection with Qbus Server\" + e.toString());\n          \n          \n            \n                                    bridgeOffline(\"No connection with Qbus Server: \" + e.toString());", "author": "fwolter", "createdAt": "2021-02-25T16:16:55Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,360 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private @Nullable QbusCommunication qbusComm;\n+\n+    protected @Nullable QbusConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    /**\n+     * Initialize the bridge\n+     */\n+    @Override\n+    public void initialize() {\n+        readConfig();\n+\n+        InetAddress addr;\n+        Integer port = getPort();\n+        Integer refresh = getRefresh();\n+\n+        if (port == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No port defined for Qbus Server\");\n+            return;\n+        }\n+\n+        try {\n+            addr = InetAddress.getByName(getAddress());\n+            if (addr == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"No ip address defined for Qbus Server\");\n+                return;\n+            } else {\n+                createCommunicationObject(addr, port);\n+            }\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Incorrect ip address set for Qbus Server\");\n+        }\n+\n+        if (refresh != null) {\n+            this.setupRefreshTimer(refresh);\n+        }\n+    }\n+\n+    /**\n+     * Sets the Bridge call back\n+     */\n+    private void setBridgeCallBack() {\n+        QbusCommunication qbusCommunication = getQbusCommunication();\n+        if (qbusCommunication != null) {\n+            qbusCommunication.setBridgeCallBack(this);\n+        }\n+    }\n+\n+    /**\n+     * Create communication object to Qbus server and start communication.\n+     *\n+     * @param addr : IP address of Qbus server\n+     * @param port : Communication port of QbusServer\n+     */\n+    private void createCommunicationObject(InetAddress addr, int port) {\n+        scheduler.submit(() -> {\n+\n+            setQbusCommunication(new QbusCommunication(thing));\n+\n+            QbusCommunication qbusCommunication = getQbusCommunication();\n+\n+            setBridgeCallBack();\n+            if (qbusCommunication != null) {\n+                try {\n+                    qbusCommunication.startCommunication();\n+                } catch (InterruptedException | IOException e) {\n+                    bridgeOffline(\"Communication could not be established {}\" + e.getMessage());\n+                    return;\n+                }\n+\n+                if (!qbusCommunication.communicationActive()) {\n+                    bridgeOffline(\"No communication with Qbus Server\");\n+                    return;\n+                }\n+\n+                if (!qbusCommunication.clientConnected()) {\n+                    bridgeOffline(\"No communication with Qbus Client\");\n+                    return;\n+                }\n+            }\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+        });\n+    }\n+\n+    /**\n+     * Take bridge offline when error in communication with Qbus server. This method can also be\n+     * called directly from {@link QbusCommunication} object.\n+     */\n+    public void bridgeOffline(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, message);\n+    }\n+\n+    /**\n+     * Put bridge online when error in communication resolved.\n+     */\n+    public void bridgeOnline() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    /**\n+     * Schedule future communication refresh.\n+     *\n+     * @param interval_config Time before refresh in minutes.\n+     */\n+\n+    private void setupRefreshTimer(int refreshInterval) {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(true);\n+            refreshTimer = null;\n+        }\n+\n+        if (refreshInterval == 0) {\n+            return;\n+        }\n+\n+        // This timer will check connection with server and client periodically\n+        refreshTimer = scheduler.scheduleWithFixedDelay(() -> {\n+            QbusCommunication comm = getCommunication();\n+\n+            if (comm != null) {\n+                if (!comm.communicationActive()) {\n+                    // Disconnected from Qbus Server, try to reconnect\n+                    try {\n+                        comm.restartCommunication();\n+                    } catch (InterruptedException e) {\n+                        bridgeOffline(\"No connection with Qbus Server\" + e.toString());", "originalCommit": "f67dda391c2a8bdda78f96e956ffd920a925b4eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mjk2OTM5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r582969393", "bodyText": "Bindings should only log to error if something severe happened, like the detection of a bug in your code. This could be debug. See this link for a description of the log levels: https://www.openhab.org/docs/developer/guidelines.html#f-logging", "author": "fwolter", "createdAt": "2021-02-25T16:17:34Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,360 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private @Nullable QbusCommunication qbusComm;\n+\n+    protected @Nullable QbusConfiguration config;\n+\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    /**\n+     * Initialize the bridge\n+     */\n+    @Override\n+    public void initialize() {\n+        readConfig();\n+\n+        InetAddress addr;\n+        Integer port = getPort();\n+        Integer refresh = getRefresh();\n+\n+        if (port == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No port defined for Qbus Server\");\n+            return;\n+        }\n+\n+        try {\n+            addr = InetAddress.getByName(getAddress());\n+            if (addr == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"No ip address defined for Qbus Server\");\n+                return;\n+            } else {\n+                createCommunicationObject(addr, port);\n+            }\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Incorrect ip address set for Qbus Server\");\n+        }\n+\n+        if (refresh != null) {\n+            this.setupRefreshTimer(refresh);\n+        }\n+    }\n+\n+    /**\n+     * Sets the Bridge call back\n+     */\n+    private void setBridgeCallBack() {\n+        QbusCommunication qbusCommunication = getQbusCommunication();\n+        if (qbusCommunication != null) {\n+            qbusCommunication.setBridgeCallBack(this);\n+        }\n+    }\n+\n+    /**\n+     * Create communication object to Qbus server and start communication.\n+     *\n+     * @param addr : IP address of Qbus server\n+     * @param port : Communication port of QbusServer\n+     */\n+    private void createCommunicationObject(InetAddress addr, int port) {\n+        scheduler.submit(() -> {\n+\n+            setQbusCommunication(new QbusCommunication(thing));\n+\n+            QbusCommunication qbusCommunication = getQbusCommunication();\n+\n+            setBridgeCallBack();\n+            if (qbusCommunication != null) {\n+                try {\n+                    qbusCommunication.startCommunication();\n+                } catch (InterruptedException | IOException e) {\n+                    bridgeOffline(\"Communication could not be established {}\" + e.getMessage());\n+                    return;\n+                }\n+\n+                if (!qbusCommunication.communicationActive()) {\n+                    bridgeOffline(\"No communication with Qbus Server\");\n+                    return;\n+                }\n+\n+                if (!qbusCommunication.clientConnected()) {\n+                    bridgeOffline(\"No communication with Qbus Client\");\n+                    return;\n+                }\n+            }\n+\n+            updateStatus(ThingStatus.ONLINE);\n+\n+        });\n+    }\n+\n+    /**\n+     * Take bridge offline when error in communication with Qbus server. This method can also be\n+     * called directly from {@link QbusCommunication} object.\n+     */\n+    public void bridgeOffline(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, message);\n+    }\n+\n+    /**\n+     * Put bridge online when error in communication resolved.\n+     */\n+    public void bridgeOnline() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    /**\n+     * Schedule future communication refresh.\n+     *\n+     * @param interval_config Time before refresh in minutes.\n+     */\n+\n+    private void setupRefreshTimer(int refreshInterval) {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(true);\n+            refreshTimer = null;\n+        }\n+\n+        if (refreshInterval == 0) {\n+            return;\n+        }\n+\n+        // This timer will check connection with server and client periodically\n+        refreshTimer = scheduler.scheduleWithFixedDelay(() -> {\n+            QbusCommunication comm = getCommunication();\n+\n+            if (comm != null) {\n+                if (!comm.communicationActive()) {\n+                    // Disconnected from Qbus Server, try to reconnect\n+                    try {\n+                        comm.restartCommunication();\n+                    } catch (InterruptedException e) {\n+                        bridgeOffline(\"No connection with Qbus Server\" + e.toString());\n+                    } catch (IOException e) {\n+                        bridgeOffline(\"No connection with Qbus Server\" + e.toString());\n+                    }\n+                    if (!comm.communicationActive()) {\n+                        bridgeOffline(\"No connection with Qbus Server\");\n+                        return;\n+                    }\n+                } else {\n+                    // Controller disconnected from Qbus client, try to reconnect controller\n+                    if (!comm.clientConnected()) {\n+                        try {\n+                            comm.restartCommunication();\n+                        } catch (InterruptedException e) {\n+                            bridgeOffline(\"No connection with Qbus Server\" + e.toString());\n+                        } catch (IOException e) {\n+                            bridgeOffline(\"No connection with Qbus Server\" + e.toString());\n+                        }\n+                        if (!comm.clientConnected()) {\n+                            bridgeOffline(\"No connection with Qbus Client\");\n+                            return;\n+                        }\n+                    }\n+                }\n+            }\n+            updateStatus(ThingStatus.ONLINE);\n+\n+        }, refreshInterval, refreshInterval, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Disposes the Bridge and stops communication with the Qbus server\n+     */\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(true);\n+        }\n+\n+        refreshTimer = null;\n+\n+        QbusCommunication comm = getCommunication();\n+\n+        if (comm != null) {\n+            try {\n+                comm.stopCommunication();\n+            } catch (IOException e) {\n+                String message = e.toString();\n+                logger.error(\"Error on stopping communication.{} \", message);", "originalCommit": "f67dda391c2a8bdda78f96e956ffd920a925b4eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mjk3MjY3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r582972673", "bodyText": "You might want to call qBridgeHandler.bridgeOnline() only if no exception occurred. Otherwise, the Thing will be set to OFFLINE and then, qBridgeHandler.bridgeOnline() will be called.", "author": "fwolter", "createdAt": "2021-02-25T16:21:31Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusGlobalHandler.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import java.io.IOException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+\n+/**\n+ * The {@link QbusGlobalHandler} is used in other handlers, to share the functions.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public abstract class QbusGlobalHandler extends BaseThingHandler {\n+\n+    public QbusGlobalHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /**\n+     * Get Bridge communication\n+     *\n+     * @param type\n+     * @param globalId\n+     * @return\n+     */\n+    public @Nullable QbusCommunication getCommunication(String type, @Nullable Integer globalId) {\n+        QbusBridgeHandler qBridgeHandler = null;\n+        if (globalId != null) {\n+            qBridgeHandler = getBridgeHandler(type, globalId);\n+        }\n+\n+        if (qBridgeHandler == null) {\n+            updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.BRIDGE_UNINITIALIZED,\n+                    \"No bridge handler initialized for \" + type + \" with id \" + globalId + \".\");\n+            return null;\n+        }\n+        QbusCommunication qComm = qBridgeHandler.getCommunication();\n+        return qComm;\n+    }\n+\n+    /**\n+     * Get the Bridge handler\n+     *\n+     * @param type\n+     * @param globalId\n+     * @return\n+     */\n+    public @Nullable QbusBridgeHandler getBridgeHandler(String type, @Nullable Integer globalId) {\n+        Bridge qBridge = getBridge();\n+        if (qBridge == null) {\n+            updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.BRIDGE_UNINITIALIZED,\n+                    \"No bridge initialized for \" + type + \" with ID \" + globalId);\n+            return null;\n+        }\n+        QbusBridgeHandler qBridgeHandler = (QbusBridgeHandler) qBridge.getHandler();\n+        return qBridgeHandler;\n+    }\n+\n+    /**\n+     *\n+     * @param qComm\n+     * @param type\n+     * @param globalId\n+     */\n+    public void restartCommunication(QbusCommunication qComm, String type, @Nullable Integer globalId) {\n+        try {\n+            qComm.restartCommunication();\n+        } catch (InterruptedException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.toString());\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.toString());\n+        }\n+\n+        if (!qComm.communicationActive()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Communication socket error\");\n+            return;\n+        }\n+\n+        QbusBridgeHandler qBridgeHandler = getBridgeHandler(type, globalId);\n+        if (qBridgeHandler != null) {\n+            qBridgeHandler.bridgeOnline();\n+        }", "originalCommit": "f67dda391c2a8bdda78f96e956ffd920a925b4eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mjk3NDA3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r582974076", "bodyText": "The command don't need to be cast. Please check all.", "author": "fwolter", "createdAt": "2021-02-25T16:23:14Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusSceneHandler.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.CHANNEL_SCENE;\n+\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.binding.qbus.internal.protocol.QbusScene;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link QbusSceneHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusSceneHandler extends QbusGlobalHandler {\n+\n+    protected @Nullable QbusThingsConfig config;\n+\n+    private @Nullable Integer sceneId;\n+\n+    private @Nullable String sn;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    public QbusSceneHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /**\n+     * Main initialization\n+     */\n+    @Override\n+    public void initialize() {\n+        setConfig();\n+        sceneId = getId();\n+\n+        QbusCommunication qComm = getCommunication(\"Scene\", sceneId);\n+        if (qComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+\n+        QbusBridgeHandler qBridgeHandler = getBridgeHandler(\"Scene\", sceneId);\n+        if (qBridgeHandler == null) {\n+            return;\n+        }\n+\n+        setSN();\n+\n+        Map<Integer, QbusScene> sceneComm = qComm.getScene();\n+\n+        if (sceneComm != null) {\n+            QbusScene qScene = sceneComm.get(sceneId);\n+            if (qScene != null) {\n+                qScene.setThingHandler(this);\n+                updateStatus(ThingStatus.ONLINE);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Error while initializing the thing.\");\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Error while initializing the thing.\");\n+        }\n+    }\n+\n+    /**\n+     * Returns the serial number of the controller\n+     *\n+     * @return the serial nr\n+     */\n+    public @Nullable String getSN() {\n+        return this.sn;\n+    }\n+\n+    /**\n+     * Sets the serial number of the controller\n+     */\n+    public void setSN() {\n+        QbusBridgeHandler qBridgeHandler = getBridgeHandler(\"Scene\", sceneId);\n+        if (qBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+        this.sn = qBridgeHandler.getSn();\n+    }\n+\n+    /**\n+     * Handle the status update from the thing\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        QbusCommunication qComm = getCommunication(\"Scene\", sceneId);\n+\n+        if (qComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Bridge communication not initialized when trying to execute command for Scene \" + sceneId);\n+            return;\n+        }\n+\n+        Map<Integer, QbusScene> sceneComm = qComm.getScene();\n+\n+        if (sceneComm != null) {\n+            QbusScene qScene = sceneComm.get(sceneId);\n+            if (qScene == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Bridge communication not initialized when trying to execute command for Scene \" + sceneId);\n+                return;\n+            } else {\n+                scheduler.submit(() -> {\n+                    if (!qComm.communicationActive()) {\n+                        restartCommunication(qComm, \"Scene\", sceneId);\n+                    }\n+\n+                    if (qComm.communicationActive()) {\n+                        switch (channelUID.getId()) {\n+                            case CHANNEL_SCENE:\n+                                handleSwitchCommand(qScene, channelUID, command);\n+                                break;\n+                        }\n+                    }\n+                });\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method to update state of channel, called from Qbus Scene.\n+     */\n+    public void handleStateUpdate(QbusScene qScene) {\n+        Integer sceneState = qScene.getState();\n+        if (sceneState != null) {\n+            updateState(CHANNEL_SCENE, (sceneState == 0) ? OnOffType.OFF : OnOffType.ON);\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param message\n+     */\n+    public void thingOffline(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, message);\n+    }\n+\n+    /**\n+     * Executes the scene command\n+     */\n+    void handleSwitchCommand(QbusScene qScene, ChannelUID channelUID, Command command) {\n+        String snr = getSN();\n+        if (command instanceof OnOffType) {\n+            OnOffType s = (OnOffType) command;\n+            if (s == OnOffType.OFF) {", "originalCommit": "f67dda391c2a8bdda78f96e956ffd920a925b4eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mjk3NTQ0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r582975449", "bodyText": "As this is not a permanent error, you are good to log it only.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                thingOffline(\"Could not set setpoint for thermostat (convertion failed)  \" + thermostatId);\n          \n          \n            \n                                thingOffline(\"Could not set setpoint for thermostat (conversion failed)  \" + thermostatId);", "author": "fwolter", "createdAt": "2021-02-25T16:24:55Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusThermostatHandler.java", "diffHunk": "@@ -0,0 +1,265 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+import static org.openhab.core.library.unit.SIUnits.CELSIUS;\n+import static org.openhab.core.types.RefreshType.REFRESH;\n+\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.binding.qbus.internal.protocol.QbusThermostat;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link QbusThermostatHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusThermostatHandler extends QbusGlobalHandler {\n+\n+    protected @Nullable QbusThingsConfig config;\n+\n+    private @Nullable Integer thermostatId;\n+\n+    private @Nullable String sn;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    public QbusThermostatHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /**\n+     * Main initialization\n+     */\n+    @Override\n+    public void initialize() {\n+        setConfig();\n+        thermostatId = getId();\n+\n+        QbusCommunication qComm = getCommunication(\"Thermostat\", thermostatId);\n+        if (qComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+\n+        QbusBridgeHandler qBridgeHandler = getBridgeHandler(\"Thermostat\", thermostatId);\n+        if (qBridgeHandler == null) {\n+            return;\n+        }\n+\n+        setSN();\n+\n+        Map<Integer, QbusThermostat> thermostatComm = qComm.getThermostat();\n+\n+        if (thermostatComm != null) {\n+            QbusThermostat qThermostat = thermostatComm.get(thermostatId);\n+            if (qThermostat != null) {\n+                qThermostat.setThingHandler(this);\n+                handleStateUpdate(qThermostat);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Error while initializing the thing.\");\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Error while initializing the thing.\");\n+        }\n+    }\n+\n+    /**\n+     * Returns the serial number of the controller\n+     *\n+     * @return the serial nr\n+     */\n+    public @Nullable String getSN() {\n+        return this.sn;\n+    }\n+\n+    /**\n+     * Sets the serial number of the controller\n+     */\n+    public void setSN() {\n+        QbusBridgeHandler qBridgeHandler = getBridgeHandler(\"Thermostat\", thermostatId);\n+        if (qBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+        this.sn = qBridgeHandler.getSn();\n+    }\n+\n+    /**\n+     * Handle the status update from the thing\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        QbusCommunication qComm = getCommunication(\"Thermostat\", thermostatId);\n+\n+        if (qComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Bridge communication not initialized when trying to execute command for thermostat \"\n+                            + thermostatId);\n+            return;\n+        }\n+\n+        Map<Integer, QbusThermostat> thermostatComm = qComm.getThermostat();\n+\n+        if (thermostatComm != null) {\n+            QbusThermostat qThermostat = thermostatComm.get(thermostatId);\n+\n+            if (qThermostat == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Bridge communication not initialized when trying to execute command for Scene \"\n+                                + thermostatId);\n+                return;\n+            } else {\n+                scheduler.submit(() -> {\n+                    if (!qComm.communicationActive()) {\n+                        restartCommunication(qComm, \"Thermostat\", thermostatId);\n+                    }\n+\n+                    if (qComm.communicationActive()) {\n+                        if (command == REFRESH) {\n+                            handleStateUpdate(qThermostat);\n+                            return;\n+                        }\n+\n+                        switch (channelUID.getId()) {\n+                            case CHANNEL_MODE:\n+                                handleModeCommand(qThermostat, command);\n+                                break;\n+\n+                            case CHANNEL_SETPOINT:\n+                                handleSetpointCommand(qThermostat, command);\n+                                break;\n+\n+                        }\n+                    }\n+                });\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Puts thing offline\n+     *\n+     * @param message\n+     */\n+    public void thingOffline(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, message);\n+    }\n+\n+    /**\n+     * Executes the Mode command\n+     */\n+    private void handleModeCommand(QbusThermostat qThermostat, Command command) {\n+        String snr = getSN();\n+        if (command instanceof DecimalType) {\n+            int mode = ((DecimalType) command).intValue();\n+            if (snr != null) {\n+                qThermostat.executeMode(mode, snr);\n+            } else {\n+                thingOffline(\"No serial number configured for  \" + thermostatId);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Executes the Setpoint command\n+     */\n+    private void handleSetpointCommand(QbusThermostat qThermostat, Command command) {\n+        String snr = getSN();\n+        if (command instanceof QuantityType<?>) {\n+            QuantityType<?> s = (QuantityType<?>) command;\n+            double sp = s.doubleValue();\n+            QuantityType<?> spCelcius = s.toUnit(CELSIUS);\n+\n+            if (snr != null) {\n+                if (spCelcius != null) {\n+                    qThermostat.executeSetpoint(sp, snr);\n+                } else {\n+                    thingOffline(\"Could not set setpoint for thermostat (convertion failed)  \" + thermostatId);", "originalCommit": "f67dda391c2a8bdda78f96e956ffd920a925b4eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mjk3NzExMg==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r582977112", "bodyText": "Bindings should only log to error if something severe happened, like the detection of a bug in your code. This could be debug. See this link for a description of the log levels: https://www.openhab.org/docs/developer/guidelines.html#f-logging", "author": "fwolter", "createdAt": "2021-02-25T16:26:46Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,949 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.core.common.NamedThreadFactory;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication extends BaseThingHandler {\n+\n+    public QbusCommunication(Thing thing) {\n+        super(thing);\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+\n+    private @Nullable String ctd;\n+    private boolean ctdConnected;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    private final ExecutorService threadExecutor = Executors\n+            .newSingleThreadExecutor(new NamedThreadFactory(getThing().getUID().getAsString(), true));\n+\n+    private @Nullable QbusBridgeHandler bridgeCallBack;\n+\n+    public synchronized void startCommunication() throws IOException, InterruptedException {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        ctdConnected = false;\n+\n+        if (qEventsRunning) {\n+            throw new IOException(\"Previous listening thread is still active.\");\n+        }\n+\n+        if (handler == null) {\n+            throw new IOException(\"No Bridge handler initialised.\");\n+        }\n+\n+        InetAddress addr = InetAddress.getByName(handler.getAddress());\n+        Integer port = handler.getPort();\n+\n+        if (port != null) {\n+            Socket socket = new Socket(addr, port);\n+            qSocket = socket;\n+            qOut = new PrintWriter(socket.getOutputStream(), true);\n+            qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            logger.debug(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                    Thread.currentThread().getId());\n+        } else {\n+            return;\n+        }\n+\n+        setSN();\n+        getSN();\n+\n+        // Connect to Qbus server\n+        connect();\n+\n+        // If Qbus Client is connected then initialize and start listening for incoming commands, else put Bridge\n+        // offline\n+        if (ctdConnected) {\n+            initialize();\n+            threadExecutor.execute(() -> {\n+                try {\n+                    qEvents();\n+                } catch (IOException e) {\n+                    logger.debug(\"Could not start thread {} \", e.getMessage());\n+                }\n+            });\n+        } else {\n+            handler.bridgeOffline(\"No communication with Qbus client\");\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() throws IOException {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        PrintWriter qbusOut = this.qOut;\n+        if (qbusOut != null) {\n+            qbusOut.close();\n+        }\n+\n+        BufferedReader qbusIn = this.qIn;\n+        try {\n+            if (qbusIn != null) {\n+                qbusIn.close();\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"Error on closing reader {} \", e.getMessage());\n+        }\n+\n+        ctdConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     *\n+     * @throws InterruptedException\n+     * @throws IOException\n+     */\n+\n+    public synchronized void restartCommunication() throws InterruptedException, IOException {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        try {\n+            startCommunication();\n+        } catch (InterruptedException | IOException e) {\n+            String message = e.toString();\n+            logger.error(\"Could not start the communication with the server. {}\", message);", "originalCommit": "f67dda391c2a8bdda78f96e956ffd920a925b4eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mjk3ODIxOA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r582978218", "bodyText": "As sendMessage() already throws the InterruptedException, you could simply remove this catch clause.", "author": "fwolter", "createdAt": "2021-02-25T16:28:01Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,949 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.core.common.NamedThreadFactory;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication extends BaseThingHandler {\n+\n+    public QbusCommunication(Thing thing) {\n+        super(thing);\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+\n+    private @Nullable String ctd;\n+    private boolean ctdConnected;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    private final ExecutorService threadExecutor = Executors\n+            .newSingleThreadExecutor(new NamedThreadFactory(getThing().getUID().getAsString(), true));\n+\n+    private @Nullable QbusBridgeHandler bridgeCallBack;\n+\n+    public synchronized void startCommunication() throws IOException, InterruptedException {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        ctdConnected = false;\n+\n+        if (qEventsRunning) {\n+            throw new IOException(\"Previous listening thread is still active.\");\n+        }\n+\n+        if (handler == null) {\n+            throw new IOException(\"No Bridge handler initialised.\");\n+        }\n+\n+        InetAddress addr = InetAddress.getByName(handler.getAddress());\n+        Integer port = handler.getPort();\n+\n+        if (port != null) {\n+            Socket socket = new Socket(addr, port);\n+            qSocket = socket;\n+            qOut = new PrintWriter(socket.getOutputStream(), true);\n+            qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            logger.debug(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                    Thread.currentThread().getId());\n+        } else {\n+            return;\n+        }\n+\n+        setSN();\n+        getSN();\n+\n+        // Connect to Qbus server\n+        connect();\n+\n+        // If Qbus Client is connected then initialize and start listening for incoming commands, else put Bridge\n+        // offline\n+        if (ctdConnected) {\n+            initialize();\n+            threadExecutor.execute(() -> {\n+                try {\n+                    qEvents();\n+                } catch (IOException e) {\n+                    logger.debug(\"Could not start thread {} \", e.getMessage());\n+                }\n+            });\n+        } else {\n+            handler.bridgeOffline(\"No communication with Qbus client\");\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() throws IOException {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        PrintWriter qbusOut = this.qOut;\n+        if (qbusOut != null) {\n+            qbusOut.close();\n+        }\n+\n+        BufferedReader qbusIn = this.qIn;\n+        try {\n+            if (qbusIn != null) {\n+                qbusIn.close();\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"Error on closing reader {} \", e.getMessage());\n+        }\n+\n+        ctdConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     *\n+     * @throws InterruptedException\n+     * @throws IOException\n+     */\n+\n+    public synchronized void restartCommunication() throws InterruptedException, IOException {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        try {\n+            startCommunication();\n+        } catch (InterruptedException | IOException e) {\n+            String message = e.toString();\n+            logger.error(\"Could not start the communication with the server. {}\", message);\n+        }\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return ctdConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     * @return\n+     * @throws IOException\n+     *\n+     */\n+    private void qEvents() throws IOException {\n+        String qMessage;\n+\n+        listenerStopped = false;\n+        qEventsRunning = true;\n+\n+        BufferedReader reader = this.qIn;\n+\n+        if (reader == null) {\n+            throw new IOException(\"Bufferreader for incoming messages not initialized.\");\n+        }\n+\n+        while (!Thread.currentThread().isInterrupted() && ((qMessage = reader.readLine()) != null)) {\n+            readMessage(qMessage);\n+        }\n+\n+        if (!listenerStopped) {\n+            qEventsRunning = false;\n+\n+            QbusBridgeHandler handler = bridgeCallBack;\n+\n+            if (handler != null) {\n+                ctdConnected = false;\n+                handler.bridgeOffline(\"No communication with Qbus server\");\n+            }\n+        }\n+\n+        qEventsRunning = false;\n+        logger.trace(\"Event listener thread stopped on thread {}\", Thread.currentThread().getId());\n+    };\n+\n+    /**\n+     * Called by other methods to send json data to Qbus.\n+     *\n+     * @param qMessage\n+     * @throws InterruptedException\n+     */\n+    synchronized void sendMessage(Object qMessage) throws InterruptedException {\n+        PrintWriter writer = qOut;\n+        String json = gsonOut.toJson(qMessage);\n+        QbusBridgeHandler handler = bridgeCallBack;\n+\n+        if (writer != null) {\n+            writer.println(json);\n+            // Delay after sending data to improve scene execution\n+            TimeUnit.MILLISECONDS.sleep(250);\n+\n+        }\n+        if ((writer == null) || (writer.checkError())) {\n+            logger.warn(\"Error sending message, trying to restart communication\");\n+            try {\n+                restartCommunication();\n+            } catch (InterruptedException e) {\n+                if (handler != null) {\n+                    handler.bridgeOffline(\"No communication with Qbus server. \" + e.toString());\n+                }", "originalCommit": "f67dda391c2a8bdda78f96e956ffd920a925b4eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mjk3ODg2OA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r582978868", "bodyText": "See above. Logging to error. Please check all.", "author": "fwolter", "createdAt": "2021-02-25T16:28:48Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,949 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.core.common.NamedThreadFactory;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication extends BaseThingHandler {\n+\n+    public QbusCommunication(Thing thing) {\n+        super(thing);\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+\n+    private @Nullable String ctd;\n+    private boolean ctdConnected;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    private final ExecutorService threadExecutor = Executors\n+            .newSingleThreadExecutor(new NamedThreadFactory(getThing().getUID().getAsString(), true));\n+\n+    private @Nullable QbusBridgeHandler bridgeCallBack;\n+\n+    public synchronized void startCommunication() throws IOException, InterruptedException {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        ctdConnected = false;\n+\n+        if (qEventsRunning) {\n+            throw new IOException(\"Previous listening thread is still active.\");\n+        }\n+\n+        if (handler == null) {\n+            throw new IOException(\"No Bridge handler initialised.\");\n+        }\n+\n+        InetAddress addr = InetAddress.getByName(handler.getAddress());\n+        Integer port = handler.getPort();\n+\n+        if (port != null) {\n+            Socket socket = new Socket(addr, port);\n+            qSocket = socket;\n+            qOut = new PrintWriter(socket.getOutputStream(), true);\n+            qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            logger.debug(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                    Thread.currentThread().getId());\n+        } else {\n+            return;\n+        }\n+\n+        setSN();\n+        getSN();\n+\n+        // Connect to Qbus server\n+        connect();\n+\n+        // If Qbus Client is connected then initialize and start listening for incoming commands, else put Bridge\n+        // offline\n+        if (ctdConnected) {\n+            initialize();\n+            threadExecutor.execute(() -> {\n+                try {\n+                    qEvents();\n+                } catch (IOException e) {\n+                    logger.debug(\"Could not start thread {} \", e.getMessage());\n+                }\n+            });\n+        } else {\n+            handler.bridgeOffline(\"No communication with Qbus client\");\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() throws IOException {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        PrintWriter qbusOut = this.qOut;\n+        if (qbusOut != null) {\n+            qbusOut.close();\n+        }\n+\n+        BufferedReader qbusIn = this.qIn;\n+        try {\n+            if (qbusIn != null) {\n+                qbusIn.close();\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"Error on closing reader {} \", e.getMessage());\n+        }\n+\n+        ctdConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     *\n+     * @throws InterruptedException\n+     * @throws IOException\n+     */\n+\n+    public synchronized void restartCommunication() throws InterruptedException, IOException {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        try {\n+            startCommunication();\n+        } catch (InterruptedException | IOException e) {\n+            String message = e.toString();\n+            logger.error(\"Could not start the communication with the server. {}\", message);\n+        }\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return ctdConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     * @return\n+     * @throws IOException\n+     *\n+     */\n+    private void qEvents() throws IOException {\n+        String qMessage;\n+\n+        listenerStopped = false;\n+        qEventsRunning = true;\n+\n+        BufferedReader reader = this.qIn;\n+\n+        if (reader == null) {\n+            throw new IOException(\"Bufferreader for incoming messages not initialized.\");\n+        }\n+\n+        while (!Thread.currentThread().isInterrupted() && ((qMessage = reader.readLine()) != null)) {\n+            readMessage(qMessage);\n+        }\n+\n+        if (!listenerStopped) {\n+            qEventsRunning = false;\n+\n+            QbusBridgeHandler handler = bridgeCallBack;\n+\n+            if (handler != null) {\n+                ctdConnected = false;\n+                handler.bridgeOffline(\"No communication with Qbus server\");\n+            }\n+        }\n+\n+        qEventsRunning = false;\n+        logger.trace(\"Event listener thread stopped on thread {}\", Thread.currentThread().getId());\n+    };\n+\n+    /**\n+     * Called by other methods to send json data to Qbus.\n+     *\n+     * @param qMessage\n+     * @throws InterruptedException\n+     */\n+    synchronized void sendMessage(Object qMessage) throws InterruptedException {\n+        PrintWriter writer = qOut;\n+        String json = gsonOut.toJson(qMessage);\n+        QbusBridgeHandler handler = bridgeCallBack;\n+\n+        if (writer != null) {\n+            writer.println(json);\n+            // Delay after sending data to improve scene execution\n+            TimeUnit.MILLISECONDS.sleep(250);\n+\n+        }\n+        if ((writer == null) || (writer.checkError())) {\n+            logger.warn(\"Error sending message, trying to restart communication\");\n+            try {\n+                restartCommunication();\n+            } catch (InterruptedException e) {\n+                if (handler != null) {\n+                    handler.bridgeOffline(\"No communication with Qbus server. \" + e.toString());\n+                }\n+            } catch (IOException e) {\n+                if (handler != null) {\n+                    handler.bridgeOffline(\"No communication with Qbus server. \" + e.toString());\n+                }\n+            }\n+            // retry sending after restart\n+            writer = qOut;\n+            if (writer != null) {\n+                writer.println(json);\n+            }\n+            if ((writer == null) || (writer.checkError())) {\n+                logger.warn(\"Error resending message\");\n+\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Called by other methods to Qbus server and read response\n+     */\n+    private void sendAndReadMessage(String command) throws IOException, InterruptedException {\n+        String snr = getSN();\n+        if (snr != null) {\n+            QbusMessageCmd qCmd = new QbusMessageCmd(snr, command);\n+\n+            sendMessage(qCmd);\n+\n+            BufferedReader reader = qIn;\n+            if (reader == null) {\n+                throw new IOException(\"Cannot read from socket, reader not connected.\");\n+            }\n+            readMessage(reader.readLine());\n+        } else {\n+            QbusBridgeHandler handler = bridgeCallBack;\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No serial nr defined\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method that interprets all feedback from Qbus Server application and calls appropriate handling methods.\n+     *\n+     * @param qMessage message read from Qbus.\n+     */\n+    private void readMessage(String qMessage) {\n+        String cmd = \"\";\n+        String ctd = \"\";\n+        String sn = null;\n+        QbusMessageBase qMessageGson;\n+\n+        qMessageGson = gsonIn.fromJson(qMessage, QbusMessageBase.class);\n+        if (qMessageGson != null) {\n+            ctd = qMessageGson.getSn();\n+            cmd = qMessageGson.getCmd();\n+        }\n+\n+        QbusBridgeHandler handler = bridgeCallBack;\n+\n+        if (handler != null) {\n+            sn = handler.getSn();\n+        }\n+\n+        if (sn != null && ctd != null) {\n+            try {\n+                if (Integer.parseInt(sn) == Integer.parseInt(ctd) && qMessageGson != null) {\n+                    // Get the compatible outputs from the Qbus server\n+                    if (\"returnBistabiel\".equals(cmd)) {\n+                        cmdListBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"returnDimmer\".equals(cmd)) {\n+                        cmdListDimmers(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnThermostat\").equals(cmd)) {\n+                        cmdListThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnScene\").equals(cmd)) {\n+                        cmdListScenes(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnCo2\").equals(cmd)) {\n+                        cmdListCo2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnRol02p\").equals(cmd)) {\n+                        cmdListRol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnSlat\").equals(cmd)) {\n+                        cmdListRolSlats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incoming commands from Qbus Client to openHAB (event)\n+                    else if (\"updateBistabiel\".equals(cmd)) {\n+                        updateBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateDimmer\".equals(cmd)) {\n+                        updateDimmer(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateThermostat\".equals(cmd)) {\n+                        updateThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateCo2\".equals(cmd)) {\n+                        updateCO2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02p\".equals(cmd)) {\n+                        updateRol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02pSlat\".equals(cmd)) {\n+                        updateRolSlats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incomming commands from Qbus server to verify the client connection\n+                    else if (\"disconnect\".equals(cmd)) {\n+                        eventDisconnect();\n+                    } else if (\"notConnected\".equals(cmd)) {\n+                        noConnection();\n+                    } else if (\"connected\".equals(cmd)) {\n+                        connection();\n+                    }\n+                }\n+\n+            } catch (JsonParseException e) {\n+                logger.warn(\"Not acted on unsupported json {}\", qMessage);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * After setting up the communication with the Qbus Server, send all initialization messages.\n+     * <p>\n+     * First send connect to connect with the Qbus Server application\n+     * Get request for Bistabiel/Timers/Intervals/Mono outputs\n+     * Get request for the Scenes\n+     * Get request for Dimmers 1T and 2T\n+     * Get request for Shutters\n+     * Get request for Thermostats\n+     * Get request for CO2\n+     */\n+    @Override\n+    public void initialize() {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+\n+        if (bridgeCallBack != null) {\n+            if (ctdConnected) {\n+                try {\n+                    sendAndReadMessage(\"getBistabiel\");\n+                    sendAndReadMessage(\"getScene\");\n+                    sendAndReadMessage(\"getDimmer\");\n+                    sendAndReadMessage(\"getRol02p\");\n+                    sendAndReadMessage(\"getRol02pSlat\");\n+                    sendAndReadMessage(\"getThermostat\");\n+                    sendAndReadMessage(\"getCo2\");\n+                } catch (IOException e) {\n+                    String message = e.toString();\n+                    if (handler != null) {\n+                        handler.bridgeOffline(\"Could not request outputs from client. {}\" + message);\n+                    } else {\n+                        logger.error(\"Could not request outputs from client. {}\", message);\n+                    }\n+                } catch (InterruptedException e) {\n+                    String message = e.toString();\n+                    if (handler != null) {\n+                        handler.bridgeOffline(\"Could not request outputs from client. {}\" + message);\n+                    } else {\n+                        logger.error(\"Could not request outputs from client. {}\", message);", "originalCommit": "f67dda391c2a8bdda78f96e956ffd920a925b4eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mjk4MDM4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r582980383", "bodyText": "Please remove this empty line.", "author": "fwolter", "createdAt": "2021-02-25T16:30:34Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,949 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.core.common.NamedThreadFactory;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication extends BaseThingHandler {\n+\n+    public QbusCommunication(Thing thing) {\n+        super(thing);\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+\n+    private @Nullable String ctd;\n+    private boolean ctdConnected;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    private final ExecutorService threadExecutor = Executors\n+            .newSingleThreadExecutor(new NamedThreadFactory(getThing().getUID().getAsString(), true));\n+\n+    private @Nullable QbusBridgeHandler bridgeCallBack;\n+\n+    public synchronized void startCommunication() throws IOException, InterruptedException {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        ctdConnected = false;\n+\n+        if (qEventsRunning) {\n+            throw new IOException(\"Previous listening thread is still active.\");\n+        }\n+\n+        if (handler == null) {\n+            throw new IOException(\"No Bridge handler initialised.\");\n+        }\n+\n+        InetAddress addr = InetAddress.getByName(handler.getAddress());\n+        Integer port = handler.getPort();\n+\n+        if (port != null) {\n+            Socket socket = new Socket(addr, port);\n+            qSocket = socket;\n+            qOut = new PrintWriter(socket.getOutputStream(), true);\n+            qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            logger.debug(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                    Thread.currentThread().getId());\n+        } else {\n+            return;\n+        }\n+\n+        setSN();\n+        getSN();\n+\n+        // Connect to Qbus server\n+        connect();\n+\n+        // If Qbus Client is connected then initialize and start listening for incoming commands, else put Bridge\n+        // offline\n+        if (ctdConnected) {\n+            initialize();\n+            threadExecutor.execute(() -> {\n+                try {\n+                    qEvents();\n+                } catch (IOException e) {\n+                    logger.debug(\"Could not start thread {} \", e.getMessage());\n+                }\n+            });\n+        } else {\n+            handler.bridgeOffline(\"No communication with Qbus client\");\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() throws IOException {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        PrintWriter qbusOut = this.qOut;\n+        if (qbusOut != null) {\n+            qbusOut.close();\n+        }\n+\n+        BufferedReader qbusIn = this.qIn;\n+        try {\n+            if (qbusIn != null) {\n+                qbusIn.close();\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"Error on closing reader {} \", e.getMessage());\n+        }\n+\n+        ctdConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     *\n+     * @throws InterruptedException\n+     * @throws IOException\n+     */\n+\n+    public synchronized void restartCommunication() throws InterruptedException, IOException {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        try {\n+            startCommunication();\n+        } catch (InterruptedException | IOException e) {\n+            String message = e.toString();\n+            logger.error(\"Could not start the communication with the server. {}\", message);\n+        }\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return ctdConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     * @return\n+     * @throws IOException\n+     *\n+     */\n+    private void qEvents() throws IOException {\n+        String qMessage;\n+\n+        listenerStopped = false;\n+        qEventsRunning = true;\n+\n+        BufferedReader reader = this.qIn;\n+\n+        if (reader == null) {\n+            throw new IOException(\"Bufferreader for incoming messages not initialized.\");\n+        }\n+\n+        while (!Thread.currentThread().isInterrupted() && ((qMessage = reader.readLine()) != null)) {\n+            readMessage(qMessage);\n+        }\n+\n+        if (!listenerStopped) {\n+            qEventsRunning = false;\n+\n+            QbusBridgeHandler handler = bridgeCallBack;\n+\n+            if (handler != null) {\n+                ctdConnected = false;\n+                handler.bridgeOffline(\"No communication with Qbus server\");\n+            }\n+        }\n+\n+        qEventsRunning = false;\n+        logger.trace(\"Event listener thread stopped on thread {}\", Thread.currentThread().getId());\n+    };\n+\n+    /**\n+     * Called by other methods to send json data to Qbus.\n+     *\n+     * @param qMessage\n+     * @throws InterruptedException\n+     */\n+    synchronized void sendMessage(Object qMessage) throws InterruptedException {\n+        PrintWriter writer = qOut;\n+        String json = gsonOut.toJson(qMessage);\n+        QbusBridgeHandler handler = bridgeCallBack;\n+\n+        if (writer != null) {\n+            writer.println(json);\n+            // Delay after sending data to improve scene execution\n+            TimeUnit.MILLISECONDS.sleep(250);\n+\n+        }\n+        if ((writer == null) || (writer.checkError())) {\n+            logger.warn(\"Error sending message, trying to restart communication\");\n+            try {\n+                restartCommunication();\n+            } catch (InterruptedException e) {\n+                if (handler != null) {\n+                    handler.bridgeOffline(\"No communication with Qbus server. \" + e.toString());\n+                }\n+            } catch (IOException e) {\n+                if (handler != null) {\n+                    handler.bridgeOffline(\"No communication with Qbus server. \" + e.toString());\n+                }\n+            }\n+            // retry sending after restart\n+            writer = qOut;\n+            if (writer != null) {\n+                writer.println(json);\n+            }\n+            if ((writer == null) || (writer.checkError())) {\n+                logger.warn(\"Error resending message\");\n+\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Called by other methods to Qbus server and read response\n+     */\n+    private void sendAndReadMessage(String command) throws IOException, InterruptedException {\n+        String snr = getSN();\n+        if (snr != null) {\n+            QbusMessageCmd qCmd = new QbusMessageCmd(snr, command);\n+\n+            sendMessage(qCmd);\n+\n+            BufferedReader reader = qIn;\n+            if (reader == null) {\n+                throw new IOException(\"Cannot read from socket, reader not connected.\");\n+            }\n+            readMessage(reader.readLine());\n+        } else {\n+            QbusBridgeHandler handler = bridgeCallBack;\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No serial nr defined\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method that interprets all feedback from Qbus Server application and calls appropriate handling methods.\n+     *\n+     * @param qMessage message read from Qbus.\n+     */\n+    private void readMessage(String qMessage) {\n+        String cmd = \"\";\n+        String ctd = \"\";\n+        String sn = null;\n+        QbusMessageBase qMessageGson;\n+\n+        qMessageGson = gsonIn.fromJson(qMessage, QbusMessageBase.class);\n+        if (qMessageGson != null) {\n+            ctd = qMessageGson.getSn();\n+            cmd = qMessageGson.getCmd();\n+        }\n+\n+        QbusBridgeHandler handler = bridgeCallBack;\n+\n+        if (handler != null) {\n+            sn = handler.getSn();\n+        }\n+\n+        if (sn != null && ctd != null) {\n+            try {\n+                if (Integer.parseInt(sn) == Integer.parseInt(ctd) && qMessageGson != null) {\n+                    // Get the compatible outputs from the Qbus server\n+                    if (\"returnBistabiel\".equals(cmd)) {\n+                        cmdListBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"returnDimmer\".equals(cmd)) {\n+                        cmdListDimmers(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnThermostat\").equals(cmd)) {\n+                        cmdListThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnScene\").equals(cmd)) {\n+                        cmdListScenes(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnCo2\").equals(cmd)) {\n+                        cmdListCo2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnRol02p\").equals(cmd)) {\n+                        cmdListRol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnSlat\").equals(cmd)) {\n+                        cmdListRolSlats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incoming commands from Qbus Client to openHAB (event)\n+                    else if (\"updateBistabiel\".equals(cmd)) {\n+                        updateBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateDimmer\".equals(cmd)) {\n+                        updateDimmer(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateThermostat\".equals(cmd)) {\n+                        updateThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateCo2\".equals(cmd)) {\n+                        updateCO2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02p\".equals(cmd)) {\n+                        updateRol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02pSlat\".equals(cmd)) {\n+                        updateRolSlats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incomming commands from Qbus server to verify the client connection\n+                    else if (\"disconnect\".equals(cmd)) {\n+                        eventDisconnect();\n+                    } else if (\"notConnected\".equals(cmd)) {\n+                        noConnection();\n+                    } else if (\"connected\".equals(cmd)) {\n+                        connection();\n+                    }\n+                }\n+\n+            } catch (JsonParseException e) {\n+                logger.warn(\"Not acted on unsupported json {}\", qMessage);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * After setting up the communication with the Qbus Server, send all initialization messages.\n+     * <p>\n+     * First send connect to connect with the Qbus Server application\n+     * Get request for Bistabiel/Timers/Intervals/Mono outputs\n+     * Get request for the Scenes\n+     * Get request for Dimmers 1T and 2T\n+     * Get request for Shutters\n+     * Get request for Thermostats\n+     * Get request for CO2\n+     */\n+    @Override\n+    public void initialize() {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+\n+        if (bridgeCallBack != null) {\n+            if (ctdConnected) {\n+                try {\n+                    sendAndReadMessage(\"getBistabiel\");\n+                    sendAndReadMessage(\"getScene\");\n+                    sendAndReadMessage(\"getDimmer\");\n+                    sendAndReadMessage(\"getRol02p\");\n+                    sendAndReadMessage(\"getRol02pSlat\");\n+                    sendAndReadMessage(\"getThermostat\");\n+                    sendAndReadMessage(\"getCo2\");\n+                } catch (IOException e) {\n+                    String message = e.toString();\n+                    if (handler != null) {\n+                        handler.bridgeOffline(\"Could not request outputs from client. {}\" + message);\n+                    } else {\n+                        logger.error(\"Could not request outputs from client. {}\", message);\n+                    }\n+                } catch (InterruptedException e) {\n+                    String message = e.toString();\n+                    if (handler != null) {\n+                        handler.bridgeOffline(\"Could not request outputs from client. {}\" + message);\n+                    } else {\n+                        logger.error(\"Could not request outputs from client. {}\", message);\n+                    }\n+                }\n+\n+            } else {\n+                ctdConnected = false;\n+\n+                if (handler != null) {\n+                    handler.bridgeOffline(\"No communication with Qbus client\");\n+                }\n+\n+                return;\n+            }\n+        } else\n+\n+        {", "originalCommit": "f67dda391c2a8bdda78f96e956ffd920a925b4eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "34536bd3cbeeeb8e309e5e68169682f2aea3765a", "url": "https://github.com/openhab/openhab-addons/commit/34536bd3cbeeeb8e309e5e68169682f2aea3765a", "message": "Updated requested changes\n\nUpdated changes reqeusted by fwolter on 25/02/2021\n\nSigned-off-by: Koen Schockaert <ks@qbus.be>", "committedDate": "2021-02-25T17:46:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTg5ODU0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r585898545", "bodyText": "Does this make any sense?", "author": "fwolter", "createdAt": "2021-03-02T20:48:52Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusRolHandler.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.*;\n+import static org.openhab.core.library.types.UpDownType.DOWN;\n+import static org.openhab.core.types.RefreshType.REFRESH;\n+\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.binding.qbus.internal.protocol.QbusRol;\n+import org.openhab.core.library.types.IncreaseDecreaseType;\n+import org.openhab.core.library.types.PercentType;\n+import org.openhab.core.library.types.UpDownType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link QbusRolHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusRolHandler extends QbusGlobalHandler {\n+\n+    protected @Nullable QbusThingsConfig config;\n+\n+    private @Nullable Integer rolId;\n+\n+    private @Nullable String sn;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    public QbusRolHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /**\n+     * Main initialization\n+     */\n+    @Override\n+    public void initialize() {\n+        setConfig();\n+        rolId = getId();\n+\n+        QbusCommunication qComm = getCommunication(\"Screen/Store\", rolId);\n+        if (qComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+\n+        QbusBridgeHandler qBridgeHandler = getBridgeHandler(\"Screen/Store\", rolId);\n+        if (qBridgeHandler == null) {\n+            return;\n+        }\n+\n+        setSN();\n+\n+        Map<Integer, QbusRol> rolComm = qComm.getRol();\n+\n+        if (rolComm != null) {\n+            QbusRol qRol = rolComm.get(rolId);\n+            if (qRol != null) {\n+                qRol.setThingHandler(this);\n+                handleStateUpdate(qRol);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Error while initializing the thing.\");\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Error while initializing the thing.\");\n+        }\n+    }\n+\n+    /**\n+     * Returns the serial number of the controller\n+     *\n+     * @return the serial nr\n+     */\n+    public @Nullable String getSN() {\n+        return this.sn;\n+    }\n+\n+    /**\n+     * Sets the serial number of the controller\n+     */\n+    public void setSN() {\n+        QbusBridgeHandler qBridgeHandler = getBridgeHandler(\"Screen/Store\", rolId);\n+        if (qBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+        this.sn = qBridgeHandler.getSn();\n+    }\n+\n+    /**\n+     * Handle the status update from the thing\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        QbusCommunication qComm = getCommunication(\"Screen/Store\", rolId);\n+\n+        if (qComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Bridge communication not initialized when trying to execute command for Screen/Store \" + rolId);\n+            return;\n+        }\n+\n+        Map<Integer, QbusRol> rolComm = qComm.getRol();\n+\n+        if (rolComm != null) {\n+            QbusRol qRol = rolComm.get(rolId);\n+            if (qRol == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Bridge communication not initialized when trying to execute command for ROL \" + rolId);\n+                return;\n+            } else {\n+                scheduler.submit(() -> {\n+                    if (!qComm.communicationActive()) {\n+                        restartCommunication(qComm, \"Screen/Store\", rolId);\n+                    }\n+\n+                    if (qComm.communicationActive()) {\n+                        if (command == REFRESH) {\n+                            handleStateUpdate(qRol);\n+                            return;\n+                        }\n+\n+                        switch (channelUID.getId()) {\n+                            case CHANNEL_ROLLERSHUTTER:\n+                                handleScreenposCommand(qRol, command);\n+                                break;\n+\n+                            case CHANNEL_SLATS:\n+                                handleSlatsposCommand(qRol, command);\n+                                break;\n+                        }\n+                    }\n+                });\n+            }\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param message\n+     */\n+    public void thingOffline(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, message);\n+    }\n+\n+    /**\n+     * Executes the command for screen up/down position\n+     */\n+    private void handleScreenposCommand(QbusRol qRol, Command command) {\n+        String snr = getSN();\n+        if (command instanceof UpDownType) {\n+            UpDownType upDown = (UpDownType) command;\n+            if (upDown == DOWN) {\n+                if (snr != null) {\n+                    qRol.execute(0, snr);\n+                } else {\n+                    thingOffline(\"No serial number configured for  \" + rolId);\n+                }\n+            } else {\n+                if (snr != null) {\n+                    qRol.execute(100, snr);\n+                } else {\n+                    thingOffline(\"No serial number configured for  \" + rolId);\n+                }\n+            }\n+        } else if (command instanceof IncreaseDecreaseType) {\n+            IncreaseDecreaseType inc = (IncreaseDecreaseType) command;\n+            int stepValue = ((Number) this.getConfig().get(CONFIG_STEP_VALUE)).intValue();\n+            Integer currentValue = qRol.getState();\n+            int newValue;\n+            int sendValue;\n+            if (currentValue != null) {\n+                if (inc == IncreaseDecreaseType.INCREASE) {\n+                    newValue = currentValue + stepValue;\n+                    // round down to step multiple\n+                    newValue = newValue - newValue % stepValue;\n+                    sendValue = newValue > 100 ? 100 : newValue;\n+                    if (snr != null) {\n+                        qRol.execute(sendValue, snr);\n+                    } else {\n+                        thingOffline(\"No serial number configured for  \" + rolId);\n+                    }\n+                } else {\n+                    newValue = currentValue - stepValue;\n+                    // round up to step multiple\n+                    newValue = newValue + newValue % stepValue;\n+                    sendValue = newValue > 100 ? 100 : newValue;\n+                    if (snr != null) {\n+                        qRol.execute(sendValue, snr);\n+                    } else {\n+                        thingOffline(\"No serial number configured for  \" + rolId);\n+                    }\n+                }\n+            }\n+        } else if (command instanceof PercentType) {\n+            PercentType p = (PercentType) command;\n+            int pp = p.intValue();\n+            if (p == PercentType.ZERO) {\n+                if (snr != null) {\n+                    qRol.execute(0, snr);\n+                } else {\n+                    thingOffline(\"No serial number configured for  \" + rolId);\n+                }\n+            } else {\n+                if (snr != null) {\n+                    qRol.execute(pp, snr);\n+                } else {\n+                    thingOffline(\"No serial number configured for  \" + rolId);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Executes the command for screen slats position\n+     */\n+    private void handleSlatsposCommand(QbusRol qRol, Command command) {\n+        String snr = getSN();\n+        if (command instanceof UpDownType) {\n+            if (command == DOWN) {\n+                if (snr != null) {\n+                    qRol.executeSlats(0, snr);\n+                } else {\n+                    thingOffline(\"No serial number configured for  \" + rolId);\n+                }\n+            } else {\n+                if (snr != null) {\n+                    qRol.executeSlats(100, snr);\n+                } else {\n+                    thingOffline(\"No serial number configured for  \" + rolId);\n+                }\n+            }\n+        } else if (command instanceof IncreaseDecreaseType) {\n+            int stepValue = ((Number) this.getConfig().get(CONFIG_STEP_VALUE)).intValue();\n+            Integer currentValue = qRol.getState();\n+            int newValue;\n+            int sendValue;\n+            if (currentValue != null) {\n+                if (command == IncreaseDecreaseType.INCREASE) {\n+                    newValue = currentValue + stepValue;\n+                    // round down to step multiple\n+                    newValue = newValue - newValue % stepValue;\n+                    sendValue = newValue > 100 ? 100 : newValue;\n+                    if (snr != null) {\n+                        qRol.executeSlats(sendValue, snr);\n+                    } else {\n+                        thingOffline(\"No serial number configured for  \" + rolId);\n+                    }\n+                } else {\n+                    newValue = currentValue - stepValue;\n+                    // round up to step multiple\n+                    newValue = newValue + newValue % stepValue;\n+                    sendValue = newValue > 100 ? 100 : newValue;\n+                    if (snr != null) {\n+                        qRol.executeSlats(sendValue, snr);\n+                    } else {\n+                        thingOffline(\"No serial number configured for  \" + rolId);\n+                    }\n+                }\n+            }\n+        } else if (command instanceof PercentType) {\n+            int percentToInt = ((PercentType) command).intValue();\n+            if (command == PercentType.ZERO) {\n+                if (snr != null) {\n+                    qRol.executeSlats(0, snr);\n+                } else {\n+                    thingOffline(\"No serial number configured for  \" + rolId);\n+                }\n+            } else {\n+                if (snr != null) {\n+                    qRol.executeSlats(percentToInt, snr);\n+                } else {\n+                    thingOffline(\"No serial number configured for  \" + rolId);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method to update state of channel, called from Qbus Screen/Store.\n+     */\n+    public void handleStateUpdate(QbusRol qRol) {\n+        Integer rolState = qRol.getState();\n+        Integer slatState = qRol.getStateSlats();\n+\n+        if (rolState != null) {\n+            updateState(CHANNEL_ROLLERSHUTTER, new PercentType(rolState));\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        if (slatState != null) {\n+            updateState(CHANNEL_SLATS, new PercentType(slatState));\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+    }\n+\n+    /**\n+     * Read the configuration\n+     */\n+    protected synchronized void setConfig() {\n+        final ScheduledFuture<?> localPollingJob = this.pollingJob;\n+\n+        if (localPollingJob != null) {\n+            localPollingJob.cancel(true);\n+        }\n+\n+        if (localPollingJob == null || localPollingJob.isCancelled()) {\n+            this.config = getConfig().as(QbusThingsConfig.class);\n+        }\n+        this.config = getConfig().as(QbusThingsConfig.class);", "originalCommit": "34536bd3cbeeeb8e309e5e68169682f2aea3765a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTg5OTA1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r585899053", "bodyText": "Same here.", "author": "fwolter", "createdAt": "2021-03-02T20:49:40Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/handler/QbusSceneHandler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.handler;\n+\n+import static org.openhab.binding.qbus.internal.QbusBindingConstants.CHANNEL_SCENE;\n+\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.binding.qbus.internal.protocol.QbusScene;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.types.Command;\n+\n+/**\n+ * The {@link QbusSceneHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusSceneHandler extends QbusGlobalHandler {\n+\n+    protected @Nullable QbusThingsConfig config;\n+\n+    private @Nullable Integer sceneId;\n+\n+    private @Nullable String sn;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    public QbusSceneHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    /**\n+     * Main initialization\n+     */\n+    @Override\n+    public void initialize() {\n+        setConfig();\n+        sceneId = getId();\n+\n+        QbusCommunication qComm = getCommunication(\"Scene\", sceneId);\n+        if (qComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+\n+        QbusBridgeHandler qBridgeHandler = getBridgeHandler(\"Scene\", sceneId);\n+        if (qBridgeHandler == null) {\n+            return;\n+        }\n+\n+        setSN();\n+\n+        Map<Integer, QbusScene> sceneComm = qComm.getScene();\n+\n+        if (sceneComm != null) {\n+            QbusScene qScene = sceneComm.get(sceneId);\n+            if (qScene != null) {\n+                qScene.setThingHandler(this);\n+                updateStatus(ThingStatus.ONLINE);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Error while initializing the thing.\");\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Error while initializing the thing.\");\n+        }\n+    }\n+\n+    /**\n+     * Returns the serial number of the controller\n+     *\n+     * @return the serial nr\n+     */\n+    public @Nullable String getSN() {\n+        return this.sn;\n+    }\n+\n+    /**\n+     * Sets the serial number of the controller\n+     */\n+    public void setSN() {\n+        QbusBridgeHandler qBridgeHandler = getBridgeHandler(\"Scene\", sceneId);\n+        if (qBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No communication with Qbus Bridge!\");\n+            return;\n+        }\n+        this.sn = qBridgeHandler.getSn();\n+    }\n+\n+    /**\n+     * Handle the status update from the thing\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        QbusCommunication qComm = getCommunication(\"Scene\", sceneId);\n+\n+        if (qComm == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Bridge communication not initialized when trying to execute command for Scene \" + sceneId);\n+            return;\n+        }\n+\n+        Map<Integer, QbusScene> sceneComm = qComm.getScene();\n+\n+        if (sceneComm != null) {\n+            QbusScene qScene = sceneComm.get(sceneId);\n+            if (qScene == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Bridge communication not initialized when trying to execute command for Scene \" + sceneId);\n+                return;\n+            } else {\n+                scheduler.submit(() -> {\n+                    if (!qComm.communicationActive()) {\n+                        restartCommunication(qComm, \"Scene\", sceneId);\n+                    }\n+\n+                    if (qComm.communicationActive()) {\n+                        switch (channelUID.getId()) {\n+                            case CHANNEL_SCENE:\n+                                handleSwitchCommand(qScene, channelUID, command);\n+                                break;\n+                        }\n+                    }\n+                });\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method to update state of channel, called from Qbus Scene.\n+     */\n+    public void handleStateUpdate(QbusScene qScene) {\n+        Integer sceneState = qScene.getState();\n+        if (sceneState != null) {\n+            updateState(CHANNEL_SCENE, (sceneState == 0) ? OnOffType.OFF : OnOffType.ON);\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @param message\n+     */\n+    public void thingOffline(String message) {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, message);\n+    }\n+\n+    /**\n+     * Executes the scene command\n+     */\n+    void handleSwitchCommand(QbusScene qScene, ChannelUID channelUID, Command command) {\n+        String snr = getSN();\n+        if (command instanceof OnOffType) {\n+            if (command == OnOffType.OFF) {\n+                if (snr != null) {\n+                    qScene.execute(0, snr);\n+                } else {\n+                    thingOffline(\"No serial number configured for  \" + sceneId);\n+                }\n+            } else {\n+                if (snr != null) {\n+                    qScene.execute(100, snr);\n+                } else {\n+                    thingOffline(\"No serial number configured for  \" + sceneId);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Read the configuration\n+     */\n+    protected synchronized void setConfig() {\n+        final ScheduledFuture<?> localPollingJob = this.pollingJob;\n+\n+        if (localPollingJob != null) {\n+            localPollingJob.cancel(true);\n+        }\n+\n+        if (localPollingJob == null || localPollingJob.isCancelled()) {\n+            this.config = getConfig().as(QbusThingsConfig.class);\n+        }\n+        this.config = getConfig().as(QbusThingsConfig.class);", "originalCommit": "34536bd3cbeeeb8e309e5e68169682f2aea3765a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTkwMTY3MA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r585901670", "bodyText": "initialize() must return fast. As this will call some network code, you need to execute it asynchronously e.g. via scheduler.submit().", "author": "fwolter", "createdAt": "2021-03-02T20:54:07Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,943 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.core.common.NamedThreadFactory;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * systems:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status information from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication extends BaseThingHandler {\n+\n+    public QbusCommunication(Thing thing) {\n+        super(thing);\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusCommunication.class);\n+\n+    private @Nullable Socket qSocket;\n+    private @Nullable PrintWriter qOut;\n+    private @Nullable BufferedReader qIn;\n+\n+    private boolean listenerStopped;\n+    private boolean qEventsRunning;\n+\n+    private Gson gsonOut = new Gson();\n+    private Gson gsonIn;\n+\n+    private @Nullable String ctd;\n+    private boolean ctdConnected;\n+\n+    private final Map<Integer, QbusBistabiel> bistabiel = new HashMap<>();\n+    private final Map<Integer, QbusScene> scene = new HashMap<>();\n+    private final Map<Integer, QbusDimmer> dimmer = new HashMap<>();\n+    private final Map<Integer, QbusRol> rol = new HashMap<>();\n+    private final Map<Integer, QbusThermostat> thermostat = new HashMap<>();\n+    private final Map<Integer, QbusCO2> co2 = new HashMap<>();\n+\n+    private final ExecutorService threadExecutor = Executors\n+            .newSingleThreadExecutor(new NamedThreadFactory(getThing().getUID().getAsString(), true));\n+\n+    private @Nullable QbusBridgeHandler bridgeCallBack;\n+\n+    public synchronized void startCommunication() throws IOException, InterruptedException {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+        ctdConnected = false;\n+\n+        if (qEventsRunning) {\n+            throw new IOException(\"Previous listening thread is still active.\");\n+        }\n+\n+        if (handler == null) {\n+            throw new IOException(\"No Bridge handler initialised.\");\n+        }\n+\n+        InetAddress addr = InetAddress.getByName(handler.getAddress());\n+        Integer port = handler.getPort();\n+\n+        if (port != null) {\n+            Socket socket = new Socket(addr, port);\n+            qSocket = socket;\n+            qOut = new PrintWriter(socket.getOutputStream(), true);\n+            qIn = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+            logger.debug(\"Connected via local port {} from thread {}\", socket.getLocalPort(),\n+                    Thread.currentThread().getId());\n+        } else {\n+            return;\n+        }\n+\n+        setSN();\n+        getSN();\n+\n+        // Connect to Qbus server\n+        connect();\n+\n+        // If Qbus Client is connected then initialize and start listening for incoming commands, else put Bridge\n+        // offline\n+        if (ctdConnected) {\n+            initialize();\n+            threadExecutor.execute(() -> {\n+                try {\n+                    qEvents();\n+                } catch (IOException e) {\n+                    logger.debug(\"Could not start thread {} \", e.getMessage());\n+                }\n+            });\n+        } else {\n+            handler.bridgeOffline(\"No communication with Qbus client\");\n+        }\n+    }\n+\n+    /**\n+     * Cleanup socket when the communication with Qbus Server is closed.\n+     *\n+     * @throws IOException\n+     *\n+     */\n+    public synchronized void stopCommunication() throws IOException {\n+        listenerStopped = true;\n+\n+        Socket socket = qSocket;\n+\n+        if (socket != null) {\n+            try {\n+                socket.close();\n+            } catch (IOException ignore) {\n+                // ignore IO Error when trying to close the socket if the intention is to close it anyway\n+            }\n+        }\n+\n+        qSocket = null;\n+\n+        PrintWriter qbusOut = this.qOut;\n+        if (qbusOut != null) {\n+            qbusOut.close();\n+        }\n+\n+        BufferedReader qbusIn = this.qIn;\n+        try {\n+            if (qbusIn != null) {\n+                qbusIn.close();\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"Error on closing reader {} \", e.getMessage());\n+        }\n+\n+        ctdConnected = false;\n+        logger.debug(\"Communication stopped from thread {}\", Thread.currentThread().getId());\n+    }\n+\n+    /**\n+     * Close and restart communication with Qbus Server.\n+     *\n+     * @throws InterruptedException\n+     * @throws IOException\n+     */\n+\n+    public synchronized void restartCommunication() throws InterruptedException, IOException {\n+        stopCommunication();\n+\n+        logger.debug(\"Qbus: restart communication from thread {}\", Thread.currentThread().getId());\n+\n+        try {\n+            startCommunication();\n+        } catch (InterruptedException | IOException e) {\n+            String message = e.toString();\n+            logger.debug(\"Could not start the communication with the server. {}\", message);\n+        }\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Server is active\n+     *\n+     * @return True if active\n+     */\n+    public boolean communicationActive() {\n+        return qSocket != null;\n+    }\n+\n+    /**\n+     * Method to check if communication with Qbus Client is active\n+     *\n+     * @return True if active\n+     */\n+\n+    public boolean clientConnected() {\n+        return ctdConnected;\n+    }\n+\n+    /**\n+     * Runnable that handles incomming communication from Qbus server.\n+     * <p>\n+     * The thread listens to the TCP socket opened at instantiation of the {@link QbusCommunication} class\n+     * and interprets all incomming json messages. It triggers state updates for active channels linked to the\n+     * Qbus outputs. It is started after initialization of the communication.\n+     *\n+     * @return\n+     * @throws IOException\n+     *\n+     */\n+    private void qEvents() throws IOException {\n+        String qMessage;\n+\n+        listenerStopped = false;\n+        qEventsRunning = true;\n+\n+        BufferedReader reader = this.qIn;\n+\n+        if (reader == null) {\n+            throw new IOException(\"Bufferreader for incoming messages not initialized.\");\n+        }\n+\n+        while (!Thread.currentThread().isInterrupted() && ((qMessage = reader.readLine()) != null)) {\n+            readMessage(qMessage);\n+        }\n+\n+        if (!listenerStopped) {\n+            qEventsRunning = false;\n+\n+            QbusBridgeHandler handler = bridgeCallBack;\n+\n+            if (handler != null) {\n+                ctdConnected = false;\n+                handler.bridgeOffline(\"No communication with Qbus server\");\n+            }\n+        }\n+\n+        qEventsRunning = false;\n+        logger.trace(\"Event listener thread stopped on thread {}\", Thread.currentThread().getId());\n+    };\n+\n+    /**\n+     * Called by other methods to send json data to Qbus.\n+     *\n+     * @param qMessage\n+     * @throws InterruptedException\n+     */\n+    synchronized void sendMessage(Object qMessage) throws InterruptedException {\n+        PrintWriter writer = qOut;\n+        String json = gsonOut.toJson(qMessage);\n+        QbusBridgeHandler handler = bridgeCallBack;\n+\n+        if (writer != null) {\n+            writer.println(json);\n+            // Delay after sending data to improve scene execution\n+            TimeUnit.MILLISECONDS.sleep(250);\n+\n+        }\n+        if ((writer == null) || (writer.checkError())) {\n+            logger.warn(\"Error sending message, trying to restart communication\");\n+            try {\n+                restartCommunication();\n+            } catch (IOException e) {\n+                if (handler != null) {\n+                    handler.bridgeOffline(\"No communication with Qbus server. \" + e.toString());\n+                }\n+            }\n+            // retry sending after restart\n+            writer = qOut;\n+            if (writer != null) {\n+                writer.println(json);\n+            }\n+            if ((writer == null) || (writer.checkError())) {\n+                logger.warn(\"Error resending message\");\n+\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Called by other methods to Qbus server and read response\n+     */\n+    private void sendAndReadMessage(String command) throws IOException, InterruptedException {\n+        String snr = getSN();\n+        if (snr != null) {\n+            QbusMessageCmd qCmd = new QbusMessageCmd(snr, command);\n+\n+            sendMessage(qCmd);\n+\n+            BufferedReader reader = qIn;\n+            if (reader == null) {\n+                throw new IOException(\"Cannot read from socket, reader not connected.\");\n+            }\n+            readMessage(reader.readLine());\n+        } else {\n+            QbusBridgeHandler handler = bridgeCallBack;\n+            if (handler != null) {\n+                handler.bridgeOffline(\"No serial nr defined\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method that interprets all feedback from Qbus Server application and calls appropriate handling methods.\n+     *\n+     * @param qMessage message read from Qbus.\n+     */\n+    private void readMessage(String qMessage) {\n+        String cmd = \"\";\n+        String ctd = \"\";\n+        String sn = null;\n+        QbusMessageBase qMessageGson;\n+\n+        qMessageGson = gsonIn.fromJson(qMessage, QbusMessageBase.class);\n+        if (qMessageGson != null) {\n+            ctd = qMessageGson.getSn();\n+            cmd = qMessageGson.getCmd();\n+        }\n+\n+        QbusBridgeHandler handler = bridgeCallBack;\n+\n+        if (handler != null) {\n+            sn = handler.getSn();\n+        }\n+\n+        if (sn != null && ctd != null) {\n+            try {\n+                if (Integer.parseInt(sn) == Integer.parseInt(ctd) && qMessageGson != null) {\n+                    // Get the compatible outputs from the Qbus server\n+                    if (\"returnBistabiel\".equals(cmd)) {\n+                        cmdListBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"returnDimmer\".equals(cmd)) {\n+                        cmdListDimmers(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnThermostat\").equals(cmd)) {\n+                        cmdListThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnScene\").equals(cmd)) {\n+                        cmdListScenes(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnCo2\").equals(cmd)) {\n+                        cmdListCo2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnRol02p\").equals(cmd)) {\n+                        cmdListRol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if ((\"returnSlat\").equals(cmd)) {\n+                        cmdListRolSlats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incoming commands from Qbus Client to openHAB (event)\n+                    else if (\"updateBistabiel\".equals(cmd)) {\n+                        updateBistabiel(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateDimmer\".equals(cmd)) {\n+                        updateDimmer(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateThermostat\".equals(cmd)) {\n+                        updateThermostat(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateCo2\".equals(cmd)) {\n+                        updateCO2(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02p\".equals(cmd)) {\n+                        updateRol(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    } else if (\"updateRol02pSlat\".equals(cmd)) {\n+                        updateRolSlats(((QbusMessageListMap) qMessageGson).getOutputs());\n+                    }\n+\n+                    // Incomming commands from Qbus server to verify the client connection\n+                    else if (\"disconnect\".equals(cmd)) {\n+                        eventDisconnect();\n+                    } else if (\"notConnected\".equals(cmd)) {\n+                        noConnection();\n+                    } else if (\"connected\".equals(cmd)) {\n+                        connection();\n+                    }\n+                }\n+\n+            } catch (JsonParseException e) {\n+                logger.warn(\"Not acted on unsupported json {}\", qMessage);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * After setting up the communication with the Qbus Server, send all initialization messages.\n+     * <p>\n+     * First send connect to connect with the Qbus Server application\n+     * Get request for Bistabiel/Timers/Intervals/Mono outputs\n+     * Get request for the Scenes\n+     * Get request for Dimmers 1T and 2T\n+     * Get request for Shutters\n+     * Get request for Thermostats\n+     * Get request for CO2\n+     */\n+    @Override\n+    public void initialize() {\n+        QbusBridgeHandler handler = bridgeCallBack;\n+\n+        if (bridgeCallBack != null) {\n+            if (ctdConnected) {\n+                try {\n+                    sendAndReadMessage(\"getBistabiel\");", "originalCommit": "34536bd3cbeeeb8e309e5e68169682f2aea3765a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0c551c6032d6cdfe42d7ae84e2289b196b157159", "url": "https://github.com/openhab/openhab-addons/commit/0c551c6032d6cdfe42d7ae84e2289b196b157159", "message": "Updated requested changes\n\nUpdated  changes as requested by fwolter on 2/3/2021\n\nSigned-off-by: Koen Schockaert <ks@qbus.be>", "committedDate": "2021-03-23T09:49:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjcyODEyOA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r602728128", "bodyText": "initialize() must return fast. As name resolution can block, it should be executed asynchronously via the scheduler. Keep in mind that name resolution errors can be temporary. The Thing will stay OFFLINE if the name resolution recovers. You could remove the check here at all.", "author": "fwolter", "createdAt": "2021-03-27T14:48:47Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/QbusBridgeHandler.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.protocol.QbusCommunication;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link QbusBridgeHandler} is the handler for a Qbus controller\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public class QbusBridgeHandler extends BaseBridgeHandler {\n+\n+    private @Nullable QbusCommunication qbusComm;\n+\n+    protected @Nullable QbusConfiguration bridgeConfig = new QbusConfiguration();\n+\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+\n+    private final Logger logger = LoggerFactory.getLogger(QbusBridgeHandler.class);\n+\n+    public QbusBridgeHandler(Bridge Bridge) {\n+        super(Bridge);\n+    }\n+\n+    /**\n+     * Initialize the bridge\n+     */\n+    @Override\n+    public void initialize() {\n+        readConfig();\n+\n+        InetAddress addr;\n+        Integer port = getPort();\n+        Integer serverCheck = getServerCheck();\n+\n+        if (port == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"No port defined for Qbus Server\");\n+            return;\n+        }\n+\n+        try {\n+            addr = InetAddress.getByName(getAddress());", "originalCommit": "0c551c6032d6cdfe42d7ae84e2289b196b157159", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjgzMTI4NA==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r602831284", "bodyText": "Thanks for pointing this out. I removed port and addr as they are set in the communications object.", "author": "QbusKoen", "createdAt": "2021-03-28T04:58:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjcyODEyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjcyODkzMw==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r602728933", "bodyText": "Can this be removed?", "author": "fwolter", "createdAt": "2021-03-27T14:57:07Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCO2.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.handler.QbusCO2Handler;\n+\n+/**\n+ * The {@link QbusCO2} class represents the action Qbus CO2 output.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCO2 {\n+\n+    private @Nullable Integer state;\n+\n+    private @Nullable QbusCO2Handler thingHandler;\n+\n+    QbusCO2() {\n+    }", "originalCommit": "0c551c6032d6cdfe42d7ae84e2289b196b157159", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjcyODk3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r602728976", "bodyText": "Can this be removed?", "author": "fwolter", "createdAt": "2021-03-27T14:57:17Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCO2.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.handler.QbusCO2Handler;\n+\n+/**\n+ * The {@link QbusCO2} class represents the action Qbus CO2 output.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCO2 {\n+\n+    private @Nullable Integer state;\n+\n+    private @Nullable QbusCO2Handler thingHandler;\n+\n+    QbusCO2() {\n+    }\n+\n+    /**\n+     * This method should be called if the ThingHandler for the thing corresponding to this CO2 is initialized.\n+     * It keeps a record of the thing handler in this object so the thing can be updated when\n+     * the CO2 output receives an update from the Qbus IP-interface.\n+     *\n+     * @param handler\n+     */\n+    public void setThingHandler(QbusCO2Handler handler) {\n+        this.thingHandler = handler;\n+    }\n+\n+    /**\n+     * This method sets a pointer to the qComm CO2 of class {@link QbusCommuncation}.\n+     * This is then used to be able to call back the sendCommand method in this class to send a command to the\n+     * Qbus client.\n+     *\n+     * @param qComm\n+     */\n+    // public void setQComm(QbusCommunication qComm) {\n+    // this.qComm = qComm;\n+    // }", "originalCommit": "0c551c6032d6cdfe42d7ae84e2289b196b157159", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjcyOTAzNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9191#discussion_r602729035", "bodyText": "Please move the constructor below the fields.", "author": "fwolter", "createdAt": "2021-03-27T14:57:44Z", "path": "bundles/org.openhab.binding.qbus/src/main/java/org/openhab/binding/qbus/internal/protocol/QbusCommunication.java", "diffHunk": "@@ -0,0 +1,796 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.qbus.internal.protocol;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.qbus.internal.QbusBridgeHandler;\n+import org.openhab.core.common.NamedThreadFactory;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * The {@link QbusCommunication} class is able to do the following tasks with Qbus\n+ * CTD controllers:\n+ * <ul>\n+ * <li>Start and stop TCP socket connection with Qbus Server.\n+ * <li>Read all the outputs and their status from the Qbus Controller.\n+ * <li>Execute Qbus commands.\n+ * <li>Listen to events from Qbus.\n+ * </ul>\n+ *\n+ * A class instance is instantiated from the {@link QbusBridgeHandler} class initialization.\n+ *\n+ * @author Koen Schockaert - Initial Contribution\n+ */\n+\n+@NonNullByDefault\n+public final class QbusCommunication extends BaseThingHandler {\n+\n+    public QbusCommunication(Thing thing) {\n+        super(thing);\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        gsonBuilder.registerTypeAdapter(QbusMessageBase.class, new QbusMessageDeserializer());\n+        gsonIn = gsonBuilder.create();\n+    }", "originalCommit": "0c551c6032d6cdfe42d7ae84e2289b196b157159", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9b408aeed71b6a091c62f2cf9f97192444311aea", "url": "https://github.com/openhab/openhab-addons/commit/9b408aeed71b6a091c62f2cf9f97192444311aea", "message": "Update requested changes\n\nUpdates changes as requested by FWolter on 27/03/2021\n\nSigned-off-by: Koen Schockaert <ks@qbus.be>", "committedDate": "2021-03-28T05:00:24Z", "type": "commit"}, {"oid": "ce4611214a7bb812a678120f6e8f1a7f472e5d7c", "url": "https://github.com/openhab/openhab-addons/commit/ce4611214a7bb812a678120f6e8f1a7f472e5d7c", "message": "Update thing-types.xml\n\nUpdate requested  as suggested by FWolter on 28/03/2021\n\nSigned-off-by: Koen Schockaert <ks@qbus.be>", "committedDate": "2021-03-28T11:47:03Z", "type": "commit"}]}