{"pr_number": 7528, "pr_title": "[novafinedust] Nova Fine Dust binding for SDS011 sensors", "pr_createdAt": "2020-05-02T15:21:15Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/7528", "timeline": [{"oid": "082d9ead955ebed650a8633f622b4ed35639f597", "url": "https://github.com/openhab/openhab-addons/commit/082d9ead955ebed650a8633f622b4ed35639f597", "message": "Nova Fine Dust binding for SDS011 sensors\n\nCloses #7527\n\nSigned-off-by: Stefan Triller <github@stefantriller.de>", "committedDate": "2020-05-02T15:28:32Z", "type": "forcePushed"}, {"oid": "17ab9e48eb7ee697b10405fcdabcba5a6d99288a", "url": "https://github.com/openhab/openhab-addons/commit/17ab9e48eb7ee697b10405fcdabcba5a6d99288a", "message": "Nova Fine Dust binding for SDS011 sensors\n\nCloses #7527\n\nSigned-off-by: Stefan Triller <github@stefantriller.de>", "committedDate": "2020-05-02T15:42:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQyMDQ5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429420499", "bodyText": "typo \"Tolerance\"", "author": "fwolter", "createdAt": "2020-05-22T19:27:57Z", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.time.chrono.ChronoZonedDateTime;\n+import java.time.temporal.Temporal;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) NovaFineDustConfiguration config;\n+    private @NonNullByDefault({}) SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private Temporal lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTollerance = Duration.ofSeconds(5);", "originalCommit": "17ab9e48eb7ee697b10405fcdabcba5a6d99288a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQyNDE3OA==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429424178", "bodyText": "The Thing is not set as online again, if the connection succeeds in one of the upcoming cycles.", "author": "fwolter", "createdAt": "2020-05-22T19:38:15Z", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.time.chrono.ChronoZonedDateTime;\n+import java.time.temporal.Temporal;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) NovaFineDustConfiguration config;\n+    private @NonNullByDefault({}) SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private Temporal lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTollerance = Duration.ofSeconds(5);\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // we do not support refreshing as values are either reported by the device or polled from the device in fixed\n+        // intervals\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            timeBetweenDataShouldArrive = Duration.ofSeconds(config.pollingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        }\n+\n+        Duration connectionMonitorStartDelay = timeBetweenDataShouldArrive.plus(CONNECTION_MONITOR_START_DELAY_OFFSET);\n+        connectionMonitor = scheduler.scheduleWithFixedDelay(this::verifyIfStillConnected,\n+                connectionMonitorStartDelay.getSeconds(), timeBetweenDataShouldArrive.getSeconds(), TimeUnit.SECONDS);\n+    }\n+\n+    private void initializeCommunicator(WorkMode mode, Duration interval) {\n+        boolean initSuccessful = false;\n+        try {\n+            initSuccessful = communicator.initialize(mode, interval);\n+        } catch (final IOException ex) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            return;\n+        } catch (PortInUseException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            return;\n+        } catch (TooManyListenersException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot attach listener to port!\");\n+            return;\n+        } catch (UnsupportedCommOperationException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot set serial port parameters\");\n+            return;\n+        }\n+\n+        if (initSuccessful) {\n+            lastCommunication = ZonedDateTime.now();\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            if (mode == WorkMode.POLLING) {\n+                pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        communicator.requestSensorData();\n+                    } catch (IOException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,", "originalCommit": "17ab9e48eb7ee697b10405fcdabcba5a6d99288a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU0NDI5NA==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429544294", "bodyText": "it will be set to ONLINE again once there is valid data received, see method updateChannels.", "author": "t2000", "createdAt": "2020-05-23T13:01:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQyNDE3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQyNDkxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429424919", "bodyText": "You don't need to check the config again, if you configured min/max etc. in the XML files.", "author": "fwolter", "createdAt": "2020-05-22T19:40:17Z", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.time.chrono.ChronoZonedDateTime;\n+import java.time.temporal.Temporal;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) NovaFineDustConfiguration config;\n+    private @NonNullByDefault({}) SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private Temporal lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTollerance = Duration.ofSeconds(5);\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // we do not support refreshing as values are either reported by the device or polled from the device in fixed\n+        // intervals\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            timeBetweenDataShouldArrive = Duration.ofSeconds(config.pollingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        }\n+\n+        Duration connectionMonitorStartDelay = timeBetweenDataShouldArrive.plus(CONNECTION_MONITOR_START_DELAY_OFFSET);\n+        connectionMonitor = scheduler.scheduleWithFixedDelay(this::verifyIfStillConnected,\n+                connectionMonitorStartDelay.getSeconds(), timeBetweenDataShouldArrive.getSeconds(), TimeUnit.SECONDS);\n+    }\n+\n+    private void initializeCommunicator(WorkMode mode, Duration interval) {\n+        boolean initSuccessful = false;\n+        try {\n+            initSuccessful = communicator.initialize(mode, interval);\n+        } catch (final IOException ex) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            return;\n+        } catch (PortInUseException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            return;\n+        } catch (TooManyListenersException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot attach listener to port!\");\n+            return;\n+        } catch (UnsupportedCommOperationException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot set serial port parameters\");\n+            return;\n+        }\n+\n+        if (initSuccessful) {\n+            lastCommunication = ZonedDateTime.now();\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            if (mode == WorkMode.POLLING) {\n+                pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        communicator.requestSensorData();\n+                    } catch (IOException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                                \"Cannot query data from device\");\n+                    }\n+                }, 2, config.pollingInterval, TimeUnit.SECONDS);\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Commands and replies from the device don't seem to match\");\n+            logger.debug(\"Could not configure sensor -> setting Thing to OFFLINE and disposing the handler\");\n+            dispose();\n+        }\n+    }\n+\n+    private boolean validateConfiguration() {\n+        if (config.port == null || config.port.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return false;\n+        }\n+\n+        if (config.reporting) {\n+            if (config.reportingInterval < 0 || config.reportingInterval > 30) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Reporting interval has to be between 0 and 30 minutes\");\n+                return false;\n+            }\n+        } else {\n+            if (config.pollingInterval < 3 || config.pollingInterval > 3600) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Polling interval has to be between 3 and 3600 seconds\");\n+                return false;\n+            }\n+        }\n+        return true;\n+    }", "originalCommit": "17ab9e48eb7ee697b10405fcdabcba5a6d99288a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU0NDMwMg==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429544302", "bodyText": "Oh wow, so openHAB now validates these values before passing them to the handler? That's cool, I didn't know that this was implemented. Thanks for letting me know. I have removed the checks.", "author": "t2000", "createdAt": "2020-05-23T13:01:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQyNDkxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA3NzMzMg==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r430077332", "bodyText": "I'm afraid I have to retract my words. The config is only validated in Paper UI, but not when configuring via a things file. @cpmeister should bindings double check their config?", "author": "fwolter", "createdAt": "2020-05-25T21:22:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQyNDkxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDEwNTYzMw==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r430105633", "bodyText": "It is always better if the binding double checks the configs.", "author": "cpmeister", "createdAt": "2020-05-26T00:35:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQyNDkxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU0MjY2OA==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r430542668", "bodyText": "Alright, I have reverted the removal of the check, so it is back in place.", "author": "t2000", "createdAt": "2020-05-26T16:23:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQyNDkxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQyNjQ2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429426461", "bodyText": "If you use ZonedDateTime instead of Temporal, you could remove this cast.", "author": "fwolter", "createdAt": "2020-05-22T19:44:40Z", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.time.chrono.ChronoZonedDateTime;\n+import java.time.temporal.Temporal;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) NovaFineDustConfiguration config;\n+    private @NonNullByDefault({}) SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private Temporal lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTollerance = Duration.ofSeconds(5);\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // we do not support refreshing as values are either reported by the device or polled from the device in fixed\n+        // intervals\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            timeBetweenDataShouldArrive = Duration.ofSeconds(config.pollingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        }\n+\n+        Duration connectionMonitorStartDelay = timeBetweenDataShouldArrive.plus(CONNECTION_MONITOR_START_DELAY_OFFSET);\n+        connectionMonitor = scheduler.scheduleWithFixedDelay(this::verifyIfStillConnected,\n+                connectionMonitorStartDelay.getSeconds(), timeBetweenDataShouldArrive.getSeconds(), TimeUnit.SECONDS);\n+    }\n+\n+    private void initializeCommunicator(WorkMode mode, Duration interval) {\n+        boolean initSuccessful = false;\n+        try {\n+            initSuccessful = communicator.initialize(mode, interval);\n+        } catch (final IOException ex) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            return;\n+        } catch (PortInUseException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            return;\n+        } catch (TooManyListenersException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot attach listener to port!\");\n+            return;\n+        } catch (UnsupportedCommOperationException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot set serial port parameters\");\n+            return;\n+        }\n+\n+        if (initSuccessful) {\n+            lastCommunication = ZonedDateTime.now();\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            if (mode == WorkMode.POLLING) {\n+                pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        communicator.requestSensorData();\n+                    } catch (IOException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                                \"Cannot query data from device\");\n+                    }\n+                }, 2, config.pollingInterval, TimeUnit.SECONDS);\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Commands and replies from the device don't seem to match\");\n+            logger.debug(\"Could not configure sensor -> setting Thing to OFFLINE and disposing the handler\");\n+            dispose();\n+        }\n+    }\n+\n+    private boolean validateConfiguration() {\n+        if (config.port == null || config.port.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return false;\n+        }\n+\n+        if (config.reporting) {\n+            if (config.reportingInterval < 0 || config.reportingInterval > 30) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Reporting interval has to be between 0 and 30 minutes\");\n+                return false;\n+            }\n+        } else {\n+            if (config.pollingInterval < 3 || config.pollingInterval > 3600) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Polling interval has to be between 3 and 3600 seconds\");\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (pollingJob != null && !pollingJob.isCancelled()) {\n+            pollingJob.cancel(true);\n+            pollingJob = null;\n+        }\n+\n+        if (connectionMonitor != null && !connectionMonitor.isCancelled()) {\n+            connectionMonitor.cancel(true);\n+            connectionMonitor = null;\n+        }\n+\n+        if (communicator != null) {\n+            scheduler.schedule(() -> communicator.dispose(), 0, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    /**\n+     * Pass the data from the device to the Thing channels\n+     *\n+     * @param sensorData the parsed data from the sensor\n+     */\n+    public void updateChannels(SensorMeasuredDataReply sensorData) {\n+        if (sensorData.isValidData()) {\n+            logger.debug(\"Updating channels with data: {}\", sensorData);\n+\n+            QuantityType<Density> statePM10 = new QuantityType<>(sensorData.getPm10(),\n+                    SmartHomeUnits.MICROGRAM_PER_CUBICMETRE);\n+            updateState(NovaFineDustBindingConstants.CHANNEL_PM10, statePM10);\n+\n+            QuantityType<Density> statePM25 = new QuantityType<>(sensorData.getPm25(),\n+                    SmartHomeUnits.MICROGRAM_PER_CUBICMETRE);\n+            updateState(NovaFineDustBindingConstants.CHANNEL_PM25, statePM25);\n+\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        // there was a communication, even if the data was not valid, thus resetting the value here\n+        lastCommunication = ZonedDateTime.now();\n+    }\n+\n+    private void verifyIfStillConnected() {\n+        ZonedDateTime now = ZonedDateTime.now();\n+        Temporal lastData = lastCommunication.plus(timeBetweenDataShouldArrive).plus(dataCanBeLateTollerance);\n+        if (now.isAfter((ChronoZonedDateTime<?>) lastData)) {", "originalCommit": "17ab9e48eb7ee697b10405fcdabcba5a6d99288a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQzMDIwNA==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429430204", "bodyText": "Bindings should only log as error, when a bug in the code is detected. You could use warn here.", "author": "fwolter", "createdAt": "2020-05-22T19:57:02Z", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.TooManyListenersException;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.SDS011Handler;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.CommandMessage;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.Constants;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.ModeReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorFirmwareReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SleepReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.WorkingPeriodReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Central instance to communicate with the device, i.e. receive data from it and send commands to it\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SDS011Communicator implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Communicator.class);\n+\n+    private SerialPortIdentifier portId;\n+    private SDS011Handler thingHandler;\n+    private @NonNullByDefault({}) SerialPort serialPort;\n+\n+    private @NonNullByDefault({}) OutputStream outputStream;\n+    private @NonNullByDefault({}) InputStream inputStream;\n+\n+    public SDS011Communicator(SDS011Handler thingHandler, SerialPortIdentifier portId) {\n+        this.thingHandler = thingHandler;\n+        this.portId = portId;\n+    }\n+\n+    /**\n+     * Initialize the communication with the device, i.e. open the serial port etc.\n+     *\n+     * @param mode the {@link WorkMode} if we want to use polling or reporting\n+     * @param interval the time between polling or reportings\n+     * @return {@code true} if we can communicate with the device\n+     * @throws PortInUseException\n+     * @throws TooManyListenersException\n+     * @throws IOException\n+     * @throws UnsupportedCommOperationException\n+     */\n+    public boolean initialize(WorkMode mode, Duration interval)\n+            throws PortInUseException, TooManyListenersException, IOException, UnsupportedCommOperationException {\n+        boolean initSuccessful = true;\n+\n+        SerialPort localSerialPort = portId.open(thingHandler.getThing().getUID().toString(), 2000);\n+        localSerialPort.setSerialPortParams(9600, 8, 1, 0);\n+\n+        outputStream = localSerialPort.getOutputStream();\n+        inputStream = localSerialPort.getInputStream();\n+\n+        if (inputStream == null || outputStream == null) {\n+            throw new IOException(\"Could not create input or outputstream for the port\");\n+        }\n+\n+        // wake up the device\n+        initSuccessful &= sendSleep(false);\n+        initSuccessful &= getFirmware();\n+\n+        if (mode == WorkMode.POLLING) {\n+            initSuccessful &= setMode(WorkMode.POLLING);\n+            initSuccessful &= setWorkingPeriod((byte) 0);\n+        } else {\n+            // reporting\n+            initSuccessful &= setWorkingPeriod((byte) interval.toMinutes());\n+            initSuccessful &= setMode(WorkMode.REPORTING);\n+        }\n+\n+        // enable listeners only after we have configured the sensor above because for configuring we send and read data\n+        // sequentially\n+        localSerialPort.notifyOnDataAvailable(true);\n+        localSerialPort.addEventListener(this);\n+        this.serialPort = localSerialPort;\n+\n+        return initSuccessful;\n+    }\n+\n+    private @Nullable SensorReply sendCommand(CommandMessage message) throws IOException {\n+        byte[] commandData = message.getBytes();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Will send command: {} ({})\", Helper.toHexString(commandData), Arrays.toString(commandData));\n+        }\n+        outputStream.write(commandData, 0, commandData.length);\n+        outputStream.flush();\n+        try {\n+            // Give the sensor some time to handle the command\n+            Thread.sleep(500);\n+        } catch (InterruptedException e) {\n+            logger.warn(\"Problem while waiting for reading a reply to our command.\");\n+            Thread.currentThread().interrupt();\n+        }\n+        SensorReply reply = readReply();\n+        // in case there is still another reporting active, we want to discard the sensor data and read the reply to our\n+        // command again\n+        if (reply instanceof SensorMeasuredDataReply) {\n+            reply = readReply();\n+        }\n+        return reply;\n+    }\n+\n+    private boolean setWorkingPeriod(byte period) throws IOException {\n+        CommandMessage m = new CommandMessage(Command.WORKING_PERIOD, new byte[] { Constants.SET_ACTION, period });\n+        logger.debug(\"Sending work period: {}\", period);\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to setWorkingPeriod command: {}\", reply);\n+        if (reply instanceof WorkingPeriodReply) {\n+            WorkingPeriodReply wpReply = (WorkingPeriodReply) reply;\n+            if (wpReply.getPeriod() == period && wpReply.getActionType() == Constants.SET_ACTION) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean setMode(WorkMode workMode) throws IOException {\n+        byte haveToRequestData = 0;\n+        if (workMode == WorkMode.POLLING) {\n+            haveToRequestData = 1;\n+        }\n+\n+        CommandMessage m = new CommandMessage(Command.MODE, new byte[] { Constants.SET_ACTION, haveToRequestData });\n+        logger.debug(\"Sending mode: {}\", workMode);\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to setMode command: {}\", reply);\n+        if (reply instanceof ModeReply) {\n+            ModeReply mr = (ModeReply) reply;\n+            if (mr.getActionType() == Constants.SET_ACTION && mr.getMode() == workMode) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean sendSleep(boolean doSleep) throws IOException {\n+        byte payload = (byte) 1;\n+        if (doSleep) {\n+            payload = (byte) 0;\n+        }\n+\n+        CommandMessage m = new CommandMessage(Command.SLEEP, new byte[] { Constants.SET_ACTION, payload });\n+        logger.debug(\"Sending doSleep: {}\", doSleep);\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to sendSleep command: {}\", reply);\n+\n+        if (!doSleep) {\n+            // sometimes the sensor does not wakeup on the first attempt, thus we try again\n+            for (int i = 0; reply == null && i < 3; i++) {\n+                reply = sendCommand(m);\n+                logger.debug(\"Got reply to sendSleep command after retry#{}: {}\", i + 1, reply);\n+            }\n+        }\n+\n+        if (reply instanceof SleepReply) {\n+            SleepReply sr = (SleepReply) reply;\n+            if (sr.getActionType() == Constants.SET_ACTION && sr.getSleep() == payload) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean getFirmware() throws IOException {\n+        CommandMessage m = new CommandMessage(Command.FIRMWARE, new byte[] {});\n+        logger.debug(\"Sending get firmware request\");\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to getFirmware command: {}\", reply);\n+\n+        if (reply instanceof SensorFirmwareReply) {\n+            SensorFirmwareReply fwReply = (SensorFirmwareReply) reply;\n+            thingHandler.setFirmware(fwReply.getFirmware());\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Request data from the device, they will be returned via the serialEvent callback\n+     *\n+     * @throws IOException\n+     */\n+    public void requestSensorData() throws IOException {\n+        CommandMessage m = new CommandMessage(Command.REQUEST_DATA, new byte[] {});\n+        byte[] data = m.getBytes();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Requesting sensor data, will send: {}\", Helper.toHexString(data));\n+        }\n+        outputStream.write(data, 0, data.length);\n+    }\n+\n+    private @Nullable SensorReply readReply() throws IOException {\n+        byte[] readBuffer = new byte[Constants.REPLY_LENGTH];\n+\n+        int b = -1;\n+        if (inputStream.available() > 0) {\n+            while ((b = inputStream.read()) != Constants.MESSAGE_START_AS_INT) {\n+                logger.debug(\"Trying to find first reply byte now...\");\n+            }\n+            readBuffer[0] = (byte) b;\n+            int remainingBytesRead = inputStream.read(readBuffer, 1, Constants.REPLY_LENGTH - 1);\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Read remaining bytes: {}, full reply={}\", remainingBytesRead,\n+                        Helper.toHexString(readBuffer));\n+            }\n+            return ReplyFactory.create(readBuffer);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Data from the device is arriving and will be parsed accordingly\n+     */\n+    @Override\n+    public void serialEvent(SerialPortEvent event) {\n+        if (event.getEventType() == SerialPortEvent.DATA_AVAILABLE) {\n+            // we get here if data has been received\n+            SensorReply reply = null;\n+            try {\n+                reply = readReply();\n+                logger.debug(\"Got data from sensor: {}\", reply);\n+            } catch (IOException e) {\n+                logger.error(\"Could not read available data from the serial port\", e);", "originalCommit": "17ab9e48eb7ee697b10405fcdabcba5a6d99288a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQzMDk2OA==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429430968", "bodyText": "Since we are going to remove the Apache Commons dependencies, could you replace the lines with standard Java code? See #7722", "author": "fwolter", "createdAt": "2020-05-22T20:00:10Z", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.TooManyListenersException;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.SDS011Handler;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.CommandMessage;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.Constants;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.ModeReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorFirmwareReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SleepReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.WorkingPeriodReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Central instance to communicate with the device, i.e. receive data from it and send commands to it\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SDS011Communicator implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Communicator.class);\n+\n+    private SerialPortIdentifier portId;\n+    private SDS011Handler thingHandler;\n+    private @NonNullByDefault({}) SerialPort serialPort;\n+\n+    private @NonNullByDefault({}) OutputStream outputStream;\n+    private @NonNullByDefault({}) InputStream inputStream;\n+\n+    public SDS011Communicator(SDS011Handler thingHandler, SerialPortIdentifier portId) {\n+        this.thingHandler = thingHandler;\n+        this.portId = portId;\n+    }\n+\n+    /**\n+     * Initialize the communication with the device, i.e. open the serial port etc.\n+     *\n+     * @param mode the {@link WorkMode} if we want to use polling or reporting\n+     * @param interval the time between polling or reportings\n+     * @return {@code true} if we can communicate with the device\n+     * @throws PortInUseException\n+     * @throws TooManyListenersException\n+     * @throws IOException\n+     * @throws UnsupportedCommOperationException\n+     */\n+    public boolean initialize(WorkMode mode, Duration interval)\n+            throws PortInUseException, TooManyListenersException, IOException, UnsupportedCommOperationException {\n+        boolean initSuccessful = true;\n+\n+        SerialPort localSerialPort = portId.open(thingHandler.getThing().getUID().toString(), 2000);\n+        localSerialPort.setSerialPortParams(9600, 8, 1, 0);\n+\n+        outputStream = localSerialPort.getOutputStream();\n+        inputStream = localSerialPort.getInputStream();\n+\n+        if (inputStream == null || outputStream == null) {\n+            throw new IOException(\"Could not create input or outputstream for the port\");\n+        }\n+\n+        // wake up the device\n+        initSuccessful &= sendSleep(false);\n+        initSuccessful &= getFirmware();\n+\n+        if (mode == WorkMode.POLLING) {\n+            initSuccessful &= setMode(WorkMode.POLLING);\n+            initSuccessful &= setWorkingPeriod((byte) 0);\n+        } else {\n+            // reporting\n+            initSuccessful &= setWorkingPeriod((byte) interval.toMinutes());\n+            initSuccessful &= setMode(WorkMode.REPORTING);\n+        }\n+\n+        // enable listeners only after we have configured the sensor above because for configuring we send and read data\n+        // sequentially\n+        localSerialPort.notifyOnDataAvailable(true);\n+        localSerialPort.addEventListener(this);\n+        this.serialPort = localSerialPort;\n+\n+        return initSuccessful;\n+    }\n+\n+    private @Nullable SensorReply sendCommand(CommandMessage message) throws IOException {\n+        byte[] commandData = message.getBytes();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Will send command: {} ({})\", Helper.toHexString(commandData), Arrays.toString(commandData));\n+        }\n+        outputStream.write(commandData, 0, commandData.length);\n+        outputStream.flush();\n+        try {\n+            // Give the sensor some time to handle the command\n+            Thread.sleep(500);\n+        } catch (InterruptedException e) {\n+            logger.warn(\"Problem while waiting for reading a reply to our command.\");\n+            Thread.currentThread().interrupt();\n+        }\n+        SensorReply reply = readReply();\n+        // in case there is still another reporting active, we want to discard the sensor data and read the reply to our\n+        // command again\n+        if (reply instanceof SensorMeasuredDataReply) {\n+            reply = readReply();\n+        }\n+        return reply;\n+    }\n+\n+    private boolean setWorkingPeriod(byte period) throws IOException {\n+        CommandMessage m = new CommandMessage(Command.WORKING_PERIOD, new byte[] { Constants.SET_ACTION, period });\n+        logger.debug(\"Sending work period: {}\", period);\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to setWorkingPeriod command: {}\", reply);\n+        if (reply instanceof WorkingPeriodReply) {\n+            WorkingPeriodReply wpReply = (WorkingPeriodReply) reply;\n+            if (wpReply.getPeriod() == period && wpReply.getActionType() == Constants.SET_ACTION) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean setMode(WorkMode workMode) throws IOException {\n+        byte haveToRequestData = 0;\n+        if (workMode == WorkMode.POLLING) {\n+            haveToRequestData = 1;\n+        }\n+\n+        CommandMessage m = new CommandMessage(Command.MODE, new byte[] { Constants.SET_ACTION, haveToRequestData });\n+        logger.debug(\"Sending mode: {}\", workMode);\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to setMode command: {}\", reply);\n+        if (reply instanceof ModeReply) {\n+            ModeReply mr = (ModeReply) reply;\n+            if (mr.getActionType() == Constants.SET_ACTION && mr.getMode() == workMode) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean sendSleep(boolean doSleep) throws IOException {\n+        byte payload = (byte) 1;\n+        if (doSleep) {\n+            payload = (byte) 0;\n+        }\n+\n+        CommandMessage m = new CommandMessage(Command.SLEEP, new byte[] { Constants.SET_ACTION, payload });\n+        logger.debug(\"Sending doSleep: {}\", doSleep);\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to sendSleep command: {}\", reply);\n+\n+        if (!doSleep) {\n+            // sometimes the sensor does not wakeup on the first attempt, thus we try again\n+            for (int i = 0; reply == null && i < 3; i++) {\n+                reply = sendCommand(m);\n+                logger.debug(\"Got reply to sendSleep command after retry#{}: {}\", i + 1, reply);\n+            }\n+        }\n+\n+        if (reply instanceof SleepReply) {\n+            SleepReply sr = (SleepReply) reply;\n+            if (sr.getActionType() == Constants.SET_ACTION && sr.getSleep() == payload) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean getFirmware() throws IOException {\n+        CommandMessage m = new CommandMessage(Command.FIRMWARE, new byte[] {});\n+        logger.debug(\"Sending get firmware request\");\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to getFirmware command: {}\", reply);\n+\n+        if (reply instanceof SensorFirmwareReply) {\n+            SensorFirmwareReply fwReply = (SensorFirmwareReply) reply;\n+            thingHandler.setFirmware(fwReply.getFirmware());\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Request data from the device, they will be returned via the serialEvent callback\n+     *\n+     * @throws IOException\n+     */\n+    public void requestSensorData() throws IOException {\n+        CommandMessage m = new CommandMessage(Command.REQUEST_DATA, new byte[] {});\n+        byte[] data = m.getBytes();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Requesting sensor data, will send: {}\", Helper.toHexString(data));\n+        }\n+        outputStream.write(data, 0, data.length);\n+    }\n+\n+    private @Nullable SensorReply readReply() throws IOException {\n+        byte[] readBuffer = new byte[Constants.REPLY_LENGTH];\n+\n+        int b = -1;\n+        if (inputStream.available() > 0) {\n+            while ((b = inputStream.read()) != Constants.MESSAGE_START_AS_INT) {\n+                logger.debug(\"Trying to find first reply byte now...\");\n+            }\n+            readBuffer[0] = (byte) b;\n+            int remainingBytesRead = inputStream.read(readBuffer, 1, Constants.REPLY_LENGTH - 1);\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Read remaining bytes: {}, full reply={}\", remainingBytesRead,\n+                        Helper.toHexString(readBuffer));\n+            }\n+            return ReplyFactory.create(readBuffer);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Data from the device is arriving and will be parsed accordingly\n+     */\n+    @Override\n+    public void serialEvent(SerialPortEvent event) {\n+        if (event.getEventType() == SerialPortEvent.DATA_AVAILABLE) {\n+            // we get here if data has been received\n+            SensorReply reply = null;\n+            try {\n+                reply = readReply();\n+                logger.debug(\"Got data from sensor: {}\", reply);\n+            } catch (IOException e) {\n+                logger.error(\"Could not read available data from the serial port\", e);\n+            }\n+            if (reply instanceof SensorMeasuredDataReply) {\n+                SensorMeasuredDataReply sensorData = (SensorMeasuredDataReply) reply;\n+                if (sensorData.isValidData()) {\n+                    thingHandler.updateChannels(sensorData);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Shutdown the communication, i.e. send the device to sleep and close the serial port\n+     */\n+    public void dispose() {\n+        if (serialPort != null) {\n+            try {\n+                // send the device to sleep to preserve power and extend the lifetime of the sensor\n+                sendSleep(true);\n+            } catch (IOException e) {\n+                // ignore because we are shutting down anyway\n+                logger.debug(\"Exception while disposing communicator (will ignore it)\", e);\n+            } finally {\n+                serialPort.removeEventListener();\n+                serialPort.close();\n+                serialPort = null;\n+            }\n+        }\n+        IOUtils.closeQuietly(inputStream);\n+        IOUtils.closeQuietly(outputStream);", "originalCommit": "17ab9e48eb7ee697b10405fcdabcba5a6d99288a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bf0810c7b031185b426267d586b8cee193dfeeff", "url": "https://github.com/openhab/openhab-addons/commit/bf0810c7b031185b426267d586b8cee193dfeeff", "message": "Nova Fine Dust binding for SDS011 sensors\n\nCloses #7527\n\nSigned-off-by: Stefan Triller <github@stefantriller.de>", "committedDate": "2020-05-23T12:47:52Z", "type": "commit"}, {"oid": "bde3d2b7dce707a863eafa496bd10e55b6dc7cd2", "url": "https://github.com/openhab/openhab-addons/commit/bde3d2b7dce707a863eafa496bd10e55b6dc7cd2", "message": "Address review comments\n\nSigned-off-by: Stefan Triller <github@stefantriller.de>", "committedDate": "2020-05-23T13:01:50Z", "type": "commit"}, {"oid": "bde3d2b7dce707a863eafa496bd10e55b6dc7cd2", "url": "https://github.com/openhab/openhab-addons/commit/bde3d2b7dce707a863eafa496bd10e55b6dc7cd2", "message": "Address review comments\n\nSigned-off-by: Stefan Triller <github@stefantriller.de>", "committedDate": "2020-05-23T13:01:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU1NDEyMw==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429554123", "bodyText": "No need to log the stacktrace here, but you could log the exception message:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.warn(\"Could not read available data from the serial port\", e);\n          \n          \n            \n                            logger.warn(\"Could not read available data from the serial port: {}\", e.getMessage());", "author": "fwolter", "createdAt": "2020-05-23T15:12:06Z", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "diffHunk": "@@ -253,7 +252,7 @@ public void serialEvent(SerialPortEvent event) {\n                 reply = readReply();\n                 logger.debug(\"Got data from sensor: {}\", reply);\n             } catch (IOException e) {\n-                logger.error(\"Could not read available data from the serial port\", e);\n+                logger.warn(\"Could not read available data from the serial port\", e);", "originalCommit": "bde3d2b7dce707a863eafa496bd10e55b6dc7cd2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU2MTM0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429561349", "bodyText": "Indeed, this makes sense to only log the message. I have changed it, thanks!", "author": "t2000", "createdAt": "2020-05-23T16:51:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU1NDEyMw=="}], "type": "inlineReview"}, {"oid": "0d2971b437b5c6dffb681d35908a946d857530be", "url": "https://github.com/openhab/openhab-addons/commit/0d2971b437b5c6dffb681d35908a946d857530be", "message": "Address further review comments\n\nSigned-off-by: Stefan Triller <github@stefantriller.de>", "committedDate": "2020-05-23T16:51:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU3MzQyMg==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429573422", "bodyText": "There is an implementation of this in HexUtils from openhab core.", "author": "cpmeister", "createdAt": "2020-05-23T19:50:24Z", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/Helper.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Class with useful utility functions\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class Helper {\n+\n+    private Helper() {\n+    }\n+\n+    /**\n+     * Converts a byte array to a hexadecimal string, handy for printing\n+     *\n+     * @param bytes the byte array to be converted\n+     * @return a String describing the byte array in hexadecimal values\n+     */\n+    public static String toHexString(byte[] bytes) {", "originalCommit": "0d2971b437b5c6dffb681d35908a946d857530be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU3NTA0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429575049", "bodyText": "Perhaps you could cache the values so that a Refresh command would be able to get the most recently reported ones.", "author": "cpmeister", "createdAt": "2020-05-23T20:15:56Z", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) NovaFineDustConfiguration config;\n+    private @NonNullByDefault({}) SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private ZonedDateTime lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTolerance = Duration.ofSeconds(5);\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // we do not support refreshing as values are either reported by the device or polled from the device in fixed\n+        // intervals", "originalCommit": "0d2971b437b5c6dffb681d35908a946d857530be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU3NTE2MA==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429575160", "bodyText": "why is this disposed asynchronously?", "author": "cpmeister", "createdAt": "2020-05-23T20:17:34Z", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) NovaFineDustConfiguration config;\n+    private @NonNullByDefault({}) SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private ZonedDateTime lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTolerance = Duration.ofSeconds(5);\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // we do not support refreshing as values are either reported by the device or polled from the device in fixed\n+        // intervals\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            timeBetweenDataShouldArrive = Duration.ofSeconds(config.pollingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        }\n+\n+        Duration connectionMonitorStartDelay = timeBetweenDataShouldArrive.plus(CONNECTION_MONITOR_START_DELAY_OFFSET);\n+        connectionMonitor = scheduler.scheduleWithFixedDelay(this::verifyIfStillConnected,\n+                connectionMonitorStartDelay.getSeconds(), timeBetweenDataShouldArrive.getSeconds(), TimeUnit.SECONDS);\n+    }\n+\n+    private void initializeCommunicator(WorkMode mode, Duration interval) {\n+        boolean initSuccessful = false;\n+        try {\n+            initSuccessful = communicator.initialize(mode, interval);\n+        } catch (final IOException ex) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            return;\n+        } catch (PortInUseException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            return;\n+        } catch (TooManyListenersException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot attach listener to port!\");\n+            return;\n+        } catch (UnsupportedCommOperationException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot set serial port parameters\");\n+            return;\n+        }\n+\n+        if (initSuccessful) {\n+            lastCommunication = ZonedDateTime.now();\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            if (mode == WorkMode.POLLING) {\n+                pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        communicator.requestSensorData();\n+                    } catch (IOException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                                \"Cannot query data from device\");\n+                    }\n+                }, 2, config.pollingInterval, TimeUnit.SECONDS);\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Commands and replies from the device don't seem to match\");\n+            logger.debug(\"Could not configure sensor -> setting Thing to OFFLINE and disposing the handler\");\n+            dispose();\n+        }\n+    }\n+\n+    private boolean validateConfiguration() {\n+        if (config.port == null || config.port.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (pollingJob != null && !pollingJob.isCancelled()) {\n+            pollingJob.cancel(true);\n+            pollingJob = null;\n+        }\n+\n+        if (connectionMonitor != null && !connectionMonitor.isCancelled()) {\n+            connectionMonitor.cancel(true);\n+            connectionMonitor = null;\n+        }\n+\n+        if (communicator != null) {\n+            scheduler.schedule(() -> communicator.dispose(), 0, TimeUnit.SECONDS);", "originalCommit": "0d2971b437b5c6dffb681d35908a946d857530be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAwNDIzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r430004231", "bodyText": "Because I think initialize and dispose from a ThingHandler should return quickly, i.e. within 5 seconds. Inside the dispose I send the sensor to sleep by communicating with it. This is important to enhance its lifetime.\nSo in order to not block the disposing call, I do it asynchronously.", "author": "t2000", "createdAt": "2020-05-25T16:06:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU3NTE2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc1NDgyOA==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r430754828", "bodyText": "So what happens if the handler is restarted (disposed then initialized again)? Would the handler be stuck in a configuration COMMUNICATION_ERROR because the port is still in use?", "author": "cpmeister", "createdAt": "2020-05-26T23:05:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU3NTE2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI1MjU5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r431252599", "bodyText": "This is a VERY interesting point! :-)\nThere are similar problems in the zigbee binding, because there it also takes a while to startup the stack and if this gets restarted through dispose/initialize calls, everything gets messed up too. Synchronization might help there but is a pain in the ass to do that for every binding.\nAnd I am afraid to say that with the 5 second rule for initialize/dispose, bindings are forced to spawn a separate task, which will ALWAYS cause these troubles if dispose/initialize is called within a short time frame (i.e. by a disable/enable of the thing).\nIf you prefer to have my dispose here running in sync with the framework, I am fine to replace the task with a direct call. In my case this usually only takes about 1-2 seconds anyway, but I wanted to play safe since I am communicating with an external device and this might timeout, etc.\nBut the overall problem for all bindings will stay, especially with the use case of enabling and disabling of a thing.\nWDYT?", "author": "t2000", "createdAt": "2020-05-27T15:55:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU3NTE2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM1NjA0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r431356043", "bodyText": "The only way I can see of dealing with delayed initialize/dispose is to make your handler and communicator objects have different lifecycles.\nYou would need to create a your own communicator factory class that handlers would request communicators for a given port.\npublic interface CommunicatorFactory{\n     SDS011Communicator getCommunicator(SerialPortIdentifier portId);\n}\n\nThe factory itself would share the same lifecycle as an osgi component so either you could make your handler factory a communicator factory or implement it in a new osgi component.\nThe key benefit here is that you would be able to reuse SDS011Communicator instances across handler restarts.", "author": "cpmeister", "createdAt": "2020-05-27T18:29:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU3NTE2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ1MDc5NA==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r431450794", "bodyText": "This doesn't really solve the problem, I could still have the communicator instance running if i dispose the handler and then the port is blocked.\nAlso its not worth the effort as I said before the communication takes max 1-2 seconds.\nI have changed it to be synchronous now.", "author": "t2000", "createdAt": "2020-05-27T21:23:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU3NTE2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ2MDk0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r431460942", "bodyText": "This doesn't really solve the problem, I could still have the communicator instance running if i dispose the handler and then the port is blocked.\n\nNot really since you can prevent a communicator from opening the port if it is already open. Likewise a communicator can stop its disposal process if a new handler requests to use it.\n\nI have changed it to be synchronous now.\n\nI don't think would work, a new handler means a new communicator object. Synchronization only works on the same object instance.\nNvm, just saw what you committed.", "author": "cpmeister", "createdAt": "2020-05-27T21:45:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU3NTE2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwODYyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r431608629", "bodyText": "Not really since you can prevent a communicator from opening the port if it is already open. Likewise a communicator can stop its disposal process if a new handler requests to use it.\n\nThe problem is not having a different thing, let's say \"thing2\" wanting the very same port. This is already handled, because the port in use exception is dealt with. And this is always a user problem, since he has configured thing1 and thing2 with the same port.\nWhat I am talking about is that the ThingHandler from thing1 is disposed and shortly afterwards initialized again. This can happen if one disabled and enables a thing, see https://github.com/openhab/openhab-core/blob/5b325aa3d210c2dfa490c676520fe755b0f3fe1c/bundles/org.openhab.core.thing/src/main/java/org/openhab/core/thing/internal/ThingManagerImpl.java#L1167-L1216\nHere it doesnt matter if a communicator object or the thinghandler itself want to open the port on initialize. If it is currently in use by a thinghandler that gets disposed at the moment, then there is no way for a starting thinghandler to open the port and he will run into the port in use exception.\nThis applies to ALL binding which are operating on a shared resource like a port btw...\nSo with the change I did yesterday evening, the dispose is always called and finished before an initialize, so for now all is good within this binding.\nHowever, one should think about the general problem of shared resources and scenarios where an initialize or dispose might take longer and one has no other choice than putting this in an external task because of this 5 second rule from openHAB.", "author": "t2000", "createdAt": "2020-05-28T06:29:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU3NTE2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4Mzk2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429583962", "bodyText": "I suggest populating this through the NovaFineDustHandlerFactory constructor.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @NonNullByDefault({}) SerialPortManager serialPortManager;\n          \n          \n            \n                private final SerialPortManager serialPortManager;\n          \n          \n            \n                \n          \n          \n            \n                @Activate\n          \n          \n            \n                public NovaFineDustHandlerFactory(@Reference SerialPortManager serialPortManager){\n          \n          \n            \n                    this.serialPortManager = serialPortManager;\n          \n          \n            \n                }\n          \n      \n    \n    \n  \n\nThen you can remove the setSerialPortManager and unsetSerialPortManager methods.", "author": "cpmeister", "createdAt": "2020-05-23T22:47:18Z", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/NovaFineDustHandlerFactory.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import static org.openhab.binding.novafinedust.internal.NovaFineDustBindingConstants.THING_TYPE_SDS011;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link NovaFineDustHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.novafinedust\", service = ThingHandlerFactory.class)\n+public class NovaFineDustHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_SDS011);\n+\n+    private @NonNullByDefault({}) SerialPortManager serialPortManager;", "originalCommit": "0d2971b437b5c6dffb681d35908a946d857530be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NDA0NA==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429584044", "bodyText": "No harm in cancelling something that is already cancelled.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (pollingJob != null && !pollingJob.isCancelled()) {\n          \n          \n            \n                    if (pollingJob != null) {", "author": "cpmeister", "createdAt": "2020-05-23T22:48:55Z", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) NovaFineDustConfiguration config;\n+    private @NonNullByDefault({}) SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private ZonedDateTime lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTolerance = Duration.ofSeconds(5);\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // we do not support refreshing as values are either reported by the device or polled from the device in fixed\n+        // intervals\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            timeBetweenDataShouldArrive = Duration.ofSeconds(config.pollingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        }\n+\n+        Duration connectionMonitorStartDelay = timeBetweenDataShouldArrive.plus(CONNECTION_MONITOR_START_DELAY_OFFSET);\n+        connectionMonitor = scheduler.scheduleWithFixedDelay(this::verifyIfStillConnected,\n+                connectionMonitorStartDelay.getSeconds(), timeBetweenDataShouldArrive.getSeconds(), TimeUnit.SECONDS);\n+    }\n+\n+    private void initializeCommunicator(WorkMode mode, Duration interval) {\n+        boolean initSuccessful = false;\n+        try {\n+            initSuccessful = communicator.initialize(mode, interval);\n+        } catch (final IOException ex) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            return;\n+        } catch (PortInUseException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            return;\n+        } catch (TooManyListenersException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot attach listener to port!\");\n+            return;\n+        } catch (UnsupportedCommOperationException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot set serial port parameters\");\n+            return;\n+        }\n+\n+        if (initSuccessful) {\n+            lastCommunication = ZonedDateTime.now();\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            if (mode == WorkMode.POLLING) {\n+                pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        communicator.requestSensorData();\n+                    } catch (IOException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                                \"Cannot query data from device\");\n+                    }\n+                }, 2, config.pollingInterval, TimeUnit.SECONDS);\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Commands and replies from the device don't seem to match\");\n+            logger.debug(\"Could not configure sensor -> setting Thing to OFFLINE and disposing the handler\");\n+            dispose();\n+        }\n+    }\n+\n+    private boolean validateConfiguration() {\n+        if (config.port == null || config.port.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (pollingJob != null && !pollingJob.isCancelled()) {", "originalCommit": "0d2971b437b5c6dffb681d35908a946d857530be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NDA1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429584056", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (connectionMonitor != null && !connectionMonitor.isCancelled()) {\n          \n          \n            \n                    if (connectionMonitor != null) {", "author": "cpmeister", "createdAt": "2020-05-23T22:49:15Z", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) NovaFineDustConfiguration config;\n+    private @NonNullByDefault({}) SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private ZonedDateTime lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTolerance = Duration.ofSeconds(5);\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // we do not support refreshing as values are either reported by the device or polled from the device in fixed\n+        // intervals\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            timeBetweenDataShouldArrive = Duration.ofSeconds(config.pollingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        }\n+\n+        Duration connectionMonitorStartDelay = timeBetweenDataShouldArrive.plus(CONNECTION_MONITOR_START_DELAY_OFFSET);\n+        connectionMonitor = scheduler.scheduleWithFixedDelay(this::verifyIfStillConnected,\n+                connectionMonitorStartDelay.getSeconds(), timeBetweenDataShouldArrive.getSeconds(), TimeUnit.SECONDS);\n+    }\n+\n+    private void initializeCommunicator(WorkMode mode, Duration interval) {\n+        boolean initSuccessful = false;\n+        try {\n+            initSuccessful = communicator.initialize(mode, interval);\n+        } catch (final IOException ex) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            return;\n+        } catch (PortInUseException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            return;\n+        } catch (TooManyListenersException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot attach listener to port!\");\n+            return;\n+        } catch (UnsupportedCommOperationException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot set serial port parameters\");\n+            return;\n+        }\n+\n+        if (initSuccessful) {\n+            lastCommunication = ZonedDateTime.now();\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            if (mode == WorkMode.POLLING) {\n+                pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        communicator.requestSensorData();\n+                    } catch (IOException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                                \"Cannot query data from device\");\n+                    }\n+                }, 2, config.pollingInterval, TimeUnit.SECONDS);\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Commands and replies from the device don't seem to match\");\n+            logger.debug(\"Could not configure sensor -> setting Thing to OFFLINE and disposing the handler\");\n+            dispose();\n+        }\n+    }\n+\n+    private boolean validateConfiguration() {\n+        if (config.port == null || config.port.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (pollingJob != null && !pollingJob.isCancelled()) {\n+            pollingJob.cancel(true);\n+            pollingJob = null;\n+        }\n+\n+        if (connectionMonitor != null && !connectionMonitor.isCancelled()) {", "originalCommit": "0d2971b437b5c6dffb681d35908a946d857530be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NDE4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429584187", "bodyText": "Please make these nullable.", "author": "cpmeister", "createdAt": "2020-05-23T22:51:24Z", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.TooManyListenersException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.SDS011Handler;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.CommandMessage;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.Constants;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.ModeReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorFirmwareReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SleepReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.WorkingPeriodReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Central instance to communicate with the device, i.e. receive data from it and send commands to it\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SDS011Communicator implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Communicator.class);\n+\n+    private SerialPortIdentifier portId;\n+    private SDS011Handler thingHandler;\n+    private @NonNullByDefault({}) SerialPort serialPort;\n+\n+    private @NonNullByDefault({}) OutputStream outputStream;\n+    private @NonNullByDefault({}) InputStream inputStream;", "originalCommit": "0d2971b437b5c6dffb681d35908a946d857530be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NDMyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429584329", "bodyText": "Why is this necessary? inputStream.read() will block until data becomes available anyway.", "author": "cpmeister", "createdAt": "2020-05-23T22:54:46Z", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.TooManyListenersException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.SDS011Handler;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.CommandMessage;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.Constants;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.ModeReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorFirmwareReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SleepReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.WorkingPeriodReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Central instance to communicate with the device, i.e. receive data from it and send commands to it\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SDS011Communicator implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Communicator.class);\n+\n+    private SerialPortIdentifier portId;\n+    private SDS011Handler thingHandler;\n+    private @NonNullByDefault({}) SerialPort serialPort;\n+\n+    private @NonNullByDefault({}) OutputStream outputStream;\n+    private @NonNullByDefault({}) InputStream inputStream;\n+\n+    public SDS011Communicator(SDS011Handler thingHandler, SerialPortIdentifier portId) {\n+        this.thingHandler = thingHandler;\n+        this.portId = portId;\n+    }\n+\n+    /**\n+     * Initialize the communication with the device, i.e. open the serial port etc.\n+     *\n+     * @param mode the {@link WorkMode} if we want to use polling or reporting\n+     * @param interval the time between polling or reportings\n+     * @return {@code true} if we can communicate with the device\n+     * @throws PortInUseException\n+     * @throws TooManyListenersException\n+     * @throws IOException\n+     * @throws UnsupportedCommOperationException\n+     */\n+    public boolean initialize(WorkMode mode, Duration interval)\n+            throws PortInUseException, TooManyListenersException, IOException, UnsupportedCommOperationException {\n+        boolean initSuccessful = true;\n+\n+        SerialPort localSerialPort = portId.open(thingHandler.getThing().getUID().toString(), 2000);\n+        localSerialPort.setSerialPortParams(9600, 8, 1, 0);\n+\n+        outputStream = localSerialPort.getOutputStream();\n+        inputStream = localSerialPort.getInputStream();\n+\n+        if (inputStream == null || outputStream == null) {\n+            throw new IOException(\"Could not create input or outputstream for the port\");\n+        }\n+\n+        // wake up the device\n+        initSuccessful &= sendSleep(false);\n+        initSuccessful &= getFirmware();\n+\n+        if (mode == WorkMode.POLLING) {\n+            initSuccessful &= setMode(WorkMode.POLLING);\n+            initSuccessful &= setWorkingPeriod((byte) 0);\n+        } else {\n+            // reporting\n+            initSuccessful &= setWorkingPeriod((byte) interval.toMinutes());\n+            initSuccessful &= setMode(WorkMode.REPORTING);\n+        }\n+\n+        // enable listeners only after we have configured the sensor above because for configuring we send and read data\n+        // sequentially\n+        localSerialPort.notifyOnDataAvailable(true);\n+        localSerialPort.addEventListener(this);\n+        this.serialPort = localSerialPort;\n+\n+        return initSuccessful;\n+    }\n+\n+    private @Nullable SensorReply sendCommand(CommandMessage message) throws IOException {\n+        byte[] commandData = message.getBytes();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Will send command: {} ({})\", Helper.toHexString(commandData), Arrays.toString(commandData));\n+        }\n+        outputStream.write(commandData, 0, commandData.length);\n+        outputStream.flush();\n+        try {\n+            // Give the sensor some time to handle the command\n+            Thread.sleep(500);", "originalCommit": "0d2971b437b5c6dffb681d35908a946d857530be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAwNDE5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r430004191", "bodyText": "Unfortunately this doesn't work. It is probably a \"feature\" of the sensor. So I have to wait here before reading the reply, otherwise the communication with the sensor will be broken.", "author": "t2000", "createdAt": "2020-05-25T16:05:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NDMyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc1NjQ3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r430756477", "bodyText": "I'm still confused, how does reading data from a serial port break communication with the sensor. Are you sure this isn't a bug in the gnu.io serial library?", "author": "cpmeister", "createdAt": "2020-05-26T23:10:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NDMyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NDgwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429584805", "bodyText": "Wouldn't this already be called implicitly through serialEvent? Wouldn't the data on the input stream be gone at that point? Could you explain how this works? I might be misunderstanding how the serial protocol works.", "author": "cpmeister", "createdAt": "2020-05-23T23:05:44Z", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.TooManyListenersException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.SDS011Handler;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.CommandMessage;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.Constants;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.ModeReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorFirmwareReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SleepReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.WorkingPeriodReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Central instance to communicate with the device, i.e. receive data from it and send commands to it\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SDS011Communicator implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Communicator.class);\n+\n+    private SerialPortIdentifier portId;\n+    private SDS011Handler thingHandler;\n+    private @NonNullByDefault({}) SerialPort serialPort;\n+\n+    private @NonNullByDefault({}) OutputStream outputStream;\n+    private @NonNullByDefault({}) InputStream inputStream;\n+\n+    public SDS011Communicator(SDS011Handler thingHandler, SerialPortIdentifier portId) {\n+        this.thingHandler = thingHandler;\n+        this.portId = portId;\n+    }\n+\n+    /**\n+     * Initialize the communication with the device, i.e. open the serial port etc.\n+     *\n+     * @param mode the {@link WorkMode} if we want to use polling or reporting\n+     * @param interval the time between polling or reportings\n+     * @return {@code true} if we can communicate with the device\n+     * @throws PortInUseException\n+     * @throws TooManyListenersException\n+     * @throws IOException\n+     * @throws UnsupportedCommOperationException\n+     */\n+    public boolean initialize(WorkMode mode, Duration interval)\n+            throws PortInUseException, TooManyListenersException, IOException, UnsupportedCommOperationException {\n+        boolean initSuccessful = true;\n+\n+        SerialPort localSerialPort = portId.open(thingHandler.getThing().getUID().toString(), 2000);\n+        localSerialPort.setSerialPortParams(9600, 8, 1, 0);\n+\n+        outputStream = localSerialPort.getOutputStream();\n+        inputStream = localSerialPort.getInputStream();\n+\n+        if (inputStream == null || outputStream == null) {\n+            throw new IOException(\"Could not create input or outputstream for the port\");\n+        }\n+\n+        // wake up the device\n+        initSuccessful &= sendSleep(false);\n+        initSuccessful &= getFirmware();\n+\n+        if (mode == WorkMode.POLLING) {\n+            initSuccessful &= setMode(WorkMode.POLLING);\n+            initSuccessful &= setWorkingPeriod((byte) 0);\n+        } else {\n+            // reporting\n+            initSuccessful &= setWorkingPeriod((byte) interval.toMinutes());\n+            initSuccessful &= setMode(WorkMode.REPORTING);\n+        }\n+\n+        // enable listeners only after we have configured the sensor above because for configuring we send and read data\n+        // sequentially\n+        localSerialPort.notifyOnDataAvailable(true);\n+        localSerialPort.addEventListener(this);\n+        this.serialPort = localSerialPort;\n+\n+        return initSuccessful;\n+    }\n+\n+    private @Nullable SensorReply sendCommand(CommandMessage message) throws IOException {\n+        byte[] commandData = message.getBytes();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Will send command: {} ({})\", Helper.toHexString(commandData), Arrays.toString(commandData));\n+        }\n+        outputStream.write(commandData, 0, commandData.length);\n+        outputStream.flush();\n+        try {\n+            // Give the sensor some time to handle the command\n+            Thread.sleep(500);\n+        } catch (InterruptedException e) {\n+            logger.warn(\"Problem while waiting for reading a reply to our command.\");\n+            Thread.currentThread().interrupt();\n+        }\n+        SensorReply reply = readReply();", "originalCommit": "0d2971b437b5c6dffb681d35908a946d857530be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAwNDE3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r430004172", "bodyText": "I am configuring the sensor with the commands BEFORE I register the listener.\nI found it a lot easier to do the protocol stuff in a synchronous manner so I have commands and their replies in one place to check if they belong together and there are no errors.\nSo this is all done before the calls:\nlocalSerialPort.notifyOnDataAvailable(true);\nlocalSerialPort.addEventListener(this);", "author": "t2000", "createdAt": "2020-05-25T16:05:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NDgwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc1ODM2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r430758367", "bodyText": "Ah! Didn't notice that, makes a lot more sense now, thanks!", "author": "cpmeister", "createdAt": "2020-05-26T23:16:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NDgwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NTA4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429585089", "bodyText": "Please add @NonNullByDefault", "author": "cpmeister", "createdAt": "2020-05-23T23:12:27Z", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/WorkMode.java", "diffHunk": "@@ -0,0 +1,24 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol;\n+\n+/**\n+ * Enum for the different sensor modes\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+public enum WorkMode {", "originalCommit": "0d2971b437b5c6dffb681d35908a946d857530be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "127335070aeacdb456c41b6c1ddc1c3ba4a27b6e", "url": "https://github.com/openhab/openhab-addons/commit/127335070aeacdb456c41b6c1ddc1c3ba4a27b6e", "message": "Address review comments from second reviewer\n\nSigned-off-by: Stefan Triller <github@stefantriller.de>", "committedDate": "2020-05-25T16:05:38Z", "type": "commit"}, {"oid": "78275e3df58da1567b75c9b1b2b6ef36af1bc404", "url": "https://github.com/openhab/openhab-addons/commit/78275e3df58da1567b75c9b1b2b6ef36af1bc404", "message": "Fix compilation error\n\nSigned-off-by: Stefan Triller <github@stefantriller.de>", "committedDate": "2020-05-25T16:26:13Z", "type": "commit"}, {"oid": "3b594394ec2080ca6bb8de2fd3710720612a5d20", "url": "https://github.com/openhab/openhab-addons/commit/3b594394ec2080ca6bb8de2fd3710720612a5d20", "message": "Revert config validation\n\nSigned-off-by: Stefan Triller <github@stefantriller.de>", "committedDate": "2020-05-26T16:21:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUzNzc1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r430537759", "bodyText": "Please make these final if possible", "author": "cpmeister", "createdAt": "2020-05-26T16:15:53Z", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/messages/SensorReply.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol.messages;\n+\n+import java.util.Arrays;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+\n+/**\n+ * Base class holding information sent by the sensor to us\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SensorReply {\n+\n+    protected byte header;\n+    protected byte commandID;\n+    protected byte[] payLoad = new byte[4];\n+    protected byte[] deviceID = new byte[2];\n+    protected byte checksum;\n+    protected byte messageTail;", "originalCommit": "78275e3df58da1567b75c9b1b2b6ef36af1bc404", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUzOTM2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r430539366", "bodyText": "Please make these final if possible", "author": "cpmeister", "createdAt": "2020-05-26T16:18:15Z", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/messages/SensorMeasuredDataReply.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol.messages;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+\n+/**\n+ * Class containing the actual measured values from the sensor\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SensorMeasuredDataReply extends SensorReply {\n+    private byte pm25lowByte;\n+    private byte pm25highByte;\n+    private byte pm10lowByte;\n+    private byte pm10highByte;", "originalCommit": "78275e3df58da1567b75c9b1b2b6ef36af1bc404", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU0MjM1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r430542359", "bodyText": "please make this final", "author": "cpmeister", "createdAt": "2020-05-26T16:22:37Z", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/messages/CommandMessage.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol.messages;\n+\n+import java.io.ByteArrayOutputStream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+\n+/**\n+ * Message to be send to the device\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class CommandMessage {\n+    private static final byte HEAD = -86; // AA\n+    private static final byte COMMAND_ID = -76; // B4\n+    private static final byte TAIL = -85; // AB\n+\n+    private static final int DATA_BYTES_AFTER_FIRST_DATA_BYTE = 12;\n+\n+    private byte firstDataByte;", "originalCommit": "78275e3df58da1567b75c9b1b2b6ef36af1bc404", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc1ODcwNA==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r430758704", "bodyText": "shouldn't you remove the event listener before you call this?", "author": "cpmeister", "createdAt": "2020-05-26T23:17:50Z", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.TooManyListenersException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.SDS011Handler;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.CommandMessage;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.Constants;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.ModeReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorFirmwareReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SleepReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.WorkingPeriodReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Central instance to communicate with the device, i.e. receive data from it and send commands to it\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SDS011Communicator implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Communicator.class);\n+\n+    private SerialPortIdentifier portId;\n+    private SDS011Handler thingHandler;\n+    private @NonNullByDefault({}) SerialPort serialPort;\n+\n+    private @Nullable OutputStream outputStream;\n+    private @Nullable InputStream inputStream;\n+\n+    public SDS011Communicator(SDS011Handler thingHandler, SerialPortIdentifier portId) {\n+        this.thingHandler = thingHandler;\n+        this.portId = portId;\n+    }\n+\n+    /**\n+     * Initialize the communication with the device, i.e. open the serial port etc.\n+     *\n+     * @param mode the {@link WorkMode} if we want to use polling or reporting\n+     * @param interval the time between polling or reportings\n+     * @return {@code true} if we can communicate with the device\n+     * @throws PortInUseException\n+     * @throws TooManyListenersException\n+     * @throws IOException\n+     * @throws UnsupportedCommOperationException\n+     */\n+    public boolean initialize(WorkMode mode, Duration interval)\n+            throws PortInUseException, TooManyListenersException, IOException, UnsupportedCommOperationException {\n+        boolean initSuccessful = true;\n+\n+        SerialPort localSerialPort = portId.open(thingHandler.getThing().getUID().toString(), 2000);\n+        localSerialPort.setSerialPortParams(9600, 8, 1, 0);\n+\n+        outputStream = localSerialPort.getOutputStream();\n+        inputStream = localSerialPort.getInputStream();\n+\n+        if (inputStream == null || outputStream == null) {\n+            throw new IOException(\"Could not create input or outputstream for the port\");\n+        }\n+\n+        // wake up the device\n+        initSuccessful &= sendSleep(false);\n+        initSuccessful &= getFirmware();\n+\n+        if (mode == WorkMode.POLLING) {\n+            initSuccessful &= setMode(WorkMode.POLLING);\n+            initSuccessful &= setWorkingPeriod((byte) 0);\n+        } else {\n+            // reporting\n+            initSuccessful &= setWorkingPeriod((byte) interval.toMinutes());\n+            initSuccessful &= setMode(WorkMode.REPORTING);\n+        }\n+\n+        // enable listeners only after we have configured the sensor above because for configuring we send and read data\n+        // sequentially\n+        localSerialPort.notifyOnDataAvailable(true);\n+        localSerialPort.addEventListener(this);\n+        this.serialPort = localSerialPort;\n+\n+        return initSuccessful;\n+    }\n+\n+    private @Nullable SensorReply sendCommand(CommandMessage message) throws IOException {\n+        byte[] commandData = message.getBytes();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Will send command: {} ({})\", HexUtils.bytesToHex(commandData), Arrays.toString(commandData));\n+        }\n+        outputStream.write(commandData, 0, commandData.length);\n+        outputStream.flush();\n+        try {\n+            // Give the sensor some time to handle the command\n+            Thread.sleep(500);\n+        } catch (InterruptedException e) {\n+            logger.warn(\"Problem while waiting for reading a reply to our command.\");\n+            Thread.currentThread().interrupt();\n+        }\n+        SensorReply reply = readReply();\n+        // in case there is still another reporting active, we want to discard the sensor data and read the reply to our\n+        // command again\n+        if (reply instanceof SensorMeasuredDataReply) {\n+            reply = readReply();\n+        }\n+        return reply;\n+    }\n+\n+    private boolean setWorkingPeriod(byte period) throws IOException {\n+        CommandMessage m = new CommandMessage(Command.WORKING_PERIOD, new byte[] { Constants.SET_ACTION, period });\n+        logger.debug(\"Sending work period: {}\", period);\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to setWorkingPeriod command: {}\", reply);\n+        if (reply instanceof WorkingPeriodReply) {\n+            WorkingPeriodReply wpReply = (WorkingPeriodReply) reply;\n+            if (wpReply.getPeriod() == period && wpReply.getActionType() == Constants.SET_ACTION) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean setMode(WorkMode workMode) throws IOException {\n+        byte haveToRequestData = 0;\n+        if (workMode == WorkMode.POLLING) {\n+            haveToRequestData = 1;\n+        }\n+\n+        CommandMessage m = new CommandMessage(Command.MODE, new byte[] { Constants.SET_ACTION, haveToRequestData });\n+        logger.debug(\"Sending mode: {}\", workMode);\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to setMode command: {}\", reply);\n+        if (reply instanceof ModeReply) {\n+            ModeReply mr = (ModeReply) reply;\n+            if (mr.getActionType() == Constants.SET_ACTION && mr.getMode() == workMode) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean sendSleep(boolean doSleep) throws IOException {\n+        byte payload = (byte) 1;\n+        if (doSleep) {\n+            payload = (byte) 0;\n+        }\n+\n+        CommandMessage m = new CommandMessage(Command.SLEEP, new byte[] { Constants.SET_ACTION, payload });\n+        logger.debug(\"Sending doSleep: {}\", doSleep);\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to sendSleep command: {}\", reply);\n+\n+        if (!doSleep) {\n+            // sometimes the sensor does not wakeup on the first attempt, thus we try again\n+            for (int i = 0; reply == null && i < 3; i++) {\n+                reply = sendCommand(m);\n+                logger.debug(\"Got reply to sendSleep command after retry#{}: {}\", i + 1, reply);\n+            }\n+        }\n+\n+        if (reply instanceof SleepReply) {\n+            SleepReply sr = (SleepReply) reply;\n+            if (sr.getActionType() == Constants.SET_ACTION && sr.getSleep() == payload) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean getFirmware() throws IOException {\n+        CommandMessage m = new CommandMessage(Command.FIRMWARE, new byte[] {});\n+        logger.debug(\"Sending get firmware request\");\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to getFirmware command: {}\", reply);\n+\n+        if (reply instanceof SensorFirmwareReply) {\n+            SensorFirmwareReply fwReply = (SensorFirmwareReply) reply;\n+            thingHandler.setFirmware(fwReply.getFirmware());\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Request data from the device, they will be returned via the serialEvent callback\n+     *\n+     * @throws IOException\n+     */\n+    public void requestSensorData() throws IOException {\n+        CommandMessage m = new CommandMessage(Command.REQUEST_DATA, new byte[] {});\n+        byte[] data = m.getBytes();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Requesting sensor data, will send: {}\", HexUtils.bytesToHex(data));\n+        }\n+        outputStream.write(data, 0, data.length);\n+    }\n+\n+    private @Nullable SensorReply readReply() throws IOException {\n+        byte[] readBuffer = new byte[Constants.REPLY_LENGTH];\n+\n+        int b = -1;\n+        if (inputStream.available() > 0) {\n+            while ((b = inputStream.read()) != Constants.MESSAGE_START_AS_INT) {\n+                logger.debug(\"Trying to find first reply byte now...\");\n+            }\n+            readBuffer[0] = (byte) b;\n+            int remainingBytesRead = inputStream.read(readBuffer, 1, Constants.REPLY_LENGTH - 1);\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Read remaining bytes: {}, full reply={}\", remainingBytesRead,\n+                        HexUtils.bytesToHex(readBuffer));\n+            }\n+            return ReplyFactory.create(readBuffer);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Data from the device is arriving and will be parsed accordingly\n+     */\n+    @Override\n+    public void serialEvent(SerialPortEvent event) {\n+        if (event.getEventType() == SerialPortEvent.DATA_AVAILABLE) {\n+            // we get here if data has been received\n+            SensorReply reply = null;\n+            try {\n+                reply = readReply();\n+                logger.debug(\"Got data from sensor: {}\", reply);\n+            } catch (IOException e) {\n+                logger.warn(\"Could not read available data from the serial port: {}\", e.getMessage());\n+            }\n+            if (reply instanceof SensorMeasuredDataReply) {\n+                SensorMeasuredDataReply sensorData = (SensorMeasuredDataReply) reply;\n+                if (sensorData.isValidData()) {\n+                    thingHandler.updateChannels(sensorData);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Shutdown the communication, i.e. send the device to sleep and close the serial port\n+     */\n+    public void dispose() {\n+        if (serialPort != null) {\n+            try {\n+                // send the device to sleep to preserve power and extend the lifetime of the sensor\n+                sendSleep(true);", "originalCommit": "3b594394ec2080ca6bb8de2fd3710720612a5d20", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI0Nzc4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r431247786", "bodyText": "I tried this before, but somehow the underlieing library does something with the port if I de-register my listener and then my command doesn't go through.\nThis is just a guess from my observation. That is why I did not de-register the listener before that call here.\nAlso in the callback method for the listener I check for valid data, so it doesn't matter if the callback receives the reply to the sleep on shutdown.", "author": "t2000", "createdAt": "2020-05-27T15:48:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc1ODcwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc1OTk5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r430759991", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    outputStream.write(commandData, 0, commandData.length);\n          \n          \n            \n                    outputStream.write(commandData);", "author": "cpmeister", "createdAt": "2020-05-26T23:22:15Z", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.TooManyListenersException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.SDS011Handler;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.CommandMessage;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.Constants;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.ModeReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorFirmwareReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SleepReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.WorkingPeriodReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Central instance to communicate with the device, i.e. receive data from it and send commands to it\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SDS011Communicator implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Communicator.class);\n+\n+    private SerialPortIdentifier portId;\n+    private SDS011Handler thingHandler;\n+    private @NonNullByDefault({}) SerialPort serialPort;\n+\n+    private @Nullable OutputStream outputStream;\n+    private @Nullable InputStream inputStream;\n+\n+    public SDS011Communicator(SDS011Handler thingHandler, SerialPortIdentifier portId) {\n+        this.thingHandler = thingHandler;\n+        this.portId = portId;\n+    }\n+\n+    /**\n+     * Initialize the communication with the device, i.e. open the serial port etc.\n+     *\n+     * @param mode the {@link WorkMode} if we want to use polling or reporting\n+     * @param interval the time between polling or reportings\n+     * @return {@code true} if we can communicate with the device\n+     * @throws PortInUseException\n+     * @throws TooManyListenersException\n+     * @throws IOException\n+     * @throws UnsupportedCommOperationException\n+     */\n+    public boolean initialize(WorkMode mode, Duration interval)\n+            throws PortInUseException, TooManyListenersException, IOException, UnsupportedCommOperationException {\n+        boolean initSuccessful = true;\n+\n+        SerialPort localSerialPort = portId.open(thingHandler.getThing().getUID().toString(), 2000);\n+        localSerialPort.setSerialPortParams(9600, 8, 1, 0);\n+\n+        outputStream = localSerialPort.getOutputStream();\n+        inputStream = localSerialPort.getInputStream();\n+\n+        if (inputStream == null || outputStream == null) {\n+            throw new IOException(\"Could not create input or outputstream for the port\");\n+        }\n+\n+        // wake up the device\n+        initSuccessful &= sendSleep(false);\n+        initSuccessful &= getFirmware();\n+\n+        if (mode == WorkMode.POLLING) {\n+            initSuccessful &= setMode(WorkMode.POLLING);\n+            initSuccessful &= setWorkingPeriod((byte) 0);\n+        } else {\n+            // reporting\n+            initSuccessful &= setWorkingPeriod((byte) interval.toMinutes());\n+            initSuccessful &= setMode(WorkMode.REPORTING);\n+        }\n+\n+        // enable listeners only after we have configured the sensor above because for configuring we send and read data\n+        // sequentially\n+        localSerialPort.notifyOnDataAvailable(true);\n+        localSerialPort.addEventListener(this);\n+        this.serialPort = localSerialPort;\n+\n+        return initSuccessful;\n+    }\n+\n+    private @Nullable SensorReply sendCommand(CommandMessage message) throws IOException {\n+        byte[] commandData = message.getBytes();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Will send command: {} ({})\", HexUtils.bytesToHex(commandData), Arrays.toString(commandData));\n+        }\n+        outputStream.write(commandData, 0, commandData.length);", "originalCommit": "3b594394ec2080ca6bb8de2fd3710720612a5d20", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc2MDA5OA==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r430760098", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    outputStream.write(data, 0, data.length);\n          \n          \n            \n                    outputStream.write(data);\n          \n          \n            \n                    outputStream.flush();", "author": "cpmeister", "createdAt": "2020-05-26T23:22:33Z", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.TooManyListenersException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.SDS011Handler;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.CommandMessage;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.Constants;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.ModeReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorFirmwareReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SleepReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.WorkingPeriodReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Central instance to communicate with the device, i.e. receive data from it and send commands to it\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SDS011Communicator implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Communicator.class);\n+\n+    private SerialPortIdentifier portId;\n+    private SDS011Handler thingHandler;\n+    private @NonNullByDefault({}) SerialPort serialPort;\n+\n+    private @Nullable OutputStream outputStream;\n+    private @Nullable InputStream inputStream;\n+\n+    public SDS011Communicator(SDS011Handler thingHandler, SerialPortIdentifier portId) {\n+        this.thingHandler = thingHandler;\n+        this.portId = portId;\n+    }\n+\n+    /**\n+     * Initialize the communication with the device, i.e. open the serial port etc.\n+     *\n+     * @param mode the {@link WorkMode} if we want to use polling or reporting\n+     * @param interval the time between polling or reportings\n+     * @return {@code true} if we can communicate with the device\n+     * @throws PortInUseException\n+     * @throws TooManyListenersException\n+     * @throws IOException\n+     * @throws UnsupportedCommOperationException\n+     */\n+    public boolean initialize(WorkMode mode, Duration interval)\n+            throws PortInUseException, TooManyListenersException, IOException, UnsupportedCommOperationException {\n+        boolean initSuccessful = true;\n+\n+        SerialPort localSerialPort = portId.open(thingHandler.getThing().getUID().toString(), 2000);\n+        localSerialPort.setSerialPortParams(9600, 8, 1, 0);\n+\n+        outputStream = localSerialPort.getOutputStream();\n+        inputStream = localSerialPort.getInputStream();\n+\n+        if (inputStream == null || outputStream == null) {\n+            throw new IOException(\"Could not create input or outputstream for the port\");\n+        }\n+\n+        // wake up the device\n+        initSuccessful &= sendSleep(false);\n+        initSuccessful &= getFirmware();\n+\n+        if (mode == WorkMode.POLLING) {\n+            initSuccessful &= setMode(WorkMode.POLLING);\n+            initSuccessful &= setWorkingPeriod((byte) 0);\n+        } else {\n+            // reporting\n+            initSuccessful &= setWorkingPeriod((byte) interval.toMinutes());\n+            initSuccessful &= setMode(WorkMode.REPORTING);\n+        }\n+\n+        // enable listeners only after we have configured the sensor above because for configuring we send and read data\n+        // sequentially\n+        localSerialPort.notifyOnDataAvailable(true);\n+        localSerialPort.addEventListener(this);\n+        this.serialPort = localSerialPort;\n+\n+        return initSuccessful;\n+    }\n+\n+    private @Nullable SensorReply sendCommand(CommandMessage message) throws IOException {\n+        byte[] commandData = message.getBytes();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Will send command: {} ({})\", HexUtils.bytesToHex(commandData), Arrays.toString(commandData));\n+        }\n+        outputStream.write(commandData, 0, commandData.length);\n+        outputStream.flush();\n+        try {\n+            // Give the sensor some time to handle the command\n+            Thread.sleep(500);\n+        } catch (InterruptedException e) {\n+            logger.warn(\"Problem while waiting for reading a reply to our command.\");\n+            Thread.currentThread().interrupt();\n+        }\n+        SensorReply reply = readReply();\n+        // in case there is still another reporting active, we want to discard the sensor data and read the reply to our\n+        // command again\n+        if (reply instanceof SensorMeasuredDataReply) {\n+            reply = readReply();\n+        }\n+        return reply;\n+    }\n+\n+    private boolean setWorkingPeriod(byte period) throws IOException {\n+        CommandMessage m = new CommandMessage(Command.WORKING_PERIOD, new byte[] { Constants.SET_ACTION, period });\n+        logger.debug(\"Sending work period: {}\", period);\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to setWorkingPeriod command: {}\", reply);\n+        if (reply instanceof WorkingPeriodReply) {\n+            WorkingPeriodReply wpReply = (WorkingPeriodReply) reply;\n+            if (wpReply.getPeriod() == period && wpReply.getActionType() == Constants.SET_ACTION) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean setMode(WorkMode workMode) throws IOException {\n+        byte haveToRequestData = 0;\n+        if (workMode == WorkMode.POLLING) {\n+            haveToRequestData = 1;\n+        }\n+\n+        CommandMessage m = new CommandMessage(Command.MODE, new byte[] { Constants.SET_ACTION, haveToRequestData });\n+        logger.debug(\"Sending mode: {}\", workMode);\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to setMode command: {}\", reply);\n+        if (reply instanceof ModeReply) {\n+            ModeReply mr = (ModeReply) reply;\n+            if (mr.getActionType() == Constants.SET_ACTION && mr.getMode() == workMode) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean sendSleep(boolean doSleep) throws IOException {\n+        byte payload = (byte) 1;\n+        if (doSleep) {\n+            payload = (byte) 0;\n+        }\n+\n+        CommandMessage m = new CommandMessage(Command.SLEEP, new byte[] { Constants.SET_ACTION, payload });\n+        logger.debug(\"Sending doSleep: {}\", doSleep);\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to sendSleep command: {}\", reply);\n+\n+        if (!doSleep) {\n+            // sometimes the sensor does not wakeup on the first attempt, thus we try again\n+            for (int i = 0; reply == null && i < 3; i++) {\n+                reply = sendCommand(m);\n+                logger.debug(\"Got reply to sendSleep command after retry#{}: {}\", i + 1, reply);\n+            }\n+        }\n+\n+        if (reply instanceof SleepReply) {\n+            SleepReply sr = (SleepReply) reply;\n+            if (sr.getActionType() == Constants.SET_ACTION && sr.getSleep() == payload) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean getFirmware() throws IOException {\n+        CommandMessage m = new CommandMessage(Command.FIRMWARE, new byte[] {});\n+        logger.debug(\"Sending get firmware request\");\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to getFirmware command: {}\", reply);\n+\n+        if (reply instanceof SensorFirmwareReply) {\n+            SensorFirmwareReply fwReply = (SensorFirmwareReply) reply;\n+            thingHandler.setFirmware(fwReply.getFirmware());\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Request data from the device, they will be returned via the serialEvent callback\n+     *\n+     * @throws IOException\n+     */\n+    public void requestSensorData() throws IOException {\n+        CommandMessage m = new CommandMessage(Command.REQUEST_DATA, new byte[] {});\n+        byte[] data = m.getBytes();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Requesting sensor data, will send: {}\", HexUtils.bytesToHex(data));\n+        }\n+        outputStream.write(data, 0, data.length);", "originalCommit": "3b594394ec2080ca6bb8de2fd3710720612a5d20", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9ffd0c160059738fff9299756eeb48e25f349c93", "url": "https://github.com/openhab/openhab-addons/commit/9ffd0c160059738fff9299756eeb48e25f349c93", "message": "Address further review comments\n\nSigned-off-by: Stefan Triller <github@stefantriller.de>", "committedDate": "2020-05-27T15:46:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM0MjAyMw==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r431342023", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private byte actionType;\n          \n          \n            \n                private WorkMode mode;\n          \n          \n            \n                private final byte actionType;\n          \n          \n            \n                private final WorkMode mode;", "author": "cpmeister", "createdAt": "2020-05-27T18:04:41Z", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/messages/ModeReply.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol.messages;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+\n+/**\n+ * Reply from sensor to a set mode command\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class ModeReply extends SensorReply {\n+\n+    private byte actionType;\n+    private WorkMode mode;", "originalCommit": "9ffd0c160059738fff9299756eeb48e25f349c93", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM0MjMwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r431342309", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private byte actionType;\n          \n          \n            \n                private byte sleep;\n          \n          \n            \n                private final byte actionType;\n          \n          \n            \n                private final byte sleep;", "author": "cpmeister", "createdAt": "2020-05-27T18:05:10Z", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/messages/SleepReply.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol.messages;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Reply from sensor to a set sleep command\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SleepReply extends SensorReply {\n+\n+    private byte actionType;\n+    private byte sleep;", "originalCommit": "9ffd0c160059738fff9299756eeb48e25f349c93", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM0MjUzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r431342531", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private byte year;\n          \n          \n            \n                private byte month;\n          \n          \n            \n                private byte day;\n          \n          \n            \n                private final byte year;\n          \n          \n            \n                private final byte month;\n          \n          \n            \n                private final byte day;", "author": "cpmeister", "createdAt": "2020-05-27T18:05:34Z", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/messages/SensorFirmwareReply.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol.messages;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Data from the sensor containing information about the installed firmware\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SensorFirmwareReply extends SensorReply {\n+\n+    private byte year;\n+    private byte month;\n+    private byte day;", "originalCommit": "9ffd0c160059738fff9299756eeb48e25f349c93", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM0Mjc4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r431342787", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private byte actionType;\n          \n          \n            \n                private byte period;\n          \n          \n            \n                private final byte actionType;\n          \n          \n            \n                private final byte period;", "author": "cpmeister", "createdAt": "2020-05-27T18:06:01Z", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/messages/WorkingPeriodReply.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol.messages;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Reply from sensor to a set working period command\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class WorkingPeriodReply extends SensorReply {\n+\n+    private byte actionType;\n+    private byte period;", "originalCommit": "9ffd0c160059738fff9299756eeb48e25f349c93", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "57ed8c622051f16ef63902c4af6a810b1908ee83", "url": "https://github.com/openhab/openhab-addons/commit/57ed8c622051f16ef63902c4af6a810b1908ee83", "message": "Addressed further review comments\n\nSigned-off-by: Stefan Triller <github@stefantriller.de>", "committedDate": "2020-05-27T21:22:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE1ODk5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r432158993", "bodyText": "Either make this nullable or initialize it to some default configuration.", "author": "cpmeister", "createdAt": "2020-05-28T22:28:20Z", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) NovaFineDustConfiguration config;", "originalCommit": "57ed8c622051f16ef63902c4af6a810b1908ee83", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE1OTMyOA==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r432159328", "bodyText": "Please make this nullable. I've had times in my own bindings that this ended up null unexpectedly.", "author": "cpmeister", "createdAt": "2020-05-28T22:29:13Z", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) NovaFineDustConfiguration config;\n+    private @NonNullByDefault({}) SDS011Communicator communicator;", "originalCommit": "57ed8c622051f16ef63902c4af6a810b1908ee83", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "36cfe9f558a43f29e09c5da567dc9c0f3479d728", "url": "https://github.com/openhab/openhab-addons/commit/36cfe9f558a43f29e09c5da567dc9c0f3479d728", "message": "More review comments\n\nSigned-off-by: Stefan Triller <github@stefantriller.de>", "committedDate": "2020-05-29T06:49:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4Mjg0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r432882841", "bodyText": "To avoid null issues with the configs, you can change your config to be non-null and just populate the config with an instance that contains default values:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @Nullable NovaFineDustConfiguration config;\n          \n          \n            \n                private NovaFineDustConfiguration config = new NovaFineDustConfiguration();", "author": "cpmeister", "createdAt": "2020-05-30T20:03:13Z", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @Nullable NovaFineDustConfiguration config;", "originalCommit": "36cfe9f558a43f29e09c5da567dc9c0f3479d728", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MzA3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r432883079", "bodyText": "Please don't use @NonNullByDefault({}) if possible.", "author": "cpmeister", "createdAt": "2020-05-30T20:06:37Z", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.TooManyListenersException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.SDS011Handler;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.CommandMessage;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.Constants;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.ModeReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorFirmwareReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SleepReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.WorkingPeriodReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Central instance to communicate with the device, i.e. receive data from it and send commands to it\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SDS011Communicator implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Communicator.class);\n+\n+    private SerialPortIdentifier portId;\n+    private SDS011Handler thingHandler;\n+    private @NonNullByDefault({}) SerialPort serialPort;", "originalCommit": "36cfe9f558a43f29e09c5da567dc9c0f3479d728", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MzI4MA==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r432883280", "bodyText": "If you want another way to get around the null checks. You could make these fields get populated from the constructor so you could make them non-null and final.\nYou would then turn your initialize method into a static factory method for SDS011Communicator instances.", "author": "cpmeister", "createdAt": "2020-05-30T20:09:30Z", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.TooManyListenersException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.SDS011Handler;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.CommandMessage;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.Constants;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.ModeReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorFirmwareReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SleepReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.WorkingPeriodReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Central instance to communicate with the device, i.e. receive data from it and send commands to it\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SDS011Communicator implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Communicator.class);\n+\n+    private SerialPortIdentifier portId;\n+    private SDS011Handler thingHandler;\n+    private @NonNullByDefault({}) SerialPort serialPort;\n+\n+    private @Nullable OutputStream outputStream;\n+    private @Nullable InputStream inputStream;", "originalCommit": "36cfe9f558a43f29e09c5da567dc9c0f3479d728", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkzMjk1OA==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r432932958", "bodyText": "I'd rather structure my code in a way that makes it look clean, i.e. in this case having the serial port and the streams within one object, rather than splitting this throughout the code just to make an analysis tool happy.\nI have made the null checks now...", "author": "t2000", "createdAt": "2020-05-31T10:37:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MzI4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4NDk4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r432884983", "bodyText": "Another example here of how to easily deal with the null warnings.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (pollingJob != null) {\n          \n          \n            \n                        pollingJob.cancel(true);\n          \n          \n            \n                        pollingJob = null;\n          \n          \n            \n                    }\n          \n          \n            \n                    Future<?> pollingJob = this.pollingJob;\n          \n          \n            \n                    if (pollingJob != null) {\n          \n          \n            \n                        pollingJob.cancel(true);\n          \n          \n            \n                        this.pollingJob = null;\n          \n          \n            \n                    }", "author": "cpmeister", "createdAt": "2020-05-30T20:28:30Z", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @Nullable NovaFineDustConfiguration config;\n+    private @Nullable SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private ZonedDateTime lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTolerance = Duration.ofSeconds(5);\n+\n+    // cached values fro refresh command\n+    private State statePM10 = UnDefType.UNDEF;\n+    private State statePM25 = UnDefType.UNDEF;\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // refresh channels with last received values from cache\n+        if (RefreshType.REFRESH.equals(command)) {\n+            if (NovaFineDustBindingConstants.CHANNEL_PM25.equals(channelUID.getId()) && statePM25 != UnDefType.UNDEF) {\n+                updateState(NovaFineDustBindingConstants.CHANNEL_PM25, statePM25);\n+            }\n+            if (NovaFineDustBindingConstants.CHANNEL_PM10.equals(channelUID.getId()) && statePM10 != UnDefType.UNDEF) {\n+                updateState(NovaFineDustBindingConstants.CHANNEL_PM10, statePM10);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            timeBetweenDataShouldArrive = Duration.ofSeconds(config.pollingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        }\n+\n+        Duration connectionMonitorStartDelay = timeBetweenDataShouldArrive.plus(CONNECTION_MONITOR_START_DELAY_OFFSET);\n+        connectionMonitor = scheduler.scheduleWithFixedDelay(this::verifyIfStillConnected,\n+                connectionMonitorStartDelay.getSeconds(), timeBetweenDataShouldArrive.getSeconds(), TimeUnit.SECONDS);\n+    }\n+\n+    private void initializeCommunicator(WorkMode mode, Duration interval) {\n+        boolean initSuccessful = false;\n+        try {\n+            initSuccessful = communicator.initialize(mode, interval);\n+        } catch (final IOException ex) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            return;\n+        } catch (PortInUseException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            return;\n+        } catch (TooManyListenersException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot attach listener to port!\");\n+            return;\n+        } catch (UnsupportedCommOperationException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot set serial port parameters\");\n+            return;\n+        }\n+\n+        if (initSuccessful) {\n+            lastCommunication = ZonedDateTime.now();\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            if (mode == WorkMode.POLLING) {\n+                pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        communicator.requestSensorData();\n+                    } catch (IOException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                                \"Cannot query data from device\");\n+                    }\n+                }, 2, config.pollingInterval, TimeUnit.SECONDS);\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Commands and replies from the device don't seem to match\");\n+            logger.debug(\"Could not configure sensor -> setting Thing to OFFLINE and disposing the handler\");\n+            dispose();\n+        }\n+    }\n+\n+    private boolean validateConfiguration() {\n+        if (config == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Configuration could not be parsed\");\n+            return false;\n+        }\n+\n+        if (config.port == null || config.port.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return false;\n+        }\n+        if (config.reporting) {\n+            if (config.reportingInterval < 0 || config.reportingInterval > 30) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Reporting interval has to be between 0 and 30 minutes\");\n+                return false;\n+            }\n+        } else {\n+            if (config.pollingInterval < 3 || config.pollingInterval > 3600) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Polling interval has to be between 3 and 3600 seconds\");\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (pollingJob != null) {\n+            pollingJob.cancel(true);\n+            pollingJob = null;\n+        }", "originalCommit": "36cfe9f558a43f29e09c5da567dc9c0f3479d728", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkzMjk2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r432932962", "bodyText": "My IDE wasn't even showing this warning.\nSo to me it looks like the IDE checks and the build checks are not in sync. There was even a build failure in travis (a couple of commits back) which was fine in eclipse.\nAlso If you insists of dealing with these warnings, I would recommend to make them errors, not warnings, so the build will fail direclty.\nOne side note:\nIf you implement is as you suggested, you will hide the class variable pollingJob with the local variable with the same name and this is a bad code style which can lead to errors. Even Sonoarlint marks this as something that should be changed.", "author": "t2000", "createdAt": "2020-05-31T10:38:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4NDk4Mw=="}], "type": "inlineReview"}, {"oid": "e685099b38e6dda40cf3326a1182d394983790ac", "url": "https://github.com/openhab/openhab-addons/commit/e685099b38e6dda40cf3326a1182d394983790ac", "message": "Make null analysis happy\n\nSigned-off-by: Stefan Triller <github@stefantriller.de>", "committedDate": "2020-05-31T10:37:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM5MjYwOA==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r433392608", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n          \n          \n            \n                                TimeUnit.SECONDS);\n          \n          \n            \n                        scheduler.submit(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive));", "author": "cpmeister", "createdAt": "2020-06-01T17:52:13Z", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private NovaFineDustConfiguration config = new NovaFineDustConfiguration();\n+    private @Nullable SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private ZonedDateTime lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTolerance = Duration.ofSeconds(5);\n+\n+    // cached values for refresh command\n+    private State statePM10 = UnDefType.UNDEF;\n+    private State statePM25 = UnDefType.UNDEF;\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // refresh channels with last received values from cache\n+        if (RefreshType.REFRESH.equals(command)) {\n+            if (NovaFineDustBindingConstants.CHANNEL_PM25.equals(channelUID.getId()) && statePM25 != UnDefType.UNDEF) {\n+                updateState(NovaFineDustBindingConstants.CHANNEL_PM25, statePM25);\n+            }\n+            if (NovaFineDustBindingConstants.CHANNEL_PM10.equals(channelUID.getId()) && statePM10 != UnDefType.UNDEF) {\n+                updateState(NovaFineDustBindingConstants.CHANNEL_PM10, statePM10);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);", "originalCommit": "e685099b38e6dda40cf3326a1182d394983790ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM5MjcwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r433392701", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n          \n          \n            \n                                TimeUnit.SECONDS);\n          \n          \n            \n                        scheduler.submit(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive));", "author": "cpmeister", "createdAt": "2020-06-01T17:52:26Z", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private NovaFineDustConfiguration config = new NovaFineDustConfiguration();\n+    private @Nullable SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private ZonedDateTime lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTolerance = Duration.ofSeconds(5);\n+\n+    // cached values for refresh command\n+    private State statePM10 = UnDefType.UNDEF;\n+    private State statePM25 = UnDefType.UNDEF;\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // refresh channels with last received values from cache\n+        if (RefreshType.REFRESH.equals(command)) {\n+            if (NovaFineDustBindingConstants.CHANNEL_PM25.equals(channelUID.getId()) && statePM25 != UnDefType.UNDEF) {\n+                updateState(NovaFineDustBindingConstants.CHANNEL_PM25, statePM25);\n+            }\n+            if (NovaFineDustBindingConstants.CHANNEL_PM10.equals(channelUID.getId()) && statePM10 != UnDefType.UNDEF) {\n+                updateState(NovaFineDustBindingConstants.CHANNEL_PM10, statePM10);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            timeBetweenDataShouldArrive = Duration.ofSeconds(config.pollingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);", "originalCommit": "e685099b38e6dda40cf3326a1182d394983790ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM5NTMzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r433395331", "bodyText": "Just to be safe, I would make sure that initialize, dispose, and initializeCommunicator are synchronized.", "author": "cpmeister", "createdAt": "2020-06-01T17:57:17Z", "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private NovaFineDustConfiguration config = new NovaFineDustConfiguration();\n+    private @Nullable SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private ZonedDateTime lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTolerance = Duration.ofSeconds(5);\n+\n+    // cached values for refresh command\n+    private State statePM10 = UnDefType.UNDEF;\n+    private State statePM25 = UnDefType.UNDEF;\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // refresh channels with last received values from cache\n+        if (RefreshType.REFRESH.equals(command)) {\n+            if (NovaFineDustBindingConstants.CHANNEL_PM25.equals(channelUID.getId()) && statePM25 != UnDefType.UNDEF) {\n+                updateState(NovaFineDustBindingConstants.CHANNEL_PM25, statePM25);\n+            }\n+            if (NovaFineDustBindingConstants.CHANNEL_PM10.equals(channelUID.getId()) && statePM10 != UnDefType.UNDEF) {\n+                updateState(NovaFineDustBindingConstants.CHANNEL_PM10, statePM10);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            timeBetweenDataShouldArrive = Duration.ofSeconds(config.pollingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        }\n+\n+        Duration connectionMonitorStartDelay = timeBetweenDataShouldArrive.plus(CONNECTION_MONITOR_START_DELAY_OFFSET);\n+        connectionMonitor = scheduler.scheduleWithFixedDelay(this::verifyIfStillConnected,\n+                connectionMonitorStartDelay.getSeconds(), timeBetweenDataShouldArrive.getSeconds(), TimeUnit.SECONDS);\n+    }\n+\n+    private void initializeCommunicator(WorkMode mode, Duration interval) {", "originalCommit": "e685099b38e6dda40cf3326a1182d394983790ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA5ODY4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r434098687", "bodyText": "How should I do that? This won't work if I write synchronized on those methods.\nThe reason is that this will synchronize of the \u00b4ThingHandlerobject and this is never the same is adisposeand aninitializeare called.  TheThingManagerwill always create a newThingHandlerinstance before callinginitialize, so the call to dispose` will happen on a different (old) object.\nThis is what I wanted to state earlier: The openHAB framework currently does NOT ensure that dispose and initialize run into each other, if one is forced to schedule a task (that runs in a different thread) from initialize if one needs more than 5 seconds.\nSo either: I do NOT schedule this task and risk the warning \"ThingHandler initialize takes longer than 5 seconds\", or I take the (in my case pretty unlikely) risk that dispose and initialize collide eventually.\nSo which option should I pick?", "author": "t2000", "createdAt": "2020-06-02T18:39:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM5NTMzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEyNDc2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r434124767", "bodyText": "@J-N-K Could you please weigh in here? I can't tell if I'm being overly concerned or not with regards to thread safety here.", "author": "cpmeister", "createdAt": "2020-06-02T19:26:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM5NTMzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE1MjU2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r434152567", "bodyText": "I can chime in here. We never have synchronized keywords on such methods. As @t2000 mentions, the work is done in a separate thread and it is actually intended that the framework is able to dispose the handler, while such jobs might still be running. They should NOT block a call of dispose, so synchronizing it would be counter-productive.", "author": "kaikreuzer", "createdAt": "2020-06-02T20:20:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM5NTMzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2MzE3MA==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r434163170", "bodyText": "@kaikreuzer I'm just concerned that initializeCommunicator would be called after dispose since initializeCommunicator is called asynchronously.", "author": "cpmeister", "createdAt": "2020-06-02T20:41:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM5NTMzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE3NjIyNA==", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r434176224", "bodyText": "Sounds pretty unlikely and even if it does, the code should be written in a way that it shouldn't harm much.\nIf dispose would set the communicator to null and initializeCommunicator would not try to set the Thing status upon a null-communicator, it should almost be safe ;-)", "author": "kaikreuzer", "createdAt": "2020-06-02T21:08:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM5NTMzMQ=="}], "type": "inlineReview"}, {"oid": "d94ddb4ba25efe4248d2a174b64f1be2db773484", "url": "https://github.com/openhab/openhab-addons/commit/d94ddb4ba25efe4248d2a174b64f1be2db773484", "message": "Small review changes\n\nSigned-off-by: Stefan Triller <github@stefantriller.de>", "committedDate": "2020-06-02T18:34:46Z", "type": "commit"}, {"oid": "00642f2333a2ad2766f8a29175e21ba142b3beca", "url": "https://github.com/openhab/openhab-addons/commit/00642f2333a2ad2766f8a29175e21ba142b3beca", "message": "Apply suggestions from code review\n\nThanks Kai for your suggestions, I have accepted them all and will take care of the few others in an additional commit.\n\nCo-authored-by: Kai Kreuzer <kai@openhab.org>\nSigned-off-by: Stefan Triller <github@stefantriller.de>", "committedDate": "2020-06-14T09:49:13Z", "type": "commit"}, {"oid": "00642f2333a2ad2766f8a29175e21ba142b3beca", "url": "https://github.com/openhab/openhab-addons/commit/00642f2333a2ad2766f8a29175e21ba142b3beca", "message": "Apply suggestions from code review\n\nThanks Kai for your suggestions, I have accepted them all and will take care of the few others in an additional commit.\n\nCo-authored-by: Kai Kreuzer <kai@openhab.org>\nSigned-off-by: Stefan Triller <github@stefantriller.de>", "committedDate": "2020-06-14T09:49:13Z", "type": "forcePushed"}, {"oid": "4abf72848a9ffffb7e922053865ccb11260c113b", "url": "https://github.com/openhab/openhab-addons/commit/4abf72848a9ffffb7e922053865ccb11260c113b", "message": "README clarifications\n\nSigned-off-by: Stefan Triller <github@stefantriller.de>", "committedDate": "2020-06-14T09:57:09Z", "type": "commit"}]}